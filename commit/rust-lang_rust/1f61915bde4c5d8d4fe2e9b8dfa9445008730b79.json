{"sha": "1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNjE5MTViZGU0YzVkOGQ0ZmUyZTliOGRmYTk0NDUwMDg3MzBiNzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-21T12:50:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-21T12:50:12Z"}, "message": "Merge #2337\n\n2337: Move resolver to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a6fd0b6ad8b6c87d28e6e1b36bb9b2fbae2c1b09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6fd0b6ad8b6c87d28e6e1b36bb9b2fbae2c1b09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1ogECRBK7hj4Ov3rIwAAdHIIAI2+XArO8PEVplky4Unvrx7Y\nbN0M5eMIcIFixtqLMR7JyUM+Dq6o5rJm1AaHWGsVQuyO3j3uAOwGpSmeVVpb3Reg\n4YT3mAEMi/e801L9kZ2AdvAvoka8EfOjvZ9ydv9ILsb977BMbvbrm3DIQuu1tfwa\nvJIgVA3XT/bioipZ3X8dQwcfGYP3fIBvOz5gIJF810WzCxU9Nse8Uj8P9r7jMenD\nqbVr6siR1lUydDqI1bdTG/Wwh1lgaXUPMXXMs5q6KsI1TxG0N42E8l8PARhVjNgs\nWugEyp7KEtUJTbpIdQMkL3BXy8qOAD6nMf7WAVyxIMkayK31RsJuGfb819/SQlA=\n=qp8r\n-----END PGP SIGNATURE-----\n", "payload": "tree a6fd0b6ad8b6c87d28e6e1b36bb9b2fbae2c1b09\nparent 612a72fc4ea4376920f2a7da7b3c334227c1716c\nparent c37d1c5b381365ce2d07dfe4b871e43995ccea2d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574340612 +0000\ncommitter GitHub <noreply@github.com> 1574340612 +0000\n\nMerge #2337\n\n2337: Move resolver to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "html_url": "https://github.com/rust-lang/rust/commit/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "612a72fc4ea4376920f2a7da7b3c334227c1716c", "url": "https://api.github.com/repos/rust-lang/rust/commits/612a72fc4ea4376920f2a7da7b3c334227c1716c", "html_url": "https://github.com/rust-lang/rust/commit/612a72fc4ea4376920f2a7da7b3c334227c1716c"}, {"sha": "c37d1c5b381365ce2d07dfe4b871e43995ccea2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c37d1c5b381365ce2d07dfe4b871e43995ccea2d", "html_url": "https://github.com/rust-lang/rust/commit/c37d1c5b381365ce2d07dfe4b871e43995ccea2d"}], "stats": {"total": 820, "additions": 493, "deletions": 327}, "files": [{"sha": "92860fb598db3ee057516c51c4998fc0edda5953", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -10,10 +10,12 @@ use hir_def::{\n     adt::VariantData,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n+    nameres::per_ns::PerNs,\n+    resolver::{HasResolver, TypeNs},\n     traits::TraitData,\n     type_ref::{Mutability, TypeRef},\n-    AssocItemId, ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalStructFieldId, Lookup, ModuleId, UnionId,\n+    ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalStructFieldId, Lookup,\n+    ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -30,9 +32,8 @@ use crate::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n         TypeAliasId,\n     },\n-    resolve::{HasResolver, TypeNs},\n     ty::{InferenceResult, Namespace, TraitRef},\n-    Either, HasSource, ImportId, Name, ScopeDef, Source, Ty,\n+    Either, HasSource, ImportId, Name, Source, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -829,7 +830,7 @@ impl Trait {\n     }\n \n     fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        let resolver = self.resolver(db);\n+        let resolver = self.id.resolver(db);\n         // returning the iterator directly doesn't easily work because of\n         // lifetime problems, but since there usually shouldn't be more than a\n         // few direct traits this should be fine (we could even use some kind of\n@@ -842,9 +843,10 @@ impl Trait {\n                 _ => None,\n             })\n             .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n-                Some(TypeNs::Trait(t)) => Some(t),\n+                Some(TypeNs::TraitId(t)) => Some(t),\n                 _ => None,\n             })\n+            .map(Trait::from)\n             .collect()\n     }\n \n@@ -871,14 +873,9 @@ impl Trait {\n \n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = self.trait_data(db);\n-        trait_data\n-            .items\n-            .iter()\n-            .filter_map(|item| match item {\n-                AssocItemId::TypeAliasId(t) => Some(TypeAlias::from(*t)),\n-                _ => None,\n-            })\n-            .find(|t| &t.name(db) == name)\n+        let res =\n+            trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n+        Some(res)\n     }\n \n     pub fn associated_type_by_name_including_super_traits(\n@@ -1068,3 +1065,26 @@ pub struct GenericParam {\n pub struct ImplBlock {\n     pub(crate) id: ImplId,\n }\n+\n+/// For IDE only\n+pub enum ScopeDef {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+    GenericParam(GenericParam),\n+    ImplSelfType(ImplBlock),\n+    AdtSelfType(Adt),\n+    Local(Local),\n+    Unknown,\n+}\n+\n+impl From<PerNs> for ScopeDef {\n+    fn from(def: PerNs) -> Self {\n+        def.take_types()\n+            .or_else(|| def.take_values())\n+            .map(|module_def_id| ScopeDef::ModuleDef(module_def_id.into()))\n+            .or_else(|| {\n+                def.get_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n+            })\n+            .unwrap_or(ScopeDef::Unknown)\n+    }\n+}"}, {"sha": "6b703d8b4bed6ac1f7f85f8bcda1dc8f0bb872bb", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use hir_def::path::known;\n+use hir_def::{path::known, resolver::HasResolver};\n use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::ast;\n use ra_syntax::AstPtr;\n@@ -11,9 +11,8 @@ use rustc_hash::FxHashSet;\n use crate::{\n     db::HirDatabase,\n     diagnostics::{MissingFields, MissingOkInTailExpr},\n-    resolve::HasResolver,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Adt, DefWithBody, Function, HasBody, Name, Path, Resolver,\n+    Adt, Function, Name, Path,\n };\n \n pub use hir_def::{\n@@ -27,30 +26,6 @@ pub use hir_def::{\n     },\n };\n \n-// needs arbitrary_self_types to be a method... or maybe move to the def?\n-pub(crate) fn resolver_for_expr(\n-    db: &impl HirDatabase,\n-    owner: DefWithBody,\n-    expr_id: ExprId,\n-) -> Resolver {\n-    let scopes = owner.expr_scopes(db);\n-    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n-}\n-\n-pub(crate) fn resolver_for_scope(\n-    db: &impl HirDatabase,\n-    owner: DefWithBody,\n-    scope_id: Option<ScopeId>,\n-) -> Resolver {\n-    let mut r = owner.resolver(db);\n-    let scopes = owner.expr_scopes(db);\n-    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n-    for scope in scope_chain.into_iter().rev() {\n-        r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n-    }\n-    r\n-}\n-\n pub(crate) struct ExprValidator<'a, 'b: 'a> {\n     func: Function,\n     infer: Arc<InferenceResult>,\n@@ -146,13 +121,13 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let std_result_path = known::std_result_result();\n \n-        let resolver = self.func.resolver(db);\n+        let resolver = self.func.id.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n             Some(it) => it,\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n+        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum.into()));\n         let params = match &mismatch.expected {\n             Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n             _ => return,"}, {"sha": "a3e9d8525f2076bf86b1d6880cffe0d80761e727", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -3,9 +3,21 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId};\n+use hir_def::{\n+    AdtId, AssocItemId, ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n+    ModuleDefId, StaticId, StructId, TypeAliasId, UnionId,\n+};\n \n-use crate::{Adt, AssocItem, DefWithBody, EnumVariant, GenericDef, ModuleDef};\n+use crate::{\n+    ty::TypableDef, Adt, AssocItem, Const, Crate, DefWithBody, EnumVariant, Function, GenericDef,\n+    ModuleDef, Static, TypeAlias,\n+};\n+\n+impl From<ra_db::CrateId> for Crate {\n+    fn from(crate_id: ra_db::CrateId) -> Self {\n+        Crate { crate_id }\n+    }\n+}\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -83,6 +95,16 @@ impl From<DefWithBody> for DefWithBodyId {\n     }\n }\n \n+impl From<DefWithBodyId> for DefWithBody {\n+    fn from(def: DefWithBodyId) -> Self {\n+        match def {\n+            DefWithBodyId::FunctionId(it) => DefWithBody::Function(it.into()),\n+            DefWithBodyId::StaticId(it) => DefWithBody::Static(it.into()),\n+            DefWithBodyId::ConstId(it) => DefWithBody::Const(it.into()),\n+        }\n+    }\n+}\n+\n impl From<AssocItemId> for AssocItem {\n     fn from(def: AssocItemId) -> Self {\n         match def {\n@@ -122,3 +144,65 @@ impl From<GenericDefId> for GenericDef {\n         }\n     }\n }\n+\n+impl From<AdtId> for TypableDef {\n+    fn from(id: AdtId) -> Self {\n+        Adt::from(id).into()\n+    }\n+}\n+\n+impl From<StructId> for TypableDef {\n+    fn from(id: StructId) -> Self {\n+        AdtId::StructId(id).into()\n+    }\n+}\n+\n+impl From<UnionId> for TypableDef {\n+    fn from(id: UnionId) -> Self {\n+        AdtId::UnionId(id).into()\n+    }\n+}\n+\n+impl From<EnumId> for TypableDef {\n+    fn from(id: EnumId) -> Self {\n+        AdtId::EnumId(id).into()\n+    }\n+}\n+\n+impl From<EnumVariantId> for TypableDef {\n+    fn from(id: EnumVariantId) -> Self {\n+        EnumVariant::from(id).into()\n+    }\n+}\n+\n+impl From<TypeAliasId> for TypableDef {\n+    fn from(id: TypeAliasId) -> Self {\n+        TypeAlias::from(id).into()\n+    }\n+}\n+\n+impl From<FunctionId> for TypableDef {\n+    fn from(id: FunctionId) -> Self {\n+        Function::from(id).into()\n+    }\n+}\n+impl From<ConstId> for TypableDef {\n+    fn from(id: ConstId) -> Self {\n+        Const::from(id).into()\n+    }\n+}\n+impl From<StaticId> for TypableDef {\n+    fn from(id: StaticId) -> Self {\n+        Static::from(id).into()\n+    }\n+}\n+\n+impl From<Adt> for GenericDefId {\n+    fn from(id: Adt) -> Self {\n+        match id {\n+            Adt::Struct(it) => it.id.into(),\n+            Adt::Union(it) => it.id.into(),\n+            Adt::Enum(it) => it.id.into(),\n+        }\n+    }\n+}"}, {"sha": "774fa1d96404a8e9d97e4a06c06b588584becdc2", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -1,11 +1,10 @@\n //! FIXME: write short doc here\n \n-use hir_def::{type_ref::TypeRef, AstItemDef};\n-use ra_syntax::ast::{self};\n+use hir_def::{resolver::HasResolver, type_ref::TypeRef, AstItemDef};\n+use ra_syntax::ast;\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    resolve::HasResolver,\n     ty::Ty,\n     AssocItem, Crate, HasSource, ImplBlock, Module, Source, TraitRef,\n };\n@@ -27,12 +26,12 @@ impl ImplBlock {\n     }\n \n     pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n-        Ty::from_hir(db, &self.resolver(db), &self.target_type(db))\n+        Ty::from_hir(db, &self.id.resolver(db), &self.target_type(db))\n     }\n \n     pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n         let target_ty = self.target_ty(db);\n-        TraitRef::from_hir(db, &self.resolver(db), &self.target_trait(db)?, Some(target_ty))\n+        TraitRef::from_hir(db, &self.id.resolver(db), &self.target_trait(db)?, Some(target_ty))\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {"}, {"sha": "76c96bdcfb31a4679cec33f98151554b01b318be", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -38,7 +38,6 @@ mod impl_block;\n mod expr;\n mod lang_item;\n pub mod generics;\n-mod resolve;\n pub mod diagnostics;\n mod util;\n \n@@ -52,23 +51,20 @@ mod test_db;\n #[cfg(test)]\n mod marks;\n \n-use crate::resolve::Resolver;\n-\n pub use crate::{\n     code_model::{\n         attrs::{AttrDef, Attrs},\n         docs::{DocDef, Docs, Documentation},\n         src::{HasBodySource, HasSource},\n         Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n         EnumVariant, FieldSource, FnData, Function, GenericParam, HasBody, ImplBlock, Local,\n-        MacroDef, Module, ModuleDef, ModuleSource, Static, Struct, StructField, Trait, TypeAlias,\n-        Union, VariantDef,\n+        MacroDef, Module, ModuleDef, ModuleSource, ScopeDef, Static, Struct, StructField, Trait,\n+        TypeAlias, Union, VariantDef,\n     },\n     expr::ExprScopes,\n     from_source::FromSource,\n     generics::GenericDef,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n-    resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n         display::HirDisplay,"}, {"sha": "c42ceabdfc3357aa0d244ba43a58924eaca4fd16", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -10,6 +10,8 @@ use std::sync::Arc;\n use hir_def::{\n     expr::{ExprId, PatId},\n     path::known,\n+    resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n+    DefWithBodyId,\n };\n use hir_expand::{name::AsName, AstId, MacroCallId, MacroCallLoc, MacroFileKind, Source};\n use ra_syntax::{\n@@ -21,36 +23,38 @@ use ra_syntax::{\n \n use crate::{\n     db::HirDatabase,\n-    expr::{self, BodySourceMap, ExprScopes, ScopeId},\n+    expr::{BodySourceMap, ExprScopes, ScopeId},\n     ids::LocationCtx,\n-    resolve::{HasResolver, ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},\n-    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, GenericParam, HasBody,\n-    HirFileId, Local, MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n+    Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n+    GenericParam, HasBody, HirFileId, Local, MacroDef, Module, Name, Path, ScopeDef, Static,\n+    Struct, Trait, Ty, TypeAlias,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n     match_ast! {\n         match (node.value) {\n             ast::Module(it) => {\n                 let src = node.with_value(it);\n-                Some(crate::Module::from_declaration(db, src)?.resolver(db))\n+                Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n             },\n              ast::SourceFile(it) => {\n                 let src = node.with_value(crate::ModuleSource::SourceFile(it));\n-                Some(crate::Module::from_definition(db, src)?.resolver(db))\n+                Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n             },\n             ast::StructDef(it) => {\n                 let src = node.with_value(it);\n-                Some(Struct::from_source(db, src)?.resolver(db))\n+                Some(Struct::from_source(db, src)?.id.resolver(db))\n             },\n             ast::EnumDef(it) => {\n                 let src = node.with_value(it);\n-                Some(Enum::from_source(db, src)?.resolver(db))\n+                Some(Enum::from_source(db, src)?.id.resolver(db))\n             },\n             _ => match node.value.kind() {\n                 FN_DEF | CONST_DEF | STATIC_DEF => {\n-                    Some(def_with_body_from_child_node(db, node)?.resolver(db))\n+                    let def = def_with_body_from_child_node(db, node)?;\n+                    let def = DefWithBodyId::from(def);\n+                    Some(def.resolver(db))\n                 }\n                 // FIXME add missing cases\n                 _ => None\n@@ -159,7 +163,7 @@ impl SourceAnalyzer {\n                 None => scope_for(&scopes, &source_map, node),\n                 Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n             };\n-            let resolver = expr::resolver_for_scope(db, def, scope);\n+            let resolver = resolver_for_scope(db, def.into(), scope);\n             SourceAnalyzer {\n                 resolver,\n                 body_owner: Some(def),\n@@ -231,7 +235,7 @@ impl SourceAnalyzer {\n     ) -> Option<MacroDef> {\n         // This must be a normal source file rather than macro file.\n         let path = macro_call.path().and_then(Path::from_ast)?;\n-        self.resolver.resolve_path_as_macro(db, &path)\n+        self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n     }\n \n     pub fn resolve_hir_path(\n@@ -240,28 +244,30 @@ impl SourceAnalyzer {\n         path: &crate::Path,\n     ) -> Option<PathResolution> {\n         let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n-            TypeNs::SelfType(it) => PathResolution::SelfType(it),\n+            TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n             TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap(),\n+                parent: self.resolver.generic_def().unwrap().into(),\n                 idx,\n             }),\n-            TypeNs::AdtSelfType(it) | TypeNs::Adt(it) => PathResolution::Def(it.into()),\n-            TypeNs::EnumVariant(it) => PathResolution::Def(it.into()),\n-            TypeNs::TypeAlias(it) => PathResolution::Def(it.into()),\n+            TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n+                PathResolution::Def(Adt::from(it).into())\n+            }\n+            TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+            TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n             TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n-            TypeNs::Trait(it) => PathResolution::Def(it.into()),\n+            TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         });\n         let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n             let res = match val {\n                 ValueNs::LocalBinding(pat_id) => {\n                     let var = Local { parent: self.body_owner?, pat_id };\n                     PathResolution::Local(var)\n                 }\n-                ValueNs::Function(it) => PathResolution::Def(it.into()),\n-                ValueNs::Const(it) => PathResolution::Def(it.into()),\n-                ValueNs::Static(it) => PathResolution::Def(it.into()),\n-                ValueNs::Struct(it) => PathResolution::Def(it.into()),\n-                ValueNs::EnumVariant(it) => PathResolution::Def(it.into()),\n+                ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n+                ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n+                ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n+                ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n+                ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n             };\n             Some(res)\n         });\n@@ -272,7 +278,9 @@ impl SourceAnalyzer {\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n-            self.resolver.resolve_path_as_macro(db, &path).map(|def| PathResolution::Macro(def))\n+            self.resolver\n+                .resolve_path_as_macro(db, &path)\n+                .map(|def| PathResolution::Macro(def.into()))\n         })\n     }\n \n@@ -307,7 +315,22 @@ impl SourceAnalyzer {\n     }\n \n     pub fn process_all_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n-        self.resolver.process_all_names(db, f)\n+        self.resolver.process_all_names(db, &mut |name, def| {\n+            let def = match def {\n+                resolver::ScopeDef::PerNs(it) => it.into(),\n+                resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n+                resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n+                resolver::ScopeDef::GenericParam(idx) => {\n+                    let parent = self.resolver.generic_def().unwrap().into();\n+                    ScopeDef::GenericParam(GenericParam { parent, idx })\n+                }\n+                resolver::ScopeDef::Local(pat_id) => {\n+                    let parent = self.resolver.body_owner().unwrap().into();\n+                    ScopeDef::Local(Local { parent, pat_id })\n+                }\n+            };\n+            f(name, def)\n+        })\n     }\n \n     // FIXME: we only use this in `inline_local_variable` assist, ideally, we\n@@ -392,7 +415,7 @@ impl SourceAnalyzer {\n         let std_future_path = known::std_future_future();\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n-            Some(it) => it,\n+            Some(it) => it.into(),\n             _ => return false,\n         };\n \n@@ -402,7 +425,7 @@ impl SourceAnalyzer {\n         };\n \n         let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n-        implements_trait(&canonical_ty, db, &self.resolver, krate, std_future_trait)\n+        implements_trait(&canonical_ty, db, &self.resolver, krate.into(), std_future_trait)\n     }\n \n     pub fn expand("}, {"sha": "5d8518041fde02f5bf32c37d74f7c057d2b5151d", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -5,11 +5,12 @@\n \n use std::iter::successors;\n \n+use hir_def::resolver::Resolver;\n use hir_expand::name;\n use log::{info, warn};\n \n use super::{traits::Solution, Canonical, Substs, Ty, TypeWalk};\n-use crate::{db::HirDatabase, generics::HasGenericParams, Resolver};\n+use crate::{db::HirDatabase, generics::HasGenericParams};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n@@ -39,7 +40,7 @@ fn deref_by_trait(\n     ty: &Canonical<Ty>,\n ) -> Option<Canonical<Ty>> {\n     let krate = resolver.krate()?;\n-    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n+    let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n         crate::lang_item::LangItemTarget::Trait(t) => t,\n         _ => return None,\n     };\n@@ -71,7 +72,7 @@ fn deref_by_trait(\n \n     let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: in_env };\n \n-    let solution = db.trait_solve(krate, canonical)?;\n+    let solution = db.trait_solve(krate.into(), canonical)?;\n \n     match &solution {\n         Solution::Unique(vars) => {"}, {"sha": "69b13baefbace0f6b5ea5fbe92f1d11d403e6325", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -23,7 +23,9 @@ use rustc_hash::FxHashMap;\n \n use hir_def::{\n     path::known,\n+    resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n+    AdtId, DefWithBodyId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n@@ -40,10 +42,9 @@ use crate::{\n     code_model::TypeAlias,\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n-    resolve::{HasResolver, Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n-    StructField, VariantDef,\n+    StructField, Trait, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -64,7 +65,7 @@ mod coerce;\n /// The entry point of type inference.\n pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let resolver = def.resolver(db);\n+    let resolver = DefWithBodyId::from(def).resolver(db);\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n     match def {\n@@ -377,8 +378,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for obligation in obligations {\n             let in_env = InEnvironment::new(self.trait_env.clone(), obligation.clone());\n             let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n-            let solution =\n-                self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n+            let solution = self\n+                .db\n+                .trait_solve(self.resolver.krate().unwrap().into(), canonicalized.value.clone());\n \n             match solution {\n                 Some(Solution::Unique(substs)) => {\n@@ -518,17 +520,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // FIXME: this should resolve assoc items as well, see this example:\n             // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n             match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n-                Some(TypeNs::Adt(Adt::Struct(it))) => it.into(),\n-                Some(TypeNs::Adt(Adt::Union(it))) => it.into(),\n+                Some(TypeNs::AdtId(AdtId::StructId(it))) => it.into(),\n+                Some(TypeNs::AdtId(AdtId::UnionId(it))) => it.into(),\n                 Some(TypeNs::AdtSelfType(adt)) => adt.into(),\n-                Some(TypeNs::EnumVariant(it)) => it.into(),\n-                Some(TypeNs::TypeAlias(it)) => it.into(),\n+                Some(TypeNs::EnumVariantId(it)) => it.into(),\n+                Some(TypeNs::TypeAliasId(it)) => it.into(),\n \n                 Some(TypeNs::SelfType(_)) |\n                 Some(TypeNs::GenericParam(_)) |\n                 Some(TypeNs::BuiltinType(_)) |\n-                Some(TypeNs::Trait(_)) |\n-                Some(TypeNs::Adt(Adt::Enum(_))) |\n+                Some(TypeNs::TraitId(_)) |\n+                Some(TypeNs::AdtId(AdtId::EnumId(_))) |\n                 None => {\n                     return (Ty::Unknown, None)\n                 }\n@@ -576,26 +578,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n         let path = known::std_iter_into_iterator();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n         let path = known::std_ops_try();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n         let path = known::std_future_future();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<Adt> {\n         let path = known::std_boxed_box();\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n-        Some(Adt::Struct(struct_))\n+        Some(Adt::Struct(struct_.into()))\n     }\n }\n "}, {"sha": "0772b9df57a05a4445f21d11d52123465ece0801", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -4,19 +4,19 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n+use hir_def::resolver::Resolver;\n use rustc_hash::FxHashMap;\n-\n use test_utils::tested_by;\n \n-use super::{InferTy, InferenceContext, TypeVarValue};\n use crate::{\n     db::HirDatabase,\n     lang_item::LangItemTarget,\n-    resolve::Resolver,\n     ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n     Adt, Mutability,\n };\n \n+use super::{InferTy, InferenceContext, TypeVarValue};\n+\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n@@ -49,8 +49,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         resolver: &Resolver,\n     ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n         let krate = resolver.krate().unwrap();\n-        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n+        let impls = match db.lang_item(krate.into(), \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate.into(), trait_),\n             _ => return FxHashMap::default(),\n         };\n "}, {"sha": "ac570075f009318a625111b8ce2d5f6e748bfc14", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -6,13 +6,13 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::Signedness,\n     path::{GenericArg, GenericArgs},\n+    resolver::resolver_for_expr,\n };\n use hir_expand::name;\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n use crate::{\n     db::HirDatabase,\n-    expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n+    expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n     ty::{\n         autoderef, method_resolution, op, CallableDef, InferTy, IntTy, Mutability, Namespace,\n@@ -22,6 +22,8 @@ use crate::{\n     Adt, Name,\n };\n \n+use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n@@ -186,7 +188,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n-                let resolver = expr::resolver_for_expr(self.db, self.owner, tgt_expr);\n+                let resolver = resolver_for_expr(self.db, self.owner.into(), tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),"}, {"sha": "70136e514e277ecbe660c36bc599734e6494f66d", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -1,16 +1,19 @@\n //! Path expression resolution.\n \n-use hir_def::path::PathSegment;\n+use hir_def::{\n+    path::PathSegment,\n+    resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+};\n \n-use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n     generics::HasGenericParams,\n-    resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::{method_resolution, Namespace, Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, Container, Name, Path,\n+    AssocItem, Container, Function, Name, Path,\n };\n \n+use super::{ExprOrPatId, InferenceContext, TraitRef};\n+\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n         &mut self,\n@@ -60,11 +63,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n                 return Some(ty);\n             }\n-            ValueNs::Function(it) => it.into(),\n-            ValueNs::Const(it) => it.into(),\n-            ValueNs::Static(it) => it.into(),\n-            ValueNs::Struct(it) => it.into(),\n-            ValueNs::EnumVariant(it) => it.into(),\n+            ValueNs::FunctionId(it) => it.into(),\n+            ValueNs::ConstId(it) => it.into(),\n+            ValueNs::StaticId(it) => it.into(),\n+            ValueNs::StructId(it) => it.into(),\n+            ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n         let mut ty = self.db.type_for_def(typable, Namespace::Values);\n@@ -94,13 +97,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let is_before_last = remaining_segments.len() == 1;\n \n         match (def, is_before_last) {\n-            (TypeNs::Trait(trait_), true) => {\n+            (TypeNs::TraitId(trait_), true) => {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n                 let trait_ref = TraitRef::from_resolved_path(\n                     self.db,\n                     &self.resolver,\n-                    trait_,\n+                    trait_.into(),\n                     resolved_segment,\n                     None,\n                 );\n@@ -160,8 +163,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             AssocItem::TypeAlias(_) => None,\n         })?;\n         let def = match item {\n-            AssocItem::Function(f) => ValueNs::Function(f),\n-            AssocItem::Const(c) => ValueNs::Const(c),\n+            AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n+            AssocItem::Const(c) => ValueNs::ConstId(c.id),\n             AssocItem::TypeAlias(_) => unreachable!(),\n         };\n         let substs = Substs::build_for_def(self.db, item)\n@@ -193,8 +196,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             method_resolution::LookupMode::Path,\n             move |_ty, item| {\n                 let def = match item {\n-                    AssocItem::Function(f) => ValueNs::Function(f),\n-                    AssocItem::Const(c) => ValueNs::Const(c),\n+                    AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n+                    AssocItem::Const(c) => ValueNs::ConstId(c.id),\n                     AssocItem::TypeAlias(_) => unreachable!(),\n                 };\n                 let substs = match item.container(self.db) {\n@@ -224,7 +227,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n-        if let ValueNs::Function(func) = def {\n+        if let ValueNs::FunctionId(func) = def {\n+            let func = Function::from(*func);\n             // We only do the infer if parent has generic params\n             let gen = func.generic_params(self.db);\n             if gen.count_parent_params() == 0 {"}, {"sha": "c6ad0811b96fbe96157fb7369a5d9ce3bf80d7cf", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -11,7 +11,9 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType},\n     path::{GenericArg, PathSegment},\n+    resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n+    GenericDefId,\n };\n \n use super::{\n@@ -22,14 +24,13 @@ use crate::{\n     db::HirDatabase,\n     generics::HasGenericParams,\n     generics::{GenericDef, WherePredicate},\n-    resolve::{HasResolver, Resolver, TypeNs},\n     ty::{\n         primitive::{FloatTy, IntTy, Uncertain},\n         Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n-    TypeAlias, Union, VariantDef,\n+    Const, Enum, EnumVariant, Function, ImplBlock, ModuleDef, Path, Static, Struct, StructField,\n+    Trait, TypeAlias, Union, VariantDef,\n };\n \n // FIXME: this is only really used in `type_for_def`, which contains a bunch of\n@@ -156,9 +157,14 @@ impl Ty {\n         remaining_segments: &[PathSegment],\n     ) -> Ty {\n         let ty = match resolution {\n-            TypeNs::Trait(trait_) => {\n-                let trait_ref =\n-                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+            TypeNs::TraitId(trait_) => {\n+                let trait_ref = TraitRef::from_resolved_path(\n+                    db,\n+                    resolver,\n+                    trait_.into(),\n+                    resolved_segment,\n+                    None,\n+                );\n                 return if remaining_segments.len() == 1 {\n                     let segment = &remaining_segments[0];\n                     match trait_ref\n@@ -189,18 +195,18 @@ impl Ty {\n                 let name = resolved_segment.name.clone();\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_block) => impl_block.target_ty(db),\n-            TypeNs::AdtSelfType(adt) => adt.ty(db),\n+            TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n+            TypeNs::AdtSelfType(adt) => Adt::from(adt).ty(db),\n \n-            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n+            TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => {\n                 Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n             }\n-            TypeNs::TypeAlias(it) => {\n+            TypeNs::TypeAliasId(it) => {\n                 Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n             }\n             // FIXME: report error\n-            TypeNs::EnumVariant(_) => return Ty::Unknown,\n+            TypeNs::EnumVariantId(_) => return Ty::Unknown,\n         };\n \n         Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n@@ -247,7 +253,7 @@ impl Ty {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = db.generic_predicates_for_param(def, param_idx);\n+        let predicates = db.generic_predicates_for_param(def.into(), param_idx);\n         let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n@@ -391,11 +397,11 @@ impl TraitRef {\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let resolved = match resolver.resolve_path_in_type_ns_fully(db, &path)? {\n-            TypeNs::Trait(tr) => tr,\n+            TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments.last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(db, resolver, resolved, segment, explicit_self_ty))\n+        Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(super) fn from_resolved_path(\n@@ -548,8 +554,8 @@ pub(crate) fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSi\n pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     let parent_def = field.parent_def(db);\n     let resolver = match parent_def {\n-        VariantDef::Struct(it) => it.resolver(db),\n-        VariantDef::EnumVariant(it) => it.parent_enum(db).resolver(db),\n+        VariantDef::Struct(it) => it.id.resolver(db),\n+        VariantDef::EnumVariant(it) => it.parent.id.resolver(db),\n     };\n     let var_data = parent_def.variant_data(db);\n     let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n@@ -569,7 +575,7 @@ pub(crate) fn generic_predicates_for_param_query(\n     def: GenericDef,\n     param_idx: u32,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n@@ -595,7 +601,7 @@ pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,\n     def: GenericDef,\n ) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n@@ -604,7 +610,7 @@ pub(crate) fn generic_predicates_query(\n \n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) -> Substs {\n-    let resolver = def.resolver(db);\n+    let resolver = GenericDefId::from(def).resolver(db);\n     let generic_params = def.generic_params(db);\n \n     let defaults = generic_params\n@@ -618,7 +624,7 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n \n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {\n     let data = def.data(db);\n-    let resolver = def.resolver(db);\n+    let resolver = def.id.resolver(db);\n     let params = data.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n     let ret = Ty::from_hir(db, &resolver, data.ret_type());\n     FnSig::from_params_and_return(params, ret)\n@@ -635,15 +641,15 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n /// Build the declared type of a const.\n fn type_for_const(db: &impl HirDatabase, def: Const) -> Ty {\n     let data = def.data(db);\n-    let resolver = def.resolver(db);\n+    let resolver = def.id.resolver(db);\n \n     Ty::from_hir(db, &resolver, data.type_ref())\n }\n \n /// Build the declared type of a static.\n fn type_for_static(db: &impl HirDatabase, def: Static) -> Ty {\n     let data = def.data(db);\n-    let resolver = def.resolver(db);\n+    let resolver = def.id.resolver(db);\n \n     Ty::from_hir(db, &resolver, data.type_ref())\n }\n@@ -695,7 +701,7 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n         Some(fields) => fields,\n         None => panic!(\"fn_sig_for_struct_constructor called on unit struct\"),\n     };\n-    let resolver = def.resolver(db);\n+    let resolver = def.id.resolver(db);\n     let params = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n@@ -721,7 +727,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant)\n         Some(fields) => fields,\n         None => panic!(\"fn_sig_for_enum_variant_constructor called for unit variant\"),\n     };\n-    let resolver = def.parent_enum(db).resolver(db);\n+    let resolver = def.parent.id.resolver(db);\n     let params = fields\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n@@ -750,7 +756,7 @@ fn type_for_adt(db: &impl HirDatabase, adt: impl Into<Adt> + HasGenericParams) -\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n     let generics = t.generic_params(db);\n-    let resolver = t.resolver(db);\n+    let resolver = t.id.resolver(db);\n     let type_ref = t.type_ref(db);\n     let substs = Substs::identity(&generics);\n     let inner = Ty::from_hir(db, &resolver, &type_ref.unwrap_or(TypeRef::Error));"}, {"sha": "64adb814d3f90b7e80c197c6a293df7dfd1f0664", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -5,11 +5,11 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n+use hir_def::resolver::Resolver;\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n-    resolve::Resolver,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n     AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n@@ -172,9 +172,14 @@ pub(crate) fn iterate_method_candidates<T>(\n             // rustc does an autoderef and then autoref again).\n \n             for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n-                if let Some(result) =\n-                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n-                {\n+                if let Some(result) = iterate_inherent_methods(\n+                    &derefed_ty,\n+                    db,\n+                    name,\n+                    mode,\n+                    krate.into(),\n+                    &mut callback,\n+                ) {\n                     return Some(result);\n                 }\n                 if let Some(result) = iterate_trait_method_candidates(\n@@ -192,7 +197,7 @@ pub(crate) fn iterate_method_candidates<T>(\n         LookupMode::Path => {\n             // No autoderef for path lookups\n             if let Some(result) =\n-                iterate_inherent_methods(&ty, db, name, mode, krate, &mut callback)\n+                iterate_inherent_methods(&ty, db, name, mode, krate.into(), &mut callback)\n             {\n                 return Some(result);\n             }\n@@ -224,7 +229,9 @@ fn iterate_trait_method_candidates<T>(\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| t.all_super_traits(db));\n-    let traits = inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db));\n+    let traits = inherent_trait\n+        .chain(traits_from_env)\n+        .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n     'traits: for t in traits {\n         let data = t.trait_data(db);\n \n@@ -238,7 +245,7 @@ fn iterate_trait_method_candidates<T>(\n             }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n-                if db.trait_solve(krate, goal).is_none() {\n+                if db.trait_solve(krate.into(), goal).is_none() {\n                     continue 'traits;\n                 }\n             }"}, {"sha": "77f09128871d30d0d59260907d23be933ba987e6", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -12,6 +12,7 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr,\n };\n+use test_utils::tested_by;\n \n use crate::{\n     body::{Body, BodySourceMap, Expander, PatPtr},\n@@ -153,6 +154,7 @@ where\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n+                            tested_by!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();"}, {"sha": "5d7d17231184372cd1625b77f91955e97a109388", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -174,7 +174,7 @@ mod tests {\n     use hir_expand::{name::AsName, Source};\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset};\n+    use test_utils::{assert_eq_text, covers, extract_offset};\n \n     use crate::{db::DefDatabase2, test_db::TestDB, FunctionId, ModuleDefId};\n \n@@ -382,4 +382,20 @@ mod tests {\n             53,\n         );\n     }\n+\n+    #[test]\n+    fn infer_resolve_while_let() {\n+        covers!(infer_resolve_while_let);\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while let Option::Some(spam) = foo {\n+        spam<|>\n+    }\n+}\n+\"#,\n+            75,\n+        );\n+    }\n }"}, {"sha": "d579f5c7ea5fa5e99b01fc476606eeaaffbc8c82", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -19,6 +19,7 @@ pub mod expr;\n pub mod body;\n pub mod generics;\n pub mod traits;\n+pub mod resolver;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "65239ca0a48b6f4e99554845cf5482e486a36a6f", "filename": "crates/ra_hir_def/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -11,4 +11,5 @@ test_utils::marks!(\n     prelude_is_macro_use\n     macro_dollar_crate_self\n     macro_dollar_crate_other\n+    infer_resolve_while_let\n );"}, {"sha": "840785baa428883205737dfbe152c083c5677f2e", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "renamed", "additions": 189, "deletions": 169, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -1,26 +1,28 @@\n-//! Name resolution.\n+//! Name resolution fa\u00e7ade.\n use std::sync::Arc;\n \n-use hir_def::{\n-    builtin_type::BuiltinType,\n-    nameres::CrateDefMap,\n-    path::{Path, PathKind},\n-    AdtId, CrateModuleId, ModuleDefId,\n+use hir_expand::{\n+    name::{self, Name},\n+    MacroDefId,\n };\n-use hir_expand::name::{self, Name};\n+use ra_db::CrateId;\n use rustc_hash::FxHashSet;\n \n use crate::{\n-    code_model::Crate,\n-    db::{DefDatabase, HirDatabase},\n-    expr::{ExprScopes, PatId, ScopeId},\n-    generics::{GenericParams, HasGenericParams},\n-    Adt, Const, Container, DefWithBody, Enum, EnumVariant, Function, GenericDef, ImplBlock, Local,\n-    MacroDef, Module, ModuleDef, PerNs, Static, Struct, Trait, TypeAlias,\n+    body::scope::{ExprScopes, ScopeId},\n+    builtin_type::BuiltinType,\n+    db::DefDatabase2,\n+    expr::{ExprId, PatId},\n+    generics::GenericParams,\n+    nameres::{per_ns::PerNs, CrateDefMap},\n+    path::{Path, PathKind},\n+    AdtId, AstItemDef, ConstId, ContainerId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId,\n+    FunctionId, GenericDefId, ImplId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n+    TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Default)]\n-pub(crate) struct Resolver {\n+pub struct Resolver {\n     scopes: Vec<Scope>,\n }\n \n@@ -33,7 +35,7 @@ pub(crate) struct ModuleItemMap {\n \n #[derive(Debug, Clone)]\n pub(crate) struct ExprScope {\n-    owner: DefWithBody,\n+    owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n@@ -43,80 +45,76 @@ pub(crate) enum Scope {\n     /// All the items and imported names of a module\n     ModuleScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n-    GenericParams { def: GenericDef, params: Arc<GenericParams> },\n+    GenericParams { def: GenericDefId, params: Arc<GenericParams> },\n     /// Brings `Self` in `impl` block into scope\n-    ImplBlockScope(ImplBlock),\n+    ImplBlockScope(ImplId),\n     /// Brings `Self` in enum, struct and union definitions into scope\n-    AdtScope(Adt),\n+    AdtScope(AdtId),\n     /// Local bindings\n     ExprScope(ExprScope),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) enum TypeNs {\n-    SelfType(ImplBlock),\n+pub enum TypeNs {\n+    SelfType(ImplId),\n     GenericParam(u32),\n-    Adt(Adt),\n-    AdtSelfType(Adt),\n-    EnumVariant(EnumVariant),\n-    TypeAlias(TypeAlias),\n+    AdtId(AdtId),\n+    AdtSelfType(AdtId),\n+    EnumVariantId(EnumVariantId),\n+    TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n-    Trait(Trait),\n+    TraitId(TraitId),\n     // Module belong to type ns, but the resolver is used when all module paths\n     // are fully resolved.\n-    // Module(Module)\n+    // ModuleId(ModuleId)\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) enum ResolveValueResult {\n+pub enum ResolveValueResult {\n     ValueNs(ValueNs),\n     Partial(TypeNs, usize),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) enum ValueNs {\n+pub enum ValueNs {\n     LocalBinding(PatId),\n-    Function(Function),\n-    Const(Const),\n-    Static(Static),\n-    Struct(Struct),\n-    EnumVariant(EnumVariant),\n+    FunctionId(FunctionId),\n+    ConstId(ConstId),\n+    StaticId(StaticId),\n+    StructId(StructId),\n+    EnumVariantId(EnumVariantId),\n }\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub(crate) fn resolve_known_trait(&self, db: &impl HirDatabase, path: &Path) -> Option<Trait> {\n+    pub fn resolve_known_trait(&self, db: &impl DefDatabase2, path: &Path) -> Option<TraitId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::TraitId(it) => Some(it.into()),\n+            ModuleDefId::TraitId(it) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n-    pub(crate) fn resolve_known_struct(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Option<Struct> {\n+    pub fn resolve_known_struct(&self, db: &impl DefDatabase2, path: &Path) -> Option<StructId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it.into()),\n+            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub(crate) fn resolve_known_enum(&self, db: &impl HirDatabase, path: &Path) -> Option<Enum> {\n+    pub fn resolve_known_enum(&self, db: &impl DefDatabase2, path: &Path) -> Option<EnumId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it.into()),\n+            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// pub only for source-binder\n-    pub(crate) fn resolve_module_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs {\n+    pub fn resolve_module_path(&self, db: &impl DefDatabase2, path: &Path) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n@@ -128,9 +126,9 @@ impl Resolver {\n         module_res\n     }\n \n-    pub(crate) fn resolve_path_in_type_ns(\n+    pub fn resolve_path_in_type_ns(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n         if path.is_type_relative() {\n@@ -164,13 +162,13 @@ impl Resolver {\n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n                     let res = match module_def.take_types()? {\n-                        ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n-                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariant(it.into()),\n+                        ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n \n-                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n                         ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n-                        ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n+                        ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n \n                         ModuleDefId::FunctionId(_)\n                         | ModuleDefId::ConstId(_)\n@@ -184,9 +182,9 @@ impl Resolver {\n         None\n     }\n \n-    pub(crate) fn resolve_path_in_type_ns_fully(\n+    pub fn resolve_path_in_type_ns_fully(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n@@ -196,9 +194,9 @@ impl Resolver {\n         Some(res)\n     }\n \n-    pub(crate) fn resolve_path_in_value_ns<'p>(\n+    pub fn resolve_path_in_value_ns<'p>(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &'p Path,\n     ) -> Option<ResolveValueResult> {\n         if path.is_type_relative() {\n@@ -259,13 +257,11 @@ impl Resolver {\n                     return match idx {\n                         None => {\n                             let value = match module_def.take_values()? {\n-                                ModuleDefId::FunctionId(it) => ValueNs::Function(it.into()),\n-                                ModuleDefId::AdtId(AdtId::StructId(it)) => {\n-                                    ValueNs::Struct(it.into())\n-                                }\n-                                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariant(it.into()),\n-                                ModuleDefId::ConstId(it) => ValueNs::Const(it.into()),\n-                                ModuleDefId::StaticId(it) => ValueNs::Static(it.into()),\n+                                ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n+                                ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n+                                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n+                                ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n+                                ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n \n                                 ModuleDefId::AdtId(AdtId::EnumId(_))\n                                 | ModuleDefId::AdtId(AdtId::UnionId(_))\n@@ -278,9 +274,9 @@ impl Resolver {\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n-                                ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n-                                ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n-                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n                                 ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n                                 ModuleDefId::ModuleId(_)\n@@ -298,9 +294,9 @@ impl Resolver {\n         None\n     }\n \n-    pub(crate) fn resolve_path_in_value_ns_fully(\n+    pub fn resolve_path_in_value_ns_fully(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n@@ -309,35 +305,26 @@ impl Resolver {\n         }\n     }\n \n-    pub(crate) fn resolve_path_as_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        path: &Path,\n-    ) -> Option<MacroDef> {\n+    pub fn resolve_path_as_macro(&self, db: &impl DefDatabase2, path: &Path) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros().map(MacroDef::from)\n+        item_map.resolve_path(db, module, path).0.get_macros()\n     }\n \n-    pub(crate) fn process_all_names(\n-        &self,\n-        db: &impl HirDatabase,\n-        f: &mut dyn FnMut(Name, ScopeDef),\n-    ) {\n+    pub fn process_all_names(&self, db: &impl DefDatabase2, f: &mut dyn FnMut(Name, ScopeDef)) {\n         for scope in self.scopes.iter().rev() {\n             scope.process_names(db, f);\n         }\n     }\n \n-    pub(crate) fn traits_in_scope(&self, db: &impl HirDatabase) -> FxHashSet<Trait> {\n+    pub fn traits_in_scope(&self, db: &impl DefDatabase2) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits\n-                        .extend(prelude_def_map[prelude.module_id].scope.traits().map(Trait::from));\n+                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n                 }\n-                traits.extend(m.crate_def_map[m.module_id].scope.traits().map(Trait::from));\n+                traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n         }\n         traits\n@@ -351,11 +338,11 @@ impl Resolver {\n         })\n     }\n \n-    pub(crate) fn krate(&self) -> Option<Crate> {\n-        self.module().map(|t| Crate { crate_id: t.0.krate() })\n+    pub fn krate(&self) -> Option<CrateId> {\n+        self.module().map(|t| t.0.krate())\n     }\n \n-    pub(crate) fn where_predicates_in_scope<'a>(\n+    pub fn where_predicates_in_scope<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = &'a crate::generics::WherePredicate> + 'a {\n         self.scopes\n@@ -367,12 +354,19 @@ impl Resolver {\n             .flat_map(|params| params.where_predicates.iter())\n     }\n \n-    pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n+    pub fn generic_def(&self) -> Option<GenericDefId> {\n         self.scopes.iter().find_map(|scope| match scope {\n             Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n         })\n     }\n+\n+    pub fn body_owner(&self) -> Option<DefWithBodyId> {\n+        self.scopes.iter().find_map(|scope| match scope {\n+            Scope::ExprScope(it) => Some(it.owner),\n+            _ => None,\n+        })\n+    }\n }\n \n impl Resolver {\n@@ -383,18 +377,18 @@ impl Resolver {\n \n     pub(crate) fn push_generic_params_scope(\n         self,\n-        db: &impl DefDatabase,\n-        def: GenericDef,\n+        db: &impl DefDatabase2,\n+        def: GenericDefId,\n     ) -> Resolver {\n-        let params = def.generic_params(db);\n+        let params = db.generic_params(def);\n         if params.params.is_empty() {\n             self\n         } else {\n             self.push_scope(Scope::GenericParams { def, params })\n         }\n     }\n \n-    pub(crate) fn push_impl_block_scope(self, impl_block: ImplBlock) -> Resolver {\n+    pub(crate) fn push_impl_block_scope(self, impl_block: ImplId) -> Resolver {\n         self.push_scope(Scope::ImplBlockScope(impl_block))\n     }\n \n@@ -408,39 +402,24 @@ impl Resolver {\n \n     pub(crate) fn push_expr_scope(\n         self,\n-        owner: DefWithBody,\n+        owner: DefWithBodyId,\n         expr_scopes: Arc<ExprScopes>,\n         scope_id: ScopeId,\n     ) -> Resolver {\n         self.push_scope(Scope::ExprScope(ExprScope { owner, expr_scopes, scope_id }))\n     }\n }\n \n-/// For IDE only\n pub enum ScopeDef {\n-    ModuleDef(ModuleDef),\n-    MacroDef(MacroDef),\n+    PerNs(PerNs),\n+    ImplSelfType(ImplId),\n+    AdtSelfType(AdtId),\n     GenericParam(u32),\n-    ImplSelfType(ImplBlock),\n-    AdtSelfType(Adt),\n-    Local(Local),\n-    Unknown,\n-}\n-\n-impl From<PerNs> for ScopeDef {\n-    fn from(def: PerNs) -> Self {\n-        def.take_types()\n-            .or_else(|| def.take_values())\n-            .map(|module_def_id| ScopeDef::ModuleDef(module_def_id.into()))\n-            .or_else(|| {\n-                def.get_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n-            })\n-            .unwrap_or(ScopeDef::Unknown)\n-    }\n+    Local(PatId),\n }\n \n impl Scope {\n-    fn process_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    fn process_names(&self, db: &impl DefDatabase2, f: &mut dyn FnMut(Name, ScopeDef)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -451,18 +430,18 @@ impl Scope {\n                 //     }),\n                 // );\n                 m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n-                    f(name.clone(), res.def.into());\n+                    f(name.clone(), ScopeDef::PerNs(res.def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), ScopeDef::MacroDef(macro_.into()));\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n                 });\n                 m.crate_def_map.extern_prelude().iter().for_each(|(name, &def)| {\n-                    f(name.clone(), ScopeDef::ModuleDef(def.into()));\n+                    f(name.clone(), ScopeDef::PerNs(PerNs::types(def.into())));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n                     prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), res.def.into());\n+                        f(name.clone(), ScopeDef::PerNs(res.def));\n                     });\n                 }\n             }\n@@ -472,114 +451,155 @@ impl Scope {\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::ImplSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::ImplSelfType((*i).into()));\n             }\n             Scope::AdtScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::AdtSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::AdtSelfType((*i).into()));\n             }\n             Scope::ExprScope(scope) => {\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n-                    let local = Local { parent: scope.owner, pat_id: e.pat() };\n-                    f(e.name().clone(), ScopeDef::Local(local));\n+                    f(e.name().clone(), ScopeDef::Local(e.pat()));\n                 });\n             }\n         }\n     }\n }\n \n-pub(crate) trait HasResolver {\n+// needs arbitrary_self_types to be a method... or maybe move to the def?\n+pub fn resolver_for_expr(\n+    db: &impl DefDatabase2,\n+    owner: DefWithBodyId,\n+    expr_id: ExprId,\n+) -> Resolver {\n+    let scopes = db.expr_scopes(owner);\n+    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n+}\n+\n+pub fn resolver_for_scope(\n+    db: &impl DefDatabase2,\n+    owner: DefWithBodyId,\n+    scope_id: Option<ScopeId>,\n+) -> Resolver {\n+    let mut r = owner.resolver(db);\n+    let scopes = db.expr_scopes(owner);\n+    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n+    for scope in scope_chain.into_iter().rev() {\n+        r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n+    }\n+    r\n+}\n+\n+pub trait HasResolver {\n     /// Builds a resolver for type references inside this def.\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver;\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver;\n }\n \n-impl HasResolver for Module {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        Resolver::default().push_module_scope(def_map, self.id.module_id)\n+impl HasResolver for ModuleId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        let def_map = db.crate_def_map(self.krate);\n+        Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n }\n \n-impl HasResolver for Trait {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+impl HasResolver for TraitId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         self.module(db).resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n-impl<T: Into<Adt>> HasResolver for T {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def = self.into();\n-        def.module(db)\n+impl HasResolver for AdtId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        let module = match self {\n+            AdtId::StructId(it) => it.0.module(db),\n+            AdtId::UnionId(it) => it.0.module(db),\n+            AdtId::EnumId(it) => it.module(db),\n+        };\n+\n+        module\n             .resolver(db)\n-            .push_generic_params_scope(db, def.into())\n-            .push_scope(Scope::AdtScope(def))\n+            .push_generic_params_scope(db, self.into())\n+            .push_scope(Scope::AdtScope(self.into()))\n     }\n }\n \n-impl HasResolver for Function {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.container(db)\n-            .map(|c| c.resolver(db))\n-            .unwrap_or_else(|| self.module(db).resolver(db))\n-            .push_generic_params_scope(db, self.into())\n+impl HasResolver for StructId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        AdtId::from(self).resolver(db)\n+    }\n+}\n+\n+impl HasResolver for UnionId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        AdtId::from(self).resolver(db)\n+    }\n+}\n+\n+impl HasResolver for EnumId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        AdtId::from(self).resolver(db)\n     }\n }\n \n-impl HasResolver for DefWithBody {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+impl HasResolver for FunctionId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n+    }\n+}\n+\n+impl HasResolver for DefWithBodyId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         match self {\n-            DefWithBody::Const(c) => c.resolver(db),\n-            DefWithBody::Function(f) => f.resolver(db),\n-            DefWithBody::Static(s) => s.resolver(db),\n+            DefWithBodyId::ConstId(c) => c.resolver(db),\n+            DefWithBodyId::FunctionId(f) => f.resolver(db),\n+            DefWithBodyId::StaticId(s) => s.resolver(db),\n         }\n     }\n }\n \n-impl HasResolver for Const {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.container(db).map(|c| c.resolver(db)).unwrap_or_else(|| self.module(db).resolver(db))\n+impl HasResolver for ConstId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        self.lookup(db).container.resolver(db)\n     }\n }\n \n-impl HasResolver for Static {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+impl HasResolver for StaticId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         self.module(db).resolver(db)\n     }\n }\n \n-impl HasResolver for TypeAlias {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.container(db)\n-            .map(|ib| ib.resolver(db))\n-            .unwrap_or_else(|| self.module(db).resolver(db))\n-            .push_generic_params_scope(db, self.into())\n+impl HasResolver for TypeAliasId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n+        self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n     }\n }\n \n-impl HasResolver for Container {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+impl HasResolver for ContainerId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         match self {\n-            Container::Trait(trait_) => trait_.resolver(db),\n-            Container::ImplBlock(impl_block) => impl_block.resolver(db),\n+            ContainerId::TraitId(it) => it.resolver(db),\n+            ContainerId::ImplId(it) => it.resolver(db),\n+            ContainerId::ModuleId(it) => it.resolver(db),\n         }\n     }\n }\n \n-impl HasResolver for GenericDef {\n-    fn resolver(self, db: &impl DefDatabase) -> crate::Resolver {\n+impl HasResolver for GenericDefId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         match self {\n-            GenericDef::Function(inner) => inner.resolver(db),\n-            GenericDef::Adt(adt) => adt.resolver(db),\n-            GenericDef::Trait(inner) => inner.resolver(db),\n-            GenericDef::TypeAlias(inner) => inner.resolver(db),\n-            GenericDef::ImplBlock(inner) => inner.resolver(db),\n-            GenericDef::EnumVariant(inner) => inner.parent_enum(db).resolver(db),\n-            GenericDef::Const(inner) => inner.resolver(db),\n+            GenericDefId::FunctionId(inner) => inner.resolver(db),\n+            GenericDefId::AdtId(adt) => adt.resolver(db),\n+            GenericDefId::TraitId(inner) => inner.resolver(db),\n+            GenericDefId::TypeAliasId(inner) => inner.resolver(db),\n+            GenericDefId::ImplId(inner) => inner.resolver(db),\n+            GenericDefId::EnumVariantId(inner) => inner.parent.resolver(db),\n+            GenericDefId::ConstId(inner) => inner.resolver(db),\n         }\n     }\n }\n \n-impl HasResolver for ImplBlock {\n-    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+impl HasResolver for ImplId {\n+    fn resolver(self, db: &impl DefDatabase2) -> Resolver {\n         self.module(db)\n             .resolver(db)\n             .push_generic_params_scope(db, self.into())", "previous_filename": "crates/ra_hir/src/resolve.rs"}, {"sha": "6c2d5b2a9f7be9bbdb1aa293ad054dc99bf55977", "filename": "crates/ra_hir_def/src/traits.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f61915bde4c5d8d4fe2e9b8dfa9445008730b79/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=1f61915bde4c5d8d4fe2e9b8dfa9445008730b79", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n     db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n-    TypeAliasLoc,\n+    TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -56,4 +56,11 @@ impl TraitData {\n         };\n         Arc::new(TraitData { name, items, auto })\n     }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|item| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n }"}]}