{"sha": "e7211948a546596bbe058b4fd3748a24adecaf02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MjExOTQ4YTU0NjU5NmJiZTA1OGI0ZmQzNzQ4YTI0YWRlY2FmMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T10:37:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T10:37:35Z"}, "message": "auto merge of #8045 : michaelwoerister/rust/destructuring, r=jdm\n\nAs the title says, valid debug info is now generated for any kind of pattern-based bindings like an example from the automated tests: \r\n```rust\r\nlet ((u, v), ((w, (x, Struct { a: y, b: z})), Struct { a: ae, b: oe }), ue) =\r\n    ((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33);  \r\n```\r\n(Not that you would necessarily want to do a thing like that :P )\r\n\r\nFixes #2533", "tree": {"sha": "caff8ee5dac58d2d291b3a44989c788cffccf042", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caff8ee5dac58d2d291b3a44989c788cffccf042"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7211948a546596bbe058b4fd3748a24adecaf02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7211948a546596bbe058b4fd3748a24adecaf02", "html_url": "https://github.com/rust-lang/rust/commit/e7211948a546596bbe058b4fd3748a24adecaf02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7211948a546596bbe058b4fd3748a24adecaf02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15310ba7c2a930a26bf6104f336cf7220eec7dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/15310ba7c2a930a26bf6104f336cf7220eec7dc7", "html_url": "https://github.com/rust-lang/rust/commit/15310ba7c2a930a26bf6104f336cf7220eec7dc7"}, {"sha": "d54615528c9d90523865a5bc518b21bb20909ce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54615528c9d90523865a5bc518b21bb20909ce2", "html_url": "https://github.com/rust-lang/rust/commit/d54615528c9d90523865a5bc518b21bb20909ce2"}], "stats": {"total": 883, "additions": 758, "deletions": 125}, "files": [{"sha": "e467f91d1b1483cf08783131a6ed5f5b59457c93", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -1791,7 +1791,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_argument_metadata(bcx, &args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_argument_metadata(bcx, &args[arg_n]);\n         }\n     }\n "}, {"sha": "7333850bf96d4c11cce94a99b3d696854f74a779", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 146, "deletions": 118, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -60,6 +60,7 @@ use middle::trans::type_::Type;\n use middle::trans::adt;\n use middle::trans;\n use middle::ty;\n+use middle::pat_util;\n use util::ppaux::ty_to_str;\n \n use std::hashmap::HashMap;\n@@ -71,15 +72,15 @@ use syntax::{ast, codemap, ast_util, ast_map};\n \n static DW_LANG_RUST: int = 0x9000;\n \n-static DW_TAG_auto_variable: int = 0x100;\n-static DW_TAG_arg_variable: int = 0x101;\n+static DW_TAG_auto_variable: c_uint = 0x100;\n+static DW_TAG_arg_variable: c_uint = 0x101;\n \n-static DW_ATE_boolean: int = 0x02;\n-static DW_ATE_float: int = 0x04;\n-static DW_ATE_signed: int = 0x05;\n-static DW_ATE_signed_char: int = 0x06;\n-static DW_ATE_unsigned: int = 0x07;\n-static DW_ATE_unsigned_char: int = 0x08;\n+static DW_ATE_boolean: c_uint = 0x02;\n+static DW_ATE_float: c_uint = 0x04;\n+static DW_ATE_signed: c_uint = 0x05;\n+static DW_ATE_signed_char: c_uint = 0x06;\n+static DW_ATE_unsigned: c_uint = 0x07;\n+static DW_ATE_unsigned_char: c_uint = 0x08;\n \n \n \n@@ -90,14 +91,16 @@ static DW_ATE_unsigned_char: int = 0x08;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct DebugContext {\n-    crate_file: ~str,\n-    llcontext: ContextRef,\n-    builder: DIBuilderRef,\n-    curr_loc: (uint, uint),\n-    created_files: HashMap<~str, DIFile>,\n-    created_functions: HashMap<ast::node_id, DISubprogram>,\n-    created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n-    created_types: HashMap<uint, DIType>\n+    priv crate_file: ~str,\n+    priv llcontext: ContextRef,\n+    priv builder: DIBuilderRef,\n+    priv curr_loc: (uint, uint),\n+    priv created_files: HashMap<~str, DIFile>,\n+    priv created_functions: HashMap<ast::node_id, DISubprogram>,\n+    priv created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n+    priv created_types: HashMap<uint, DIType>,\n+    priv last_function_context_id: ast::node_id,\n+    priv argument_counter: uint,\n }\n \n impl DebugContext {\n@@ -115,6 +118,8 @@ impl DebugContext {\n             created_functions: HashMap::new(),\n             created_blocks: HashMap::new(),\n             created_types: HashMap::new(),\n+            last_function_context_id: -1, // magic value :(\n+            argument_counter: 1,\n         };\n     }\n }\n@@ -132,126 +137,147 @@ pub fn finalize(cx: @mut CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-/// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_local_var_metadata(bcx: @mut Block, local: @ast::Local) -> DIVariable {\n+pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n+    let def_map = cx.tcx.def_map;\n+    let pattern = local.pat;\n \n-    let ident = match local.pat.node {\n-      ast::pat_ident(_, ref pth, _) => ast_util::path_to_ident(pth),\n-      // FIXME this should be handled (#2533)\n-      _ => {\n-        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n-        return ptr::null();\n-      }\n+    let scope = match bcx.parent {\n+        None => create_function_metadata(bcx.fcx),\n+        Some(_) => lexical_block_metadata(bcx)\n     };\n \n-    let name: &str = cx.sess.str_of(ident);\n-    debug!(\"create_local_var_metadata: %s\", name);\n+    let filename = span_start(cx, local.span).file.name;\n+    let file_metadata = file_metadata(cx, filename);\n \n-    let loc = span_start(cx, local.span);\n-    let ty = node_id_type(bcx, local.id);\n-    let type_metadata = type_metadata(cx, ty, local.ty.span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n \n-    let context = match bcx.parent {\n-        None => create_function_metadata(bcx.fcx),\n-        Some(_) => lexical_block_metadata(bcx)\n-    };\n+        let ident = ast_util::path_to_ident(path_ref);\n+        let name: &str = cx.sess.str_of(ident);\n+        debug!(\"create_local_var_metadata: %s\", name);\n+        let loc = span_start(cx, span);\n+        let ty = node_id_type(bcx, node_id);\n+        let type_metadata = type_metadata(cx, ty, span);\n+\n+        let var_metadata = do name.as_c_str |name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    DW_TAG_auto_variable,\n+                    scope,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    false,\n+                    0,\n+                    0)\n+            }\n+        };\n+\n+        let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+            }\n+        };\n \n-    let var_metadata = do name.as_c_str |name| {\n+        set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n         unsafe {\n-            llvm::LLVMDIBuilderCreateLocalVariable(\n+            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                 DIB(cx),\n-                DW_TAG_auto_variable as u32,\n-                context,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                false,\n-                0,\n-                0)\n-        }\n-    };\n+                llptr,\n+                var_metadata,\n+                bcx.llbb);\n \n-    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.pat.id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(\n-                local.span,\n-                fmt!(\"No entry in lllocals table for %?\", local.id));\n+            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n         }\n-    };\n-\n-    set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n-\n-    return var_metadata;\n }\n \n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-/// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_argument_metadata(bcx: @mut Block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_argument_metadata\");\n-    if true {\n-        // XXX create_argument_metadata disabled for now because \"node_id_type(bcx, arg.id)\" below\n-        // blows up:\n-        // \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n-        return None;\n-    }\n-\n+pub fn create_argument_metadata(bcx: @mut Block,\n+                                arg: &ast::arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let loc = span_start(cx, span);\n-    if \"<intrinsic>\" == loc.file.name {\n-        return None;\n+    let pattern = arg.pat;\n+    let filename = span_start(cx, pattern.span).file.name;\n+\n+    if fcx.id == -1 ||\n+       fcx.span.is_none() ||\n+       \"<intrinsic>\" == filename {\n+        return;\n     }\n \n-    let ty = node_id_type(bcx, arg.id);\n-    let type_metadata = type_metadata(cx, ty, arg.ty.span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n-    let context = create_function_metadata(fcx);\n-\n-    match arg.pat.node {\n-        ast::pat_ident(_, ref path, _) => {\n-            // XXX: This is wrong; it should work for multiple bindings.\n-            let ident = path.idents.last();\n-            let name: &str = cx.sess.str_of(*ident);\n-            let var_metadata = do name.as_c_str |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateLocalVariable(\n-                        DIB(cx),\n-                        DW_TAG_arg_variable as u32,\n-                        context,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        false,\n-                        0,\n-                        0)\n-                    // XXX need to pass in a real argument number\n-                }\n-            };\n+    // Limited the scope within which `debug_context` is live,\n+    // otherwise => borrowing errors\n+    {\n+        let debug_context = dbg_cx(cx);\n+\n+        // If this is a new function, reset the counter. llvm::DIBuilder\n+        // wants arguments to be indexed starting from 1.\n+        if fcx.id != debug_context.last_function_context_id {\n+                    debug_context.argument_counter = 1;\n+        }\n+        // Keep track of the function we are in\n+        debug_context.last_function_context_id = fcx.id;\n+    }\n+\n+    let def_map = cx.tcx.def_map;\n+    let file_metadata = file_metadata(cx, filename);\n+    let scope = create_function_metadata(fcx);\n+\n+    do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n+\n+        let ty = node_id_type(bcx, node_id);\n+        let type_metadata = type_metadata(cx, ty, codemap::dummy_sp());\n+        let loc = span_start(cx, span);\n+        let ident = ast_util::path_to_ident(path_ref);\n+        let name: &str = cx.sess.str_of(ident);\n+        debug!(\"create_argument_metadata: %s\", name);\n+\n+        let argument_index = {\n+            let debug_context = dbg_cx(cx);\n+            let argument_index = debug_context.argument_counter;\n+            debug_context.argument_counter += 1;\n+            argument_index as c_uint\n+        };\n \n-            let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n+        let arg_metadata = do name.as_c_str |name| {\n             unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, var_metadata, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    DW_TAG_arg_variable,\n+                    scope,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    false,\n+                    0,\n+                    argument_index)\n             }\n-            return Some(var_metadata);\n-        }\n-        _ => {\n-            return None;\n+        };\n+\n+        let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in llargs table for %?\", node_id));\n+            }\n+        };\n+\n+        set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n+        unsafe {\n+            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                DIB(cx),\n+                llptr,\n+                arg_metadata,\n+                bcx.llbb);\n+\n+            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n         }\n     }\n }\n@@ -274,7 +300,6 @@ pub fn update_source_pos(bcx: @mut Block, span: span) {\n /// The return value should be ignored if called from outside of the debuginfo module.\n pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n-    let span = fcx.span.get();\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n     let (ident, ret_ty, id) = match fnitem {\n@@ -320,14 +345,19 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n             _) => {\n             (ident, ty, id)\n         }\n-        _ => fcx.ccx.sess.bug(\"create_function_metadata: unexpected sort of node\")\n+        _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n \n     match dbg_cx(cx).created_functions.find(&id) {\n         Some(fn_metadata) => return *fn_metadata,\n         None => ()\n     }\n \n+    let span = match fcx.span {\n+        Some(value) => value,\n+        None => codemap::dummy_sp()\n+    };\n+\n     debug!(\"create_function_metadata: %s, %s\",\n            cx.sess.str_of(ident),\n            cx.sess.codemap.span_to_str(span));\n@@ -527,7 +557,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n                 name,\n                 bytes_to_bits(size),\n                 bytes_to_bits(align),\n-                encoding as c_uint)\n+                encoding)\n         }\n     };\n \n@@ -608,8 +638,6 @@ fn tuple_metadata(cx: &mut CrateContext,\n fn enum_metadata(cx: &mut CrateContext,\n                  enum_type: ty::t,\n                  enum_def_id: ast::def_id,\n-                 // _substs is only needed in the other version. Will go away with new snapshot.\n-                 _substs: &ty::substs,\n                  span: span)\n               -> DIType {\n \n@@ -1113,8 +1141,8 @@ fn type_metadata(cx: &mut CrateContext,\n                 }\n             }\n         },\n-        ty::ty_enum(def_id, ref substs) => {\n-            enum_metadata(cx, t, def_id, substs, span)\n+        ty::ty_enum(def_id, _) => {\n+            enum_metadata(cx, t, def_id, span)\n         },\n         ty::ty_box(ref mt) => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)"}, {"sha": "05718ab48909f3d7a1775158e4ba5f518eec1559", "filename": "src/test/debug-info/destructured-fn-argument.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -0,0 +1,318 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$1 = 1\n+// debugger:print b\n+// check:$2 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$3 = 2\n+// debugger:print b\n+// check:$4 = 3\n+// debugger:print c\n+// check:$5 = 4\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$6 = 5\n+// debugger:print b\n+// check:$7 = {6, 7}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print h\n+// check:$8 = 8\n+// debugger:print i\n+// check:$9 = {a = 9, b = 10}\n+// debugger:print j\n+// check:$10 = 11\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print k\n+// check:$11 = 12\n+// debugger:print l\n+// check:$12 = 13\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print m\n+// check:$13 = 14\n+// debugger:print n\n+// check:$14 = 16\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print o\n+// check:$15 = 18\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print p\n+// check:$16 = 19\n+// debugger:print q\n+// check:$17 = 20\n+// debugger:print r\n+// check:$18 = {a = 21, b = 22}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print s\n+// check:$19 = 24\n+// debugger:print t\n+// check:$20 = 23\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print u\n+// check:$21 = 25\n+// debugger:print v\n+// check:$22 = 26\n+// debugger:print w\n+// check:$23 = 27\n+// debugger:print x\n+// check:$24 = 28\n+// debugger:print y\n+// check:$25 = 29\n+// debugger:print z\n+// check:$26 = 30\n+// debugger:print ae\n+// check:$27 = 31\n+// debugger:print oe\n+// check:$28 = 32\n+// debugger:print ue\n+// check:$29 = 33\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print aa\n+// check:$30 = {34, 35}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print bb\n+// check:$31 = {36, 37}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print cc\n+// check:$32 = 38\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print dd\n+// check:$33 = {40, 41, 42}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *ee\n+// check:$34 = {43, 44, 45}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *ff\n+// check:$35 = 46\n+// debugger:print gg\n+// check:$36 = {47, 48}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *hh\n+// check:$37 = 50\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print ii\n+// check:$38 = 51\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *jj\n+// check:$39 = 52\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print kk\n+// check:$40 = 53\n+// debugger:print ll\n+// check:$41 = 54\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print mm\n+// check:$42 = 55\n+// debugger:print *nn\n+// check:$43 = 56\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print oo\n+// check:$44 = 57\n+// debugger:print pp\n+// check:$45 = 58\n+// debugger:print qq\n+// check:$46 = 59\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print rr\n+// check:$47 = 60\n+// debugger:print ss\n+// check:$48 = 61\n+// debugger:print tt\n+// check:$49 = 62\n+// debugger:continue\n+\n+\n+struct Struct {\n+    a: i64,\n+    b: i32\n+}\n+\n+enum Univariant {\n+    Unit(i32)\n+}\n+\n+struct TupleStruct (float, int);\n+\n+\n+fn simple_tuple((a, b): (int, bool)) {\n+    zzz();\n+}\n+\n+fn nested_tuple((a, (b, c)): (int, (u16, u16))) {\n+    zzz();\n+}\n+\n+fn destructure_only_first_level((a, b): (int, (u32, u32))) {\n+    zzz();\n+}\n+\n+fn struct_as_tuple_element((h, i, j): (i16, Struct, i16)) {\n+    zzz();\n+}\n+\n+fn struct_pattern(Struct { a: k, b: l }: Struct) {\n+    zzz();\n+}\n+\n+fn ignored_tuple_element((m, _, n): (int, u16, i32)) {\n+    zzz();\n+}\n+\n+fn ignored_struct_field(Struct { b: o, _ }: Struct) {\n+    zzz();\n+}\n+\n+fn one_struct_destructured_one_not((Struct { a: p, b: q }, r): (Struct, Struct)) {\n+    zzz();\n+}\n+\n+fn different_order_of_struct_fields(Struct { b: s, a: t }: Struct ) {\n+    zzz();\n+}\n+\n+fn complex_nesting(((u,   v  ), ((w,   (x,   Struct { a: y, b: z})), Struct { a: ae, b: oe }), ue ):\n+                   ((i16, i32), ((i64, (i32, Struct,             )), Struct                 ), u16)) {\n+    zzz();\n+}\n+\n+fn managed_box(@aa: @(int, int)) {\n+    zzz();\n+}\n+\n+fn borrowed_pointer(&bb: &(int, int)) {\n+    zzz();\n+}\n+\n+fn contained_borrowed_pointer((&cc, _): (&int, int)) {\n+    zzz();\n+}\n+\n+fn unique_pointer(~dd: ~(int, int, int)) {\n+    zzz();\n+}\n+\n+fn ref_binding(ref ee: (int, int, int)) {\n+    zzz();\n+}\n+\n+fn ref_binding_in_tuple((ref ff, gg): (int, (int, int))) {\n+    zzz();\n+}\n+\n+fn ref_binding_in_struct(Struct { b: ref hh, _ }: Struct) {\n+    zzz();\n+}\n+\n+fn univariant_enum(Unit(ii): Univariant) {\n+    zzz();\n+}\n+\n+fn univariant_enum_with_ref_binding(Unit(ref jj): Univariant) {\n+    zzz();\n+}\n+\n+fn tuple_struct(TupleStruct(kk, ll): TupleStruct) {\n+    zzz();\n+}\n+\n+fn tuple_struct_with_ref_binding(TupleStruct(mm, ref nn): TupleStruct) {\n+    zzz();\n+}\n+\n+fn multiple_arguments((oo, pp): (int, int), qq : int) {\n+    zzz();\n+}\n+\n+fn main() {\n+    simple_tuple((1, false));\n+    nested_tuple((2, (3, 4)));\n+    destructure_only_first_level((5, (6, 7)));\n+    struct_as_tuple_element((8, Struct { a: 9, b: 10 }, 11));\n+    struct_pattern(Struct { a: 12, b: 13 });\n+    ignored_tuple_element((14, 15, 16));\n+    ignored_struct_field(Struct { a: 17, b: 18 });\n+    one_struct_destructured_one_not((Struct { a: 19, b: 20 }, Struct { a: 21, b: 22 }));\n+    different_order_of_struct_fields(Struct { a: 23, b: 24 });\n+    complex_nesting(((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33));\n+    managed_box(@(34, 35));\n+    borrowed_pointer(&(36, 37));\n+    contained_borrowed_pointer((&38, 39));\n+    unique_pointer(~(40, 41, 42));\n+    ref_binding((43, 44, 45));\n+    ref_binding_in_tuple((46, (47, 48)));\n+    ref_binding_in_struct(Struct { a: 49, b: 50 });\n+    univariant_enum(Unit(51));\n+    univariant_enum_with_ref_binding(Unit(52));\n+    tuple_struct(TupleStruct(53.0, 54));\n+    tuple_struct_with_ref_binding(TupleStruct(55.0, 56));\n+    multiple_arguments((57, 58), 59);\n+\n+    fn nested_function(rr: int, (ss, tt): (int, int)) {\n+        zzz();\n+    }\n+\n+    nested_function(60, (61, 62));\n+}\n+\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "f8db7981c941bce78ce7d5b9585196e8e3722a46", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 183, "deletions": 4, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -8,21 +8,200 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n // debugger:finish\n \n // debugger:print a\n-// check:$1 = 9898\n-\n+// check:$1 = 1\n // debugger:print b\n // check:$2 = false\n \n+// debugger:print c\n+// check:$3 = 2\n+// debugger:print d\n+// check:$4 = 3\n+// debugger:print e\n+// check:$5 = 4\n+\n+// debugger:print f\n+// check:$6 = 5\n+// debugger:print g\n+// check:$7 = {6, 7}\n+\n+// debugger:print h\n+// check:$8 = 8\n+// debugger:print i\n+// check:$9 = {a = 9, b = 10}\n+// debugger:print j\n+// check:$10 = 11\n+\n+// debugger:print k\n+// check:$11 = 12\n+// debugger:print l\n+// check:$12 = 13\n+\n+// debugger:print m\n+// check:$13 = 14\n+// debugger:print n\n+// check:$14 = 16\n+\n+// debugger:print o\n+// check:$15 = 18\n+\n+// debugger:print p\n+// check:$16 = 19\n+// debugger:print q\n+// check:$17 = 20\n+// debugger:print r\n+// check:$18 = {a = 21, b = 22}\n+\n+// debugger:print s\n+// check:$19 = 24\n+// debugger:print t\n+// check:$20 = 23\n+\n+// debugger:print u\n+// check:$21 = 25\n+// debugger:print v\n+// check:$22 = 26\n+// debugger:print w\n+// check:$23 = 27\n+// debugger:print x\n+// check:$24 = 28\n+// debugger:print y\n+// check:$25 = 29\n+// debugger:print z\n+// check:$26 = 30\n+// debugger:print ae\n+// check:$27 = 31\n+// debugger:print oe\n+// check:$28 = 32\n+// debugger:print ue\n+// check:$29 = 33\n+\n+// debugger:print aa\n+// check:$30 = {34, 35}\n+\n+// debugger:print bb\n+// check:$31 = {36, 37}\n+\n+// debugger:print cc\n+// check:$32 = 38\n+\n+// debugger:print dd\n+// check:$33 = {40, 41, 42}\n+\n+// debugger:print *ee\n+// check:$34 = {43, 44, 45}\n+\n+// debugger:print *ff\n+// check:$35 = 46\n+\n+// debugger:print gg\n+// check:$36 = {47, 48}\n+\n+// debugger:print *hh\n+// check:$37 = 50\n+\n+// debugger:print ii\n+// check:$38 = 51\n+\n+// debugger:print *jj\n+// check:$39 = 52\n+\n+// debugger:print kk\n+// check:$40 = 53\n+\n+// debugger:print ll\n+// check:$41 = 54\n+\n+// debugger:print mm\n+// check:$42 = 55\n+\n+// debugger:print *nn\n+// check:$43 = 56\n+\n+\n+struct Struct {\n+    a: i64,\n+    b: i32\n+}\n+\n+enum Univariant {\n+    Unit(i32)\n+}\n+\n+struct TupleStruct (float, int);\n+\n+\n fn main() {\n-    let (a, b): (int, bool) = (9898, false);\n+    // simple tuple\n+    let (a, b) : (int, bool) = (1, false);\n+\n+    // nested tuple\n+    let (c, (d, e)) : (int, (u16, u16)) = (2, (3, 4));\n+\n+    // bind tuple-typed value to one name (destructure only first level)\n+    let (f, g) : (int, (u32, u32)) = (5, (6, 7));\n+\n+    // struct as tuple element\n+    let (h, i, j) : (i16, Struct, i16) = (8, Struct { a: 9, b: 10 }, 11);\n+\n+    // struct pattern\n+    let Struct { a: k, b: l } = Struct { a: 12, b: 13 };\n+\n+    // ignored tuple element\n+    let (m, _, n) = (14, 15, 16);\n+\n+    // ignored struct field\n+    let Struct { b: o, _ } = Struct { a: 17, b: 18 };\n+\n+    // one struct destructured, one not\n+    let (Struct { a: p, b: q }, r) = (Struct { a: 19, b: 20 }, Struct { a: 21, b: 22 });\n+\n+    // different order of struct fields\n+    let Struct { b: s, a: t } = Struct { a: 23, b: 24 };\n+\n+    // complex nesting\n+    let ((u, v), ((w, (x, Struct { a: y, b: z})), Struct { a: ae, b: oe }), ue) =\n+        ((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33);\n+\n+    // managed box\n+    let @aa = @(34, 35);\n+\n+    // borrowed pointer\n+    let &bb = &(36, 37);\n+\n+    // contained borrowed pointer\n+    let (&cc, _) = (&38, 39);\n+\n+    // unique pointer\n+    let ~dd = ~(40, 41, 42);\n+\n+    // ref binding\n+    let ref ee = (43, 44, 45);\n+\n+    // ref binding in tuple\n+    let (ref ff, gg) = (46, (47, 48));\n+\n+    // ref binding in struct\n+    let Struct { b: ref hh, _ } = Struct { a: 49, b: 50 };\n+\n+    // univariant enum\n+    let Unit(ii) = Unit(51);\n+\n+    // univariant enum with ref      binding\n+    let Unit(ref jj) = Unit(52);\n+\n+    // tuple struct\n+    let TupleStruct(kk, ll) = TupleStruct(53.0, 54);\n+\n+    // tuple struct with ref binding\n+    let TupleStruct(mm, ref nn) = TupleStruct(55.0, 56);\n \n     zzz();\n }"}, {"sha": "1fe79b8e2a9e903b04ff5fb74b2232f245d918b3", "filename": "src/test/debug-info/function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n@@ -34,7 +34,7 @@ fn main() {\n     nested(2000, 3000);\n \n     fn nested(a: i32, b: i64) -> (i32, i64) {\n-        zzz()\n+        zzz();\n         (a, b)\n     }\n }"}, {"sha": "5b690b9d067c426585a82c2d5c1e1a2e641ef853", "filename": "src/test/debug-info/multiple-functions-equal-var-names.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fmultiple-functions-equal-var-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fmultiple-functions-equal-var-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmultiple-functions-equal-var-names.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print abc\n+// check:$1 = 10101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print abc\n+// check:$2 = 20202\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print abc\n+// check:$3 = 30303\n+\n+fn function_one() {\n+\tlet abc = 10101;\n+\tzzz();\n+}\n+\n+fn function_two() {\n+\tlet abc = 20202;\n+\tzzz();\n+}\n+\n+\n+fn function_three() {\n+\tlet abc = 30303;\n+\tzzz();\n+}\n+\n+\n+fn main() {\n+\tfunction_one();\n+\tfunction_two();\n+\tfunction_three();\n+}\n+\n+fn zzz() {()}"}, {"sha": "aaac723f1613eaf3941ef51851cbc40bd0d8a86a", "filename": "src/test/debug-info/multiple-functions.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fmultiple-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7211948a546596bbe058b4fd3748a24adecaf02/src%2Ftest%2Fdebug-info%2Fmultiple-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmultiple-functions.rs?ref=e7211948a546596bbe058b4fd3748a24adecaf02", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print a\n+// check:$1 = 10101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print b\n+// check:$2 = 20202\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print c\n+// check:$3 = 30303\n+\n+fn function_one() {\n+\tlet a = 10101;\n+\tzzz();\n+}\n+\n+fn function_two() {\n+\tlet b = 20202;\n+\tzzz();\n+}\n+\n+\n+fn function_three() {\n+\tlet c = 30303;\n+\tzzz();\n+}\n+\n+\n+fn main() {\n+\tfunction_one();\n+\tfunction_two();\n+\tfunction_three();\n+}\n+\n+fn zzz() {()}"}]}