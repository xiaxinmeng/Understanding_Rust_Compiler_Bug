{"sha": "1ecdf3abc1cf08e76dbe309e1ee9255f899427f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlY2RmM2FiYzFjZjA4ZTc2ZGJlMzA5ZTFlZTkyNTVmODk5NDI3Zjc=", "commit": {"author": {"name": "Michael Neumann", "email": "mneumann@ntecs.de", "date": "2013-01-25T11:17:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-28T22:40:11Z"}, "message": "Greatly improve performance for TcpSocketBuf.read\n\nFor every call to the read() function the internal buffer was copied\ninto a new buffer (minus the bytes copied into the result buffer). When\nthe internal buffer is large enough, this severely affects performance,\nespecially when read_line() is used which calls read_byte() (which calls\nread()) for each read byte.\n\nFor line oriented I/O this wasn't all that bad, because the internal\nbuffers usually never were very big. The effect is much more visible\nonce the buffer grows larger.\n\nNow we always first look into the internal buffer and copy as many bytes\nas possible (and desired) into the result buffer. If we need more, we\ncall the socket read function and use the result as the new internal\nbuffer, then continue to copy from the (new) internal buffer, and so on.", "tree": {"sha": "9dab5ed5744680b7764cf65181a5ad2f511d5130", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dab5ed5744680b7764cf65181a5ad2f511d5130"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7", "html_url": "https://github.com/rust-lang/rust/commit/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7/comments", "author": {"login": "mneumann", "id": 34112, "node_id": "MDQ6VXNlcjM0MTEy", "avatar_url": "https://avatars.githubusercontent.com/u/34112?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mneumann", "html_url": "https://github.com/mneumann", "followers_url": "https://api.github.com/users/mneumann/followers", "following_url": "https://api.github.com/users/mneumann/following{/other_user}", "gists_url": "https://api.github.com/users/mneumann/gists{/gist_id}", "starred_url": "https://api.github.com/users/mneumann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mneumann/subscriptions", "organizations_url": "https://api.github.com/users/mneumann/orgs", "repos_url": "https://api.github.com/users/mneumann/repos", "events_url": "https://api.github.com/users/mneumann/events{/privacy}", "received_events_url": "https://api.github.com/users/mneumann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "html_url": "https://github.com/rust-lang/rust/commit/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d"}], "stats": {"total": 112, "additions": 77, "deletions": 35}, "files": [{"sha": "b75ddebac8f279e67730184d23a9a4b544c360d3", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ecdf3abc1cf08e76dbe309e1ee9255f899427f7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=1ecdf3abc1cf08e76dbe309e1ee9255f899427f7", "patch": "@@ -72,7 +72,7 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n  */\n pub struct TcpSocketBuf {\n     data: @TcpBufferedSocketData,\n-    mut end_of_stream: bool,\n+    mut end_of_stream: bool\n }\n \n pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n@@ -809,7 +809,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@TcpBufferedSocketData { sock: sock, buf: ~[] })\n+    TcpSocketBuf(@TcpBufferedSocketData { sock: move sock, mut buf: ~[], buf_off: 0 })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n@@ -859,48 +859,89 @@ impl TcpSocket {\n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n     fn read(&self, buf: &[mut u8], len: uint) -> uint {\n-        // Loop until our buffer has enough data in it for us to read from.\n-        while self.data.buf.len() < len {\n-            let read_result = read(&self.data.sock, 0u);\n-            if read_result.is_err() {\n-                let err_data = read_result.get_err();\n+        if len == 0 { return 0 }\n+        let mut count: uint = 0;\n \n-                if err_data.err_name == ~\"EOF\" {\n-                    self.end_of_stream = true;\n-                    break;\n-                } else {\n-                    debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n-                           err_data.err_name, err_data.err_msg);\n+        loop {\n+          assert count < len;\n \n-                    return 0;\n+          // If possible, copy up to `len` bytes from the internal \n+          // `data.buf` into `buf`\n+          let nbuffered = self.data.buf.len() - self.data.buf_off;\n+          let needed = len - count;\n+            if nbuffered > 0 {\n+                unsafe {\n+                    let ncopy = uint::min(nbuffered, needed); \n+                    let dst = ptr::mut_offset(\n+                        vec::raw::to_mut_ptr(buf), count);\n+                    let src = ptr::const_offset(\n+                        vec::raw::to_const_ptr(self.data.buf),\n+                        self.data.buf_off);\n+                    ptr::copy_memory(dst, src, ncopy); \n+                    self.data.buf_off += ncopy;\n+                    count += ncopy;\n                 }\n-            }\n-            else {\n-                self.data.buf.push_all(result::unwrap(read_result));\n-            }\n-        }\n-\n-        let count = uint::min(len, self.data.buf.len());\n-\n-        let mut data = ~[];\n-        self.data.buf <-> data;\n+          }\n \n-        vec::bytes::copy_memory(buf, vec::view(data, 0, data.len()), count);\n+          assert count <= len;\n+          if count == len {\n+              break;\n+          }\n \n-        self.data.buf.push_all(vec::view(data, count, data.len()));\n+          // We copied all the bytes we had in the internal buffer into\n+          // the result buffer, but the caller wants more bytes, so we\n+          // need to read in data from the socket. Note that the internal\n+          // buffer is of no use anymore as we read all bytes from it,\n+          // so we can throw it away.\n+          let read_result = read(&self.data.sock, 0u);\n+          if read_result.is_err() {\n+              let err_data = read_result.get_err();\n+\n+              if err_data.err_name == ~\"EOF\" {\n+                  self.end_of_stream = true;\n+                  break;\n+              } else {\n+                  debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                         err_data.err_name, err_data.err_msg);\n+                  // As we have already copied data into result buffer,\n+                  // we cannot simply return 0 here. Instead the error\n+                  // should show up in a later call to read(). \n+                  break;\n+              }\n+          }\n+          else {\n+              self.data.buf = result::unwrap(read_result);\n+              self.data.buf_off = 0;\n+          }\n+        }\n \n         count\n     }\n     fn read_byte(&self) -> int {\n-        let mut bytes = ~[0];\n-        if self.read(bytes, 1u) == 0 {\n-            if self.end_of_stream {\n-                -1\n-            } else {\n-                fail\n-            }\n-        } else {\n-            bytes[0] as int\n+        loop {\n+          if self.data.buf.len() > self.data.buf_off {\n+            let c = self.data.buf[self.data.buf_off];\n+            self.data.buf_off += 1;\n+            return c as int\n+          }\n+\n+          let read_result = read(&self.data.sock, 0u);\n+          if read_result.is_err() {\n+              let err_data = read_result.get_err();\n+\n+              if err_data.err_name == ~\"EOF\" {\n+                  self.end_of_stream = true;\n+                  return -1\n+              } else {\n+                  debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                         err_data.err_name, err_data.err_msg);\n+                  fail\n+              }\n+          }\n+          else {\n+              self.data.buf = result::unwrap(read_result);\n+              self.data.buf_off = 0;\n+          }\n         }\n     }\n     fn eof(&self) -> bool {\n@@ -1375,6 +1416,7 @@ struct TcpSocketData {\n struct TcpBufferedSocketData {\n     sock: TcpSocket,\n     mut buf: ~[u8],\n+    mut buf_off: uint\n }\n \n //#[cfg(test)]"}]}