{"sha": "59355e99ca6e6124dac22cb1700b7a5320984cb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MzU1ZTk5Y2E2ZTYxMjRkYWMyMmNiMTcwMGI3YTUzMjA5ODRjYjg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T22:08:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T22:08:44Z"}, "message": "tutioral: Discuss basic function syntax is discussed before the memory model", "tree": {"sha": "02b78e0488b55b911e6acca9d3e1c0f9a2f8580c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b78e0488b55b911e6acca9d3e1c0f9a2f8580c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59355e99ca6e6124dac22cb1700b7a5320984cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59355e99ca6e6124dac22cb1700b7a5320984cb8", "html_url": "https://github.com/rust-lang/rust/commit/59355e99ca6e6124dac22cb1700b7a5320984cb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59355e99ca6e6124dac22cb1700b7a5320984cb8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a856bccdc647330624fa36a25190aa63e1274379", "url": "https://api.github.com/repos/rust-lang/rust/commits/a856bccdc647330624fa36a25190aa63e1274379", "html_url": "https://github.com/rust-lang/rust/commit/a856bccdc647330624fa36a25190aa63e1274379"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "c8c2de902d1753fc7aefae7586bd7a6454dd9bb3", "filename": "doc/tutorial.md", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59355e99ca6e6124dac22cb1700b7a5320984cb8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/59355e99ca6e6124dac22cb1700b7a5320984cb8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=59355e99ca6e6124dac22cb1700b7a5320984cb8", "patch": "@@ -876,6 +876,39 @@ while (x > 10) { x -= 10; }\n assert x == 10;\n ~~~~\n \n+# Functions\n+\n+Like all other static declarations, such as `type`, functions can be\n+declared both at the top level and inside other functions (or modules,\n+which we'll come back to in moment).\n+\n+The `ret` keyword immediately returns from a function. It is\n+optionally followed by an expression to return. In functions that\n+return `()`, the returned expression can be left off. A function can\n+also return a value by having its top level block produce an\n+expression (by omitting the final semicolon).\n+\n+Some functions (such as the C function `exit`) never return normally.\n+In Rust, these are annotated with the pseudo-return type '`!`':\n+\n+~~~~\n+fn dead_end() -> ! { fail; }\n+~~~~\n+\n+This helps the compiler avoid spurious error messages. For example,\n+the following code would be a type error if `dead_end` would be\n+expected to return.\n+\n+~~~~\n+# fn can_go_left() -> bool { true }\n+# fn can_go_right() -> bool { true }\n+# enum dir { left, right }\n+# fn dead_end() -> ! { fail; }\n+let dir = if can_go_left() { left }\n+          else if can_go_right() { right }\n+          else { dead_end(); };\n+~~~~\n+\n # The Rust Memory Model\n \n At this junction let's take a detour to explain the concepts involved\n@@ -951,40 +984,7 @@ and the unique pointer (`~T`). These three sigils will appear\n repeatedly as we explore the language. Learning the appropriate role\n of each is key to using Rust effectively.\n \n-# Functions\n-\n-Like all other static declarations, such as `type`, functions can be\n-declared both at the top level and inside other functions (or modules,\n-which we'll come back to in moment).\n-\n-The `ret` keyword immediately returns from a function. It is\n-optionally followed by an expression to return. In functions that\n-return `()`, the returned expression can be left off. A function can\n-also return a value by having its top level block produce an\n-expression (by omitting the final semicolon).\n-\n-Some functions (such as the C function `exit`) never return normally.\n-In Rust, these are annotated with the pseudo-return type '`!`':\n-\n-~~~~\n-fn dead_end() -> ! { fail; }\n-~~~~\n-\n-This helps the compiler avoid spurious error messages. For example,\n-the following code would be a type error if `dead_end` would be\n-expected to return.\n-\n-~~~~\n-# fn can_go_left() -> bool { true }\n-# fn can_go_right() -> bool { true }\n-# enum dir { left, right }\n-# fn dead_end() -> ! { fail; }\n-let dir = if can_go_left() { left }\n-          else if can_go_right() { right }\n-          else { dead_end(); };\n-~~~~\n-\n-## Closures\n+# Closures\n \n Named functions, like those in the previous section, may not refer\n to local variables decalared outside the function - they do not\n@@ -1039,7 +1039,7 @@ position and cannot be stored in structures nor returned from\n functions. Despite the limitations stack closures are used\n pervasively in Rust code.\n \n-### Boxed closures\n+## Boxed closures\n \n When you need to store a closure in a data structure, a stack closure\n will not do, since the compiler will refuse to let you store it. For\n@@ -1081,7 +1081,7 @@ fn mk_appender(suffix: str) -> fn@(str) -> str {\n }\n ~~~~\n \n-### Unique closures\n+## Unique closures\n \n Unique closures, written `fn~` in analogy to the `~` pointer type (see\n next section), hold on to things that can safely be sent between\n@@ -1090,7 +1090,7 @@ closures, but they also 'own' them\u2014meaning no other code can access\n them. Unique closures are used in concurrent code, particularly\n for spawning [tasks](#tasks).\n \n-### Closure compatibility\n+## Closure compatibility\n \n A nice property of Rust closures is that you can pass any kind of\n closure (as long as the arguments and return types match) to functions"}]}