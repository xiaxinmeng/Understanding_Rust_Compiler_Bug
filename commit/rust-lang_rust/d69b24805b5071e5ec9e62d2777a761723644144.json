{"sha": "d69b24805b5071e5ec9e62d2777a761723644144", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OWIyNDgwNWI1MDcxZTVlYzllNjJkMjc3N2E3NjE3MjM2NDQxNDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-27T01:30:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-04T04:21:35Z"}, "message": "rust: Import LLD for linking wasm objects\n\nThis commit imports the LLD project from LLVM to serve as the default linker for\nthe `wasm32-unknown-unknown` target. The `binaryen` submoule is consequently\nremoved along with \"binaryen linker\" support in rustc.\n\nMoving to LLD brings with it a number of benefits for wasm code:\n\n* LLD is itself an actual linker, so there's no need to compile all wasm code\n  with LTO any more. As a result builds should be *much* speedier as LTO is no\n  longer forcibly enabled for all builds of the wasm target.\n* LLD is quickly becoming an \"official solution\" for linking wasm code together.\n  This, I believe at least, is intended to be the main supported linker for\n  native code and wasm moving forward. Picking up support early on should help\n  ensure that we can help LLD identify bugs and otherwise prove that it works\n  great for all our use cases!\n* Improvements to the wasm toolchain are currently primarily focused around LLVM\n  and LLD (from what I can tell at least), so it's in general much better to be\n  on this bandwagon for bugfixes and new features.\n* Historical \"hacks\" like `wasm-gc` will soon no longer be necessary, LLD\n  will [natively implement][gc] `--gc-sections` (better than `wasm-gc`!) which\n  means a postprocessor is no longer needed to show off Rust's \"small wasm\n  binary size\".\n\nLLD is added in a pretty standard way to rustc right now. A new rustbuild target\nwas defined for building LLD, and this is executed when a compiler's sysroot is\nbeing assembled. LLD is compiled against the LLVM that we've got in tree, which\nmeans we're currently on the `release_60` branch, but this may get upgraded in\nthe near future!\n\nLLD is placed into rustc's sysroot in a `bin` directory. This is similar to\nwhere `gcc.exe` can be found on Windows. This directory is automatically added\nto `PATH` whenever rustc executes the linker, allowing us to define a `WasmLd`\nlinker which implements the interface that `wasm-ld`, LLD's frontend, expects.\n\nLike Emscripten the LLD target is currently only enabled for Tier 1 platforms,\nnotably OSX/Windows/Linux, and will need to be installed manually for compiling\nto wasm on other platforms. LLD is by default turned off in rustbuild, and\nrequires a `config.toml` option to be enabled to turn it on.\n\nFinally the unstable `#![wasm_import_memory]` attribute was also removed as LLD\nhas a native option for controlling this.\n\n[gc]: https://reviews.llvm.org/D42511", "tree": {"sha": "f4b8f9d6205f7eb73ddc124457d2bc03f364f292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4b8f9d6205f7eb73ddc124457d2bc03f364f292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69b24805b5071e5ec9e62d2777a761723644144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69b24805b5071e5ec9e62d2777a761723644144", "html_url": "https://github.com/rust-lang/rust/commit/d69b24805b5071e5ec9e62d2777a761723644144", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69b24805b5071e5ec9e62d2777a761723644144/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "html_url": "https://github.com/rust-lang/rust/commit/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3"}], "stats": {"total": 1153, "additions": 408, "deletions": 745}, "files": [{"sha": "55f586389b11766c587af558c66a716cdced1fb9", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -41,9 +41,6 @@\n [submodule \"src/dlmalloc\"]\n \tpath = src/dlmalloc\n \turl = https://github.com/alexcrichton/dlmalloc-rs.git\n-[submodule \"src/binaryen\"]\n-\tpath = src/binaryen\n-\turl = https://github.com/alexcrichton/binaryen.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example\n@@ -53,3 +50,6 @@\n [submodule \"src/stdsimd\"]\n \tpath = src/stdsimd\n \turl = https://github.com/rust-lang-nursery/stdsimd\n+[submodule \"src/tools/lld\"]\n+\tpath = src/tools/lld\n+\turl = https://github.com/rust-lang/lld.git"}, {"sha": "4738f91665dbebe8b2d3d6d9ac6a6f92663c0170", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -81,7 +81,7 @@ matrix:\n     # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-extended --enable-profiler --enable-emscripten\"\n+        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -95,7 +95,7 @@ matrix:\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers --enable-profiler --enable-emscripten\"\n+        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1"}, {"sha": "19ef96fae015c9f851c1c2eed143656bf6d57cdc", "filename": "README.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -129,9 +129,6 @@ CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.\n python x.py build\n ```\n \n-If you are seeing build failure when compiling `rustc_binaryen`, make sure the path\n-length of the rust folder is not longer than 22 characters.\n-\n #### Specifying an ABI\n [specifying-an-abi]: #specifying-an-abi\n "}, {"sha": "0735ead8923cc1e8a4183c1049f81d37161f25eb", "filename": "appveyor.yml", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -67,29 +67,27 @@ environment:\n   # 32/64 bit MSVC and GNU deployment\n   - RUST_CONFIGURE_ARGS: >\n       --build=x86_64-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n-      --enable-emscripten\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n-      --enable-emscripten\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-extended --enable-emscripten\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n     SCRIPT: python x.py dist\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n   - MSYS_BITS: 64\n     SCRIPT: python x.py dist\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-extended --enable-emscripten\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64"}, {"sha": "b47f9163c0dacf7a08a9f93cc46f833e1db078cf", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -329,6 +329,10 @@\n # target, as without this option the test output will not be captured.\n #wasm-syscall = false\n \n+# Indicates whether LLD will be compiled and made available in the sysroot for\n+# rustc to execute.\n+#lld = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "7620fe8ddb3c32886665ac9825c7be92d62ada51", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -1818,15 +1818,6 @@ dependencies = [\n  \"syntax 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_binaryen\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"cc 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cmake 0.1.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc_borrowck\"\n version = \"0.0.0\"\n@@ -2107,7 +2098,6 @@ dependencies = [\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_binaryen 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "17841e155edf858c8ea7802dd5f5ecbef54b989f", "filename": "src/binaryen", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1 +0,0 @@\n-Subproject commit 17841e155edf858c8ea7802dd5f5ecbef54b989f"}, {"sha": "6c3c48aba72f13894745493d47dcf07140b5b249", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -224,7 +224,7 @@ fn main() {\n                 // flesh out rpath support more fully in the future.\n                 cmd.arg(\"-Z\").arg(\"osx-rpath-install-name\");\n                 Some(\"-Wl,-rpath,@loader_path/../lib\")\n-            } else if !target.contains(\"windows\") {\n+            } else if !target.contains(\"windows\") && !target.contains(\"wasm32\") {\n                 Some(\"-Wl,-rpath,$ORIGIN/../lib\")\n             } else {\n                 None"}, {"sha": "d8f7cd7ed9227377fefbfe93a2c9bc16de1f19a5", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -641,6 +641,10 @@ def update_submodules(self):\n                     continue\n                 if self.get_toml('jemalloc'):\n                     continue\n+            if module.endswith(\"lld\"):\n+                config = self.get_toml('lld')\n+                if config is None or config == 'false':\n+                    continue\n             filtered_submodules.append(module)\n         run([\"git\", \"submodule\", \"update\",\n              \"--init\", \"--recursive\"] + filtered_submodules,"}, {"sha": "8cbb1f3d0e9cbcb7e2b272b4827b989c8c12a185", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -316,7 +316,7 @@ impl<'a> Builder<'a> {\n                 tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n-                native::Llvm, tool::Rustfmt, tool::Miri),\n+                native::Llvm, tool::Rustfmt, tool::Miri, native::Lld),\n             Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n             Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n                 test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,"}, {"sha": "9e1b1f7db2f991a7c9774cef39f16331d52cde07", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -79,6 +79,9 @@ pub fn find(build: &mut Build) {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n+        if target.contains(\"msvc\") {\n+            cfg.static_crt(true);\n+        }\n \n         let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {"}, {"sha": "695cf04a82c14ac7acc6a93c4b4173bcdd28e58c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -747,6 +747,21 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     }\n }\n \n+fn copy_lld_to_sysroot(builder: &Builder,\n+                       target_compiler: Compiler,\n+                       lld_install_root: &Path) {\n+    let target = target_compiler.host;\n+\n+    let dst = builder.sysroot_libdir(target_compiler, target)\n+        .parent()\n+        .unwrap()\n+        .join(\"bin\");\n+    t!(fs::create_dir_all(&dst));\n+\n+    let exe = exe(\"lld\", &target);\n+    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+}\n+\n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n@@ -896,6 +911,14 @@ impl Step for Assemble {\n             }\n         }\n \n+        let lld_install = if build.config.lld_enabled && target_compiler.stage > 0 {\n+            Some(builder.ensure(native::Lld {\n+                target: target_compiler.host,\n+            }))\n+        } else {\n+            None\n+        };\n+\n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n         println!(\"Assembling stage{} compiler ({})\", stage, host);\n@@ -915,6 +938,9 @@ impl Step for Assemble {\n         copy_codegen_backends_to_sysroot(builder,\n                                          build_compiler,\n                                          target_compiler);\n+        if let Some(lld_install) = lld_install {\n+            copy_lld_to_sysroot(builder, target_compiler, &lld_install);\n+        }\n \n         // Link the compiler binary itself into place\n         let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);"}, {"sha": "f15d4d358583984d9928158053843d2cc60df0c6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -81,6 +81,8 @@ pub struct Config {\n     pub llvm_experimental_targets: String,\n     pub llvm_link_jobs: Option<u32>,\n \n+    pub lld_enabled: bool,\n+\n     // rust codegen options\n     pub rust_optimize: bool,\n     pub rust_codegen_units: Option<u32>,\n@@ -292,6 +294,7 @@ struct Rust {\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n     wasm_syscall: Option<bool>,\n+    lld: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -480,6 +483,7 @@ impl Config {\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n             set(&mut config.wasm_syscall, rust.wasm_syscall);\n+            set(&mut config.lld_enabled, rust.lld);\n             config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);"}, {"sha": "e9b4a233d0af51ad152afed64f40c281f936671d", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -66,6 +66,7 @@ def v(*args):\n o(\"cargo-openssl-static\", \"build.openssl-static\", \"static openssl in cargo\")\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"emscripten\", None, \"compile the emscripten backend as well as LLVM\")\n+o(\"full-tools\", None, \"enable all tools\")\n \n # Optimization and debugging options. These may be overridden by the release\n # channel, etc.\n@@ -326,6 +327,10 @@ def set(key, value):\n         set('build.target', value.split(','))\n     elif option.name == 'emscripten':\n         set('rust.codegen-backends', ['llvm', 'emscripten'])\n+    elif option.name == 'full-tools':\n+        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+        set('rust.lld', True)\n+        set('build.extended', True)\n     elif option.name == 'option-checking':\n         # this was handled above\n         pass"}, {"sha": "02ef7c0e1ff68cec9bd2e0c46469b8cb58d5e69f", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -28,7 +28,7 @@ use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file};\n+use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -443,6 +443,22 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(&backends_dst));\n             cp_r(&backends_src, &backends_dst);\n \n+            // Copy over lld if it's there\n+            if builder.config.lld_enabled {\n+                let exe = exe(\"lld\", &compiler.host);\n+                let src = builder.sysroot_libdir(compiler, host)\n+                    .parent()\n+                    .unwrap()\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                let dst = image.join(\"lib/rustlib\")\n+                    .join(&*host)\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                t!(fs::create_dir_all(&dst.parent().unwrap()));\n+                copy(&src, &dst);\n+            }\n+\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = build.src.join(\"src/doc/man\");"}, {"sha": "f3d9246c6fc6c192e4299137c31d209705602909", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -501,6 +501,10 @@ impl Build {\n         self.out.join(&*target).join(\"llvm-emscripten\")\n     }\n \n+    fn lld_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"lld\")\n+    }\n+\n     /// Output directory for all documentation for a target\n     fn doc_out(&self, target: Interned<String>) -> PathBuf {\n         self.out.join(&*target).join(\"doc\")\n@@ -685,7 +689,9 @@ impl Build {\n                                                        .and_then(|c| c.linker.as_ref()) {\n             Some(linker)\n         } else if target != self.config.build &&\n-                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+                  !target.contains(\"msvc\") &&\n+                  !target.contains(\"emscripten\") &&\n+                  !target.contains(\"wasm32\") {\n             Some(self.cc(target))\n         } else {\n             None"}, {"sha": "987d70fd047ff204c4df2b43723772f6681eabd6", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 129, "deletions": 69, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -81,11 +81,11 @@ impl Step for Llvm {\n \n         let (out_dir, llvm_config_ret_dir) = if emscripten {\n             let dir = build.emscripten_llvm_out(target);\n-            let config_dir = dir.join(\"bin\");\n+            let config_dir = dir.join(\"build/bin\");\n             (dir, config_dir)\n         } else {\n             (build.llvm_out(target),\n-                build.llvm_out(build.config.build).join(\"bin\"))\n+                build.llvm_out(build.config.build).join(\"build/bin\"))\n         };\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n         let build_llvm_config = llvm_config_ret_dir\n@@ -110,9 +110,6 @@ impl Step for Llvm {\n         // http://llvm.org/docs/CMake.html\n         let root = if self.emscripten { \"src/llvm-emscripten\" } else { \"src/llvm\" };\n         let mut cfg = cmake::Config::new(build.src.join(root));\n-        if build.config.ninja {\n-            cfg.generator(\"Ninja\");\n-        }\n \n         let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n             (false, _) => \"Debug\",\n@@ -139,9 +136,7 @@ impl Step for Llvm {\n \n         let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n-        cfg.target(&target)\n-           .host(&build.build)\n-           .out_dir(&out_dir)\n+        cfg.out_dir(&out_dir)\n            .profile(profile)\n            .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n            .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n@@ -213,67 +208,7 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_NATIVE_BUILD\", build.llvm_out(build.build).join(\"build\"));\n         }\n \n-        let sanitize_cc = |cc: &Path| {\n-            if target.contains(\"msvc\") {\n-                OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n-            } else {\n-                cc.as_os_str().to_owned()\n-            }\n-        };\n-\n-        let configure_compilers = |cfg: &mut cmake::Config| {\n-            // MSVC with CMake uses msbuild by default which doesn't respect these\n-            // vars that we'd otherwise configure. In that case we just skip this\n-            // entirely.\n-            if target.contains(\"msvc\") && !build.config.ninja {\n-                return\n-            }\n-\n-            let cc = build.cc(target);\n-            let cxx = build.cxx(target).unwrap();\n-\n-            // Handle msvc + ninja + ccache specially (this is what the bots use)\n-            if target.contains(\"msvc\") &&\n-               build.config.ninja &&\n-               build.config.ccache.is_some() {\n-                let mut cc = env::current_exe().expect(\"failed to get cwd\");\n-                cc.set_file_name(\"sccache-plus-cl.exe\");\n-\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n-               cfg.env(\"SCCACHE_PATH\",\n-                       build.config.ccache.as_ref().unwrap())\n-                  .env(\"SCCACHE_TARGET\", target);\n-\n-            // If ccache is configured we inform the build a little differently hwo\n-            // to invoke ccache while also invoking our compilers.\n-            } else if let Some(ref ccache) = build.config.ccache {\n-               cfg.define(\"CMAKE_C_COMPILER\", ccache)\n-                  .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", ccache)\n-                  .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n-            } else {\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n-            }\n-\n-            cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n-            cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n-            cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n-            if let Some(ar) = build.ar(target) {\n-                if ar.is_absolute() {\n-                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n-                    // tries to resolve this path in the LLVM build directory.\n-                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n-                }\n-            }\n-        };\n-\n-        configure_compilers(&mut cfg);\n-\n-        if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-            cfg.env(\"RUST_LOG\", \"sccache=warn\");\n-        }\n+        configure_cmake(build, target, &mut cfg);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g. we just want a few components and a few\n@@ -304,6 +239,131 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n }\n \n+fn configure_cmake(build: &Build,\n+                   target: Interned<String>,\n+                   cfg: &mut cmake::Config) {\n+    if build.config.ninja {\n+        cfg.generator(\"Ninja\");\n+    }\n+    cfg.target(&target)\n+       .host(&build.config.build);\n+\n+    let sanitize_cc = |cc: &Path| {\n+        if target.contains(\"msvc\") {\n+            OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n+        } else {\n+            cc.as_os_str().to_owned()\n+        }\n+    };\n+\n+    // MSVC with CMake uses msbuild by default which doesn't respect these\n+    // vars that we'd otherwise configure. In that case we just skip this\n+    // entirely.\n+    if target.contains(\"msvc\") && !build.config.ninja {\n+        return\n+    }\n+\n+    let cc = build.cc(target);\n+    let cxx = build.cxx(target).unwrap();\n+\n+    // Handle msvc + ninja + ccache specially (this is what the bots use)\n+    if target.contains(\"msvc\") &&\n+       build.config.ninja &&\n+       build.config.ccache.is_some() {\n+        let mut cc = env::current_exe().expect(\"failed to get cwd\");\n+        cc.set_file_name(\"sccache-plus-cl.exe\");\n+\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n+       cfg.env(\"SCCACHE_PATH\",\n+               build.config.ccache.as_ref().unwrap())\n+          .env(\"SCCACHE_TARGET\", target);\n+\n+    // If ccache is configured we inform the build a little differently hwo\n+    // to invoke ccache while also invoking our compilers.\n+    } else if let Some(ref ccache) = build.config.ccache {\n+       cfg.define(\"CMAKE_C_COMPILER\", ccache)\n+          .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", ccache)\n+          .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n+    } else {\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+    }\n+\n+    cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n+    cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n+    let mut cxxflags = build.cflags(target).join(\" \");\n+    if build.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n+        cxxflags.push_str(\" -static-libstdc++\");\n+    }\n+    cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n+    if let Some(ar) = build.ar(target) {\n+        if ar.is_absolute() {\n+            // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+            // tries to resolve this path in the LLVM build directory.\n+            cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+        }\n+    }\n+\n+    if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n+        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Lld {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Lld {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/lld\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Lld { target: run.target });\n+    }\n+\n+    /// Compile LLVM for `target`.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let target = self.target;\n+        let build = builder.build;\n+\n+        let llvm_config = builder.ensure(Llvm {\n+            target: self.target,\n+            emscripten: false,\n+        });\n+\n+        let out_dir = build.lld_out(target);\n+        let done_stamp = out_dir.join(\"lld-finished-building\");\n+        if done_stamp.exists() {\n+            return out_dir\n+        }\n+\n+        let _folder = build.fold_output(|| \"lld\");\n+        println!(\"Building LLD for {}\", target);\n+        let _time = util::timeit();\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n+        configure_cmake(build, target, &mut cfg);\n+\n+        cfg.out_dir(&out_dir)\n+           .profile(\"Release\")\n+           .define(\"LLVM_CONFIG_PATH\", llvm_config)\n+           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n+\n+        cfg.build();\n+\n+        t!(File::create(&done_stamp));\n+        out_dir\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TestHelpers {\n     pub target: Interned<String>,"}, {"sha": "c0998c1e42c9773e7ffce7df0aef20ee3adc5a6f", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -914,7 +914,7 @@ impl Step for Compiletest {\n         }\n \n         if build.config.llvm_enabled {\n-            let llvm_config = build.llvm_config(target);\n+            let llvm_config = build.llvm_config(build.config.build);\n             let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n             cmd.arg(\"--llvm-version\").arg(llvm_version);\n             if !build.is_rust_llvm(target) {"}, {"sha": "0ec57ee08868716098f19a4e6aa9bf0067123305", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -82,10 +82,9 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=i686-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler \\\n-      --enable-emscripten\n+      --enable-profiler\n ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "3b98b0aa926bd1250915725724ca5af9356a7b9d", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -82,10 +82,9 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=x86_64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler \\\n-      --enable-emscripten\n+      --enable-profiler\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "0972eb85191a94b7134f23df7f22a7fa064b38f4", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -22,7 +22,8 @@ RUN sh /scripts/sccache.sh\n ENV TARGETS=wasm32-unknown-unknown\n \n ENV RUST_CONFIGURE_ARGS \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node\n+  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n+  --set rust.lld\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n   src/test/ui \\"}, {"sha": "98d6202a63fbf75468bcf71206a540329d8efa9b", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -107,6 +107,8 @@ imports.env = {\n   exp2f: function(x) { return Math.pow(2, x); },\n   ldexp: function(x, y) { return x * Math.pow(2, y); },\n   ldexpf: function(x, y) { return x * Math.pow(2, y); },\n+  log: Math.log,\n+  log2: Math.log2,\n   log10: Math.log10,\n   log10f: Math.log10,\n "}, {"sha": "141c8954a3306bdaefc0452b798bdc70beddeec3", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -43,47 +43,57 @@ use std::str::FromStr;\n \n use serialize::json::{Json, ToJson};\n \n-macro_rules! linker_flavor {\n-    ($(($variant:ident, $string:expr),)+) => {\n-        #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        pub enum LinkerFlavor {\n-            $($variant,)+\n-        }\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub enum LinkerFlavor {\n+    Em,\n+    Gcc,\n+    Ld,\n+    Msvc,\n+    Lld(LldFlavor),\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub enum LldFlavor {\n+    Wasm,\n+}\n \n+impl ToJson for LinkerFlavor {\n+    fn to_json(&self) -> Json {\n+        self.desc().to_json()\n+    }\n+}\n+macro_rules! flavor_mappings {\n+    ($((($($flavor:tt)*), $string:expr),)*) => (\n         impl LinkerFlavor {\n             pub const fn one_of() -> &'static str {\n                 concat!(\"one of: \", $($string, \" \",)+)\n             }\n \n             pub fn from_str(s: &str) -> Option<Self> {\n                 Some(match s {\n-                    $($string => LinkerFlavor::$variant,)+\n+                    $($string => $($flavor)*,)+\n                     _ => return None,\n                 })\n             }\n \n             pub fn desc(&self) -> &str {\n                 match *self {\n-                    $(LinkerFlavor::$variant => $string,)+\n+                    $($($flavor)* => $string,)+\n                 }\n             }\n         }\n-\n-        impl ToJson for LinkerFlavor {\n-            fn to_json(&self) -> Json {\n-                self.desc().to_json()\n-            }\n-        }\n-    }\n+    )\n }\n \n-linker_flavor! {\n-    (Em, \"em\"),\n-    (Binaryen, \"binaryen\"),\n-    (Gcc, \"gcc\"),\n-    (Ld, \"ld\"),\n-    (Msvc, \"msvc\"),\n+\n+flavor_mappings! {\n+    ((LinkerFlavor::Em), \"em\"),\n+    ((LinkerFlavor::Gcc), \"gcc\"),\n+    ((LinkerFlavor::Ld), \"ld\"),\n+    ((LinkerFlavor::Msvc), \"msvc\"),\n+    ((LinkerFlavor::Lld(LldFlavor::Wasm)), \"wasm-ld\"),\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "c771762cfc89bb590a18c29722feb81345e4320e", "filename": "src/librustc_back/target/wasm32_unknown_unknown.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -8,40 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The wasm32-unknown-unknown target is currently a highly experimental version\n-// of a wasm-based target which does *not* use the Emscripten toolchain. Instead\n-// this is a pretty flavorful (aka hacked up) target right now. The definition\n-// and semantics of this target are likely to change and so this shouldn't be\n-// relied on just yet.\n+// The wasm32-unknown-unknown target is currently an experimental version of a\n+// wasm-based target which does *not* use the Emscripten toolchain. Instead\n+// this toolchain is based purely on LLVM's own toolchain, using LLVM's native\n+// WebAssembly backend as well as LLD for a native linker.\n //\n-// In general everyone is currently waiting on a linker for wasm code. In the\n-// meantime we have no means of actually making use of the traditional separate\n-// compilation model. At a high level this means that assembling Rust programs\n-// into a WebAssembly program looks like:\n-//\n-//  1. All intermediate artifacts are LLVM bytecode. We'll be using LLVM as\n-//     a linker later on.\n-//  2. For the final artifact we emit one giant assembly file (WebAssembly\n-//     doesn't have an object file format). To do this we force LTO to be turned\n-//     on (`requires_lto` below) to ensure all Rust code is in one module. Any\n-//     \"linked\" C library is basically just ignored.\n-//  3. Using LLVM we emit a `foo.s` file (assembly) with some... what I can only\n-//     describe as arcane syntax. From there we need to actually change this\n-//     into a wasm module. For this step we use the `binaryen` project. This\n-//     project is mostly intended as a WebAssembly code generator, but for now\n-//     we're just using its LLVM-assembly-to-wasm-module conversion utilities.\n-//\n-// And voila, out comes a web assembly module! There's some various tweaks here\n-// and there, but that's the high level at least. Note that this will be\n-// rethought from the ground up once a linker (lld) is available, so this is all\n-// temporary and should improve in the future.\n+// There's some trickery below on crate types supported and various defaults\n+// (aka panic=abort by default), but otherwise this is in general a relatively\n+// standard target.\n \n-use LinkerFlavor;\n+use {LinkerFlavor, LldFlavor};\n use super::{Target, TargetOptions, PanicStrategy};\n \n pub fn target() -> Result<Target, String> {\n     let opts = TargetOptions {\n-        linker: \"not-used\".to_string(),\n+        linker: \"lld\".to_string(),\n \n         // we allow dynamic linking, but only cdylibs. Basically we allow a\n         // final library artifact that exports some symbols (a wasm module) but\n@@ -58,9 +39,6 @@ pub fn target() -> Result<Target, String> {\n         dll_suffix: \".wasm\".to_string(),\n         linker_is_gnu: false,\n \n-        // We're storing bitcode for now in all the rlibs\n-        obj_is_bitcode: true,\n-\n         // A bit of a lie, but \"eh\"\n         max_atomic_width: Some(32),\n \n@@ -69,27 +47,17 @@ pub fn target() -> Result<Target, String> {\n         // the future once unwinding is implemented. Don't rely on this.\n         panic_strategy: PanicStrategy::Abort,\n \n-        // There's no linker yet so we're forced to use LLVM as a linker. This\n-        // means that we must always enable LTO for final artifacts.\n-        requires_lto: true,\n-\n         // Wasm doesn't have atomics yet, so tell LLVM that we're in a single\n         // threaded model which will legalize atomics to normal operations.\n         singlethread: true,\n \n-        // Because we're always enabling LTO we can't enable builtin lowering as\n-        // otherwise we'll lower the definition of the `memcpy` function to\n-        // memcpy itself. Note that this is specifically because we're\n-        // performing LTO with compiler-builtins.\n-        no_builtins: true,\n-\n         // no dynamic linking, no need for default visibility!\n         default_hidden_visibility: true,\n \n         .. Default::default()\n     };\n     Ok(Target {\n-        llvm_target: \"wasm32-unknown-unknown\".to_string(),\n+        llvm_target: \"wasm32-unknown-unknown-wasm\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n         target_c_int_width: \"32\".to_string(),\n@@ -100,8 +68,7 @@ pub fn target() -> Result<Target, String> {\n         target_vendor: \"unknown\".to_string(),\n         data_layout: \"e-m:e-p:32:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"wasm32\".to_string(),\n-        // A bit of a lie, but it gets the job done\n-        linker_flavor: LinkerFlavor::Binaryen,\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Wasm),\n         options: opts,\n     })\n }"}, {"sha": "55f11665f6d0ba83a157680b9ce433bfeab5f02a", "filename": "src/librustc_binaryen/BinaryenWrapper.cpp", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This is a small C API inserted on top of the Binaryen C++ API which we use\n-// from Rust. Once we have a real linker for we'll be able to remove all this,\n-// and otherwise this is just all on a \"as we need it\" basis for now.\n-\n-#include <stdint.h>\n-#include <string>\n-#include <sstream>\n-#include <stdlib.h>\n-\n-#include \"s2wasm.h\"\n-#include \"wasm-binary.h\"\n-#include \"wasm-linker.h\"\n-\n-using namespace wasm;\n-\n-struct BinaryenRustModule {\n-  BufferWithRandomAccess buffer;\n-  std::string sourceMapJSON;\n-};\n-\n-struct BinaryenRustModuleOptions {\n-  uint64_t globalBase;\n-  bool debug;\n-  uint64_t stackAllocation;\n-  uint64_t initialMem;\n-  uint64_t maxMem;\n-  bool importMemory;\n-  bool ignoreUnknownSymbols;\n-  bool debugInfo;\n-  std::string startFunction;\n-  std::string sourceMapUrl;\n-\n-  BinaryenRustModuleOptions() :\n-    globalBase(0),\n-    debug(false),\n-    stackAllocation(0),\n-    initialMem(0),\n-    maxMem(0),\n-    importMemory(false),\n-    ignoreUnknownSymbols(false),\n-    debugInfo(false),\n-    startFunction(\"\"),\n-    sourceMapUrl(\"\")\n-  {}\n-\n-};\n-\n-extern \"C\" BinaryenRustModuleOptions*\n-BinaryenRustModuleOptionsCreate() {\n-  return new BinaryenRustModuleOptions;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsFree(BinaryenRustModuleOptions *options) {\n-  delete options;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsSetDebugInfo(BinaryenRustModuleOptions *options,\n-                                      bool debugInfo) {\n-  options->debugInfo = debugInfo;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsSetStart(BinaryenRustModuleOptions *options,\n-                                  char *start) {\n-  options->startFunction = start;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsSetSourceMapUrl(BinaryenRustModuleOptions *options,\n-                                         char *sourceMapUrl) {\n-  options->sourceMapUrl = sourceMapUrl;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsSetStackAllocation(BinaryenRustModuleOptions *options,\n-                                            uint64_t stack) {\n-  options->stackAllocation = stack;\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleOptionsSetImportMemory(BinaryenRustModuleOptions *options,\n-                                         bool import) {\n-  options->importMemory = import;\n-}\n-\n-extern \"C\" BinaryenRustModule*\n-BinaryenRustModuleCreate(const BinaryenRustModuleOptions *options,\n-                         const char *assembly) {\n-  Linker linker(\n-      options->globalBase,\n-      options->stackAllocation,\n-      options->initialMem,\n-      options->maxMem,\n-      options->importMemory,\n-      options->ignoreUnknownSymbols,\n-      options->startFunction,\n-      options->debug);\n-\n-  S2WasmBuilder mainbuilder(assembly, options->debug);\n-  linker.linkObject(mainbuilder);\n-  linker.layout();\n-\n-  auto ret = make_unique<BinaryenRustModule>();\n-  {\n-    WasmBinaryWriter writer(&linker.getOutput().wasm, ret->buffer, options->debug);\n-    writer.setNamesSection(options->debugInfo);\n-\n-    std::unique_ptr<std::ostringstream> sourceMapStream = nullptr;\n-    {\n-      sourceMapStream = make_unique<std::ostringstream>();\n-      writer.setSourceMap(sourceMapStream.get(), options->sourceMapUrl);\n-    }\n-\n-    // FIXME: support symbol maps?\n-    // writer.setSymbolMap(symbolMap);\n-    writer.write();\n-\n-    if (sourceMapStream) {\n-      ret->sourceMapJSON = sourceMapStream->str();\n-    }\n-  }\n-  return ret.release();\n-}\n-\n-extern \"C\" const uint8_t*\n-BinaryenRustModulePtr(const BinaryenRustModule *M) {\n-  return M->buffer.data();\n-}\n-\n-extern \"C\" size_t\n-BinaryenRustModuleLen(const BinaryenRustModule *M) {\n-  return M->buffer.size();\n-}\n-\n-extern \"C\" const char*\n-BinaryenRustModuleSourceMapPtr(const BinaryenRustModule *M) {\n-  return M->sourceMapJSON.data();\n-}\n-\n-extern \"C\" size_t\n-BinaryenRustModuleSourceMapLen(const BinaryenRustModule *M) {\n-  return M->sourceMapJSON.length();\n-}\n-\n-extern \"C\" void\n-BinaryenRustModuleFree(BinaryenRustModule *M) {\n-  delete M;\n-}"}, {"sha": "9573c89471404d7877437cee350fa27b3cf97830", "filename": "src/librustc_binaryen/Cargo.toml", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2FCargo.toml?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,16 +0,0 @@\n-# Wondering what this crate is? Take a look at the `lib.rs`!\n-\n-[package]\n-name = \"rustc_binaryen\"\n-version = \"0.0.0\"\n-authors = [\"The Rust Project Developers\"]\n-\n-[lib]\n-path = \"lib.rs\"\n-\n-[dependencies]\n-libc = \"0.2\"\n-\n-[build-dependencies]\n-cmake = \"0.1\"\n-cc = \"1.0\""}, {"sha": "f23ff3cee555bba7c48cb6d6b5eee3b857b680da", "filename": "src/librustc_binaryen/build.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2Fbuild.rs?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate cc;\n-extern crate cmake;\n-\n-use std::env;\n-\n-use cmake::Config;\n-\n-fn main() {\n-    let target = env::var(\"TARGET\").unwrap();\n-\n-    // Bring in `__emutls_get_address` which is apparently needed for now\n-    if target.contains(\"pc-windows-gnu\") {\n-        println!(\"cargo:rustc-link-lib=gcc_eh\");\n-        println!(\"cargo:rustc-link-lib=pthread\");\n-    }\n-\n-    Config::new(\"../binaryen\")\n-        .define(\"BUILD_STATIC_LIB\", \"ON\")\n-        .build_target(\"binaryen\")\n-        .build();\n-\n-    // I couldn't figure out how to link just one of these, so link everything.\n-    println!(\"cargo:rustc-link-lib=static=asmjs\");\n-    println!(\"cargo:rustc-link-lib=static=binaryen\");\n-    println!(\"cargo:rustc-link-lib=static=cfg\");\n-    println!(\"cargo:rustc-link-lib=static=emscripten-optimizer\");\n-    println!(\"cargo:rustc-link-lib=static=ir\");\n-    println!(\"cargo:rustc-link-lib=static=passes\");\n-    println!(\"cargo:rustc-link-lib=static=support\");\n-    println!(\"cargo:rustc-link-lib=static=wasm\");\n-\n-    let out_dir = env::var(\"OUT_DIR\").unwrap();\n-    println!(\"cargo:rustc-link-search=native={}/build/lib\", out_dir);\n-\n-    // Add in our own little shim along with some extra files that weren't\n-    // included in the main build.\n-    let mut cfg = cc::Build::new();\n-    cfg.file(\"BinaryenWrapper.cpp\")\n-        .file(\"../binaryen/src/wasm-linker.cpp\")\n-        .file(\"../binaryen/src/wasm-emscripten.cpp\")\n-        .include(\"../binaryen/src\")\n-        .cpp_link_stdlib(None)\n-        .warnings(false)\n-        .cpp(true);\n-\n-    if !target.contains(\"msvc\") {\n-        cfg.flag(\"-std=c++11\");\n-    }\n-    cfg.compile(\"binaryen_wrapper\");\n-}"}, {"sha": "36174e11ba04a988012f7724e537dd41c0bfb339", "filename": "src/librustc_binaryen/lib.rs", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Flibrustc_binaryen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2Flib.rs?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,172 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rustc bindings to the binaryen project.\n-//!\n-//! This crate is a small shim around the binaryen project which provides us the\n-//! ability to take LLVM's output and generate a wasm module. Specifically this\n-//! only supports one operation, creating a module from LLVM's assembly format\n-//! and then serializing that module to a wasm module.\n-\n-extern crate libc;\n-\n-use std::slice;\n-use std::ffi::{CString, CStr};\n-\n-/// In-memory representation of a serialized wasm module.\n-pub struct Module {\n-    ptr: *mut BinaryenRustModule,\n-}\n-\n-impl Module {\n-    /// Creates a new wasm module from the LLVM-assembly provided (in a C string\n-    /// format).\n-    ///\n-    /// The actual module creation can be tweaked through the various options in\n-    /// `ModuleOptions` as well. Any errors are just returned as a bland string.\n-    pub fn new(assembly: &CStr, opts: &ModuleOptions) -> Result<Module, String> {\n-        unsafe {\n-            let ptr = BinaryenRustModuleCreate(opts.ptr, assembly.as_ptr());\n-            if ptr.is_null() {\n-                Err(format!(\"failed to create binaryen module\"))\n-            } else {\n-                Ok(Module { ptr })\n-            }\n-        }\n-    }\n-\n-    /// Returns the data of the serialized wasm module. This is a `foo.wasm`\n-    /// file contents.\n-    pub fn data(&self) -> &[u8] {\n-        unsafe {\n-            let ptr = BinaryenRustModulePtr(self.ptr);\n-            let len = BinaryenRustModuleLen(self.ptr);\n-            slice::from_raw_parts(ptr, len)\n-        }\n-    }\n-\n-    /// Returns the data of the source map JSON.\n-    pub fn source_map(&self) -> &[u8] {\n-        unsafe {\n-            let ptr = BinaryenRustModuleSourceMapPtr(self.ptr);\n-            let len = BinaryenRustModuleSourceMapLen(self.ptr);\n-            slice::from_raw_parts(ptr, len)\n-        }\n-    }\n-}\n-\n-impl Drop for Module {\n-    fn drop(&mut self) {\n-        unsafe {\n-            BinaryenRustModuleFree(self.ptr);\n-        }\n-    }\n-}\n-\n-pub struct ModuleOptions {\n-    ptr: *mut BinaryenRustModuleOptions,\n-}\n-\n-impl ModuleOptions {\n-    pub fn new() -> ModuleOptions {\n-        unsafe {\n-            let ptr = BinaryenRustModuleOptionsCreate();\n-            ModuleOptions { ptr }\n-        }\n-    }\n-\n-    /// Turns on or off debug info.\n-    ///\n-    /// From what I can tell this just creates a \"names\" section of the wasm\n-    /// module which contains a table of the original function names.\n-    pub fn debuginfo(&mut self, debug: bool) -> &mut Self {\n-        unsafe {\n-            BinaryenRustModuleOptionsSetDebugInfo(self.ptr, debug);\n-        }\n-        self\n-    }\n-\n-    /// Configures a `start` function for the module, to be executed when it's\n-    /// loaded.\n-    pub fn start(&mut self, func: &str) -> &mut Self {\n-        let func = CString::new(func).unwrap();\n-        unsafe {\n-            BinaryenRustModuleOptionsSetStart(self.ptr, func.as_ptr());\n-        }\n-        self\n-    }\n-\n-    /// Configures a `sourceMappingURL` custom section value for the module.\n-    pub fn source_map_url(&mut self, url: &str) -> &mut Self {\n-        let url = CString::new(url).unwrap();\n-        unsafe {\n-            BinaryenRustModuleOptionsSetSourceMapUrl(self.ptr, url.as_ptr());\n-        }\n-        self\n-    }\n-\n-    /// Configures how much stack is initially allocated for the module. 1MB is\n-    /// probably good enough for now.\n-    pub fn stack(&mut self, amt: u64) -> &mut Self {\n-        unsafe {\n-            BinaryenRustModuleOptionsSetStackAllocation(self.ptr, amt);\n-        }\n-        self\n-    }\n-\n-    /// Flags whether the initial memory should be imported or exported. So far\n-    /// we export it by default.\n-    pub fn import_memory(&mut self, import: bool) -> &mut Self {\n-        unsafe {\n-            BinaryenRustModuleOptionsSetImportMemory(self.ptr, import);\n-        }\n-        self\n-    }\n-}\n-\n-impl Drop for ModuleOptions {\n-    fn drop(&mut self) {\n-        unsafe {\n-            BinaryenRustModuleOptionsFree(self.ptr);\n-        }\n-    }\n-}\n-\n-enum BinaryenRustModule {}\n-enum BinaryenRustModuleOptions {}\n-\n-extern {\n-    fn BinaryenRustModuleCreate(opts: *const BinaryenRustModuleOptions,\n-                                assembly: *const libc::c_char)\n-        -> *mut BinaryenRustModule;\n-    fn BinaryenRustModulePtr(module: *const BinaryenRustModule) -> *const u8;\n-    fn BinaryenRustModuleLen(module: *const BinaryenRustModule) -> usize;\n-    fn BinaryenRustModuleSourceMapPtr(module: *const BinaryenRustModule) -> *const u8;\n-    fn BinaryenRustModuleSourceMapLen(module: *const BinaryenRustModule) -> usize;\n-    fn BinaryenRustModuleFree(module: *mut BinaryenRustModule);\n-\n-    fn BinaryenRustModuleOptionsCreate()\n-        -> *mut BinaryenRustModuleOptions;\n-    fn BinaryenRustModuleOptionsSetDebugInfo(module: *mut BinaryenRustModuleOptions,\n-                                             debuginfo: bool);\n-    fn BinaryenRustModuleOptionsSetStart(module: *mut BinaryenRustModuleOptions,\n-                                         start: *const libc::c_char);\n-    fn BinaryenRustModuleOptionsSetSourceMapUrl(module: *mut BinaryenRustModuleOptions,\n-                                                sourceMapUrl: *const libc::c_char);\n-    fn BinaryenRustModuleOptionsSetStackAllocation(\n-        module: *mut BinaryenRustModuleOptions,\n-        stack: u64,\n-    );\n-    fn BinaryenRustModuleOptionsSetImportMemory(\n-        module: *mut BinaryenRustModuleOptions,\n-        import: bool,\n-    );\n-    fn BinaryenRustModuleOptionsFree(module: *mut BinaryenRustModuleOptions);\n-}"}, {"sha": "4b9c93088a517dc5aab846b88e305a319099ef82", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -21,7 +21,6 @@ rustc-demangle = \"0.1.4\"\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_binaryen = { path = \"../librustc_binaryen\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "e5e0a4e3ba0edee18939c0555ac7b029b0841cbf", "filename": "src/librustc_trans/back/command.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -17,6 +17,8 @@ use std::io;\n use std::mem;\n use std::process::{self, Output};\n \n+use rustc_back::LldFlavor;\n+\n #[derive(Clone)]\n pub struct Command {\n     program: Program,\n@@ -28,6 +30,7 @@ pub struct Command {\n enum Program {\n     Normal(OsString),\n     CmdBatScript(OsString),\n+    Lld(OsString, LldFlavor)\n }\n \n impl Command {\n@@ -39,6 +42,10 @@ impl Command {\n         Command::_new(Program::CmdBatScript(program.as_ref().to_owned()))\n     }\n \n+    pub fn lld<P: AsRef<OsStr>>(program: P, flavor: LldFlavor) -> Command {\n+        Command::_new(Program::Lld(program.as_ref().to_owned(), flavor))\n+    }\n+\n     fn _new(program: Program) -> Command {\n         Command {\n             program,\n@@ -101,6 +108,13 @@ impl Command {\n                 c.arg(\"/c\").arg(p);\n                 c\n             }\n+            Program::Lld(ref p, flavor) => {\n+                let mut c = process::Command::new(p);\n+                c.arg(\"-flavor\").arg(match flavor {\n+                    LldFlavor::Wasm => \"wasm\",\n+                });\n+                c\n+            }\n         };\n         ret.args(&self.args);\n         ret.envs(self.env.clone());"}, {"sha": "c134203a773fea5a78a38532b8dafd7786dad37c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -15,6 +15,7 @@ use super::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n+use rustc_back::LinkerFlavor;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n use rustc::session::config::{RUST_CGU_EXT, Lto};\n use rustc::session::filesearch;\n@@ -27,7 +28,7 @@ use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n use tempdir::TempDir;\n-use rustc_back::{PanicStrategy, RelroLevel, LinkerFlavor};\n+use rustc_back::{PanicStrategy, RelroLevel};\n use context::get_reloc_model;\n use llvm;\n \n@@ -82,6 +83,10 @@ pub fn get_linker(sess: &Session) -> (PathBuf, Command, Vec<(OsString, OsString)\n     } else if sess.target.target.options.is_like_msvc {\n         let (cmd, envs) = msvc_link_exe_cmd(sess);\n         (PathBuf::from(\"link.exe\"), cmd, envs)\n+    } else if let LinkerFlavor::Lld(f) = sess.linker_flavor() {\n+        let linker = PathBuf::from(&sess.target.target.options.linker);\n+        let cmd = Command::lld(&linker, f);\n+        (linker, cmd, envs)\n     } else {\n         let linker = PathBuf::from(&sess.target.target.options.linker);\n         let cmd = cmd(&linker);\n@@ -612,11 +617,6 @@ fn link_natively(sess: &Session,\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n \n-    // The \"binaryen linker\" is massively special, so skip everything below.\n-    if flavor == LinkerFlavor::Binaryen {\n-        return link_binaryen(sess, crate_type, out_filename, trans, tmpdir);\n-    }\n-\n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd, envs) = get_linker(sess);\n     // This will set PATH on windows\n@@ -1485,33 +1485,6 @@ fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     }\n }\n \n-/// For now \"linking with binaryen\" is just \"move the one module we generated in\n-/// the backend to the final output\"\n-///\n-/// That is, all the heavy lifting happens during the `back::write` phase. Here\n-/// we just clean up after that.\n-///\n-/// Note that this is super temporary and \"will not survive the night\", this is\n-/// guaranteed to get removed as soon as a linker for wasm exists. This should\n-/// not be used for anything other than wasm.\n-fn link_binaryen(sess: &Session,\n-                 _crate_type: config::CrateType,\n-                 out_filename: &Path,\n-                 trans: &CrateTranslation,\n-                 _tmpdir: &Path) {\n-    assert!(trans.allocator_module.is_none());\n-    assert_eq!(trans.modules.len(), 1);\n-\n-    let object = trans.modules[0].object.as_ref().expect(\"object must exist\");\n-    let res = fs::hard_link(object, out_filename)\n-        .or_else(|_| fs::copy(object, out_filename).map(|_| ()));\n-    if let Err(e) = res {\n-        sess.fatal(&format!(\"failed to create `{}`: {}\",\n-                            out_filename.display(),\n-                            e));\n-    }\n-}\n-\n fn is_full_lto_enabled(sess: &Session) -> bool {\n     match sess.lto() {\n         Lto::Yes |"}, {"sha": "a82270c5272b9e919b0bcb9200bc7eeea28e82c3", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n use rustc::ty::TyCtxt;\n-use rustc_back::LinkerFlavor;\n+use rustc_back::{LinkerFlavor, LldFlavor};\n use serialize::{json, Encoder};\n \n /// For all the linkers we support, and information they might\n@@ -77,8 +77,11 @@ impl LinkerInfo {\n                     is_ld: true,\n                 }) as Box<Linker>\n             }\n-            LinkerFlavor::Binaryen => {\n-                panic!(\"can't instantiate binaryen linker\")\n+\n+            LinkerFlavor::Lld(LldFlavor::Wasm) => {\n+                Box::new(WasmLd {\n+                    cmd,\n+                }) as Box<Linker>\n             }\n         }\n     }\n@@ -785,3 +788,111 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n \n     symbols\n }\n+\n+pub struct WasmLd {\n+    cmd: Command,\n+}\n+\n+impl Linker for WasmLd {\n+    fn link_dylib(&mut self, lib: &str) {\n+        self.cmd.arg(\"-l\").arg(lib);\n+    }\n+\n+    fn link_staticlib(&mut self, lib: &str) {\n+        self.cmd.arg(\"-l\").arg(lib);\n+    }\n+\n+    fn link_rlib(&mut self, lib: &Path) {\n+        self.cmd.arg(lib);\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        self.cmd.arg(\"-L\").arg(path);\n+    }\n+\n+    fn framework_path(&mut self, _path: &Path) {\n+        panic!(\"frameworks not supported\")\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        self.cmd.arg(\"-o\").arg(path);\n+    }\n+\n+    fn add_object(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn position_independent_executable(&mut self) {\n+    }\n+\n+    fn partial_relro(&mut self) {\n+    }\n+\n+    fn full_relro(&mut self) {\n+    }\n+\n+    fn build_static_executable(&mut self) {\n+    }\n+\n+    fn args(&mut self, args: &[String]) {\n+        self.cmd.args(args);\n+    }\n+\n+    fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+        self.cmd.arg(\"-l\").arg(lib);\n+    }\n+\n+    fn link_framework(&mut self, _framework: &str) {\n+        panic!(\"frameworks not supported\")\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {\n+        self.cmd.arg(\"-l\").arg(lib);\n+    }\n+\n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.cmd.arg(lib);\n+    }\n+\n+    fn gc_sections(&mut self, _keep_metadata: bool) {\n+    }\n+\n+    fn optimize(&mut self) {\n+    }\n+\n+    fn debuginfo(&mut self) {\n+    }\n+\n+    fn no_default_libraries(&mut self) {\n+    }\n+\n+    fn build_dylib(&mut self, _out_filename: &Path) {\n+    }\n+\n+    fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {\n+    }\n+\n+    fn subsystem(&mut self, _subsystem: &str) {\n+    }\n+\n+    fn no_position_independent_executable(&mut self) {\n+    }\n+\n+    fn finalize(&mut self) -> Command {\n+        self.cmd.arg(\"--threads\");\n+\n+        // FIXME we probably shouldn't pass this but instead pass an explicit\n+        // whitelist of symbols we'll allow to be undefined. Unfortunately\n+        // though we can't handle symbols like `log10` that LLVM injects at a\n+        // super late date without actually parsing object files. For now let's\n+        // stick to this and hopefully fix it before stabilization happens.\n+        self.cmd.arg(\"--allow-undefined\");\n+\n+        // For now we just never have an entry symbol\n+        self.cmd.arg(\"--no-entry\");\n+\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n+}"}, {"sha": "55ef4e7ed3ae528736f414ecc4dc04666d123fa3", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -21,7 +21,6 @@ use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::FxHashMap;\n use rustc_allocator::ALLOCATOR_METHODS;\n-use rustc_back::LinkerFlavor;\n use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n@@ -156,26 +155,12 @@ pub fn provide_extern(providers: &mut Providers) {\n         let special_runtime_crate =\n             tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n \n-        // Dealing with compiler-builtins and wasm right now is super janky.\n-        // There's no linker! As a result we need all of the compiler-builtins\n-        // exported symbols to make their way through all the way to the end of\n-        // compilation. We want to make sure that LLVM doesn't remove them as\n-        // well because we may or may not need them in the final output\n-        // artifact. For now just force them to always get exported at the C\n-        // layer, and we'll worry about gc'ing them later.\n-        let compiler_builtins_and_binaryen =\n-            tcx.is_compiler_builtins(cnum) &&\n-            tcx.sess.linker_flavor() == LinkerFlavor::Binaryen;\n-\n         let mut crate_exports: Vec<_> = tcx\n             .exported_symbol_ids(cnum)\n             .iter()\n             .map(|&def_id| {\n                 let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = if compiler_builtins_and_binaryen &&\n-                                      tcx.contains_extern_indicator(def_id) {\n-                    SymbolExportLevel::C\n-                } else if special_runtime_crate {\n+                let export_level = if special_runtime_crate {\n                     // We can probably do better here by just ensuring that\n                     // it has hidden visibility rather than public\n                     // visibility, as this is primarily here to ensure it's"}, {"sha": "1664aa9d0b3a399309f377461cd4973515fc2b8a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 8, "deletions": 77, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -23,7 +23,6 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, SomePass\n                              AllPasses, Sanitizer, Lto};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_back::LinkerFlavor;\n use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n@@ -344,9 +343,7 @@ pub struct CodegenContext {\n     pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n-    binaryen_linker: bool,\n     debuginfo: config::DebugInfoLevel,\n-    wasm_import_memory: bool,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -639,13 +636,6 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         f(cpm)\n     }\n \n-    // If we're going to generate wasm code from the assembly that llvm\n-    // generates then we'll be transitively affecting a ton of options below.\n-    // This only happens on the wasm target now.\n-    let asm2wasm = cgcx.binaryen_linker &&\n-        !cgcx.crate_types.contains(&config::CrateTypeRlib) &&\n-        mtrans.kind == ModuleKind::Regular;\n-\n     // If we don't have the integrated assembler, then we need to emit asm\n     // from LLVM and use `gcc` to create the object file.\n     let asm_to_obj = config.emit_obj && config.no_integrated_as;\n@@ -654,10 +644,10 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     // just llvm bitcode. In that case write bitcode, and possibly\n     // delete the bitcode if it wasn't requested. Don't generate the\n     // machine code, instead copy the .o file from the .bc\n-    let write_bc = config.emit_bc || (config.obj_is_bitcode && !asm2wasm);\n-    let rm_bc = !config.emit_bc && config.obj_is_bitcode && !asm2wasm;\n-    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm2wasm && !asm_to_obj;\n-    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode && !asm2wasm;\n+    let write_bc = config.emit_bc || config.obj_is_bitcode;\n+    let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n+    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm_to_obj;\n+    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n     let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n     let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n@@ -736,13 +726,13 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             timeline.record(\"ir\");\n         }\n \n-        if config.emit_asm || (asm2wasm && config.emit_obj) || asm_to_obj {\n+        if config.emit_asm || asm_to_obj {\n             let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n             // module to produce the asm output\n-            let llmod = if config.emit_obj && !asm2wasm {\n+            let llmod = if config.emit_obj {\n                 llvm::LLVMCloneModule(llmod)\n             } else {\n                 llmod\n@@ -751,24 +741,13 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                 write_output_file(diag_handler, tm, cpm, llmod, &path,\n                                   llvm::FileType::AssemblyFile)\n             })?;\n-            if config.emit_obj && !asm2wasm {\n+            if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n             timeline.record(\"asm\");\n         }\n \n-        if asm2wasm && config.emit_obj {\n-            let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-            let suffix = \".wasm.map\"; // FIXME use target suffix\n-            let map = cgcx.output_filenames.path(OutputType::Exe)\n-                .with_extension(&suffix[1..]);\n-            binaryen_assemble(cgcx, diag_handler, &assembly, &obj_out, &map);\n-            timeline.record(\"binaryen\");\n-\n-            if !config.emit_asm {\n-                drop(fs::remove_file(&assembly));\n-            }\n-        } else if write_obj {\n+        if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n@@ -808,49 +787,6 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                                    &cgcx.output_filenames))\n }\n \n-/// Translates the LLVM-generated `assembly` on the filesystem into a wasm\n-/// module using binaryen, placing the output at `object`.\n-///\n-/// In this case the \"object\" is actually a full and complete wasm module. We\n-/// won't actually be doing anything else to the output for now. This is all\n-/// pretty janky and will get removed as soon as a linker for wasm exists.\n-fn binaryen_assemble(cgcx: &CodegenContext,\n-                     handler: &Handler,\n-                     assembly: &Path,\n-                     object: &Path,\n-                     map: &Path) {\n-    use rustc_binaryen::{Module, ModuleOptions};\n-\n-    let input = fs::read(&assembly).and_then(|contents| {\n-        Ok(CString::new(contents)?)\n-    });\n-    let mut options = ModuleOptions::new();\n-    if cgcx.debuginfo != config::NoDebugInfo {\n-        options.debuginfo(true);\n-        let map_file_name = map.file_name().unwrap();\n-        options.source_map_url(map_file_name.to_str().unwrap());\n-    }\n-\n-    options.stack(1024 * 1024);\n-    options.import_memory(cgcx.wasm_import_memory);\n-    let assembled = input.and_then(|input| {\n-        Module::new(&input, &options)\n-            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))\n-    });\n-    let err = assembled.and_then(|binary| {\n-        fs::write(&object, binary.data()).and_then(|()| {\n-            if cgcx.debuginfo != config::NoDebugInfo {\n-                fs::write(map, binary.source_map())\n-            } else {\n-                Ok(())\n-            }\n-        })\n-    });\n-    if let Err(e) = err {\n-        handler.err(&format!(\"failed to run binaryen assembler: {}\", e));\n-    }\n-}\n-\n pub(crate) struct CompiledModules {\n     pub modules: Vec<CompiledModule>,\n     pub metadata_module: CompiledModule,\n@@ -1431,9 +1367,6 @@ fn start_executing_work(tcx: TyCtxt,\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n-    let wasm_import_memory =\n-        attr::contains_name(&tcx.hir.krate().attrs, \"wasm_import_memory\");\n-\n     let assembler_cmd = if modules_config.no_integrated_as {\n         // HACK: currently we use linker (gcc) as our assembler\n         let (name, mut cmd, _) = get_linker(sess);\n@@ -1471,9 +1404,7 @@ fn start_executing_work(tcx: TyCtxt,\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n-        binaryen_linker: tcx.sess.linker_flavor() == LinkerFlavor::Binaryen,\n         debuginfo: tcx.sess.opts.debuginfo,\n-        wasm_import_memory,\n         assembler_cmd,\n     };\n "}, {"sha": "51ad17fe2051fe82340741c0186b398c7b2d4088", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -49,7 +49,6 @@ extern crate rustc_mir;\n extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_back;\n-extern crate rustc_binaryen;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_demangle;"}, {"sha": "058df1d516909f9f8e48e6db56ca78c1d7bd629e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -414,9 +414,6 @@ declare_features! (\n     // Allow trait methods with arbitrary self types\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874)),\n \n-    // #![wasm_import_memory] attribute\n-    (active, wasm_import_memory, \"1.22.0\", None),\n-\n     // `crate` in paths\n     (active, crate_in_paths, \"1.23.0\", Some(45477)),\n \n@@ -985,11 +982,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                         never be stable\",\n                                                        cfg_fn!(rustc_attrs))),\n \n-    (\"wasm_import_memory\", Whitelisted, Gated(Stability::Unstable,\n-                                 \"wasm_import_memory\",\n-                                 \"wasm_import_memory attribute is currently unstable\",\n-                                 cfg_fn!(wasm_import_memory))),\n-\n     (\"rustc_args_required_const\", Whitelisted, Gated(Stability::Unstable,\n                                  \"rustc_attrs\",\n                                  \"never will be stable\","}, {"sha": "3616ab9e6c7303b9f8f5283353dae062fa0c68f3", "filename": "src/test/run-pass/issue-15487.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Ftest%2Frun-pass%2Fissue-15487.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Ftest%2Frun-pass%2Fissue-15487.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15487.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-windows\n+// ignore-wasm32-bare no libs to link\n \n #![feature(link_args)]\n "}, {"sha": "a010ebb3551d0f7a13c9db60b046a1eb0a841625", "filename": "src/test/ui/feature-gate-wasm_import_memory.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.rs?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![wasm_import_memory] //~ ERROR: currently unstable\n-\n-fn main() {}\n-"}, {"sha": "0ec502724672ae5fc221ee7288054d382090b6b5", "filename": "src/test/ui/feature-gate-wasm_import_memory.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_memory.stderr?ref=0be38e1ce3dcfe6402b3bd9617f74857fe7fa8c3", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: wasm_import_memory attribute is currently unstable\n-  --> $DIR/feature-gate-wasm_import_memory.rs:11:1\n-   |\n-LL | #![wasm_import_memory] //~ ERROR: currently unstable\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(wasm_import_memory)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-If you want more information on this error, try using \"rustc --explain E0658\""}, {"sha": "b87873eaceb75cf9342d5273f01ba2c020f61ca8", "filename": "src/tools/lld", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flld?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -0,0 +1 @@\n+Subproject commit b87873eaceb75cf9342d5273f01ba2c020f61ca8"}, {"sha": "5134c869912611ba6fb9e220568189eb4583205c", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69b24805b5071e5ec9e62d2777a761723644144/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69b24805b5071e5ec9e62d2777a761723644144/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=d69b24805b5071e5ec9e62d2777a761723644144", "patch": "@@ -50,7 +50,6 @@ pub mod unstable_book;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n-        \"src/binaryen\",\n         \"src/dlmalloc\",\n         \"src/jemalloc\",\n         \"src/llvm\",\n@@ -68,6 +67,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/rust-installer\",\n         \"src/tools/rustfmt\",\n         \"src/tools/miri\",\n+        \"src/tools/lld\",\n         \"src/librustc/mir/interpret\",\n         \"src/librustc_mir/interpret\",\n         \"src/target\","}]}