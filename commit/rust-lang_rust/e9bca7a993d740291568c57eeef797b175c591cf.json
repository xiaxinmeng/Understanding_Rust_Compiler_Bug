{"sha": "e9bca7a993d740291568c57eeef797b175c591cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YmNhN2E5OTNkNzQwMjkxNTY4YzU3ZWVlZjc5N2IxNzVjNTkxY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T12:20:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T12:20:18Z"}, "message": "Auto merge of #55906 - nnethercote:rm-OpenSnapshot-CommittedSnapshot, r=nikomatsakis\n\nClean up and streamline snapshot data structures\n\nThese commits clean up the snapshot structures a bit, so they are more consistent with each other and with the `ena` crate.\n\nThey also remove the `OpenSnapshot` and `CommittedSnapshot` entries in the undo log, just like I did for the `ena` crate in https://github.com/rust-lang-nursery/ena/pull/14. This PR in combination with that `ena` PR reduces instruction counts by up to 6% on benchmarks.\n\nr? @nikomatsakis. Note that this isn't quite ready for landing, because the `ena` dependency in the first commit needs to be updated once https://github.com/rust-lang-nursery/ena/pull/14 lands. But otherwise it should be good.", "tree": {"sha": "159713b642b10c25dd4b31cb5571322e742b6d19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/159713b642b10c25dd4b31cb5571322e742b6d19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9bca7a993d740291568c57eeef797b175c591cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bca7a993d740291568c57eeef797b175c591cf", "html_url": "https://github.com/rust-lang/rust/commit/e9bca7a993d740291568c57eeef797b175c591cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9bca7a993d740291568c57eeef797b175c591cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe19a730576cf7ead1bf7995271b53d551ea37f", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe19a730576cf7ead1bf7995271b53d551ea37f", "html_url": "https://github.com/rust-lang/rust/commit/abe19a730576cf7ead1bf7995271b53d551ea37f"}, {"sha": "94967ae8c1129d63df4446240df4fc45a57c8164", "url": "https://api.github.com/repos/rust-lang/rust/commits/94967ae8c1129d63df4446240df4fc45a57c8164", "html_url": "https://github.com/rust-lang/rust/commit/94967ae8c1129d63df4446240df4fc45a57c8164"}], "stats": {"total": 214, "additions": 96, "deletions": 118}, "files": [{"sha": "a7b83f87b191b9ff835f0d9f0da2420a1bed14bc", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -661,7 +661,7 @@ dependencies = [\n \n [[package]]\n name = \"ena\"\n-version = \"0.10.1\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2230,7 +2230,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3295,7 +3295,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum elasticlunr-rs 2.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4837d77a1e157489a3933b743fd774ae75074e0e390b2b7f071530048a0d87ee\"\n-\"checksum ena 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25b4e5febb25f08c49f1b07dc33a182729a6b21edfb562b5aef95f78e0dbe5bb\"\n+\"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n \"checksum ena 0.9.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88dc8393b3c7352f94092497f6b52019643e493b6b890eb417cdb7c46117e621\"\n \"checksum env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f4d7e69c283751083d53d01eac767407343b8b69c4bd70058e08adc2637cb257\"\n \"checksum env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\""}, {"sha": "16140e748aa1e3c5a28889283309f1d5e2207e42", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -554,11 +554,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\"pop_placeholders({:?})\", placeholder_map);\n         let placeholder_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n-        self.borrow_region_constraints()\n-            .pop_placeholders(\n-                &placeholder_regions,\n-                &snapshot.region_constraints_snapshot,\n-            );\n+        self.borrow_region_constraints().pop_placeholders(&placeholder_regions);\n         self.universe.set(snapshot.universe);\n         if !placeholder_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_placeholder("}, {"sha": "d8beae45b0ad481243db4a8600258f6e699e1c58", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -790,7 +790,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.projection_cache\n             .borrow_mut()\n-            .commit(&projection_cache_snapshot);\n+            .commit(projection_cache_snapshot);\n         self.type_variables.borrow_mut().commit(type_snapshot);\n         self.int_unification_table.borrow_mut().commit(int_snapshot);\n         self.float_unification_table"}, {"sha": "af1b6964b818967abf4933d2a40c6cc30a2b9b17", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -11,7 +11,7 @@\n //! See README.md\n \n use self::CombineMapType::*;\n-use self::UndoLogEntry::*;\n+use self::UndoLog::*;\n \n use super::unify_key;\n use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n@@ -52,14 +52,17 @@ pub struct RegionConstraintCollector<'tcx> {\n \n     /// The undo log records actions that might later be undone.\n     ///\n-    /// Note: when the undo_log is empty, we are not actively\n+    /// Note: `num_open_snapshots` is used to track if we are actively\n     /// snapshotting. When the `start_snapshot()` method is called, we\n-    /// push an OpenSnapshot entry onto the list to indicate that we\n-    /// are now actively snapshotting. The reason for this is that\n-    /// otherwise we end up adding entries for things like the lower\n-    /// bound on a variable and so forth, which can never be rolled\n-    /// back.\n-    undo_log: Vec<UndoLogEntry<'tcx>>,\n+    /// increment `num_open_snapshots` to indicate that we are now actively\n+    /// snapshotting. The reason for this is that otherwise we end up adding\n+    /// entries for things like the lower bound on a variable and so forth,\n+    /// which can never be rolled back.\n+    undo_log: Vec<UndoLog<'tcx>>,\n+\n+    /// The number of open snapshots, i.e. those that haven't been committed or\n+    /// rolled back.\n+    num_open_snapshots: usize,\n \n     /// When we add a R1 == R2 constriant, we currently add (a) edges\n     /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n@@ -254,15 +257,7 @@ struct TwoRegions<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum UndoLogEntry<'tcx> {\n-    /// Pushed when we start a snapshot.\n-    OpenSnapshot,\n-\n-    /// Replaces an `OpenSnapshot` when a snapshot is committed, but\n-    /// that snapshot is not the root. If the root snapshot is\n-    /// unrolled, all nested snapshots must be committed.\n-    CommitedSnapshot,\n-\n+enum UndoLog<'tcx> {\n     /// We added `RegionVid`\n     AddVar(RegionVid),\n \n@@ -387,6 +382,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             glbs,\n             bound_count: _,\n             undo_log: _,\n+            num_open_snapshots: _,\n             unification_table,\n             any_unifications,\n         } = self;\n@@ -415,53 +411,60 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     fn in_snapshot(&self) -> bool {\n-        !self.undo_log.is_empty()\n+        self.num_open_snapshots > 0\n     }\n \n     pub fn start_snapshot(&mut self) -> RegionSnapshot {\n         let length = self.undo_log.len();\n         debug!(\"RegionConstraintCollector: start_snapshot({})\", length);\n-        self.undo_log.push(OpenSnapshot);\n+        self.num_open_snapshots += 1;\n         RegionSnapshot {\n             length,\n             region_snapshot: self.unification_table.snapshot(),\n             any_unifications: self.any_unifications,\n         }\n     }\n \n+    fn assert_open_snapshot(&self, snapshot: &RegionSnapshot) {\n+        assert!(self.undo_log.len() >= snapshot.length);\n+        assert!(self.num_open_snapshots > 0);\n+    }\n+\n     pub fn commit(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n-        assert!(self.undo_log.len() > snapshot.length);\n-        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+        self.assert_open_snapshot(&snapshot);\n \n-        if snapshot.length == 0 {\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.length == 0);\n             self.undo_log.clear();\n-        } else {\n-            (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n+\n+        self.num_open_snapshots -= 1;\n+\n         self.unification_table.commit(snapshot.region_snapshot);\n     }\n \n     pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: rollback_to({:?})\", snapshot);\n-        assert!(self.undo_log.len() > snapshot.length);\n-        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-        while self.undo_log.len() > snapshot.length + 1 {\n+        self.assert_open_snapshot(&snapshot);\n+\n+        while self.undo_log.len() > snapshot.length {\n             let undo_entry = self.undo_log.pop().unwrap();\n             self.rollback_undo_entry(undo_entry);\n         }\n-        let c = self.undo_log.pop().unwrap();\n-        assert!(c == OpenSnapshot);\n+\n+        self.num_open_snapshots -= 1;\n+\n         self.unification_table.rollback_to(snapshot.region_snapshot);\n         self.any_unifications = snapshot.any_unifications;\n     }\n \n-    fn rollback_undo_entry(&mut self, undo_entry: UndoLogEntry<'tcx>) {\n+    fn rollback_undo_entry(&mut self, undo_entry: UndoLog<'tcx>) {\n         match undo_entry {\n-            OpenSnapshot => {\n-                panic!(\"Failure to observe stack discipline\");\n-            }\n-            Purged | CommitedSnapshot => {\n+            Purged => {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n@@ -521,15 +524,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// in `skols`. This is used after a higher-ranked operation\n     /// completes to remove all trace of the placeholder regions\n     /// created in that time.\n-    pub fn pop_placeholders(\n-        &mut self,\n-        placeholders: &FxHashSet<ty::Region<'tcx>>,\n-        snapshot: &RegionSnapshot,\n-    ) {\n+    pub fn pop_placeholders(&mut self, placeholders: &FxHashSet<ty::Region<'tcx>>) {\n         debug!(\"pop_placeholders(placeholders={:?})\", placeholders);\n \n         assert!(self.in_snapshot());\n-        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n         let constraints_to_kill: Vec<usize> = self.undo_log\n             .iter()\n@@ -548,7 +546,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         fn kill_constraint<'tcx>(\n             placeholders: &FxHashSet<ty::Region<'tcx>>,\n-            undo_entry: &UndoLogEntry<'tcx>,\n+            undo_entry: &UndoLog<'tcx>,\n         ) -> bool {\n             match undo_entry {\n                 &AddConstraint(Constraint::VarSubVar(..)) => false,\n@@ -562,7 +560,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 &AddCombination(_, ref two_regions) => {\n                     placeholders.contains(&two_regions.a) || placeholders.contains(&two_regions.b)\n                 }\n-                &AddVar(..) | &OpenSnapshot | &Purged | &CommitedSnapshot => false,\n+                &AddVar(..) | &Purged => false,\n             }\n         }\n     }"}, {"sha": "27ce7f106030aebbd9ddc449a6dfeebceeb29a20", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> TaintSet<'tcx> {\n     pub(super) fn fixed_point(\n         &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        undo_log: &[UndoLogEntry<'tcx>],\n+        undo_log: &[UndoLog<'tcx>],\n         verifys: &[Verify<'tcx>],\n     ) {\n         let mut prev_len = 0;\n@@ -65,8 +65,7 @@ impl<'tcx> TaintSet<'tcx> {\n                             \"we never add verifications while doing higher-ranked things\",\n                         )\n                     }\n-                    &Purged | &AddCombination(..) | &AddVar(..) | &OpenSnapshot\n-                    | &CommitedSnapshot => {}\n+                    &Purged | &AddCombination(..) | &AddVar(..) => {}\n                 }\n             }\n         }"}, {"sha": "1d3d66e82f14cc2048ed1e03fd9a017a2ec906a7", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -1652,15 +1652,15 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.rollback_to(&snapshot.snapshot);\n+        self.map.rollback_to(snapshot.snapshot);\n     }\n \n     pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n         self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_placeholders());\n     }\n \n-    pub fn commit(&mut self, snapshot: &ProjectionCacheSnapshot) {\n-        self.map.commit(&snapshot.snapshot);\n+    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.commit(snapshot.snapshot);\n     }\n \n     /// Try to start normalize `key`; returns an error if\n@@ -1714,12 +1714,8 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// to be a NormalizedTy.\n     pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n         // We want to insert `ty` with no obligations. If the existing value\n-        // already has no obligations (as is common) we can use `insert_noop`\n-        // to do a minimal amount of work -- the HashMap insertion is skipped,\n-        // and minimal changes are made to the undo log.\n-        if ty.obligations.is_empty() {\n-            self.map.insert_noop();\n-        } else {\n+        // already has no obligations (as is common) we don't insert anything.\n+        if !ty.obligations.is_empty() {\n             self.map.insert(key, ProjectionCacheEntry::NormalizedTy(Normalized {\n                 value: ty.value,\n                 obligations: vec![]"}, {"sha": "188919d063351cbe390a275d4a3c3646a0c0e986", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -9,7 +9,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-ena = \"0.10.1\"\n+ena = \"0.11\"\n log = \"0.4\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "c256506a19d4299a94c0cb0c1d591c794e7cfafc", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -21,6 +21,7 @@ pub struct SnapshotMap<K, V>\n {\n     map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,\n+    num_open_snapshots: usize,\n }\n \n // HACK(eddyb) manual impl avoids `Default` bounds on `K` and `V`.\n@@ -31,6 +32,7 @@ impl<K, V> Default for SnapshotMap<K, V>\n         SnapshotMap {\n             map: Default::default(),\n             undo_log: Default::default(),\n+            num_open_snapshots: 0,\n         }\n     }\n }\n@@ -40,11 +42,9 @@ pub struct Snapshot {\n }\n \n enum UndoLog<K, V> {\n-    OpenSnapshot,\n-    CommittedSnapshot,\n     Inserted(K),\n     Overwrite(K, V),\n-    Noop,\n+    Purged,\n }\n \n impl<K, V> SnapshotMap<K, V>\n@@ -53,35 +53,34 @@ impl<K, V> SnapshotMap<K, V>\n     pub fn clear(&mut self) {\n         self.map.clear();\n         self.undo_log.clear();\n+        self.num_open_snapshots = 0;\n+    }\n+\n+    fn in_snapshot(&self) -> bool {\n+        self.num_open_snapshots > 0\n     }\n \n     pub fn insert(&mut self, key: K, value: V) -> bool {\n         match self.map.insert(key.clone(), value) {\n             None => {\n-                if !self.undo_log.is_empty() {\n+                if self.in_snapshot() {\n                     self.undo_log.push(UndoLog::Inserted(key));\n                 }\n                 true\n             }\n             Some(old_value) => {\n-                if !self.undo_log.is_empty() {\n+                if self.in_snapshot() {\n                     self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 }\n                 false\n             }\n         }\n     }\n \n-    pub fn insert_noop(&mut self) {\n-        if !self.undo_log.is_empty() {\n-            self.undo_log.push(UndoLog::Noop);\n-        }\n-    }\n-\n     pub fn remove(&mut self, key: K) -> bool {\n         match self.map.remove(&key) {\n             Some(old_value) => {\n-                if !self.undo_log.is_empty() {\n+                if self.in_snapshot() {\n                     self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 }\n                 true\n@@ -95,27 +94,27 @@ impl<K, V> SnapshotMap<K, V>\n     }\n \n     pub fn snapshot(&mut self) -> Snapshot {\n-        self.undo_log.push(UndoLog::OpenSnapshot);\n-        let len = self.undo_log.len() - 1;\n+        let len = self.undo_log.len();\n+        self.num_open_snapshots += 1;\n         Snapshot { len }\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n-        assert!(snapshot.len < self.undo_log.len());\n-        assert!(match self.undo_log[snapshot.len] {\n-            UndoLog::OpenSnapshot => true,\n-            _ => false,\n-        });\n+        assert!(self.undo_log.len() >= snapshot.len);\n+        assert!(self.num_open_snapshots > 0);\n     }\n \n-    pub fn commit(&mut self, snapshot: &Snapshot) {\n-        self.assert_open_snapshot(snapshot);\n-        if snapshot.len == 0 {\n-            // The root snapshot.\n-            self.undo_log.truncate(0);\n-        } else {\n-            self.undo_log[snapshot.len] = UndoLog::CommittedSnapshot;\n+    pub fn commit(&mut self, snapshot: Snapshot) {\n+        self.assert_open_snapshot(&snapshot);\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.len == 0);\n+            self.undo_log.clear();\n         }\n+\n+        self.num_open_snapshots -= 1;\n     }\n \n     pub fn partial_rollback<F>(&mut self,\n@@ -124,45 +123,32 @@ impl<K, V> SnapshotMap<K, V>\n         where F: Fn(&K) -> bool\n     {\n         self.assert_open_snapshot(snapshot);\n-        for i in (snapshot.len + 1..self.undo_log.len()).rev() {\n+        for i in (snapshot.len .. self.undo_log.len()).rev() {\n             let reverse = match self.undo_log[i] {\n-                UndoLog::OpenSnapshot => false,\n-                UndoLog::CommittedSnapshot => false,\n-                UndoLog::Noop => false,\n+                UndoLog::Purged => false,\n                 UndoLog::Inserted(ref k) => should_revert_key(k),\n                 UndoLog::Overwrite(ref k, _) => should_revert_key(k),\n             };\n \n             if reverse {\n-                let entry = mem::replace(&mut self.undo_log[i], UndoLog::Noop);\n+                let entry = mem::replace(&mut self.undo_log[i], UndoLog::Purged);\n                 self.reverse(entry);\n             }\n         }\n     }\n \n-    pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n-        self.assert_open_snapshot(snapshot);\n-        while self.undo_log.len() > snapshot.len + 1 {\n+    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n+        self.assert_open_snapshot(&snapshot);\n+        while self.undo_log.len() > snapshot.len {\n             let entry = self.undo_log.pop().unwrap();\n             self.reverse(entry);\n         }\n \n-        let v = self.undo_log.pop().unwrap();\n-        assert!(match v {\n-            UndoLog::OpenSnapshot => true,\n-            _ => false,\n-        });\n-        assert!(self.undo_log.len() == snapshot.len);\n+        self.num_open_snapshots -= 1;\n     }\n \n     fn reverse(&mut self, entry: UndoLog<K, V>) {\n         match entry {\n-            UndoLog::OpenSnapshot => {\n-                panic!(\"cannot rollback an uncommitted snapshot\");\n-            }\n-\n-            UndoLog::CommittedSnapshot => {}\n-\n             UndoLog::Inserted(key) => {\n                 self.map.remove(&key);\n             }\n@@ -171,7 +157,7 @@ impl<K, V> SnapshotMap<K, V>\n                 self.map.insert(key, old_value);\n             }\n \n-            UndoLog::Noop => {}\n+            UndoLog::Purged => {}\n         }\n     }\n }"}, {"sha": "b4ecb85fc43023b78eebd68169abea23be3eacb4", "filename": "src/librustc_data_structures/snapshot_map/test.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -17,10 +17,10 @@ fn basic() {\n     let snapshot = map.snapshot();\n     map.insert(22, \"thirty-three\");\n     assert_eq!(map[&22], \"thirty-three\");\n-    map.insert(44, \"fourty-four\");\n-    assert_eq!(map[&44], \"fourty-four\");\n+    map.insert(44, \"forty-four\");\n+    assert_eq!(map[&44], \"forty-four\");\n     assert_eq!(map.get(&33), None);\n-    map.rollback_to(&snapshot);\n+    map.rollback_to(snapshot);\n     assert_eq!(map[&22], \"twenty-two\");\n     assert_eq!(map.get(&33), None);\n     assert_eq!(map.get(&44), None);\n@@ -32,8 +32,11 @@ fn out_of_order() {\n     let mut map = SnapshotMap::default();\n     map.insert(22, \"twenty-two\");\n     let snapshot1 = map.snapshot();\n-    let _snapshot2 = map.snapshot();\n-    map.rollback_to(&snapshot1);\n+    map.insert(33, \"thirty-three\");\n+    let snapshot2 = map.snapshot();\n+    map.insert(44, \"forty-four\");\n+    map.rollback_to(snapshot1); // bogus, but accepted\n+    map.rollback_to(snapshot2); // asserts\n }\n \n #[test]\n@@ -43,8 +46,8 @@ fn nested_commit_then_rollback() {\n     let snapshot1 = map.snapshot();\n     let snapshot2 = map.snapshot();\n     map.insert(22, \"thirty-three\");\n-    map.commit(&snapshot2);\n+    map.commit(snapshot2);\n     assert_eq!(map[&22], \"thirty-three\");\n-    map.rollback_to(&snapshot1);\n+    map.rollback_to(snapshot1);\n     assert_eq!(map[&22], \"twenty-two\");\n }"}]}