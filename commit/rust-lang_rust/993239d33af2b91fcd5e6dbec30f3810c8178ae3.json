{"sha": "993239d33af2b91fcd5e6dbec30f3810c8178ae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MzIzOWQzM2FmMmI5MWZjZDVlNmRiZWMzMGYzODEwYzgxNzhhZTM=", "commit": {"author": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-19T22:04:01Z"}, "committer": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-19T23:04:06Z"}, "message": "Initial implementation of lossy cast lints.\n\nIntroduces 3 lints :\n  cast_possible_overflow\n  cast_precision_loss\n  cast_sign_loss\nAdd a compile-test test case.\nFix errors spotted by dogfood script.", "tree": {"sha": "b9293cd66c994ca9d86daad4340a3c035a6e4064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9293cd66c994ca9d86daad4340a3c035a6e4064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/993239d33af2b91fcd5e6dbec30f3810c8178ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/993239d33af2b91fcd5e6dbec30f3810c8178ae3", "html_url": "https://github.com/rust-lang/rust/commit/993239d33af2b91fcd5e6dbec30f3810c8178ae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/993239d33af2b91fcd5e6dbec30f3810c8178ae3/comments", "author": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150840667e4bc1782e6947cc53af94a37281ab38", "url": "https://api.github.com/repos/rust-lang/rust/commits/150840667e4bc1782e6947cc53af94a37281ab38", "html_url": "https://github.com/rust-lang/rust/commit/150840667e4bc1782e6947cc53af94a37281ab38"}], "stats": {"total": 274, "additions": 223, "deletions": 51}, "files": [{"sha": "df097ca9e3ffb2bddba2ffd54c36080098347a87", "filename": "README.md", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/993239d33af2b91fcd5e6dbec30f3810c8178ae3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/993239d33af2b91fcd5e6dbec30f3810c8178ae3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=993239d33af2b91fcd5e6dbec30f3810c8178ae3", "patch": "@@ -6,47 +6,50 @@ A collection of lints that give helpful tips to newbies and catch oversights.\n ##Lints\n Lints included in this crate:\n \n-name                 | default | meaning\n----------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-approx_constant      | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n-bad_bit_mask         | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n-box_vec              | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n-cmp_nan              | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n-cmp_owned            | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n-collapsible_if       | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n-eq_op                | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n-explicit_iter_loop   | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n-float_cmp            | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n-identity_op          | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n-ineffective_bit_mask | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n-inline_always        | warn    | `#[inline(always)]` is a bad idea in most cases\n-iter_next_loop       | warn    | for-looping over `_.next()` which is probably not intended\n-len_without_is_empty | warn    | traits and impls that have `.len()` but not `.is_empty()`\n-len_zero             | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n-let_and_return       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n-let_unit_value       | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n-linkedlist           | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n-modulo_one           | warn    | taking a number modulo 1, which always returns 0\n-mut_mut              | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n-needless_bool        | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n-needless_lifetimes   | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n-needless_range_loop  | warn    | for-looping over a range of indices where an iterator over items would do\n-needless_return      | warn    | using a return statement like `return expr;` where an expression would suffice\n-non_ascii_literal    | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n-option_unwrap_used   | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n-precedence           | warn    | expressions where precedence may trip up the unwary reader of the source; suggests adding parentheses, e.g. `x << 2 + y` will be parsed as `x << (2 + y)`\n-ptr_arg              | allow   | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n-range_step_by_zero   | warn    | using Range::step_by(0), which produces an infinite iterator\n-redundant_closure    | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n-result_unwrap_used   | allow   | using `Result.unwrap()`, which might be better handled\n-single_match         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n-str_to_string        | warn    | using `to_string()` on a str, which should be `to_owned()`\n-string_add           | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n-string_add_assign    | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n-string_to_string     | warn    | calling `String.to_string()` which is a no-op\n-toplevel_ref_arg     | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n-unit_cmp             | warn    | comparing unit values (which is always `true` or `false`, respectively)\n-zero_width_space     | deny    | using a zero-width space in a string literal, which is confusing\n+name                   | default | meaning\n+-----------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n+approx_constant        | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+bad_bit_mask           | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+box_vec                | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n+cast_possible_overflow | allow   | casts that may cause overflow\n+cast_precision_loss    | allow   | casts that cause loss of precision\n+cast_sign_loss         | allow   | casts from signed types to unsigned types\n+cmp_nan                | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n+cmp_owned              | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n+collapsible_if         | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n+eq_op                  | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+explicit_iter_loop     | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+float_cmp              | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n+identity_op            | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n+ineffective_bit_mask   | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n+inline_always          | warn    | `#[inline(always)]` is a bad idea in most cases\n+iter_next_loop         | warn    | for-looping over `_.next()` which is probably not intended\n+len_without_is_empty   | warn    | traits and impls that have `.len()` but not `.is_empty()`\n+len_zero               | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n+let_and_return         | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n+let_unit_value         | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n+linkedlist             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n+modulo_one             | warn    | taking a number modulo 1, which always returns 0\n+mut_mut                | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n+needless_bool          | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n+needless_lifetimes     | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n+needless_range_loop    | warn    | for-looping over a range of indices where an iterator over items would do\n+needless_return        | warn    | using a return statement like `return expr;` where an expression would suffice\n+non_ascii_literal      | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+option_unwrap_used     | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+precedence             | warn    | expressions where precedence may trip up the unwary reader of the source; suggests adding parentheses, e.g. `x << 2 + y` will be parsed as `x << (2 + y)`\n+ptr_arg                | allow   | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n+range_step_by_zero     | warn    | using Range::step_by(0), which produces an infinite iterator\n+redundant_closure      | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n+result_unwrap_used     | allow   | using `Result.unwrap()`, which might be better handled\n+single_match           | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n+str_to_string          | warn    | using `to_string()` on a str, which should be `to_owned()`\n+string_add             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n+string_add_assign      | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n+string_to_string       | warn    | calling `String.to_string()` which is a no-op\n+toplevel_ref_arg       | warn    | a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not `fn foo((ref x, ref y): (u8, u8))`)\n+unit_cmp               | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+zero_width_space       | deny    | using a zero-width space in a string literal, which is confusing\n \n To use, add the following lines to your Cargo.toml:\n "}, {"sha": "c033888e360671473b1cb60cf4ce7bc9de04df48", "filename": "src/consts.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=993239d33af2b91fcd5e6dbec30f3810c8178ae3", "patch": "@@ -67,15 +67,16 @@ impl Constant {\n     }\n \n     /// convert this constant to a f64, if possible\n-   pub fn as_float(&self) -> Option<f64> {\n-       match *self {\n-           ConstantByte(b) => Some(b as f64),\n-           ConstantFloat(ref s, _) => s.parse().ok(),\n-           ConstantInt(i, ty) => Some(if is_negative(ty) {\n-               -(i as f64) } else { i as f64 }),\n-           _ => None\n-       }\n-   }\n+    #[allow(unknown_lints,cast_precision_loss)]\n+    pub fn as_float(&self) -> Option<f64> {\n+        match *self {\n+            ConstantByte(b) => Some(b as f64),\n+            ConstantFloat(ref s, _) => s.parse().ok(),\n+            ConstantInt(i, ty) => Some(if is_negative(ty) {\n+                -(i as f64) } else { i as f64 }),\n+            _ => None\n+        }\n+    }\n }\n \n impl PartialEq for Constant {"}, {"sha": "1b4d77dacca4aa851793a6876c6ba6a6f0944b30", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=993239d33af2b91fcd5e6dbec30f3810c8178ae3", "patch": "@@ -68,6 +68,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box loops::LoopsPass as LintPassObject);\n     reg.register_lint_pass(box lifetimes::LifetimePass as LintPassObject);\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n+    reg.register_lint_pass(box types::CastPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -104,6 +105,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         strings::STRING_ADD,\n         strings::STRING_ADD_ASSIGN,\n         types::BOX_VEC,\n+        types::CAST_POSSIBLE_OVERFLOW,\n+        types::CAST_PRECISION_LOSS,\n+        types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,\n         types::UNIT_CMP,"}, {"sha": "17ebb791c3ca984ec160b7f1c8648839a00d965c", "filename": "src/types.rs", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993239d33af2b91fcd5e6dbec30f3810c8178ae3/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=993239d33af2b91fcd5e6dbec30f3810c8178ae3", "patch": "@@ -6,7 +6,7 @@ use syntax::ptr::P;\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, snippet, span_lint, span_help_and_lint};\n+use utils::{in_macro, snippet, span_lint, span_help_and_lint, in_external_macro};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -136,3 +136,136 @@ impl LintPass for UnitCmp {\n         }\n     }\n }\n+\n+pub struct CastPass;\n+\n+declare_lint!(pub CAST_PRECISION_LOSS, Allow,\n+              \"casts that cause loss of precision\");\n+declare_lint!(pub CAST_SIGN_LOSS, Allow,\n+              \"casts from signed types to unsigned types\");\n+declare_lint!(pub CAST_POSSIBLE_OVERFLOW, Allow,\n+              \"casts that may cause overflow\");\n+\n+impl LintPass for CastPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(CAST_PRECISION_LOSS,\n+                    CAST_SIGN_LOSS,\n+                    CAST_POSSIBLE_OVERFLOW)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprCast(ref ex, _) = expr.node {\n+            let (cast_from, cast_to) = (cx.tcx.expr_ty(&*ex), cx.tcx.expr_ty(expr));\n+            if cast_from.is_numeric() && !in_external_macro(cx, expr.span) {\n+                match (cast_from.is_integral(), cast_to.is_integral()) {\n+                    (true, false)  => {\n+                        match (&cast_from.sty, &cast_to.sty) {\n+                            (&ty::TypeVariants::TyInt(i), &ty::TypeVariants::TyFloat(f)) => {\n+                                match (i, f) {\n+                                    (ast::IntTy::TyI32, ast::FloatTy::TyF32) |\n+                                    (ast::IntTy::TyI64, ast::FloatTy::TyF32) |\n+                                    (ast::IntTy::TyI64, ast::FloatTy::TyF64) => {\n+                                        span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+                                                  &format!(\"converting from {} to {}, which causes a loss of precision\",\n+                                                           i, f));\n+                                    },\n+                                    _ => ()\n+                                }\n+                            }\n+                            (&ty::TypeVariants::TyUint(u), &ty::TypeVariants::TyFloat(f)) => {\n+                                match (u, f) {\n+                                    (ast::UintTy::TyU32, ast::FloatTy::TyF32) |\n+                                    (ast::UintTy::TyU64, ast::FloatTy::TyF32) |\n+                                    (ast::UintTy::TyU64, ast::FloatTy::TyF64) => {\n+                                        span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+                                                  &format!(\"converting from {} to {}, which causes a loss of precision\",\n+                                                           u, f));\n+                                    },\n+                                    _ => ()\n+                                }\n+                            },\n+                            _ => ()\n+                        }\n+                    },\n+                    (false, true) => {\n+                        span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \n+                                  &format!(\"the contents of a {} may overflow a {}\", cast_from, cast_to));\n+                        if !cx.tcx.expr_ty(expr).is_signed() {\n+                            span_lint(cx, CAST_SIGN_LOSS, expr.span, \n+                                      &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n+                        }\n+                    },\n+                    (true, true) => {\n+                        match (&cast_from.sty, &cast_to.sty) {\n+                            (&ty::TypeVariants::TyInt(i1), &ty::TypeVariants::TyInt(i2)) => {\n+                                match (i1, i2) {\n+                                    (ast::IntTy::TyI64, ast::IntTy::TyI32) |\n+                                    (ast::IntTy::TyI64, ast::IntTy::TyI16) |\n+                                    (ast::IntTy::TyI64, ast::IntTy::TyI8)  |\n+                                    (ast::IntTy::TyI32, ast::IntTy::TyI16) |\n+                                    (ast::IntTy::TyI32, ast::IntTy::TyI8)  |\n+                                    (ast::IntTy::TyI16, ast::IntTy::TyI8) => \n+                                        span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \n+                                                  &format!(\"the contents of a {} may overflow a {}\", i1, i2)),\n+                                    _ => ()\n+                                }\n+                            },\n+                            (&ty::TypeVariants::TyInt(i), &ty::TypeVariants::TyUint(u)) => {\n+                                span_lint(cx, CAST_SIGN_LOSS, expr.span, \n+                                          &format!(\"casting from {} to {} loses the sign of the value\", i, u));\n+                                match (i, u) {\n+                                    (ast::IntTy::TyI64, ast::UintTy::TyU32) |\n+                                    (ast::IntTy::TyI64, ast::UintTy::TyU16) |\n+                                    (ast::IntTy::TyI64, ast::UintTy::TyU8)  |\n+                                    (ast::IntTy::TyI32, ast::UintTy::TyU16) |\n+                                    (ast::IntTy::TyI32, ast::UintTy::TyU8)  |\n+                                    (ast::IntTy::TyI16, ast::UintTy::TyU8) => \n+                                        span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \n+                                                  &format!(\"the contents of a {} may overflow a {}\", i, u)),\n+                                    _ => ()\n+                                }\n+                            },\n+                            (&ty::TypeVariants::TyUint(u), &ty::TypeVariants::TyInt(i)) => {\n+                                match (u, i) {\n+                                    (ast::UintTy::TyU64, ast::IntTy::TyI32) |\n+                                    (ast::UintTy::TyU64, ast::IntTy::TyI64) |\n+                                    (ast::UintTy::TyU64, ast::IntTy::TyI16) |\n+                                    (ast::UintTy::TyU64, ast::IntTy::TyI8)  |\n+                                    (ast::UintTy::TyU32, ast::IntTy::TyI32) |\n+                                    (ast::UintTy::TyU32, ast::IntTy::TyI16) |\n+                                    (ast::UintTy::TyU32, ast::IntTy::TyI8)  |\n+                                    (ast::UintTy::TyU16, ast::IntTy::TyI16) |\n+                                    (ast::UintTy::TyU16, ast::IntTy::TyI8)  |\n+                                    (ast::UintTy::TyU8, ast::IntTy::TyI8) => \n+                                        span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \n+                                                  &format!(\"the contents of a {} may overflow a {}\", u, i)),\n+                                    _ => ()\n+                                }\n+                            },\n+                            (&ty::TypeVariants::TyUint(u1), &ty::TypeVariants::TyUint(u2)) => {\n+                                match (u1, u2) {\n+                                    (ast::UintTy::TyU64, ast::UintTy::TyU32) |\n+                                    (ast::UintTy::TyU64, ast::UintTy::TyU16) |\n+                                    (ast::UintTy::TyU64, ast::UintTy::TyU8)  |\n+                                    (ast::UintTy::TyU32, ast::UintTy::TyU16) |\n+                                    (ast::UintTy::TyU32, ast::UintTy::TyU8)  |\n+                                    (ast::UintTy::TyU16, ast::UintTy::TyU8) => \n+                                        span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \n+                                                  &format!(\"the contents of a {} may overflow a {}\", u1, u2)),\n+                                    _ => ()\n+                                }\n+                            },\n+                            _ => ()\n+                        }\n+                    }\n+                    (false, false) => {\n+                        if let (&ty::TypeVariants::TyFloat(ast::FloatTy::TyF64),\n+                                &ty::TypeVariants::TyFloat(ast::FloatTy::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                            span_lint(cx, CAST_POSSIBLE_OVERFLOW, expr.span, \"the contents of a f64 may overflow a f32\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }                                        \n+}"}, {"sha": "a51ea62a7b874b8c85248e3de71f5225c9a83be3", "filename": "tests/compile-fail/cast.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/993239d33af2b91fcd5e6dbec30f3810c8178ae3/tests%2Fcompile-fail%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993239d33af2b91fcd5e6dbec30f3810c8178ae3/tests%2Fcompile-fail%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast.rs?ref=993239d33af2b91fcd5e6dbec30f3810c8178ae3", "patch": "@@ -0,0 +1,31 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(cast_precision_loss, cast_possible_overflow, cast_sign_loss)]\n+fn main() {\n+    let i : i32 = 42;\n+    let u : u32 = 42;\n+    let f : f32 = 42.0;\n+\n+    // Test cast_precision_loss\n+    i as f32; //~ERROR converting from i32 to f32, which causes a loss of precision\n+    (i as i64) as f32; //~ERROR converting from i64 to f32, which causes a loss of precision\n+    (i as i64) as f64; //~ERROR converting from i64 to f64, which causes a loss of precision\n+    u as f32; //~ERROR converting from u32 to f32, which causes a loss of precision\n+    (u as u64) as f32; //~ERROR converting from u64 to f32, which causes a loss of precision\n+    (u as u64) as f64; //~ERROR converting from u64 to f64, which causes a loss of precision\n+    i as f64; // Should not trigger the lint\n+    u as f64; // Should not trigger the lint\n+    \n+    // Test cast_possible_overflow\n+    f as i32; //~ERROR the contents of a f32 may overflow a i32\n+    f as u32; //~ERROR the contents of a f32 may overflow a u32\n+              //~^ERROR casting from f32 to u32 loses the sign of the value\n+    i as u8;  //~ERROR the contents of a i32 may overflow a u8\n+              //~^ERROR casting from i32 to u8 loses the sign of the value\n+    (f as f64) as f32; //~ERROR the contents of a f64 may overflow a f32\n+    i as i8;  //~ERROR the contents of a i32 may overflow a i8\n+    \n+    // Test cast_sign_loss\n+    i as u32; //~ERROR casting from i32 to u32 loses the sign of the value\n+}\n\\ No newline at end of file"}]}