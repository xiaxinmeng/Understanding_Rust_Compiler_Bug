{"sha": "6de7afdf9529ec66bc2fabe7ce012a885cd48002", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZTdhZmRmOTUyOWVjNjZiYzJmYWJlN2NlMDEyYTg4NWNkNDgwMDI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-07T20:03:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:14:34Z"}, "message": "Prefer IntRange::into_ctor to range_to_ctor", "tree": {"sha": "241c1a821d67b5f7d6470bbccb70da96a53bf868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/241c1a821d67b5f7d6470bbccb70da96a53bf868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6de7afdf9529ec66bc2fabe7ce012a885cd48002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6de7afdf9529ec66bc2fabe7ce012a885cd48002", "html_url": "https://github.com/rust-lang/rust/commit/6de7afdf9529ec66bc2fabe7ce012a885cd48002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6de7afdf9529ec66bc2fabe7ce012a885cd48002/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a186103ae501f74bdee25270f7e52d0f44694ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a186103ae501f74bdee25270f7e52d0f44694ba", "html_url": "https://github.com/rust-lang/rust/commit/0a186103ae501f74bdee25270f7e52d0f44694ba"}], "stats": {"total": 81, "additions": 34, "deletions": 47}, "files": [{"sha": "1b589d5ac84da2aae5b048ad108399ba4712fea4", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 34, "deletions": 47, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6de7afdf9529ec66bc2fabe7ce012a885cd48002/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de7afdf9529ec66bc2fabe7ce012a885cd48002/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=6de7afdf9529ec66bc2fabe7ce012a885cd48002", "patch": "@@ -1389,20 +1389,15 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n-    fn range_to_ctor(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        r: RangeInclusive<u128>,\n-        span: Span,\n-    ) -> Constructor<'tcx> {\n-        let bias = IntRange::signed_bias(tcx, ty);\n-        let (lo, hi) = r.into_inner();\n+    /// Converts an `IntRange` to a `ConstantValue` or inclusive `ConstantRange`.\n+    fn into_ctor(self, tcx: TyCtxt<'tcx>) -> Constructor<'tcx> {\n+        let bias = IntRange::signed_bias(tcx, self.ty);\n+        let (lo, hi) = self.range.into_inner();\n         if lo == hi {\n-            let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), span)\n+            let ty = ty::ParamEnv::empty().and(self.ty);\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), self.span)\n         } else {\n-            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included, span)\n+            ConstantRange(lo ^ bias, hi ^ bias, self.ty, RangeEnd::Included, self.span)\n         }\n     }\n \n@@ -1419,38 +1414,27 @@ impl<'tcx> IntRange<'tcx> {\n             .filter_map(|r| IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range));\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n+        let span = self.span;\n         let (lo, hi) = self.range.into_inner();\n         for subrange in ranges {\n             let (subrange_lo, subrange_hi) = subrange.into_inner();\n             if lo > subrange_hi || subrange_lo > hi {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(Self::range_to_ctor(\n-                    tcx,\n-                    ty,\n-                    subrange_lo..=subrange_hi,\n-                    self.span,\n-                ));\n+                remaining_ranges\n+                    .push(IntRange { range: subrange_lo..=subrange_hi, ty, span }.into_ctor(tcx));\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(\n-                        tcx,\n-                        ty,\n-                        subrange_lo..=(lo - 1),\n-                        self.span,\n-                    ));\n+                    remaining_ranges\n+                        .push(IntRange { range: subrange_lo..=(lo - 1), ty, span }.into_ctor(tcx));\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(\n-                        tcx,\n-                        ty,\n-                        (hi + 1)..=subrange_hi,\n-                        self.span,\n-                    ));\n+                    remaining_ranges\n+                        .push(IntRange { range: (hi + 1)..=subrange_hi, ty, span }.into_ctor(tcx));\n                 }\n             }\n         }\n@@ -1964,23 +1948,24 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // We're going to iterate through every adjacent pair of borders, making sure that\n                 // each represents an interval of nonnegative length, and convert each such\n                 // interval into a constructor.\n-                for IntRange { range, .. } in\n-                    borders.windows(2).filter_map(|window| match (window[0], window[1]) {\n-                        (Border::JustBefore(n), Border::JustBefore(m)) => {\n-                            if n < m {\n-                                Some(IntRange { range: n..=(m - 1), ty, span })\n-                            } else {\n-                                None\n+                split_ctors.extend(\n+                    borders\n+                        .windows(2)\n+                        .filter_map(|window| match (window[0], window[1]) {\n+                            (Border::JustBefore(n), Border::JustBefore(m)) => {\n+                                if n < m {\n+                                    Some(IntRange { range: n..=(m - 1), ty, span })\n+                                } else {\n+                                    None\n+                                }\n                             }\n-                        }\n-                        (Border::JustBefore(n), Border::AfterMax) => {\n-                            Some(IntRange { range: n..=u128::MAX, ty, span })\n-                        }\n-                        (Border::AfterMax, _) => None,\n-                    })\n-                {\n-                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n-                }\n+                            (Border::JustBefore(n), Border::AfterMax) => {\n+                                Some(IntRange { range: n..=u128::MAX, ty, span })\n+                            }\n+                            (Border::AfterMax, _) => None,\n+                        })\n+                        .map(|range| range.into_ctor(tcx)),\n+                );\n             }\n             VarLenSlice(self_prefix, self_suffix) => {\n                 // The exhaustiveness-checking paper does not include any details on\n@@ -2127,7 +2112,9 @@ fn lint_overlapping_patterns(\n                 int_range.span,\n                 &format!(\n                     \"this range overlaps on `{}`\",\n-                    IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+                    IntRange { range: int_range.range, ty, span: DUMMY_SP }\n+                        .into_ctor(tcx)\n+                        .display(tcx),\n                 ),\n             );\n         }"}]}