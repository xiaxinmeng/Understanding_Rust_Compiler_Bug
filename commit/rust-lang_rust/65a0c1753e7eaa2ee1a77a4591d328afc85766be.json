{"sha": "65a0c1753e7eaa2ee1a77a4591d328afc85766be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YTBjMTc1M2U3ZWFhMmVlMWE3N2E0NTkxZDMyOGFmYzg1NzY2YmU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-29T18:35:09Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-29T18:35:09Z"}, "message": "poke at data and conversions more", "tree": {"sha": "11edcac648e4abb2a9e13bcf5956d1f7ebf246b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11edcac648e4abb2a9e13bcf5956d1f7ebf246b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65a0c1753e7eaa2ee1a77a4591d328afc85766be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65a0c1753e7eaa2ee1a77a4591d328afc85766be", "html_url": "https://github.com/rust-lang/rust/commit/65a0c1753e7eaa2ee1a77a4591d328afc85766be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65a0c1753e7eaa2ee1a77a4591d328afc85766be/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717", "html_url": "https://github.com/rust-lang/rust/commit/a1f6bbc67ae532be0f1bfbe7a631ae39c230c717"}], "stats": {"total": 242, "additions": 100, "deletions": 142}, "files": [{"sha": "ad5d240f2a7418f5dcc2c92c5c1d17b394da1948", "filename": "conversions.md", "status": "modified", "additions": 64, "deletions": 122, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/65a0c1753e7eaa2ee1a77a4591d328afc85766be/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/65a0c1753e7eaa2ee1a77a4591d328afc85766be/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=65a0c1753e7eaa2ee1a77a4591d328afc85766be", "patch": "@@ -32,21 +32,6 @@ more ergonomic alternatives.\n \n \n \n-# Auto-Deref\n-\n-(Maybe nix this in favour of receiver coercions)\n-\n-Deref is a trait that allows you to overload the unary `*` to specify a type\n-you dereference to. This is largely only intended to be implemented by pointer\n-types like `&`, `Box`, and `Rc`. The dot operator will automatically perform\n-automatic dereferencing, so that foo.bar() will work uniformly on `Foo`, `&Foo`, `\n-&&Foo`, `&Rc<Box<&mut&Box<Foo>>>` and so-on. Search bottoms out on the *first* match,\n-so implementing methods on pointers is generally to be avoided, as it will shadow\n-\"actual\" methods.\n-\n-\n-\n-\n # Coercions\n \n Types can implicitly be coerced to change in certain contexts. These changes are\n@@ -58,118 +43,75 @@ Here's all the kinds of coercion:\n \n Coercion is allowed between the following types:\n \n-* `T` to `U` if `T` is a [subtype](lifetimes.html#subtyping-and-variance)\n-  of `U` (the 'identity' case);\n-\n-* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n-  (transitivity case);\n-\n-* `&mut T` to `&T`;\n-\n-* `*mut T` to `*const T`;\n-\n-* `&T` to `*const T`;\n-\n-* `&mut T` to `*mut T`;\n-\n-* `T` to `U` if `T` implements `CoerceUnsized<U>` (see below) and `T = Foo<...>`\n-  and `U = Foo<...>`;\n-\n-* From TyCtor(`T`) to TyCtor(coerce_inner(`T`));\n-\n-where TyCtor(`T`) is one of `&T`, `&mut T`, `*const T`, `*mut T`, or `Box<T>`.\n-And where coerce_inner is defined as\n-\n-* coerce_inner(`[T, ..n]`) = `[T]`;\n-\n-* coerce_inner(`T`) = `U` where `T` is a concrete type which implements the\n-  trait `U`;\n-\n-* coerce_inner(`T`) = `U` where `T` is a sub-trait of `U`;\n-\n-* coerce_inner(`Foo<..., T, ...>`) = `Foo<..., coerce_inner(T), ...>` where\n-  `Foo` is a struct and only the last field has type `T` and `T` is not part of\n-  the type of any other fields;\n-\n-* coerce_inner(`(..., T)`) = `(..., coerce_inner(T))`.\n-\n-Coercions only occur at a *coercion site*. Exhaustively, the coercion sites\n-are:\n-\n-* In `let` statements where an explicit type is given: in `let _: U = e;`, `e`\n-  is coerced to to have type `U`;\n-\n-* In statics and consts, similarly to `let` statements;\n-\n-* In argument position for function calls. The value being coerced is the actual\n-  parameter and it is coerced to the type of the formal parameter. For example,\n-  where `foo` is defined as `fn foo(x: U) { ... }` and is called with `foo(e);`,\n-  `e` is coerced to have type `U`;\n-\n-* Where a field of a struct or variant is instantiated. E.g., where `struct Foo\n-  { x: U }` and the instantiation is `Foo { x: e }`, `e` is coerced to to have\n-  type `U`;\n-\n-* The result of a function, either the final line of a block if it is not semi-\n-  colon terminated or any expression in a `return` statement. For example, for\n-  `fn foo() -> U { e }`, `e` is coerced to to have type `U`;\n-\n-If the expression in one of these coercion sites is a coercion-propagating\n-expression, then the relevant sub-expressions in that expression are also\n-coercion sites. Propagation recurses from these new coercion sites. Propagating\n-expressions and their relevant sub-expressions are:\n-\n-* array literals, where the array has type `[U, ..n]`, each sub-expression in\n-  the array literal is a coercion site for coercion to type `U`;\n-\n-* array literals with repeating syntax, where the array has type `[U, ..n]`, the\n-  repeated sub-expression is a coercion site for coercion to type `U`;\n-\n-* tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`, each\n-  sub-expression is a coercion site for the respective type, e.g., the zero-th\n-  sub-expression is a coercion site to `U_0`;\n-\n-* the box expression, if the expression has type `Box<U>`, the sub-expression is\n-  a coercion site to `U`;\n-\n-* parenthesised sub-expressions (`(e)`), if the expression has type `U`, then\n-  the sub-expression is a coercion site to `U`;\n-\n-* blocks, if a block has type `U`, then the last expression in the block (if it\n-  is not semicolon-terminated) is a coercion site to `U`. This includes blocks\n-  which are part of control flow statements, such as `if`/`else`, if the block\n-  has a known type.\n-\n+* Subtyping: `T` to `U` if `T` is a [subtype](lifetimes.html#subtyping-and-variance)\n+  of `U`\n+* Transitivity: `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n+* Pointer Weakening:\n+    * `&mut T` to `&T`\n+    * `*mut T` to `*const T`\n+    * `&T` to `*const T`\n+    * `&mut T` to `*mut T`\n+* Unsizing: `T` to `U` if `T` implements `CoerceUnsized<U>`\n+\n+`CoerceUnsized<Pointer<U>> for Pointer<T>` where T: Unsize<U> is implemented\n+for all pointer types (including smart pointers like Box and Rc). Unsize is\n+only implemented automatically, and enables the following transformations:\n+\n+* `[T, ..n]` => `[T]`\n+* `T` => `Trait` where `T: Trait`\n+* `SubTrait` => `Trait` where `SubTrait: Trait` (TODO: is this now implied by the previous?)\n+* `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n+    * T: Unsize<U>\n+    * `Foo` is a struct\n+    * Only the last field has type `T`\n+    * `T` is not part of the type of any other fields\n+  (note that this also applies to to tuples as an anonymous struct `Tuple3<T, U, V>`)\n+\n+Coercions occur at a *coercion site*. Any location that is explicitly typed\n+will cause a coercion to its type. If inference is necessary, the coercion will\n+not be performed. Exhaustively, the coercion sites for an expression `e` to\n+type `U` are:\n+\n+* let statements, statics, and consts: `let x: U = e`\n+* Arguments to functions: `takes_a_U(e)`\n+* Any expression that will be returned: `fn foo() -> U { e }`\n+* Struct literals: `Foo { some_u: e }`\n+* Array literals: `let x: [U; 10] = [e, ..]`\n+* Tuple literals: `let x: (U, ..) = (e, ..)`\n+* The last expression in a block: `let x: U = { ..; e }`\n \n Note that we do not perform coercions when matching traits (except for\n receivers, see below). If there is an impl for some type `U` and `T` coerces to\n `U`, that does not constitute an implementation for `T`. For example, the\n following will not type check, even though it is OK to coerce `t` to `&T` and\n there is an impl for `&T`:\n \n-```\n-struct T;\n+```rust\n trait Trait {}\n \n fn foo<X: Trait>(t: X) {}\n \n-impl<'a> Trait for &'a T {}\n+impl<'a> Trait for &'a i32 {}\n \n \n fn main() {\n-    let t: &mut T = &mut T;\n-    foo(t); //~ ERROR failed to find an implementation of trait Trait for &mut T\n+    let t: &mut i32 = &mut 0;\n+    foo(t);\n }\n ```\n \n-In a cast expression, `e as U`, the compiler will first attempt to coerce `e` to\n-`U`, only if that fails will the conversion rules for casts (see below) be\n-applied.\n-\n+```text\n+<anon>:10:5: 10:8 error: the trait `Trait` is not implemented for the type `&mut i32` [E0277]\n+<anon>:10     foo(t);\n+              ^~~\n+```\n \n+# The Dot Operator\n \n-TODO: receiver coercions?\n+The dot operator will perform a lot of magic to convert types. It will perform\n+auto-referencing, auto-dereferencing, and coercion until types match.\n \n+TODO: steal information from http://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082\n \n # Casts\n \n@@ -178,21 +120,21 @@ cast, but some conversions *require* a cast. These \"true casts\" are generally re\n as dangerous or problematic actions. True casts revolve around raw pointers and\n the primitive numeric types. True casts aren't checked.\n \n-Here's an exhaustive list of all the true casts:\n-\n- * `e` has type `T` and `T` coerces to `U`; *coercion-cast*\n- * `e` has type `*T`, `U` is `*U_0`, and either `U_0: Sized` or\n-    unsize_kind(`T`) = unsize_kind(`U_0`); *ptr-ptr-cast*\n- * `e` has type `*T` and `U` is a numeric type, while `T: Sized`; *ptr-addr-cast*\n- * `e` is an integer and `U` is `*U_0`, while `U_0: Sized`; *addr-ptr-cast*\n- * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n- * `e` is a C-like enum and `U` is an integer type; *enum-cast*\n- * `e` has type `bool` or `char` and `U` is an integer; *prim-int-cast*\n- * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n- * `e` has type `&[T; n]` and `U` is `*const T`; *array-ptr-cast*\n- * `e` is a function pointer type and `U` has type `*T`,\n-   while `T: Sized`; *fptr-ptr-cast*\n- * `e` is a function pointer type and `U` is an integer; *fptr-addr-cast*\n+Here's an exhaustive list of all the true casts. For brevity, we will use `*`\n+to denote either a `*const` or `*mut`, and `integer` to denote any integral primitive:\n+\n+ * `*T as *U` where `T, U: Sized`\n+ * `*T as *U` TODO: explain unsized situation\n+ * `*T as integer`\n+ * `integer as *T`\n+ * `number as number`\n+ * `C-like-enum as integer`\n+ * `bool as integer`\n+ * `char as integer`\n+ * `u8 as char`\n+ * `&[T; n] as *const T`\n+ * `fn as *T` where `T: Sized`\n+ * `fn as integer`\n \n where `&.T` and `*T` are references of either mutability,\n and where unsize_kind(`T`) is the kind of the unsize info"}, {"sha": "d5259c1348a02c0a6e2783885d1b559bd51f1644", "filename": "data.md", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/65a0c1753e7eaa2ee1a77a4591d328afc85766be/data.md", "raw_url": "https://github.com/rust-lang/rust/raw/65a0c1753e7eaa2ee1a77a4591d328afc85766be/data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/data.md?ref=65a0c1753e7eaa2ee1a77a4591d328afc85766be", "patch": "@@ -7,7 +7,7 @@ represented in Rust.\n \n \n \n-# The rust repr\n+# The Rust repr\n \n Rust gives you the following ways to lay out composite data:\n \n@@ -16,12 +16,14 @@ Rust gives you the following ways to lay out composite data:\n * arrays (homogeneous product types)\n * enums (named sum types -- tagged unions)\n \n-For all these, individual fields are aligned to their preferred alignment.\n-For primitives this is equal to\n-their size. For instance, a u32 will be aligned to a multiple of 32 bits, and a u16 will\n-be aligned to a multiple of 16 bits. Composite structures will have their size rounded\n-up to be a multiple of the highest alignment required by their fields, and an alignment\n-requirement equal to the highest alignment required by their fields. So for instance,\n+An enum is said to be *C-like* if none of its variants have associated data.\n+\n+For all these, individual fields are aligned to their preferred alignment. For\n+primitives this is usually equal to their size. For instance, a u32 will be\n+aligned to a multiple of 32 bits, and a u16 will be aligned to a multiple of 16\n+bits. Composite structures will have their size rounded up to be a multiple of\n+the highest alignment required by their fields, and an alignment requirement\n+equal to the highest alignment required by their fields. So for instance,\n \n ```rust\n struct A {\n@@ -127,6 +129,9 @@ In principle enums can use fairly elaborate algorithms to cache bits throughout\n with special constrained representations. As such it is *especially* desirable that we leave\n enum layout unspecified today.\n \n+\n+\n+\n # Dynamically Sized Types (DSTs)\n \n Rust also supports types without a statically known size. On the surface,\n@@ -219,15 +224,14 @@ struct Foo {\n ```\n \n For details as to *why* this is done, and how to make it not happen, check out\n-[SOME OTHER SECTION].\n+[TODO: SOME OTHER SECTION].\n \n \n \n \n # Alternative representations\n \n-Rust allows you to specify alternative data layout strategies from the default Rust\n-one.\n+Rust allows you to specify alternative data layout strategies from the default.\n \n \n \n@@ -241,32 +245,44 @@ to soundly do more elaborate tricks with data layout such as reintepretting valu\n as a different type.\n \n However, the interaction with Rust's more exotic data layout features must be kept\n-in mind. Due to its dual purpose as a \"for FFI\" and \"for layout control\", repr(C)\n+in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\", `repr(C)`\n can be applied to types that will be nonsensical or problematic if passed through\n the FFI boundary.\n \n * ZSTs are still zero-sized, even though this is not a standard behaviour\n-in C, and is explicitly contrary to the behaviour of an empty type in C++, which\n-still consumes a byte of space.\n+  in C, and is explicitly contrary to the behaviour of an empty type in C++, which\n+  still consumes a byte of space.\n \n-* DSTs are not a concept in C\n+* DSTs, tuples, and tagged unions are not a concept in C and as such are never\n+  FFI safe.\n \n * **The drop flag will still be added**\n \n-* This is equivalent to repr(u32) for enums (see below)\n+* This is equivalent to `repr(u32)` for enums (see below)\n \n \n \n ## repr(packed)\n \n-`repr(packed)` forces rust to strip any padding it would normally apply.\n-This may improve the memory footprint of a type, but will have negative\n-side-effects from \"field access is heavily penalized\" to \"completely breaks\n-everything\" based on target platform.\n+`repr(packed)` forces rust to strip any padding, and only align the type to a\n+byte. This may improve the memory footprint, but will likely have other\n+negative side-effects.\n+\n+In particular, most architectures *strongly* prefer values to be aligned. This\n+may mean the unaligned loads are penalized (x86), or even fault (ARM). In\n+particular, the compiler may have trouble with references to unaligned fields.\n+\n+`repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n+this should not be used.\n \n+This repr is a modifier on `repr(C)` and `repr(rust)`.\n \n \n ## repr(u8), repr(u16), repr(u32), repr(u64)\n \n-These specify the size to make a c-like enum (one which has no values in its variants).\n+These specify the size to make a C-like enum. If the discriminant overflows the\n+integer it has to fit in, it will be an error. You can manually ask Rust to\n+allow this by setting the overflowing element to explicitly be 0. However Rust\n+will not allow you to create an enum where two variants.\n \n+These reprs have no affect on struct or non-C-like enum."}]}