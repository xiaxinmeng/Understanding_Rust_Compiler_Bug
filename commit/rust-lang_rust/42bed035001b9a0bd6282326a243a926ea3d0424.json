{"sha": "42bed035001b9a0bd6282326a243a926ea3d0424", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYmVkMDM1MDAxYjlhMGJkNjI4MjMyNmEyNDNhOTI2ZWEzZDA0MjQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-21T03:05:47Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:48:19Z"}, "message": "Pass on the DefId so rustdoc can name it in suggestions\n\nLook at this beauty:\n\n```rust\nerror: unresolved link to `S::h`\n  --> intra-link-errors.rs:51:6\n   |\n51 | /// [type@S::h]\n   |      ^^^^^^^^^ help: to link to the associated function, use its disambiguator: `S::h()`\n   |\n   = note: this link resolves to the associated function `h`, which is not in the type namespace\n```", "tree": {"sha": "a96a25c67338ddbe34f1a6ea9b9ae52b7d654775", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a96a25c67338ddbe34f1a6ea9b9ae52b7d654775"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42bed035001b9a0bd6282326a243a926ea3d0424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42bed035001b9a0bd6282326a243a926ea3d0424", "html_url": "https://github.com/rust-lang/rust/commit/42bed035001b9a0bd6282326a243a926ea3d0424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42bed035001b9a0bd6282326a243a926ea3d0424/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcb21999a7989792c9405a89e9c788ac143e0574", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb21999a7989792c9405a89e9c788ac143e0574", "html_url": "https://github.com/rust-lang/rust/commit/fcb21999a7989792c9405a89e9c788ac143e0574"}], "stats": {"total": 86, "additions": 52, "deletions": 34}, "files": [{"sha": "287f5fcf805efa7c6ca527f6792053d78019ece4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=42bed035001b9a0bd6282326a243a926ea3d0424", "patch": "@@ -121,7 +121,7 @@ struct LinkCollector<'a, 'tcx> {\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n-    kind_side_channel: Cell<Option<DefKind>>,\n+    kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 ) => {\n                     debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                     // Checks if item_name belongs to `impl SomeItem`\n-                    let kind = cx\n+                    let assoc_item = cx\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n@@ -393,7 +393,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 imp,\n                             )\n                         })\n-                        .map(|item| item.kind)\n+                        .map(|item| (item.kind, item.def_id))\n                         // There should only ever be one associated item that matches from any inherent impl\n                         .next()\n                         // Check if item_name belongs to `impl SomeTrait for SomeItem`\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             kind\n                         });\n \n-                    if let Some(kind) = kind {\n+                    if let Some((kind, id)) = assoc_item {\n                         let out = match kind {\n                             ty::AssocKind::Fn => \"method\",\n                             ty::AssocKind::Const => \"associatedconstant\",\n@@ -425,7 +425,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             // HACK(jynelson): `clean` expects the type, not the associated item.\n                             // but the disambiguator logic expects the associated item.\n                             // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.set(Some(kind.as_def_kind()));\n+                            self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         })\n                     } else if ns == Namespace::ValueNS {\n@@ -525,7 +525,7 @@ fn resolve_associated_trait_item(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &DocContext<'_>,\n-) -> Option<ty::AssocKind> {\n+) -> Option<(ty::AssocKind, DefId)> {\n     let ty = cx.tcx.type_of(did);\n     // First consider automatic impls: `impl From<T> for T`\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n@@ -553,7 +553,7 @@ fn resolve_associated_trait_item(\n                             // but provided methods come directly from `tcx`.\n                             // Fortunately, we don't need the whole method, we just need to know\n                             // what kind of associated item it is.\n-                            Some((assoc.def_id, kind))\n+                            Some((kind, assoc.def_id))\n                         });\n                         let assoc = items.next();\n                         debug_assert_eq!(items.count(), 0);\n@@ -575,7 +575,7 @@ fn resolve_associated_trait_item(\n                                 ns,\n                                 trait_,\n                             )\n-                            .map(|assoc| (assoc.def_id, assoc.kind))\n+                            .map(|assoc| (assoc.kind, assoc.def_id))\n                     }\n                 }\n                 _ => panic!(\"get_impls returned something that wasn't an impl\"),\n@@ -592,12 +592,12 @@ fn resolve_associated_trait_item(\n             cx.tcx\n                 .associated_items(trait_)\n                 .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-                .map(|assoc| (assoc.def_id, assoc.kind))\n+                .map(|assoc| (assoc.kind, assoc.def_id))\n         }));\n     }\n     // FIXME: warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates);\n-    candidates.pop().map(|(_, kind)| kind)\n+    candidates.pop()\n }\n \n /// Given a type, return all traits in scope in `module` implemented by that type.\n@@ -851,18 +851,21 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 // used for reporting better errors\n                 let check_full_res = |this: &mut Self, ns| {\n-                    match this.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n-                        Ok(res) => {\n-                            debug!(\n-                                \"check_full_res: saw res for {} in {:?} ns: {:?}\",\n-                                path_str, ns, res.0\n-                            );\n-                            Some(res.0)\n-                        }\n-                        Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n-                        // TODO: add `Res` to AnchorFailure\n-                        Err(ErrorKind::AnchorFailure(_)) => None,\n-                    }\n+                    let res =\n+                        match this.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n+                        {\n+                            Ok(res) => {\n+                                debug!(\n+                                    \"check_full_res: saw res for {} in {:?} ns: {:?}\",\n+                                    path_str, ns, res.0\n+                                );\n+                                Some(res.0)\n+                            }\n+                            Err(ErrorKind::Resolve(kind)) => kind.full_res(),\n+                            // TODO: add `Res` to AnchorFailure\n+                            Err(ErrorKind::AnchorFailure(_)) => None,\n+                        };\n+                    this.kind_side_channel.take().map(|(kind, id)| Res::Def(kind, id)).or(res)\n                 };\n \n                 match disambiguator.map(Disambiguator::ns) {\n@@ -876,7 +879,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 if kind.full_res().is_none() {\n                                     let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n                                     if let Some(res) = check_full_res(self, other_ns) {\n-                                        kind = ResolutionFailure::WrongNamespace(res, other_ns);\n+                                        // recall that this stores the _expected_ namespace\n+                                        kind = ResolutionFailure::WrongNamespace(res, ns);\n                                     }\n                                 }\n                                 resolution_failure(\n@@ -1092,7 +1096,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 // Disallow e.g. linking to enums with `struct@`\n                 if let Res::Def(kind, _) = res {\n                     debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-                    match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n+                    match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n                         | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n                         // NOTE: this allows 'method' to mean both normal functions and associated functions\n                         // This can't cause ambiguity because both are in the same namespace."}, {"sha": "8c42a38ff4eb04259e99f8348f766a843ed6cda7", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=42bed035001b9a0bd6282326a243a926ea3d0424", "patch": "@@ -49,11 +49,18 @@ pub struct S;\n pub enum E { A, B, C }\n \n /// [type@S::h]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the associated function\n+//~| NOTE not in the type namespace\n impl S {\n     pub fn h() {}\n }\n \n /// [type@T::g]\n+//~^ ERROR unresolved link\n+//~| HELP to link to the associated function\n+//~| NOTE not in the type namespace\n+\n /// [T::h!]\n pub trait T {\n     fn g() {}"}, {"sha": "bb9db68e0d5e10fbc06383e9f80115d0ae3be428", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42bed035001b9a0bd6282326a243a926ea3d0424/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=42bed035001b9a0bd6282326a243a926ea3d0424", "patch": "@@ -80,27 +80,34 @@ error: unresolved link to `S`\n   --> $DIR/intra-link-errors.rs:41:6\n    |\n LL | /// [S!]\n-   |      ^^ help: to link to the unit struct, use its disambiguator: `value@S`\n+   |      ^^ help: to link to the struct, use its disambiguator: `struct@S`\n    |\n-   = note: this link resolves to the unit struct `S`, which is not in the macro namespace\n+   = note: this link resolves to the struct `S`, which is not in the macro namespace\n \n error: unresolved link to `T::g`\n-  --> $DIR/intra-link-errors.rs:56:6\n+  --> $DIR/intra-link-errors.rs:59:6\n    |\n LL | /// [type@T::g]\n-   |      ^^^^^^^^^\n+   |      ^^^^^^^^^ help: to link to the associated function, use its disambiguator: `T::g()`\n    |\n-   = note: this link partially resolves to the trait `T`\n-   = note: `T` has no field, variant, or associated item named `g`\n+   = note: this link resolves to the associated function `g`, which is not in the type namespace\n+\n+error: unresolved link to `T::h`\n+  --> $DIR/intra-link-errors.rs:64:6\n+   |\n+LL | /// [T::h!]\n+   |      ^^^^^\n+   |\n+   = note: no item named `T::h` is in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n error: unresolved link to `S::h`\n   --> $DIR/intra-link-errors.rs:51:6\n    |\n LL | /// [type@S::h]\n-   |      ^^^^^^^^^\n+   |      ^^^^^^^^^ help: to link to the associated function, use its disambiguator: `S::h()`\n    |\n-   = note: this link partially resolves to the struct `S`\n-   = note: `S` has no field, variant, or associated item named `h`\n+   = note: this link resolves to the associated function `h`, which is not in the type namespace\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}]}