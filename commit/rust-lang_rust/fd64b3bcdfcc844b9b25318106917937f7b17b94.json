{"sha": "fd64b3bcdfcc844b9b25318106917937f7b17b94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNjRiM2JjZGZjYzg0NGI5YjI1MzE4MTA2OTE3OTM3ZjdiMTdiOTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T11:31:51Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T14:16:36Z"}, "message": "parser: make `eat_macro_def` redundant.", "tree": {"sha": "ab41c0547a96d484fb4279dd09f3a3e8e7d1b8ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab41c0547a96d484fb4279dd09f3a3e8e7d1b8ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd64b3bcdfcc844b9b25318106917937f7b17b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd64b3bcdfcc844b9b25318106917937f7b17b94", "html_url": "https://github.com/rust-lang/rust/commit/fd64b3bcdfcc844b9b25318106917937f7b17b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd64b3bcdfcc844b9b25318106917937f7b17b94/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2026030b5d761a83d62c7e198057b119addcfd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2026030b5d761a83d62c7e198057b119addcfd1", "html_url": "https://github.com/rust-lang/rust/commit/c2026030b5d761a83d62c7e198057b119addcfd1"}], "stats": {"total": 45, "additions": 12, "deletions": 33}, "files": [{"sha": "27b3d501751b74f9ce7de8f8bcfcf691d501ef02", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd64b3bcdfcc844b9b25318106917937f7b17b94/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd64b3bcdfcc844b9b25318106917937f7b17b94/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=fd64b3bcdfcc844b9b25318106917937f7b17b94", "patch": "@@ -86,7 +86,7 @@ impl<'a> Parser<'a> {\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n         if let Some((ident, kind)) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n-            return Ok(Some(self.mk_item(lo.to(self.prev_span), ident, kind, vis, attrs)));\n+            return Ok(Some(P(self.mk_item(lo, ident, kind, vis, attrs))));\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -942,9 +942,7 @@ impl<'a> Parser<'a> {\n             }\n             self.unexpected()?\n         };\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(P(ast::ForeignItem { ident, attrs, kind, id: DUMMY_NODE_ID, span, vis, tokens: None }))\n+        Ok(P(self.mk_item(lo, ident, kind, vis, attrs)))\n     }\n \n     /// Parses a static item from a foreign module.\n@@ -1364,7 +1362,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n-    fn is_macro_rules_item(&mut self) -> bool {\n+    pub(super) fn is_macro_rules_item(&mut self) -> bool {\n         self.check_keyword(sym::macro_rules)\n             && self.look_ahead(1, |t| *t == token::Not)\n             && self.look_ahead(2, |t| t.is_ident())\n@@ -1385,22 +1383,6 @@ impl<'a> Parser<'a> {\n         Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n     }\n \n-    pub(super) fn eat_macro_def(\n-        &mut self,\n-        attrs: &[Attribute],\n-        vis: &Visibility,\n-        lo: Span,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, kind) = if self.eat_keyword(kw::Macro) {\n-            self.parse_item_decl_macro(lo)?\n-        } else if self.is_macro_rules_item() {\n-            self.parse_item_macro_rules(vis)?\n-        } else {\n-            return Ok(None);\n-        };\n-        Ok(Some(self.mk_item(lo.to(self.prev_span), ident, kind, vis.clone(), attrs.to_vec())))\n-    }\n-\n     fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n         match *vis {\n             VisibilityKind::Inherited => {}\n@@ -1496,15 +1478,16 @@ impl<'a> Parser<'a> {\n         Ok(true)\n     }\n \n-    fn mk_item(\n+    fn mk_item<K>(\n         &self,\n-        span: Span,\n+        lo: Span,\n         ident: Ident,\n-        kind: ItemKind,\n+        kind: K,\n         vis: Visibility,\n         attrs: Vec<Attribute>,\n-    ) -> P<Item> {\n-        P(Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None })\n+    ) -> Item<K> {\n+        let span = lo.to(self.prev_span);\n+        Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None }\n     }\n }\n "}, {"sha": "b111b45e70990370382788d2ed9b433e7e255678", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd64b3bcdfcc844b9b25318106917937f7b17b94/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd64b3bcdfcc844b9b25318106917937f7b17b94/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=fd64b3bcdfcc844b9b25318106917937f7b17b94", "patch": "@@ -7,10 +7,10 @@ use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n use rustc_errors::{Applicability, PResult};\n-use rustc_span::source_map::{respan, BytePos, Span};\n+use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Symbol};\n use syntax::ast;\n-use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle, VisibilityKind};\n+use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle};\n use syntax::ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n use syntax::ptr::P;\n use syntax::token::{self, TokenKind};\n@@ -55,11 +55,6 @@ impl<'a> Parser<'a> {\n             return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n         }\n \n-        let mac_vis = respan(lo, VisibilityKind::Inherited);\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &mac_vis, lo)? {\n-            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))));\n-        }\n-\n         // Starts like a simple path, being careful to avoid contextual keywords\n         // such as a union items, item with `crate` visibility or auto trait items.\n         // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n@@ -70,6 +65,7 @@ impl<'a> Parser<'a> {\n             && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n             && !self.is_auto_trait_item()\n             && !self.is_async_fn()\n+            && !self.is_macro_rules_item()\n         {\n             let path = self.parse_path(PathStyle::Expr)?;\n "}]}