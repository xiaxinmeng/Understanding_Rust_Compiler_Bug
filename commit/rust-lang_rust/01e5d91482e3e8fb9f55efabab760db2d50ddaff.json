{"sha": "01e5d91482e3e8fb9f55efabab760db2d50ddaff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZTVkOTE0ODJlM2U4ZmI5ZjU1ZWZhYmFiNzYwZGIyZDUwZGRhZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-01T11:34:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-01T11:34:51Z"}, "message": "Auto merge of #65718 - eddyb:codegen-var-debuginfo, r=nikomatsakis\n\nrustc_codegen_ssa: introduce MIR VarDebugInfo, but only for codegen.\n\nThese are all the codegen changes necessary for #56231.\n\nThe refactors were performed locally to codegen, and in several steps, to ease reviewing and avoid introducing changes in behavior (as I'm not sure our debuginfo tests cover enough).\n\nr? @michaelwoerister cc @nagisa @rkruppe @oli-obk", "tree": {"sha": "99beaa3196bfef915068b2b985b5581134758843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99beaa3196bfef915068b2b985b5581134758843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01e5d91482e3e8fb9f55efabab760db2d50ddaff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01e5d91482e3e8fb9f55efabab760db2d50ddaff", "html_url": "https://github.com/rust-lang/rust/commit/01e5d91482e3e8fb9f55efabab760db2d50ddaff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01e5d91482e3e8fb9f55efabab760db2d50ddaff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253fc0ed742c235fa34c5d78814fa7b8a5e5e055", "url": "https://api.github.com/repos/rust-lang/rust/commits/253fc0ed742c235fa34c5d78814fa7b8a5e5e055", "html_url": "https://github.com/rust-lang/rust/commit/253fc0ed742c235fa34c5d78814fa7b8a5e5e055"}, {"sha": "60a22665c8c6aff406ffa453965b011eca50ef0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a22665c8c6aff406ffa453965b011eca50ef0c", "html_url": "https://github.com/rust-lang/rust/commit/60a22665c8c6aff406ffa453965b011eca50ef0c"}], "stats": {"total": 1308, "additions": 655, "deletions": 653}, "files": [{"sha": "6ee76b71fced68f3855833f6f6b352f058d3daa5", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,4 +1,4 @@\n-use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, FunctionDebugContextData, MirDebugScope};\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n@@ -12,34 +12,20 @@ use libc::c_uint;\n use syntax_pos::Pos;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-\n-use syntax_pos::BytePos;\n+use rustc_index::vec::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n-/// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(\n+pub fn compute_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n     mir: &Body<'_>,\n-    debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n-) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n-    let null_scope = MirDebugScope {\n-        scope_metadata: None,\n-        file_start_pos: BytePos(0),\n-        file_end_pos: BytePos(0)\n-    };\n-    let mut scopes = IndexVec::from_elem(null_scope, &mir.source_scopes);\n-\n-    let debug_context = match *debug_context {\n-        FunctionDebugContext::RegularContext(ref data) => data,\n-        FunctionDebugContext::DebugInfoDisabled |\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            return scopes;\n-        }\n-    };\n-\n+    fn_metadata: &'ll DISubprogram,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n+    // FIXME(eddyb) base this on `decl.name`, or even better, on debuginfo.\n+    // FIXME(eddyb) take into account that arguments always have debuginfo,\n+    // irrespective of their name (assuming full debuginfo is enabled).\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.visibility_scope);\n@@ -48,31 +34,29 @@ pub fn create_mir_scopes(\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, &mir, &has_variables, debug_context, scope, &mut scopes);\n+        make_mir_scope(cx, &mir, fn_metadata, &has_variables, debug_context, scope);\n     }\n-\n-    scopes\n }\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Body<'_>,\n+                  fn_metadata: &'ll DISubprogram,\n                   has_variables: &BitSet<SourceScope>,\n-                  debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n-                  scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope<&'ll DIScope>>) {\n-    if scopes[scope].is_valid() {\n+                  debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n+                  scope: SourceScope) {\n+    if debug_context.scopes[scope].is_valid() {\n         return;\n     }\n \n     let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(cx, mir, has_variables, debug_context, parent, scopes);\n-        scopes[parent]\n+        make_mir_scope(cx, mir, fn_metadata, has_variables, debug_context, parent);\n+        debug_context.scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = span_start(cx, mir.span);\n-        scopes[scope] = MirDebugScope {\n-            scope_metadata: Some(debug_context.fn_metadata),\n+        debug_context.scopes[scope] = DebugScope {\n+            scope_metadata: Some(fn_metadata),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -86,8 +70,8 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata.unwrap() != debug_context.fn_metadata {\n-            scopes[scope] = parent_scope;\n+        if parent_scope.scope_metadata.unwrap() != fn_metadata {\n+            debug_context.scopes[scope] = parent_scope;\n             return;\n         }\n     }\n@@ -105,7 +89,7 @@ fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint))\n     };\n-    scopes[scope] = MirDebugScope {\n+    debug_context.scopes[scope] = DebugScope {\n         scope_metadata,\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,"}, {"sha": "7713fe47004b93182c0608c9a2bb56343ef2c901", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 83, "deletions": 76, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,8 +1,7 @@\n // See doc.rs for documentation.\n mod doc;\n \n-use rustc_codegen_ssa::debuginfo::VariableAccess::*;\n-use rustc_codegen_ssa::debuginfo::VariableKind::*;\n+use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_instance;\n@@ -11,7 +10,7 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use crate::llvm;\n-use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags,\n+use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DIArray, DIFlags,\n     DISPFlags, DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n@@ -27,17 +26,19 @@ use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_index::vec::IndexVec;\n-use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess,\n-    VariableKind, FunctionDebugContextData, type_names};\n+use rustc_codegen_ssa::debuginfo::type_names;\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, DebugScope,\n+    VariableKind};\n \n use libc::c_uint;\n use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n \n-use syntax_pos::{self, Span, Pos};\n+use smallvec::SmallVec;\n+use syntax_pos::{self, BytePos, Span, Pos};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Size};\n use rustc_codegen_ssa::traits::*;\n \n pub mod gdb;\n@@ -47,7 +48,7 @@ pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::create_scope_map::{create_mir_scopes};\n+pub use self::create_scope_map::compute_mir_scopes;\n pub use self::metadata::create_global_var_metadata;\n pub use self::metadata::extend_scope_to_file;\n pub use self::source_loc::set_source_location;\n@@ -148,21 +149,23 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn declare_local(\n         &mut self,\n-        dbg_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        dbg_context: &FunctionDebugContext<&'ll DIScope>,\n         variable_name: ast::Name,\n         variable_type: Ty<'tcx>,\n         scope_metadata: &'ll DIScope,\n-        variable_access: VariableAccess<'_, &'ll Value>,\n+        variable_alloca: Self::Value,\n+        direct_offset: Size,\n+        indirect_offsets: &[Size],\n         variable_kind: VariableKind,\n         span: Span,\n     ) {\n-        assert!(!dbg_context.get_ref(span).source_locations_enabled);\n+        assert!(!dbg_context.source_locations_enabled);\n         let cx = self.cx();\n \n         let file = span_start(cx, span).file;\n         let file_metadata = file_metadata(cx,\n                                           &file.name,\n-                                          dbg_context.get_ref(span).defining_crate);\n+                                          dbg_context.defining_crate);\n \n         let loc = span_start(cx, span);\n         let type_metadata = type_metadata(cx, variable_type, span);\n@@ -173,49 +176,61 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         };\n         let align = cx.align_of(variable_type);\n \n-        let name = SmallCStr::new(&variable_name.as_str());\n-        match (variable_access, &[][..]) {\n-            (DirectVariable { alloca }, address_operations) |\n-            (IndirectVariable {alloca, address_operations}, _) => {\n-                let metadata = unsafe {\n-                    llvm::LLVMRustDIBuilderCreateVariable(\n-                        DIB(cx),\n-                        dwarf_tag,\n-                        scope_metadata,\n-                        name.as_ptr(),\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        cx.sess().opts.optimize != config::OptLevel::No,\n-                        DIFlags::FlagZero,\n-                        argument_index,\n-                        align.bytes() as u32,\n-                    )\n-                };\n-                source_loc::set_debug_location(self,\n-                    InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n-                unsafe {\n-                    let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n-                    let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx),\n-                        alloca,\n-                        metadata,\n-                        address_operations.as_ptr(),\n-                        address_operations.len() as c_uint,\n-                        debug_loc,\n-                        self.llbb());\n-\n-                    llvm::LLVMSetInstDebugLocation(self.llbuilder, instr);\n-                }\n-                source_loc::set_debug_location(self, UnknownLocation);\n+        // Convert the direct and indirect offsets to address ops.\n+        let op_deref = || unsafe { llvm::LLVMRustDIBuilderCreateOpDeref() };\n+        let op_plus_uconst = || unsafe { llvm::LLVMRustDIBuilderCreateOpPlusUconst() };\n+        let mut addr_ops = SmallVec::<[_; 8]>::new();\n+\n+        if direct_offset.bytes() > 0 {\n+            addr_ops.push(op_plus_uconst());\n+            addr_ops.push(direct_offset.bytes() as i64);\n+        }\n+        for &offset in indirect_offsets {\n+            addr_ops.push(op_deref());\n+            if offset.bytes() > 0 {\n+                addr_ops.push(op_plus_uconst());\n+                addr_ops.push(offset.bytes() as i64);\n             }\n         }\n+\n+        let name = SmallCStr::new(&variable_name.as_str());\n+        let metadata = unsafe {\n+            llvm::LLVMRustDIBuilderCreateVariable(\n+                DIB(cx),\n+                dwarf_tag,\n+                scope_metadata,\n+                name.as_ptr(),\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                cx.sess().opts.optimize != config::OptLevel::No,\n+                DIFlags::FlagZero,\n+                argument_index,\n+                align.bytes() as u32,\n+            )\n+        };\n+        source_loc::set_debug_location(self,\n+            InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n+        unsafe {\n+            let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n+            let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n+                DIB(cx),\n+                variable_alloca,\n+                metadata,\n+                addr_ops.as_ptr(),\n+                addr_ops.len() as c_uint,\n+                debug_loc,\n+                self.llbb());\n+\n+            llvm::LLVMSetInstDebugLocation(self.llbuilder, instr);\n+        }\n+        source_loc::set_debug_location(self, UnknownLocation);\n     }\n \n     fn set_source_location(\n         &mut self,\n-        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n-        scope: Option<&'ll DIScope>,\n+        debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+        scope: &'ll DIScope,\n         span: Span,\n     ) {\n         set_source_location(debug_context, &self, scope, span)\n@@ -224,7 +239,7 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n \n-    fn set_var_name(&mut self, value: &'ll Value, name: impl ToString) {\n+    fn set_var_name(&mut self, value: &'ll Value, name: &str) {\n         // Avoid wasting time if LLVM value names aren't even enabled.\n         if self.sess().fewer_names() {\n             return;\n@@ -254,7 +269,7 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             Err(_) => return,\n         }\n \n-        let cname = CString::new(name.to_string()).unwrap();\n+        let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n@@ -268,14 +283,14 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         sig: ty::FnSig<'tcx>,\n         llfn: &'ll Value,\n         mir: &mir::Body<'_>,\n-    ) -> FunctionDebugContext<&'ll DISubprogram> {\n+    ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n-            return FunctionDebugContext::DebugInfoDisabled;\n+            return None;\n         }\n \n         if let InstanceDef::Item(def_id) = instance.def {\n             if self.tcx().codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                return None;\n             }\n         }\n \n@@ -284,7 +299,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // This can be the case for functions inlined from another crate\n         if span.is_dummy() {\n             // FIXME(simulacrum): Probably can't happen; remove.\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            return None;\n         }\n \n         let def_id = instance.def_id();\n@@ -357,14 +372,23 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 None)\n         };\n \n-        // Initialize fn debug context (including scope map and namespace map)\n-        let fn_debug_context = FunctionDebugContextData {\n-            fn_metadata,\n+        // Initialize fn debug context (including scopes).\n+        // FIXME(eddyb) figure out a way to not need `Option` for `scope_metadata`.\n+        let null_scope = DebugScope {\n+            scope_metadata: None,\n+            file_start_pos: BytePos(0),\n+            file_end_pos: BytePos(0)\n+        };\n+        let mut fn_debug_context = FunctionDebugContext {\n+            scopes: IndexVec::from_elem(null_scope, &mir.source_scopes),\n             source_locations_enabled: false,\n             defining_crate: def_id.krate,\n         };\n \n-        return FunctionDebugContext::RegularContext(fn_debug_context);\n+        // Fill in all the scopes, with the information from the MIR body.\n+        compute_mir_scopes(self, mir, fn_metadata, &mut fn_debug_context);\n+\n+        return Some(fn_debug_context);\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -549,14 +573,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         metadata::create_vtable_metadata(self, ty, vtable)\n     }\n \n-    fn create_mir_scopes(\n-        &self,\n-        mir: &mir::Body<'_>,\n-        debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n-    ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n-        create_scope_map::create_mir_scopes(self, mir, debug_context)\n-    }\n-\n     fn extend_scope_to_file(\n          &self,\n          scope_metadata: &'ll DIScope,\n@@ -569,13 +585,4 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn debuginfo_finalize(&self) {\n         finalize(self)\n     }\n-\n-    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n-        unsafe {\n-            [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-             llvm::LLVMRustDIBuilderCreateOpPlusUconst(),\n-             byte_offset_of_var_in_env as i64,\n-             llvm::LLVMRustDIBuilderCreateOpDeref()]\n-        }\n-    }\n }"}, {"sha": "ccb3bde1cbe4e3bd4da90b36fdd942d840dac746", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -2,7 +2,7 @@ use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n use super::metadata::UNKNOWN_COLUMN_NUMBER;\n-use rustc_codegen_ssa::debuginfo::FunctionDebugContext;\n+use rustc_codegen_ssa::mir::debuginfo::FunctionDebugContext;\n \n use crate::llvm;\n use crate::llvm::debuginfo::DIScope;\n@@ -18,22 +18,13 @@ use syntax_pos::{Span, Pos};\n pub fn set_source_location<D>(\n     debug_context: &FunctionDebugContext<D>,\n     bx: &Builder<'_, 'll, '_>,\n-    scope: Option<&'ll DIScope>,\n+    scope: &'ll DIScope,\n     span: Span,\n ) {\n-    let function_debug_context = match *debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => return,\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(bx, UnknownLocation);\n-            return;\n-        }\n-        FunctionDebugContext::RegularContext(ref data) => data\n-    };\n-\n-    let dbg_loc = if function_debug_context.source_locations_enabled {\n+    let dbg_loc = if debug_context.source_locations_enabled {\n         debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx(), span);\n-        InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n+        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };"}, {"sha": "e7562c399b22256652e0dba04f52478b4b5d368f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -38,6 +38,7 @@ extern crate rustc_fs_util;\n extern crate rustc_driver as _;\n \n #[macro_use] extern crate log;\n+extern crate smallvec;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;"}, {"sha": "d1a0cf78d6a2efdae2902abc19a32c78015fcf55", "filename": "src/librustc_codegen_ssa/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Fmod.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,82 +1,2 @@\n-use syntax_pos::{BytePos, Span};\n-use rustc::hir::def_id::CrateNum;\n-\n+// FIXME(eddyb) find a place for this (or a way to replace it).\n pub mod type_names;\n-\n-pub enum FunctionDebugContext<D> {\n-    RegularContext(FunctionDebugContextData<D>),\n-    DebugInfoDisabled,\n-    FunctionWithoutDebugInfo,\n-}\n-\n-impl<D> FunctionDebugContext<D> {\n-    pub fn get_ref(&self, span: Span) -> &FunctionDebugContextData<D> {\n-        match *self {\n-            FunctionDebugContext::RegularContext(ref data) => data,\n-            FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     although debug info is disabled!\",\n-                );\n-            }\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(\n-                    span,\n-                    \"debuginfo: Error trying to access FunctionDebugContext \\\n-                     for function that should be ignored by debug info!\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to codegen a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations<D>(dbg_context: &mut FunctionDebugContext<D>) {\n-    match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref mut data) => {\n-            data.source_locations_enabled = true;\n-        },\n-        _ => { /* safe to ignore */ }\n-    }\n-}\n-\n-pub struct FunctionDebugContextData<D> {\n-    pub fn_metadata: D,\n-    pub source_locations_enabled: bool,\n-    pub defining_crate: CrateNum,\n-}\n-\n-pub enum VariableAccess<'a, V> {\n-    // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: V },\n-    // The llptr given is an alloca containing the start of some pointer chain\n-    // leading to the variable's content.\n-    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n-}\n-\n-pub enum VariableKind {\n-    ArgumentVariable(usize /*index*/),\n-    LocalVariable,\n-}\n-\n-\n-#[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope<D> {\n-    pub scope_metadata: Option<D>,\n-    // Start and end offsets of the file to which this DIScope belongs.\n-    // These are used to quickly determine whether some span refers to the same file.\n-    pub file_start_pos: BytePos,\n-    pub file_end_pos: BytePos,\n-}\n-\n-impl<D> MirDebugScope<D> {\n-    pub fn is_valid(&self) -> bool {\n-        !self.scope_metadata.is_none()\n-    }\n-}"}, {"sha": "2e5dc3db31af90c89ef94eecb8f408a655ecfbd4", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -7,6 +7,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::traversal;\n+use rustc::session::config::DebugInfo;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use syntax_pos::DUMMY_SP;\n@@ -21,13 +22,20 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     analyzer.visit_body(mir);\n \n-    for (index, (ty, span)) in mir.local_decls.iter()\n-        .map(|l| (l.ty, l.source_info.span))\n-        .enumerate()\n+    for (local, decl) in mir.local_decls.iter_enumerated()\n     {\n-        let ty = fx.monomorphize(&ty);\n-        debug!(\"local {} has type {:?}\", index, ty);\n-        let layout = fx.cx.spanned_layout_of(ty, span);\n+        // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n+        // of putting everything in allocas just so we can use llvm.dbg.declare.\n+        if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n+            if mir.local_kind(local) == mir::LocalKind::Arg || decl.name.is_some() {\n+                analyzer.not_ssa(local);\n+                continue;\n+            }\n+        }\n+\n+        let ty = fx.monomorphize(&decl.ty);\n+        debug!(\"local {:?} has type `{}`\", local, ty);\n+        let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n         if fx.cx.is_backend_immediate(layout) {\n             // These sorts of types are immediates that we can store\n             // in an Value without an alloca.\n@@ -40,7 +48,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // (e.g., structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n-            analyzer.not_ssa(mir::Local::new(index));\n+            analyzer.not_ssa(local);\n         }\n     }\n "}, {"sha": "c215db34ccbc8bec54fec479088cf5d50451eb41", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -0,0 +1,385 @@\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc::hir::def_id::CrateNum;\n+use rustc::mir;\n+use rustc::session::config::DebugInfo;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::{LayoutOf, Size, VariantIdx};\n+use crate::traits::*;\n+\n+use syntax_pos::{BytePos, Span, Symbol};\n+use syntax::symbol::kw;\n+\n+use super::{FunctionCx, LocalRef};\n+use super::OperandValue;\n+\n+pub struct FunctionDebugContext<D> {\n+    pub scopes: IndexVec<mir::SourceScope, DebugScope<D>>,\n+    pub source_locations_enabled: bool,\n+    pub defining_crate: CrateNum,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct DebugScope<D> {\n+    pub scope_metadata: Option<D>,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl<D> DebugScope<D> {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_none()\n+    }\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn set_debug_loc(\n+        &mut self,\n+        bx: &mut Bx,\n+        source_info: mir::SourceInfo\n+    ) {\n+        let (scope, span) = self.debug_loc(source_info);\n+        if let Some(debug_context) = &mut self.debug_context {\n+            // FIXME(eddyb) get rid of this unwrap somehow.\n+            bx.set_source_location(debug_context, scope.unwrap(), span);\n+        }\n+    }\n+\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n+        // Bail out if debug info emission is not enabled.\n+        match self.debug_context {\n+            None => return (None, source_info.span),\n+            Some(_) => {}\n+        }\n+\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        if !source_info.span.from_expansion() ||\n+           self.cx.sess().opts.debugging_opts.debug_macros {\n+            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n+            (scope, source_info.span)\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            let span = syntax_pos::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n+            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n+            // Use span of the outermost expansion site, while keeping the original lexical scope.\n+            (scope, span)\n+        }\n+    }\n+\n+    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    // it may so happen that the current span belongs to a different file than the DIScope\n+    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    // \"extension\" into that file.\n+    fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n+                              -> Option<Bx::DIScope> {\n+        let debug_context = self.debug_context.as_ref()?;\n+        let scope_metadata = debug_context.scopes[scope_id].scope_metadata;\n+        if pos < debug_context.scopes[scope_id].file_start_pos ||\n+           pos >= debug_context.scopes[scope_id].file_end_pos {\n+            let sm = self.cx.sess().source_map();\n+            let defining_crate = debug_context.defining_crate;\n+            Some(self.cx.extend_scope_to_file(\n+                scope_metadata.unwrap(),\n+                &sm.lookup_char_pos(pos).file,\n+                defining_crate\n+            ))\n+        } else {\n+            scope_metadata\n+        }\n+    }\n+\n+    /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n+    /// or initializing the local with an operand (whichever applies).\n+    // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n+    // not just `llvm.dbg.declare` (which requires `alloca`).\n+    pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n+        // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n+        if local == mir::RETURN_PLACE {\n+            return;\n+        }\n+\n+        let vars = match &self.per_local_var_debug_info {\n+            Some(per_local) => &per_local[local],\n+            None => return,\n+        };\n+        let whole_local_var = vars.iter().find(|var| {\n+            var.place.projection.is_empty()\n+        });\n+        let has_proj = || vars.iter().any(|var| {\n+            !var.place.projection.is_empty()\n+        });\n+\n+        let (fallback_var, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+            let arg_index = local.index() - 1;\n+\n+            // Add debuginfo even to unnamed arguments.\n+            // FIXME(eddyb) is this really needed?\n+            let var = if arg_index == 0 && has_proj() {\n+                // Hide closure environments from debuginfo.\n+                // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n+                // be offset to account for the hidden environment?\n+                None\n+            } else {\n+                Some(VarDebugInfo {\n+                    name: kw::Invalid,\n+                    source_info: self.mir.local_decls[local].source_info,\n+                    place: local.into(),\n+                })\n+            };\n+            (var, VariableKind::ArgumentVariable(arg_index + 1))\n+        } else {\n+            (None, VariableKind::LocalVariable)\n+        };\n+\n+        let local_ref = &self.locals[local];\n+\n+        if !bx.sess().fewer_names() {\n+            let name = match whole_local_var.or(fallback_var.as_ref()) {\n+                Some(var) if var.name != kw::Invalid => var.name.to_string(),\n+                _ => format!(\"{:?}\", local),\n+            };\n+            match local_ref {\n+                LocalRef::Place(place) |\n+                LocalRef::UnsizedPlace(place) => {\n+                    bx.set_var_name(place.llval, &name);\n+                }\n+                LocalRef::Operand(Some(operand)) => match operand.val {\n+                    OperandValue::Ref(x, ..) |\n+                    OperandValue::Immediate(x) => {\n+                        bx.set_var_name(x, &name);\n+                    }\n+                    OperandValue::Pair(a, b) => {\n+                        // FIXME(eddyb) these are scalar components,\n+                        // maybe extract the high-level fields?\n+                        bx.set_var_name(a, &(name.clone() + \".0\"));\n+                        bx.set_var_name(b, &(name + \".1\"));\n+                    }\n+                }\n+                LocalRef::Operand(None) => {}\n+            }\n+        }\n+\n+        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+            return;\n+        }\n+\n+        let debug_context = match &self.debug_context {\n+            Some(debug_context) => debug_context,\n+            None => return,\n+        };\n+\n+        // FIXME(eddyb) add debuginfo for unsized places too.\n+        let base = match local_ref {\n+            LocalRef::Place(place) => place,\n+            _ => return,\n+        };\n+\n+        let vars = vars.iter().chain(if whole_local_var.is_none() {\n+            fallback_var.as_ref()\n+        } else {\n+            None\n+        });\n+\n+        for var in vars {\n+            let mut layout = base.layout;\n+            let mut direct_offset = Size::ZERO;\n+            // FIXME(eddyb) use smallvec here.\n+            let mut indirect_offsets = vec![];\n+\n+            let kind = if var.place.projection.is_empty() {\n+                kind\n+            } else {\n+                VariableKind::LocalVariable\n+            };\n+\n+            for elem in &var.place.projection[..] {\n+                match *elem {\n+                    mir::ProjectionElem::Deref => {\n+                        indirect_offsets.push(Size::ZERO);\n+                        layout = bx.cx().layout_of(\n+                            layout.ty.builtin_deref(true)\n+                                .unwrap_or_else(|| {\n+                                    span_bug!(\n+                                        var.source_info.span,\n+                                        \"cannot deref `{}`\",\n+                                        layout.ty,\n+                                    )\n+                                }).ty,\n+                        );\n+                    }\n+                    mir::ProjectionElem::Field(field, _) => {\n+                        let i = field.index();\n+                        let offset = indirect_offsets.last_mut()\n+                            .unwrap_or(&mut direct_offset);\n+                        *offset += layout.fields.offset(i);\n+                        layout = layout.field(bx.cx(), i);\n+                    }\n+                    mir::ProjectionElem::Downcast(_, variant) => {\n+                        layout = layout.for_variant(bx.cx(), variant);\n+                    }\n+                    _ => span_bug!(\n+                        var.source_info.span,\n+                        \"unsupported var debuginfo place `{:?}`\",\n+                        var.place,\n+                    ),\n+                }\n+            }\n+\n+            let (scope, span) = self.debug_loc(var.source_info);\n+            if let Some(scope) = scope {\n+                bx.declare_local(debug_context, var.name, layout.ty, scope,\n+                    base.llval, direct_offset, &indirect_offsets, kind, span);\n+            }\n+        }\n+    }\n+\n+    pub fn debug_introduce_locals(&self, bx: &mut Bx) {\n+        if bx.sess().opts.debuginfo == DebugInfo::Full || !bx.sess().fewer_names() {\n+            for local in self.locals.indices() {\n+                self.debug_introduce_local(bx, local);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn per_local_var_debug_info(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mir::Body<'tcx>,\n+) -> Option<IndexVec<mir::Local, Vec<VarDebugInfo<'tcx>>>> {\n+    if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n+        let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n+            if let Some(name) = decl.name {\n+                per_local[local].push(VarDebugInfo {\n+                    name,\n+                    source_info: mir::SourceInfo {\n+                        span: decl.source_info.span,\n+                        scope: decl.visibility_scope,\n+                    },\n+                    place: local.into(),\n+                });\n+            }\n+        }\n+\n+        let upvar_debuginfo = &body.__upvar_debuginfo_codegen_only_do_not_use;\n+        if !upvar_debuginfo.is_empty() {\n+\n+            let env_arg = mir::Local::new(1);\n+            let mut env_projs = vec![];\n+\n+            let pin_did = tcx.lang_items().pin_type();\n+            match body.local_decls[env_arg].ty.kind {\n+                ty::RawPtr(_) |\n+                ty::Ref(..)  => {\n+                    env_projs.push(mir::ProjectionElem::Deref);\n+                }\n+                ty::Adt(def, substs) if Some(def.did) == pin_did => {\n+                    if let ty::Ref(..) = substs.type_at(0).kind {\n+                        env_projs.push(mir::ProjectionElem::Field(\n+                            mir::Field::new(0),\n+                            // HACK(eddyb) field types aren't used or needed here.\n+                            tcx.types.err,\n+                        ));\n+                        env_projs.push(mir::ProjectionElem::Deref);\n+                    }\n+                }\n+                _ => {}\n+            }\n+\n+            let extra_locals = {\n+                let upvars = upvar_debuginfo\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, upvar)| {\n+                        let source_info = mir::SourceInfo {\n+                            span: body.span,\n+                            scope: mir::OUTERMOST_SOURCE_SCOPE,\n+                        };\n+                        (None, i, upvar.debug_name, upvar.by_ref, source_info)\n+                    });\n+\n+                let generator_fields = body.generator_layout.as_ref().map(|generator_layout| {\n+                    generator_layout.variant_fields.iter()\n+                        .enumerate()\n+                        .flat_map(move |(variant_idx, fields)| {\n+                            let variant_idx = Some(VariantIdx::from(variant_idx));\n+                            fields.iter()\n+                                .enumerate()\n+                                .filter_map(move |(i, field)| {\n+                                    let decl = &generator_layout.\n+                                        __local_debuginfo_codegen_only_do_not_use[*field];\n+                                    if let Some(name) = decl.name {\n+                                        let source_info = mir::SourceInfo {\n+                                            span: decl.source_info.span,\n+                                            scope: decl.visibility_scope,\n+                                        };\n+                                        Some((variant_idx, i, name, false, source_info))\n+                                    } else {\n+                                        None\n+                                    }\n+                            })\n+                        })\n+                }).into_iter().flatten();\n+\n+                upvars.chain(generator_fields)\n+            };\n+\n+            for (variant_idx, field, name, by_ref, source_info) in extra_locals {\n+                let mut projs = env_projs.clone();\n+\n+                if let Some(variant_idx) = variant_idx {\n+                    projs.push(mir::ProjectionElem::Downcast(None, variant_idx));\n+                }\n+\n+                projs.push(mir::ProjectionElem::Field(\n+                    mir::Field::new(field),\n+                    // HACK(eddyb) field types aren't used or needed here.\n+                    tcx.types.err,\n+                ));\n+\n+                if by_ref {\n+                    projs.push(mir::ProjectionElem::Deref);\n+                }\n+\n+                per_local[env_arg].push(VarDebugInfo {\n+                    name,\n+                    source_info,\n+                    place: mir::Place {\n+                        base: mir::PlaceBase::Local(env_arg),\n+                        projection: tcx.intern_place_elems(&projs),\n+                    },\n+                });\n+            }\n+        }\n+\n+        Some(per_local)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Debug information relatating to an user variable.\n+// FIXME(eddyb) move this to the MIR bodies themselves.\n+#[derive(Clone)]\n+pub struct VarDebugInfo<'tcx> {\n+    pub name: Symbol,\n+\n+    /// Source info of the user variable, including the scope\n+    /// within which the variable is visible (to debuginfo)\n+    /// (see `LocalDecl`'s `source_info` field for more details).\n+    pub source_info: mir::SourceInfo,\n+\n+    /// Where the data for this user variable is to be found.\n+    pub place: mir::Place<'tcx>,\n+}"}, {"sha": "5ad14456285ba80a7af96810ffbc7374e5275450", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 31, "deletions": 324, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,22 +1,17 @@\n-use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts, Instance};\n+use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Body};\n-use rustc::session::config::DebugInfo;\n use rustc_target::abi::call::{FnType, PassMode};\n-use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n-use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, BytePos, Span};\n-use syntax::symbol::kw;\n-\n use std::iter;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use self::analyze::CleanupKind;\n+use self::debuginfo::FunctionDebugContext;\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n@@ -28,7 +23,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     mir: &'a mir::Body<'tcx>,\n \n-    debug_context: FunctionDebugContext<Bx::DIScope>,\n+    debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n     llfn: Bx::Function,\n \n@@ -79,8 +74,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n-    /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n+    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<debuginfo::VarDebugInfo<'tcx>>>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -93,64 +87,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             value,\n         )\n     }\n-\n-    pub fn set_debug_loc(\n-        &mut self,\n-        bx: &mut Bx,\n-        source_info: mir::SourceInfo\n-    ) {\n-        let (scope, span) = self.debug_loc(source_info);\n-        bx.set_source_location(&mut self.debug_context, scope, span);\n-    }\n-\n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n-        // Bail out if debug info emission is not enabled.\n-        match self.debug_context {\n-            FunctionDebugContext::DebugInfoDisabled |\n-            FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                return (self.scopes[source_info.scope].scope_metadata, source_info.span);\n-            }\n-            FunctionDebugContext::RegularContext(_) =>{}\n-        }\n-\n-        // In order to have a good line stepping behavior in debugger, we overwrite debug\n-        // locations of macro expansions with that of the outermost expansion site\n-        // (unless the crate is being compiled with `-Z debug-macros`).\n-        if !source_info.span.from_expansion() ||\n-           self.cx.sess().opts.debugging_opts.debug_macros {\n-            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n-            (scope, source_info.span)\n-        } else {\n-            // Walk up the macro expansion chain until we reach a non-expanded span.\n-            // We also stop at the function body level because no line stepping can occur\n-            // at the level above that.\n-            let span = syntax_pos::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n-            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n-            // Use span of the outermost expansion site, while keeping the original lexical scope.\n-            (scope, span)\n-        }\n-    }\n-\n-    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n-    // it may so happen that the current span belongs to a different file than the DIScope\n-    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n-    // \"extension\" into that file.\n-    fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                              -> Option<Bx::DIScope> {\n-        let scope_metadata = self.scopes[scope_id].scope_metadata;\n-        if pos < self.scopes[scope_id].file_start_pos ||\n-           pos >= self.scopes[scope_id].file_end_pos {\n-            let sm = self.cx.sess().source_map();\n-            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            Some(self.cx.extend_scope_to_file(\n-                scope_metadata.unwrap(),\n-                &sm.lookup_char_pos(pos).file,\n-                defining_crate\n-            ))\n-        } else {\n-            scope_metadata\n-        }\n-    }\n }\n \n enum LocalRef<'tcx, V> {\n@@ -192,8 +128,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n-    let mut debug_context =\n+\n+    let debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);\n+\n     let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n@@ -215,8 +153,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n         }).collect();\n \n-    // Compute debuginfo scopes from MIR scopes.\n-    let scopes = cx.create_mir_scopes(mir, &mut debug_context);\n     let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n@@ -231,9 +167,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cleanup_kinds,\n         landing_pads,\n         funclets,\n-        scopes,\n         locals: IndexVec::new(),\n         debug_context,\n+        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir),\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);\n@@ -247,62 +183,22 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n-            if let Some(name) = decl.name {\n-                // User variable\n-                let debug_scope = fx.scopes[decl.visibility_scope];\n-                let dbg = debug_scope.is_valid() &&\n-                    bx.sess().opts.debuginfo == DebugInfo::Full;\n-\n-                if !memory_locals.contains(local) && !dbg {\n-                    debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(&mut bx, layout);\n-                }\n+            if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n+                debug!(\"alloc: {:?} (return place) -> place\", local);\n+                let llretptr = bx.get_param(0);\n+                return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n+            }\n \n-                debug!(\"alloc: {:?} ({}) -> place\", local, name);\n+            if memory_locals.contains(local) {\n+                debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n-                    bx.set_var_name(indirect_place.llval, name);\n-                    // FIXME: add an appropriate debuginfo\n-                    LocalRef::UnsizedPlace(indirect_place)\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout);\n-                    bx.set_var_name(place.llval, name);\n-                    if dbg {\n-                        let (scope, span) = fx.debug_loc(mir::SourceInfo {\n-                            span: decl.source_info.span,\n-                            scope: decl.visibility_scope,\n-                        });\n-                        bx.declare_local(&fx.debug_context, name, layout.ty, scope.unwrap(),\n-                            VariableAccess::DirectVariable { alloca: place.llval },\n-                            VariableKind::LocalVariable, span);\n-                    }\n-                    LocalRef::Place(place)\n+                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n                 }\n             } else {\n-                // Temporary or return place\n-                if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n-                    debug!(\"alloc: {:?} (return place) -> place\", local);\n-                    let llretptr = bx.get_param(0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout))\n-                } else if memory_locals.contains(local) {\n-                    debug!(\"alloc: {:?} -> place\", local);\n-                    if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n-                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n-                        LocalRef::UnsizedPlace(indirect_place)\n-                    } else {\n-                        let place = PlaceRef::alloca(&mut bx, layout);\n-                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n-                        LocalRef::Place(place)\n-                    }\n-                } else {\n-                    // If this is an immediate local, we do not create an\n-                    // alloca in advance. Instead we wait until we see the\n-                    // definition and update the operand there.\n-                    debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(&mut bx, layout)\n-                }\n+                debug!(\"alloc: {:?} -> operand\", local);\n+                LocalRef::new_operand(&mut bx, layout)\n             }\n         };\n \n@@ -313,6 +209,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             .collect()\n     };\n \n+    // Apply debuginfo to the newly allocated locals.\n+    fx.debug_introduce_locals(&mut bx);\n+\n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n         bx.br(fx.blocks[mir::START_BLOCK]);\n@@ -321,7 +220,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&mut fx.debug_context);\n+    if let Some(debug_context) = &mut fx.debug_context {\n+        debug_context.source_locations_enabled = true;\n+    }\n \n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n@@ -421,28 +322,12 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n-    let tcx = fx.cx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n-    // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = fx.scopes[mir::OUTERMOST_SOURCE_SCOPE];\n-    let arg_scope = if bx.sess().opts.debuginfo == DebugInfo::Full {\n-        arg_scope.scope_metadata\n-    } else {\n-        None\n-    };\n-\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n-        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n-        let name = if let Some(name) = arg_decl.name {\n-            name.as_str().to_string()\n-        } else {\n-            format!(\"{:?}\", local)\n-        };\n-\n         if Some(local) == mir.spread_arg {\n             // This argument (e.g., the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n@@ -456,7 +341,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             };\n \n             let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n-            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -467,47 +351,15 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 bx.store_fn_arg(arg, &mut llarg_idx, pr_field);\n             }\n \n-            // Now that we have one alloca that contains the aggregate value,\n-            // we can create one debuginfo entry for the argument.\n-            arg_scope.map(|scope| {\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: place.llval\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    arg_ty, scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-            });\n-\n             return LocalRef::Place(place);\n         }\n \n         if fx.fn_ty.c_variadic && arg_index == fx.fn_ty.args.len() {\n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n \n             let va_list = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n-            bx.set_var_name(va_list.llval, name);\n             bx.va_start(va_list.llval);\n \n-            arg_scope.map(|scope| {\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: va_list.llval\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    va_list.layout.ty,\n-                    scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-            });\n-\n             return LocalRef::Place(va_list);\n         }\n \n@@ -517,7 +369,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n         }\n \n-        if arg_scope.is_none() && !memory_locals.contains(local) {\n+        if !memory_locals.contains(local) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n@@ -528,7 +380,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n@@ -537,11 +388,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n                     llarg_idx += 2;\n \n-                    // FIXME(eddyb) these are scalar components,\n-                    // maybe extract the high-level fields?\n-                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n-                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n-\n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n                         layout: arg.layout\n@@ -551,14 +397,13 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n         }\n \n-        let place = if arg.is_sized_indirect() {\n+        if arg.is_sized_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout)\n+            LocalRef::Place(PlaceRef::new_sized(llarg, arg.layout))\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer.\n@@ -569,158 +414,20 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n             let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n-            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n-            tmp\n+            LocalRef::UnsizedPlace(tmp)\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout);\n-            bx.set_var_name(tmp.llval, name);\n             bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-            tmp\n-        };\n-        let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n-        arg_scope.map(|scope| {\n-            // Is this a regular argument?\n-            if arg_index > 0 || upvar_debuginfo.is_empty() {\n-                // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n-                // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n-                // byval attribute, for which LLVM always does the deref itself,\n-                // so we must not add it.\n-                let variable_access = VariableAccess::DirectVariable {\n-                    alloca: place.llval\n-                };\n-\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    arg_decl.name.unwrap_or(kw::Invalid),\n-                    arg.layout.ty,\n-                    scope,\n-                    variable_access,\n-                    VariableKind::ArgumentVariable(arg_index + 1),\n-                    DUMMY_SP\n-                );\n-                return;\n-            }\n-\n-            let pin_did = tcx.lang_items().pin_type();\n-            // Or is it the closure environment?\n-            let (closure_layout, env_ref) = match arg.layout.ty.kind {\n-                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n-                ty::Adt(def, substs) if Some(def.did) == pin_did => {\n-                    match substs.type_at(0).kind {\n-                        ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n-                        _ => (arg.layout, false),\n-                    }\n-                }\n-                _ => (arg.layout, false)\n-            };\n-\n-            let (def_id, upvar_substs) = match closure_layout.ty.kind {\n-                ty::Closure(def_id, substs) => (def_id,\n-                    UpvarSubsts::Closure(substs)),\n-                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n-            };\n-            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n-\n-            let extra_locals = {\n-                let upvars = upvar_debuginfo\n-                    .iter()\n-                    .zip(upvar_tys)\n-                    .enumerate()\n-                    .map(|(i, (upvar, ty))| {\n-                        (None, i, upvar.debug_name, upvar.by_ref, ty, scope, DUMMY_SP)\n-                    });\n-\n-                let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n-                    let (def_id, gen_substs) = match closure_layout.ty.kind {\n-                        ty::Generator(def_id, substs, _) => (def_id, substs),\n-                        _ => bug!(\"generator layout without generator substs\"),\n-                    };\n-                    let state_tys = gen_substs.as_generator().state_tys(def_id, tcx);\n-\n-                    generator_layout.variant_fields.iter()\n-                        .zip(state_tys)\n-                        .enumerate()\n-                        .flat_map(move |(variant_idx, (fields, tys))| {\n-                            let variant_idx = Some(VariantIdx::from(variant_idx));\n-                            fields.iter()\n-                                .zip(tys)\n-                                .enumerate()\n-                                .filter_map(move |(i, (field, ty))| {\n-                                    let decl = &generator_layout.\n-                                        __local_debuginfo_codegen_only_do_not_use[*field];\n-                                    if let Some(name) = decl.name {\n-                                        let ty = fx.monomorphize(&ty);\n-                                        let (var_scope, var_span) = fx.debug_loc(mir::SourceInfo {\n-                                            span: decl.source_info.span,\n-                                            scope: decl.visibility_scope,\n-                                        });\n-                                        let var_scope = var_scope.unwrap_or(scope);\n-                                        Some((variant_idx, i, name, false, ty, var_scope, var_span))\n-                                    } else {\n-                                        None\n-                                    }\n-                            })\n-                        })\n-                }).into_iter().flatten();\n-\n-                upvars.chain(generator_fields)\n-            };\n-\n-            for (variant_idx, field, name, by_ref, ty, var_scope, var_span) in extra_locals {\n-                let fields = match variant_idx {\n-                    Some(variant_idx) => {\n-                        match &closure_layout.variants {\n-                            Variants::Multiple { variants, .. } => {\n-                                &variants[variant_idx].fields\n-                            },\n-                            _ => bug!(\"variant index on univariant layout\"),\n-                        }\n-                    }\n-                    None => &closure_layout.fields,\n-                };\n-                let byte_offset_of_var_in_env = fields.offset(field).bytes();\n-\n-                let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n-\n-                // The environment and the capture can each be indirect.\n-                let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n-\n-                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.kind) {\n-                    ty\n-                } else {\n-                    ops = &ops[..ops.len() - 1];\n-                    ty\n-                };\n-\n-                let variable_access = VariableAccess::IndirectVariable {\n-                    alloca: place.llval,\n-                    address_operations: &ops\n-                };\n-                bx.declare_local(\n-                    &fx.debug_context,\n-                    name,\n-                    ty,\n-                    var_scope,\n-                    variable_access,\n-                    VariableKind::LocalVariable,\n-                    var_span\n-                );\n-            }\n-        });\n-        if arg.is_unsized_indirect() {\n-            LocalRef::UnsizedPlace(place)\n-        } else {\n-            LocalRef::Place(place)\n+            LocalRef::Place(tmp)\n         }\n     }).collect()\n }\n \n mod analyze;\n mod block;\n pub mod constant;\n+pub mod debuginfo;\n pub mod place;\n pub mod operand;\n mod rvalue;"}, {"sha": "3e7c4ef49fb5aeab6452dcf7aa71f43235ae3712", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -68,6 +68,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n     }\n \n+    // FIXME(eddyb) pass something else for the name so no work is done\n+    // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n@@ -78,6 +80,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n+    // FIXME(eddyb) pass something else for the name so no work is done\n+    // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,"}, {"sha": "d11601be0b4ab3d02e0a249a0ab4874997ce6d05", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -27,21 +27,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[index].name {\n-                                match operand.val {\n-                                    OperandValue::Ref(x, ..) |\n-                                    OperandValue::Immediate(x) => {\n-                                        bx.set_var_name(x, name);\n-                                    }\n-                                    OperandValue::Pair(a, b) => {\n-                                        // FIXME(eddyb) these are scalar components,\n-                                        // maybe extract the high-level fields?\n-                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n-                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n-                                    }\n-                                }\n-                            }\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n+                            self.debug_introduce_local(&mut bx, index);\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {"}, {"sha": "802eaaa357ac09c4ea4245a2f28697fa99de909f", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -1,9 +1,9 @@\n use super::BackendTypes;\n-use crate::debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n+use crate::mir::debuginfo::{FunctionDebugContext, VariableKind};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::ty::{self, Ty, Instance};\n-use rustc_index::vec::IndexVec;\n+use rustc::ty::layout::Size;\n use syntax::ast::Name;\n use syntax_pos::{SourceFile, Span};\n \n@@ -13,30 +13,22 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n     /// Creates the function-specific debug context.\n     ///\n     /// Returns the FunctionDebugContext for the function which holds state needed\n-    /// for debug info creation. The function may also return another variant of the\n-    /// FunctionDebugContext enum which indicates why no debuginfo should be created\n-    /// for the function.\n+    /// for debug info creation, if it is enabled.\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: Self::Function,\n         mir: &mir::Body<'_>,\n-    ) -> FunctionDebugContext<Self::DIScope>;\n+    ) -> Option<FunctionDebugContext<Self::DIScope>>;\n \n-    fn create_mir_scopes(\n-        &self,\n-        mir: &mir::Body<'_>,\n-        debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-    ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n     fn extend_scope_to_file(\n         &self,\n         scope_metadata: Self::DIScope,\n         file: &SourceFile,\n         defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n-    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4];\n }\n \n pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n@@ -46,16 +38,19 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n         variable_name: Name,\n         variable_type: Ty<'tcx>,\n         scope_metadata: Self::DIScope,\n-        variable_access: VariableAccess<'_, Self::Value>,\n+        variable_alloca: Self::Value,\n+        direct_offset: Size,\n+        // NB: each offset implies a deref (i.e. they're steps in a pointer chain).\n+        indirect_offsets: &[Size],\n         variable_kind: VariableKind,\n         span: Span,\n     );\n     fn set_source_location(\n         &mut self,\n         debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-        scope: Option<Self::DIScope>,\n+        scope: Self::DIScope,\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n-    fn set_var_name(&mut self, value: Self::Value, name: impl ToString);\n+    fn set_var_name(&mut self, value: Self::Value, name: &str);\n }"}, {"sha": "4a5b7c05231dcb05f428f70ce3a91b46b4cc8c4a", "filename": "src/test/codegen/optimize-attr-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -8,7 +8,7 @@\n \n // CHECK-LABEL: define i32 @nothing\n // CHECK-SAME: [[NOTHING_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 4\n // SPEEC-OPT: ret i32 4\n #[no_mangle]\n@@ -18,7 +18,7 @@ pub fn nothing() -> i32 {\n \n // CHECK-LABEL: define i32 @size\n // CHECK-SAME: [[SIZE_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 6\n // SPEED-OPT: ret i32 6\n #[optimize(size)]\n@@ -31,7 +31,7 @@ pub fn size() -> i32 {\n // NO-OPT-SAME: [[NOTHING_ATTRS]]\n // SPEED-OPT-SAME: [[NOTHING_ATTRS]]\n // SIZE-OPT-SAME: [[SPEED_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 8\n // SPEED-OPT: ret i32 8\n #[optimize(speed)]"}, {"sha": "267c995e0704ff453534de86a953c3ba67aa0aee", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-arithmetic-saturating.rs", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -116,143 +116,150 @@ extern \"platform-intrinsic\" {\n     fn simd_saturating_sub<T>(x: T, y: T) -> T;\n }\n \n+// NOTE(eddyb) `%{{x|_3}}` is used because on some targets (e.g. WASM)\n+// SIMD vectors are passed directly, resulting in `%x` being a vector,\n+// while on others they're passed indirectly, resulting in `%x` being\n+// a pointer to a vector, and `%_3` a vector loaded from that pointer.\n+// This is controlled by the target spec option `simd_types_indirect`.\n+// The same applies to `%{{y|_4}}` as well.\n+\n // CHECK-LABEL: @sadd_i8x2\n #[no_mangle]\n pub unsafe fn sadd_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x4\n #[no_mangle]\n pub unsafe fn sadd_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x8\n #[no_mangle]\n pub unsafe fn sadd_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x16\n #[no_mangle]\n pub unsafe fn sadd_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x32\n #[no_mangle]\n pub unsafe fn sadd_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x64\n #[no_mangle]\n pub unsafe fn sadd_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x2\n #[no_mangle]\n pub unsafe fn sadd_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x4\n #[no_mangle]\n pub unsafe fn sadd_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x8\n #[no_mangle]\n pub unsafe fn sadd_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x16\n #[no_mangle]\n pub unsafe fn sadd_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x32\n #[no_mangle]\n pub unsafe fn sadd_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x2\n #[no_mangle]\n pub unsafe fn sadd_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x4\n #[no_mangle]\n pub unsafe fn sadd_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x8\n #[no_mangle]\n pub unsafe fn sadd_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x16\n #[no_mangle]\n pub unsafe fn sadd_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x2\n #[no_mangle]\n pub unsafe fn sadd_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x4\n #[no_mangle]\n pub unsafe fn sadd_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x8\n #[no_mangle]\n pub unsafe fn sadd_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x2\n #[no_mangle]\n pub unsafe fn sadd_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x4\n #[no_mangle]\n pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n@@ -261,140 +268,140 @@ pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @uadd_u8x2\n #[no_mangle]\n pub unsafe fn uadd_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x4\n #[no_mangle]\n pub unsafe fn uadd_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x8\n #[no_mangle]\n pub unsafe fn uadd_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x16\n #[no_mangle]\n pub unsafe fn uadd_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x32\n #[no_mangle]\n pub unsafe fn uadd_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x64\n #[no_mangle]\n pub unsafe fn uadd_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x2\n #[no_mangle]\n pub unsafe fn uadd_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x4\n #[no_mangle]\n pub unsafe fn uadd_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x8\n #[no_mangle]\n pub unsafe fn uadd_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x16\n #[no_mangle]\n pub unsafe fn uadd_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x32\n #[no_mangle]\n pub unsafe fn uadd_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x2\n #[no_mangle]\n pub unsafe fn uadd_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x4\n #[no_mangle]\n pub unsafe fn uadd_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x8\n #[no_mangle]\n pub unsafe fn uadd_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x16\n #[no_mangle]\n pub unsafe fn uadd_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x2\n #[no_mangle]\n pub unsafe fn uadd_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x4\n #[no_mangle]\n pub unsafe fn uadd_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x8\n #[no_mangle]\n pub unsafe fn uadd_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x2\n #[no_mangle]\n pub unsafe fn uadd_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x4\n #[no_mangle]\n pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n@@ -405,140 +412,140 @@ pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n // CHECK-LABEL: @ssub_i8x2\n #[no_mangle]\n pub unsafe fn ssub_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x4\n #[no_mangle]\n pub unsafe fn ssub_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x8\n #[no_mangle]\n pub unsafe fn ssub_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x16\n #[no_mangle]\n pub unsafe fn ssub_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x32\n #[no_mangle]\n pub unsafe fn ssub_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x64\n #[no_mangle]\n pub unsafe fn ssub_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x2\n #[no_mangle]\n pub unsafe fn ssub_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x4\n #[no_mangle]\n pub unsafe fn ssub_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x8\n #[no_mangle]\n pub unsafe fn ssub_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x16\n #[no_mangle]\n pub unsafe fn ssub_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x32\n #[no_mangle]\n pub unsafe fn ssub_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x2\n #[no_mangle]\n pub unsafe fn ssub_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x4\n #[no_mangle]\n pub unsafe fn ssub_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x8\n #[no_mangle]\n pub unsafe fn ssub_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x16\n #[no_mangle]\n pub unsafe fn ssub_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x2\n #[no_mangle]\n pub unsafe fn ssub_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x4\n #[no_mangle]\n pub unsafe fn ssub_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x8\n #[no_mangle]\n pub unsafe fn ssub_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x2\n #[no_mangle]\n pub unsafe fn ssub_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x4\n #[no_mangle]\n pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n@@ -547,139 +554,139 @@ pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @usub_u8x2\n #[no_mangle]\n pub unsafe fn usub_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x4\n #[no_mangle]\n pub unsafe fn usub_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x8\n #[no_mangle]\n pub unsafe fn usub_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x16\n #[no_mangle]\n pub unsafe fn usub_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x32\n #[no_mangle]\n pub unsafe fn usub_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x64\n #[no_mangle]\n pub unsafe fn usub_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x2\n #[no_mangle]\n pub unsafe fn usub_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x4\n #[no_mangle]\n pub unsafe fn usub_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x8\n #[no_mangle]\n pub unsafe fn usub_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x16\n #[no_mangle]\n pub unsafe fn usub_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x32\n #[no_mangle]\n pub unsafe fn usub_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x2\n #[no_mangle]\n pub unsafe fn usub_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x4\n #[no_mangle]\n pub unsafe fn usub_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x8\n #[no_mangle]\n pub unsafe fn usub_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x16\n #[no_mangle]\n pub unsafe fn usub_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x2\n #[no_mangle]\n pub unsafe fn usub_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x4\n #[no_mangle]\n pub unsafe fn usub_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x8\n #[no_mangle]\n pub unsafe fn usub_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x2\n #[no_mangle]\n pub unsafe fn usub_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x4\n #[no_mangle]\n pub unsafe fn usub_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }"}, {"sha": "87c8b0d87d8bbc575425b69fe327a68d3f0bf2c7", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-bitmask.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e5d91482e3e8fb9f55efabab760db2d50ddaff/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs?ref=01e5d91482e3e8fb9f55efabab760db2d50ddaff", "patch": "@@ -26,10 +26,16 @@ extern \"platform-intrinsic\" {\n     fn simd_bitmask<T, U>(x: T) -> U;\n }\n \n+// NOTE(eddyb) `%{{x|_2}}` is used because on some targets (e.g. WASM)\n+// SIMD vectors are passed directly, resulting in `%x` being a vector,\n+// while on others they're passed indirectly, resulting in `%x` being\n+// a pointer to a vector, and `%_2` a vector loaded from that pointer.\n+// This is controlled by the target spec option `simd_types_indirect`.\n+\n // CHECK-LABEL: @bitmask_int\n #[no_mangle]\n pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{[0-9a-z]+}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -39,7 +45,7 @@ pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n // CHECK-LABEL: @bitmask_uint\n #[no_mangle]\n pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{[0-9a-z]+}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -49,7 +55,7 @@ pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n // CHECK-LABEL: @bitmask_int16\n #[no_mangle]\n pub unsafe fn bitmask_int16(x: i8x16) -> u16 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{[0-9a-z]+}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n+    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{x|_2}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n     // CHECK: [[B:%[0-9]+]] = trunc <16 x i8> [[A]] to <16 x i1>\n     // CHECK: %{{[0-9]+}} = bitcast <16 x i1> [[B]] to i16\n     // CHECK-NOT: zext"}]}