{"sha": "41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZjFlMTg5ZWUyYjA3ODgzOGZjZDJmNzU1MGQxNGU5ZjFmZDVlNDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-20T08:32:15Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-24T00:23:03Z"}, "message": "Use `DefId`s instead of `NodeId`s for `pub(restricted)` visibilities.", "tree": {"sha": "fa6d6e101903f2abccd7ef8fa882c18f6cc5f97f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa6d6e101903f2abccd7ef8fa882c18f6cc5f97f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "html_url": "https://github.com/rust-lang/rust/commit/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467a7f049bac0386097c6cd2c80966c8d7453ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/467a7f049bac0386097c6cd2c80966c8d7453ce8", "html_url": "https://github.com/rust-lang/rust/commit/467a7f049bac0386097c6cd2c80966c8d7453ce8"}], "stats": {"total": 298, "additions": 137, "deletions": 161}, "files": [{"sha": "89e976598bf92533ba9c3c996d98c5a6330af319", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -219,63 +219,65 @@ pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n     /// Visible only in the given crate-local module.\n-    Restricted(NodeId),\n+    Restricted(DefId),\n     /// Not visible anywhere in the local crate. This is the visibility of private external items.\n-    PrivateExternal,\n+    Invisible,\n }\n \n-pub trait NodeIdTree {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool;\n+pub trait DefIdTree: Copy {\n+    fn parent(self, id: DefId) -> Option<DefId>;\n }\n \n-impl<'a> NodeIdTree for ast_map::Map<'a> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let mut node_ancestor = node;\n-        while node_ancestor != ancestor {\n-            let node_ancestor_parent = self.get_module_parent(node_ancestor);\n-            if node_ancestor_parent == node_ancestor {\n-                return false;\n-            }\n-            node_ancestor = node_ancestor_parent;\n-        }\n-        true\n+impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn parent(self, id: DefId) -> Option<DefId> {\n+        self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n     }\n }\n \n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n         match *visibility {\n             hir::Public => Visibility::Public,\n-            hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n+            hir::Visibility::Crate => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n             hir::Visibility::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n-                def => Visibility::Restricted(tcx.map.as_local_node_id(def.def_id()).unwrap()),\n+                def => Visibility::Restricted(def.def_id()),\n             },\n-            hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n+            hir::Inherited => {\n+                Visibility::Restricted(tcx.map.local_def_id(tcx.map.get_module_parent(id)))\n+            }\n         }\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: NodeIdTree>(self, block: NodeId, tree: &T) -> bool {\n+    pub fn is_accessible_from<T: DefIdTree>(self, mut module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n             // Private items from other crates are visible nowhere.\n-            Visibility::PrivateExternal => return false,\n+            Visibility::Invisible => return false,\n             // Restricted items are visible in an arbitrary local module.\n+            Visibility::Restricted(other) if other.krate != module.krate => return false,\n             Visibility::Restricted(module) => module,\n         };\n \n-        tree.is_descendant_of(block, restriction)\n+        while module != restriction {\n+            match tree.parent(module) {\n+                Some(parent) => module = parent,\n+                None => return false,\n+            }\n+        }\n+\n+        true\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least<T: NodeIdTree>(self, vis: Visibility, tree: &T) -> bool {\n+    pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n-            Visibility::PrivateExternal => return true,\n+            Visibility::Invisible => return true,\n             Visibility::Restricted(module) => module,\n         };\n \n@@ -1779,7 +1781,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>) -> bool {\n-        block.map_or(true, |b| self.vis.is_accessible_from(b, &tcx.map)) &&\n+        block.map_or(true, |b| tcx.vis_is_accessible_from(self.vis, b)) &&\n         self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n     }\n }\n@@ -2266,6 +2268,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn vis_is_accessible_from(self, vis: Visibility, block: NodeId) -> bool {\n+        vis.is_accessible_from(self.map.local_def_id(self.map.get_module_parent(block)), self)\n+    }\n+\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)"}, {"sha": "93c79046580794be7825f1e5c8403b87cbc9f50d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n                     name: self.item_name(index),\n-                    vis: f.visibility\n+                    vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n             disr_val: ConstInt::Infer(data.disr),\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.entry(id).visibility,\n+            false => self.entry(id).visibility.decode(self),\n         }\n     }\n \n@@ -885,7 +885,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Const,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n@@ -898,7 +898,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Method,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: data.container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 ty::AssociatedItem {\n                     name: name,\n                     kind: ty::AssociatedKind::Type,\n-                    vis: item.visibility,\n+                    vis: item.visibility.decode(self),\n                     defaultness: container.defaultness(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),"}, {"sha": "bc0a64b9a51700a58426fc0608fdfdd61ea852a5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n-            visibility: enum_vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Mod(self.lazy(&data)),\n-            visibility: vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(vis, id, tcx)),\n             span: self.lazy(&md.inner),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n@@ -327,30 +327,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-trait Visibility {\n-    fn simplify(&self) -> ty::Visibility;\n-}\n-\n-impl Visibility for hir::Visibility {\n-    fn simplify(&self) -> ty::Visibility {\n-        if *self == hir::Public {\n-            ty::Visibility::Public\n-        } else {\n-            ty::Visibility::PrivateExternal\n-        }\n-    }\n-}\n-\n-impl Visibility for ty::Visibility {\n-    fn simplify(&self) -> ty::Visibility {\n-        if *self == ty::Visibility::Public {\n-            ty::Visibility::Public\n-        } else {\n-            ty::Visibility::PrivateExternal\n-        }\n-    }\n-}\n-\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.lookup_adt_def(adt_def_id);\n@@ -386,7 +362,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Field,\n-            visibility: field.vis.simplify(),\n+            visibility: self.lazy(&field.vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n@@ -419,7 +395,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n-            visibility: struct_vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(struct_vis, struct_id, tcx)),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -485,7 +461,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: trait_item.vis.simplify(),\n+            visibility: self.lazy(&trait_item.vis),\n             span: self.lazy(&ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -574,7 +550,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: impl_item.vis.simplify(),\n+            visibility: self.lazy(&impl_item.vis),\n             span: self.lazy(&ast_item.span),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -736,7 +712,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: item.vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.id, tcx)),\n             span: self.lazy(&item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n@@ -849,7 +825,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n             })),\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&macro_def.span),\n \n             attributes: self.encode_attributes(&macro_def.attrs),\n@@ -950,7 +926,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: kind,\n-            visibility: nitem.vis.simplify(),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n             span: self.lazy(&nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n@@ -1032,7 +1008,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -1060,7 +1036,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Entry {\n             kind: EntryKind::Closure(self.lazy(&data)),\n-            visibility: ty::Visibility::Public,\n+            visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),"}, {"sha": "2bd5a9ea59d04274aeb723bc9d5dac88da80e421", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -201,7 +201,7 @@ pub struct TraitImpls {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n-    pub visibility: ty::Visibility,\n+    pub visibility: Lazy<ty::Visibility>,\n     pub span: Lazy<Span>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,"}, {"sha": "ca3e4e1c762c72e837bd3e0a49439b5aff75641d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -28,7 +28,7 @@ extern crate syntax_pos;\n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -391,7 +391,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n \n struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    curitem: ast::NodeId,\n+    curitem: DefId,\n     in_foreign: bool,\n }\n \n@@ -401,12 +401,12 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             Some(node_id) =>\n                 ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n             None => self.tcx.sess.cstore.visibility(did),\n-        }.is_accessible_from(self.curitem, &self.tcx.map)\n+        }.is_accessible_from(self.curitem, self.tcx)\n     }\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n+        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                       field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_curitem = replace(&mut self.curitem, item.id);\n+        let orig_curitem = replace(&mut self.curitem, self.tcx.map.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                 if let Def::StructCtor(_, CtorKind::Fn) = path.def {\n                     let adt_def = self.tcx.expect_variant_def(path.def);\n                     let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n-                        !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n+                        !field.vis.is_accessible_from(self.curitem, self.tcx)\n                     }).map(|(i, _)| i).collect::<Vec<_>>();\n \n                     if !private_indexes.is_empty() {\n@@ -940,7 +940,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             ty::TyAdt(adt, _) => Some(adt.did),\n             ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => {\n-                if self.required_visibility == ty::Visibility::PrivateExternal {\n+                if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -961,10 +961,10 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                 let item = self.tcx.map.expect_item(node_id);\n                 let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n-                if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                if !vis.is_at_least(self.min_visibility, self.tcx) {\n                     self.min_visibility = vis;\n                 }\n-                if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                if !vis.is_at_least(self.required_visibility, self.tcx) {\n                     if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n                         let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n                             \"private type `{}` in public interface\", ty);\n@@ -996,10 +996,10 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n-            if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+            if !vis.is_at_least(self.min_visibility, self.tcx) {\n                 self.min_visibility = vis;\n             }\n-            if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+            if !vis.is_at_least(self.required_visibility, self.tcx) {\n                 if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n                     struct_span_err!(self.tcx.sess, self.span, E0445,\n                                      \"private trait `{}` in public interface\", trait_ref)\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n         let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, &tcx.map) { vis2 } else { vis1 }\n+            if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n         };\n \n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n@@ -1137,8 +1137,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n-                let ty_vis = self.check(item.id, ty::Visibility::PrivateExternal)\n-                                 .item_type().min_visibility;\n+                let ty_vis =\n+                    self.check(item.id, ty::Visibility::Invisible).item_type().min_visibility;\n                 self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n-                let vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                let vis = self.check(item.id, ty::Visibility::Invisible)\n                               .item_type().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n@@ -1203,7 +1203,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n-        curitem: ast::DUMMY_NODE_ID,\n+        curitem: DefId::local(CRATE_DEF_INDEX),\n         in_foreign: false,\n         tcx: tcx,\n     };"}, {"sha": "758b93aed6711ae7ce706f545cb445e03120352d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -229,7 +229,7 @@ impl<'a> Resolver<'a> {\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport {\n                             is_prelude: is_prelude,\n-                            max_vis: Cell::new(ty::Visibility::PrivateExternal),\n+                            max_vis: Cell::new(ty::Visibility::Invisible),\n                         };\n                         self.add_import_directive(\n                             module_path, subclass, view_path.span, item.id, vis, expansion,\n@@ -265,16 +265,16 @@ impl<'a> Resolver<'a> {\n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def = Def::Mod(self.definitions.local_def_id(item.id));\n+                let def_id = self.definitions.local_def_id(item.id);\n+                let module_kind = ModuleKind::Def(Def::Mod(def_id), ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    normal_ancestor_id: Some(item.id),\n-                    ..ModuleData::new(Some(parent), ModuleKind::Def(def, ident.name))\n+                    ..ModuleData::new(Some(parent), module_kind, def_id)\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.module_map.insert(item.id, module);\n+                self.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n                 self.current_module = module;\n@@ -305,7 +305,8 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), true);\n+                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n@@ -355,8 +356,8 @@ impl<'a> Resolver<'a> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let module =\n-                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), ident.name), true);\n+                let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n@@ -404,15 +405,10 @@ impl<'a> Resolver<'a> {\n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n-            let block_id = block.id;\n-\n-            debug!(\"(building reduced graph for block) creating a new anonymous module for block \\\n-                    {}\",\n-                   block_id);\n-\n-            let new_module = self.new_module(parent, ModuleKind::Block(block_id), true);\n-            self.module_map.insert(block_id, new_module);\n-            self.current_module = new_module; // Descend into the block.\n+            let module =\n+                self.new_module(parent, ModuleKind::Block(block.id), parent.normal_ancestor_id);\n+            self.block_map.insert(block.id, module);\n+            self.current_module = module; // Descend into the block.\n         }\n     }\n \n@@ -429,7 +425,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), def_id);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n@@ -446,7 +442,8 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n@@ -497,12 +494,10 @@ impl<'a> Resolver<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n+        let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleData {\n-                populated: Cell::new(false),\n-                ..ModuleData::new(None, ModuleKind::Def(Def::Mod(def_id), name))\n-            })\n+            arenas.alloc_module(ModuleData::new(None, module_kind, def_id))\n         })\n     }\n "}, {"sha": "d7f237ea09597a8ccc6b3a6abf641622ac62f9e6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -43,14 +43,13 @@ use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n-use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n+use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{Determined, Undetermined};\n use syntax::symbol::{Symbol, keywords};\n@@ -771,8 +770,8 @@ pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n     kind: ModuleKind,\n \n-    // The node id of the closest normal module (`mod`) ancestor (including this module).\n-    normal_ancestor_id: Option<NodeId>,\n+    // The def id of the closest normal module (`mod`) ancestor (including this module).\n+    normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n@@ -798,11 +797,11 @@ pub struct ModuleData<'a> {\n pub type Module<'a> = &'a ModuleData<'a>;\n \n impl<'a> ModuleData<'a> {\n-    fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n+    fn new(parent: Option<Module<'a>>, kind: ModuleKind, normal_ancestor_id: DefId) -> Self {\n         ModuleData {\n             parent: parent,\n             kind: kind,\n-            normal_ancestor_id: None,\n+            normal_ancestor_id: normal_ancestor_id,\n             resolutions: RefCell::new(FxHashMap()),\n             legacy_macro_resolutions: RefCell::new(Vec::new()),\n             macro_resolutions: RefCell::new(Vec::new()),\n@@ -811,7 +810,7 @@ impl<'a> ModuleData<'a> {\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n-            populated: Cell::new(true),\n+            populated: Cell::new(normal_ancestor_id.is_local()),\n         }\n     }\n \n@@ -848,7 +847,7 @@ impl<'a> ModuleData<'a> {\n     }\n \n     fn is_local(&self) -> bool {\n-        self.normal_ancestor_id.is_some()\n+        self.normal_ancestor_id.is_local()\n     }\n }\n \n@@ -1063,7 +1062,7 @@ pub struct Resolver<'a> {\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n \n-    // A map from nodes to modules, both normal (`mod`) modules and anonymous modules.\n+    // A map from nodes to anonymous modules.\n     // Anonymous modules are pseudo-modules that are implicitly created around items\n     // contained within blocks.\n     //\n@@ -1077,7 +1076,8 @@ pub struct Resolver<'a> {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    module_map: NodeMap<Module<'a>>,\n+    block_map: NodeMap<Module<'a>>,\n+    module_map: FxHashMap<DefId, Module<'a>>,\n     extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n     pub make_glob_map: bool,\n@@ -1153,15 +1153,12 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-impl<'a> ty::NodeIdTree for Resolver<'a> {\n-    fn is_descendant_of(&self, mut node: NodeId, ancestor: NodeId) -> bool {\n-        while node != ancestor {\n-            node = match self.module_map[&node].parent {\n-                Some(parent) => parent.normal_ancestor_id.unwrap(),\n-                None => return false,\n-            }\n-        }\n-        true\n+impl<'a, 'b: 'a> ty::DefIdTree for &'a Resolver<'b> {\n+    fn parent(self, id: DefId) -> Option<DefId> {\n+        match id.krate {\n+            LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n+            _ => self.session.cstore.def_key(id).parent,\n+        }.map(|index| DefId { index: index, ..id })\n     }\n }\n \n@@ -1202,14 +1199,14 @@ impl<'a> Resolver<'a> {\n                crate_loader: &'a mut CrateLoader,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n-        let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n+        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n+        let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n         let graph_root = arenas.alloc_module(ModuleData {\n-            normal_ancestor_id: Some(CRATE_NODE_ID),\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleData::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+            ..ModuleData::new(None, root_module_kind, root_def_id)\n         });\n-        let mut module_map = NodeMap();\n-        module_map.insert(CRATE_NODE_ID, graph_root);\n+        let mut module_map = FxHashMap();\n+        module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n@@ -1254,6 +1251,7 @@ impl<'a> Resolver<'a> {\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             module_map: module_map,\n+            block_map: NodeMap(),\n             extern_crate_roots: FxHashMap(),\n \n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n@@ -1324,12 +1322,9 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleData {\n-            normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n-            populated: Cell::new(local),\n-            ..ModuleData::new(Some(parent), kind)\n-        })\n+    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, normal_ancestor_id: DefId)\n+                  -> Module<'a> {\n+        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id))\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1462,6 +1457,7 @@ impl<'a> Resolver<'a> {\n     fn with_scope<F>(&mut self, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n+        let id = self.definitions.local_def_id(id);\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n@@ -1958,7 +1954,7 @@ impl<'a> Resolver<'a> {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n+        let anonymous_module = self.block_map.get(&block.id).cloned(); // clones a reference\n \n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n@@ -2334,13 +2330,13 @@ impl<'a> Resolver<'a> {\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n             if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n-                module = Some(self.module_map[&self.current_module.normal_ancestor_id.unwrap()]);\n+                module = Some(self.module_map[&self.current_module.normal_ancestor_id]);\n                 continue\n             } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n                 let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n-                let self_module = self.module_map[&current_module.normal_ancestor_id.unwrap()];\n+                let self_module = self.module_map[&current_module.normal_ancestor_id];\n                 if let Some(parent) = self_module.parent {\n-                    module = Some(self.module_map[&parent.normal_ancestor_id.unwrap()]);\n+                    module = Some(self.module_map[&parent.normal_ancestor_id]);\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n@@ -3000,10 +2996,12 @@ impl<'a> Resolver<'a> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let (segments, span, id) = match *vis {\n             ast::Visibility::Public => return ty::Visibility::Public,\n-            ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n+            ast::Visibility::Crate(_) => {\n+                return ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+            }\n             ast::Visibility::Restricted { ref path, id } => (&path.segments, path.span, id),\n             ast::Visibility::Inherited => {\n-                return ty::Visibility::Restricted(self.current_module.normal_ancestor_id.unwrap());\n+                return ty::Visibility::Restricted(self.current_module.normal_ancestor_id);\n             }\n         };\n \n@@ -3012,7 +3010,7 @@ impl<'a> Resolver<'a> {\n         let vis = match self.resolve_path(&path, None, Some(span)) {\n             PathResult::Module(module) => {\n                 path_resolution = PathResolution::new(module.def().unwrap());\n-                ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n+                ty::Visibility::Restricted(module.normal_ancestor_id)\n             }\n             PathResult::Failed(msg, _) => {\n                 self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n@@ -3029,11 +3027,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n-        vis.is_accessible_from(self.current_module.normal_ancestor_id.unwrap(), self)\n+        vis.is_accessible_from(self.current_module.normal_ancestor_id, self)\n     }\n \n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n-        vis.is_accessible_from(module.normal_ancestor_id.unwrap(), self)\n+        vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n     fn report_errors(&mut self) {"}, {"sha": "44cc580ad123b727af7b0ef976e66881c1cd3df0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -88,7 +88,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n-        let module = self.module_map[&id];\n+        let module = self.module_map[&self.definitions.local_def_id(id)];\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n@@ -154,7 +154,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(Def::Macro(def_id)),\n             span: DUMMY_SP,\n-            vis: ty::Visibility::PrivateExternal,\n+            vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n         self.builtin_macros.insert(ident.name, binding);"}, {"sha": "62dcb7e9e2fd9f7dbc5883708f116119f1e028d1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -19,6 +19,7 @@ use {resolve_error, ResolutionError};\n \n use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n+use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n \n use syntax::ast::{Ident, NodeId};\n@@ -274,7 +275,7 @@ impl<'a> Resolver<'a> {\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+    pub fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n                   -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n@@ -317,7 +318,7 @@ impl<'a> Resolver<'a> {\n                         resolution.shadows_glob = Some(binding);\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n-                    } else if !old_binding.vis.is_at_least(binding.vis, this) {\n+                    } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n@@ -340,7 +341,7 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    pub fn ambiguity(&mut self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+    pub fn ambiguity(&self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n                      -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Ambiguity { b1: b1, b2: b2, legacy: false },\n@@ -415,9 +416,9 @@ impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b: 'a> ty::NodeIdTree for ImportResolver<'a, 'b> {\n-    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        self.resolver.is_descendant_of(node, ancestor)\n+impl<'a, 'b: 'a> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n+    fn parent(self, id: DefId) -> Option<DefId> {\n+        self.resolver.parent(id)\n     }\n }\n \n@@ -490,7 +491,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let vis = directive.vis.get();\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n-            directive.vis.set(ty::Visibility::PrivateExternal);\n+            directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(&directive.module_path, None, None);\n             directive.vis.set(vis);\n \n@@ -580,8 +581,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n-                   max_vis.get() != ty::Visibility::PrivateExternal && // Allow empty globs.\n-                   !max_vis.get().is_at_least(directive.vis.get(), self) {\n+                   max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n+                   !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n                     self.session.span_err(directive.span, msg);\n                 }\n@@ -644,7 +645,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 let vis = directive.vis.get();\n-                if !binding.pseudo_vis().is_at_least(vis, this) {\n+                if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n                 } else {\n                     any_successful_reexport = true;\n@@ -752,7 +753,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             match binding.kind {\n                 NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n                     if ns == TypeNS && orig_binding.is_variant() &&\n-                       !orig_binding.vis.is_at_least(binding.vis, self) {\n+                       !orig_binding.vis.is_at_least(binding.vis, &*self) {\n                         let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                            (error E0364), consider declaring its enum as `pub`\",\n                                           ident);"}, {"sha": "9b8e77301e52480f5cb19576ffaaf51a44dec640", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.check_stability(def.def_id(), expr_id, span);\n \n         if let probe::InherentImplPick = pick.kind {\n-            if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n+            if !self.tcx.vis_is_accessible_from(pick.item.vis, self.body_id) {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }"}, {"sha": "1962534c397166d00861acf6c47ddb9f8095b89a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue\n             }\n \n-            if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n+            if !self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n                 self.private_candidate = Some(item.def());\n                 continue\n             }"}, {"sha": "a2dceed8d2653f4c74261db5714e963d2dfabd54", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f1e189ee2b078838fcd2f7550d14e9f1fd5e45/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=41f1e189ee2b078838fcd2f7550d14e9f1fd5e45", "patch": "@@ -3009,7 +3009,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n-                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n                             self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n \n@@ -3116,7 +3116,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     base_def.struct_variant().fields.get(idx.node).and_then(|field| {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         private_candidate = Some((base_def.did, field_ty));\n-                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n                             Some(field_ty)\n                         } else {"}]}