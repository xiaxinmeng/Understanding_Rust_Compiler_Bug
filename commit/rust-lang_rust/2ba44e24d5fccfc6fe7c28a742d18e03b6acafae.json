{"sha": "2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTQ0ZTI0ZDVmY2NmYzZmZTdjMjhhNzQyZDE4ZTAzYjZhY2FmYWU=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-12T09:32:09Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-12T23:30:20Z"}, "message": "(core::str) rename byte_len_range -> substr_len_bytes and\nrename char_len_range -> substr_len_chars", "tree": {"sha": "7533e535c883aa357f83fedeb097260f0a46a8d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7533e535c883aa357f83fedeb097260f0a46a8d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "html_url": "https://github.com/rust-lang/rust/commit/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b4f5136a52041a88fbf3a03f627e9c00869f182", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4f5136a52041a88fbf3a03f627e9c00869f182", "html_url": "https://github.com/rust-lang/rust/commit/2b4f5136a52041a88fbf3a03f627e9c00869f182"}], "stats": {"total": 104, "additions": 56, "deletions": 48}, "files": [{"sha": "d1b60916e195121eb84b986df3bd1de49d9e062a", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "patch": "@@ -135,7 +135,7 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     let {fm,line} = lookup_line(cm,chpos,lookup);\n     let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n     let col = chpos - fm.lines[line].ch;\n-    let col_offset = str::byte_len_range(*fm.src, line_offset, col);\n+    let col_offset = str::substr_len_bytes(*fm.src, line_offset, col);\n     ret {fm: fm, pos: line_offset + col_offset};\n }\n "}, {"sha": "522ae89d3954734fd847ff640f4edbe5760ae600", "filename": "src/libcore/str.rs", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "patch": "@@ -85,8 +85,8 @@ export\n    // Misc\n    // FIXME: perhaps some more of this section shouldn't be exported?\n    is_utf8,\n-   char_len_range,\n-   byte_len_range,\n+   substr_len_bytes,\n+   substr_len_chars,\n    utf8_char_width,\n    char_range_at,\n    char_at,\n@@ -271,7 +271,7 @@ Failure:\n If the string does not contain any characters.\n */\n fn pop_char(&s: str) -> char unsafe {\n-    let end = byte_len(s);\n+    let end = len_bytes(s);\n     let {ch:ch, prev:end} = char_range_at_reverse(s, end);\n     s = unsafe::slice_bytes(s, 0u, end);\n     ret ch;\n@@ -288,7 +288,7 @@ If the string does not contain any characters.\n */\n fn shift_char(&s: str) -> char unsafe {\n     let r = char_range_at(s, 0u);\n-    s = unsafe::slice_bytes(s, r.next, byte_len(s));\n+    s = unsafe::slice_bytes(s, r.next, len_bytes(s));\n     ret r.ch;\n }\n \n@@ -367,7 +367,7 @@ Convert a string to a vector of characters\n fn chars(s: str) -> [char] {\n     let buf: [char] = [];\n     let i = 0u;\n-    let len = byte_len(s);\n+    let len = len_bytes(s);\n     while i < len {\n         let cur = char_range_at(s, i);\n         buf += [cur.ch];\n@@ -443,7 +443,7 @@ fn splitn_byte(ss: str, sep: u8, count: uint) -> [str] unsafe {\n     assert u8::is_ascii(sep);\n \n     let vv = [];\n-    let start = 0u, current = 0u, len = byte_len(ss);\n+    let start = 0u, current = 0u, len = len_bytes(ss);\n     let splits_done = 0u;\n \n     while splits_done < count && current < len {\n@@ -550,7 +550,7 @@ up to `count` times\n fn splitn_char(ss: str, sep: char, count: uint) -> [str] unsafe {\n \n    let vv = [];\n-   let start = 0u, current = 0u, len = byte_len(ss);\n+   let start = 0u, current = 0u, len = len_bytes(ss);\n    let splits_done = 0u;\n \n    while splits_done < count && current < len {\n@@ -656,10 +656,11 @@ Returns:\n The original string with all occurances of `from` replaced with `to`\n */\n fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str unsafe {\n-    if byte_len(s) == 0u {\n+    if len_bytes(s) == 0u {\n         ret \"\";\n     } else if starts_with(s, from) {\n-        ret to + replace(unsafe::slice_bytes(s, byte_len(from), byte_len(s)),\n+        ret to + replace(\n+                     unsafe::slice_bytes(s, len_bytes(from), len_bytes(s)),\n                                        from, to);\n     } else {\n         let idx = find(s, from);\n@@ -726,7 +727,7 @@ Return true if a predicate matches all characters or\n if the string contains no characters\n */\n fn all(s: str, it: fn(char) -> bool) -> bool{\n-    ret substr_all(s, 0u, byte_len(s), it);\n+    ret substr_all(s, 0u, len_bytes(s), it);\n }\n \n /*\n@@ -746,7 +747,7 @@ Apply a function to each character\n */\n fn map(ss: str, ff: fn(char) -> char) -> str {\n     let result = \"\";\n-    reserve(result, byte_len(ss));\n+    reserve(result, len_bytes(ss));\n \n     chars_iter(ss, {|cc|\n         str::push_char(result, ff(cc));\n@@ -762,7 +763,7 @@ Iterate over the bytes in a string\n */\n fn bytes_iter(ss: str, it: fn(u8)) {\n     let pos = 0u;\n-    let len = byte_len(ss);\n+    let len = len_bytes(ss);\n \n     while (pos < len) {\n         it(ss[pos]);\n@@ -776,7 +777,7 @@ Function: chars_iter\n Iterate over the characters in a string\n */\n fn chars_iter(s: str, it: fn(char)) {\n-    let pos = 0u, len = byte_len(s);\n+    let pos = 0u, len = len_bytes(s);\n     while (pos < len) {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n@@ -833,7 +834,7 @@ Section: Searching\n fn index(ss: str, cc: char) -> option<uint> {\n     let bii = 0u;\n     let cii = 0u;\n-    let len = byte_len(ss);\n+    let len = len_bytes(ss);\n     while bii < len {\n         let {ch, next} = char_range_at(ss, bii);\n \n@@ -855,7 +856,7 @@ fn index(ss: str, cc: char) -> option<uint> {\n // Returns the index of the first matching char\n // (as option some/none)\n fn rindex(ss: str, cc: char) -> option<uint> {\n-    let bii = byte_len(ss);\n+    let bii = len_bytes(ss);\n     let cii = len(ss);\n     while bii > 0u {\n         let {ch, prev} = char_range_at_reverse(ss, bii);\n@@ -890,8 +891,8 @@ The index of the first occurance of `needle`, or -1 if not found.\n FIXME: UTF-8\n */\n fn find(haystack: str, needle: str) -> int {\n-    let haystack_len: int = byte_len(haystack) as int;\n-    let needle_len: int = byte_len(needle) as int;\n+    let haystack_len: int = len_bytes(haystack) as int;\n+    let needle_len: int = len_bytes(needle) as int;\n     if needle_len == 0 { ret 0; }\n     fn match_at(haystack: str, needle: str, i: int) -> bool {\n         let j: int = i;\n@@ -931,8 +932,8 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn starts_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = byte_len(haystack);\n-    let needle_len: uint = byte_len(needle);\n+    let haystack_len: uint = len_bytes(haystack);\n+    let needle_len: uint = len_bytes(needle);\n     if needle_len == 0u { ret true; }\n     if needle_len > haystack_len { ret false; }\n     ret eq(substr(haystack, 0u, needle_len), needle);\n@@ -969,7 +970,7 @@ Function: is_ascii\n Determines if a string contains only ASCII characters\n */\n fn is_ascii(s: str) -> bool {\n-    let i: uint = byte_len(s);\n+    let i: uint = len_bytes(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n@@ -1019,7 +1020,7 @@ pure fn byte_len(s: str) -> uint unsafe { len_bytes(s) }\n // String length or size in characters.\n // (Synonyms: len_chars, char_len)\n fn len(s: str) -> uint {\n-    char_len_range(s, 0u, byte_len(s))\n+    substr_len_chars(s, 0u, len_bytes(s))\n }\n \n fn len_chars(s: str) -> uint { len(s) }\n@@ -1054,7 +1055,7 @@ fn is_utf8(v: [u8]) -> bool {\n }\n \n /*\n-Function: char_len_range\n+Function: substr_len_chars\n \n As char_len but for a slice of a string\n \n@@ -1071,10 +1072,8 @@ Safety note:\n - This function does not check whether the substring is valid.\n - This function fails if `byte_offset` or `byte_len` do not\n  represent valid positions inside `s`\n-\n-FIXME: rename to 'substr_len_chars'\n */\n-fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n+fn substr_len_chars(s: str, byte_start: uint, byte_len: uint) -> uint {\n     let i         = byte_start;\n     let byte_stop = i + byte_len;\n     let len   = 0u;\n@@ -1088,7 +1087,7 @@ fn char_len_range(s: str, byte_start: uint, byte_len: uint) -> uint {\n }\n \n /*\n-Function: byte_len_range\n+Function: substr_len_bytes\n \n As byte_len but for a substring\n \n@@ -1108,7 +1107,7 @@ valid positions in `s`\n \n FIXME: rename to 'substr_len_bytes'\n */\n-fn byte_len_range(s: str, byte_offset: uint, char_len: uint) -> uint {\n+fn substr_len_bytes(s: str, byte_offset: uint, char_len: uint) -> uint {\n     let i = byte_offset;\n     let chars = 0u;\n     while chars < char_len {\n@@ -1149,7 +1148,7 @@ This function can be used to iterate over the unicode characters of a string.\n Example:\n > let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n > let i = 0u;\n-> while i < str::byte_len(s) {\n+> while i < str::len_bytes(s) {\n >    let {ch, next} = str::char_range_at(s, i);\n >    std::io::println(#fmt(\"%u: %c\",i,ch));\n >    i = next;\n@@ -1391,7 +1390,7 @@ mod unsafe {\n    unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n        // FIXME: Typestate precondition\n        assert (begin <= end);\n-       assert (end <= byte_len(s));\n+       assert (end <= len_bytes(s));\n \n        let v = as_bytes(s) { |v| vec::slice(v, begin, end) };\n        v += [0u8];\n@@ -1408,7 +1407,7 @@ mod unsafe {\n    unsafe fn slice_bytes_safe_range(s: str, begin: uint, end: uint)\n        : uint::le(begin, end) -> str {\n        // would need some magic to make this a precondition\n-       assert (end <= byte_len(s));\n+       assert (end <= len_bytes(s));\n        ret slice_bytes(s, begin, end);\n    }\n \n@@ -1430,7 +1429,7 @@ mod unsafe {\n    //\n    // Removes the last byte from a string and returns it.  (Not UTF-8 safe).\n    unsafe fn pop_byte(&s: str) -> u8 unsafe {\n-       let len = byte_len(s);\n+       let len = len_bytes(s);\n        assert (len > 0u);\n        let b = s[len - 1u];\n        s = unsafe::slice_bytes(s, 0u, len - 1u);\n@@ -1441,7 +1440,7 @@ mod unsafe {\n    //\n    // Removes the first byte from a string and returns it. (Not UTF-8 safe).\n    unsafe fn shift_byte(&s: str) -> u8 unsafe {\n-       let len = byte_len(s);\n+       let len = len_bytes(s);\n        assert (len > 0u);\n        let b = s[0];\n        s = unsafe::slice_bytes(s, 1u, len);\n@@ -1470,14 +1469,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bytes_len() {\n-        assert (byte_len(\"\") == 0u);\n-        assert (byte_len(\"hello world\") == 11u);\n-        assert (byte_len(\"\\x63\") == 1u);\n-        assert (byte_len(\"\\xa2\") == 2u);\n-        assert (byte_len(\"\\u03c0\") == 2u);\n-        assert (byte_len(\"\\u2620\") == 3u);\n-        assert (byte_len(\"\\U0001d11e\") == 4u);\n+    fn test_len() {\n+        assert (len_bytes(\"\") == 0u);\n+        assert (len_bytes(\"hello world\") == 11u);\n+        assert (len_bytes(\"\\x63\") == 1u);\n+        assert (len_bytes(\"\\xa2\") == 2u);\n+        assert (len_bytes(\"\\u03c0\") == 2u);\n+        assert (len_bytes(\"\\u2620\") == 3u);\n+        assert (len_bytes(\"\\U0001d11e\") == 4u);\n+\n+        assert (len(\"\") == 0u);\n+        assert (len(\"hello world\") == 11u);\n+        assert (len(\"\\x63\") == 1u);\n+        assert (len(\"\\xa2\") == 1u);\n+        assert (len(\"\\u03c0\") == 1u);\n+        assert (len(\"\\u2620\") == 1u);\n+        assert (len(\"\\U0001d11e\") == 1u);\n+        assert (len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n     }\n \n     #[test]\n@@ -1712,7 +1720,7 @@ mod tests {\n     #[test]\n     fn test_substr() {\n         fn t(a: str, b: str, start: int) {\n-            assert (eq(substr(a, start as uint, byte_len(b)), b));\n+            assert (eq(substr(a, start as uint, len_bytes(b)), b));\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n@@ -2002,7 +2010,7 @@ mod tests {\n         let v: [u8] = bytes(s1);\n         let s2: str = from_bytes(v);\n         let i: uint = 0u;\n-        let n1: uint = byte_len(s1);\n+        let n1: uint = len_bytes(s1);\n         let n2: uint = vec::len::<u8>(v);\n         assert (n1 == n2);\n         while i < n1 {"}, {"sha": "07ee837a9b9188ac750e4f3ac9df898f8e42e226", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44e24d5fccfc6fe7c28a742d18e03b6acafae/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2ba44e24d5fccfc6fe7c28a742d18e03b6acafae", "patch": "@@ -743,7 +743,7 @@ mod node {\n      */\n     fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n-                  str::char_len_range(*str, byte_start, byte_len));\n+                  str::substr_len_chars(*str, byte_start, byte_len));\n     }\n \n     /*\n@@ -795,7 +795,7 @@ mod node {\n                     if i == 0u  { first_leaf_char_len }\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n-                    str::byte_len_range(*str, offset, chunk_char_len);\n+                    str::substr_len_bytes(*str, offset, chunk_char_len);\n                 nodes[i] = @leaf({\n                     byte_offset: offset,\n                     byte_len:    chunk_byte_len,\n@@ -998,7 +998,7 @@ mod node {\n             alt(*node) {\n               node::leaf(x) {\n                 let char_len =\n-                    str::char_len_range(*x.content, byte_offset, byte_len);\n+                    str::substr_len_chars(*x.content, byte_offset, byte_len);\n                 ret @leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n@@ -1059,9 +1059,9 @@ mod node {\n                     ret node;\n                 }\n                 let byte_offset =\n-                    str::byte_len_range(*x.content, 0u, char_offset);\n+                    str::substr_len_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n-                    str::byte_len_range(*x.content, byte_offset, char_len);\n+                    str::substr_len_bytes(*x.content, byte_offset, char_len);\n                 ret @leaf({byte_offset: byte_offset,\n                            byte_len:    byte_len,\n                            char_len:    char_len,"}]}