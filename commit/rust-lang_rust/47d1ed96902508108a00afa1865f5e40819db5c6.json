{"sha": "47d1ed96902508108a00afa1865f5e40819db5c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDFlZDk2OTAyNTA4MTA4YTAwYWZhMTg2NWY1ZTQwODE5ZGI1YzY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-10T17:48:54Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-04-11T02:32:09Z"}, "message": "Preprocess intra-doc links consistently\n\nPreviously, rustdoc would panic on links to external crates if they were\nsurrounded by backticks.", "tree": {"sha": "b77482eef7c7528ac4374f304b84f8527be325f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b77482eef7c7528ac4374f304b84f8527be325f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d1ed96902508108a00afa1865f5e40819db5c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d1ed96902508108a00afa1865f5e40819db5c6", "html_url": "https://github.com/rust-lang/rust/commit/47d1ed96902508108a00afa1865f5e40819db5c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d1ed96902508108a00afa1865f5e40819db5c6/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4029d4d0be03b10edccb65588b522ad541b5ccaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4029d4d0be03b10edccb65588b522ad541b5ccaf", "html_url": "https://github.com/rust-lang/rust/commit/4029d4d0be03b10edccb65588b522ad541b5ccaf"}], "stats": {"total": 252, "additions": 160, "deletions": 92}, "files": [{"sha": "1da06f78fa2558c5cc0be613f5ce61afa573ecdd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=47d1ed96902508108a00afa1865f5e40819db5c6", "patch": "@@ -365,21 +365,20 @@ crate fn create_resolver<'a>(\n     }\n     impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n         fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-            use crate::html::markdown::{markdown_links, MarkdownLink};\n-            use crate::passes::collect_intra_doc_links::Disambiguator;\n+            use crate::html::markdown::markdown_links;\n+            use crate::passes::collect_intra_doc_links::preprocess_link;\n \n             if let Some(doc) = attr.doc_str() {\n-                for MarkdownLink { link, .. } in markdown_links(&doc.as_str()) {\n-                    // FIXME: this misses a *lot* of the preprocessing done in collect_intra_doc_links\n-                    // I think most of it shouldn't be necessary since we only need the crate prefix?\n-                    let path_str = match Disambiguator::from_str(&link) {\n-                        Ok(x) => x.map_or(link.as_str(), |(_, p)| p),\n-                        Err(_) => continue,\n+                for link in markdown_links(&doc.as_str()) {\n+                    let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n+                        x.path_str\n+                    } else {\n+                        continue;\n                     };\n                     self.resolver.borrow_mut().access(|resolver| {\n                         let _ = resolver.resolve_str_path_error(\n                             attr.span,\n-                            path_str,\n+                            &path_str,\n                             TypeNS,\n                             self.current_mod,\n                         );"}, {"sha": "5d280b590bdfc6a03b7448a647681e0d7bd32412", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 138, "deletions": 82, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=47d1ed96902508108a00afa1865f5e40819db5c6", "patch": "@@ -68,7 +68,7 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n }\n \n #[derive(Copy, Clone, Debug, Hash)]\n-enum Res {\n+crate enum Res {\n     Def(DefKind, DefId),\n     Primitive(PrimitiveType),\n }\n@@ -134,7 +134,7 @@ impl TryFrom<ResolveRes> for Res {\n \n /// A link failed to resolve.\n #[derive(Debug)]\n-enum ResolutionFailure<'a> {\n+crate enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     WrongNamespace {\n         /// What the link resolved to.\n@@ -172,7 +172,7 @@ enum ResolutionFailure<'a> {\n }\n \n #[derive(Debug)]\n-enum MalformedGenerics {\n+crate enum MalformedGenerics {\n     /// This link has unbalanced angle brackets.\n     ///\n     /// For example, `Vec<T` should trigger this, as should `Vec<T>>`.\n@@ -224,7 +224,7 @@ impl ResolutionFailure<'a> {\n     }\n }\n \n-enum AnchorFailure {\n+crate enum AnchorFailure {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n     /// The anchor provided by the user conflicts with Rustdoc's generated anchor.\n@@ -892,6 +892,117 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+crate enum PreprocessingError<'a> {\n+    Anchor(AnchorFailure),\n+    Disambiguator(Range<usize>, String),\n+    Resolution(ResolutionFailure<'a>, String, Option<Disambiguator>),\n+}\n+\n+impl From<AnchorFailure> for PreprocessingError<'_> {\n+    fn from(err: AnchorFailure) -> Self {\n+        Self::Anchor(err)\n+    }\n+}\n+\n+crate struct PreprocessingInfo {\n+    crate path_str: String,\n+    disambiguator: Option<Disambiguator>,\n+    extra_fragment: Option<String>,\n+    link_text: String,\n+}\n+\n+/// Returns:\n+/// - `None` if the link should be ignored.\n+/// - `Some(Err)` if the link should emit an error\n+/// - `Some(Ok)` if the link is valid\n+///\n+/// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n+crate fn preprocess_link<'a>(\n+    ori_link: &'a MarkdownLink,\n+) -> Option<Result<PreprocessingInfo, PreprocessingError<'a>>> {\n+    // [] is mostly likely not supposed to be a link\n+    if ori_link.link.is_empty() {\n+        return None;\n+    }\n+\n+    // Bail early for real links.\n+    if ori_link.link.contains('/') {\n+        return None;\n+    }\n+\n+    let stripped = ori_link.link.replace(\"`\", \"\");\n+    let mut parts = stripped.split('#');\n+\n+    let link = parts.next().unwrap();\n+    if link.trim().is_empty() {\n+        // This is an anchor to an element of the current page, nothing to do in here!\n+        return None;\n+    }\n+    let extra_fragment = parts.next();\n+    if parts.next().is_some() {\n+        // A valid link can't have multiple #'s\n+        return Some(Err(AnchorFailure::MultipleAnchors.into()));\n+    }\n+\n+    // Parse and strip the disambiguator from the link, if present.\n+    let (path_str, disambiguator) = match Disambiguator::from_str(&link) {\n+        Ok(Some((d, path))) => (path.trim(), Some(d)),\n+        Ok(None) => (link.trim(), None),\n+        Err((err_msg, relative_range)) => {\n+            // Only report error if we would not have ignored this link. See issue #83859.\n+            if !should_ignore_link_with_disambiguators(link) {\n+                let no_backticks_range = range_between_backticks(&ori_link);\n+                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n+                    ..(no_backticks_range.start + relative_range.end);\n+                return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n+            } else {\n+                return None;\n+            }\n+        }\n+    };\n+\n+    if should_ignore_link(path_str) {\n+        return None;\n+    }\n+\n+    // We stripped `()` and `!` when parsing the disambiguator.\n+    // Add them back to be displayed, but not prefix disambiguators.\n+    let link_text =\n+        disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+\n+    // Strip generics from the path.\n+    let path_str = if path_str.contains(['<', '>'].as_slice()) {\n+        match strip_generics_from_path(&path_str) {\n+            Ok(path) => path,\n+            Err(err_kind) => {\n+                debug!(\"link has malformed generics: {}\", path_str);\n+                return Some(Err(PreprocessingError::Resolution(\n+                    err_kind,\n+                    path_str.to_owned(),\n+                    disambiguator,\n+                )));\n+            }\n+        }\n+    } else {\n+        path_str.to_owned()\n+    };\n+\n+    // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+    assert!(!path_str.contains(['<', '>'].as_slice()));\n+\n+    // The link is not an intra-doc link if it still contains spaces after stripping generics.\n+    if path_str.contains(' ') {\n+        return None;\n+    }\n+\n+    Some(Ok(PreprocessingInfo {\n+        path_str,\n+        disambiguator,\n+        extra_fragment: extra_fragment.map(String::from),\n+        link_text,\n+    }))\n+}\n+\n impl LinkCollector<'_, '_> {\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n@@ -907,64 +1018,36 @@ impl LinkCollector<'_, '_> {\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link.link);\n \n-        // Bail early for real links.\n-        if ori_link.link.contains('/') {\n-            return None;\n-        }\n-\n-        // [] is mostly likely not supposed to be a link\n-        if ori_link.link.is_empty() {\n-            return None;\n-        }\n-\n         let diag_info = DiagnosticInfo {\n             item,\n             dox,\n             ori_link: &ori_link.link,\n             link_range: ori_link.range.clone(),\n         };\n \n-        let link = ori_link.link.replace(\"`\", \"\");\n-        let no_backticks_range = range_between_backticks(&ori_link);\n-        let parts = link.split('#').collect::<Vec<_>>();\n-        let (link, extra_fragment) = if parts.len() > 2 {\n-            // A valid link can't have multiple #'s\n-            anchor_failure(self.cx, diag_info, AnchorFailure::MultipleAnchors);\n-            return None;\n-        } else if parts.len() == 2 {\n-            if parts[0].trim().is_empty() {\n-                // This is an anchor to an element of the current page, nothing to do in here!\n-                return None;\n-            }\n-            (parts[0], Some(parts[1].to_owned()))\n-        } else {\n-            (parts[0], None)\n-        };\n-\n-        // Parse and strip the disambiguator from the link, if present.\n-        let (mut path_str, disambiguator) = match Disambiguator::from_str(&link) {\n-            Ok(Some((d, path))) => (path.trim(), Some(d)),\n-            Ok(None) => (link.trim(), None),\n-            Err((err_msg, relative_range)) => {\n-                if !should_ignore_link_with_disambiguators(link) {\n-                    // Only report error if we would not have ignored this link.\n-                    // See issue #83859.\n-                    let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                        ..(no_backticks_range.start + relative_range.end);\n-                    disambiguator_error(self.cx, diag_info, disambiguator_range, &err_msg);\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } =\n+            match preprocess_link(&ori_link)? {\n+                Ok(x) => x,\n+                Err(err) => {\n+                    match err {\n+                        PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, err),\n+                        PreprocessingError::Disambiguator(range, msg) => {\n+                            disambiguator_error(self.cx, diag_info, range, &msg)\n+                        }\n+                        PreprocessingError::Resolution(err, path_str, disambiguator) => {\n+                            resolution_failure(\n+                                self,\n+                                diag_info,\n+                                &path_str,\n+                                disambiguator,\n+                                smallvec![err],\n+                            );\n+                        }\n+                    }\n+                    return None;\n                 }\n-                return None;\n-            }\n-        };\n-\n-        if should_ignore_link(path_str) {\n-            return None;\n-        }\n-\n-        // We stripped `()` and `!` when parsing the disambiguator.\n-        // Add them back to be displayed, but not prefix disambiguators.\n-        let link_text =\n-            disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+            };\n+        let mut path_str = &*path_str;\n \n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n@@ -1029,39 +1112,12 @@ impl LinkCollector<'_, '_> {\n             module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n-        // Strip generics from the path.\n-        let stripped_path_string;\n-        if path_str.contains(['<', '>'].as_slice()) {\n-            stripped_path_string = match strip_generics_from_path(path_str) {\n-                Ok(path) => path,\n-                Err(err_kind) => {\n-                    debug!(\"link has malformed generics: {}\", path_str);\n-                    resolution_failure(\n-                        self,\n-                        diag_info,\n-                        path_str,\n-                        disambiguator,\n-                        smallvec![err_kind],\n-                    );\n-                    return None;\n-                }\n-            };\n-            path_str = &stripped_path_string;\n-        }\n-        // Sanity check to make sure we don't have any angle brackets after stripping generics.\n-        assert!(!path_str.contains(['<', '>'].as_slice()));\n-\n-        // The link is not an intra-doc link if it still contains spaces after stripping generics.\n-        if path_str.contains(' ') {\n-            return None;\n-        }\n-\n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment,\n+                extra_fragment: extra_fragment.map(String::from),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs?ref=47d1ed96902508108a00afa1865f5e40819db5c6", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty2.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs?ref=47d1ed96902508108a00afa1865f5e40819db5c6", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "5d8dcf8bc1d1682357b5cb982c07713c82f6c3f5", "filename": "src/test/rustdoc/intra-doc/extern-crate-only-used-in-link.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d1ed96902508108a00afa1865f5e40819db5c6/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs?ref=47d1ed96902508108a00afa1865f5e40819db5c6", "patch": "@@ -1,8 +1,19 @@\n+// This test is just a little cursed.\n // aux-build:issue-66159-1.rs\n // aux-crate:priv:issue_66159_1=issue-66159-1.rs\n+// aux-build:empty.rs\n+// aux-crate:priv:empty=empty.rs\n+// aux-build:empty2.rs\n+// aux-crate:priv:empty2=empty2.rs\n // build-aux-docs\n-// compile-flags:-Z unstable-options\n+// compile-flags:-Z unstable-options --edition 2018\n \n // @has extern_crate_only_used_in_link/index.html\n // @has - '//a[@href=\"../issue_66159_1/struct.Something.html\"]' 'issue_66159_1::Something'\n //! [issue_66159_1::Something]\n+\n+// @has - '//a[@href=\"../empty/index.html\"]' 'empty'\n+//! [`empty`]\n+\n+// @has - '//a[@href=\"../empty2/index.html\"]' 'empty2'\n+//! [empty2<x>]"}]}