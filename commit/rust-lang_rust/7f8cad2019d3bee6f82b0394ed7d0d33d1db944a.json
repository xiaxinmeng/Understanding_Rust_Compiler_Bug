{"sha": "7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOGNhZDIwMTlkM2JlZTZmODJiMDM5NGVkN2QwZDMzZDFkYjk0NGE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2021-06-05T18:08:35Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2021-06-07T22:04:52Z"}, "message": "Make OpaqueTypeKey the key of opaque types map", "tree": {"sha": "3d2c0db0be418944d1eefab9ad27d583951ebff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d2c0db0be418944d1eefab9ad27d583951ebff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmC+mAYACgkQgTGiTgx5\n76/aCg//e/V9GPPka4HNgUPwH8wdMR5hQhJ4OrQpchRV08FmH5Mdfn/60QxJd52g\nBcmXtVUCBP727WhXbcJRopv5LmHQkhdJajbciltySRdDs7YtSv6N4/97yIE/G4w+\nq/xyUiCHs65MU/X4hrWNNQrxEOnELqVNixowtTaIHCu75fDC5qj7vwybkrFNa+P+\nOJuZM0wZUoEBAaC+Q6Y0FPnXH3r+Z3A8CMb0r4OlDaw5XWdW1L9IB5P9ChKw6saS\n1UQ6aWslv7psAV3A9alRHCc2hRsdIONu9LiooniJvqByVu+bGRDEOXEVFq4Y5DNn\nT4e8Ndqsox6++JJO7pgzcCXW6+r+W/N9WpNINwDaM37qAGXvdOrc1vJFvEYU1wRw\nJgCwI5v5/uGI7H21c9zSgyuG8hx1+XOuhguN316EDJCw4tkmHSVT1M8qVA7jzV7R\nD4xaRSoxAg6naZTORzUaJ2lsjV6iFXWkg/kWyM88hKsHSFKBBVIQ7dQB2fE8tj1f\nr4/oX/xnr3vnkSF5NJHcYhjOABXsMrdr9lekPGGmAsJ1b0oH2LlDf2zDUnCXTp7z\ngtDHkChxbyEmL+yAMLr62yGDvuwVxFKDnd8+O34f44kbvMqWO+qQXddP0vNcLOUE\nbEGT5qu8E6uGAz6OxUmg1OxRf3vFYpdWdkHPQL5HrFkqjfBCOhs=\n=FEAN\n-----END PGP SIGNATURE-----", "payload": "tree 3d2c0db0be418944d1eefab9ad27d583951ebff6\nparent 3405725e0026dbea6dd3e8dccbcb44898511fa13\nauthor Santiago Pastorino <spastorino@gmail.com> 1622916515 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1623103492 -0300\n\nMake OpaqueTypeKey the key of opaque types map\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "html_url": "https://github.com/rust-lang/rust/commit/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3405725e0026dbea6dd3e8dccbcb44898511fa13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3405725e0026dbea6dd3e8dccbcb44898511fa13", "html_url": "https://github.com/rust-lang/rust/commit/3405725e0026dbea6dd3e8dccbcb44898511fa13"}], "stats": {"total": 232, "additions": 134, "deletions": 98}, "files": [{"sha": "9e61f5629ae025e84195648c002073b0a306f586", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -9,6 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n@@ -210,7 +211,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: VecMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "d4433ebd350f14bf9f49bd91da8eee2f394dc7f4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -48,6 +48,7 @@ use rustc_hir::{\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n+use rustc_middle::ty::OpaqueTypeKey;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n@@ -425,7 +426,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// All the opaque types that are restricted to concrete types\n     /// by this function.\n-    pub concrete_opaque_types: VecMap<DefId, ResolvedOpaqueTy<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, ResolvedOpaqueTy<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "268818b64e56e8dcc304e24a1cf54c9565ee6f2b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -835,6 +835,12 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub struct OpaqueTypeKey<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n rustc_index::newtype_index! {\n     /// \"Universes\" are used during type- and trait-checking in the\n     /// presence of `for<..>` binders to control what sets of names are"}, {"sha": "36eb8a4baa8308f1f7d13a8c81c8f64cb79d57d2", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -2,7 +2,6 @@\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -26,7 +25,7 @@ use either::Either;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n-use std::iter::{self, FromIterator};\n+use std::iter;\n use std::mem;\n use std::rc::Rc;\n \n@@ -442,7 +441,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n \n     let result = BorrowCheckResult {\n-        concrete_opaque_types: VecMap::from_iter(opaque_type_values.into_iter()),\n+        concrete_opaque_types: opaque_type_values,\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n     };"}, {"sha": "fdc06ae303a0745c0db64d7e02f0691c666f4983", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -1,15 +1,14 @@\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, RegionKind, RegionVid};\n+use rustc_middle::ty::{self, OpaqueTypeKey, RegionKind, RegionVid};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -47,7 +46,7 @@ crate type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    pub opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n     pub nll_errors: RegionErrors<'tcx>,\n@@ -367,7 +366,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n-    opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "b1954e9938dd5e7a640a3e14231de1f8ee38f65a", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -1,7 +1,6 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, OpaqueTypeKey, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n@@ -51,12 +50,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(in crate::borrow_check) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n         span: Span,\n-    ) -> FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>> {\n+    ) -> VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .map(|(opaque_def_id, ty::ResolvedOpaqueTy { concrete_type, substs })| {\n+            .map(|(opaque_type_key, ty::ResolvedOpaqueTy { concrete_type, substs })| {\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n@@ -110,14 +109,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 debug!(?universal_concrete_type, ?universal_substs);\n \n+                let opaque_type_key =\n+                    OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };\n                 let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n-                    opaque_def_id,\n-                    universal_substs,\n+                    opaque_type_key,\n                     universal_concrete_type,\n                     span,\n                 );\n                 (\n-                    opaque_def_id,\n+                    opaque_type_key,\n                     ty::ResolvedOpaqueTy { concrete_type: remapped_type, substs: universal_substs },\n                 )\n             })"}, {"sha": "26ae3f4b5c805d8e14d12addd45afc300db6c1bd", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -7,9 +7,10 @@ use either::Either;\n \n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n@@ -27,8 +28,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPredicate, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueTypeKey, RegionVid,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -818,7 +819,7 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -833,7 +834,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(in crate::borrow_check) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -978,7 +979,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            opaque_type_values: FxHashMap::default(),\n+            opaque_type_values: VecMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1240,7 +1241,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let param_env = self.param_env;\n         let body = self.body;\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n-        let mut opaque_type_values = Vec::new();\n+        let mut opaque_type_values = VecMap::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", body.source.def_id());\n         let opaque_type_map = self.fully_perform_op(\n@@ -1288,7 +1289,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         } else {\n                             false\n                         };\n-                        let opaque_defn_ty = match concrete_opaque_types.get(&opaque_def_id) {\n+\n+                        let opaque_type_key =\n+                            OpaqueTypeKey { def_id: opaque_def_id, substs: opaque_decl.substs };\n+                        let opaque_defn_ty = match concrete_opaque_types\n+                            .iter()\n+                            .find(|(opaque_type_key, _)| opaque_type_key.def_id == opaque_def_id)\n+                            .map(|(_, resolved_opaque_ty)| resolved_opaque_ty)\n+                        {\n                             None => {\n                                 if !concrete_is_opaque {\n                                     tcx.sess.delay_span_bug(\n@@ -1322,13 +1330,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                     .at(&ObligationCause::dummy(), param_env)\n                                     .eq(opaque_decl.concrete_ty, renumbered_opaque_defn_ty)?,\n                             );\n-                            opaque_type_values.push((\n-                                opaque_def_id,\n+                            opaque_type_values.insert(\n+                                opaque_type_key,\n                                 ty::ResolvedOpaqueTy {\n                                     concrete_type: renumbered_opaque_defn_ty,\n                                     substs: opaque_decl.substs,\n                                 },\n-                            ));\n+                            );\n                         } else {\n                             // We're using an opaque `impl Trait` type without\n                             // 'revealing' it. For example, code like this:"}, {"sha": "fc497755b3cb1d96a64033940a814024706e6a14", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n@@ -143,8 +143,7 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx>;\n@@ -573,11 +572,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ///   `opaque_defn.concrete_ty`\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n             def_id, instantiated_ty"}, {"sha": "ec940cb369326149aeef1c86e0ced3065dd8e484", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n@@ -493,9 +493,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // fn foo<U>() -> Foo<U> { .. }\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n+            let opaque_type_key = OpaqueTypeKey { def_id, substs: opaque_defn.substs };\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                def_id,\n-                opaque_defn.substs,\n+                opaque_type_key,\n                 instantiated_ty,\n                 span,\n             );\n@@ -527,7 +527,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         substs: opaque_defn.substs,\n                     };\n \n-                    let old = self.typeck_results.concrete_opaque_types.insert(def_id, new);\n+                    let opaque_type_key = OpaqueTypeKey { def_id, substs: opaque_defn.substs };\n+                    let old =\n+                        self.typeck_results.concrete_opaque_types.insert(opaque_type_key, new);\n                     if let Some(old) = old {\n                         if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n                             span_bug!("}, {"sha": "b53ef070a458f0b24ce73f6cb554a381acfa5e8e", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8cad2019d3bee6f82b0394ed7d0d33d1db944a/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=7f8cad2019d3bee6f82b0394ed7d0d33d1db944a", "patch": "@@ -1,4 +1,5 @@\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -9,7 +10,9 @@ use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, OpaqueTypeKey, ResolvedOpaqueTy, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -346,36 +349,36 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n-                    let concrete_ty = tcx\n-                        .mir_borrowck(owner.expect_local())\n-                        .concrete_opaque_types\n-                        .get(&def_id.to_def_id())\n-                        .map(|opaque| opaque.concrete_type)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n-                            if let Some(ErrorReported) =\n-                                tcx.typeck(owner.expect_local()).tainted_by_errors\n-                            {\n-                                // Some error in the\n-                                // owner fn prevented us from populating\n-                                // the `concrete_opaque_types` table.\n-                                tcx.ty_error()\n-                            } else {\n-                                // We failed to resolve the opaque type or it\n-                                // resolves to itself. Return the non-revealed\n-                                // type, which should result in E0720.\n-                                tcx.mk_opaque(\n-                                    def_id.to_def_id(),\n-                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-                                )\n-                            }\n-                        });\n+                    let concrete_ty = find_concrete_ty_from_def_id(\n+                        &tcx.mir_borrowck(owner.expect_local()).concrete_opaque_types,\n+                        def_id.to_def_id(),\n+                    )\n+                    .map(|opaque| opaque.concrete_type)\n+                    .unwrap_or_else(|| {\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\n+                                \"owner {:?} has no opaque type for {:?} in its typeck results\",\n+                                owner, def_id,\n+                            ),\n+                        );\n+                        if let Some(ErrorReported) =\n+                            tcx.typeck(owner.expect_local()).tainted_by_errors\n+                        {\n+                            // Some error in the\n+                            // owner fn prevented us from populating\n+                            // the `concrete_opaque_types` table.\n+                            tcx.ty_error()\n+                        } else {\n+                            // We failed to resolve the opaque type or it\n+                            // resolves to itself. Return the non-revealed\n+                            // type, which should result in E0720.\n+                            tcx.mk_opaque(\n+                                def_id.to_def_id(),\n+                                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                            )\n+                        }\n+                    });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n                     concrete_ty\n                 }\n@@ -515,15 +518,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+            if find_concrete_ty_from_def_id(\n+                &self.tcx.typeck(def_id).concrete_opaque_types,\n+                self.def_id,\n+            )\n+            .is_none()\n+            {\n                 debug!(\n                     \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n                     self.def_id, def_id,\n                 );\n                 return;\n             }\n             // Use borrowck to get the type with unerased regions.\n-            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n+            let ty = find_concrete_ty_from_def_id(\n+                &self.tcx.mir_borrowck(def_id).concrete_opaque_types,\n+                self.def_id,\n+            );\n             if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n                 debug!(\n                     \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n@@ -697,32 +708,31 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n     let opaque_ty_def_id = opaque_ty_id.to_def_id();\n \n     let owner_typeck_results = tcx.typeck(scope_def_id);\n-    let concrete_ty = owner_typeck_results\n-        .concrete_opaque_types\n-        .get(&opaque_ty_def_id)\n-        .map(|opaque| opaque.concrete_type)\n-        .unwrap_or_else(|| {\n-            tcx.sess.delay_span_bug(\n-                DUMMY_SP,\n-                &format!(\n-                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n-                    scope_def_id, opaque_ty_id\n-                ),\n-            );\n-            if let Some(ErrorReported) = owner_typeck_results.tainted_by_errors {\n-                // Some error in the owner fn prevented us from populating the\n-                // `concrete_opaque_types` table.\n-                tcx.ty_error()\n-            } else {\n-                // We failed to resolve the opaque type or it resolves to\n-                // itself. Return the non-revealed type, which should result in\n-                // E0720.\n-                tcx.mk_opaque(\n-                    opaque_ty_def_id,\n-                    InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n-                )\n-            }\n-        });\n+    let concrete_ty =\n+        find_concrete_ty_from_def_id(&owner_typeck_results.concrete_opaque_types, opaque_ty_def_id)\n+            .map(|opaque| opaque.concrete_type)\n+            .unwrap_or_else(|| {\n+                tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    &format!(\n+                        \"owner {:?} has no opaque type for {:?} in its typeck results\",\n+                        scope_def_id, opaque_ty_id\n+                    ),\n+                );\n+                if let Some(ErrorReported) = owner_typeck_results.tainted_by_errors {\n+                    // Some error in the owner fn prevented us from populating the\n+                    // `concrete_opaque_types` table.\n+                    tcx.ty_error()\n+                } else {\n+                    // We failed to resolve the opaque type or it resolves to\n+                    // itself. Return the non-revealed type, which should result in\n+                    // E0720.\n+                    tcx.mk_opaque(\n+                        opaque_ty_def_id,\n+                        InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n+                    )\n+                }\n+            });\n     debug!(\"concrete_ty = {:?}\", concrete_ty);\n     if concrete_ty.has_erased_regions() {\n         // FIXME(impl_trait_in_bindings) Handle this case.\n@@ -796,3 +806,13 @@ fn check_feature_inherent_assoc_ty(tcx: TyCtxt<'_>, span: Span) {\n         .emit();\n     }\n }\n+\n+fn find_concrete_ty_from_def_id<'tcx>(\n+    concrete_opaque_types: &'tcx VecMap<OpaqueTypeKey<'tcx>, ResolvedOpaqueTy<'tcx>>,\n+    def_id: DefId,\n+) -> Option<&'tcx ResolvedOpaqueTy<'tcx>> {\n+    concrete_opaque_types\n+        .iter()\n+        .find(|(opaque_type_key, _)| opaque_type_key.def_id == def_id)\n+        .map(|(_, resolved_opaque_ty)| resolved_opaque_ty)\n+}"}]}