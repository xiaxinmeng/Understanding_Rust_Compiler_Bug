{"sha": "c6d8ab09e39bacae2c008995bbb669442115517f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDhhYjA5ZTM5YmFjYWUyYzAwODk5NWJiYjY2OTQ0MjExNTUxN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-16T03:56:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-16T03:56:47Z"}, "message": "Auto merge of #38357 - arielb1:deterministic-hash, r=michaelwoerister\n\nmake deterministic_hash host-architecture-independent\n\n`DefPath::deterministic_hash` used to call `std::hash::Hash`, which depends on the current architecture in several ways, which would prevent metadata written on one host architecture from being successfully read on another one.\n\nUse a hasher we control instead.\n\nFixes #38177.\n\nr? @michaelwoerister", "tree": {"sha": "ff6224ebd2972cf016659a10815b487dd142d4bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff6224ebd2972cf016659a10815b487dd142d4bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d8ab09e39bacae2c008995bbb669442115517f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d8ab09e39bacae2c008995bbb669442115517f", "html_url": "https://github.com/rust-lang/rust/commit/c6d8ab09e39bacae2c008995bbb669442115517f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d8ab09e39bacae2c008995bbb669442115517f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ae904062b2700a797138d2b8274f2e141ea1e53", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae904062b2700a797138d2b8274f2e141ea1e53", "html_url": "https://github.com/rust-lang/rust/commit/8ae904062b2700a797138d2b8274f2e141ea1e53"}, {"sha": "e1d4b8fc8c3e991627715916f7285611ec49424e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d4b8fc8c3e991627715916f7285611ec49424e", "html_url": "https://github.com/rust-lang/rust/commit/e1d4b8fc8c3e991627715916f7285611ec49424e"}], "stats": {"total": 498, "additions": 269, "deletions": 229}, "files": [{"sha": "a684563512da652a726785817238d02efda070c5", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -10,9 +10,9 @@\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n@@ -131,7 +131,8 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n-        let mut state = DefaultHasher::new();\n+        debug!(\"deterministic_hash({:?})\", self);\n+        let mut state = StableHasher::new();\n         self.deterministic_hash_to(tcx, &mut state);\n         state.finish()\n     }\n@@ -377,4 +378,3 @@ impl DefPathData {\n         self.as_interned_str().to_string()\n     }\n }\n-"}, {"sha": "b4ac6b9d2502ece9030c319723ecd1e76d2603b8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 88, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -24,11 +24,11 @@ use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n use std::cmp;\n-use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n+use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher::new(self, DefaultHasher::default());\n+        let mut hasher = TypeIdHasher::new(self);\n         hasher.visit_ty(ty);\n         hasher.finish()\n     }\n@@ -395,96 +395,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// When hashing a type this ends up affecting properties like symbol names. We\n-/// want these symbol names to be calculated independent of other factors like\n-/// what architecture you're compiling *from*.\n-///\n-/// The hashing just uses the standard `Hash` trait, but the implementations of\n-/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n-/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n-/// `isize` completely when hashing. To ensure that these don't leak in we use a\n-/// custom hasher implementation here which inflates the size of these to a `u64`\n-/// and `i64`.\n-///\n-/// The same goes for endianess: We always convert multi-byte integers to little\n-/// endian before hashing.\n-#[derive(Debug)]\n-pub struct ArchIndependentHasher<H> {\n-    inner: H,\n-}\n-\n-impl<H> ArchIndependentHasher<H> {\n-    pub fn new(inner: H) -> ArchIndependentHasher<H> {\n-        ArchIndependentHasher { inner: inner }\n-    }\n-\n-    pub fn into_inner(self) -> H {\n-        self.inner\n-    }\n+pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    state: StableHasher<W>,\n }\n \n-impl<H: Hasher> Hasher for ArchIndependentHasher<H> {\n-    fn write(&mut self, bytes: &[u8]) {\n-        self.inner.write(bytes)\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        self.inner.finish()\n-    }\n-\n-    fn write_u8(&mut self, i: u8) {\n-        self.inner.write_u8(i)\n-    }\n-    fn write_u16(&mut self, i: u16) {\n-        self.inner.write_u16(i.to_le())\n-    }\n-    fn write_u32(&mut self, i: u32) {\n-        self.inner.write_u32(i.to_le())\n-    }\n-    fn write_u64(&mut self, i: u64) {\n-        self.inner.write_u64(i.to_le())\n-    }\n-    fn write_usize(&mut self, i: usize) {\n-        self.inner.write_u64((i as u64).to_le())\n+impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n+    where W: StableHasherResult\n+{\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        TypeIdHasher { tcx: tcx, state: StableHasher::new() }\n     }\n-    fn write_i8(&mut self, i: i8) {\n-        self.inner.write_i8(i)\n-    }\n-    fn write_i16(&mut self, i: i16) {\n-        self.inner.write_i16(i.to_le())\n-    }\n-    fn write_i32(&mut self, i: i32) {\n-        self.inner.write_i32(i.to_le())\n-    }\n-    fn write_i64(&mut self, i: i64) {\n-        self.inner.write_i64(i.to_le())\n-    }\n-    fn write_isize(&mut self, i: isize) {\n-        self.inner.write_i64((i as i64).to_le())\n-    }\n-}\n-\n-pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: ArchIndependentHasher<H>,\n-}\n \n-impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n-        TypeIdHasher {\n-            tcx: tcx,\n-            state: ArchIndependentHasher::new(state),\n-        }\n+    pub fn finish(self) -> W {\n+        self.state.finish()\n     }\n \n     pub fn hash<T: Hash>(&mut self, x: T) {\n         x.hash(&mut self.state);\n     }\n \n-    pub fn finish(self) -> u64 {\n-        self.state.finish()\n-    }\n-\n     fn hash_discriminant_u8<T>(&mut self, x: &T) {\n         let v = unsafe {\n             intrinsics::discriminant_value(x)\n@@ -504,13 +434,11 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n         def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n-\n-    pub fn into_inner(self) -> H {\n-        self.state.inner\n-    }\n }\n \n-impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {\n+impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n+    where W: StableHasherResult\n+{\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // Distinguish between the Ty variants uniformly.\n         self.hash_discriminant_u8(&ty.sty);"}, {"sha": "86f244d65dd42fe16bc8e7f420cf948ed82202e5", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -44,6 +44,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n \n+pub use rustc_serialize::hex::ToHex;\n+\n pub mod array_vec;\n pub mod accumulate_vec;\n pub mod small_vec;\n@@ -59,6 +61,7 @@ pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod snapshot_map;\n pub mod snapshot_vec;\n+pub mod stable_hasher;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;"}, {"sha": "ed97c3dde5effae11c16d94ff21fda4995d77f74", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -0,0 +1,176 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hasher;\n+use std::marker::PhantomData;\n+use std::mem;\n+use blake2b::Blake2bHasher;\n+use rustc_serialize::leb128;\n+\n+fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n+    leb128::write_unsigned_leb128_to(value, |i, v| buf[i] = v)\n+}\n+\n+fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n+    leb128::write_signed_leb128_to(value, |i, v| buf[i] = v)\n+}\n+\n+/// When hashing something that ends up affecting properties like symbol names. We\n+/// want these symbol names to be calculated independent of other factors like\n+/// what architecture you're compiling *from*.\n+///\n+/// The hashing just uses the standard `Hash` trait, but the implementations of\n+/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+/// `isize` completely when hashing.\n+///\n+/// To do that, we encode all integers to be hashed with some\n+/// arch-independent encoding.\n+///\n+/// At the moment, we pass i8/u8 straight through and encode\n+/// all other integers using leb128.\n+///\n+/// This hasher currently always uses the stable Blake2b algorithm\n+/// and allows for variable output lengths through its type\n+/// parameter.\n+#[derive(Debug)]\n+pub struct StableHasher<W> {\n+    state: Blake2bHasher,\n+    bytes_hashed: u64,\n+    width: PhantomData<W>,\n+}\n+\n+pub trait StableHasherResult: Sized {\n+    fn finish(hasher: StableHasher<Self>) -> Self;\n+}\n+\n+impl<W: StableHasherResult> StableHasher<W> {\n+    pub fn new() -> Self {\n+        StableHasher {\n+            state: Blake2bHasher::new(mem::size_of::<W>(), &[]),\n+            bytes_hashed: 0,\n+            width: PhantomData,\n+        }\n+    }\n+\n+    pub fn finish(self) -> W {\n+        W::finish(self)\n+    }\n+}\n+\n+impl StableHasherResult for [u8; 20] {\n+    fn finish(mut hasher: StableHasher<Self>) -> Self {\n+        let mut result: [u8; 20] = [0; 20];\n+        result.copy_from_slice(hasher.state.finalize());\n+        result\n+    }\n+}\n+\n+impl StableHasherResult for u64 {\n+    fn finish(mut hasher: StableHasher<Self>) -> Self {\n+        hasher.state.finalize();\n+        hasher.state.finish()\n+    }\n+}\n+\n+impl<W> StableHasher<W> {\n+    #[inline]\n+    pub fn finalize(&mut self) -> &[u8] {\n+        self.state.finalize()\n+    }\n+\n+    #[inline]\n+    pub fn bytes_hashed(&self) -> u64 {\n+        self.bytes_hashed\n+    }\n+\n+    #[inline]\n+    fn write_uleb128(&mut self, value: u64) {\n+        let mut buf = [0; 16];\n+        let len = write_unsigned_leb128_to_buf(&mut buf, value);\n+        self.state.write(&buf[..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n+\n+    #[inline]\n+    fn write_ileb128(&mut self, value: i64) {\n+        let mut buf = [0; 16];\n+        let len = write_signed_leb128_to_buf(&mut buf, value);\n+        self.state.write(&buf[..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n+}\n+\n+// For the non-u8 integer cases we leb128 encode them first. Because small\n+// integers dominate, this significantly and cheaply reduces the number of\n+// bytes hashed, which is good because blake2b is expensive.\n+impl<W> Hasher for StableHasher<W> {\n+    fn finish(&self) -> u64 {\n+        panic!(\"use StableHasher::finish instead\");\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        self.state.write(bytes);\n+        self.bytes_hashed += bytes.len() as u64;\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.state.write_u8(i);\n+        self.bytes_hashed += 1;\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write_uleb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, i: i8) {\n+        self.state.write_i8(i);\n+        self.bytes_hashed += 1;\n+    }\n+\n+    #[inline]\n+    fn write_i16(&mut self, i: i16) {\n+        self.write_ileb128(i as i64);\n+    }\n+\n+    #[inline]\n+    fn write_i32(&mut self, i: i32) {\n+        self.write_ileb128(i as i64);\n+    }\n+\n+    #[inline]\n+    fn write_i64(&mut self, i: i64) {\n+        self.write_ileb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_isize(&mut self, i: isize) {\n+        self.write_ileb128(i as i64);\n+    }\n+}"}, {"sha": "ace00f031859dd43e30afdf6b1a958726ecb4e22", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -11,9 +11,7 @@\n use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n use rustc::hir::lowering::lower_crate;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n-use rustc_data_structures::fmt_wrap::FmtWrap;\n-use rustc::ty::util::ArchIndependentHasher;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n@@ -27,6 +25,7 @@ use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental::ich::Fingerprint;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -1274,7 +1273,7 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n     // FIXME(mw): It seems that the crate_disambiguator is used everywhere as\n     //            a hex-string instead of raw bytes. We should really use the\n     //            smaller representation.\n-    let mut hasher = ArchIndependentHasher::new(Blake2bHasher::new(128 / 8, &[]));\n+    let mut hasher = StableHasher::<Fingerprint>::new();\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -1292,14 +1291,11 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n         hasher.write(s.as_bytes());\n     }\n \n-    let mut hash_state = hasher.into_inner();\n-    let hash_bytes = hash_state.finalize();\n-\n     // If this is an executable, add a special suffix, so that we don't get\n     // symbol conflicts when linking against a library of the same name.\n     let is_exe = session.crate_types.borrow().contains(&config::CrateTypeExecutable);\n \n-    format!(\"{:x}{}\", FmtWrap(hash_bytes), if is_exe { \"-exe\" } else {\"\"})\n+    format!(\"{}{}\", hasher.finish().to_hex(), if is_exe { \"-exe\" } else {\"\"})\n }\n \n pub fn build_output_filenames(input: &Input,"}, {"sha": "d7d9c231a91f48ea772b72585da7cd23dcfd316b", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8ae904062b2700a797138d2b8274f2e141ea1e53/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae904062b2700a797138d2b8274f2e141ea1e53/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=8ae904062b2700a797138d2b8274f2e141ea1e53", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-use std::hash::Hasher;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n-use rustc::ty::util::ArchIndependentHasher;\n-use ich::Fingerprint;\n-use rustc_serialize::leb128::write_unsigned_leb128;\n-\n-#[derive(Debug)]\n-pub struct IchHasher {\n-    state: ArchIndependentHasher<Blake2bHasher>,\n-    leb128_helper: Vec<u8>,\n-    bytes_hashed: u64,\n-}\n-\n-impl IchHasher {\n-    pub fn new() -> IchHasher {\n-        let hash_size = mem::size_of::<Fingerprint>();\n-        IchHasher {\n-            state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n-            leb128_helper: vec![],\n-            bytes_hashed: 0\n-        }\n-    }\n-\n-    pub fn bytes_hashed(&self) -> u64 {\n-        self.bytes_hashed\n-    }\n-\n-    pub fn finish(self) -> Fingerprint {\n-        let mut fingerprint = Fingerprint::zero();\n-        fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n-        fingerprint\n-    }\n-\n-    #[inline]\n-    fn write_uleb128(&mut self, value: u64) {\n-        let len = write_unsigned_leb128(&mut self.leb128_helper, 0, value);\n-        self.state.write(&self.leb128_helper[0..len]);\n-        self.bytes_hashed += len as u64;\n-    }\n-}\n-\n-// For the non-u8 integer cases we leb128 encode them first. Because small\n-// integers dominate, this significantly and cheaply reduces the number of\n-// bytes hashed, which is good because blake2b is expensive.\n-impl Hasher for IchHasher {\n-    fn finish(&self) -> u64 {\n-        bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n-    }\n-\n-    #[inline]\n-    fn write(&mut self, bytes: &[u8]) {\n-        self.state.write(bytes);\n-        self.bytes_hashed += bytes.len() as u64;\n-    }\n-\n-    // There is no need to leb128-encode u8 values.\n-\n-    #[inline]\n-    fn write_u16(&mut self, i: u16) {\n-        self.write_uleb128(i as u64);\n-    }\n-\n-    #[inline]\n-    fn write_u32(&mut self, i: u32) {\n-        self.write_uleb128(i as u64);\n-    }\n-\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.write_uleb128(i);\n-    }\n-\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        self.write_uleb128(i as u64);\n-    }\n-}"}, {"sha": "eb31be4a8ade289d58edc0c3c1eff942cee0fb74", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -36,21 +36,21 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n use self::caching_codemap_view::CachingCodemapView;\n-use self::hasher::IchHasher;\n-use ich::Fingerprint;\n-\n \n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n-pub mod hasher;\n+\n+pub type IchHasher = StableHasher<Fingerprint>;\n \n pub struct IncrementalHashesMap {\n     hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n@@ -244,4 +244,3 @@ impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n         visit::walk_foreign_item(self, item);\n     }\n }\n-"}, {"sha": "ec44e19df10c999518d873199520d035632cfab3", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -32,7 +32,7 @@ use std::hash::Hash;\n \n use super::def_path_hash::DefPathHashes;\n use super::caching_codemap_view::CachingCodemapView;\n-use super::hasher::IchHasher;\n+use super::IchHasher;\n \n const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\","}, {"sha": "d296d8293fb0674010bb00d12ec012fdfaca0588", "filename": "src/librustc_incremental/ich/fingerprint.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n+use rustc_data_structures::stable_hasher;\n+use rustc_data_structures::ToHex;\n \n const FINGERPRINT_LENGTH: usize = 16;\n \n@@ -44,6 +46,10 @@ impl Fingerprint {\n         ((self.0[6] as u64) << 48) |\n         ((self.0[7] as u64) << 56)\n     }\n+\n+    pub fn to_hex(&self) -> String {\n+        self.0.to_hex()\n+    }\n }\n \n impl Encodable for Fingerprint {\n@@ -79,3 +85,12 @@ impl ::std::fmt::Display for Fingerprint {\n         Ok(())\n     }\n }\n+\n+\n+impl stable_hasher::StableHasherResult for Fingerprint {\n+    fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n+        let mut fingerprint = Fingerprint::zero();\n+        fingerprint.0.copy_from_slice(hasher.finalize());\n+        fingerprint\n+    }\n+}"}, {"sha": "ce73b14ef2d027c926393936a1dd00ebe79ac6fd", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -48,7 +48,7 @@ pub mod ich;\n pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::compute_incremental_hashes_map;\n pub use calculate_svh::IncrementalHashesMap;\n-pub use calculate_svh::hasher::IchHasher;\n+pub use calculate_svh::IchHasher;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "f3bbd02dffa3f1d8fc54a329c311391e7da39993", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -30,7 +30,7 @@ use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n-use calculate_svh::hasher::IchHasher;\n+use calculate_svh::IchHasher;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,"}, {"sha": "938848054fee24266522d561ce951da69cef6d55", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -99,8 +99,6 @@\n \n use common::SharedCrateContext;\n use monomorphize::Instance;\n-use rustc_data_structures::fmt_wrap::FmtWrap;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -135,7 +133,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let tcx = scx.tcx();\n \n-    let mut hasher = ty::util::TypeIdHasher::new(tcx, Blake2bHasher::new(8, &[]));\n+    let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n@@ -158,9 +156,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    let mut hasher = hasher.into_inner();\n-    let hash_bytes = hasher.finalize();\n-    format!(\"h{:x}\", FmtWrap(hash_bytes))\n+    format!(\"h{:016x}\", hasher.finish())\n }\n \n impl<'a, 'tcx> Instance<'tcx> {"}, {"sha": "bc9c86c99a3ee982f15a7502efc5f768b916c431", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -31,7 +31,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc_data_structures::ToHex;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -42,7 +42,6 @@ use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use syntax::ast;\n@@ -147,21 +146,11 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        const TYPE_ID_HASH_LENGTH: usize = 20;\n \n-        let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n-                                                   Blake2bHasher::new(TYPE_ID_HASH_LENGTH, &[]));\n+        let mut type_id_hasher = TypeIdHasher::<[u8; 20]>::new(cx.tcx());\n         type_id_hasher.visit_ty(type_);\n-        let mut hash_state = type_id_hasher.into_inner();\n-        let hash: &[u8] = hash_state.finalize();\n-        debug_assert!(hash.len() == TYPE_ID_HASH_LENGTH);\n-\n-        let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n-\n-        for byte in hash.into_iter() {\n-            write!(&mut unique_type_id, \"{:x}\", byte).unwrap();\n-        }\n \n+        let unique_type_id = type_id_hasher.finish().to_hex();\n         let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n "}, {"sha": "5b72c6d46aceb330b5a7c382e42e6b6a6123527a", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d8ab09e39bacae2c008995bbb669442115517f/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=c6d8ab09e39bacae2c008995bbb669442115517f", "patch": "@@ -9,33 +9,46 @@\n // except according to those terms.\n \n #[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8) {\n-    if *position == vec.len() {\n+fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n+    if position == vec.len() {\n         vec.push(byte);\n     } else {\n-        vec[*position] = byte;\n+        vec[position] = byte;\n     }\n-\n-    *position += 1;\n }\n \n-pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, mut value: u64) -> usize {\n-    let mut position = start_position;\n+#[inline]\n+/// encodes an integer using unsigned leb128 encoding and stores\n+/// the result using a callback function.\n+///\n+/// The callback `write` is called once for each position\n+/// that is to be written to with the byte to be encoded\n+/// at that position.\n+pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n+    where W: FnMut(usize, u8)\n+{\n+    let mut position = 0;\n+\n     loop {\n         let mut byte = (value & 0x7F) as u8;\n         value >>= 7;\n         if value != 0 {\n             byte |= 0x80;\n         }\n \n-        write_to_vec(out, &mut position, byte);\n+        write(position, byte);\n+        position += 1;\n \n         if value == 0 {\n             break;\n         }\n     }\n \n-    return position - start_position;\n+    position\n+}\n+\n+pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u64) -> usize {\n+    write_unsigned_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n@@ -56,9 +69,17 @@ pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize)\n     (result, position - start_position)\n }\n \n-\n-pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, mut value: i64) -> usize {\n-    let mut position = start_position;\n+#[inline]\n+/// encodes an integer using signed leb128 encoding and stores\n+/// the result using a callback function.\n+///\n+/// The callback `write` is called once for each position\n+/// that is to be written to with the byte to be encoded\n+/// at that position.\n+pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n+    where W: FnMut(usize, u8)\n+{\n+    let mut position = 0;\n \n     loop {\n         let mut byte = (value as u8) & 0x7f;\n@@ -69,14 +90,19 @@ pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, mut value:\n             byte |= 0x80; // Mark this byte to show that more bytes will follow.\n         }\n \n-        write_to_vec(out, &mut position, byte);\n+        write(position, byte);\n+        position += 1;\n \n         if !more {\n             break;\n         }\n     }\n \n-    return position - start_position;\n+    position\n+}\n+\n+pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i64) -> usize {\n+    write_signed_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]"}]}