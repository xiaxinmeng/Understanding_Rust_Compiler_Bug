{"sha": "472ca7159812f8c360697f63454ee7bda1e02570", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MmNhNzE1OTgxMmY4YzM2MDY5N2Y2MzQ1NGVlN2JkYTFlMDI1NzA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-08-22T13:56:37Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-31T06:39:59Z"}, "message": "Implement the `min_const_fn` feature gate", "tree": {"sha": "6a79a67fdb82c6c5619bdada6859aa6598b555b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a79a67fdb82c6c5619bdada6859aa6598b555b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/472ca7159812f8c360697f63454ee7bda1e02570", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/472ca7159812f8c360697f63454ee7bda1e02570", "html_url": "https://github.com/rust-lang/rust/commit/472ca7159812f8c360697f63454ee7bda1e02570", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/472ca7159812f8c360697f63454ee7bda1e02570/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1114ab684fbad001c4e580326d8eb4d8c4e917d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1114ab684fbad001c4e580326d8eb4d8c4e917d3", "html_url": "https://github.com/rust-lang/rust/commit/1114ab684fbad001c4e580326d8eb4d8c4e917d3"}], "stats": {"total": 1856, "additions": 1626, "deletions": 230}, "files": [{"sha": "e00a22bf8b6c360674bcd3ec5da5573e49cb0cf6", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -285,6 +285,15 @@ pub fn forget<T>(t: T) {\n /// [alignment]: ./fn.align_of.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+pub const fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+/// Ceci n'est pas la documentation\n pub const fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -334,6 +343,16 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n+#[cfg(not(stage0))]\n+pub fn min_align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n+#[cfg(stage0)]\n+/// Ceci n'est pas la documentation\n pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -376,6 +395,15 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+pub const fn align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+/// Ceci n'est pas la documentation\n pub const fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }"}, {"sha": "f11e4487964624d74ce17abd7aa57a3d0b0846e9", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -65,6 +65,7 @@ for mir::UnsafetyViolationKind {\n \n         match *self {\n             mir::UnsafetyViolationKind::General => {}\n+            mir::UnsafetyViolationKind::MinConstFn => {}\n             mir::UnsafetyViolationKind::ExternStatic(lint_node_id) |\n             mir::UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n                 lint_node_id.hash_stable(hcx, hasher);"}, {"sha": "a15411c7d83698c115b8bb5dc8f8a5531e22a0ae", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -130,7 +130,7 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     level,\n     feature,\n     rustc_depr,\n-    rustc_const_unstable\n+    const_stability\n });\n \n impl<'a> HashStable<StableHashingContext<'a>>\n@@ -161,7 +161,6 @@ for ::syntax::attr::StabilityLevel {\n }\n \n impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason });\n-impl_stable_hash_for!(struct ::syntax::attr::RustcConstUnstable { feature });\n \n \n impl_stable_hash_for!(enum ::syntax::attr::IntType {"}, {"sha": "f237c5b397bd5263722c7ab089f0760ac12a605f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -440,7 +440,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                     },\n                     feature: Symbol::intern(\"rustc_private\"),\n                     rustc_depr: None,\n-                    rustc_const_unstable: None,\n+                    const_stability: None,\n                 });\n                 annotator.parent_stab = Some(stability);\n             }"}, {"sha": "0e60d6565176ad7da452fcf1ff72410a3dff9a1d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -2394,6 +2394,8 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n+    /// unsafety is not allowed at all in min const fn\n+    MinConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n }"}, {"sha": "6981d92f05f00cf9ec4c96acf9e99d4adccf19e9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -1099,6 +1099,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         local as usize == global as usize\n     }\n \n+    /// Returns true if this function must conform to `min_const_fn`\n+    pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n+        if self.features().staged_api {\n+            // some intrinsics are waved through if called inside the\n+            // standard library. Users never need to call them directly\n+            if let abi::Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n+                assert!(!self.is_const_fn(def_id));\n+                match &self.item_name(def_id).as_str()[..] {\n+                    | \"size_of\"\n+                    | \"min_align_of\"\n+                    => return true,\n+                    _ => {},\n+                }\n+            }\n+            // in order for a libstd function to be considered min_const_fn\n+            // it needs to be stable and have no `rustc_const_unstable` attribute\n+            match self.lookup_stability(def_id) {\n+                // stable functions with unstable const fn aren't `min_const_fn`\n+                Some(&attr::Stability { const_stability: Some(_), .. }) => false,\n+                // unstable functions don't need to conform\n+                Some(&attr::Stability { ref level, .. }) if level.is_unstable() => false,\n+                // everything else needs to conform, because it would be callable from\n+                // other `min_const_fn` functions\n+                _ => true,\n+            }\n+        } else {\n+            // users enabling the `const_fn` can do what they want\n+            !self.sess.features_untracked().const_fn\n+        }\n+    }\n+\n     /// Create a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid"}, {"sha": "b4257a40e38af0dd0ea3ff3de467b5d4cd080ca6", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -18,7 +18,6 @@ use hair::*;\n \n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::Node;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n@@ -67,10 +66,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n             hir::BodyOwnerKind::Static(_) => hir::Constness::Const,\n-            hir::BodyOwnerKind::Fn => {\n-                let fn_like = FnLikeNode::from_node(infcx.tcx.hir.get(src_id));\n-                fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n-            }\n+            hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n         let attrs = tcx.hir.attrs(src_id);\n@@ -83,7 +79,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();\n \n-        // Constants and const fn's always need overflow checks.\n+        // Constants always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n         let lint_level = lint_level_for_hir_id(tcx, src_id);"}, {"sha": "ec7fd371a442bb8ca406751b2953587379eb3173", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -28,6 +28,7 @@ use util;\n \n pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n+    min_const_fn: bool,\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n@@ -38,12 +39,16 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>,\n-           source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n-           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>) -> Self {\n+    fn new(\n+        min_const_fn: bool,\n+        mir: &'a Mir<'tcx>,\n+        source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n         Self {\n             mir,\n+            min_const_fn,\n             source_scope_local_data,\n             violations: vec![],\n             source_info: SourceInfo {\n@@ -269,14 +274,22 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn register_violations(&mut self,\n                            violations: &[UnsafetyViolation],\n                            unsafe_blocks: &[(ast::NodeId, bool)]) {\n+        if self.min_const_fn {\n+            for violation in violations {\n+                let mut violation = violation.clone();\n+                violation.kind = UnsafetyViolationKind::MinConstFn;\n+                if !self.violations.contains(&violation) {\n+                    self.violations.push(violation)\n+                }\n+            }\n+        }\n         let within_unsafe = match self.source_scope_local_data[self.source_info.scope].safety {\n             Safety::Safe => {\n                 for violation in violations {\n                     if !self.violations.contains(violation) {\n                         self.violations.push(violation.clone())\n                     }\n                 }\n-\n                 false\n             }\n             Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n@@ -369,6 +382,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     let param_env = tcx.param_env(def_id);\n     let mut checker = UnsafetyChecker::new(\n+        tcx.is_const_fn(def_id) && tcx.is_min_const_fn(def_id),\n         mir, source_scope_local_data, tcx, param_env);\n     checker.visit_mir(mir);\n \n@@ -478,6 +492,15 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                     .note(&details.as_str()[..])\n                     .emit();\n             }\n+            UnsafetyViolationKind::MinConstFn => {\n+                tcx.sess.struct_span_err(\n+                    source_info.span,\n+                    &format!(\"{} is unsafe and unsafe operations \\\n+                            are not allowed in const fn\", description))\n+                    .span_label(source_info.span, &description.as_str()[..])\n+                    .note(&details.as_str()[..])\n+                    .emit();\n+            }\n             UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n                 tcx.lint_node_note(SAFE_EXTERN_STATICS,\n                               lint_node_id,"}, {"sha": "1e05b07030ef898436f6740b9ebce4076a11d749", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -36,6 +36,7 @@ pub mod elaborate_drops;\n pub mod add_call_guards;\n pub mod promote_consts;\n pub mod qualify_consts;\n+mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n pub mod dump_mir;\n pub mod deaggregator;"}, {"sha": "c696318d283cecd87d26e0d3b52fa69cc52ce11b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -916,9 +916,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         );\n                     }\n                 } else if let Some(&attr::Stability {\n-                    rustc_const_unstable: Some(attr::RustcConstUnstable {\n-                        feature: ref feature_name\n-                    }),\n+                    const_stability: Some(ref feature_name),\n                 .. }) = self.tcx.lookup_stability(def_id) {\n                     if\n                         // feature-gate is not enabled,\n@@ -1175,8 +1173,20 @@ impl MirPass for QualifyAndPromoteConstants {\n             let (temps, candidates) = {\n                 let mut qualifier = Qualifier::new(tcx, def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n-                    // Enforce a constant-like CFG for `const fn`.\n-                    qualifier.qualify_const();\n+                    if tcx.is_min_const_fn(def_id) {\n+                        // enforce `min_const_fn` for stable const fns\n+                        use super::qualify_min_const_fn::is_min_const_fn;\n+                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, mir) {\n+                            tcx.sess.span_err(span, &err);\n+                        } else {\n+                            // this should not produce any errors, but better safe than sorry\n+                            // FIXME(#53819)\n+                            qualifier.qualify_const();\n+                        }\n+                    } else {\n+                        // Enforce a constant-like CFG for `const fn`.\n+                        qualifier.qualify_const();\n+                    }\n                 } else {\n                     while let Some((bb, data)) = qualifier.rpo.next() {\n                         qualifier.visit_basic_block_data(bb, data);"}, {"sha": "53ba4b03cb734f760c962f294c667dad76473526", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,378 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, Predicate, TyCtxt};\n+use std::borrow::Cow;\n+use syntax_pos::Span;\n+\n+mod helper {\n+    pub struct IsMinConstFn(());\n+    /// This should only ever be used *once* and then passed around as a token.\n+    pub fn ensure_that_you_really_intended_to_create_an_instance_of_this() -> IsMinConstFn {\n+        IsMinConstFn(())\n+    }\n+}\n+\n+use self::helper::*;\n+\n+type McfResult = Result<IsMinConstFn, (Span, Cow<'static, str>)>;\n+\n+pub fn is_min_const_fn(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    mir: &'a Mir<'tcx>,\n+) -> McfResult {\n+    let mut current = def_id;\n+    loop {\n+        let predicates = tcx.predicates_of(current);\n+        for predicate in &predicates.predicates {\n+            match predicate {\n+                | Predicate::RegionOutlives(_)\n+                | Predicate::TypeOutlives(_)\n+                | Predicate::WellFormed(_)\n+                | Predicate::ConstEvaluatable(..) => continue,\n+                | Predicate::ObjectSafe(_) => {\n+                    bug!(\"object safe predicate on function: {:#?}\", predicate)\n+                }\n+                Predicate::ClosureKind(..) => {\n+                    bug!(\"closure kind predicate on function: {:#?}\", predicate)\n+                }\n+                Predicate::Subtype(_) => bug!(\"subtype predicate on function: {:#?}\", predicate),\n+                Predicate::Projection(_) => {\n+                    let span = tcx.def_span(current);\n+                    // we'll hit a `Predicate::Trait` later which will report an error\n+                    tcx.sess\n+                        .delay_span_bug(span, \"projection without trait bound\");\n+                    continue;\n+                }\n+                Predicate::Trait(pred) => {\n+                    if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n+                        continue;\n+                    }\n+                    match pred.skip_binder().self_ty().sty {\n+                        ty::Param(ref p) => {\n+                            let generics = tcx.generics_of(current);\n+                            let def = generics.type_param(p, tcx);\n+                            let span = tcx.def_span(def.def_id);\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ));\n+                        }\n+                        // other kinds of bounds are either tautologies\n+                        // or cause errors in other passes\n+                        _ => continue,\n+                    }\n+                }\n+            }\n+        }\n+        match predicates.parent {\n+            Some(parent) => current = parent,\n+            None => break,\n+        }\n+    }\n+\n+    let mut token = ensure_that_you_really_intended_to_create_an_instance_of_this();\n+\n+    for local in mir.vars_iter() {\n+        return Err((\n+            mir.local_decls[local].source_info.span,\n+            \"local variables in const fn are unstable\".into(),\n+        ));\n+    }\n+    for local in &mir.local_decls {\n+        token = check_ty(tcx, local.ty, local.source_info.span, token)?;\n+    }\n+    // impl trait is gone in MIR, so check the return type manually\n+    token = check_ty(\n+        tcx,\n+        tcx.fn_sig(def_id).output().skip_binder(),\n+        mir.local_decls.iter().next().unwrap().source_info.span,\n+        token,\n+    )?;\n+\n+    for bb in mir.basic_blocks() {\n+        token = check_terminator(tcx, mir, bb.terminator(), token)?;\n+        for stmt in &bb.statements {\n+            token = check_statement(tcx, mir, stmt, token)?;\n+        }\n+    }\n+    Ok(token)\n+}\n+\n+fn check_ty(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    span: Span,\n+    token: IsMinConstFn,\n+) -> McfResult {\n+    for ty in ty.walk() {\n+        match ty.sty {\n+            ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n+                span,\n+                \"mutable references in const fn are unstable\".into(),\n+            )),\n+            ty::Anon(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::FnPtr(..) => {\n+                return Err((span, \"function pointers in const fn are unstable\".into()))\n+            }\n+            ty::Dynamic(preds, _) => {\n+                for pred in preds.iter() {\n+                    match pred.skip_binder() {\n+                        | ty::ExistentialPredicate::AutoTrait(_)\n+                        | ty::ExistentialPredicate::Projection(_) => {\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ))\n+                        }\n+                        ty::ExistentialPredicate::Trait(trait_ref) => {\n+                            if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n+                                return Err((\n+                                    span,\n+                                    \"trait bounds other than `Sized` \\\n+                                     on const fn parameters are unstable\"\n+                                        .into(),\n+                                ));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(token)\n+}\n+\n+fn check_rvalue(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    rvalue: &Rvalue<'tcx>,\n+    span: Span,\n+    token: IsMinConstFn,\n+) -> McfResult {\n+    match rvalue {\n+        Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n+            check_operand(tcx, mir, operand, span, token)\n+        }\n+        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n+            check_place(tcx, mir, place, span, token, PlaceMode::Read)\n+        }\n+        Rvalue::Cast(_, operand, cast_ty) => {\n+            use rustc::ty::cast::CastTy;\n+            let cast_in = CastTy::from_ty(operand.ty(mir, tcx)).expect(\"bad input type for cast\");\n+            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            match (cast_in, cast_out) {\n+                (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => Err((\n+                    span,\n+                    \"casting pointers to ints is unstable in const fn\".into(),\n+                )),\n+                (CastTy::RPtr(_), CastTy::Float) => bug!(),\n+                (CastTy::RPtr(_), CastTy::Int(_)) => bug!(),\n+                (CastTy::Ptr(_), CastTy::RPtr(_)) => bug!(),\n+                _ => check_operand(tcx, mir, operand, span, token),\n+            }\n+        }\n+        // binops are fine on integers\n+        Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+            let token = check_operand(tcx, mir, lhs, span, token)?;\n+            let token = check_operand(tcx, mir, rhs, span, token)?;\n+            let ty = lhs.ty(mir, tcx);\n+            if ty.is_integral() || ty.is_bool() || ty.is_char() {\n+                Ok(token)\n+            } else {\n+                Err((\n+                    span,\n+                    \"only int, `bool` and `char` operations are stable in const fn\".into(),\n+                ))\n+            }\n+        }\n+        // checked by regular const fn checks\n+        Rvalue::NullaryOp(..) => Ok(token),\n+        Rvalue::UnaryOp(_, operand) => {\n+            let ty = operand.ty(mir, tcx);\n+            if ty.is_integral() || ty.is_bool() {\n+                check_operand(tcx, mir, operand, span, token)\n+            } else {\n+                Err((\n+                    span,\n+                    \"only int and `bool` operations are stable in const fn\".into(),\n+                ))\n+            }\n+        }\n+        Rvalue::Aggregate(_, operands) => {\n+            let mut token = token;\n+            for operand in operands {\n+                token = check_operand(tcx, mir, operand, span, token)?;\n+            }\n+            Ok(token)\n+        }\n+    }\n+}\n+\n+enum PlaceMode {\n+    Assign,\n+    Read,\n+}\n+\n+fn check_statement(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    statement: &Statement<'tcx>,\n+    token: IsMinConstFn,\n+) -> McfResult {\n+    let span = statement.source_info.span;\n+    match &statement.kind {\n+        StatementKind::Assign(place, rval) => {\n+            let token = check_place(tcx, mir, place, span, token, PlaceMode::Assign)?;\n+            check_rvalue(tcx, mir, rval, span, token)\n+        }\n+\n+        StatementKind::ReadForMatch(_) => Err((span, \"match in const fn is unstable\".into())),\n+\n+        // just an assignment\n+        StatementKind::SetDiscriminant { .. } => Ok(token),\n+\n+        | StatementKind::InlineAsm { .. } => {\n+            Err((span, \"cannot use inline assembly in const fn\".into()))\n+        }\n+\n+        // These are all NOPs\n+        | StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        | StatementKind::Validate(..)\n+        | StatementKind::EndRegion(_)\n+        | StatementKind::UserAssertTy(..)\n+        | StatementKind::Nop => Ok(token),\n+    }\n+}\n+\n+fn check_operand(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    operand: &Operand<'tcx>,\n+    span: Span,\n+    token: IsMinConstFn,\n+) -> McfResult {\n+    match operand {\n+        Operand::Move(place) | Operand::Copy(place) => {\n+            check_place(tcx, mir, place, span, token, PlaceMode::Read)\n+        }\n+        Operand::Constant(_) => Ok(token),\n+    }\n+}\n+\n+fn check_place(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    place: &Place<'tcx>,\n+    span: Span,\n+    token: IsMinConstFn,\n+    mode: PlaceMode,\n+) -> McfResult {\n+    match place {\n+        Place::Local(l) => match mode {\n+            PlaceMode::Assign => match mir.local_kind(*l) {\n+                LocalKind::Temp | LocalKind::ReturnPointer => Ok(token),\n+                LocalKind::Arg | LocalKind::Var => {\n+                    Err((span, \"assignments in const fn are unstable\".into()))\n+                }\n+            },\n+            PlaceMode::Read => Ok(token),\n+        },\n+        // promoteds are always fine, they are essentially constants\n+        Place::Promoted(_) => Ok(token),\n+        Place::Static(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+        Place::Projection(proj) => {\n+            match proj.elem {\n+                | ProjectionElem::Deref | ProjectionElem::Field(..) | ProjectionElem::Index(_) => {\n+                    check_place(tcx, mir, &proj.base, span, token, mode)\n+                }\n+                // slice patterns are unstable\n+                | ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                    return Err((span, \"slice patterns in const fn are unstable\".into()))\n+                }\n+                | ProjectionElem::Downcast(..) => {\n+                    Err((span, \"`match` or `if let` in `const fn` is unstable\".into()))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_terminator(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    terminator: &Terminator<'tcx>,\n+    token: IsMinConstFn,\n+) -> McfResult {\n+    let span = terminator.source_info.span;\n+    match &terminator.kind {\n+        | TerminatorKind::Goto { .. }\n+        | TerminatorKind::Return\n+        | TerminatorKind::Resume => Ok(token),\n+\n+        TerminatorKind::Drop { location, .. } => {\n+            check_place(tcx, mir, location, span, token, PlaceMode::Read)\n+        }\n+        TerminatorKind::DropAndReplace { location, value, .. } => {\n+            let token = check_place(tcx, mir, location, span, token, PlaceMode::Read)?;\n+            check_operand(tcx, mir, value, span, token)\n+        },\n+        TerminatorKind::SwitchInt { .. } => Err((\n+            span,\n+            \"`if`, `match`, `&&` and `||` are not stable in const fn\".into(),\n+        )),\n+        | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n+            Err((span, \"const fn with unreachable code is not stable\".into()))\n+        }\n+        | TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n+            Err((span, \"const fn generators are unstable\".into()))\n+        }\n+\n+        TerminatorKind::Call {\n+            func,\n+            args,\n+            destination: _,\n+            cleanup: _,\n+        } => {\n+            let fn_ty = func.ty(mir, tcx);\n+            if let ty::FnDef(def_id, _) = fn_ty.sty {\n+                if tcx.is_min_const_fn(def_id) {\n+                    let mut token = check_operand(tcx, mir, func, span, token)?;\n+\n+                    for arg in args {\n+                        token = check_operand(tcx, mir, arg, span, token)?;\n+                    }\n+                    Ok(token)\n+                } else {\n+                    Err((\n+                        span,\n+                        \"can only call other `min_const_fn` within a `min_const_fn`\".into(),\n+                    ))\n+                }\n+            } else {\n+                Err((span, \"can only call other const fns within const fn\".into()))\n+            }\n+        }\n+\n+        TerminatorKind::Assert {\n+            cond,\n+            expected: _,\n+            msg: _,\n+            target: _,\n+            cleanup: _,\n+        } => check_operand(tcx, mir, cond, span, token),\n+\n+        | TerminatorKind::FalseEdges { .. } | TerminatorKind::FalseUnwind { .. } => span_bug!(\n+            terminator.source_info.span,\n+            \"min_const_fn encountered `{:#?}`\",\n+            terminator\n+        ),\n+    }\n+}"}, {"sha": "f9f74b77e6c46347386fbbf08edab0570986d24d", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -178,9 +178,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n \n         if let Some(&attr::Stability {\n-            rustc_const_unstable: Some(attr::RustcConstUnstable {\n-                                           feature: ref feature_name\n-                                       }),\n+            const_stability: Some(ref feature_name),\n             .. }) = self.tcx.lookup_stability(def_id) {\n             let stable_check =\n                 // feature-gate is enabled,"}, {"sha": "c7db3debf5a0d6dfacd6b276249715e1202d0a95", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -26,12 +26,15 @@ use rustc::hir;\n \n use std::iter;\n \n-fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   it: &hir::ForeignItem,\n-                                   n_tps: usize,\n-                                   abi: Abi,\n-                                   inputs: Vec<Ty<'tcx>>,\n-                                   output: Ty<'tcx>) {\n+fn equate_intrinsic_type<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    it: &hir::ForeignItem,\n+    n_tps: usize,\n+    abi: Abi,\n+    safety: hir::Unsafety,\n+    inputs: Vec<Ty<'tcx>>,\n+    output: Ty<'tcx>,\n+) {\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     match it.node {\n@@ -65,7 +68,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         inputs.into_iter(),\n         output,\n         false,\n-        hir::Unsafety::Unsafe,\n+        safety,\n         abi\n     )));\n     let cause = ObligationCause::new(it.span, it.id, ObligationCauseCode::IntrinsicType);\n@@ -78,7 +81,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n     let name = it.name.as_str();\n-    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+    let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n@@ -109,10 +112,14 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 return;\n             }\n         };\n-        (n_tps, inputs, output)\n+        (n_tps, inputs, output, hir::Unsafety::Unsafe)\n     } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), tcx.types.never)\n+        (0, Vec::new(), tcx.types.never, hir::Unsafety::Unsafe)\n     } else {\n+        let unsafety = match &name[..] {\n+            \"size_of\" | \"min_align_of\" => hir::Unsafety::Normal,\n+            _ => hir::Unsafety::Unsafe,\n+        };\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n             \"size_of\" |\n@@ -327,9 +334,9 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 return;\n             }\n         };\n-        (n_tps, inputs, output)\n+        (n_tps, inputs, output, unsafety)\n     };\n-    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -439,7 +446,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     };\n \n-    equate_intrinsic_type(tcx, it, n_tps, Abi::PlatformIntrinsic,\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::PlatformIntrinsic, hir::Unsafety::Unsafe,\n                           inputs, output)\n }\n "}, {"sha": "b956c72b3a2da53c0d8fde1b847165a1a108b7ac", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -1981,12 +1981,15 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     decl: &hir::FnDecl,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n-    let fty = AstConv::ty_of_fn(\n-        &ItemCtxt::new(tcx, def_id),\n-        hir::Unsafety::Unsafe,\n-        abi,\n-        decl,\n-    );\n+    let unsafety = if abi == abi::Abi::RustIntrinsic {\n+        match &*tcx.item_name(def_id).as_str() {\n+            \"size_of\" | \"min_align_of\" => hir::Unsafety::Normal,\n+            _ => hir::Unsafety::Unsafe,\n+        }\n+    } else {\n+        hir::Unsafety::Unsafe\n+    };\n+    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly."}, {"sha": "24965ff69318435e874eaad52f9dc8a1b58edcc3", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -18,41 +18,39 @@ pub struct Lazy<T> {\n     // We never call `lock.init()`, so it is UB to attempt to acquire this mutex reentrantly!\n     lock: Mutex,\n     ptr: Cell<*mut Arc<T>>,\n-    init: fn() -> Arc<T>,\n }\n \n #[inline]\n const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n \n unsafe impl<T> Sync for Lazy<T> {}\n \n-impl<T: Send + Sync + 'static> Lazy<T> {\n-    /// Safety: `init` must not call `get` on the variable that is being\n-    /// initialized.\n-    pub const unsafe fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n+impl<T> Lazy<T> {\n+    pub const fn new() -> Lazy<T> {\n         Lazy {\n             lock: Mutex::new(),\n             ptr: Cell::new(ptr::null_mut()),\n-            init,\n         }\n     }\n+}\n \n-    pub fn get(&'static self) -> Option<Arc<T>> {\n-        unsafe {\n-            let _guard = self.lock.lock();\n-            let ptr = self.ptr.get();\n-            if ptr.is_null() {\n-                Some(self.init())\n-            } else if ptr == done() {\n-                None\n-            } else {\n-                Some((*ptr).clone())\n-            }\n+impl<T: Send + Sync + 'static> Lazy<T> {\n+    /// Safety: `init` must not call `get` on the variable that is being\n+    /// initialized.\n+    pub unsafe fn get(&'static self, init: fn() -> Arc<T>) -> Option<Arc<T>> {\n+        let _guard = self.lock.lock();\n+        let ptr = self.ptr.get();\n+        if ptr.is_null() {\n+            Some(self.init(init))\n+        } else if ptr == done() {\n+            None\n+        } else {\n+            Some((*ptr).clone())\n         }\n     }\n \n     // Must only be called with `lock` held\n-    unsafe fn init(&'static self) -> Arc<T> {\n+    unsafe fn init(&'static self, init: fn() -> Arc<T>) -> Arc<T> {\n         // If we successfully register an at exit handler, then we cache the\n         // `Arc` allocation in our own internal box (it will get deallocated by\n         // the at exit handler). Otherwise we just return the freshly allocated\n@@ -66,8 +64,8 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         });\n         // This could reentrantly call `init` again, which is a problem\n         // because our `lock` allows reentrancy!\n-        // That's why `new` is unsafe and requires the caller to ensure no reentrancy happens.\n-        let ret = (self.init)();\n+        // That's why `get` is unsafe and requires the caller to ensure no reentrancy happens.\n+        let ret = init();\n         if registered.is_ok() {\n             self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n         }"}, {"sha": "a413432cdaabc6ba2b0075a2e10e161379ec7578", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -197,9 +197,11 @@ pub struct StdinLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = unsafe { Lazy::new(stdin_init) };\n+    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new();\n     return Stdin {\n-        inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n+        inner: unsafe {\n+            INSTANCE.get(stdin_init).expect(\"cannot access stdin during shutdown\")\n+        },\n     };\n \n     fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> {\n@@ -396,10 +398,11 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>\n-        = unsafe { Lazy::new(stdout_init) };\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> = Lazy::new();\n     return Stdout {\n-        inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n+        inner: unsafe {\n+            INSTANCE.get(stdout_init).expect(\"cannot access stdout during shutdown\")\n+        },\n     };\n \n     fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> {\n@@ -533,10 +536,11 @@ pub struct StderrLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> =\n-        unsafe { Lazy::new(stderr_init) };\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new();\n     return Stderr {\n-        inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n+        inner: unsafe {\n+            INSTANCE.get(stderr_init).expect(\"cannot access stderr during shutdown\")\n+        },\n     };\n \n     fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {"}, {"sha": "3eecdf14a4e50029eb62d7a161e310bcbd71f905", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -107,7 +107,11 @@ pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n     pub rustc_depr: Option<RustcDeprecation>,\n-    pub rustc_const_unstable: Option<RustcConstUnstable>,\n+    /// `None` means the function is stable but needs to be allowed by the\n+    /// `min_const_fn` feature\n+    /// `Some` contains the feature gate required to be able to use the function\n+    /// as const fn\n+    pub const_stability: Option<Symbol>,\n }\n \n /// The available stability levels.\n@@ -141,11 +145,6 @@ pub struct RustcDeprecation {\n     pub reason: Symbol,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct RustcConstUnstable {\n-    pub feature: Symbol,\n-}\n-\n /// Check if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n@@ -176,7 +175,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n \n     let mut stab: Option<Stability> = None;\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n-    let mut rustc_const_unstable: Option<RustcConstUnstable> = None;\n+    let mut rustc_const_unstable: Option<Symbol> = None;\n \n     'outer: for attr in attrs_iter {\n         if ![\n@@ -191,6 +190,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n         mark_used(attr);\n \n         let meta = attr.meta();\n+        // attributes with data\n         if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n@@ -272,9 +272,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n \n                     get_meta!(feature);\n                     if let Some(feature) = feature {\n-                        rustc_const_unstable = Some(RustcConstUnstable {\n-                            feature\n-                        });\n+                        rustc_const_unstable = Some(feature);\n                     } else {\n                         span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n                         continue\n@@ -330,7 +328,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 },\n                                 feature,\n                                 rustc_depr: None,\n-                                rustc_const_unstable: None,\n+                                const_stability: None,\n                             })\n                         }\n                         (None, _, _) => {\n@@ -379,7 +377,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 },\n                                 feature,\n                                 rustc_depr: None,\n-                                rustc_const_unstable: None,\n+                                const_stability: None,\n                             })\n                         }\n                         (None, _) => {\n@@ -412,9 +410,9 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n     }\n \n     // Merge the const-unstable info into the stability info\n-    if let Some(rustc_const_unstable) = rustc_const_unstable {\n+    if let Some(feature) = rustc_const_unstable {\n         if let Some(ref mut stab) = stab {\n-            stab.rustc_const_unstable = Some(rustc_const_unstable);\n+            stab.const_stability = Some(feature);\n         } else {\n             span_err!(diagnostic, item_sp, E0630,\n                       \"rustc_const_unstable attribute must be paired with \\"}, {"sha": "19bbbceff5fc02f3d6ef9d8e5f7d8421efc3b0f5", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -15,7 +15,7 @@ mod builtin;\n pub use self::builtin::{\n     cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n     find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, IntType, ReprAttr,\n-    RustcConstUnstable, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n+    RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n };\n pub use self::IntType::*;\n pub use self::ReprAttr::*;"}, {"sha": "f226c9dd979d44d0fcbcdfa505aac85b698cabe5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -40,6 +40,16 @@ use symbol::{keywords, Symbol};\n use std::{env, path};\n \n macro_rules! set {\n+    // The const_fn feature also enables the min_const_fn feature, because `min_const_fn` allows\n+    // the declaration `const fn`, but the `const_fn` feature gate enables things inside those\n+    // functions that we do not want to expose to the user for now.\n+    (const_fn) => {{\n+        fn f(features: &mut Features, _: Span) {\n+            features.const_fn = true;\n+            features.min_const_fn = true;\n+        }\n+        f as fn(&mut Features, Span)\n+    }};\n     ($field: ident) => {{\n         fn f(features: &mut Features, _: Span) {\n             features.$field = true;\n@@ -206,25 +216,28 @@ declare_features! (\n     // #23121. Array patterns have some hazards yet.\n     (active, slice_patterns, \"1.0.0\", Some(23121), None),\n \n-    // Allows the definition of `const fn` functions.\n+    // Allows the definition of `const fn` functions with some advanced features.\n     (active, const_fn, \"1.2.0\", Some(24111), None),\n \n+    // Allows the definition of `const fn` functions.\n+    (active, min_const_fn, \"1.30.0\", Some(53555), None),\n+\n     // Allows let bindings and destructuring in `const fn` functions and constants.\n     (active, const_let, \"1.22.1\", Some(48821), None),\n \n-    // Allows accessing fields of unions inside const fn\n+    // Allows accessing fields of unions inside const fn.\n     (active, const_fn_union, \"1.27.0\", Some(51909), None),\n \n-    // Allows casting raw pointers to `usize` during const eval\n+    // Allows casting raw pointers to `usize` during const eval.\n     (active, const_raw_ptr_to_usize_cast, \"1.27.0\", Some(51910), None),\n \n-    // Allows dereferencing raw pointers during const eval\n+    // Allows dereferencing raw pointers during const eval.\n     (active, const_raw_ptr_deref, \"1.27.0\", Some(51911), None),\n \n-    // Allows reinterpretation of the bits of a value of one type as another type during const eval\n+    // Allows reinterpretation of the bits of a value of one type as another type during const eval.\n     (active, const_transmute, \"1.29.0\", Some(53605), None),\n \n-    // Allows comparing raw pointers during const eval\n+    // Allows comparing raw pointers during const eval.\n     (active, const_compare_raw_pointers, \"1.27.0\", Some(53020), None),\n \n     // Allows panicking during const eval (produces compile-time errors)\n@@ -1786,7 +1799,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     gate_feature_post!(&self, async_await, span, \"async fn is unstable\");\n                 }\n                 if header.constness.node == ast::Constness::Const {\n-                    gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, min_const_fn, span, \"const fn is unstable\");\n                 }\n                 // stability of const fn methods are covered in\n                 // visit_trait_item and visit_impl_item below; this is\n@@ -1844,7 +1857,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match ii.node {\n             ast::ImplItemKind::Method(ref sig, _) => {\n                 if sig.header.constness.node == ast::Constness::Const {\n-                    gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, min_const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }\n             ast::ImplItemKind::Existential(..) => {"}, {"sha": "72c0e33cd9ecf46e636b7d3e5f3f971c7dd17d3d", "filename": "src/test/mir-opt/lower_128bit_test.rs", "status": "modified", "additions": 57, "deletions": 95, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-emscripten\n \n-// compile-flags: -Z lower_128bit_ops=yes -C debug_assertions=no\n+// compile-flags: -Z lower_128bit_ops=yes -C debug_assertions=no -O\n \n #![feature(const_fn)]\n \n@@ -63,103 +63,65 @@ fn main() {\n // END RUST SOURCE\n \n // START rustc.const_signed.Lower128Bit.after.mir\n-//     _8 = _1;\n-//     _9 = const compiler_builtins::int::addsub::rust_i128_addo(move _8, const 1i128) -> bb10;\n-//     ...\n-//     _7 = move (_9.0: i128);\n-//     ...\n-//     _10 = const compiler_builtins::int::addsub::rust_i128_subo(move _7, const 2i128) -> bb11;\n-//     ...\n-//     _6 = move (_10.0: i128);\n-//     ...\n-//     _11 = const compiler_builtins::int::mul::rust_i128_mulo(move _6, const 3i128) -> bb12;\n-//     ...\n-//     _5 = move (_11.0: i128);\n-//     ...\n-//     _12 = Eq(const 4i128, const 0i128);\n-//     assert(!move _12, \"attempt to divide by zero\") -> bb4;\n-//     ...\n-//     _13 = Eq(const 4i128, const -1i128);\n-//     _14 = Eq(_5, const -170141183460469231731687303715884105728i128);\n-//     _15 = BitAnd(move _13, move _14);\n-//     assert(!move _15, \"attempt to divide with overflow\") -> bb5;\n-//     ...\n-//     _4 = const compiler_builtins::int::sdiv::rust_i128_div(move _5, const 4i128) -> bb13;\n-//     ...\n-//     _17 = Eq(const 5i128, const -1i128);\n-//     _18 = Eq(_4, const -170141183460469231731687303715884105728i128);\n-//     _19 = BitAnd(move _17, move _18);\n-//     assert(!move _19, \"attempt to calculate the remainder with overflow\") -> bb7;\n-//     ...\n-//     _3 = const compiler_builtins::int::sdiv::rust_i128_rem(move _4, const 5i128) -> bb15;\n-//     ...\n-//     _2 = move (_20.0: i128);\n-//     ...\n-//     _23 = const 7i32 as u128 (Misc);\n-//     _21 = const compiler_builtins::int::shift::rust_i128_shro(move _2, move _23) -> bb16;\n-//     ...\n-//     _0 = move (_21.0: i128);\n-//     ...\n-//     assert(!move (_9.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_10.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_11.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     _16 = Eq(const 5i128, const 0i128);\n-//     assert(!move _16, \"attempt to calculate the remainder with a divisor of zero\") -> bb6;\n-//     ...\n-//     assert(!move (_20.1: bool), \"attempt to shift left with overflow\") -> bb8;\n-//     ...\n-//     _22 = const 6i32 as u128 (Misc);\n-//     _20 = const compiler_builtins::int::shift::rust_i128_shlo(move _3, move _22) -> bb14;\n-//     ...\n-//     assert(!move (_21.1: bool), \"attempt to shift right with overflow\") -> bb9;\n+// _7 = const compiler_builtins::int::addsub::rust_i128_add(move _8, const 1i128) -> bb7;\n+// ...\n+// _10 = Eq(const 4i128, const -1i128);\n+// _11 = Eq(_5, const -170141183460469231731687303715884105728i128);\n+// _12 = BitAnd(move _10, move _11);\n+// assert(!move _12, \"attempt to divide with overflow\") -> bb2;\n+// ...\n+// _4 = const compiler_builtins::int::sdiv::rust_i128_div(move _5, const 4i128) -> bb8;\n+// ...\n+// _14 = Eq(const 5i128, const -1i128);\n+// _15 = Eq(_4, const -170141183460469231731687303715884105728i128);\n+// _16 = BitAnd(move _14, move _15);\n+// assert(!move _16, \"attempt to calculate the remainder with overflow\") -> bb4;\n+// ...\n+// _3 = const compiler_builtins::int::sdiv::rust_i128_rem(move _4, const 5i128) -> bb11;\n+// ...\n+// _9 = Eq(const 4i128, const 0i128);\n+// assert(!move _9, \"attempt to divide by zero\") -> bb1;\n+// ...\n+// _5 = const compiler_builtins::int::mul::rust_i128_mul(move _6, const 3i128) -> bb5;\n+// ...\n+// _6 = const compiler_builtins::int::addsub::rust_i128_sub(move _7, const 2i128) -> bb6;\n+// ...\n+// _13 = Eq(const 5i128, const 0i128);\n+// assert(!move _13, \"attempt to calculate the remainder with a divisor of zero\") -> bb3;\n+// ...\n+// _17 = const 7i32 as u32 (Misc);\n+// _0 = const compiler_builtins::int::shift::rust_i128_shr(move _2, move _17) -> bb9;\n+// ...\n+// _18 = const 6i32 as u32 (Misc);\n+// _2 = const compiler_builtins::int::shift::rust_i128_shl(move _3, move _18) -> bb10;\n // END rustc.const_signed.Lower128Bit.after.mir\n \n // START rustc.const_unsigned.Lower128Bit.after.mir\n-//     _8 = _1;\n-//     _9 = const compiler_builtins::int::addsub::rust_u128_addo(move _8, const 1u128) -> bb8;\n-//     ...\n-//     _7 = move (_9.0: u128);\n-//     ...\n-//     _10 = const compiler_builtins::int::addsub::rust_u128_subo(move _7, const 2u128) -> bb9;\n-//     ...\n-//     _6 = move (_10.0: u128);\n-//     ...\n-//     _11 = const compiler_builtins::int::mul::rust_u128_mulo(move _6, const 3u128) -> bb10;\n-//     ...\n-//     _5 = move (_11.0: u128);\n-//     ...\n-//     _12 = Eq(const 4u128, const 0u128);\n-//     assert(!move _12, \"attempt to divide by zero\") -> bb4;\n-//     ...\n-//     _4 = const compiler_builtins::int::udiv::rust_u128_div(move _5, const 4u128) -> bb11;\n-//     ...\n-//     _3 = const compiler_builtins::int::udiv::rust_u128_rem(move _4, const 5u128) -> bb13;\n-//     ...\n-//     _2 = move (_14.0: u128);\n-//     ...\n-//     _17 = const 7i32 as u128 (Misc);\n-//     _15 = const compiler_builtins::int::shift::rust_u128_shro(move _2, move _17) -> bb14;\n-//     ...\n-//     _0 = move (_15.0: u128);\n-//     ...\n-//     assert(!move (_9.1: bool), \"attempt to add with overflow\") -> bb1;\n-//     ...\n-//     assert(!move (_10.1: bool), \"attempt to subtract with overflow\") -> bb2;\n-//     ...\n-//     assert(!move (_11.1: bool), \"attempt to multiply with overflow\") -> bb3;\n-//     ...\n-//     _13 = Eq(const 5u128, const 0u128);\n-//     assert(!move _13, \"attempt to calculate the remainder with a divisor of zero\") -> bb5;\n-//     ...\n-//     assert(!move (_14.1: bool), \"attempt to shift left with overflow\") -> bb6;\n-//     ...\n-//     _16 = const 6i32 as u128 (Misc);\n-//     _14 = const compiler_builtins::int::shift::rust_u128_shlo(move _3, move _16) -> bb12;\n-//     ...\n-//     assert(!move (_15.1: bool), \"attempt to shift right with overflow\") -> bb7;\n+// _8 = _1;\n+// _7 = const compiler_builtins::int::addsub::rust_u128_add(move _8, const 1u128) -> bb5;\n+// ...\n+// _4 = const compiler_builtins::int::udiv::rust_u128_div(move _5, const 4u128) -> bb6;\n+// ...\n+// _3 = const compiler_builtins::int::udiv::rust_u128_rem(move _4, const 5u128) -> bb9;\n+// ...\n+// _9 = Eq(const 4u128, const 0u128);\n+// assert(!move _9, \"attempt to divide by zero\") -> bb1;\n+// ...\n+// _5 = const compiler_builtins::int::mul::rust_u128_mul(move _6, const 3u128) -> bb3;\n+// ...\n+// _6 = const compiler_builtins::int::addsub::rust_u128_sub(move _7, const 2u128) -> bb4;\n+// ...\n+// _10 = Eq(const 5u128, const 0u128);\n+// assert(!move _10, \"attempt to calculate the remainder with a divisor of zero\") -> bb2;\n+// ...\n+// return;\n+// ...\n+// _11 = const 7i32 as u32 (Misc);\n+// _0 = const compiler_builtins::int::shift::rust_u128_shr(move _2, move _11) -> bb7;\n+// ...\n+// _12 = const 6i32 as u32 (Misc);\n+// _2 = const compiler_builtins::int::shift::rust_u128_shl(move _3, move _12) -> bb8;\n+\n // END rustc.const_unsigned.Lower128Bit.after.mir\n \n // START rustc.test_signed.Lower128Bit.after.mir"}, {"sha": "a18d82fb7a4e7e22c334fe85204ff5b500795ae7", "filename": "src/test/run-pass/invalid_const_promotion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Frun-pass%2Finvalid_const_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Frun-pass%2Finvalid_const_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvalid_const_promotion.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -11,6 +11,8 @@\n // ignore-wasm32\n // ignore-emscripten\n \n+// compile-flags: -C debug_assertions=yes\n+\n #![feature(const_fn, libc)]\n #![allow(const_err)]\n \n@@ -19,7 +21,7 @@ extern crate libc;\n use std::env;\n use std::process::{Command, Stdio};\n \n-// this will panic in debug mode\n+// this will panic in debug mode and overflow in release mode\n const fn bar() -> usize { 0 - 1 }\n \n fn foo() {"}, {"sha": "ab8b5792e681d58bb7e6c9af3193f77664c00252", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -4,14 +4,14 @@ note: ...which requires normalizing `ParamEnvAnd { param_env: ParamEnv { caller_\n note: ...which requires const-evaluating `Foo::bytes::{{constant}}`...\n   --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n-LL |     unsafe { intrinsics::size_of::<T>() }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires computing layout of `Foo`, completing the cycle\n note: cycle used when const-evaluating `Foo::bytes::{{constant}}`\n   --> $SRC_DIR/libcore/mem.rs:LL:COL\n    |\n-LL |     unsafe { intrinsics::size_of::<T>() }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b156e5a9731dad18faf8fb99da5da2b49d887f49", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,224 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:49:25\n+   |\n+LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be evaluated\n+   |                         ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:51:5\n+   |\n+LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:56:28\n+   |\n+LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be evaluated\n+   |                            ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:58:5\n+   |\n+LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:63:27\n+   |\n+LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n+   |                           ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:65:5\n+   |\n+LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:70:5\n+   |\n+LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:88:16\n+   |\n+LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n+   |                ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:90:18\n+   |\n+LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n+   |                  ^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:92:33\n+   |\n+LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n+   |                                 ^^^^^^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:94:35\n+   |\n+LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n+   |                                   ^^^^^^^\n+\n+error: only int and `bool` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:96:35\n+   |\n+LL | const fn foo19_3(f: f32) -> f32 { -f }\n+   |                                   ^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:98:43\n+   |\n+LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n+   |                                           ^^^^^\n+\n+error: cannot access `static` items in const fn\n+  --> $DIR/min_const_fn.rs:102:27\n+   |\n+LL | const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n+   |                           ^^^\n+\n+error: cannot access `static` items in const fn\n+  --> $DIR/min_const_fn.rs:103:36\n+   |\n+LL | const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n+   |                                    ^^^^\n+\n+error: casting pointers to ints is unstable in const fn\n+  --> $DIR/min_const_fn.rs:104:42\n+   |\n+LL | const fn foo30(x: *const u32) -> usize { x as usize }\n+   |                                          ^^^^^^^^^^\n+\n+error: casting pointers to ints is unstable in const fn\n+  --> $DIR/min_const_fn.rs:106:42\n+   |\n+LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n+   |                                          ^^^^^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:108:38\n+   |\n+LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:110:29\n+   |\n+LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n+   |                             ^^^^^^^^^^^\n+\n+error: local variables in const fn are unstable\n+  --> $DIR/min_const_fn.rs:111:34\n+   |\n+LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+   |                                  ^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:112:44\n+   |\n+LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n+   |                                            ^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:114:44\n+   |\n+LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n+   |                                            ^^^^^^\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:116:14\n+   |\n+LL | const fn inc(x: &mut i32) { *x += 1 }\n+   |              ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:121:6\n+   |\n+LL | impl<T: std::fmt::Debug> Foo<T> {\n+   |      ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:126:6\n+   |\n+LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n+   |      ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:131:6\n+   |\n+LL | impl<T: Sync + Sized> Foo<T> {\n+   |      ^\n+\n+error: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn.rs:137:1\n+   |\n+LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:139:34\n+   |\n+LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:141:22\n+   |\n+LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn.rs:142:1\n+   |\n+LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:143:23\n+   |\n+LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+   |                       ^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:144:1\n+   |\n+LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/min_const_fn.rs:144:64\n+   |\n+LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n+   |                                                                ^^ - temporary value only lives until here\n+   |                                                                |\n+   |                                                                temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:149:41\n+   |\n+LL | const fn really_no_traits_i_mean_it() { (&() as &std::fmt::Debug, ()).1 }\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn.rs:152:21\n+   |\n+LL | const fn no_fn_ptrs(_x: fn()) {}\n+   |                     ^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn.rs:154:1\n+   |\n+LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 36 previous errors\n+\n+Some errors occurred: E0493, E0597.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "b861e312d4245e4664ea6d12c1956927e3ee0269", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(min_const_fn)]\n+\n+// ok\n+const fn foo1() {}\n+const fn foo2(x: i32) -> i32 { x }\n+const fn foo3<T>(x: T) -> T { x }\n+const fn foo7() {\n+    (\n+        foo1(),\n+        foo2(420),\n+        foo3(69),\n+    ).0\n+}\n+const fn foo12<T: Sized>(t: T) -> T { t }\n+const fn foo13<T: ?Sized>(t: &T) -> &T { t }\n+const fn foo14<'a, T: 'a>(t: &'a T) -> &'a T { t }\n+const fn foo15<T>(t: T) -> T where T: Sized { t }\n+const fn foo15_2<T>(t: &T) -> &T where T: ?Sized { t }\n+const fn foo16(f: f32) -> f32 { f }\n+const fn foo17(f: f32) -> u32 { f as u32 }\n+const fn foo18(i: i32) -> i32 { i * 3 }\n+const fn foo20(b: bool) -> bool { !b }\n+const fn foo21<T, U>(t: T, u: U) -> (T, U) { (t, u) }\n+const fn foo22(s: &[u8], i: usize) -> u8 { s[i] }\n+const FOO: u32 = 42;\n+const fn foo23() -> u32 { FOO }\n+const fn foo24() -> &'static u32 { &FOO }\n+const fn foo27(x: &u32) -> u32 { *x }\n+const fn foo28(x: u32) -> u32 { *&x }\n+const fn foo29(x: u32) -> i32 { x as i32 }\n+const fn foo31(a: bool, b: bool) -> bool { a & b }\n+const fn foo32(a: bool, b: bool) -> bool { a | b }\n+const fn foo33(a: bool, b: bool) -> bool { a & b }\n+const fn foo34(a: bool, b: bool) -> bool { a | b }\n+const fn foo35(a: bool, b: bool) -> bool { a ^ b }\n+struct Foo<T: ?Sized>(T);\n+impl<T> Foo<T> {\n+    const fn new(t: T) -> Self { Foo(t) }\n+    const fn into_inner(self) -> T { self.0 } //~ destructors cannot be evaluated\n+    const fn get(&self) -> &T { &self.0 }\n+    const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n+    //~^ mutable references in const fn are unstable\n+}\n+impl<'a, T> Foo<T> {\n+    const fn new_lt(t: T) -> Self { Foo(t) }\n+    const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be evaluated\n+    const fn get_lt(&'a self) -> &T { &self.0 }\n+    const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n+    //~^ mutable references in const fn are unstable\n+}\n+impl<T: Sized> Foo<T> {\n+    const fn new_s(t: T) -> Self { Foo(t) }\n+    const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n+    const fn get_s(&self) -> &T { &self.0 }\n+    const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n+    //~^ mutable references in const fn are unstable\n+}\n+impl<T: ?Sized> Foo<T> {\n+    const fn get_sq(&self) -> &T { &self.0 }\n+    const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n+    //~^ mutable references in const fn are unstable\n+}\n+\n+\n+const fn char_ops(c: char, d: char) -> bool { c == d }\n+const fn char_ops2(c: char, d: char) -> bool { c < d }\n+const fn char_ops3(c: char, d: char) -> bool { c != d }\n+const fn i32_ops(c: i32, d: i32) -> bool { c == d }\n+const fn i32_ops2(c: i32, d: i32) -> bool { c < d }\n+const fn i32_ops3(c: i32, d: i32) -> bool { c != d }\n+const fn i32_ops4(c: i32, d: i32) -> i32 { c + d }\n+const fn char_cast(u: u8) -> char { u as char }\n+const unsafe fn foo4() -> i32 { 42 }\n+const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n+const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n+\n+// not ok\n+const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n+//~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n+const fn foo11_2<T: Send>(t: T) -> T { t }\n+//~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n+const fn foo19(f: f32) -> f32 { f * 2.0 }\n+//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n+//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+const fn foo19_3(f: f32) -> f32 { -f }\n+//~^ ERROR only int and `bool` operations are stable in const fn\n+const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n+//~^ ERROR only int, `bool` and `char` operations are stable in const fn\n+\n+static BAR: u32 = 42;\n+const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n+const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n+const fn foo30(x: *const u32) -> usize { x as usize }\n+//~^ ERROR casting pointers to int\n+const fn foo30_2(x: *mut u32) -> usize { x as usize }\n+//~^ ERROR casting pointers to int\n+const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n+//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n+const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+const fn foo36(a: bool, b: bool) -> bool { a && b }\n+//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+const fn foo37(a: bool, b: bool) -> bool { a || b }\n+//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+const fn inc(x: &mut i32) { *x += 1 }\n+//~^ ERROR mutable references in const fn are unstable\n+\n+fn main() {}\n+\n+impl<T: std::fmt::Debug> Foo<T> {\n+//~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n+    const fn foo(&self) {}\n+}\n+\n+impl<T: std::fmt::Debug + Sized> Foo<T> {\n+//~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n+    const fn foo2(&self) {}\n+}\n+\n+impl<T: Sync + Sized> Foo<T> {\n+//~^ ERROR trait bounds other than `Sized` on const fn parameters are unstable\n+    const fn foo3(&self) {}\n+}\n+\n+struct AlanTuring<T>(T);\n+const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n+//~^ ERROR `impl Trait` in const fn is unstable\n+const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n+//~^ ERROR trait bounds other than `Sized`\n+const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n+const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n+//~^ ERROR trait bounds other than `Sized`\n+\n+const fn no_unsafe() { unsafe {} }\n+\n+const fn really_no_traits_i_mean_it() { (&() as &std::fmt::Debug, ()).1 }\n+//~^ ERROR trait bounds other than `Sized`\n+\n+const fn no_fn_ptrs(_x: fn()) {}\n+//~^ ERROR function pointers in const fn are unstable\n+const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n+//~^ ERROR function pointers in const fn are unstable\n+"}, {"sha": "019948c31b15ca4b40d42470a2a70b44c5062b2e", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,213 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:49:25\n+   |\n+LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be evaluated\n+   |                         ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:51:5\n+   |\n+LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:56:28\n+   |\n+LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be evaluated\n+   |                            ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:58:5\n+   |\n+LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/min_const_fn.rs:63:27\n+   |\n+LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n+   |                           ^^^^ constant functions cannot evaluate destructors\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:65:5\n+   |\n+LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:70:5\n+   |\n+LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:88:16\n+   |\n+LL | const fn foo11<T: std::fmt::Display>(t: T) -> T { t }\n+   |                ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:90:18\n+   |\n+LL | const fn foo11_2<T: Send>(t: T) -> T { t }\n+   |                  ^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:92:33\n+   |\n+LL | const fn foo19(f: f32) -> f32 { f * 2.0 }\n+   |                                 ^^^^^^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:94:35\n+   |\n+LL | const fn foo19_2(f: f32) -> f32 { 2.0 - f }\n+   |                                   ^^^^^^^\n+\n+error: only int and `bool` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:96:35\n+   |\n+LL | const fn foo19_3(f: f32) -> f32 { -f }\n+   |                                   ^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn.rs:98:43\n+   |\n+LL | const fn foo19_4(f: f32, g: f32) -> f32 { f / g }\n+   |                                           ^^^^^\n+\n+error: cannot access `static` items in const fn\n+  --> $DIR/min_const_fn.rs:102:27\n+   |\n+LL | const fn foo25() -> u32 { BAR } //~ ERROR cannot access `static` items in const fn\n+   |                           ^^^\n+\n+error: cannot access `static` items in const fn\n+  --> $DIR/min_const_fn.rs:103:36\n+   |\n+LL | const fn foo26() -> &'static u32 { &BAR } //~ ERROR cannot access `static` items\n+   |                                    ^^^^\n+\n+error: casting pointers to ints is unstable in const fn\n+  --> $DIR/min_const_fn.rs:104:42\n+   |\n+LL | const fn foo30(x: *const u32) -> usize { x as usize }\n+   |                                          ^^^^^^^^^^\n+\n+error: casting pointers to ints is unstable in const fn\n+  --> $DIR/min_const_fn.rs:106:42\n+   |\n+LL | const fn foo30_2(x: *mut u32) -> usize { x as usize }\n+   |                                          ^^^^^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:108:38\n+   |\n+LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:110:29\n+   |\n+LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n+   |                             ^^^^^^^^^^^\n+\n+error: local variables in const fn are unstable\n+  --> $DIR/min_const_fn.rs:111:34\n+   |\n+LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+   |                                  ^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:112:44\n+   |\n+LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n+   |                                            ^^^^^^\n+\n+error: `if`, `match`, `&&` and `||` are not stable in const fn\n+  --> $DIR/min_const_fn.rs:114:44\n+   |\n+LL | const fn foo37(a: bool, b: bool) -> bool { a || b }\n+   |                                            ^^^^^^\n+\n+error: mutable references in const fn are unstable\n+  --> $DIR/min_const_fn.rs:116:14\n+   |\n+LL | const fn inc(x: &mut i32) { *x += 1 }\n+   |              ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:121:6\n+   |\n+LL | impl<T: std::fmt::Debug> Foo<T> {\n+   |      ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:126:6\n+   |\n+LL | impl<T: std::fmt::Debug + Sized> Foo<T> {\n+   |      ^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:131:6\n+   |\n+LL | impl<T: Sync + Sized> Foo<T> {\n+   |      ^\n+\n+error: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn.rs:137:1\n+   |\n+LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:139:34\n+   |\n+LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:141:22\n+   |\n+LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn.rs:142:1\n+   |\n+LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:143:23\n+   |\n+LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n+   |                       ^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:144:1\n+   |\n+LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn.rs:149:41\n+   |\n+LL | const fn really_no_traits_i_mean_it() { (&() as &std::fmt::Debug, ()).1 }\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn.rs:152:21\n+   |\n+LL | const fn no_fn_ptrs(_x: fn()) {}\n+   |                     ^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn.rs:154:1\n+   |\n+LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 35 previous errors\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "cfcc7990fb30db722c5242b0e13145421b6221ad", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.nll.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.nll.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,25 @@\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn_dyn.rs:21:5\n+   |\n+LL |     x.0.field;\n+   |     ^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn_dyn.rs:24:66\n+   |\n+LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n+   |                                                                  ^^\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/min_const_fn_dyn.rs:24:67\n+   |\n+LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n+   |                                                                   ^    - temporary value only lives until here\n+   |                                                                   |\n+   |                                                                   temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "38e2825643009aba926884ab2e0333624b6b53da", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(min_const_fn)]\n+\n+struct HasDyn {\n+    field: &'static dyn std::fmt::Debug,\n+}\n+\n+struct Hide(HasDyn);\n+\n+const fn no_inner_dyn_trait(_x: Hide) {}\n+const fn no_inner_dyn_trait2(x: Hide) {\n+    x.0.field;\n+//~^ ERROR trait bounds other than `Sized`\n+}\n+const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n+//~^ ERROR trait bounds other than `Sized`\n+\n+fn main() {}"}, {"sha": "3a1055f2ede1504ccd802e7ebfa2e91c461322c8", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,14 @@\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn_dyn.rs:21:5\n+   |\n+LL |     x.0.field;\n+   |     ^^^^^^^^^\n+\n+error: trait bounds other than `Sized` on const fn parameters are unstable\n+  --> $DIR/min_const_fn_dyn.rs:24:66\n+   |\n+LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n+   |                                                                  ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "100d275f97e732970f8c884338bf8cad8faa54d8", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_fn_ptr.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(min_const_fn)]\n+\n+struct HasPtr {\n+    field: fn(),\n+}\n+\n+struct Hide(HasPtr);\n+\n+fn field() {}\n+\n+const fn no_inner_dyn_trait(_x: Hide) {}\n+const fn no_inner_dyn_trait2(x: Hide) {\n+    x.0.field;\n+//~^ ERROR function pointers in const fn\n+}\n+const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasPtr { field }) }\n+//~^ ERROR function pointers in const fn\n+\n+fn main() {}"}, {"sha": "c10af3d2c8e71d4aa3755f500456e1ae56a2f749", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_fn_ptr.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_fn_ptr.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,14 @@\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn_fn_ptr.rs:23:5\n+   |\n+LL |     x.0.field;\n+   |     ^^^^^^^^^\n+\n+error: function pointers in const fn are unstable\n+  --> $DIR/min_const_fn_fn_ptr.rs:26:59\n+   |\n+LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasPtr { field }) }\n+   |                                                           ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4ce62ecc485335980db3c577130444dbf8738e4e", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"humans\",\n+            reason = \"who ever let humans program computers,\n+            we're apparently really bad at it\",\n+            issue = \"0\")]\n+\n+#![feature(rustc_const_unstable, const_fn, foo)]\n+#![feature(staged_api)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature=\"foo\")]\n+const fn foo() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+\n+#[unstable(feature = \"rust1\", issue=\"0\")]\n+const fn foo2() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// conformity is required, even with `const_fn` feature gate\n+const fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` operations\n+\n+fn main() {}"}, {"sha": "8e47090890db35f4f655b72eb6eec1c85267021a", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,20 @@\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_fn_libstd_stability.rs:25:25\n+   |\n+LL | const fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+   |                         ^^^^^\n+\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_fn_libstd_stability.rs:32:26\n+   |\n+LL | const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+   |                          ^^^^^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_fn_libstd_stability.rs:36:26\n+   |\n+LL | const fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` operations\n+   |                          ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e7caa4c6cb4263d801f6fd0868f9434e55cb8302", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(min_const_fn)]\n+\n+// ok\n+const unsafe fn foo4() -> i32 { 42 }\n+const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n+const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n+const fn no_unsafe() { unsafe {} }\n+\n+// not ok\n+const fn foo8() -> i32 {\n+    unsafe { foo4() } //~ ERROR unsafe operations are not allowed in const fn\n+}\n+const fn foo9() -> *const String {\n+    unsafe { foo5::<String>() } //~ ERROR unsafe operations are not allowed in const fn\n+}\n+const fn foo10() -> *const Vec<std::cell::Cell<u32>> {\n+    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() } //~ ERROR not allowed in const fn\n+}\n+const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+//~^ dereferencing raw pointers in constant functions\n+\n+fn main() {}\n+\n+const unsafe fn no_union() {\n+    union Foo { x: (), y: () }\n+    Foo { x: () }.y //~ ERROR not allowed in const fn\n+    //~^ unions in const fn\n+}"}, {"sha": "17cba8569c148f8d7cd9bfeedd288c951924fa42", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,59 @@\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe.rs:29:51\n+   |\n+LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                   ^^\n+   |\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n+\n+error[E0658]: unions in const fn are unstable (see issue #51909)\n+  --> $DIR/min_const_fn_unsafe.rs:36:5\n+   |\n+LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn_union)] to the crate attributes to enable\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe.rs:21:14\n+   |\n+LL |     unsafe { foo4() } //~ ERROR unsafe operations are not allowed in const fn\n+   |              ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe.rs:24:14\n+   |\n+LL |     unsafe { foo5::<String>() } //~ ERROR unsafe operations are not allowed in const fn\n+   |              ^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe.rs:27:14\n+   |\n+LL |     unsafe { foo6::<Vec<std::cell::Cell<u32>>>() } //~ ERROR not allowed in const fn\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe.rs:29:51\n+   |\n+LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                   ^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: access to union field is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe.rs:36:5\n+   |\n+LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "438dd50f2bfa80aaca4ed97b47cf152bed233132", "filename": "src/test/ui/error-codes/E0308.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ferror-codes%2FE0308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ferror-codes%2FE0308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -4,8 +4,8 @@ error[E0308]: intrinsic has wrong type\n LL |     fn size_of<T>(); //~ ERROR E0308\n    |     ^^^^^^^^^^^^^^^^ expected (), found usize\n    |\n-   = note: expected type `unsafe extern \"rust-intrinsic\" fn()`\n-              found type `unsafe extern \"rust-intrinsic\" fn() -> usize`\n+   = note: expected type `extern \"rust-intrinsic\" fn()`\n+              found type `extern \"rust-intrinsic\" fn() -> usize`\n \n error: aborting due to previous error\n "}, {"sha": "f774658975b79d983021d8ee80f4c430704a83a2", "filename": "src/test/ui/feature-gates/feature-gate-const_fn.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test use of const fn without feature gate.\n+// Test use of const fn without the `const_fn` feature gate.\n+// `min_const_fn` is checked in its own file\n+#![feature(min_const_fn)]\n \n-const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n+const fn foo() -> usize { 0 } // ok\n \n trait Foo {\n     const fn foo() -> u32; //~ ERROR const fn is unstable\n@@ -20,12 +22,11 @@ trait Foo {\n }\n \n impl Foo {\n-    const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n+    const fn baz() -> u32 { 0 } // ok\n }\n \n impl Foo for u32 {\n-    const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n-                                //~| ERROR trait fns cannot be declared const\n+    const fn foo() -> u32 { 0 } //~ ERROR trait fns cannot be declared const\n }\n \n static FOO: usize = foo();"}, {"sha": "26c0c7877b4ecc6f51b03b1531e65a720dced564", "filename": "src/test/ui/feature-gates/feature-gate-const_fn.stderr", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -1,62 +1,38 @@\n error[E0379]: trait fns cannot be declared const\n-  --> $DIR/feature-gate-const_fn.rs:16:5\n+  --> $DIR/feature-gate-const_fn.rs:18:5\n    |\n LL |     const fn foo() -> u32; //~ ERROR const fn is unstable\n    |     ^^^^^ trait fns cannot be const\n \n error[E0379]: trait fns cannot be declared const\n-  --> $DIR/feature-gate-const_fn.rs:18:5\n+  --> $DIR/feature-gate-const_fn.rs:20:5\n    |\n LL |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n    |     ^^^^^ trait fns cannot be const\n \n error[E0379]: trait fns cannot be declared const\n-  --> $DIR/feature-gate-const_fn.rs:27:5\n+  --> $DIR/feature-gate-const_fn.rs:29:5\n    |\n-LL |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+LL |     const fn foo() -> u32 { 0 } //~ ERROR trait fns cannot be declared const\n    |     ^^^^^ trait fns cannot be const\n \n error[E0658]: const fn is unstable (see issue #24111)\n-  --> $DIR/feature-gate-const_fn.rs:13:1\n-   |\n-LL | const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n-\n-error[E0658]: const fn is unstable (see issue #24111)\n-  --> $DIR/feature-gate-const_fn.rs:16:5\n+  --> $DIR/feature-gate-const_fn.rs:18:5\n    |\n LL |     const fn foo() -> u32; //~ ERROR const fn is unstable\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n error[E0658]: const fn is unstable (see issue #24111)\n-  --> $DIR/feature-gate-const_fn.rs:18:5\n+  --> $DIR/feature-gate-const_fn.rs:20:5\n    |\n LL |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0658]: const fn is unstable (see issue #24111)\n-  --> $DIR/feature-gate-const_fn.rs:23:5\n-   |\n-LL |     const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n-\n-error[E0658]: const fn is unstable (see issue #24111)\n-  --> $DIR/feature-gate-const_fn.rs:27:5\n-   |\n-LL |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(const_fn)] to the crate attributes to enable\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors occurred: E0379, E0658.\n For more information about an error, try `rustc --explain E0379`."}, {"sha": "e052ba9c8b43a6846c13d8d172b17ed358dfc3ed", "filename": "src/test/ui/feature-gates/feature-gate-min_const_fn.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.rs?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test use of min_const_fn without feature gate.\n+\n+const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n+\n+trait Foo {\n+    const fn foo() -> u32; //~ ERROR const fn is unstable\n+                           //~| ERROR trait fns cannot be declared const\n+    const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+                                //~| ERROR trait fns cannot be declared const\n+}\n+\n+impl Foo {\n+    const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n+}\n+\n+impl Foo for u32 {\n+    const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+                                //~| ERROR trait fns cannot be declared const\n+}\n+\n+static FOO: usize = foo();\n+const BAR: usize = foo();\n+\n+macro_rules! constant {\n+    ($n:ident: $t:ty = $v:expr) => {\n+        const $n: $t = $v;\n+    }\n+}\n+\n+constant! {\n+    BAZ: usize = foo()\n+}\n+\n+fn main() {\n+    let x: [usize; foo()] = [];\n+}"}, {"sha": "aa7750362b2fd363d89c113eff5575d66a7a5058", "filename": "src/test/ui/feature-gates/feature-gate-min_const_fn.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/472ca7159812f8c360697f63454ee7bda1e02570/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-min_const_fn.stderr?ref=472ca7159812f8c360697f63454ee7bda1e02570", "patch": "@@ -0,0 +1,62 @@\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-min_const_fn.rs:16:5\n+   |\n+LL |     const fn foo() -> u32; //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-min_const_fn.rs:18:5\n+   |\n+LL |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/feature-gate-min_const_fn.rs:27:5\n+   |\n+LL |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^ trait fns cannot be const\n+\n+error[E0658]: const fn is unstable (see issue #53555)\n+  --> $DIR/feature-gate-min_const_fn.rs:13:1\n+   |\n+LL | const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(min_const_fn)] to the crate attributes to enable\n+\n+error[E0658]: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-min_const_fn.rs:16:5\n+   |\n+LL |     const fn foo() -> u32; //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error[E0658]: const fn is unstable (see issue #24111)\n+  --> $DIR/feature-gate-min_const_fn.rs:18:5\n+   |\n+LL |     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error[E0658]: const fn is unstable (see issue #53555)\n+  --> $DIR/feature-gate-min_const_fn.rs:23:5\n+   |\n+LL |     const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(min_const_fn)] to the crate attributes to enable\n+\n+error[E0658]: const fn is unstable (see issue #53555)\n+  --> $DIR/feature-gate-min_const_fn.rs:27:5\n+   |\n+LL |     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(min_const_fn)] to the crate attributes to enable\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors occurred: E0379, E0658.\n+For more information about an error, try `rustc --explain E0379`."}]}