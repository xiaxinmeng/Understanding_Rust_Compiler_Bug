{"sha": "cfe81559ee970b99e45a73af02ba4837cb30b6db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZTgxNTU5ZWU5NzBiOTllNDVhNzNhZjAyYmE0ODM3Y2IzMGI2ZGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-11T14:35:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:57:01Z"}, "message": "resolve: Recover \"did you mean\" suggestions in imports", "tree": {"sha": "b7bf70150dea1b4cd2ec5203bf11598b25eb2c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7bf70150dea1b4cd2ec5203bf11598b25eb2c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfe81559ee970b99e45a73af02ba4837cb30b6db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe81559ee970b99e45a73af02ba4837cb30b6db", "html_url": "https://github.com/rust-lang/rust/commit/cfe81559ee970b99e45a73af02ba4837cb30b6db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfe81559ee970b99e45a73af02ba4837cb30b6db/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5d822a8ba8b11c653f48da73c0e281f7245bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5d822a8ba8b11c653f48da73c0e281f7245bea", "html_url": "https://github.com/rust-lang/rust/commit/4c5d822a8ba8b11c653f48da73c0e281f7245bea"}], "stats": {"total": 86, "additions": 36, "deletions": 50}, "files": [{"sha": "5bfa57468153d17cb0a1dc32b6b88db4814cc114", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=cfe81559ee970b99e45a73af02ba4837cb30b6db", "patch": "@@ -11,46 +11,40 @@\n use {CrateLint, PathResult, Segment};\n use macros::ParentScope;\n \n-use std::collections::BTreeSet;\n-\n use syntax::ast::Ident;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use resolve_imports::ImportResolver;\n+use std::cmp::Reverse;\n \n impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// Add suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Segment>,\n+        mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n-        // If we don't have a path to suggest changes to, then return.\n-        if path.is_empty() {\n-            return None;\n-        }\n-\n-        // Check whether a ident is a path segment that is not root.\n-        let is_special = |ident: Ident| ident.is_path_segment_keyword() &&\n-                                        ident.name != keywords::CrateRoot.name();\n \n         match (path.get(0), path.get(1)) {\n-            // Make suggestions that require at least two non-special path segments.\n-            (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n-                debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n-\n-                self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n-                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone(),\n-                                                                   parent_scope))\n-                    .or_else(|| self.make_missing_super_suggestion(span, path.clone(),\n-                                                                   parent_scope))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n-            },\n-            _ => None,\n+            // `{{root}}::ident::...` on both editions.\n+            // On 2015 `{{root}}` is usually added implicitly.\n+            (Some(fst), Some(snd)) if fst.name == keywords::CrateRoot.name() &&\n+                                      !snd.is_path_segment_keyword() => {}\n+            // `ident::...` on 2018\n+            (Some(fst), _) if self.session.rust_2018() && !fst.is_path_segment_keyword() => {\n+                // Insert a placeholder that's later replaced by `self`/`super`/etc.\n+                path.insert(0, keywords::Invalid.ident());\n+            }\n+            _ => return None,\n         }\n+\n+        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n+            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n     }\n \n     /// Suggest a missing `self::` if that resolves to an correct module.\n@@ -148,22 +142,20 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n-        // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n-        // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n-        // each time.\n-        let external_crate_names: BTreeSet<Symbol> = self.resolver.extern_prelude\n-            .iter().map(|(ident, _)| ident.name).collect();\n+        if !self.session.rust_2018() {\n+            return None;\n+        }\n \n-        // Insert a new path segment that we can replace.\n-        let new_path_segment = path[0].clone();\n-        path.insert(1, new_path_segment);\n+        // Sort extern crate names in reverse order to get\n+        // 1) some consistent ordering for emitted dignostics and\n+        // 2) `std` suggestions before `core` suggestions.\n+        let mut extern_crate_names =\n+            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+        extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n \n-        // Iterate in reverse so that we start with crates at the end of the alphabet. This means\n-        // that we'll always get `std` before `core`.\n-        for name in external_crate_names.iter().rev() {\n-            // Replace the first after root (a placeholder we inserted) with a crate name\n-            // and check if that is valid.\n-            path[1].ident.name = *name;\n+        for name in extern_crate_names.into_iter() {\n+            // Replace first ident with a crate name and check if that is valid.\n+            path[0].ident.name = name;\n             let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);"}, {"sha": "a24f92fdc6d65b3e5f6ba448aa17336bed540b2a", "filename": "src/test/ui/resolve_self_super_hint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.rs?ref=cfe81559ee970b99e45a73af02ba4837cb30b6db", "patch": "@@ -23,11 +23,11 @@ mod a {\n         mod c {\n             use alloc::HashMap;\n             //~^ ERROR unresolved import `alloc` [E0432]\n-            //~| Did you mean `std::alloc`?\n+            //~| Did you mean `a::alloc`?\n             mod d {\n                 use alloc::HashMap;\n                 //~^ ERROR unresolved import `alloc` [E0432]\n-                //~| Did you mean `std::alloc`?\n+                //~| Did you mean `a::alloc`?\n             }\n         }\n     }"}, {"sha": "924788bdaabfe5de05051474393ed7a4d5cd2658", "filename": "src/test/ui/resolve_self_super_hint.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve_self_super_hint.stderr?ref=cfe81559ee970b99e45a73af02ba4837cb30b6db", "patch": "@@ -14,13 +14,13 @@ error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:24:17\n    |\n LL |             use alloc::HashMap;\n-   |                 ^^^^^ Did you mean `std::alloc`?\n+   |                 ^^^^^ Did you mean `a::alloc`?\n \n error[E0432]: unresolved import `alloc`\n   --> $DIR/resolve_self_super_hint.rs:28:21\n    |\n LL |                 use alloc::HashMap;\n-   |                     ^^^^^ Did you mean `std::alloc`?\n+   |                     ^^^^^ Did you mean `a::alloc`?\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2a673bdbad20648337689fafe69f44d1c748359c", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.rs?ref=cfe81559ee970b99e45a73af02ba4837cb30b6db", "patch": "@@ -16,7 +16,7 @@ mod foo {\n     pub type Bar = u32;\n }\n \n-mod baz {\n+mod bazz {\n     use foo::Bar;\n \n     fn baz() {"}, {"sha": "b8a786bcbb48569b918f4fcb0d8e6f791d61ee4f", "filename": "src/test/ui/rust-2018/local-path-suggestions-2018.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfe81559ee970b99e45a73af02ba4837cb30b6db/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Flocal-path-suggestions-2018.stderr?ref=cfe81559ee970b99e45a73af02ba4837cb30b6db", "patch": "@@ -6,18 +6,12 @@ LL |     use foo::Bar;\n    |\n    = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>\n \n-error[E0432]: unresolved import `foo`\n-  --> $DIR/local-path-suggestions-2018.rs:27:5\n-   |\n-LL | use foo::Bar;\n-   |     ^^^ Did you mean `self::foo`?\n-\n error[E0432]: unresolved import `foobar`\n   --> $DIR/local-path-suggestions-2018.rs:29:5\n    |\n LL | use foobar::Baz;\n    |     ^^^^^^ Did you mean `baz::foobar`?\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0432`."}]}