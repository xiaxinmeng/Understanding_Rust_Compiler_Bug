{"sha": "7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOGU2ZGQzYmZkZWMwYjBhNmY0N2IxMDk2NjY3M2Y4OGE5MjQyZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-11T11:23:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-11T11:23:49Z"}, "message": "Auto merge of #34211 - srinivasreddy:rf_libstd_coll, r=brson\n\nrun rustfmt on libstd/collections/hash folder", "tree": {"sha": "81517f68dddca5cb18600a239695a8736d03f1be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81517f68dddca5cb18600a239695a8736d03f1be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5", "html_url": "https://github.com/rust-lang/rust/commit/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "682abf79afa40ba17eb6dfe47f944544c966839c", "url": "https://api.github.com/repos/rust-lang/rust/commits/682abf79afa40ba17eb6dfe47f944544c966839c", "html_url": "https://github.com/rust-lang/rust/commit/682abf79afa40ba17eb6dfe47f944544c966839c"}, {"sha": "bb19d1dc2ec5f0862c32003b60d2a3d49aed0e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb19d1dc2ec5f0862c32003b60d2a3d49aed0e84", "html_url": "https://github.com/rust-lang/rust/commit/bb19d1dc2ec5f0862c32003b60d2a3d49aed0e84"}], "stats": {"total": 345, "additions": 178, "deletions": 167}, "files": [{"sha": "c4c4cb453134f5e6fc15a58a12068041de7c7931", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 178, "deletions": 167, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=7d8e6dd3bfdec0b0a6f47b10966673f88a9242f5", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{allocate, deallocate, EMPTY};\n+use alloc::heap::{EMPTY, allocate, deallocate};\n \n use cmp;\n-use hash::{Hash, Hasher, BuildHasher};\n+use hash::{BuildHasher, Hash, Hasher};\n use intrinsics::needs_drop;\n use marker;\n use mem::{align_of, size_of};\n@@ -62,12 +62,12 @@ const EMPTY_BUCKET: u64 = 0;\n #[unsafe_no_drop_flag]\n pub struct RawTable<K, V> {\n     capacity: usize,\n-    size:     usize,\n-    hashes:   Unique<u64>,\n+    size: usize,\n+    hashes: Unique<u64>,\n \n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n-    marker:   marker::PhantomData<(K,V)>,\n+    marker: marker::PhantomData<(K, V)>,\n }\n \n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n@@ -77,44 +77,48 @@ struct RawBucket<K, V> {\n     hash: *mut u64,\n \n     // We use *const to ensure covariance with respect to K and V\n-    key:  *const K,\n-    val:  *const V,\n-    _marker: marker::PhantomData<(K,V)>,\n+    key: *const K,\n+    val: *const V,\n+    _marker: marker::PhantomData<(K, V)>,\n }\n \n-impl<K,V> Copy for RawBucket<K,V> {}\n-impl<K,V> Clone for RawBucket<K,V> {\n-    fn clone(&self) -> RawBucket<K, V> { *self }\n+impl<K, V> Copy for RawBucket<K, V> {}\n+impl<K, V> Clone for RawBucket<K, V> {\n+    fn clone(&self) -> RawBucket<K, V> {\n+        *self\n+    }\n }\n \n pub struct Bucket<K, V, M> {\n-    raw:   RawBucket<K, V>,\n-    idx:   usize,\n-    table: M\n+    raw: RawBucket<K, V>,\n+    idx: usize,\n+    table: M,\n }\n \n-impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}\n-impl<K,V,M:Copy> Clone for Bucket<K,V,M> {\n-    fn clone(&self) -> Bucket<K,V,M> { *self }\n+impl<K, V, M: Copy> Copy for Bucket<K, V, M> {}\n+impl<K, V, M: Copy> Clone for Bucket<K, V, M> {\n+    fn clone(&self) -> Bucket<K, V, M> {\n+        *self\n+    }\n }\n \n pub struct EmptyBucket<K, V, M> {\n-    raw:   RawBucket<K, V>,\n-    idx:   usize,\n-    table: M\n+    raw: RawBucket<K, V>,\n+    idx: usize,\n+    table: M,\n }\n \n pub struct FullBucket<K, V, M> {\n-    raw:   RawBucket<K, V>,\n-    idx:   usize,\n-    table: M\n+    raw: RawBucket<K, V>,\n+    idx: usize,\n+    table: M,\n }\n \n pub type EmptyBucketImm<'table, K, V> = EmptyBucket<K, V, &'table RawTable<K, V>>;\n-pub type  FullBucketImm<'table, K, V> =  FullBucket<K, V, &'table RawTable<K, V>>;\n+pub type FullBucketImm<'table, K, V> = FullBucket<K, V, &'table RawTable<K, V>>;\n \n pub type EmptyBucketMut<'table, K, V> = EmptyBucket<K, V, &'table mut RawTable<K, V>>;\n-pub type  FullBucketMut<'table, K, V> =  FullBucket<K, V, &'table mut RawTable<K, V>>;\n+pub type FullBucketMut<'table, K, V> = FullBucket<K, V, &'table mut RawTable<K, V>>;\n \n pub enum BucketState<K, V, M> {\n     Empty(EmptyBucket<K, V, M>),\n@@ -139,14 +143,17 @@ pub struct SafeHash {\n impl SafeHash {\n     /// Peek at the hash value, which is guaranteed to be non-zero.\n     #[inline(always)]\n-    pub fn inspect(&self) -> u64 { self.hash }\n+    pub fn inspect(&self) -> u64 {\n+        self.hash\n+    }\n }\n \n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n-    where T: Hash, S: BuildHasher\n+    where T: Hash,\n+          S: BuildHasher\n {\n     let mut state = hash_state.build_hasher();\n     t.hash(&mut state);\n@@ -175,8 +182,8 @@ impl<K, V> RawBucket<K, V> {\n     unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n         RawBucket {\n             hash: self.hash.offset(count),\n-            key:  self.key.offset(count),\n-            val:  self.val.offset(count),\n+            key: self.key.offset(count),\n+            val: self.val.offset(count),\n             _marker: marker::PhantomData,\n         }\n     }\n@@ -212,7 +219,9 @@ impl<K, V, M> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M> Deref for FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n+impl<K, V, M> Deref for FullBucket<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>\n+{\n     type Target = RawTable<K, V>;\n     fn deref(&self) -> &RawTable<K, V> {\n         &self.table\n@@ -232,42 +241,45 @@ impl<'t, K, V> Put<K, V> for &'t mut RawTable<K, V> {\n     }\n }\n \n-impl<K, V, M> Put<K, V> for Bucket<K, V, M> where M: Put<K, V> {\n+impl<K, V, M> Put<K, V> for Bucket<K, V, M>\n+    where M: Put<K, V>\n+{\n     unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n         self.table.borrow_table_mut()\n     }\n }\n \n-impl<K, V, M> Put<K, V> for FullBucket<K, V, M> where M: Put<K, V> {\n+impl<K, V, M> Put<K, V> for FullBucket<K, V, M>\n+    where M: Put<K, V>\n+{\n     unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n         self.table.borrow_table_mut()\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n+impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n         // This is an uncommon case though, so avoid it in release builds.\n-        debug_assert!(table.capacity() > 0, \"Table should have capacity at this point\");\n+        debug_assert!(table.capacity() > 0,\n+                      \"Table should have capacity at this point\");\n         let ib_index = ib_index & (table.capacity() - 1);\n         Bucket {\n-            raw: unsafe {\n-               table.first_bucket_raw().offset(ib_index as isize)\n-            },\n+            raw: unsafe { table.first_bucket_raw().offset(ib_index as isize) },\n             idx: ib_index,\n-            table: table\n+            table: table,\n         }\n     }\n \n     pub fn first(table: M) -> Bucket<K, V, M> {\n         Bucket {\n             raw: table.first_bucket_raw(),\n             idx: 0,\n-            table: table\n+            table: table,\n         }\n     }\n \n@@ -277,18 +289,20 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     /// this module.\n     pub fn peek(self) -> BucketState<K, V, M> {\n         match unsafe { *self.raw.hash } {\n-            EMPTY_BUCKET =>\n+            EMPTY_BUCKET => {\n                 Empty(EmptyBucket {\n                     raw: self.raw,\n                     idx: self.idx,\n-                    table: self.table\n-                }),\n-            _ =>\n+                    table: self.table,\n+                })\n+            }\n+            _ => {\n                 Full(FullBucket {\n                     raw: self.raw,\n                     idx: self.idx,\n-                    table: self.table\n+                    table: self.table,\n                 })\n+            }\n         }\n     }\n \n@@ -308,7 +322,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n+impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -321,39 +335,40 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n             idx: self.idx,\n-            table: self.table\n+            table: self.table,\n         }\n     }\n \n     pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> {\n         let gap = EmptyBucket {\n             raw: self.raw,\n             idx: self.idx,\n-            table: ()\n+            table: (),\n         };\n \n         match self.next().peek() {\n             Full(bucket) => {\n                 Some(GapThenFull {\n                     gap: gap,\n-                    full: bucket\n+                    full: bucket,\n                 })\n             }\n-            Empty(..) => None\n+            Empty(..) => None,\n         }\n     }\n }\n \n-impl<K, V, M> EmptyBucket<K, V, M> where M: Put<K, V> {\n+impl<K, V, M> EmptyBucket<K, V, M>\n+    where M: Put<K, V>\n+{\n     /// Puts given key and value pair, along with the key's hash,\n     /// into this bucket in the hashtable. Note how `self` is 'moved' into\n     /// this function, because this slot will no longer be empty when\n     /// we return! A `FullBucket` is returned for later use, pointing to\n     /// the newly-filled slot in the hashtable.\n     ///\n     /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n-    pub fn put(mut self, hash: SafeHash, key: K, value: V)\n-               -> FullBucket<K, V, M> {\n+    pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n             *self.raw.hash = hash.inspect();\n             ptr::write(self.raw.key as *mut K, key);\n@@ -362,11 +377,15 @@ impl<K, V, M> EmptyBucket<K, V, M> where M: Put<K, V> {\n             self.table.borrow_table_mut().size += 1;\n         }\n \n-        FullBucket { raw: self.raw, idx: self.idx, table: self.table }\n+        FullBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self.table,\n+        }\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n+impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     #[inline]\n     pub fn next(self) -> Bucket<K, V, M> {\n         let mut bucket = self.into_bucket();\n@@ -379,7 +398,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n             idx: self.idx,\n-            table: self.table\n+            table: self.table,\n         }\n     }\n \n@@ -407,19 +426,12 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n \n     #[inline]\n     pub fn hash(&self) -> SafeHash {\n-        unsafe {\n-            SafeHash {\n-                hash: *self.raw.hash\n-            }\n-        }\n+        unsafe { SafeHash { hash: *self.raw.hash } }\n     }\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe {\n-            (&*self.raw.key,\n-             &*self.raw.val)\n-        }\n+        unsafe { (&*self.raw.key, &*self.raw.val) }\n     }\n }\n \n@@ -436,69 +448,68 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n \n         unsafe {\n             *self.raw.hash = EMPTY_BUCKET;\n-            (\n-                EmptyBucket {\n-                    raw: self.raw,\n-                    idx: self.idx,\n-                    table: self.table\n-                },\n-                ptr::read(self.raw.key),\n-                ptr::read(self.raw.val)\n-            )\n+            (EmptyBucket {\n+                raw: self.raw,\n+                idx: self.idx,\n+                table: self.table,\n+            },\n+             ptr::read(self.raw.key),\n+             ptr::read(self.raw.val))\n         }\n     }\n }\n \n // This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases\n // where `M` is a full bucket or table reference type with mutable access to the table.\n-impl<K, V, M> FullBucket<K, V, M> where M: Put<K, V> {\n+impl<K, V, M> FullBucket<K, V, M>\n+    where M: Put<K, V>\n+{\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let old_key  = ptr::replace(self.raw.key as *mut K,  k);\n-            let old_val  = ptr::replace(self.raw.val as *mut V,  v);\n+            let old_key = ptr::replace(self.raw.key as *mut K, k);\n+            let old_val = ptr::replace(self.raw.val as *mut V, v);\n \n             (old_hash, old_key, old_val)\n         }\n     }\n }\n \n-impl<K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut {\n+impl<K, V, M> FullBucket<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>> + DerefMut\n+{\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        unsafe {\n-            (&mut *(self.raw.key as *mut K),\n-             &mut *(self.raw.val as *mut V))\n-        }\n+        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n     }\n }\n \n-impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + 't {\n+impl<'t, K, V, M> FullBucket<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>> + 't\n+{\n     /// Exchange a bucket state for immutable references into the table.\n     /// Because the underlying reference to the table is also consumed,\n     /// no further changes to the structure of the table are possible;\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe {\n-            (&*self.raw.key,\n-             &*self.raw.val)\n-        }\n+        unsafe { (&*self.raw.key, &*self.raw.val) }\n     }\n }\n \n-impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut + 't {\n+impl<'t, K, V, M> FullBucket<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>> + DerefMut + 't\n+{\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        unsafe {\n-            (&mut *(self.raw.key as *mut K),\n-             &mut *(self.raw.val as *mut V))\n-        }\n+        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n     }\n }\n \n-impl<K, V, M> GapThenFull<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n+impl<K, V, M> GapThenFull<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>\n+{\n     #[inline]\n     pub fn full(&self) -> &FullBucket<K, V, M> {\n         &self.full\n@@ -522,7 +533,7 @@ impl<K, V, M> GapThenFull<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n \n                 Some(self)\n             }\n-            Empty(..) => None\n+            Empty(..) => None,\n         }\n     }\n }\n@@ -554,7 +565,8 @@ fn test_rounding() {\n // from the start of a mallocated array.\n #[inline]\n fn calculate_offsets(hashes_size: usize,\n-                     keys_size: usize, keys_align: usize,\n+                     keys_size: usize,\n+                     keys_align: usize,\n                      vals_align: usize)\n                      -> (usize, usize, bool) {\n     let keys_offset = round_up_to_next(hashes_size, keys_align);\n@@ -567,14 +579,15 @@ fn calculate_offsets(hashes_size: usize,\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n-fn calculate_allocation(hash_size: usize, hash_align: usize,\n-                        keys_size: usize, keys_align: usize,\n-                        vals_size: usize, vals_align: usize)\n+fn calculate_allocation(hash_size: usize,\n+                        hash_align: usize,\n+                        keys_size: usize,\n+                        keys_align: usize,\n+                        vals_size: usize,\n+                        vals_align: usize)\n                         -> (usize, usize, usize, bool) {\n     let hash_offset = 0;\n-    let (_, vals_offset, oflo) = calculate_offsets(hash_size,\n-                                                   keys_size, keys_align,\n-                                                              vals_align);\n+    let (_, vals_offset, oflo) = calculate_offsets(hash_size, keys_size, keys_align, vals_align);\n     let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n \n     let align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n@@ -584,12 +597,13 @@ fn calculate_allocation(hash_size: usize, hash_align: usize,\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148, false));\n-    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6, false));\n-    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48, false));\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4),\n+               (8, 0, 148, false));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 0, 6, false));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 0, 48, false));\n     assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144, false));\n-    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5, false));\n-    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24, false));\n+    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5, false));\n+    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24, false));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -608,8 +622,8 @@ impl<K, V> RawTable<K, V> {\n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n         let hashes_size = capacity * size_of::<u64>();\n-        let keys_size   = capacity * size_of::< K >();\n-        let vals_size   = capacity * size_of::< V >();\n+        let keys_size = capacity * size_of::<K>();\n+        let vals_size = capacity * size_of::<V>();\n \n         // Allocating hashmaps is a little tricky. We need to allocate three\n         // arrays, but since we know their sizes and alignments up front,\n@@ -619,31 +633,38 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, size, oflo) =\n-            calculate_allocation(\n-                hashes_size, align_of::<u64>(),\n-                keys_size,   align_of::< K >(),\n-                vals_size,   align_of::< V >());\n+        let (malloc_alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n+                                                                               align_of::<u64>(),\n+                                                                               keys_size,\n+                                                                               align_of::<K>(),\n+                                                                               vals_size,\n+                                                                               align_of::<V>());\n \n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>().checked_add(size_of::<K>()).unwrap()\n-                                             .checked_add(size_of::<V>()).unwrap();\n-        assert!(size >= capacity.checked_mul(size_of_bucket)\n-                                .expect(\"capacity overflow\"),\n+        let size_of_bucket = size_of::<u64>()\n+                                 .checked_add(size_of::<K>())\n+                                 .unwrap()\n+                                 .checked_add(size_of::<V>())\n+                                 .unwrap();\n+        assert!(size >=\n+                capacity.checked_mul(size_of_bucket)\n+                        .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n         let buffer = allocate(size, malloc_alignment);\n-        if buffer.is_null() { ::alloc::oom() }\n+        if buffer.is_null() {\n+            ::alloc::oom()\n+        }\n \n         let hashes = buffer.offset(hash_offset as isize) as *mut u64;\n \n         RawTable {\n             capacity: capacity,\n-            size:     0,\n-            hashes:   Unique::new(hashes),\n-            marker:   marker::PhantomData,\n+            size: 0,\n+            hashes: Unique::new(hashes),\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -652,16 +673,16 @@ impl<K, V> RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n \n         let buffer = *self.hashes as *const u8;\n-        let (keys_offset, vals_offset, oflo) =\n-            calculate_offsets(hashes_size,\n-                              keys_size, align_of::<K>(),\n-                              align_of::<V>());\n+        let (keys_offset, vals_offset, oflo) = calculate_offsets(hashes_size,\n+                                                                 keys_size,\n+                                                                 align_of::<K>(),\n+                                                                 align_of::<V>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n-                key:  buffer.offset(keys_offset as isize) as *const K,\n-                val:  buffer.offset(vals_offset as isize) as *const V,\n+                key: buffer.offset(keys_offset as isize) as *const K,\n+                val: buffer.offset(vals_offset as isize) as *const V,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -691,9 +712,7 @@ impl<K, V> RawTable<K, V> {\n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n-            hashes_end: unsafe {\n-                self.hashes.offset(self.capacity as isize)\n-            },\n+            hashes_end: unsafe { self.hashes.offset(self.capacity as isize) },\n             marker: marker::PhantomData,\n         }\n     }\n@@ -747,7 +766,7 @@ impl<K, V> RawTable<K, V> {\n             raw: raw_bucket.offset(self.capacity as isize),\n             hashes_end: raw_bucket.hash,\n             elems_left: self.size,\n-            marker:     marker::PhantomData,\n+            marker: marker::PhantomData,\n         }\n     }\n }\n@@ -827,10 +846,7 @@ impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n \n                 if *self.raw.hash != EMPTY_BUCKET {\n                     self.elems_left -= 1;\n-                    return Some((\n-                        ptr::read(self.raw.key),\n-                        ptr::read(self.raw.val)\n-                    ));\n+                    return Some((ptr::read(self.raw.key), ptr::read(self.raw.val)));\n                 }\n             }\n         }\n@@ -851,7 +867,7 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left\n+            elems_left: self.elems_left,\n         }\n     }\n }\n@@ -873,7 +889,7 @@ unsafe impl<'a, K: Send, V: Send> Send for IterMut<'a, K, V> {}\n /// Iterator over the entries in a table, consuming the table.\n pub struct IntoIter<K, V> {\n     table: RawTable<K, V>,\n-    iter: RawBuckets<'static, K, V>\n+    iter: RawBuckets<'static, K, V>,\n }\n \n unsafe impl<K: Sync, V: Sync> Sync for IntoIter<K, V> {}\n@@ -894,10 +910,7 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe {\n-                (&*bucket.key,\n-                 &*bucket.val)\n-            }\n+            unsafe { (&*bucket.key, &*bucket.val) }\n         })\n     }\n \n@@ -906,7 +919,9 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     }\n }\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n-    fn len(&self) -> usize { self.elems_left }\n+    fn len(&self) -> usize {\n+        self.elems_left\n+    }\n }\n \n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n@@ -915,10 +930,7 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe {\n-                (&*bucket.key,\n-                 &mut *(bucket.val as *mut V))\n-            }\n+            unsafe { (&*bucket.key, &mut *(bucket.val as *mut V)) }\n         })\n     }\n \n@@ -927,7 +939,9 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     }\n }\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n-    fn len(&self) -> usize { self.elems_left }\n+    fn len(&self) -> usize {\n+        self.elems_left\n+    }\n }\n \n impl<K, V> Iterator for IntoIter<K, V> {\n@@ -937,13 +951,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;\n             unsafe {\n-                (\n-                    SafeHash {\n-                        hash: *bucket.hash,\n-                    },\n-                    ptr::read(bucket.key),\n-                    ptr::read(bucket.val)\n-                )\n+                (SafeHash { hash: *bucket.hash }, ptr::read(bucket.key), ptr::read(bucket.val))\n             }\n         })\n     }\n@@ -954,7 +962,9 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     }\n }\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    fn len(&self) -> usize { self.table.size() }\n+    fn len(&self) -> usize {\n+        self.table.size()\n+    }\n }\n \n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n@@ -965,13 +975,9 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;\n             unsafe {\n-                (\n-                    SafeHash {\n-                        hash: ptr::replace(bucket.hash, EMPTY_BUCKET),\n-                    },\n-                    ptr::read(bucket.key),\n-                    ptr::read(bucket.val)\n-                )\n+                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) },\n+                 ptr::read(bucket.key),\n+                 ptr::read(bucket.val))\n             }\n         })\n     }\n@@ -982,7 +988,9 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     }\n }\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n-    fn len(&self) -> usize { self.table.size() }\n+    fn len(&self) -> usize {\n+        self.table.size()\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n@@ -1040,18 +1048,21 @@ impl<K, V> Drop for RawTable<K, V> {\n         // dropping empty tables such as on resize.\n         // Also avoid double drop of elements that have been already moved out.\n         unsafe {\n-            if needs_drop::<(K, V)>() { // avoid linear runtime for types that don't need drop\n+            if needs_drop::<(K, V)>() {\n+                // avoid linear runtime for types that don't need drop\n                 for _ in self.rev_move_buckets() {}\n             }\n         }\n \n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n         let vals_size = self.capacity * size_of::<V>();\n-        let (align, _, size, oflo) =\n-            calculate_allocation(hashes_size, align_of::<u64>(),\n-                                 keys_size, align_of::<K>(),\n-                                 vals_size, align_of::<V>());\n+        let (align, _, size, oflo) = calculate_allocation(hashes_size,\n+                                                          align_of::<u64>(),\n+                                                          keys_size,\n+                                                          align_of::<K>(),\n+                                                          vals_size,\n+                                                          align_of::<V>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}]}