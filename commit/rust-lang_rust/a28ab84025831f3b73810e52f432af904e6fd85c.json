{"sha": "a28ab84025831f3b73810e52f432af904e6fd85c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyOGFiODQwMjU4MzFmM2I3MzgxMGU1MmY0MzJhZjkwNGU2ZmQ4NWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-12T13:04:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:38:11Z"}, "message": "nice_region_error: rustfmt", "tree": {"sha": "cd5cc70646c54dae6ee24a9648274c09f9144c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd5cc70646c54dae6ee24a9648274c09f9144c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a28ab84025831f3b73810e52f432af904e6fd85c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a28ab84025831f3b73810e52f432af904e6fd85c", "html_url": "https://github.com/rust-lang/rust/commit/a28ab84025831f3b73810e52f432af904e6fd85c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a28ab84025831f3b73810e52f432af904e6fd85c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3720242c75adb3edbe40806fed58cd999e80bef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3720242c75adb3edbe40806fed58cd999e80bef4", "html_url": "https://github.com/rust-lang/rust/commit/3720242c75adb3edbe40806fed58cd999e80bef4"}], "stats": {"total": 181, "additions": 98, "deletions": 83}, "files": [{"sha": "35c94853b9e7bfc1fc0748d1cf75331a380b57dc", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=a28ab84025831f3b73810e52f432af904e6fd85c", "patch": "@@ -72,22 +72,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n \n-        debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n-               ty_sub,\n-               sup,\n-               bregion_sup);\n-        debug!(\"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n-               ty_sup,\n-               sub,\n-               bregion_sub);\n+        debug!(\n+            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            ty_sub,\n+            sup,\n+            bregion_sup\n+        );\n+        debug!(\n+            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            ty_sup,\n+            sub,\n+            bregion_sub\n+        );\n \n         let (ty_sup, ty_fndecl_sup) = ty_sup;\n         let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-        let AnonymousArgInfo { arg: anon_arg_sup, .. } =\n-            or_false!(self.find_arg_with_region(sup, sup));\n-        let AnonymousArgInfo { arg: anon_arg_sub, .. } =\n-            or_false!(self.find_arg_with_region(sub, sub));\n+        let AnonymousArgInfo {\n+            arg: anon_arg_sup, ..\n+        } = or_false!(self.find_arg_with_region(sup, sup));\n+        let AnonymousArgInfo {\n+            arg: anon_arg_sub, ..\n+        } = or_false!(self.find_arg_with_region(sub, sub));\n \n         let sup_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n@@ -110,34 +116,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n             (None, None) => {\n                 let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n-\n-                    (format!(\"this type is declared with multiple lifetimes...\"),\n-                     format!(\"...but data{} flows{} here\",\n-                             format!(\" with one lifetime\"),\n-                             format!(\" into the other\")))\n+                    (\n+                        format!(\"this type is declared with multiple lifetimes...\"),\n+                        format!(\n+                            \"...but data{} flows{} here\",\n+                            format!(\" with one lifetime\"),\n+                            format!(\" into the other\")\n+                        ),\n+                    )\n                 } else {\n-                    (format!(\"these two types are declared with different lifetimes...\"),\n-                     format!(\"...but data{} flows{} here\",\n-                             span_label_var1,\n-                             span_label_var2))\n+                    (\n+                        format!(\"these two types are declared with different lifetimes...\"),\n+                        format!(\n+                            \"...but data{} flows{} here\",\n+                            span_label_var1,\n+                            span_label_var2\n+                        ),\n+                    )\n                 };\n                 (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n             }\n \n-            (Some(ret_span), _) => {\n-                (ty_sub.span,\n-                 ret_span,\n-                 format!(\"this parameter and the return type are declared \\\n-                          with different lifetimes...\",),\n-                 format!(\"...but data{} is returned here\", span_label_var1))\n-            }\n-            (_, Some(ret_span)) => {\n-                (ty_sup.span,\n-                 ret_span,\n-                 format!(\"this parameter and the return type are declared \\\n-                          with different lifetimes...\",),\n-                 format!(\"...but data{} is returned here\", span_label_var1))\n-            }\n+            (Some(ret_span), _) => (\n+                ty_sub.span,\n+                ret_span,\n+                format!(\n+                    \"this parameter and the return type are declared \\\n+                     with different lifetimes...\",\n+                ),\n+                format!(\"...but data{} is returned here\", span_label_var1),\n+            ),\n+            (_, Some(ret_span)) => (\n+                ty_sup.span,\n+                ret_span,\n+                format!(\n+                    \"this parameter and the return type are declared \\\n+                     with different lifetimes...\",\n+                ),\n+                format!(\"...but data{} is returned here\", span_label_var1),\n+            ),\n         };\n \n \n@@ -149,4 +166,3 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         return true;\n     }\n }\n-"}, {"sha": "92fdb52e02f8b7c35338652b2694af7daf4cb627", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=a28ab84025831f3b73810e52f432af904e6fd85c", "patch": "@@ -13,7 +13,7 @@ use infer::InferCtxt;\n use ty::{self, Region};\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters"}, {"sha": "04584f34a15d8d5eae47faf7838620b835de3aa9", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28ab84025831f3b73810e52f432af904e6fd85c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a28ab84025831f3b73810e52f432af904e6fd85c", "patch": "@@ -68,17 +68,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub(super) fn find_arg_with_region(&self,\n-                                anon_region: Region<'tcx>,\n-                                replace_region: Region<'tcx>)\n-                                -> Option<AnonymousArgInfo> {\n-\n+    pub(super) fn find_arg_with_region(\n+        &self,\n+        anon_region: Region<'tcx>,\n+        replace_region: Region<'tcx>,\n+    ) -> Option<AnonymousArgInfo> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n-                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n-            }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n@@ -94,21 +94,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty = tables.borrow().node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx\n-                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                            let new_arg_ty = self.tcx.fold_regions(&ty, &mut false, |r, _| {\n+                                if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n                                 } else {\n                                     r\n-                                });\n+                                }\n+                            });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n                                 Some(AnonymousArgInfo {\n-                                         arg: arg,\n-                                         arg_ty: new_arg_ty,\n-                                         bound_region: bound_region,\n-                                         is_first: is_first,\n-                                     })\n+                                    arg: arg,\n+                                    arg_ty: new_arg_ty,\n+                                    bound_region: bound_region,\n+                                    is_first: is_first,\n+                                })\n                             } else {\n                                 None\n                             }\n@@ -127,13 +128,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // This method returns the DefId and the BoundRegion corresponding to the given region.\n     pub(super) fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n-\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n-                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n-            }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n@@ -142,31 +142,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-\n-            Some(hir_map::NodeItem(..)) |\n-            Some(hir_map::NodeTraitItem(..)) => false,\n+            Some(hir_map::NodeItem(..)) | Some(hir_map::NodeTraitItem(..)) => false,\n             Some(hir_map::NodeImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,\n         };\n \n         return Some(FreeRegionInfo {\n-                        def_id: suitable_region_binding_scope,\n-                        boundregion: bound_region,\n-                        is_impl_item: is_impl_item,\n-                    });\n-\n+            def_id: suitable_region_binding_scope,\n+            boundregion: bound_region,\n+            is_impl_item: is_impl_item,\n+        });\n     }\n \n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n-    pub(super) fn is_return_type_anon(&self,\n-                               scope_def_id: DefId,\n-                               br: ty::BoundRegion,\n-                               decl: &hir::FnDecl)\n-                               -> Option<Span> {\n+    pub(super) fn is_return_type_anon(\n+        &self,\n+        scope_def_id: DefId,\n+        br: ty::BoundRegion,\n+        decl: &hir::FnDecl,\n+    ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::TyFnDef(_, _) => {\n@@ -186,14 +184,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n     pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n-        is_first &&\n-        self.tcx\n-            .opt_associated_item(scope_def_id)\n-            .map(|i| i.method_has_self_argument) == Some(true)\n+        is_first\n+            && self.tcx\n+                .opt_associated_item(scope_def_id)\n+                .map(|i| i.method_has_self_argument) == Some(true)\n     }\n \n     // Here we check if the bound region is in Impl Item.\n-    pub(super) fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n+    pub(super) fn is_bound_region_in_impl_item(\n+        &self,\n+        suitable_region_binding_scope: DefId,\n+    ) -> bool {\n         let container_id = self.tcx\n             .associated_item(suitable_region_binding_scope)\n             .container\n@@ -213,12 +214,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method returns whether the given Region is Named\n     pub(super) fn is_named_region(&self, region: Region<'tcx>) -> bool {\n         match *region {\n-            ty::ReFree(ref free_region) => {\n-                match free_region.bound_region {\n-                    ty::BrNamed(..) => true,\n-                    _ => false,\n-                }\n-            }\n+            ty::ReFree(ref free_region) => match free_region.bound_region {\n+                ty::BrNamed(..) => true,\n+                _ => false,\n+            },\n             ty::ReEarlyBound(_) => true,\n             _ => false,\n         }"}]}