{"sha": "8dbdcdbfb3d09c6d521b275e71370117850c89e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmRjZGJmYjNkMDljNmQ1MjFiMjc1ZTcxMzcwMTE3ODUwYzg5ZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T15:38:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:25:12Z"}, "message": "Fallout: RingBuf, use Unique.", "tree": {"sha": "fdb34cded175afeef3899e1a62c08269d6569d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdb34cded175afeef3899e1a62c08269d6569d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dbdcdbfb3d09c6d521b275e71370117850c89e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbdcdbfb3d09c6d521b275e71370117850c89e2", "html_url": "https://github.com/rust-lang/rust/commit/8dbdcdbfb3d09c6d521b275e71370117850c89e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dbdcdbfb3d09c6d521b275e71370117850c89e2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2891cc48798908a96d1b3f847d2cf241fcc58bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2891cc48798908a96d1b3f847d2cf241fcc58bb", "html_url": "https://github.com/rust-lang/rust/commit/c2891cc48798908a96d1b3f847d2cf241fcc58bb"}], "stats": {"total": 60, "additions": 31, "deletions": 29}, "files": [{"sha": "6e5970345f1d88951e10d5a7ccdf87ab5041706b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8dbdcdbfb3d09c6d521b275e71370117850c89e2/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbdcdbfb3d09c6d521b275e71370117850c89e2/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=8dbdcdbfb3d09c6d521b275e71370117850c89e2", "patch": "@@ -28,7 +28,7 @@ use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut};\n-use core::ptr;\n+use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n \n use core::hash::{Writer, Hash, Hasher};\n@@ -51,7 +51,7 @@ pub struct RingBuf<T> {\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    ptr: *mut T\n+    ptr: Unique<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -74,7 +74,7 @@ impl<T> Drop for RingBuf<T> {\n         self.clear();\n         unsafe {\n             if mem::size_of::<T>() != 0 {\n-                heap::deallocate(self.ptr as *mut u8,\n+                heap::deallocate(*self.ptr as *mut u8,\n                                  self.cap * mem::size_of::<T>(),\n                                  mem::min_align_of::<T>())\n             }\n@@ -92,13 +92,13 @@ impl<T> RingBuf<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Moves an element out of the buffer\n@@ -165,21 +165,21 @@ impl<T> RingBuf<T> {\n         let size = cap.checked_mul(mem::size_of::<T>())\n                       .expect(\"capacity overflow\");\n \n-        let ptr = if mem::size_of::<T>() != 0 {\n-            unsafe {\n+        let ptr = unsafe {\n+            if mem::size_of::<T>() != 0 {\n                 let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n                 if ptr.is_null() { ::alloc::oom() }\n-                ptr\n+                Unique::new(ptr)\n+            } else {\n+                Unique::new(heap::EMPTY as *mut T)\n             }\n-        } else {\n-            heap::EMPTY as *mut T\n         };\n \n         RingBuf {\n             tail: 0,\n             head: 0,\n             cap: cap,\n-            ptr: ptr\n+            ptr: ptr,\n         }\n     }\n \n@@ -335,11 +335,12 @@ impl<T> RingBuf<T> {\n                 let new = count.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n \n@@ -453,11 +454,12 @@ impl<T> RingBuf<T> {\n                 let old = self.cap * mem::size_of::<T>();\n                 let new_size = target_cap * mem::size_of::<T>();\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new_size,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new_size,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n             self.cap = target_cap;\n@@ -539,8 +541,8 @@ impl<T> RingBuf<T> {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n-            ptr: self.ptr,\n-            marker: marker::ContravariantLifetime,\n+            ptr: *self.ptr,\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -1336,7 +1338,7 @@ impl<T> RingBuf<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 first_half.as_ptr().offset(at as isize),\n                                                 amount_in_first);\n \n@@ -1349,7 +1351,7 @@ impl<T> RingBuf<T> {\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 second_half.as_ptr().offset(offset as isize),\n                                                 amount_in_second);\n             }\n@@ -1518,7 +1520,7 @@ pub struct IterMut<'a, T:'a> {\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    marker: marker::ContravariantLifetime<'a>,\n+    marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1986,9 +1988,9 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum Taggypar<T> {\n-        Onepar(i32),\n-        Twopar(i32, i32),\n-        Threepar(i32, i32, i32),\n+        Onepar(T),\n+        Twopar(T, T),\n+        Threepar(T, T, T),\n     }\n \n     #[derive(Clone, PartialEq, Debug)]"}]}