{"sha": "8dc554a32507de2d923e5ba3ca3d672adaf0a822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYzU1NGEzMjUwN2RlMmQ5MjNlNWJhM2NhM2Q2NzJhZGFmMGE4MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-12T06:38:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-12T06:38:11Z"}, "message": "Auto merge of #54534 - nagisa:align-offset-simplification, r=alexcrichton\n\nSimplify implementation of align_offset slightly", "tree": {"sha": "ae6da91224688aba4e7b05eab74bd6f759a7a3ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae6da91224688aba4e7b05eab74bd6f759a7a3ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dc554a32507de2d923e5ba3ca3d672adaf0a822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc554a32507de2d923e5ba3ca3d672adaf0a822", "html_url": "https://github.com/rust-lang/rust/commit/8dc554a32507de2d923e5ba3ca3d672adaf0a822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dc554a32507de2d923e5ba3ca3d672adaf0a822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "567557f630693d47fd21151ff1fdbc430e330a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/567557f630693d47fd21151ff1fdbc430e330a13", "html_url": "https://github.com/rust-lang/rust/commit/567557f630693d47fd21151ff1fdbc430e330a13"}, {"sha": "0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "html_url": "https://github.com/rust-lang/rust/commit/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "b8d7fcffbcc0968922dc2ed3d5786a0c70efb4be", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8dc554a32507de2d923e5ba3ca3d672adaf0a822/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc554a32507de2d923e5ba3ca3d672adaf0a822/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8dc554a32507de2d923e5ba3ca3d672adaf0a822", "patch": "@@ -2370,13 +2370,13 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e. for\n         /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n-        const INV_TABLE_MOD_16: [usize; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n+        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n         const INV_TABLE_MOD: usize = 16;\n         /// INV_TABLE_MOD\u00b2\n         const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n-        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1];\n+        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n         if m <= INV_TABLE_MOD {\n             table_inverse & (m - 1)\n         } else {\n@@ -2429,36 +2429,23 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n     let gcd = 1usize << gcdpow;\n \n-    if gcd == 1 {\n-        // This branch solves for the variable $o$ in following linear congruence equation:\n-        //\n-        // \u23b0 p + o \u2261 0 (mod a)   # $p + o$ must be aligned to specified alignment $a$\n-        // \u23b1     o \u2261 0 (mod s)   # offset $o$ must be a multiple of stride $s$\n-        //\n-        // where\n+    if p as usize & (gcd - 1) == 0 {\n+        // This branch solves for the following linear congruence equation:\n         //\n-        // * a, s are co-prime\n+        // $$ p + so \u2261 0 mod a $$\n         //\n-        // This gives us the formula below:\n+        // $p$ here is the pointer value, $s$ \u2013 stride of `T`, $o$ offset in `T`s, and $a$ \u2013 the\n+        // requested alignment.\n         //\n-        // o = (a - (p mod a)) * (s\u207b\u00b9 mod a) * s\n+        // g = gcd(a, s)\n+        // o = (a - (p mod a))/g * ((s/g)\u207b\u00b9 mod a)\n         //\n         // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n-        // incrementing p by one s change the relative alignment of p\u201d, the third term is\n-        // translating change in units of s to a byte count.\n+        // incrementing p by s bytes change the relative alignment of p\u201d. Division by `g` is\n+        // necessary to make this equation well formed if $a$ and $s$ are not co-prime.\n         //\n         // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n-        // to take the result $o mod lcm(s, a)$. Since $s$ and $a$ are co-prime (i.e. $gcd(s, a) =\n-        // 1$) and $lcm(s, a) = s * a / gcd(s, a)$, we can replace $lcm(s, a)$ with just a $s * a$.\n-        //\n-        // (Author note: we decided later on to express the offset in \"elements\" rather than bytes,\n-        // which drops the multiplication by `s` on both sides of the modulo.)\n-        return intrinsics::unchecked_rem(a.wrapping_sub(pmoda).wrapping_mul(mod_inv(smoda, a)), a);\n-    }\n-\n-    if p as usize & (gcd - 1) == 0 {\n-        // This can be aligned, but `a` and `stride` are not co-prime, so a somewhat adapted\n-        // formula is used.\n+        // to take the result $o mod lcm(s, a)$. We can replace $lcm(s, a)$ with just a $a / g$.\n         let j = a.wrapping_sub(pmoda) >> gcdpow;\n         let k = smoda >> gcdpow;\n         return intrinsics::unchecked_rem(j.wrapping_mul(mod_inv(k, a)), a >> gcdpow);"}, {"sha": "c9013f589edd36eb9159d62b9a3c7bae9106d69d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dc554a32507de2d923e5ba3ca3d672adaf0a822/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc554a32507de2d923e5ba3ca3d672adaf0a822/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8dc554a32507de2d923e5ba3ca3d672adaf0a822", "patch": "@@ -1932,7 +1932,7 @@ impl<T> [T] {\n         fn gcd(a: usize, b: usize) -> usize {\n             // iterative stein\u2019s algorithm\n             // We should still make this `const fn` (and revert to recursive algorithm if we do)\n-            // because relying on llvm to consteval all this is\u2026 well, it makes me\n+            // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n             let (ctz_a, mut ctz_b) = unsafe {\n                 if a == 0 { return b; }\n                 if b == 0 { return a; }"}]}