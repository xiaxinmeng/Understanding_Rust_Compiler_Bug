{"sha": "bab15885c0ab1230186cc45290c6d6c224289f6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYjE1ODg1YzBhYjEyMzAxODZjYzQ1MjkwYzZkNmMyMjQyODlmNmI=", "commit": {"author": {"name": "pawanbisht62", "email": "36775517+pawanbisht62@users.noreply.github.com", "date": "2020-08-15T03:29:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-15T03:29:12Z"}, "message": "Merge branch 'master' into feature/incorporate-tracing", "tree": {"sha": "ce67bbf8ae8d6294671d8af43877cd9bc3a06be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce67bbf8ae8d6294671d8af43877cd9bc3a06be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab15885c0ab1230186cc45290c6d6c224289f6b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfN1aICRBK7hj4Ov3rIwAAdHIIACU/FWsNpRCROv+WYzrHwMzX\nKl5m8xpJed6OWCADp1JWnnygTqgyfMHCUpkntGvl6Le5TUxX/+KE3Yc8+8tzwDiA\nQMCTU+l+7NBlwO9IYtdce5EKmp7f0J56W59raNV/vNYeWLzG8IwphZb67ooA8Fz9\nqHJJRuGHE8TwOjzO32qrbb07KxcV2ebNuK4C/wV79Qy7f0omNPoL75Js1jZ9GDft\nPN5AgUwM7P78qTwf3M+tvKbbqy7UDzTWNmJIi9dOuklpZBLgP7dwZCcQW6VMeP2w\nw4k5FHnC1dPYqFslysdApVFmlnDSSGqra/++1Mmi4n03+hlQis/CvTESeyXXPhw=\n=iUJU\n-----END PGP SIGNATURE-----\n", "payload": "tree ce67bbf8ae8d6294671d8af43877cd9bc3a06be8\nparent 7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b\nparent 668a34e0f438d4a950b9440239656d6755ad963c\nauthor pawanbisht62 <36775517+pawanbisht62@users.noreply.github.com> 1597462152 +0530\ncommitter GitHub <noreply@github.com> 1597462152 +0530\n\nMerge branch 'master' into feature/incorporate-tracing"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab15885c0ab1230186cc45290c6d6c224289f6b", "html_url": "https://github.com/rust-lang/rust/commit/bab15885c0ab1230186cc45290c6d6c224289f6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab15885c0ab1230186cc45290c6d6c224289f6b/comments", "author": {"login": "pawanbisht62", "id": 36775517, "node_id": "MDQ6VXNlcjM2Nzc1NTE3", "avatar_url": "https://avatars.githubusercontent.com/u/36775517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pawanbisht62", "html_url": "https://github.com/pawanbisht62", "followers_url": "https://api.github.com/users/pawanbisht62/followers", "following_url": "https://api.github.com/users/pawanbisht62/following{/other_user}", "gists_url": "https://api.github.com/users/pawanbisht62/gists{/gist_id}", "starred_url": "https://api.github.com/users/pawanbisht62/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pawanbisht62/subscriptions", "organizations_url": "https://api.github.com/users/pawanbisht62/orgs", "repos_url": "https://api.github.com/users/pawanbisht62/repos", "events_url": "https://api.github.com/users/pawanbisht62/events{/privacy}", "received_events_url": "https://api.github.com/users/pawanbisht62/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "html_url": "https://github.com/rust-lang/rust/commit/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b"}, {"sha": "668a34e0f438d4a950b9440239656d6755ad963c", "url": "https://api.github.com/repos/rust-lang/rust/commits/668a34e0f438d4a950b9440239656d6755ad963c", "html_url": "https://github.com/rust-lang/rust/commit/668a34e0f438d4a950b9440239656d6755ad963c"}], "stats": {"total": 18719, "additions": 12094, "deletions": 6625}, "files": [{"sha": "c1fa3bef07c7ef294074f36ac1f5cefe0f620eda", "filename": "Cargo.lock", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2454,9 +2454,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.36\"\n+version = \"2.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09ba6cca9fcd8ae086b842b1bd9e3f19f104a4c30e0e8927b2befc06d375e7e0\"\n+checksum = \"db975752fc2c2430b4159d262585f7e45eb9aa43d733bf02c5f2fde512b00bfb\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2804,19 +2804,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_arena\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c9cdd301e9dcb15ead384fc07196c850fd22829fae81d296b2ed6b4b10bf3278\"\n+checksum = \"4a3941333c39ffa778611a34692244052fc9ba0f6b02dcf019c8d24925707dd6\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f7c0d0537ca69dfe4a49212035295dfb37a235b5df01aa877d50b247f4775b8\"\n+checksum = \"27c579f7d89e6fc971b433e92bb2b8c65b716d7c797b21de8685945be9455610\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -2832,9 +2832,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_passes\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4cf4dca95f55f70eeb193fb08554026d79d0628de771fd726bb609e36887b82\"\n+checksum = \"f9914fadee461568d19ca2ebaec8699ff898f8ffec9928154659a57ee018e5fd\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"log\",\n@@ -2851,9 +2851,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"202bd2886d0cfa48baa3711042c14843f1b4852555b7ee7e5376bf66b276cb8d\"\n+checksum = \"2a78c5cc50a2f294d3c4e9131a15676724c9f136d3ed54e9ba419850b6025cb3\"\n dependencies = [\n  \"log\",\n  \"rustc-ap-rustc_ast\",\n@@ -2863,9 +2863,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b11ee1d92b3214e8a8c7829eff84cc1b03925da0ea5c6900cefe05b99edb4682\"\n+checksum = \"a78ce08227d146949755175c0cf710280a4b5bf6ee504c0e3f7ccc30d66fbfd9\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n@@ -2881,9 +2881,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7a45d43b974d4cb9e32e5a15119c5eb7672c306ef09b064f2125b6a0399f6656\"\n+checksum = \"9d5ac3735c38d2d0e95991ebcd7eb1618b60e784194a738e0ce2e8d39c39b809\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n@@ -2911,9 +2911,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cd895d440820aaa04e6dc5486105494920a1e9779b9b051e8dba4ca5c182f94\"\n+checksum = \"5166a95afa6e3b78ccbece4c2f1e163634854297f1147c6fd90e2712ed3fede5\"\n dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n@@ -2929,9 +2929,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_expand\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"71a0cc7820860d6691bf0aa7a95cdbc60f6587b495c18e0fa15a888fdabbf171\"\n+checksum = \"1a0586e83bdfe70eda8393429a8a38ecb529525dd252d787e479af075d3cab08\"\n dependencies = [\n  \"log\",\n  \"rustc-ap-rustc_ast\",\n@@ -2951,9 +2951,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5473d5106401aa46f881eb91772f0a41fd5f28ae6134cf4b450eb1370ea6af22\"\n+checksum = \"48fc3aa8de0737a8c5a4353e6948548f469150d2b5d3eac391843de32c6c6ca2\"\n dependencies = [\n  \"lazy_static\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -2962,40 +2962,40 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8da1d57ee7a7ef55f31a97d99c7f919f02fc9a60ab96faa8cf45a7ae3ab1ccbf\"\n+checksum = \"59fd3380f4029020b693bbfd5a14ec8c893ec33c5c0063ad2e68e46d3fbd6a1f\"\n \n [[package]]\n name = \"rustc-ap-rustc_graphviz\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3af62b20460908378cd1d354917acd9553376c5363bbb4e465f949bd82bdef9\"\n+checksum = \"b54bd98f70e04291bf611151d1fcd4d7770b35f7ec603d301c4aee0d1979cca4\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3af7d4c456fe7647453d3fcd58335c9d512d1ff9a239a370b7ebdd353d69f66f\"\n+checksum = \"335bfb187a2489a59ee8c67fcf5d1760e9dcdbe0f02025c199a74caa05096b15\"\n dependencies = [\n+ \"arrayvec 0.5.1\",\n  \"rustc-ap-rustc_serialize\",\n- \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"456af5f09c006cf6c22c1a433ee0232c4bb74bdc6c647a010166a47c94ed2a63\"\n+checksum = \"22e1221f3bfa2943c942cf8da319ab2346887f8757778c29c7f1822cd27b521f\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64f6acd192f313047759a346b892998b626466b93fe04f415da5f38906bb3b4c\"\n+checksum = \"8b774df26c4ef513555b3a303cb209f44cf68a9e6a5481b41ac832301c6487cb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -3005,9 +3005,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c006e8117c1c55e42bb56386c86ce6f7e4b47349e0bec7888c1d24784272e61b\"\n+checksum = \"065e632101bdd57a271f38ee7a4d72b5a3d0467ec845104346c284b2c6c69960\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -3024,19 +3024,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_serialize\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"306ced69beaeebe4de9552ee751eb54ea25b5f34a73fe80f5f9cbbe15ccebc48\"\n+checksum = \"0e8c0b704e3dedb97cbb1ac566bbc0ab397ec4a4743098326a8f2230463fd9f9\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dbff48435f5a476365e3ab5f49e07f98715cecb2d8c5bbcafeaf3aec638407be\"\n+checksum = \"dda99ede4e6e260712754f8548b0a175b615686ad393653a3bd11f6c5e41a04e\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n@@ -3054,9 +3054,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec4273af0abbe78fc4585316ab193445c848c555e9203ddc28af02330918bf30\"\n+checksum = \"53453791c2c0b501a921927ce8e305a801eef130920873f8da92d83dad595236\"\n dependencies = [\n  \"cfg-if\",\n  \"log\",\n@@ -3073,9 +3073,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"669.0.0\"\n+version = \"671.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f9a2d6004ce6ad492a8eeacc2569b1c008169434b8828996d8dade4e5c6b6ee\"\n+checksum = \"ac82006fdb31ef44e24e1623f8b72ac2b404ef15ba20b7ebec0df35e5d20bbef\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -3257,6 +3257,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n+ \"rustc_lexer\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3333,6 +3334,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3363,10 +3365,12 @@ dependencies = [\n  \"rustc-rayon-core\",\n  \"rustc_graphviz\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"stacker\",\n+ \"tempfile\",\n  \"tracing\",\n  \"winapi 0.3.8\",\n ]\n@@ -3414,6 +3418,7 @@ dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"rustc_data_structures\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"termcolor\",\n@@ -3435,6 +3440,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3497,6 +3503,7 @@ dependencies = [\n  \"rustc_fs_util\",\n  \"rustc_graphviz\",\n  \"rustc_hir\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3509,6 +3516,7 @@ name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n  \"arrayvec 0.5.1\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n ]\n \n@@ -3638,6 +3646,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3813,6 +3822,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"smallvec 1.4.0\",\n@@ -3867,6 +3877,7 @@ name = \"rustc_serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n+ \"rustc_macros\",\n  \"smallvec 1.4.0\",\n ]\n \n@@ -3882,6 +3893,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4078,7 +4090,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.19\"\n+version = \"1.4.20\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\",\n@@ -4622,6 +4634,10 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"tier-check\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"time\"\n version = \"0.1.42\""}, {"sha": "87e958a1bafe64bea36d84de36c726d940a08bd2", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -13,6 +13,7 @@ members = [\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\",\n+  \"src/tools/tier-check\",\n   \"src/tools/build-manifest\",\n   \"src/tools/remote-test-client\",\n   \"src/tools/remote-test-server\","}, {"sha": "3399f7fe6c8b1463b4c432986a7f90f68561f154", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,9 +1,9 @@\n-<a href = \"https://www.rust-lang.org/\"> \n+<a href = \"https://www.rust-lang.org/\">\n <img width = \"90%\" height = \"auto\" src = \"https://img.shields.io/badge/Rust-Programming%20Language-black?style=flat&logo=rust\" alt = \"The Rust Programming Language\">\n </a>\n \n This is the main source code repository for [Rust]. It contains the compiler,\n-standard library, and documentation. \n+standard library, and documentation.\n \n [Rust]: https://www.rust-lang.org\n \n@@ -23,7 +23,7 @@ Read [\"Installation\"] from [The Book].\n section.**\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. More information about it can be found \n+which manages the bootstrapping process. More information about it can be found\n by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n \n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n@@ -157,17 +157,6 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n > python x.py build\n ```\n \n-### Building rustc with older host toolchains\n-It is still possible to build Rust with the older toolchain versions listed below, but only if the\n-LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN option is set to true in the config.toml file.\n-\n-* Clang 3.1\n-* Apple Clang 3.1\n-* GCC 4.8\n-* Visual Studio 2015 (Update 3)\n-\n-Toolchain versions older than what is listed above cannot be used to build rustc.\n-\n #### Specifying an ABI\n \n Each specific ABI can also be used from either environment (for example, using"}, {"sha": "b3d8c2f65f63377b32c5afd3958a6bf842d4cae0", "filename": "RELEASES.md", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,3 +1,104 @@\n+Version 1.46.0 (2020-08-27)\n+==========================\n+\n+Language\n+--------\n+- [`if`, `match`, and `loop` expressions can now be used in const functions.][72437]\n+- [Additionally you are now also able to coerce and cast to slices (`&[T]`) in\n+  const functions.][73862]\n+- [The `#[track_caller]` attribute can now be added to functions to use the\n+  function's caller's location information for panic messages.][72445]\n+- [Recursively indexing into tuples no longer needs parentheses.][71322] E.g.\n+  `x.0.0` over `(x.0).0`.\n+- [`mem::transmute` can now be used in static and constants.][72920] **Note**\n+  You currently can't use `mem::transmute` in constant functions.\n+\n+Compiler\n+--------\n+- [You can now use the `cdylib` target on Apple iOS and tvOS platforms.][73516]\n+- [Enabled static \"Position Independent Executables\" by default\n+  for `x86_64-unknown-linux-musl`.][70740]\n+\n+Libraries\n+---------\n+- [`mem::forget` is now a `const fn`.][73887]\n+- [`String` now implements `From<char>`.][73466]\n+- [The `leading_ones`, and `trailing_ones` methods have been stabilised for all\n+  integer types.][73032]\n+- [`vec::IntoIter<T>` now implements `AsRef<[T]>`.][72583]\n+- [All non-zero integer types (`NonZeroU8`) now implement `TryFrom` for their\n+  zero-able equivalent (e.g. `TryFrom<u8>`).][72717]\n+- [`&[T]` and `&mut [T]` now implement `PartialEq<Vec<T>>`.][71660]\n+- [`(String, u16)` now implements `ToSocketAddrs`.][73007]\n+- [`vec::Drain<'_, T>` now implements `AsRef<[T]>`.][72584]\n+\n+Stabilized APIs\n+---------------\n+- [`Option::zip`]\n+- [`vec::Drain::as_slice`]\n+\n+Cargo\n+-----\n+Added a number of new environment variables that are now available when\n+compiling your crate.\n+\n+- [`CARGO_BIN_NAME` and `CARGO_CRATE_NAME`][cargo/8270] Providing the name of\n+  the specific binary being compiled and the name of the crate.\n+- [`CARGO_PKG_LICENSE`][cargo/8325] The license from the manifest of the package.\n+- [`CARGO_PKG_LICENSE_FILE`][cargo/8387] The path to the license file.\n+\n+Compatibility Notes\n+-------------------\n+- [The target configuration option `abi_blacklist` has been renamed\n+  to `unsupported_abis`.][74150] The old name will still continue to work.\n+- [Rustc will now warn if you have a C-like enum that implements `Drop`.][72331]\n+  This was previously accepted but will become a hard error in a future release.\n+- [Rustc will fail to compile if you have a struct with\n+  `#[repr(i128)]` or `#[repr(u128)]`.][74109] This representation is currently only\n+  allowed on `enum`s.\n+- [Tokens passed to `macro_rules!` are now always captured.][73293] This helps\n+  ensure that spans have the correct information, and may cause breakage if you\n+  were relying on receiving spans with dummy information.\n+- [The InnoSetup installer for Windows is no longer available.][72569] This was\n+  a legacy installer that was replaced by a MSI installer a few years ago but\n+  was still being built.\n+- [`{f32, f64}::asinh` now returns the correct values for negative numbers.][72486]\n+- [Rustc will no longer accept overlapping trait implementations that only\n+  differ in how the lifetime was bound.][72493]\n+- [Rustc now correctly relates the lifetime of an existential associated\n+  type.][71896] This fixes some edge cases where `rustc` would erroneously allow\n+  you to pass a shorter lifetime than expected.\n+\n+[74109]: https://github.com/rust-lang/rust/pull/74109/\n+[74150]: https://github.com/rust-lang/rust/pull/74150/\n+[73862]: https://github.com/rust-lang/rust/pull/73862/\n+[73887]: https://github.com/rust-lang/rust/pull/73887/\n+[73466]: https://github.com/rust-lang/rust/pull/73466/\n+[73516]: https://github.com/rust-lang/rust/pull/73516/\n+[73293]: https://github.com/rust-lang/rust/pull/73293/\n+[73007]: https://github.com/rust-lang/rust/pull/73007/\n+[73032]: https://github.com/rust-lang/rust/pull/73032/\n+[72920]: https://github.com/rust-lang/rust/pull/72920/\n+[72569]: https://github.com/rust-lang/rust/pull/72569/\n+[72583]: https://github.com/rust-lang/rust/pull/72583/\n+[72584]: https://github.com/rust-lang/rust/pull/72584/\n+[72717]: https://github.com/rust-lang/rust/pull/72717/\n+[72437]: https://github.com/rust-lang/rust/pull/72437/\n+[72445]: https://github.com/rust-lang/rust/pull/72445/\n+[72486]: https://github.com/rust-lang/rust/pull/72486/\n+[72493]: https://github.com/rust-lang/rust/pull/72493/\n+[72331]: https://github.com/rust-lang/rust/pull/72331/\n+[71896]: https://github.com/rust-lang/rust/pull/71896/\n+[71660]: https://github.com/rust-lang/rust/pull/71660/\n+[71322]: https://github.com/rust-lang/rust/pull/71322/\n+[70740]: https://github.com/rust-lang/rust/pull/70740/\n+[cargo/8270]: https://github.com/rust-lang/cargo/pull/8270/\n+[cargo/8325]: https://github.com/rust-lang/cargo/pull/8325/\n+[cargo/8387]: https://github.com/rust-lang/cargo/pull/8387/\n+[`Option::zip`]: https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.zip\n+[`vec::Drain::as_slice`]: https://doc.rust-lang.org/stable/std/vec/struct.Drain.html#method.as_slice\n+\n+\n Version 1.45.2 (2020-08-03)\n ==========================\n \n@@ -7,6 +108,7 @@ Version 1.45.2 (2020-08-03)\n [74954]: https://github.com/rust-lang/rust/issues/74954\n [74784]: https://github.com/rust-lang/rust/issues/74784\n \n+\n Version 1.45.1 (2020-07-30)\n ==========================\n \n@@ -20,6 +122,7 @@ Version 1.45.1 (2020-07-30)\n [74509]: https://github.com/rust-lang/rust/pull/74509\n [74457]: https://github.com/rust-lang/rust/pull/74457\n \n+\n Version 1.45.0 (2020-07-16)\n ==========================\n "}, {"sha": "b22eb1ff6354b6f9786240b927b058e56d8f4106", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,14 +2,14 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering;\n-use core::fmt::Debug;\n+use core::fmt::{self, Debug};\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, ptr};\n+use core::ptr;\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n@@ -154,7 +154,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n-                        let mut out_node = match root.as_mut().force() {\n+                        let mut out_node = match root.node_as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -210,7 +210,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             // Ord` constraint, which this method lacks.\n             BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().as_ref()) // unwrap succeeds because not empty\n+            clone_subtree(self.root.as_ref().unwrap().node_as_ref()) // unwrap succeeds because not empty\n         }\n     }\n }\n@@ -223,14 +223,16 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -242,8 +244,8 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.as_mut(), &key) {\n-            Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.node_as_mut(), &key) {\n+            Found(handle) => Some(mem::replace(handle.into_key_mut(), key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n                     .insert(());\n@@ -565,7 +567,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -592,7 +595,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -617,8 +621,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_key_value(&self) -> Option<(&K, &V)> {\n-        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n-        front.right_kv().ok().map(Handle::into_kv)\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n \n     /// Returns the first entry in the map for in-place manipulation.\n@@ -643,8 +647,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n-        let kv = front.right_kv().ok()?;\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        let kv = root_node.first_leaf_edge().right_kv().ok()?;\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             length: &mut self.length,\n@@ -694,8 +698,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_key_value(&self) -> Option<(&K, &V)> {\n-        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n-        back.left_kv().ok().map(Handle::into_kv)\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n \n     /// Returns the last entry in the map for in-place manipulation.\n@@ -720,8 +724,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n-        let kv = back.left_kv().ok()?;\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        let kv = root_node.last_leaf_edge().left_kv().ok()?;\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             length: &mut self.length,\n@@ -805,8 +809,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n-            Found(handle) => Some(handle.into_kv_mut().1),\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n+            Found(handle) => Some(handle.into_val_mut()),\n             GoDown(_) => None,\n         }\n     }\n@@ -899,7 +904,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -995,7 +1001,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let (f, b) = range_search(root.as_ref(), range);\n+            let (f, b) = range_search(root.node_as_ref(), range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1041,7 +1047,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = range_search(root.as_mut(), range);\n+            let (f, b) = range_search(root.node_as_mut(), range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1071,7 +1077,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree(root.as_mut(), &key) {\n+        match search::search_tree(root.node_as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1083,7 +1089,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         let root = Self::ensure_is_owned(&mut self.root);\n-        let mut cur_node = root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = root.node_as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1133,7 +1139,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(root: &mut node::Root<K, V>) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = root.as_mut();\n+        let mut cur_node = root.node_as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1201,8 +1207,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n \n         {\n-            let mut left_node = left_root.as_mut();\n-            let mut right_node = right_root.as_mut();\n+            let mut left_node = left_root.node_as_mut();\n+            let mut right_node = right_root.node_as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1280,7 +1286,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n-        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        let root_node = self.root.as_mut().map(|r| r.node_as_mut());\n+        let front = root_node.map(|rn| rn.first_leaf_edge());\n         DrainFilterInner {\n             length: &mut self.length,\n             cur_leaf_edge: front,\n@@ -1315,7 +1322,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().node_as_ref());\n     }\n \n     /// Creates a consuming iterator visiting all the keys, in sorted order.\n@@ -2251,7 +2258,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         if let Some(root) = &self.root {\n-            let (f, b) = full_range_search(root.as_ref());\n+            let (f, b) = full_range_search(root.node_as_ref());\n \n             Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n         } else {\n@@ -2283,7 +2290,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = full_range_search(root.as_mut());\n+            let (f, b) = full_range_search(root.node_as_mut());\n \n             IterMut {\n                 range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n@@ -2741,7 +2748,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.handle.into_kv_mut().1\n+        self.handle.into_val_mut()\n     }\n \n     /// Sets the value of the entry with the `OccupiedEntry`'s key,\n@@ -2895,7 +2902,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n-        while self.height() > 0 && self.as_ref().len() == 0 {\n+        while self.height() > 0 && self.node_as_ref().len() == 0 {\n             self.pop_internal_level();\n         }\n     }\n@@ -2904,7 +2911,7 @@ impl<K, V> node::Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.as_mut();\n+            let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -2930,7 +2937,7 @@ impl<K, V> node::Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.as_mut();\n+            let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -3017,3 +3024,6 @@ impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "910e7043092a550c09f2ef40436285eda2d263df", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,16 +1,20 @@\n-use std::collections::btree_map::Entry::{Occupied, Vacant};\n-use std::collections::BTreeMap;\n+use crate::boxed::Box;\n+use crate::collections::btree_map::Entry::{Occupied, Vacant};\n+use crate::collections::BTreeMap;\n+use crate::fmt::Debug;\n+use crate::rc::Rc;\n+use crate::string::String;\n+use crate::string::ToString;\n+use crate::vec::Vec;\n use std::convert::TryFrom;\n-use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-use super::DeterministicRng;\n+use super::super::DeterministicRng;\n \n // Value of node::CAPACITY, thus capacity of a tree with a single level,\n // i.e. a tree who's root is a leaf node at height 0.", "previous_filename": "library/alloc/tests/btree/map.rs"}, {"sha": "6c8a588eb58f33db5d98c32d2f53f2cb7695d80a", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -25,3 +25,30 @@ pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n         }\n     })\n }\n+\n+#[cfg(test)]\n+/// XorShiftRng\n+struct DeterministicRng {\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+    w: u32,\n+}\n+\n+#[cfg(test)]\n+impl DeterministicRng {\n+    fn new() -> Self {\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n+    }\n+\n+    fn next(&mut self) -> u32 {\n+        let x = self.x;\n+        let t = x ^ (x << 11);\n+        self.x = self.y;\n+        self.y = self.z;\n+        self.z = self.w;\n+        let w_ = self.w;\n+        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n+        self.w\n+    }\n+}"}, {"sha": "acc2ae73572ba757aa801bafde1ae2e376efc2b5", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 88, "deletions": 51, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -43,6 +43,9 @@ use crate::boxed::Box;\n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n+const KV_IDX_CENTER: usize = B - 1;\n+const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n+const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n \n /// The underlying representation of leaf nodes.\n #[repr(C)]\n@@ -163,7 +166,8 @@ impl<K, V> Root<K, V> {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n     }\n \n-    pub fn as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n+    /// Borrows and returns an immutable reference to the node owned by the root.\n+    pub fn node_as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -172,7 +176,8 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    pub fn as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n+    /// Borrows and returns a mutable reference to the node owned by the root.\n+    pub fn node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -226,12 +231,12 @@ impl<K, V> Root<K, V> {\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(\n-                self.as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n+                self.node_as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n             )\n         };\n         self.height -= 1;\n         unsafe {\n-            (*self.as_mut().as_leaf_mut()).parent = ptr::null();\n+            (*self.node_as_mut().as_leaf_mut()).parent = ptr::null();\n         }\n \n         unsafe {\n@@ -411,7 +416,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n     /// node is a `Leaf` or an `Internal`.\n-    unsafe fn cast_unchecked<NewType>(&mut self) -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n+    unsafe fn cast_unchecked<NewType>(self) -> NodeRef<marker::Mut<'a>, K, V, NewType> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n@@ -616,7 +621,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     let edge =\n                         ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n+                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n@@ -648,7 +653,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n+                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -719,7 +724,7 @@ impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n }\n \n impl<Node, Type> Handle<Node, Type> {\n-    /// Retrieves the node that contains the edge of key/value pair this handle points to.\n+    /// Retrieves the node that contains the edge or key/value pair this handle points to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n@@ -819,6 +824,27 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n+enum InsertionPlace {\n+    Left(usize),\n+    Right(usize),\n+}\n+\n+/// Given an edge index where we want to insert into a node filled to capacity,\n+/// computes a sensible KV index of a split point and where to perform the insertion.\n+/// The goal of the split point is for its key and value to end up in a parent node;\n+/// the keys, values and edges to the left of the split point become the left child;\n+/// the keys, values and edges to the right of the split point become the right child.\n+fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n+    debug_assert!(edge_idx <= CAPACITY);\n+    // Rust issue #74834 tries to explain these symmetric rules.\n+    match edge_idx {\n+        0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, InsertionPlace::Left(edge_idx)),\n+        EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Left(edge_idx)),\n+        EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, InsertionPlace::Right(0)),\n+        _ => (KV_IDX_CENTER + 1, InsertionPlace::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),\n+    }\n+}\n+\n impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n     /// Helps implementations of `insert_fit` for a particular `NodeType`,\n     /// by taking care of leaf data.\n@@ -861,18 +887,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let ptr = if self.idx <= B {\n-                unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n-            } else {\n-                unsafe {\n+            let ptr = match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n-                        right.as_mut().cast_unchecked::<marker::Leaf>(),\n-                        self.idx - (B + 1),\n+                        right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val)\n-                }\n+                },\n             };\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), ptr)\n         }\n@@ -934,20 +962,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             InsertResult::Fit(kv)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            if self.idx <= B {\n-                unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val, edge);\n-                }\n-            } else {\n-                unsafe {\n+            match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val, edge);\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n-                        right.as_mut().cast_unchecked::<marker::Internal>(),\n-                        self.idx - (B + 1),\n+                        right.node_as_mut().cast_unchecked::<marker::Internal>(),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val, edge);\n-                }\n+                },\n             }\n             InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n         }\n@@ -1016,6 +1044,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeTyp\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    pub fn into_key_mut(self) -> &'a mut K {\n+        let keys = self.node.into_key_slice_mut();\n+        unsafe { keys.get_unchecked_mut(self.idx) }\n+    }\n+\n+    pub fn into_val_mut(self) -> &'a mut V {\n+        let vals = self.node.into_val_slice_mut();\n+        unsafe { vals.get_unchecked_mut(self.idx) }\n+    }\n+\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n         unsafe {\n             let (keys, vals) = self.node.into_slices_mut();\n@@ -1080,7 +1118,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     }\n \n     /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n-    /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n+    /// that the key/value pair collapsed into.\n     pub fn remove(\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n@@ -1117,7 +1155,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n             for i in 0..(new_len + 1) {\n-                Handle::new_edge(new_root.as_mut().cast_unchecked(), i).correct_parent_link();\n+                Handle::new_edge(new_root.node_as_mut().cast_unchecked(), i).correct_parent_link();\n             }\n \n             (self.node, k, v, new_root)\n@@ -1138,18 +1176,17 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// to by this handle, and the node immediately to the right of this handle into one new\n     /// child of the underlying node, returning an edge referencing that new child.\n     ///\n-    /// Assumes that this edge `.can_merge()`.\n+    /// Panics unless this edge `.can_merge()`.\n     pub fn merge(\n         mut self,\n     ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };\n         let self2 = unsafe { ptr::read(&self) };\n         let mut left_node = self1.left_edge().descend();\n         let left_len = left_node.len();\n-        let mut right_node = self2.right_edge().descend();\n+        let right_node = self2.right_edge().descend();\n         let right_len = right_node.len();\n \n-        // necessary for correctness, but in a private module\n         assert!(left_len + right_len < CAPACITY);\n \n         unsafe {\n@@ -1180,28 +1217,25 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n-            let layout = if self.node.height > 1 {\n+            if self.node.height > 1 {\n+                // SAFETY: the height of the nodes being merged is one below the height\n+                // of the node of this edge, thus above zero, so they are internal.\n+                let mut left_node = left_node.cast_unchecked();\n+                let right_node = right_node.cast_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.cast_unchecked().as_internal().edges.as_ptr(),\n-                    left_node\n-                        .cast_unchecked()\n-                        .as_internal_mut()\n-                        .edges\n-                        .as_mut_ptr()\n-                        .add(left_len + 1),\n+                    right_node.reborrow().as_internal().edges.as_ptr(),\n+                    left_node.reborrow_mut().as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n                 for i in left_len + 1..left_len + right_len + 2 {\n-                    Handle::new_edge(left_node.cast_unchecked().reborrow_mut(), i)\n-                        .correct_parent_link();\n+                    Handle::new_edge(left_node.reborrow_mut(), i).correct_parent_link();\n                 }\n \n-                Layout::new::<InternalNode<K, V>>()\n+                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n-                Layout::new::<LeafNode<K, V>>()\n-            };\n-            Global.dealloc(right_node.node.cast(), layout);\n+                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n+            }\n \n             Handle::new_edge(self.node, self.idx)\n         }\n@@ -1214,8 +1248,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let (k, v, edge) = self.reborrow_mut().left_edge().descend().pop();\n \n-            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n-            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+            let k = mem::replace(self.kv_mut().0, k);\n+            let v = mem::replace(self.kv_mut().1, v);\n \n             match self.reborrow_mut().right_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push_front(k, v),\n@@ -1231,8 +1265,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let (k, v, edge) = self.reborrow_mut().right_edge().descend().pop_front();\n \n-            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n-            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+            let k = mem::replace(self.kv_mut().0, k);\n+            let v = mem::replace(self.kv_mut().1, v);\n \n             match self.reborrow_mut().left_edge().descend().force() {\n                 ForceResult::Leaf(mut leaf) => leaf.push(k, v),\n@@ -1260,7 +1294,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.reborrow_mut().into_kv_mut();\n+                    let kv = self.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1317,7 +1351,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n                 let parent_kv = {\n-                    let kv = self.reborrow_mut().into_kv_mut();\n+                    let kv = self.kv_mut();\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n@@ -1543,3 +1577,6 @@ unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n         ret\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "e2416974ddca39c1e9410bec7f1d398930a7f51a", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,25 @@\n+use super::*;\n+\n+#[test]\n+fn test_splitpoint() {\n+    for idx in 0..=CAPACITY {\n+        let (middle_kv_idx, insertion) = splitpoint(idx);\n+\n+        // Simulate performing the split:\n+        let mut left_len = middle_kv_idx;\n+        let mut right_len = CAPACITY - middle_kv_idx - 1;\n+        match insertion {\n+            InsertionPlace::Left(edge_idx) => {\n+                assert!(edge_idx <= left_len);\n+                left_len += 1;\n+            }\n+            InsertionPlace::Right(edge_idx) => {\n+                assert!(edge_idx <= right_len);\n+                right_len += 1;\n+            }\n+        }\n+        assert!(left_len >= MIN_LEN);\n+        assert!(right_len >= MIN_LEN);\n+        assert!(left_len + right_len == CAPACITY);\n+    }\n+}"}, {"sha": "a559e87e4e29855956eb15258660871a45afb54b", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1572,3 +1572,6 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T: Ord> FusedIterator for Union<'_, T> {}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "f4e957e22fe15ae07d0141ae2cc89f3e9bda908a", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "renamed", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,9 +1,10 @@\n-use std::collections::BTreeSet;\n+use crate::collections::BTreeSet;\n+use crate::vec::Vec;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use super::DeterministicRng;\n+use super::super::DeterministicRng;\n \n #[test]\n fn test_clone_eq() {\n@@ -15,24 +16,6 @@ fn test_clone_eq() {\n     assert_eq!(m.clone(), m);\n }\n \n-#[test]\n-fn test_hash() {\n-    use crate::hash;\n-\n-    let mut x = BTreeSet::new();\n-    let mut y = BTreeSet::new();\n-\n-    x.insert(1);\n-    x.insert(2);\n-    x.insert(3);\n-\n-    y.insert(3);\n-    y.insert(2);\n-    y.insert(1);\n-\n-    assert_eq!(hash(&x), hash(&y));\n-}\n-\n #[test]\n fn test_iter_min_max() {\n     let mut a = BTreeSet::new();", "previous_filename": "library/alloc/tests/btree/set.rs"}, {"sha": "a0b151a4496f114c86d3530990b16c73012c82eb", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -239,7 +239,7 @@\n //! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n //! ```\n //!\n-//! print two significantly different things:\n+//! print three significantly different things:\n //!\n //! ```text\n //! Hello, `1234.560` has 3 fractional digits"}, {"sha": "2d25941a52412187c8a43f1bb03c25fb865eb3ab", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -80,6 +80,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n@@ -93,6 +94,7 @@\n #![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(exclusive_range_pattern)]\n #![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n@@ -101,6 +103,8 @@\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(libc)]\n+#![feature(map_first_last)]\n+#![feature(map_into_keys_values)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(nll)]"}, {"sha": "8ca0a0883cb1679a538d203e3b8471e5c4f705d5", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2269,7 +2269,7 @@ impl<T> Vec<T> {\n     /// with the given `replace_with` iterator and yields the removed items.\n     /// `replace_with` does not need to be the same length as `range`.\n     ///\n-    /// The element range is removed even if the iterator is not consumed until the end.\n+    /// `range` is removed even if the iterator is not consumed until the end.\n     ///\n     /// It is unspecified how many elements are removed from the vector\n     /// if the `Splice` value is leaked.\n@@ -2620,9 +2620,6 @@ where\n ///\n /// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n /// by the [`IntoIterator`] trait).\n-///\n-/// [`Vec`]: struct.Vec.html\n-/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     buf: NonNull<T>,\n@@ -2802,10 +2799,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n \n /// A draining iterator for `Vec<T>`.\n ///\n-/// This `struct` is created by the [`drain`] method on [`Vec`].\n-///\n-/// [`drain`]: struct.Vec.html#method.drain\n-/// [`Vec`]: struct.Vec.html\n+/// This `struct` is created by [`Vec::drain`].\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n@@ -2933,11 +2927,8 @@ impl<T> FusedIterator for Drain<'_, T> {}\n \n /// A splicing iterator for `Vec`.\n ///\n-/// This struct is created by the [`splice()`] method on [`Vec`]. See its\n-/// documentation for more.\n-///\n-/// [`splice()`]: struct.Vec.html#method.splice\n-/// [`Vec`]: struct.Vec.html\n+/// This struct is created by [`Vec::splice()`].\n+/// See its documentation for more.\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "library/alloc/tests/btree/mod.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbtree%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,27 +0,0 @@\n-mod map;\n-mod set;\n-\n-/// XorShiftRng\n-struct DeterministicRng {\n-    x: u32,\n-    y: u32,\n-    z: u32,\n-    w: u32,\n-}\n-\n-impl DeterministicRng {\n-    fn new() -> Self {\n-        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n-    }\n-\n-    fn next(&mut self) -> u32 {\n-        let x = self.x;\n-        let t = x ^ (x << 11);\n-        self.x = self.y;\n-        self.y = self.z;\n-        self.z = self.w;\n-        let w_ = self.w;\n-        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n-        self.w\n-    }\n-}"}, {"sha": "e06a95ded94c75dc09577214ea54bc8b71ae921f", "filename": "library/alloc/tests/btree_set_hash.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Fbtree_set_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Fbtree_set_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbtree_set_hash.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::BTreeSet;\n+\n+#[test]\n+fn test_hash() {\n+    use crate::hash;\n+\n+    let mut x = BTreeSet::new();\n+    let mut y = BTreeSet::new();\n+\n+    x.insert(1);\n+    x.insert(2);\n+    x.insert(3);\n+\n+    y.insert(3);\n+    y.insert(2);\n+    y.insert(1);\n+\n+    assert_eq!(hash(&x), hash(&y));\n+}"}, {"sha": "f2ba1ab64810b11a73a86d910516e36a3ea4f377", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,10 +1,7 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n-#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n-#![feature(map_first_last)]\n-#![feature(map_into_keys_values)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(str_split_once)]\n@@ -25,7 +22,7 @@ mod arc;\n mod binary_heap;\n mod borrow;\n mod boxed;\n-mod btree;\n+mod btree_set_hash;\n mod cow_str;\n mod fmt;\n mod heap;"}, {"sha": "3c7d57f8b32a8d88f9fa9f70424dc7df872da8ee", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1522,15 +1522,15 @@ fn test_copy_from_slice() {\n }\n \n #[test]\n-#[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[should_panic(expected = \"source slice length (4) does not match destination slice length (5)\")]\n fn test_copy_from_slice_dst_longer() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 5];\n     dst.copy_from_slice(&src);\n }\n \n #[test]\n-#[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[should_panic(expected = \"source slice length (4) does not match destination slice length (3)\")]\n fn test_copy_from_slice_dst_shorter() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 3];"}, {"sha": "6b28ab7d755631f68860ed2cd402f9d1cb20c418", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -364,3 +364,66 @@ macro_rules! array_impl_default {\n }\n \n array_impl_default! {32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}\n+\n+#[cfg(not(bootstrap))]\n+#[lang = \"array\"]\n+impl<T, const N: usize> [T; N] {\n+    /// Returns an array of the same size as `self`, with function `f` applied to each element\n+    /// in order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_map)]\n+    /// let x = [1, 2, 3];\n+    /// let y = x.map(|v| v + 1);\n+    /// assert_eq!(y, [2, 3, 4]);\n+    ///\n+    /// let x = [1, 2, 3];\n+    /// let mut temp = 0;\n+    /// let y = x.map(|v| { temp += 1; v * temp });\n+    /// assert_eq!(y, [1, 4, 9]);\n+    ///\n+    /// let x = [\"Ferris\", \"Bueller's\", \"Day\", \"Off\"];\n+    /// let y = x.map(|v| v.len());\n+    /// assert_eq!(y, [6, 9, 3, 3]);\n+    /// ```\n+    #[unstable(feature = \"array_map\", issue = \"75243\")]\n+    pub fn map<F, U>(self, mut f: F) -> [U; N]\n+    where\n+        F: FnMut(T) -> U,\n+    {\n+        use crate::mem::MaybeUninit;\n+        struct Guard<T, const N: usize> {\n+            dst: *mut T,\n+            initialized: usize,\n+        }\n+\n+        impl<T, const N: usize> Drop for Guard<T, N> {\n+            fn drop(&mut self) {\n+                debug_assert!(self.initialized <= N);\n+\n+                let initialized_part =\n+                    crate::ptr::slice_from_raw_parts_mut(self.dst, self.initialized);\n+                // SAFETY: this raw slice will contain only initialized objects\n+                // that's why, it is allowed to drop it.\n+                unsafe {\n+                    crate::ptr::drop_in_place(initialized_part);\n+                }\n+            }\n+        }\n+        let mut dst = MaybeUninit::uninit_array::<N>();\n+        let mut guard: Guard<U, N> =\n+            Guard { dst: MaybeUninit::first_ptr_mut(&mut dst), initialized: 0 };\n+        for (src, dst) in IntoIter::new(self).zip(&mut dst) {\n+            dst.write(f(src));\n+            guard.initialized += 1;\n+        }\n+        // FIXME: Convert to crate::mem::transmute once it works with generics.\n+        // unsafe { crate::mem::transmute::<[MaybeUninit<U>; N], [U; N]>(dst) }\n+        crate::mem::forget(guard);\n+        // SAFETY: At this point we've properly initialized the whole array\n+        // and we just need to cast it to the correct type.\n+        unsafe { crate::mem::transmute_copy::<_, [U; N]>(&dst) }\n+    }\n+}"}, {"sha": "6f5a6aa7c79cabf9ab3cf72a8d39b6f6bd544936", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -40,14 +40,12 @@\n /// provide a reference to related type `T`, it is often better to use\n /// [`AsRef<T>`] as more types can safely implement it.\n ///\n-/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n-/// [`BorrowMut<T>`]: trait.BorrowMut.html\n+/// [`BorrowMut<T>`]: BorrowMut\n /// [`Box<T>`]: ../../std/boxed/struct.Box.html\n /// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n /// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [`str`]: ../../std/primitive.str.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`borrow`]: #tymethod.borrow\n+/// [`borrow`]: Borrow::borrow\n ///\n /// # Examples\n ///\n@@ -152,10 +150,9 @@\n /// If it wants to allow others access to the underlying `str`, it can do\n /// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n ///\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`Hash`]: crate::hash::Hash\n /// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n@@ -187,7 +184,7 @@ pub trait Borrow<Borrowed: ?Sized> {\n /// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n /// for more information on borrowing as another type.\n ///\n-/// [`Borrow<T>`]: trait.Borrow.html\n+/// [`Borrow<T>`]: Borrow\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n     /// Mutably borrows from an owned value."}, {"sha": "e775ded60f593e4aaf131e68508eeffa81e26344", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -17,14 +17,8 @@\n //!\n //! For more details, see the respective documentation of each item in the list.\n //!\n-//! [`Eq`]: trait.Eq.html\n-//! [`PartialEq`]: trait.PartialEq.html\n-//! [`Ord`]: trait.Ord.html\n-//! [`PartialOrd`]: trait.PartialOrd.html\n-//! [`Ordering`]: enum.Ordering.html\n-//! [`Reverse`]: struct.Reverse.html\n-//! [`max`]: fn.max.html\n-//! [`min`]: fn.min.html\n+//! [`max`]: Ord::max\n+//! [`min`]: Ord::min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "763457d485da451a7195dffeb7fb50b62b2b6531", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -145,6 +145,7 @@\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_extra)]\n #![feature(external_doc)]\n #![feature(associated_type_bounds)]\n #![feature(const_caller_location)]"}, {"sha": "e45aa86c0795a915d7f5b079e4189d8a7999e3a7", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -56,9 +56,9 @@ use crate::ptr;\n /// working with [pinned] data, where reusing the memory without calling the destructor could lead\n /// to Undefined Behaviour.\n ///\n-/// [`mem::zeroed`]: fn.zeroed.html\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-/// [pinned]: ../pin/index.html\n+/// [`mem::zeroed`]: crate::mem::zeroed\n+/// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n+/// [pinned]: crate::pin\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -116,8 +116,6 @@ impl<T> ManuallyDrop<T> {\n     /// leaving the state of this container unchanged.\n     /// It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n     ///\n-    /// [`ManuallyDrop::drop`]: #method.drop\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n     #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n     #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n@@ -148,9 +146,7 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n     /// uphold those guarantees without assistance from the compiler.\n     ///\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    /// [`ptr::drop_in_place`]: ../ptr/fn.drop_in_place.html\n-    /// [pinned]: ../pin/index.html\n+    /// [pinned]: crate::pin\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {"}, {"sha": "d2d65fd2fa517027c365215f4e88c28e3dc98125", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -247,7 +247,7 @@ impl<T> MaybeUninit<T> {\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     ///\n-    /// [`assume_init`]: #method.assume_init\n+    /// [`assume_init`]: MaybeUninit::assume_init\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n@@ -525,7 +525,7 @@ impl<T> MaybeUninit<T> {\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n-    /// [`assume_init`]: #method.assume_init\n+    /// [`assume_init`]: MaybeUninit::assume_init\n     ///\n     /// # Examples\n     ///"}, {"sha": "ac20897d258fb78ffd55060a43f0e33408d9951f", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -662,6 +662,11 @@ impl<T: ?Sized> *const T {\n     /// will only affect the pointer part, whereas for (thin) pointers to\n     /// sized types, this has the same effect as a simple assignment.\n     ///\n+    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `val` but the metadata of\n+    /// `self`.\n+    ///\n     /// # Examples\n     ///\n     /// This function is primarily useful for allowing byte-wise pointer\n@@ -673,13 +678,17 @@ impl<T: ?Sized> *const T {\n     /// let arr: [i32; 3] = [1, 2, 3];\n     /// let mut ptr = &arr[0] as *const dyn Debug;\n     /// let thin = ptr as *const u8;\n-    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n-    /// assert_eq!(unsafe { *(ptr as *const i32) }, 3);\n+    /// unsafe {\n+    ///     ptr = ptr.set_ptr_value(thin.add(8));\n+    ///     # assert_eq!(*(ptr as *const i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n     /// ```\n     #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline]\n-    pub fn set_ptr_value(mut self, val: *const ()) -> Self {\n-        let thin = &mut self as *mut *const T as *mut *const ();\n+    pub fn set_ptr_value(mut self, val: *const u8) -> Self {\n+        let thin = &mut self as *mut *const T as *mut *const u8;\n         // SAFETY: In case of a thin pointer, this operations is identical\n         // to a simple assignment. In case of a fat pointer, with the current\n         // fat pointer layout implementation, the first field of such a"}, {"sha": "df00139118aa4bc0cd98fe6398c9c74816f72f8f", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -718,6 +718,11 @@ impl<T: ?Sized> *mut T {\n     /// will only affect the pointer part, whereas for (thin) pointers to\n     /// sized types, this has the same effect as a simple assignment.\n     ///\n+    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `val` but the metadata of\n+    /// `self`.\n+    ///\n     /// # Examples\n     ///\n     /// This function is primarily useful for allowing byte-wise pointer\n@@ -729,13 +734,17 @@ impl<T: ?Sized> *mut T {\n     /// let mut arr: [i32; 3] = [1, 2, 3];\n     /// let mut ptr = &mut arr[0] as *mut dyn Debug;\n     /// let thin = ptr as *mut u8;\n-    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n-    /// assert_eq!(unsafe { *(ptr as *mut i32) }, 3);\n+    /// unsafe {\n+    ///     ptr = ptr.set_ptr_value(thin.add(8));\n+    ///     # assert_eq!(*(ptr as *mut i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n     /// ```\n     #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline]\n-    pub fn set_ptr_value(mut self, val: *mut ()) -> Self {\n-        let thin = &mut self as *mut *mut T as *mut *mut ();\n+    pub fn set_ptr_value(mut self, val: *mut u8) -> Self {\n+        let thin = &mut self as *mut *mut T as *mut *mut u8;\n         // SAFETY: In case of a thin pointer, this operations is identical\n         // to a simple assignment. In case of a fat pointer, with the current\n         // fat pointer layout implementation, the first field of such a"}, {"sha": "f2477ed6a6e1bf9214de80c7e6c70209dadd9452", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 206, "deletions": 31, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! Slice management and manipulation.\n //!\n@@ -70,6 +69,8 @@ impl<T> [T] {\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n+        // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n         unsafe { crate::ptr::Repr { rust: self }.raw.len }\n     }\n \n@@ -443,7 +444,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_ptr_range(&self) -> Range<*const T> {\n-        // The `add` here is safe, because:\n+        let start = self.as_ptr();\n+        // SAFETY: The `add` here is safe, because:\n         //\n         //   - Both pointers are part of the same object, as pointing directly\n         //     past the object also counts.\n@@ -460,7 +462,6 @@ impl<T> [T] {\n         //     the end of the address space.\n         //\n         // See the documentation of pointer::add.\n-        let start = self.as_ptr();\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -484,8 +485,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n-        // See as_ptr_range() above for why `add` here is safe.\n         let start = self.as_mut_ptr();\n+        // SAFETY: See as_ptr_range() above for why `add` here is safe.\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -511,11 +512,15 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn swap(&mut self, a: usize, b: usize) {\n+        // Can't take two mutable loans from one vector, so instead just cast\n+        // them to their raw pointers to do the swap.\n+        let pa: *mut T = &mut self[a];\n+        let pb: *mut T = &mut self[b];\n+        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n+        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n+        // Note that accessing the elements behind `a` and `b` is checked and will\n+        // panic when out of bounds.\n         unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n             ptr::swap(pa, pb);\n         }\n     }\n@@ -554,6 +559,24 @@ impl<T> [T] {\n             // Use the llvm.bswap intrinsic to reverse u8s in a usize\n             let chunk = mem::size_of::<usize>();\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: There are several things to check here:\n+                //\n+                // - Note that `chunk` is either 4 or 8 due to the cfg check\n+                //   above. So `chunk - 1` is positive.\n+                // - Indexing with index `i` is fine as the loop check guarantees\n+                //   `i + chunk - 1 < ln / 2`\n+                //   <=> `i < ln / 2 - (chunk - 1) < ln / 2 < ln`.\n+                // - Indexing with index `ln - i - chunk = ln - (i + chunk)` is fine:\n+                //   - `i + chunk > 0` is trivially true.\n+                //   - The loop check guarantees:\n+                //     `i + chunk - 1 < ln / 2`\n+                //     <=> `i + chunk \u2264 ln / 2 \u2264 ln`, thus subtraction does not underflow.\n+                // - The `read_unaligned` and `write_unaligned` calls are fine:\n+                //   - `pa` points to index `i` where `i < ln / 2 - (chunk - 1)`\n+                //     (see above) and `pb` points to index `ln - i - chunk`, so\n+                //     both are at least `chunk`\n+                //     many bytes away from the end of `self`.\n+                //   - Any initialized memory is valid `usize`.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -570,6 +593,20 @@ impl<T> [T] {\n             // Use rotate-by-16 to reverse u16s in a u32\n             let chunk = mem::size_of::<u32>() / 2;\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n+                // (and obviously `i < ln`), because each element is 2 bytes and\n+                // we're reading 4.\n+                //\n+                // `i + chunk - 1 < ln / 2` # while condition\n+                // `i + 2 - 1 < ln / 2`\n+                // `i + 1 < ln / 2`\n+                //\n+                // Since it's less than the length divided by 2, then it must be\n+                // in bounds.\n+                //\n+                // This also means that the condition `0 < i + chunk <= ln` is\n+                // always respected, ensuring the `pb` pointer can be used\n+                // safely.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -583,8 +620,13 @@ impl<T> [T] {\n         }\n \n         while i < ln / 2 {\n-            // Unsafe swap to avoid the bounds check in safe swap.\n+            // SAFETY: `i` is inferior to half the length of the slice so\n+            // accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and\n+            // will not go further than `ln / 2 - 1`).\n+            // The resulting pointers `pa` and `pb` are therefore valid and\n+            // aligned, and can be read from and written to.\n             unsafe {\n+                // Unsafe swap to avoid the bounds check in safe swap.\n                 let pa: *mut T = self.get_unchecked_mut(i);\n                 let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n@@ -609,8 +651,24 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n+        let ptr = self.as_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -637,8 +695,24 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n+        let ptr = self.as_mut_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_mut_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -1107,6 +1181,8 @@ impl<T> [T] {\n         let len = self.len();\n         let ptr = self.as_mut_ptr();\n \n+        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n+        // fulfills the requirements of `from_raw_parts_mut`.\n         unsafe {\n             assert!(mid <= len);\n \n@@ -1655,14 +1731,14 @@ impl<T> [T] {\n         while size > 1 {\n             let half = size / 2;\n             let mid = base + half;\n-            // mid is always in [0, size), that means mid is >= 0 and < size.\n-            // mid >= 0: by definition\n-            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n+            // SAFETY: the call is made safe by the following inconstants:\n+            // - `mid >= 0`: by definition\n+            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n             let cmp = f(unsafe { s.get_unchecked(mid) });\n             base = if cmp == Greater { base } else { mid };\n             size -= half;\n         }\n-        // base is always in [0, size) because base <= mid.\n+        // SAFETY: base is always in [0, size) because base <= mid.\n         let cmp = f(unsafe { s.get_unchecked(base) });\n         if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n     }\n@@ -2120,6 +2196,21 @@ impl<T> [T] {\n         let mut next_read: usize = 1;\n         let mut next_write: usize = 1;\n \n+        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n+        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n+        // one element before `ptr_write`, but `next_write` starts at 1, so\n+        // `prev_ptr_write` is never less than 0 and is inside the slice.\n+        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n+        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n+        // and `prev_ptr_write.offset(1)`.\n+        //\n+        // `next_write` is also incremented at most once per loop at most meaning\n+        // no element is skipped when it may need to be swapped.\n+        //\n+        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n+        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n+        // The explanation is simply that `next_read >= next_write` is always true,\n+        // thus `next_read > next_write - 1` is too.\n         unsafe {\n             // Avoid bounds checks by using raw pointers.\n             while next_read < len {\n@@ -2203,9 +2294,11 @@ impl<T> [T] {\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n+        let p = self.as_mut_ptr();\n \n+        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n+        // valid for reading and writing, as required by `ptr_rotate`.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2244,9 +2337,11 @@ impl<T> [T] {\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n+        let p = self.as_mut_ptr();\n \n+        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n+        // valid for reading and writing, as required by `ptr_rotate`.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2406,7 +2501,25 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        assert_eq!(self.len(), src.len(), \"destination and source slices have different lengths\");\n+        // The panic code path was put into a cold function to not bloat the\n+        // call site.\n+        #[inline(never)]\n+        #[cold]\n+        #[track_caller]\n+        fn len_mismatch_fail(dst_len: usize, src_len: usize) -> ! {\n+            panic!(\n+                \"source slice length ({}) does not match destination slice length ({})\",\n+                src_len, dst_len,\n+            );\n+        }\n+\n+        if self.len() != src.len() {\n+            len_mismatch_fail(self.len(), src.len());\n+        }\n+\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n         }\n@@ -2460,6 +2573,8 @@ impl<T> [T] {\n         assert!(src_end <= self.len(), \"src is out of bounds\");\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n+        // SAFETY: the conditions for `ptr::copy` have all been checked above,\n+        // as have those for `ptr::add`.\n         unsafe {\n             ptr::copy(self.as_ptr().add(src_start), self.as_mut_ptr().add(dest), count);\n         }\n@@ -2515,6 +2630,9 @@ impl<T> [T] {\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::swap_nonoverlapping(self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n         }\n@@ -2546,6 +2664,8 @@ impl<T> [T] {\n             // iterative stein\u2019s algorithm\n             // We should still make this `const fn` (and revert to recursive algorithm if we do)\n             // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n+\n+            // SAFETY: `a` and `b` are checked to be non-zero values.\n             let (ctz_a, mut ctz_b) = unsafe {\n                 if a == 0 {\n                     return b;\n@@ -2565,6 +2685,7 @@ impl<T> [T] {\n                     mem::swap(&mut a, &mut b);\n                 }\n                 b = b - a;\n+                // SAFETY: `b` is checked to be non-zero.\n                 unsafe {\n                     if b == 0 {\n                         break;\n@@ -2626,6 +2747,7 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n+        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n         let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &[], &[])\n@@ -2685,6 +2807,13 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n+        // SAFETY: Here we are ensuring we will use aligned pointers for U for the\n+        // rest of the method. This is done by passing a pointer to &[T] with an\n+        // alignment targeted for U.\n+        // `crate::ptr::align_offset` is called with a correctly aligned and\n+        // valid pointer `ptr` (it comes from a reference to `self`) and with\n+        // a size that is a power of two (since it comes from the alignement for U),\n+        // satisfying its safety constraints.\n         let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &mut [], &mut [])\n@@ -2810,15 +2939,13 @@ impl<T> [T] {\n \n         while left != right {\n             let mid = left + (right - left) / 2;\n-            // SAFETY:\n-            // When left < right, left <= mid < right.\n-            // Therefore left always increases and right always decreases,\n-            // and eigher of them is selected.\n-            // In both cases left <= right is satisfied.\n-            // Therefore if left < right in a step,\n-            // left <= right is satisfied in the next step.\n-            // Therefore as long as left != right, 0 <= left < right <= len is satisfied\n-            // and if this case 0 <= mid < len is satisfied too.\n+            // SAFETY: When `left < right`, `left <= mid < right`.\n+            // Therefore `left` always increases and `right` always decreases,\n+            // and either of them is selected. In both cases `left <= right` is\n+            // satisfied. Therefore if `left < right` in a step, `left <= right`\n+            // is satisfied in the next step. Therefore as long as `left != right`,\n+            // `0 <= left < right <= len` is satisfied and if this case\n+            // `0 <= mid < len` is satisfied too.\n             let value = unsafe { self.get_unchecked(mid) };\n             if pred(value) {\n                 left = mid + 1;\n@@ -2938,7 +3065,8 @@ fn is_ascii(s: &[u8]) -> bool {\n     // above.\n     debug_assert!(offset_to_aligned <= len);\n \n-    // word_ptr is the (properly aligned) usize ptr we use to read the middle chunk of the slice.\n+    // SAFETY: word_ptr is the (properly aligned) usize ptr we use to read the\n+    // middle chunk of the slice.\n     let mut word_ptr = unsafe { start.add(offset_to_aligned) as *const usize };\n \n     // `byte_pos` is the byte index of `word_ptr`, used for loop end checks.\n@@ -3126,11 +3254,13 @@ unsafe impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n@@ -3171,6 +3301,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n@@ -3180,6 +3311,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n@@ -3208,6 +3340,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3218,6 +3351,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3290,6 +3424,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3298,6 +3433,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3543,6 +3679,9 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n+                // SAFETY: the iterator was created from a slice with pointer\n+                // `self.ptr` and length `len!(self)`. This guarantees that all\n+                // the prerequisites for `from_raw_parts` are fulfilled.\n                 unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n             }\n \n@@ -3601,6 +3740,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer\n+                // must be non-null, and slices over non-ZSTs must also have a\n+                // non-null end pointer. The call to `next_unchecked!` is safe\n+                // since we check if the iterator is empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3634,14 +3778,14 @@ macro_rules! iterator {\n                         // could be (due to wrapping).\n                         self.end = self.ptr.as_ptr();\n                     } else {\n+                        // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                         unsafe {\n-                            // End can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                             self.ptr = NonNull::new_unchecked(self.end as *mut T);\n                         }\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n                     self.post_inc_start(n as isize);\n                     Some(next_unchecked!(self))\n@@ -3748,6 +3892,8 @@ macro_rules! iterator {\n                 let mut i = 0;\n                 while let Some(x) = self.next() {\n                     if predicate(x) {\n+                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n+                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3769,6 +3915,8 @@ macro_rules! iterator {\n                 while let Some(x) = self.next_back() {\n                     i -= 1;\n                     if predicate(x) {\n+                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n+                        // and is only decreasing.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3784,6 +3932,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer must be non-null,\n+                // and slices over non-ZSTs must also have a non-null end pointer.\n+                // The call to `next_back_unchecked!` is safe since we check if the iterator is\n+                // empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3804,7 +3957,7 @@ macro_rules! iterator {\n                     self.end = self.ptr.as_ptr();\n                     return None;\n                 }\n-                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                 unsafe {\n                     self.pre_dec_end(n as isize);\n                     Some(next_back_unchecked!(self))\n@@ -3999,6 +4152,9 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n+        // SAFETY: the iterator was created from a mutable slice with pointer\n+        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n+        // for `from_raw_parts_mut` are fulfilled.\n         unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n     }\n \n@@ -5568,6 +5724,8 @@ impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n         unsafe { self.iter.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n@@ -6288,12 +6446,20 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_ref<T>(s: &T) -> &[T] {\n+    // SAFETY: a reference is guaranteed to be valid for reads. The returned\n+    // reference cannot be mutated as it is an immutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts` is safe.\n     unsafe { from_raw_parts(s, 1) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_mut<T>(s: &mut T) -> &mut [T] {\n+    // SAFETY: a mutable reference is guaranteed to be valid for writes.\n+    // The reference cannot be accessed by another pointer as it is an mutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts_mut` is safe.\n     unsafe { from_raw_parts_mut(s, 1) }\n }\n \n@@ -6414,6 +6580,8 @@ where\n         if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n             return true;\n         }\n+        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n+        // The two slices have been checked to have the same size above.\n         unsafe {\n             let size = mem::size_of_val(self);\n             memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n@@ -6516,6 +6684,9 @@ impl SliceOrd for u8 {\n     #[inline]\n     fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n+            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n+            // We use the minimum of both lengths which guarantees that both regions are\n+            // valid for reads in that interval.\n             unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n             left.len().cmp(&right.len())\n@@ -6590,6 +6761,10 @@ impl SliceContains for u8 {\n impl SliceContains for i8 {\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         let byte = *self as u8;\n+        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n+        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n+        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n+        // than `isize::MAX`. The returned slice is never mutated.\n         let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n         memchr::memchr(byte, bytes).is_some()\n     }"}, {"sha": "934f581f3faeb7575aa8f99726e22c69f51b50a2", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -414,12 +414,13 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    // SAFETY: the caller must guarantee that the bytes `v`\n-    // are valid UTF-8, thus the cast to `*const str` is safe.\n-    // Also, the pointer dereference is safe because that pointer\n-    // comes from a reference which is guaranteed to be valid for reads.\n-    unsafe { &*(v as *const [u8] as *const str) }\n+#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n+#[allow(unused_attributes)]\n+#[allow_internal_unstable(const_fn_transmute)]\n+pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n+    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n+    // Also relies on `&str` and `&[u8]` having the same layout.\n+    unsafe { mem::transmute(v) }\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -2357,15 +2358,10 @@ impl str {\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n     #[allow(unused_attributes)]\n-    #[allow_internal_unstable(const_fn_union)]\n+    #[allow_internal_unstable(const_fn_transmute)]\n     pub const fn as_bytes(&self) -> &[u8] {\n-        #[repr(C)]\n-        union Slices<'a> {\n-            str: &'a str,\n-            slice: &'a [u8],\n-        }\n         // SAFETY: const sound because we transmute two types with the same layout\n-        unsafe { Slices { str: self }.slice }\n+        unsafe { mem::transmute(self) }\n     }\n \n     /// Converts a mutable string slice to a mutable byte slice."}, {"sha": "5aba1a5d958d1dfe38f66230be09f0a5b3deec99", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -290,3 +290,43 @@ fn empty_array_is_always_default() {\n \n     let _arr = <[DoesNotImplDefault; 0]>::default();\n }\n+\n+#[test]\n+fn array_map() {\n+    let a = [1, 2, 3];\n+    let b = a.map(|v| v + 1);\n+    assert_eq!(b, [2, 3, 4]);\n+\n+    let a = [1u8, 2, 3];\n+    let b = a.map(|v| v as u64);\n+    assert_eq!(b, [1, 2, 3]);\n+}\n+\n+// See note on above test for why `should_panic` is used.\n+#[test]\n+#[should_panic(expected = \"test succeeded\")]\n+fn array_map_drop_safety() {\n+    use core::sync::atomic::AtomicUsize;\n+    use core::sync::atomic::Ordering;\n+    static DROPPED: AtomicUsize = AtomicUsize::new(0);\n+    struct DropCounter;\n+    impl Drop for DropCounter {\n+        fn drop(&mut self) {\n+            DROPPED.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let num_to_create = 5;\n+    let success = std::panic::catch_unwind(|| {\n+        let items = [0; 10];\n+        let mut nth = 0;\n+        items.map(|_| {\n+            assert!(nth < num_to_create);\n+            nth += 1;\n+            DropCounter\n+        });\n+    });\n+    assert!(success.is_err());\n+    assert_eq!(DROPPED.load(Ordering::SeqCst), num_to_create);\n+    panic!(\"test succeeded\")\n+}"}, {"sha": "904e3f7284049b982ae68af411759276dc6eb3b4", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,5 +1,6 @@\n #![feature(alloc_layout_extra)]\n #![feature(array_chunks)]\n+#![feature(array_map)]\n #![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]"}, {"sha": "ef0ef415b4cbab4bbc00d7dbf5e8b86b00c627fd", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,7 +16,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.74\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.32\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "11b3f22503e83c6c6c8a474efb6519e94884ebd5", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 83, "deletions": 149, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,3 +1,4 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n use crate::ascii;\n use crate::borrow::{Borrow, Cow};\n use crate::cmp::Ordering;\n@@ -35,23 +36,23 @@ use crate::sys;\n /// example, you can build a `CString` straight out of a [`String`] or\n /// a [`&str`], since both implement that trait).\n ///\n-/// The [`new`] method will actually check that the provided `&[u8]`\n+/// The [`CString::new`] method will actually check that the provided `&[u8]`\n /// does not have 0 bytes in the middle, and return an error if it\n /// finds one.\n ///\n /// # Extracting a raw pointer to the whole C string\n ///\n-/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// `CString` implements a [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n /// trait. This method will give you a `*const c_char` which you can\n /// feed directly to extern functions that expect a nul-terminated\n-/// string, like C's `strdup()`. Notice that [`as_ptr`] returns a\n+/// string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n /// read-only pointer; if the C code writes to it, that causes\n /// undefined behavior.\n ///\n /// # Extracting a slice of the whole C string\n ///\n /// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n-/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// `CString` with the [`CString::as_bytes`] method. Slices produced in this\n /// way do *not* contain the trailing nul terminator. This is useful\n /// when you will be calling an extern function that takes a `*const\n /// u8` argument which is not necessarily nul-terminated, plus another\n@@ -60,28 +61,19 @@ use crate::sys;\n /// [`len`][slice.len] method.\n ///\n /// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n-/// can use [`as_bytes_with_nul`] instead.\n+/// can use [`CString::as_bytes_with_nul`] instead.\n ///\n /// Once you have the kind of slice you need (with or without a nul\n /// terminator), you can call the slice's own\n /// [`as_ptr`][slice.as_ptr] method to get a read-only raw pointer to pass to\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n-/// [`Into`]: ../convert/trait.Into.html\n-/// [`Vec`]: ../vec/struct.Vec.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`new`]: #method.new\n-/// [`as_bytes`]: #method.as_bytes\n-/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n-/// [`as_ptr`]: #method.as_ptr\n+/// [`&str`]: str\n /// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n /// [slice.len]: ../primitive.slice.html#method.len\n-/// [`Deref`]: ../ops/trait.Deref.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`&CStr`]: struct.CStr.html\n+/// [`Deref`]: ops::Deref\n+/// [`&CStr`]: CStr\n ///\n /// # Examples\n ///\n@@ -113,7 +105,6 @@ use crate::sys;\n /// documentation of `CString` before use, as improper ownership management\n /// of `CString` instances can lead to invalid memory accesses, memory leaks,\n /// and other memory errors.\n-\n #[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CString {\n@@ -137,8 +128,8 @@ pub struct CString {\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n /// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n-/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n-/// interface to other consumers.\n+/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n+/// a safe interface to other consumers.\n ///\n /// # Examples\n ///\n@@ -189,11 +180,7 @@ pub struct CString {\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n ///\n-/// [`u8`]: ../primitive.u8.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`from_ptr`]: #method.from_ptr\n+/// [`&str`]: str\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -218,9 +205,6 @@ pub struct CStr {\n /// This error is created by the [`new`][`CString::new`] method on\n /// [`CString`]. See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`CString::new`]: struct.CString.html#method.new\n-///\n /// # Examples\n ///\n /// ```\n@@ -237,12 +221,9 @@ pub struct NulError(usize, Vec<u8>);\n /// The slice used to create a [`CStr`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_bytes_with_nul`] method on [`CStr`].\n+/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CStr`]: struct.CStr.html\n-/// [`from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -261,12 +242,9 @@ pub struct FromBytesWithNulError {\n /// The vector used to create a [`CString`] must have one and only one nul byte,\n /// positioned at the end.\n ///\n-/// This error is created by the [`from_vec_with_nul`] method on [`CString`].\n+/// This error is created by the [`CString::from_vec_with_nul`] method.\n /// See its documentation for more.\n ///\n-/// [`CString`]: struct.CString.html\n-/// [`from_vec_with_nul`]: struct.CString.html#method.from_vec_with_nul\n-///\n /// # Examples\n ///\n /// ```\n@@ -316,8 +294,6 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }\n@@ -343,26 +319,19 @@ impl FromVecWithNulError {\n     ///\n     /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n     /// ```\n-    ///\n-    /// [`CString`]: struct.CString.html\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.bytes\n     }\n }\n \n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n-/// `CString` is just a wrapper over a buffer of bytes with a nul\n-/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n-/// validation on those bytes and may return this error.\n+/// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n+/// [`CString::into_string`] performs UTF-8 validation on those bytes and may\n+/// return this error.\n ///\n-/// This `struct` is created by the\n-/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// This `struct` is created by [`CString::into_string()`]. See\n /// its documentation for more.\n-///\n-/// [`String`]: ../string/struct.String.html\n-/// [`CString`]: struct.CString.html\n-/// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n@@ -398,8 +367,6 @@ impl CString {\n     /// This function will return an error if the supplied bytes contain an\n     /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n-    ///\n-    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         trait SpecIntoVec {\n@@ -439,11 +406,9 @@ impl CString {\n     /// Creates a C-compatible string by consuming a byte vector,\n     /// without checking for interior 0 bytes.\n     ///\n-    /// This method is equivalent to [`new`] except that no runtime assertion\n-    /// is made that `v` contains no 0 bytes, and it requires an actual\n-    /// byte vector, not anything that can be converted to one with Into.\n-    ///\n-    /// [`new`]: #method.new\n+    /// This method is equivalent to [`CString::new`] except that no runtime\n+    /// assertion is made that `v` contains no 0 bytes, and it requires an\n+    /// actual byte vector, not anything that can be converted to one with Into.\n     ///\n     /// # Examples\n     ///\n@@ -462,21 +427,22 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n+    /// Retakes ownership of a `CString` that was transferred to C via\n+    /// [`CString::into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n     /// # Safety\n     ///\n     /// This should only ever be called with a pointer that was earlier\n-    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g., trying to take\n+    /// obtained by calling [`CString::into_raw`]. Other usage (e.g., trying to take\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n     /// It should be noted that the length isn't just \"recomputed,\" but that\n     /// the recomputed length must match the original length from the\n-    /// [`into_raw`] call. This means the [`into_raw`]/`from_raw` methods\n-    /// should not be used when passing the string to C functions that can\n+    /// [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n+    /// methods should not be used when passing the string to C functions that can\n     /// modify the string's length.\n     ///\n     /// > **Note:** If you need to borrow a string that was allocated by\n@@ -485,9 +451,6 @@ impl CString {\n     /// > make your own provisions for freeing it appropriately, likely\n     /// > with the foreign code's API to do that.\n     ///\n-    /// [`into_raw`]: #method.into_raw\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n@@ -510,26 +473,31 @@ impl CString {\n     /// ```\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n-        let len = sys::strlen(ptr) + 1; // Including the NUL byte\n-        let slice = slice::from_raw_parts_mut(ptr, len as usize);\n-        CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n+        // SAFETY: This is called with a pointer that was obtained from a call\n+        // to `CString::into_raw` and the length has not been modified. As such,\n+        // we know there is a NUL byte (and only one) at the end and that the\n+        // information about the size of the allocation is correct on Rust's\n+        // side.\n+        unsafe {\n+            let len = sys::strlen(ptr) + 1; // Including the NUL byte\n+            let slice = slice::from_raw_parts_mut(ptr, len as usize);\n+            CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n+        }\n     }\n \n     /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n     /// The pointer which this function returns must be returned to Rust and reconstituted using\n-    /// [`from_raw`] to be properly deallocated. Specifically, one\n+    /// [`CString::from_raw`] to be properly deallocated. Specifically, one\n     /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n-    /// Failure to call [`from_raw`] will lead to a memory leak.\n+    /// Failure to call [`CString::from_raw`] will lead to a memory leak.\n     ///\n     /// The C side must **not** modify the length of the string (by writing a\n     /// `NULL` somewhere inside the string or removing the final one) before\n-    /// it makes it back into Rust using [`from_raw`]. See the safety section\n-    /// in [`from_raw`].\n-    ///\n-    /// [`from_raw`]: #method.from_raw\n+    /// it makes it back into Rust using [`CString::from_raw`]. See the safety section\n+    /// in [`CString::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -560,8 +528,6 @@ impl CString {\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n-    /// [`String`]: ../string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -608,10 +574,8 @@ impl CString {\n         vec\n     }\n \n-    /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`into_bytes`]: #method.into_bytes\n+    /// Equivalent to [`CString::into_bytes()`] except that the\n+    /// returned vector includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -632,9 +596,7 @@ impl CString {\n     /// The returned slice does **not** contain the trailing nul\n     /// terminator, and it is guaranteed to not have any interior nul\n     /// bytes. If you need the nul terminator, use\n-    /// [`as_bytes_with_nul`] instead.\n-    ///\n-    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+    /// [`CString::as_bytes_with_nul`] instead.\n     ///\n     /// # Examples\n     ///\n@@ -651,10 +613,8 @@ impl CString {\n         &self.inner[..self.inner.len() - 1]\n     }\n \n-    /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul terminator.\n-    ///\n-    /// [`as_bytes`]: #method.as_bytes\n+    /// Equivalent to [`CString::as_bytes()`] except that the\n+    /// returned slice includes the trailing nul terminator.\n     ///\n     /// # Examples\n     ///\n@@ -673,8 +633,6 @@ impl CString {\n \n     /// Extracts a [`CStr`] slice containing the entire string.\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -693,8 +651,6 @@ impl CString {\n \n     /// Converts this `CString` into a boxed [`CStr`].\n     ///\n-    /// [`CStr`]: struct.CStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -711,8 +667,6 @@ impl CString {\n     }\n \n     /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n-    ///\n-    /// [`Drop`]: ../ops/trait.Drop.html\n     fn into_inner(self) -> Box<[u8]> {\n         // Rationale: `mem::forget(self)` invalidates the previous call to `ptr::read(&self.inner)`\n         // so we use `ManuallyDrop` to ensure `self` is not dropped.\n@@ -722,12 +676,12 @@ impl CString {\n         unsafe { ptr::read(&this.inner) }\n     }\n \n-    /// Converts a `Vec` of `u8` to a `CString` without checking the invariants\n-    /// on the given `Vec`.\n+    /// Converts a [`Vec`]`<u8>` to a [`CString`] without checking the\n+    /// invariants on the given [`Vec`].\n     ///\n     /// # Safety\n     ///\n-    /// The given `Vec` **must** have one nul byte as its last element.\n+    /// The given [`Vec`] **must** have one nul byte as its last element.\n     /// This means it cannot be empty nor have any other nul byte anywhere else.\n     ///\n     /// # Example\n@@ -745,10 +699,10 @@ impl CString {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n-    /// Attempts to converts a `Vec` of `u8` to a `CString`.\n+    /// Attempts to converts a [`Vec`]`<u8>` to a [`CString`].\n     ///\n     /// Runtime checks are present to ensure there is only one nul byte in the\n-    /// `Vec`, its last element.\n+    /// [`Vec`], its last element.\n     ///\n     /// # Errors\n     ///\n@@ -757,8 +711,8 @@ impl CString {\n     ///\n     /// # Examples\n     ///\n-    /// A successful conversion will produce the same result as [`new`] when\n-    /// called without the ending nul byte.\n+    /// A successful conversion will produce the same result as [`CString::new`]\n+    /// when called without the ending nul byte.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -770,7 +724,7 @@ impl CString {\n     /// );\n     /// ```\n     ///\n-    /// A incorrectly formatted vector will produce an error.\n+    /// A incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n     /// #![feature(cstring_from_vec_with_nul)]\n@@ -780,8 +734,6 @@ impl CString {\n     /// // No nul byte\n     /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n     /// ```\n-    ///\n-    /// [`new`]: #method.new\n     #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n     pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n         let nul_pos = memchr::memchr(0, &v);\n@@ -838,9 +790,6 @@ impl From<CString> for Vec<u8> {\n     /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n     ///\n     /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n-    ///\n-    /// [`Vec`]: ../vec/struct.Vec.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: CString) -> Vec<u8> {\n         s.into_bytes()\n@@ -913,9 +862,6 @@ impl From<Cow<'_, CStr>> for Box<CStr> {\n #[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\n impl From<Box<CStr>> for CString {\n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n         s.into_c_string()\n@@ -926,10 +872,6 @@ impl From<Box<CStr>> for CString {\n impl From<Vec<NonZeroU8>> for CString {\n     /// Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without\n     /// copying nor checking for inner null bytes.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`NonZeroU8`]: ../num/struct.NonZeroU8.html\n-    /// [`Vec`]: ../vec/struct.Vec.html\n     #[inline]\n     fn from(v: Vec<NonZeroU8>) -> CString {\n         unsafe {\n@@ -959,9 +901,6 @@ impl Clone for Box<CStr> {\n #[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n impl From<CString> for Box<CStr> {\n     /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Box`]: ../boxed/struct.Box.html\n     #[inline]\n     fn from(s: CString) -> Box<CStr> {\n         s.into_boxed_c_str()\n@@ -995,9 +934,6 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n     /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Arc`]: ../sync/struct.Arc.html\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());\n@@ -1017,9 +953,6 @@ impl From<&CStr> for Arc<CStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n     /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n-    ///\n-    /// [`CString`]: ../ffi/struct.CString.html\n-    /// [`Rc`]: ../rc/struct.Rc.html\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());\n@@ -1048,8 +981,6 @@ impl NulError {\n     /// Returns the position of the nul byte in the slice that caused\n     /// [`CString::new`] to fail.\n     ///\n-    /// [`CString::new`]: struct.CString.html#method.new\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1101,9 +1032,6 @@ impl fmt::Display for NulError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n-    ///\n-    /// [`NulError`]: ../ffi/struct.NulError.html\n-    /// [`io::Error`]: ../io/struct.Error.html\n     fn from(_: NulError) -> io::Error {\n         io::Error::new(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n     }\n@@ -1154,8 +1082,6 @@ impl fmt::Display for FromVecWithNulError {\n impl IntoStringError {\n     /// Consumes this error, returning original [`CString`] which generated the\n     /// error.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_cstring(self) -> CString {\n         self.inner\n@@ -1228,9 +1154,21 @@ impl CStr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n-        let len = sys::strlen(ptr);\n-        let ptr = ptr as *const u8;\n-        CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+        // SAFETY: The caller has provided a pointer that points to a valid C\n+        // string with a NUL terminator of size less than `isize::MAX`, whose\n+        // content remain valid and doesn't change for the lifetime of the\n+        // returned `CStr`.\n+        //\n+        // Thus computing the length is fine (a NUL byte exists), the call to\n+        // from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning\n+        // the call to `from_bytes_with_nul_unchecked` is correct.\n+        //\n+        // The cast from c_char to u8 is ok because a c_char is always one byte.\n+        unsafe {\n+            let len = sys::strlen(ptr);\n+            let ptr = ptr as *const u8;\n+            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+        }\n     }\n \n     /// Creates a C string wrapper from a byte slice.\n@@ -1299,7 +1237,12 @@ impl CStr {\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_unstable(feature = \"const_cstr_unchecked\", issue = \"none\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        &*(bytes as *const [u8] as *const CStr)\n+        // SAFETY: Casting to CStr is safe because its internal representation\n+        // is a [u8] too (safe only inside std).\n+        // Dereferencing the obtained pointer is safe because it comes from a\n+        // reference. Making a reference is then safe because its lifetime\n+        // is bound by the lifetime of the given `bytes`.\n+        unsafe { &*(bytes as *const [u8] as *const CStr) }\n     }\n \n     /// Returns the inner pointer to this C string.\n@@ -1330,7 +1273,8 @@ impl CStr {\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n     /// lifetime information and the [`CString`] is deallocated immediately after\n-    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.\n+    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n+    /// expression is evaluated.\n     /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n@@ -1345,10 +1289,8 @@ impl CStr {\n     /// }\n     /// ```\n     ///\n-    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// This way, the lifetime of the [`CString`] in `hello` encompasses\n     /// the lifetime of `ptr` and the `unsafe` block.\n-    ///\n-    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n@@ -1382,15 +1324,13 @@ impl CStr {\n \n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n-    /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul terminator instead of chopping it off.\n+    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n+    /// will retain the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n     ///\n-    /// [`to_bytes`]: #method.to_bytes\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1411,7 +1351,7 @@ impl CStr {\n     /// function will return the corresponding [`&str`] slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -1439,12 +1379,9 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n-    /// [`Cow`]: ../borrow/enum.Cow.html\n-    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n-    /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned\n-    /// [`str`]: ../primitive.str.html\n-    /// [`String`]: ../string/struct.String.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`Borrowed`]: Cow::Borrowed\n+    /// [`Owned`]: Cow::Owned\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -1479,9 +1416,6 @@ impl CStr {\n \n     /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n     ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`CString`]: struct.CString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "0184495eecf09ffdf59ca11148b34f41f974acd1", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -88,7 +88,7 @@\n //! [`env::var_os()`] is used to query environment variables; it\n //! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n //! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n-//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! convert to a Rust string. This yields a [`Result`], so that\n //! your code can detect errors in case the environment variable did\n //! not in fact contain valid Unicode data.\n //!\n@@ -124,34 +124,22 @@\n //! method is an [`OsString`] which can be round-tripped to a Windows\n //! string losslessly.\n //!\n-//! [`String`]: ../string/struct.String.html\n-//! [`str`]: ../primitive.str.html\n-//! [`char`]: ../primitive.char.html\n-//! [`u8`]: ../primitive.u8.html\n-//! [`u16`]: ../primitive.u16.html\n //! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n-//! [`CString`]: struct.CString.html\n-//! [`CStr`]: struct.CStr.html\n-//! [`OsString`]: struct.OsString.html\n-//! [`OsStr`]: struct.OsStr.html\n-//! [`env::set_var()`]: ../env/fn.set_var.html\n-//! [`env::var_os()`]: ../env/fn.var_os.html\n-//! [`Result<>`]: ../result/enum.Result.html\n-//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n-//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n-//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n-//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n-//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n-//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n-//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n-//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n-//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n-//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n-//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n-//! [`Option`]: ../option/enum.Option.html\n-//! [`Some`]: ../option/enum.Option.html#variant.Some\n+//! [`env::set_var()`]: crate::env::set_var\n+//! [`env::var_os()`]: crate::env::var_os\n+//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt\n+//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec\n+//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec\n+//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt\n+//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes\n+//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes\n+//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt\n+//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt\n+//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide\n+//! [`collect`]: crate::iter::Iterator::collect\n+//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt\n+//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "262d39d98ee2ecc66790141c9cb2b11fe3b96162", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 15, "deletions": 64, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -47,14 +47,14 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// create an `OsString` from a normal Rust string.\n ///\n /// **From slices:** Just like you can start with an empty Rust\n-/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// [`String`] and then [`String::push_str`] `&str`\n /// sub-string slices into it, you can create an empty `OsString` with\n-/// the [`new`] method and then push string slices into it with the\n-/// [`push`] method.\n+/// the [`OsString::new`] method and then push string slices into it with the\n+/// [`OsString::push`] method.\n ///\n /// # Extracting a borrowed reference to the whole OS string\n ///\n-/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from\n /// an `OsString`; this is effectively a borrowed reference to the\n /// whole string.\n ///\n@@ -63,18 +63,9 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsString` implements for [conversions] from/to native representations.\n ///\n-/// [`OsStr`]: struct.OsStr.html\n-/// [`&OsStr`]: struct.OsStr.html\n-/// [`CStr`]: struct.CStr.html\n-/// [`From`]: ../convert/trait.From.html\n-/// [`String`]: ../string/struct.String.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`u8`]: ../primitive.u8.html\n-/// [`u16`]: ../primitive.u16.html\n-/// [String.push_str]: ../string/struct.String.html#method.push_str\n-/// [`new`]: #method.new\n-/// [`push`]: #method.push\n-/// [`as_os_str`]: #method.as_os_str\n+/// [`&OsStr`]: OsStr\n+/// [`&str`]: str\n+/// [`CStr`]: crate::ffi::CStr\n /// [conversions]: index.html#conversions\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -93,9 +84,7 @@ pub struct OsString {\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsStr` implements for [conversions] from/to native representations.\n ///\n-/// [`OsString`]: struct.OsString.html\n-/// [`&str`]: ../primitive.str.html\n-/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: str\n /// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -125,8 +114,6 @@ impl OsString {\n \n     /// Converts to an [`OsStr`] slice.\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -145,8 +132,6 @@ impl OsString {\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -163,7 +148,7 @@ impl OsString {\n \n     /// Extends the string with the given [`&OsStr`] slice.\n     ///\n-    /// [`&OsStr`]: struct.OsStr.html\n+    /// [`&OsStr`]: OsStr\n     ///\n     /// # Examples\n     ///\n@@ -333,8 +318,6 @@ impl OsString {\n \n     /// Converts this `OsString` into a boxed [`OsStr`].\n     ///\n-    /// [`OsStr`]: struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -356,8 +339,6 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n-    ///\n-    /// [`OsString`]: ../../std/ffi/struct.OsString.html\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -544,7 +525,7 @@ impl OsStr {\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     ///\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -564,9 +545,7 @@ impl OsStr {\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n     ///\n-    /// [`Cow`]: ../../std/borrow/enum.Cow.html\n-    /// [`str`]: ../../std/primitive.str.html\n-    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -613,8 +592,6 @@ impl OsStr {\n \n     /// Copies the slice into an owned [`OsString`].\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -662,9 +639,6 @@ impl OsStr {\n     /// This number is simply useful for passing to other methods, like\n     /// [`OsString::with_capacity`] to avoid reallocations.\n     ///\n-    /// [`OsString`]: struct.OsString.html\n-    /// [`OsString::with_capacity`]: struct.OsString.html#method.with_capacity\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -682,9 +656,6 @@ impl OsStr {\n     }\n \n     /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: struct.OsString.html\n     #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n     pub fn into_os_string(self: Box<OsStr>) -> OsString {\n         let boxed = unsafe { Box::from_raw(Box::into_raw(self) as *mut Slice) };\n@@ -706,9 +677,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new lowercased value without modifying the existing one, use\n-    /// [`to_ascii_lowercase`].\n-    ///\n-    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    /// [`OsStr::to_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -733,9 +702,7 @@ impl OsStr {\n     /// but non-ASCII letters are unchanged.\n     ///\n     /// To return a new uppercased value without modifying the existing one, use\n-    /// [`to_ascii_uppercase`].\n-    ///\n-    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    /// [`OsStr::to_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -760,9 +727,7 @@ impl OsStr {\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n-    ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// To lowercase the value in-place, use [`OsStr::make_ascii_lowercase`].\n     ///\n     /// # Examples\n     ///\n@@ -784,9 +749,7 @@ impl OsStr {\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n-    ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// To uppercase the value in-place, use [`OsStr::make_ascii_uppercase`].\n     ///\n     /// # Examples\n     ///\n@@ -865,9 +828,6 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n impl From<Box<OsStr>> for OsString {\n     /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n     /// allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n@@ -876,9 +836,6 @@ impl From<Box<OsStr>> for OsString {\n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n     /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Box`]: ../boxed/struct.Box.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -895,9 +852,6 @@ impl Clone for Box<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n     /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Arc`]: ../sync/struct.Arc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -917,9 +871,6 @@ impl From<&OsStr> for Arc<OsStr> {\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n     /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n-    ///\n-    /// [`Rc`]: ../rc/struct.Rc.html\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "e90ee5c285f2f5ca8d5af091914c8bcb1b3792fe", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1212,7 +1212,7 @@ impl Initializer {\n ///\n /// [`write`]: Self::write\n /// [`flush`]: Self::flush\n-/// [`std::io`]: index.html\n+/// [`std::io`]: self\n ///\n /// # Examples\n ///\n@@ -1590,8 +1590,6 @@ pub trait Seek {\n     /// # Errors\n     ///\n     /// Seeking to a negative offset is considered an error.\n-    ///\n-    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n \n@@ -1678,8 +1676,6 @@ pub trait Seek {\n /// Enumeration of possible methods to seek within an I/O object.\n ///\n /// It is used by the [`Seek`] trait.\n-///\n-/// [`Seek`]: trait.Seek.html\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SeekFrom {\n@@ -1759,11 +1755,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// For example, [`File`] implements [`Read`], but not `BufRead`.\n /// [`BufReader`] to the rescue!\n ///\n-/// [`BufReader`]: struct.BufReader.html\n /// [`File`]: crate::fs::File\n /// [`read_line`]: Self::read_line\n /// [`lines`]: Self::lines\n-/// [`Read`]: trait.Read.html\n ///\n /// ```no_run\n /// use std::io::{self, BufReader};\n@@ -1869,16 +1863,13 @@ pub trait BufRead: Read {\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n     /// [`fill_buf`]: Self::fill_buf\n-    /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n     /// # Examples\n     ///\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n     /// in hyphen delimited segments:\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -1940,8 +1931,6 @@ pub trait BufRead: Read {\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -1996,8 +1985,6 @@ pub trait BufRead: Read {\n     /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n     /// segments in a byte slice\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -2046,8 +2033,6 @@ pub trait BufRead: Read {\n     /// # Errors\n     ///\n     /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n-    ///\n-    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self>\n     where\n@@ -2062,7 +2047,7 @@ pub trait BufRead: Read {\n /// This struct is generally created by calling [`chain`] on a reader.\n /// Please see the documentation of [`chain`] for more details.\n ///\n-/// [`chain`]: trait.Read.html#method.chain\n+/// [`chain`]: Read::chain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<T, U> {\n     first: T,\n@@ -2204,7 +2189,7 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n /// This struct is generally created by calling [`take`] on a reader.\n /// Please see the documentation of [`take`] for more details.\n ///\n-/// [`take`]: trait.Read.html#method.take\n+/// [`take`]: Read::take\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Take<T> {\n@@ -2403,7 +2388,7 @@ impl<T: BufRead> BufRead for Take<T> {\n /// This struct is generally created by calling [`bytes`] on a reader.\n /// Please see the documentation of [`bytes`] for more details.\n ///\n-/// [`bytes`]: trait.Read.html#method.bytes\n+/// [`bytes`]: Read::bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Bytes<R> {\n@@ -2433,7 +2418,7 @@ impl<R: Read> Iterator for Bytes<R> {\n /// This struct is generally created by calling [`split`] on a `BufRead`.\n /// Please see the documentation of [`split`] for more details.\n ///\n-/// [`split`]: trait.BufRead.html#method.split\n+/// [`split`]: BufRead::split\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Split<B> {\n@@ -2465,7 +2450,7 @@ impl<B: BufRead> Iterator for Split<B> {\n /// This struct is generally created by calling [`lines`] on a `BufRead`.\n /// Please see the documentation of [`lines`] for more details.\n ///\n-/// [`lines`]: trait.BufRead.html#method.lines\n+/// [`lines`]: BufRead::lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Lines<B> {"}, {"sha": "c39989a60c92b5c62d4615de8c46192064f45963", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 181, "deletions": 3, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1813,12 +1813,190 @@ mod type_keyword {}\n \n #[doc(keyword = \"unsafe\")]\n //\n-/// Code or interfaces whose [memory safety] cannot be verified by the type system.\n+/// Code or interfaces whose [memory safety] cannot be verified by the type\n+/// system.\n+///\n+/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n+/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n+/// programmer has checked that these contracts have been upheld (`unsafe {}`\n+/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n+/// exclusive, as can be seen in `unsafe fn`.\n+///\n+/// # Unsafe abilities\n+///\n+/// **No matter what, Safe Rust can't cause Undefined Behavior**. This is\n+/// referred to as [soundness]: a well-typed program actually has the desired\n+/// properties. The [Nomicon][nomicon-soundness] has a more detailed explanation\n+/// on the subject.\n+///\n+/// To ensure soundness, Safe Rust is restricted enough that it can be\n+/// automatically checked. Sometimes, however, it is necessary to write code\n+/// that is correct for reasons which are too clever for the compiler to\n+/// understand. In those cases, you need to use Unsafe Rust.\n+///\n+/// Here are the abilities Unsafe Rust has in addition to Safe Rust:\n+///\n+/// - Dereference [raw pointers]\n+/// - Implement `unsafe` [`trait`]s\n+/// - Call `unsafe` functions\n+/// - Mutate [`static`]s (including [`extern`]al ones)\n+/// - Access fields of [`union`]s\n+///\n+/// However, this extra power comes with extra responsibilities: it is now up to\n+/// you to ensure soundness. The `unsafe` keyword helps by clearly marking the\n+/// pieces of code that need to worry about this.\n+///\n+/// ## The different meanings of `unsafe`\n+///\n+/// Not all uses of `unsafe` are equivalent: some are here to mark the existence\n+/// of a contract the programmer must check, others are to say \"I have checked\n+/// the contract, go ahead and do this\". The following\n+/// [discussion on Rust Internals] has more in-depth explanations about this but\n+/// here is a summary of the main points:\n+///\n+/// - `unsafe fn`: calling this function means abiding by a contract the\n+/// compiler cannot enforce.\n+/// - `unsafe trait`: implementing the [`trait`] means abiding by a\n+/// contract the compiler cannot enforce.\n+/// - `unsafe {}`: the contract necessary to call the operations inside the\n+/// block has been checked by the programmer and is guaranteed to be respected.\n+/// - `unsafe impl`: the contract necessary to implement the trait has been\n+/// checked by the programmer and is guaranteed to be respected.\n+///\n+/// `unsafe fn` also acts like an `unsafe {}` block\n+/// around the code inside the function. This means it is not just a signal to\n+/// the caller, but also promises that the preconditions for the operations\n+/// inside the function are upheld. Mixing these two meanings can be confusing\n+/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n+/// making `unsafe` operations.\n+///\n+/// See the [Rustnomicon] and the [Reference] for more informations.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// # Examples\n+///\n+/// ## Marking elements as `unsafe`\n+///\n+/// `unsafe` can be used on functions. Note that functions and statics declared\n+/// in [`extern`] blocks are implicitly marked as `unsafe` (but not functions\n+/// declared as `extern \"something\" fn ...`). Mutable statics are always unsafe,\n+/// wherever they are declared. Methods can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// static mut FOO: &str = \"hello\";\n+///\n+/// unsafe fn unsafe_fn() {}\n+///\n+/// extern \"C\" {\n+///     fn unsafe_extern_fn();\n+///     static BAR: *mut u32;\n+/// }\n+///\n+/// trait SafeTraitWithUnsafeMethod {\n+///     unsafe fn unsafe_method(&self);\n+/// }\n+///\n+/// struct S;\n+///\n+/// impl S {\n+///     unsafe fn unsafe_method_on_struct() {}\n+/// }\n+/// ```\n+///\n+/// Traits can also be declared as `unsafe`:\n+///\n+/// ```rust\n+/// unsafe trait UnsafeTrait {}\n+/// ```\n ///\n+/// Since `unsafe fn` and `unsafe trait` indicate that there is a safety\n+/// contract that the compiler cannot enforce, documenting it is important. The\n+/// standard library has many examples of this, like the following which is an\n+/// extract from [`Vec::set_len`]. The `# Safety` section explains the contract\n+/// that must be fulfilled to safely call the function.\n+///\n+/// ```rust,ignore (stub-to-show-doc-example)\n+/// /// Forces the length of the vector to `new_len`.\n+/// ///\n+/// /// This is a low-level operation that maintains none of the normal\n+/// /// invariants of the type. Normally changing the length of a vector\n+/// /// is done using one of the safe operations instead, such as\n+/// /// `truncate`, `resize`, `extend`, or `clear`.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// - `new_len` must be less than or equal to `capacity()`.\n+/// /// - The elements at `old_len..new_len` must be initialized.\n+/// pub unsafe fn set_len(&mut self, new_len: usize)\n+/// ```\n+///\n+/// ## Using `unsafe {}` blocks and `impl`s\n+///\n+/// Performing `unsafe` operations requires an `unsafe {}` block:\n+///\n+/// ```rust\n+/// # #![allow(dead_code)]\n+/// /// Dereference the given pointer.\n+/// ///\n+/// /// # Safety\n+/// ///\n+/// /// `ptr` must be aligned and must not be dangling.\n+/// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n+///     *ptr\n+/// }\n+///\n+/// let a = 3;\n+/// let b = &a as *const _;\n+/// // SAFETY: `a` has not been dropped and references are always aligned,\n+/// // so `b` is a valid address.\n+/// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n+/// ```\n+///\n+/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n+/// makes a guarantee to other `unsafe` code that the implementation satisfies\n+/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n+/// this behaviour in the standard library.\n+///\n+/// ```rust\n+/// /// Implementors of this trait must guarantee an element is always\n+/// /// accessible with index 3.\n+/// unsafe trait ThreeIndexable<T> {\n+///     /// Returns a reference to the element with index 3 in `&self`.\n+///     fn three(&self) -> &T;\n+/// }\n+///\n+/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n+/// // because the implementor must abide by a contract the compiler cannot\n+/// // check but as a programmer we know there will always be a valid element\n+/// // at index 3 to access.\n+/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n+///     fn three(&self) -> &T {\n+///         // SAFETY: implementing the trait means there always is an element\n+///         // with index 3 accessible.\n+///         unsafe { self.get_unchecked(3) }\n+///     }\n+/// }\n+///\n+/// let a = [1, 2, 4, 8];\n+/// assert_eq!(a.three(), &8);\n+/// ```\n+///\n+/// [`extern`]: keyword.extern.html\n+/// [`trait`]: keyword.trait.html\n+/// [`static`]: keyword.static.html\n+/// [`union`]: keyword.union.html\n+/// [`impl`]: keyword.impl.html\n+/// [Send]: marker/trait.Send.html\n+/// [Sync]: marker/trait.Sync.html\n+/// [`Vec::set_len`]: vec/struct.Vec.html#method.set_len\n+/// [raw pointers]: ../reference/types/pointer.html\n /// [memory safety]: ../book/ch19-01-unsafe-rust.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// [Rustnomicon]: ../nomicon/index.html\n+/// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n+/// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n+/// [Reference]: ../reference/unsafety.html\n+/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n+/// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n \n #[doc(keyword = \"use\")]"}, {"sha": "1144a13b52c30b377a806a4e075891bd82711355", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -22,7 +22,7 @@\n //! * [`std::*` modules](#modules)\n //! * [Primitive types](#primitives)\n //! * [Standard macros](#macros)\n-//! * [The Rust Prelude](prelude/index.html)\n+//! * [The Rust Prelude]\n //!\n //! If this is your first time, the documentation for the standard library is\n //! written to be casually perused. Clicking on interesting things should\n@@ -63,8 +63,8 @@\n //! So for example there is a [page for the primitive type\n //! `i32`](primitive.i32.html) that lists all the methods that can be called on\n //! 32-bit integers (very useful), and there is a [page for the module\n-//! `std::i32`](i32/index.html) that documents the constant values [`MIN`] and\n-//! [`MAX`](i32/constant.MAX.html) (rarely useful).\n+//! `std::i32`] that documents the constant values [`MIN`] and [`MAX`] (rarely\n+//! useful).\n //!\n //! Note the documentation for the primitives [`str`] and [`[T]`][slice] (also\n //! called 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\n@@ -152,48 +152,35 @@\n //! contains further primitive shared memory types, including [`atomic`] and\n //! [`mpsc`], which contains the channel types for message passing.\n //!\n-//! [I/O]: io/index.html\n-//! [`MIN`]: i32/constant.MIN.html\n-//! [TCP]: net/struct.TcpStream.html\n-//! [The Rust Prelude]: prelude/index.html\n-//! [UDP]: net/struct.UdpSocket.html\n-//! [`Arc`]: sync/struct.Arc.html\n-//! [owned slice]: boxed/index.html\n-//! [`Cell`]: cell/struct.Cell.html\n-//! [`FromStr`]: str/trait.FromStr.html\n-//! [`HashMap<K, V>`]: collections/struct.HashMap.html\n-//! [`Iterator`]: iter/trait.Iterator.html\n-//! [`Mutex`]: sync/struct.Mutex.html\n-//! [`Option<T>`]: option/enum.Option.html\n-//! [`Rc`]: rc/struct.Rc.html\n-//! [`RefCell`]: cell/struct.RefCell.html\n-//! [`Result<T, E>`]: result/enum.Result.html\n-//! [`String`]: string/struct.String.html\n-//! [`Vec<T>`]: vec/struct.Vec.html\n-//! [array]: primitive.array.html\n-//! [slice]: primitive.slice.html\n-//! [`atomic`]: sync/atomic/index.html\n-//! [`collections`]: collections/index.html\n+//! [I/O]: io\n+//! [`MIN`]: i32::MIN\n+//! [`MAX`]: i32::MAX\n+//! [page for the module `std::i32`]: crate::i32\n+//! [TCP]: net::TcpStream\n+//! [The Rust Prelude]: prelude\n+//! [UDP]: net::UdpSocket\n+//! [`Arc`]: sync::Arc\n+//! [owned slice]: boxed\n+//! [`Cell`]: cell::Cell\n+//! [`FromStr`]: str::FromStr\n+//! [`HashMap<K, V>`]: collections::HashMap\n+//! [`Mutex`]: sync::Mutex\n+//! [`Option<T>`]: option::Option\n+//! [`Rc`]: rc::Rc\n+//! [`RefCell`]: cell::RefCell\n+//! [`Result<T, E>`]: result::Result\n+//! [`Vec<T>`]: vec::Vec\n+//! [`atomic`]: sync::atomic\n //! [`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n-//! [`format!`]: macro.format.html\n-//! [`fs`]: fs/index.html\n-//! [`io`]: io/index.html\n-//! [`iter`]: iter/index.html\n-//! [`mpsc`]: sync/mpsc/index.html\n-//! [`net`]: net/index.html\n-//! [`option`]: option/index.html\n-//! [`result`]: result/index.html\n-//! [`std::cmp`]: cmp/index.html\n-//! [`std::slice`]: slice/index.html\n-//! [`str`]: primitive.str.html\n-//! [`sync`]: sync/index.html\n-//! [`thread`]: thread/index.html\n+//! [`mpsc`]: sync::mpsc\n+//! [`std::cmp`]: cmp\n+//! [`std::slice`]: slice\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n //! [crates.io]: https://crates.io\n //! [deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n-//! [files]: fs/struct.File.html\n-//! [multithreading]: thread/index.html\n+//! [files]: fs::File\n+//! [multithreading]: thread\n //! [other]: #what-is-in-the-standard-library-documentation\n //! [primitive types]: ../book/ch03-02-data-types.html\n //! [rust-discord]: https://discord.gg/rust-lang\n@@ -249,6 +236,7 @@\n #![feature(clamp)]\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n+#![feature(const_fn_transmute)]\n #![feature(const_raw_ptr_deref)]\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]"}, {"sha": "4f751656e09c82d8d348345840f8ace30006d18d", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -37,7 +37,7 @@ use crate::vec;\n /// assert_eq!(socket.port(), 8080);\n /// assert_eq!(socket.is_ipv4(), true);\n /// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SocketAddr {\n     /// An IPv4 socket address.\n@@ -597,6 +597,13 @@ impl fmt::Display for SocketAddr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for SocketAddrV4 {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "9d7b2b807636f9568072dcf3f0397d052b185b68", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 85, "deletions": 41, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,6 +10,7 @@ use crate::cmp::Ordering;\n use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n use crate::io::Write as IoWrite;\n+use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -39,7 +40,7 @@ use crate::sys_common::{AsInner, FromInner};\n /// assert_eq!(localhost_v4.is_ipv4(), true);\n /// ```\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n pub enum IpAddr {\n     /// An IPv4 address.\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n@@ -766,10 +767,8 @@ impl Ipv4Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n-        let octets = self.octets();\n-        Ipv6Addr::from([\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, octets[0], octets[1], octets[2], octets[3],\n-        ])\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d])\n     }\n \n     /// Converts this address to an IPv4-mapped [IPv6 address].\n@@ -788,10 +787,8 @@ impl Ipv4Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n-        let octets = self.octets();\n-        Ipv6Addr::from([\n-            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, octets[0], octets[1], octets[2], octets[3],\n-        ])\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d])\n     }\n }\n \n@@ -805,6 +802,13 @@ impl fmt::Display for IpAddr {\n     }\n }\n \n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Debug for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n #[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n impl From<Ipv4Addr> for IpAddr {\n     /// Copies this address to a new `IpAddr::V4`.\n@@ -1045,27 +1049,23 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[allow_internal_unstable(const_fn_transmute)]\n     pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n+        let addr16 = [\n+            a.to_be(),\n+            b.to_be(),\n+            c.to_be(),\n+            d.to_be(),\n+            e.to_be(),\n+            f.to_be(),\n+            g.to_be(),\n+            h.to_be(),\n+        ];\n         Ipv6Addr {\n             inner: c::in6_addr {\n-                s6_addr: [\n-                    (a >> 8) as u8,\n-                    a as u8,\n-                    (b >> 8) as u8,\n-                    b as u8,\n-                    (c >> 8) as u8,\n-                    c as u8,\n-                    (d >> 8) as u8,\n-                    d as u8,\n-                    (e >> 8) as u8,\n-                    e as u8,\n-                    (f >> 8) as u8,\n-                    f as u8,\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8,\n-                ],\n+                // All elements in `addr16` are big endian.\n+                // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+                s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n             },\n         }\n     }\n@@ -1108,16 +1108,19 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n-        let arr = &self.inner.s6_addr;\n+        // All elements in `s6_addr` must be big endian.\n+        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n+        // We want native endian u16\n         [\n-            u16::from_be_bytes([arr[0], arr[1]]),\n-            u16::from_be_bytes([arr[2], arr[3]]),\n-            u16::from_be_bytes([arr[4], arr[5]]),\n-            u16::from_be_bytes([arr[6], arr[7]]),\n-            u16::from_be_bytes([arr[8], arr[9]]),\n-            u16::from_be_bytes([arr[10], arr[11]]),\n-            u16::from_be_bytes([arr[12], arr[13]]),\n-            u16::from_be_bytes([arr[14], arr[15]]),\n+            u16::from_be(a),\n+            u16::from_be(b),\n+            u16::from_be(c),\n+            u16::from_be(d),\n+            u16::from_be(e),\n+            u16::from_be(f),\n+            u16::from_be(g),\n+            u16::from_be(h),\n         ]\n     }\n \n@@ -1477,6 +1480,37 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xff00) == 0xff00\n     }\n \n+    /// Converts this address to an [IPv4 address] if it's an \"IPv4-mapped IPv6 address\"\n+    /// defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n+    ///\n+    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n+    /// All addresses *not* starting with `::ffff` will return `None`.\n+    ///\n+    /// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n+    /// ```\n+    pub fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n+        match self.octets() {\n+            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n+                Some(Ipv4Addr::new(a, b, c, d))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     /// Converts this address to an [IPv4 address]. Returns [`None`] if this address is\n     /// neither IPv4-compatible or IPv4-mapped.\n     ///\n@@ -1498,11 +1532,12 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n-        match self.segments() {\n-            [0, 0, 0, 0, 0, f, g, h] if f == 0 || f == 0xffff => {\n-                Some(Ipv4Addr::new((g >> 8) as u8, g as u8, (h >> 8) as u8, h as u8))\n-            }\n-            _ => None,\n+        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n+            let [a, b] = ab.to_be_bytes();\n+            let [c, d] = cd.to_be_bytes();\n+            Some(Ipv4Addr::new(a, b, c, d))\n+        } else {\n+            None\n         }\n     }\n \n@@ -2073,6 +2108,15 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn ipv6_to_ipv4_mapped() {\n+        assert_eq!(\n+            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n+            Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+        );\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n+    }\n+\n     #[test]\n     fn ipv6_to_ipv4() {\n         assert_eq!("}, {"sha": "6aeef330dfa24b38e590baf3b4d370bbb3924c07", "filename": "library/std/src/os/android/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::android::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "e4c4e04cd30aa87a378772280433f5fce7a413a6", "filename": "library/std/src/os/dragonfly/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fdragonfly%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fdragonfly%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fdragonfly%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::dragonfly::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "d4f758a3457fe3266bfda5e1d2787177d69fa270", "filename": "library/std/src/os/emscripten/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Femscripten%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Femscripten%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Femscripten%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::emscripten::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "c6a00e179bd7fb736105294724c98d299159ed40", "filename": "library/std/src/os/freebsd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Ffreebsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Ffreebsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffreebsd%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::freebsd::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "b48a46f9124a916fa6e429ba1bf811294dcaee5f", "filename": "library/std/src/os/fuchsia/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Ffuchsia%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Ffuchsia%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffuchsia%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,7 +5,7 @@ use crate::sys_common::AsInner;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]"}, {"sha": "28015f62526331698937d416eb6810c085072912", "filename": "library/std/src/os/haiku/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::haiku::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "021d154ff5a8a6e7dd75aae9ecc514297187866f", "filename": "library/std/src/os/illumos/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fillumos%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fillumos%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fillumos%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::illumos::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "2c5e38a803d30a2c4efcf3095679466450eb3f6c", "filename": "library/std/src/os/ios/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fios%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::ios::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "cae65f12187e21d3c934ad2d1f2535daa4fa49b2", "filename": "library/std/src/os/linux/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::linux::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains\n@@ -18,7 +18,7 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     ///\n-    /// [`stat`]: ../../../../std/os/linux/raw/struct.stat.html\n+    /// [`stat`]: crate::os::linux::raw::stat\n     ///\n     /// # Examples\n     ///"}, {"sha": "4152c3529361ded6e8e560da87860fc0bb9eea4d", "filename": "library/std/src/os/macos/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmacos%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::macos::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "6b29a40d2b5452bc08d644c3bd92b8fd89774e1d", "filename": "library/std/src/os/netbsd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fnetbsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fnetbsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnetbsd%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::netbsd::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "3143dc95fdf44adb0098920a1a4f78c2791cc2c7", "filename": "library/std/src/os/openbsd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fopenbsd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fopenbsd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fopenbsd%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::openbsd::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "8256b725acfa399877768d57c53b9b6c35915d4b", "filename": "library/std/src/os/raw/char.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fchar.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,7 +5,5 @@ Equivalent to C's `char` type.\n C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See [`CStr`] for more information.\n \n [C's `char` type]: https://en.wikipedia.org/wiki/C_data_types#Basic_types\n-[Rust's `char` type]: ../../primitive.char.html\n-[`CStr`]: ../../ffi/struct.CStr.html\n-[`i8`]: ../../primitive.i8.html\n-[`u8`]: ../../primitive.u8.html\n+[Rust's `char` type]: char\n+[`CStr`]: crate::ffi::CStr"}, {"sha": "57f4534829ec834a1b69ae377b393adc3dfd0519", "filename": "library/std/src/os/raw/double.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fdouble.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,5 +3,4 @@ Equivalent to C's `double` type.\n This type will almost always be [`f64`], which is guaranteed to be an [IEEE-754 double-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a [`float`], and it may be `f32` or something entirely different from the IEEE-754 standard.\n \n [IEEE-754 double-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n-[`float`]: type.c_float.html\n-[`f64`]: ../../primitive.f64.html\n+[`float`]: c_float"}, {"sha": "61e2abc05189df2e12d7fa1b77894868f3e2d269", "filename": "library/std/src/os/raw/float.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ffloat.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,4 +3,3 @@ Equivalent to C's `float` type.\n This type will almost always be [`f32`], which is guaranteed to be an [IEEE-754 single-precision float] in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than `f32` or not follow the IEEE-754 standard at all.\n \n [IEEE-754 single-precision float]: https://en.wikipedia.org/wiki/IEEE_754\n-[`f32`]: ../../primitive.f32.html"}, {"sha": "8062ff2307a9537ccf9007c982aa5e0eda09135e", "filename": "library/std/src/os/raw/int.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fint.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed int` (`int`) type.\n \n This type will almost always be [`i32`], but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a [`short`]; some systems define it as an [`i16`], for example.\n \n-[`short`]: type.c_short.html\n-[`i32`]: ../../primitive.i32.html\n-[`i16`]: ../../primitive.i16.html\n+[`short`]: c_short"}, {"sha": "cc160783f78b7d5b429f92ac9e8750531ce64063", "filename": "library/std/src/os/raw/long.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flong.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed long` (`long`) type.\n \n This type will always be [`i32`] or [`i64`]. Most notably, many Linux-based systems assume an `i64`, but Windows assumes `i32`. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an [`int`], although in practice, no system would have a `long` that is neither an `i32` nor `i64`.\n \n-[`int`]: type.c_int.html\n-[`i32`]: ../../primitive.i32.html\n-[`i64`]: ../../primitive.i64.html\n+[`int`]: c_int"}, {"sha": "49c61bd61f4ad71c2c569289b978b182f125c85c", "filename": "library/std/src/os/raw/longlong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Flonglong.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `signed long long` (`long long`) type.\n \n This type will almost always be [`i64`], but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a [`long`], although in practice, no system would have a `long long` that is not an `i64`, as most systems do not have a standardised [`i128`] type.\n \n-[`long`]: type.c_int.html\n-[`i64`]: ../../primitive.i64.html\n-[`i128`]: ../../primitive.i128.html\n+[`long`]: c_int"}, {"sha": "69879c9f17f4d80af70250424ed18558942cdc5c", "filename": "library/std/src/os/raw/schar.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fschar.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `signed char` type.\n \n This type will always be [`i8`], but is included for completeness. It is defined as being a signed integer the same size as a C [`char`].\n \n-[`char`]: type.c_char.html\n-[`i8`]: ../../primitive.i8.html\n+[`char`]: c_char"}, {"sha": "3d1e53d1325f31a12fee0825a30a8e89a2c0c857", "filename": "library/std/src/os/raw/short.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fshort.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `signed short` (`short`) type.\n \n This type will almost always be [`i16`], but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as `i32`, for example.\n \n-[`char`]: type.c_char.html\n-[`i16`]: ../../primitive.i16.html\n+[`char`]: c_char"}, {"sha": "b633bb7f8dacf5bf2ca300d0ab0a793acbbc3a49", "filename": "library/std/src/os/raw/uchar.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuchar.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `unsigned char` type.\n \n This type will always be [`u8`], but is included for completeness. It is defined as being an unsigned integer the same size as a C [`char`].\n \n-[`char`]: type.c_char.html\n-[`u8`]: ../../primitive.u8.html\n+[`char`]: c_char"}, {"sha": "f3abea35937abd712a916313955b86932570fb00", "filename": "library/std/src/os/raw/uint.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fuint.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned int` type.\n \n This type will almost always be [`u32`], but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an [`int`]; some systems define it as a [`u16`], for example.\n \n-[`int`]: type.c_int.html\n-[`u32`]: ../../primitive.u32.html\n-[`u16`]: ../../primitive.u16.html\n+[`int`]: c_int"}, {"sha": "4ab304e65777326eeef30e4e950e0296bb38881b", "filename": "library/std/src/os/raw/ulong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulong.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned long` type.\n \n This type will always be [`u32`] or [`u64`]. Most notably, many Linux-based systems assume an `u64`, but Windows assumes `u32`. The C standard technically only requires that this type be an unsigned integer with the size of a [`long`], although in practice, no system would have a `ulong` that is neither a `u32` nor `u64`.\n \n-[`long`]: type.c_long.html\n-[`u32`]: ../../primitive.u32.html\n-[`u64`]: ../../primitive.u64.html\n+[`long`]: c_long"}, {"sha": "a27d70e17537d440fcddae685df71b4e1d6a9fd8", "filename": "library/std/src/os/raw/ulonglong.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fulonglong.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,6 +2,4 @@ Equivalent to C's `unsigned long long` type.\n \n This type will almost always be [`u64`], but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a [`long long`], although in practice, no system would have a `long long` that is not a `u64`, as most systems do not have a standardised [`u128`] type.\n \n-[`long long`]: type.c_longlong.html\n-[`u64`]: ../../primitive.u64.html\n-[`u128`]: ../../primitive.u128.html\n+[`long long`]: c_longlong"}, {"sha": "6928e51b352c82d2a5aa413f20c402f4ff28dca4", "filename": "library/std/src/os/raw/ushort.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fushort.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,5 +2,4 @@ Equivalent to C's `unsigned short` type.\n \n This type will almost always be [`u16`], but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a [`short`].\n \n-[`short`]: type.c_short.html\n-[`u16`]: ../../primitive.u16.html\n+[`short`]: c_short"}, {"sha": "94d65651daa3c4cc5e15e434700305cfb9e7a925", "filename": "library/std/src/os/redox/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fredox%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::redox::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains\n@@ -18,7 +18,7 @@ pub trait MetadataExt {\n     /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n     /// cross-Unix abstractions contained within the raw stat.\n     ///\n-    /// [`stat`]: ../../../../std/os/redox/raw/struct.stat.html\n+    /// [`stat`]: crate::os::redox::raw::stat\n     ///\n     /// # Examples\n     ///"}, {"sha": "908c5c38a842e83ac4817f684dd06d5e3e24b992", "filename": "library/std/src/os/solaris/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fsolaris%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fsolaris%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fsolaris%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use crate::os::solaris::raw;\n \n /// OS-specific extensions to [`fs::Metadata`].\n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Gain a reference to the underlying `stat` structure which contains"}, {"sha": "5a7e5bcaa7600a92061908eca7fbaa33a5776da2", "filename": "library/std/src/os/vxworks/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -4,7 +4,7 @@ use crate::fs::Metadata;\n use crate::sys_common::AsInner;\n \n ///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+/// [`fs::Metadata`]: crate::fs::Metadata\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]"}, {"sha": "710c616be73cbec5d12cd24f36451d1edd3661c9", "filename": "library/std/src/prelude/mod.rs", "status": "modified", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -17,7 +17,7 @@\n //! such as [`std::io::prelude`]. Various libraries in the Rust ecosystem may\n //! also define their own preludes.\n //!\n-//! [`std::io::prelude`]: ../io/prelude/index.html\n+//! [`std::io::prelude`]: crate::io::prelude\n //!\n //! The difference between 'the prelude' and these other preludes is that they\n //! are not automatically `use`'d, and must be imported manually. This is still\n@@ -49,67 +49,34 @@\n //! * [`std::iter`]::{[`Iterator`], [`Extend`], [`IntoIterator`],\n //!   [`DoubleEndedIterator`], [`ExactSizeIterator`]}. Iterators of various\n //!   kinds.\n-//! * [`std::option`]::[`Option`]::{`self`, `Some`, `None`}. A type which\n-//!   expresses the presence or absence of a value. This type is so commonly\n-//!   used, its variants are also exported.\n-//! * [`std::result`]::[`Result`]::{`self`, `Ok`, `Err`}. A type for functions\n-//!   that may succeed or fail. Like [`Option`], its variants are exported as\n-//!   well.\n+//! * [`std::option`]::[`Option`]::{[`self`][`Option`], [`Some`], [`None`]}. A\n+//!   type which expresses the presence or absence of a value. This type is so\n+//!   commonly used, its variants are also exported.\n+//! * [`std::result`]::[`Result`]::{[`self`][`Result`], [`Ok`], [`Err`]}. A type\n+//!   for functions that may succeed or fail. Like [`Option`], its variants are\n+//!   exported as well.\n //! * [`std::string`]::{[`String`], [`ToString`]}, heap allocated strings.\n-//! * [`std::vec`]::[`Vec`](../vec/struct.Vec.html), a growable, heap-allocated\n+//! * [`std::vec`]::[`Vec`], a growable, heap-allocated\n //!   vector.\n //!\n-//! [`AsMut`]: ../convert/trait.AsMut.html\n-//! [`AsRef`]: ../convert/trait.AsRef.html\n-//! [`Box`]: ../boxed/struct.Box.html\n-//! [`Clone`]: ../clone/trait.Clone.html\n-//! [`Copy`]: ../marker/trait.Copy.html\n-//! [`Default`]: ../default/trait.Default.html\n-//! [`DoubleEndedIterator`]: ../iter/trait.DoubleEndedIterator.html\n-//! [`Drop`]: ../ops/trait.Drop.html\n-//! [`Eq`]: ../cmp/trait.Eq.html\n-//! [`ExactSizeIterator`]: ../iter/trait.ExactSizeIterator.html\n-//! [`Extend`]: ../iter/trait.Extend.html\n-//! [`FnMut`]: ../ops/trait.FnMut.html\n-//! [`FnOnce`]: ../ops/trait.FnOnce.html\n-//! [`Fn`]: ../ops/trait.Fn.html\n-//! [`From`]: ../convert/trait.From.html\n-//! [`IntoIterator`]: ../iter/trait.IntoIterator.html\n-//! [`Into`]: ../convert/trait.Into.html\n-//! [`Iterator`]: ../iter/trait.Iterator.html\n-//! [`Option`]: ../option/enum.Option.html\n-//! [`Ord`]: ../cmp/trait.Ord.html\n-//! [`PartialEq`]: ../cmp/trait.PartialEq.html\n-//! [`PartialOrd`]: ../cmp/trait.PartialOrd.html\n-//! [`Result`]: ../result/enum.Result.html\n-//! [`Send`]: ../marker/trait.Send.html\n-//! [`Sized`]: ../marker/trait.Sized.html\n-//! [`SliceConcatExt`]: ../slice/trait.SliceConcatExt.html\n-//! [`String`]: ../string/struct.String.html\n-//! [`Sync`]: ../marker/trait.Sync.html\n-//! [`ToOwned`]: ../borrow/trait.ToOwned.html\n-//! [`ToString`]: ../string/trait.ToString.html\n-//! [`Unpin`]: ../marker/trait.Unpin.html\n-//! [`Vec`]: ../vec/struct.Vec.html\n-//! [`Clone::clone`]: ../clone/trait.Clone.html#tymethod.clone\n-//! [`mem::drop`]: ../mem/fn.drop.html\n-//! [`std::borrow`]: ../borrow/index.html\n-//! [`std::boxed`]: ../boxed/index.html\n-//! [`std::clone`]: ../clone/index.html\n-//! [`std::cmp`]: ../cmp/index.html\n-//! [`std::convert`]: ../convert/index.html\n-//! [`std::default`]: ../default/index.html\n-//! [`std::iter`]: ../iter/index.html\n-//! [`std::marker`]: ../marker/index.html\n-//! [`std::mem`]: ../mem/index.html\n-//! [`std::ops`]: ../ops/index.html\n-//! [`std::option`]: ../option/index.html\n-//! [`std::prelude::v1`]: v1/index.html\n-//! [`std::result`]: ../result/index.html\n-//! [`std::slice`]: ../slice/index.html\n-//! [`std::string`]: ../string/index.html\n+//! [`mem::drop`]: crate::mem::drop\n+//! [`std::borrow`]: crate::borrow\n+//! [`std::boxed`]: crate::boxed\n+//! [`std::clone`]: crate::clone\n+//! [`std::cmp`]: crate::cmp\n+//! [`std::convert`]: crate::convert\n+//! [`std::default`]: crate::default\n+//! [`std::iter`]: crate::iter\n+//! [`std::marker`]: crate::marker\n+//! [`std::mem`]: crate::mem\n+//! [`std::ops`]: crate::ops\n+//! [`std::option`]: crate::option\n+//! [`std::prelude::v1`]: v1\n+//! [`std::result`]: crate::result\n+//! [`std::slice`]: crate::slice\n+//! [`std::string`]: crate::string\n //! [`std::vec`]: ../vec/index.html\n-//! [`to_owned`]: ../borrow/trait.ToOwned.html#tymethod.to_owned\n+//! [`to_owned`]: crate::borrow::ToOwned::to_owned\n //! [book-closures]: ../../book/ch13-01-closures.html\n //! [book-dtor]: ../../book/ch15-03-drop.html\n //! [book-enums]: ../../book/ch06-01-defining-an-enum.html"}, {"sha": "bca1732b84d95677af4fbb4742c3b7d11beea5ab", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -764,19 +764,55 @@ mod prim_str {}\n mod prim_tuple {}\n \n #[doc(primitive = \"f32\")]\n-/// The 32-bit floating point type.\n+/// A 32-bit floating point type (specifically, the \"binary32\" type defined in IEEE 754-2008).\n+///\n+/// This type can represent a wide range of decimal numbers, like `3.5`, `27`,\n+/// `-113.75`, `0.0078125`, `34359738368`, `0`, `-1`. So unlike integer types\n+/// (such as `i32`), floating point types can represent non-integer numbers,\n+/// too.\n+///\n+/// However, being able to represent this wide range of numbers comes at the\n+/// cost of precision: floats can only represent some of the real numbers and\n+/// calculation with floats round to a nearby representable number. For example,\n+/// `5.0` and `1.0` can be exactly represented as `f32`, but `1.0 / 5.0` results\n+/// in `0.20000000298023223876953125` since `0.2` cannot be exactly represented\n+/// as `f32`. Note however, that printing floats with `println` and friends will\n+/// often discard insignificant digits: `println!(\"{}\", 1.0f32 / 5.0f32)` will\n+/// print `0.2`.\n+///\n+/// Additionally, `f32` can represent a couple of special values:\n+///\n+/// - `-0`: this is just due to how floats are encoded. It is semantically\n+///   equivalent to `0` and `-0.0 == 0.0` results in `true`.\n+/// - [\u221e](#associatedconstant.INFINITY) and\n+///   [\u2212\u221e](#associatedconstant.NEG_INFINITY): these result from calculations\n+///   like `1.0 / 0.0`.\n+/// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n+///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n+///   behavior: it is unequal to any float, including itself! It is also neither\n+///   smaller nor greater than any float, making it impossible to sort. Lastly,\n+///   it is considered infectious as almost all calculations where one of the\n+///   operands is NaN will also result in NaN.\n+///\n+/// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///\n /// *[See also the `std::f32::consts` module](f32/consts/index.html).*\n ///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_f32 {}\n \n #[doc(primitive = \"f64\")]\n-//\n-/// The 64-bit floating point type.\n+/// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n+///\n+/// This type is very similar to [`f32`](primitive.f32.html), but has increased\n+/// precision by using twice as many bits. Please see [the documentation for\n+/// `f32`](primitive.f32.html) or [Wikipedia on double precision\n+/// values][wikipedia] for more information.\n ///\n /// *[See also the `std::f64::consts` module](f64/consts/index.html).*\n ///\n+/// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_f64 {}\n \n@@ -1022,6 +1058,8 @@ mod prim_ref {}\n /// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n /// pointers, make your type `Option<fn()>` with your required signature.\n ///\n+/// ### Safety\n+///\n /// Plain function pointers are obtained by casting either plain functions, or closures that don't\n /// capture an environment:\n ///\n@@ -1059,23 +1097,60 @@ mod prim_ref {}\n /// let really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n /// ```\n ///\n-/// On top of that, function pointers can vary based on what ABI they use. This is achieved by\n-/// adding the `extern` keyword to the type name, followed by the ABI in question. For example,\n-/// `fn()` is different from `extern \"C\" fn()`, which itself is different from `extern \"stdcall\"\n-/// fn()`, and so on for the various ABIs that Rust supports. Non-`extern` functions have an ABI\n-/// of `\"Rust\"`, and `extern` functions without an explicit ABI have an ABI of `\"C\"`. For more\n-/// information, see [the nomicon's section on foreign calling conventions][nomicon-abi].\n+/// ### ABI\n+///\n+/// On top of that, function pointers can vary based on what ABI they use. This\n+/// is achieved by adding the `extern` keyword before the type, followed by the\n+/// ABI in question. The default ABI is \"Rust\", i.e., `fn()` is the exact same\n+/// type as `extern \"Rust\" fn()`. A pointer to a function with C ABI would have\n+/// type `extern \"C\" fn()`.\n+///\n+/// `extern \"ABI\" { ... }` blocks declare functions with ABI \"ABI\". The default\n+/// here is \"C\", i.e., functions declared in an `extern {...}` block have \"C\"\n+/// ABI.\n ///\n-/// [nomicon-abi]: ../nomicon/ffi.html#foreign-calling-conventions\n+/// For more information and a list of supported ABIs, see [the nomicon's\n+/// section on foreign calling conventions][nomicon-abi].\n+///\n+/// ### Variadic functions\n ///\n /// Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them\n-/// to be called with a variable number of arguments. Normal rust functions, even those with an\n+/// to be called with a variable number of arguments. Normal Rust functions, even those with an\n /// `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon's section on\n /// variadic functions][nomicon-variadic].\n ///\n /// [nomicon-variadic]: ../nomicon/ffi.html#variadic-functions\n ///\n-/// These markers can be combined, so `unsafe extern \"stdcall\" fn()` is a valid type.\n+/// ### Creating function pointers\n+///\n+/// When `bar` is the name of a function, then the expression `bar` is *not* a\n+/// function pointer. Rather, it denotes a value of an unnameable type that\n+/// uniquely identifies the function `bar`. The value is zero-sized because the\n+/// type already identifies the function. This has the advantage that \"calling\"\n+/// the value (it implements the `Fn*` traits) does not require dynamic\n+/// dispatch.\n+///\n+/// This zero-sized type *coerces* to a regular function pointer. For example:\n+///\n+/// ```rust\n+/// use std::mem;\n+///\n+/// fn bar(x: i32) {}\n+///\n+/// let not_bar_ptr = bar; // `not_bar_ptr` is zero-sized, uniquely identifying `bar`\n+/// assert_eq!(mem::size_of_val(&not_bar_ptr), 0);\n+///\n+/// let bar_ptr: fn(i32) = not_bar_ptr; // force coercion to function pointer\n+/// assert_eq!(mem::size_of_val(&bar_ptr), mem::size_of::<usize>());\n+///\n+/// let footgun = &bar; // this is a shared reference to the zero-sized type identifying `bar`\n+/// ```\n+///\n+/// The last line shows that `&bar` is not a function pointer either. Rather, it\n+/// is a reference to the function-specific ZST. `&bar` is basically never what you\n+/// want when `bar` is a function.\n+///\n+/// ### Traits\n ///\n /// Function pointers implement the following traits:\n ///"}, {"sha": "6d94fa9ebfe6d7316dd5149e7c0068a249f42ab7", "filename": "library/std/src/process.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -84,25 +84,15 @@\n //! assert_eq!(b\"test\", output.stdout.as_slice());\n //! ```\n //!\n-//! [`abort`]: fn.abort.html\n-//! [`exit`]: fn.exit.html\n+//! [`spawn`]: Command::spawn\n+//! [`output`]: Command::output\n //!\n-//! [`Command`]: struct.Command.html\n-//! [`spawn`]: struct.Command.html#method.spawn\n-//! [`output`]: struct.Command.html#method.output\n+//! [`stdout`]: Command::stdout\n+//! [`stdin`]: Command::stdin\n+//! [`stderr`]: Command::stderr\n //!\n-//! [`Child`]: struct.Child.html\n-//! [`ChildStdin`]: struct.ChildStdin.html\n-//! [`ChildStdout`]: struct.ChildStdout.html\n-//! [`ChildStderr`]: struct.ChildStderr.html\n-//! [`Stdio`]: struct.Stdio.html\n-//!\n-//! [`stdout`]: struct.Command.html#method.stdout\n-//! [`stdin`]: struct.Command.html#method.stdin\n-//! [`stderr`]: struct.Command.html#method.stderr\n-//!\n-//! [`Write`]: ../io/trait.Write.html\n-//! [`Read`]: ../io/trait.Read.html\n+//! [`Write`]: io::Write\n+//! [`Read`]: io::Read\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n \n@@ -130,7 +120,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// run, even after the `Child` handle to the child process has gone out of\n /// scope.\n ///\n-/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n+/// Calling [`wait`] (or other functions that wrap around it) will make\n /// the parent process wait until the child has actually exited before\n /// continuing.\n ///\n@@ -162,25 +152,44 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// assert!(ecode.success());\n /// ```\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Drop`]: ../../core/ops/trait.Drop.html\n-/// [`wait`]: #method.wait\n+/// [`wait`]: Child::wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n     handle: imp::Process,\n \n     /// The handle for writing to the child's standard input (stdin), if it has\n-    /// been captured.\n+    /// been captured. To avoid partially moving\n+    /// the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stdin`,\n+    /// you might find it helpful:\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stdin = child.stdin.take().unwrap();\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n \n     /// The handle for reading from the child's standard output (stdout), if it\n-    /// has been captured.\n+    /// has been captured. You might find it helpful to do\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stdout = child.stdout.take().unwrap();\n+    /// ```\n+    ///\n+    /// to avoid partially moving the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stdout`.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdout: Option<ChildStdout>,\n \n     /// The handle for reading from the child's standard error (stderr), if it\n-    /// has been captured.\n+    /// has been captured. You might find it helpful to do\n+    ///\n+    /// ```compile_fail,E0425\n+    /// let stderr = child.stderr.take().unwrap();\n+    /// ```\n+    ///\n+    /// to avoid partially moving the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stderr`.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stderr: Option<ChildStderr>,\n }\n@@ -227,9 +236,8 @@ impl fmt::Debug for Child {\n /// file handle will be closed. If the child process was blocked on input prior\n /// to being dropped, it will become unblocked after dropping.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stdin`]: struct.Child.html#structfield.stdin\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stdin`]: Child::stdin\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe,\n@@ -286,9 +294,8 @@ impl fmt::Debug for ChildStdin {\n /// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n /// underlying file handle will be closed.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stdout`]: struct.Child.html#structfield.stdout\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stdout`]: Child::stdout\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe,\n@@ -347,9 +354,8 @@ impl fmt::Debug for ChildStdout {\n /// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n /// underlying file handle will be closed.\n ///\n-/// [`Child`]: struct.Child.html\n-/// [`stderr`]: struct.Child.html#structfield.stderr\n-/// [dropped]: ../ops/trait.Drop.html\n+/// [`stderr`]: Child::stderr\n+/// [dropped]: Drop\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe,\n@@ -522,7 +528,7 @@ impl Command {\n     ///\n     /// To pass multiple arguments see [`args`].\n     ///\n-    /// [`args`]: #method.args\n+    /// [`args`]: Command::args\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +553,7 @@ impl Command {\n     ///\n     /// To pass a single argument see [`arg`].\n     ///\n-    /// [`arg`]: #method.arg\n+    /// [`arg`]: Command::arg\n     ///\n     /// # Examples\n     ///\n@@ -700,7 +706,7 @@ impl Command {\n     ///         .expect(\"ls command failed to start\");\n     /// ```\n     ///\n-    /// [`canonicalize`]: ../fs/fn.canonicalize.html\n+    /// [`canonicalize`]: crate::fs::canonicalize\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n@@ -712,8 +718,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -738,8 +744,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -764,8 +770,8 @@ impl Command {\n     /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n     /// defaults to [`piped`] when used with `output`.\n     ///\n-    /// [`inherit`]: struct.Stdio.html#method.inherit\n-    /// [`piped`]: struct.Stdio.html#method.piped\n+    /// [`inherit`]: Stdio::inherit\n+    /// [`piped`]: Stdio::piped\n     ///\n     /// # Examples\n     ///\n@@ -893,10 +899,8 @@ impl AsInnerMut<imp::Command> for Command {\n /// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n /// process.\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Child`]: struct.Child.html\n-/// [`output`]: struct.Command.html#method.output\n-/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n+/// [`output`]: Command::output\n+/// [`wait_with_output`]: Child::wait_with_output\n #[derive(PartialEq, Eq, Clone)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Output {\n@@ -939,10 +943,9 @@ impl fmt::Debug for Output {\n /// Describes what to do with a standard I/O stream for a child process when\n /// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n ///\n-/// [`stdin`]: struct.Command.html#method.stdin\n-/// [`stdout`]: struct.Command.html#method.stdout\n-/// [`stderr`]: struct.Command.html#method.stderr\n-/// [`Command`]: struct.Command.html\n+/// [`stdin`]: Command::stdin\n+/// [`stdout`]: Command::stdout\n+/// [`stderr`]: Command::stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Stdio(imp::Stdio);\n \n@@ -1206,10 +1209,8 @@ impl From<fs::File> for Stdio {\n /// status is exposed through the [`status`] method, or the [`wait`] method\n /// of a [`Child`] process.\n ///\n-/// [`Command`]: struct.Command.html\n-/// [`Child`]: struct.Child.html\n-/// [`status`]: struct.Command.html#method.status\n-/// [`wait`]: struct.Child.html#method.wait\n+/// [`status`]: Command::status\n+/// [`wait`]: Child::wait\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ExitStatus(imp::ExitStatus);\n@@ -1294,8 +1295,8 @@ impl fmt::Display for ExitStatus {\n /// For the platform's canonical successful and unsuccessful codes, see\n /// the [`SUCCESS`] and [`FAILURE`] associated items.\n ///\n-/// [`SUCCESS`]: #associatedconstant.SUCCESS\n-/// [`FAILURE`]: #associatedconstant.FAILURE\n+/// [`SUCCESS`]: ExitCode::SUCCESS\n+/// [`FAILURE`]: ExitCode::FAILURE\n ///\n /// **Warning**: While various forms of this were discussed in [RFC #1937],\n /// it was ultimately cut from that RFC, and thus this type is more subject\n@@ -1349,9 +1350,9 @@ impl Child {\n     /// }\n     /// ```\n     ///\n-    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n-    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n-    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n+    /// [`ErrorKind`]: io::ErrorKind\n+    /// [`InvalidInput`]: io::ErrorKind::InvalidInput\n+    /// [`Other`]: io::ErrorKind::Other\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n         self.handle.kill()\n@@ -1616,8 +1617,7 @@ pub fn exit(code: i32) -> ! {\n /// }\n /// ```\n ///\n-/// [`panic!`]: ../../std/macro.panic.html\n-/// [panic hook]: ../../std/panic/fn.set_hook.html\n+/// [panic hook]: crate::panic::set_hook\n #[stable(feature = \"process_abort\", since = \"1.17.0\")]\n pub fn abort() -> ! {\n     crate::sys::abort_internal();"}, {"sha": "8408756f1b3be1cca5bff0c8e8dc031d7163895e", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -46,6 +46,7 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n+    append: bool,\n     dirflags: wasi::Lookupflags,\n     fdflags: wasi::Fdflags,\n     oflags: wasi::Oflags,\n@@ -270,8 +271,9 @@ impl OpenOptions {\n         }\n     }\n \n-    pub fn append(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAGS_APPEND, set);\n+    pub fn append(&mut self, append: bool) {\n+        self.append = append;\n+        self.fdflag(wasi::FDFLAGS_APPEND, append);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n@@ -321,7 +323,7 @@ impl OpenOptions {\n             base |= wasi::RIGHTS_FD_READ;\n             base |= wasi::RIGHTS_FD_READDIR;\n         }\n-        if self.write {\n+        if self.write || self.append {\n             base |= wasi::RIGHTS_FD_WRITE;\n             base |= wasi::RIGHTS_FD_DATASYNC;\n             base |= wasi::RIGHTS_FD_ALLOCATE;"}, {"sha": "02161ecb4c8d21adeb0ea2cb68c763fc21506fcc", "filename": "library/std/src/time.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -97,7 +97,6 @@ pub use core::time::Duration;\n /// [clock_time_get (Monotonic Clock)]: https://nuxi.nl/cloudabi/#clock_time_get\n ///\n /// **Disclaimer:** These system calls might change over time.\n-///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct Instant(time::Instant);\n@@ -125,11 +124,6 @@ pub struct Instant(time::Instant);\n /// The size of a `SystemTime` struct may vary depending on the target operating\n /// system.\n ///\n-/// [`Instant`]: ../../std/time/struct.Instant.html\n-/// [`Result`]: ../../std/result/enum.Result.html\n-/// [`Duration`]: ../../std/time/struct.Duration.html\n-/// [`UNIX_EPOCH`]: ../../std/time/constant.UNIX_EPOCH.html\n-///\n /// Example:\n ///\n /// ```no_run\n@@ -176,7 +170,6 @@ pub struct Instant(time::Instant);\n /// [GetSystemTimeAsFileTime]: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime\n ///\n /// **Disclaimer:** These system calls might change over time.\n-///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct SystemTime(time::SystemTime);\n@@ -366,9 +359,7 @@ impl Add<Duration> for Instant {\n     /// # Panics\n     ///\n     /// This function may panic if the resulting point in time cannot be represented by the\n-    /// underlying data structure. See [`checked_add`] for a version without panic.\n-    ///\n-    /// [`checked_add`]: ../../std/time/struct.Instant.html#method.checked_add\n+    /// underlying data structure. See [`Instant::checked_add`] for a version without panic.\n     fn add(self, other: Duration) -> Instant {\n         self.checked_add(other).expect(\"overflow when adding duration to instant\")\n     }\n@@ -463,11 +454,6 @@ impl SystemTime {\n     /// Returns an [`Err`] if `earlier` is later than `self`, and the error\n     /// contains how far from `self` the time is.\n     ///\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Duration`]: ../../std/time/struct.Duration.html\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Instant`]: ../../std/time/struct.Instant.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -497,11 +483,6 @@ impl SystemTime {\n     /// Returns an [`Err`] if `self` is later than the current system time, and\n     /// the error contains how far from the current system time `self` is.\n     ///\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Duration`]: ../../std/time/struct.Duration.html\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Instant`]: ../../std/time/struct.Instant.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -542,9 +523,7 @@ impl Add<Duration> for SystemTime {\n     /// # Panics\n     ///\n     /// This function may panic if the resulting point in time cannot be represented by the\n-    /// underlying data structure. See [`checked_add`] for a version without panic.\n-    ///\n-    /// [`checked_add`]: ../../std/time/struct.SystemTime.html#method.checked_add\n+    /// underlying data structure. See [`SystemTime::checked_add`] for a version without panic.\n     fn add(self, dur: Duration) -> SystemTime {\n         self.checked_add(dur).expect(\"overflow when adding duration to instant\")\n     }\n@@ -589,8 +568,6 @@ impl fmt::Debug for SystemTime {\n /// measurement lies, and using `UNIX_EPOCH + duration` can be used to create a\n /// [`SystemTime`] instance to represent another fixed point in time.\n ///\n-/// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n-///\n /// # Examples\n ///\n /// ```no_run\n@@ -608,13 +585,9 @@ impl SystemTimeError {\n     /// Returns the positive duration which represents how far forward the\n     /// second system time was from the first.\n     ///\n-    /// A `SystemTimeError` is returned from the [`duration_since`] and [`elapsed`]\n-    /// methods of [`SystemTime`] whenever the second system time represents a point later\n-    /// in time than the `self` of the method call.\n-    ///\n-    /// [`duration_since`]: ../../std/time/struct.SystemTime.html#method.duration_since\n-    /// [`elapsed`]: ../../std/time/struct.SystemTime.html#method.elapsed\n-    /// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n+    /// A `SystemTimeError` is returned from the [`SystemTime::duration_since`]\n+    /// and [`SystemTime::elapsed`] methods whenever the second system time\n+    /// represents a point later in time than the `self` of the method call.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4b0905bd6c16c8d14eee46a0c5e45b201b3a89c3", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -404,6 +404,7 @@ impl<'a> Builder<'a> {\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n                 test::Linkcheck,\n+                test::TierCheck,\n                 test::Cargotest,\n                 test::Cargo,\n                 test::Rls,"}, {"sha": "3ab50e114c750426a13c04e9b4d616a7276af938", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -178,7 +178,7 @@ impl Step for Llvm {\n             .define(\"LLVM_TARGET_ARCH\", target_native.split('-').next().unwrap())\n             .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target_native);\n \n-        if !target.contains(\"netbsd\") {\n+        if !target.contains(\"netbsd\") && target != \"aarch64-apple-darwin\" {\n             cfg.define(\"LLVM_ENABLE_ZLIB\", \"ON\");\n         } else {\n             // FIXME: Enable zlib on NetBSD too"}, {"sha": "11e2564305f0db3b54825cc65d556030e267b83b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2043,3 +2043,47 @@ impl Step for Bootstrap {\n         run.builder.ensure(Bootstrap);\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TierCheck {\n+    pub compiler: Compiler,\n+    target: TargetSelection,\n+}\n+\n+impl Step for TierCheck {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/tier-check\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        let compiler = run.builder.compiler_for(run.builder.top_stage, run.host, run.host);\n+        run.builder.ensure(TierCheck { compiler, target: run.host });\n+    }\n+\n+    /// Tests the Platform Support page in the rustc book.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.ensure(compile::Std { compiler: self.compiler, target: self.target });\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            self.compiler,\n+            Mode::ToolRustc,\n+            self.target,\n+            \"run\",\n+            \"src/tools/tier-check\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        cargo.arg(builder.src.join(\"src/doc/rustc/src/platform-support.md\"));\n+        cargo.arg(&builder.rustc(self.compiler));\n+        if builder.is_verbose() {\n+            cargo.arg(\"--verbose\");\n+        }\n+\n+        builder.info(\"platform support check\");\n+        try_run(builder, &mut cargo.into());\n+    }\n+}"}, {"sha": "bbbd632c6bb8206a0a851bb61f9e6106cb4bebe0", "filename": "src/ci/docker/host-x86_64/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,9 +23,9 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV \\\n-    AR_i686_unknown_freebsd=i686-unknown-freebsd10-ar \\\n-    CC_i686_unknown_freebsd=i686-unknown-freebsd10-clang \\\n-    CXX_i686_unknown_freebsd=i686-unknown-freebsd10-clang++\n+    AR_i686_unknown_freebsd=i686-unknown-freebsd11-ar \\\n+    CC_i686_unknown_freebsd=i686-unknown-freebsd11-clang \\\n+    CXX_i686_unknown_freebsd=i686-unknown-freebsd11-clang++\n \n ENV HOSTS=i686-unknown-freebsd\n "}, {"sha": "766e6531c95071880cb50e0770716d0e514cda2a", "filename": "src/ci/docker/host-x86_64/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,9 +23,9 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV \\\n-    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n-    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-clang \\\n-    CXX_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-clang++\n+    AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd11-ar \\\n+    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd11-clang \\\n+    CXX_x86_64_unknown_freebsd=x86_64-unknown-freebsd11-clang++\n \n ENV HOSTS=x86_64-unknown-freebsd\n "}, {"sha": "cb507dced4248c22c87c95be88e528b938038432", "filename": "src/ci/docker/host-x86_64/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -19,8 +19,13 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+RUN mkdir -p /config\n+RUN echo \"[rust]\" > /config/nopt-std-config.toml\n+RUN echo \"optimize = false\" >> /config/nopt-std-config.toml\n+\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV SCRIPT python3 ../x.py --stage 2 test\n+ENV SCRIPT python3 ../x.py test --stage 0 --config /config/nopt-std-config.toml library/std \\\n+  && python3 ../x.py --stage 2 test\n \n # FIXME(#59637) takes too long on CI right now\n ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "41e83c69e549f4809ecdeffb54351356101cfb1f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -18,7 +18,12 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+RUN mkdir -p /config\n+RUN echo \"[rust]\" > /config/nopt-std-config.toml\n+RUN echo \"optimize = false\" >> /config/nopt-std-config.toml\n+\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV SCRIPT python3 ../x.py --stage 2 test\n+ENV SCRIPT python3 ../x.py test --stage 0 --config /config/nopt-std-config.toml library/std \\\n+  && python3 ../x.py --stage 2 test"}, {"sha": "b10263d5a268e4aa859da514f16c8c69320e0781", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,8 +5,8 @@ set -eux\n \n arch=$1\n binutils_version=2.25.1\n-freebsd_version=10.3\n-triple=$arch-unknown-freebsd10\n+freebsd_version=11.4\n+triple=$arch-unknown-freebsd11\n sysroot=/usr/local/$triple\n \n hide_output() {\n@@ -58,31 +58,17 @@ for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared; do\n done\n \n # Originally downloaded from:\n-# https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://ci-mirrors.rust-lang.org/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+# URL=https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n+URL=https://ci-mirrors.rust-lang.org/rustc/2020-08-09-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n-# Fix up absolute symlinks from the system image.  This can be removed\n-# for FreeBSD 11.  (If there's an easy way to make them relative\n-# symlinks instead, feel free to change this.)\n-set +x\n-find \"$sysroot\" -type l | while read symlink_path; do\n-  symlink_target=$(readlink \"$symlink_path\")\n-  case $symlink_target in\n-    (/*)\n-      echo \"Fixing symlink ${symlink_path} -> ${sysroot}${symlink_target}\" >&2\n-      ln -nfs \"${sysroot}${symlink_target}\" \"${symlink_path}\" ;;\n-  esac\n-done\n-set -x\n-\n # Clang can do cross-builds out of the box, if we give it the right\n # flags.  (The local binutils seem to work, but they set the ELF\n # header \"OS/ABI\" (EI_OSABI) field to SysV rather than FreeBSD, so\n # there might be other problems.)\n #\n # The --target option is last because the cross-build of LLVM uses\n-# --target without an OS version (\"-freebsd\" vs. \"-freebsd10\").  This\n+# --target without an OS version (\"-freebsd\" vs. \"-freebsd11\").  This\n # makes Clang default to libstdc++ (which no longer exists), and also\n # controls other features, like GNU-style symbol table hashing and\n # anything predicated on the version number in the __FreeBSD__"}, {"sha": "165ecc791804472bd79ac03c8e231458bc7a4672", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -490,15 +490,17 @@ jobs:\n \n           # 32/64-bit MinGW builds.\n           #\n-          # We are using MinGW with posix threads since LLVM does not compile with\n-          # the win32 threads version due to missing support for C++'s std::thread.\n+          # We are using MinGW with POSIX threads since LLVM requires\n+          # C++'s std::thread which is disabled in libstdc++ with win32 threads.\n+          # FIXME: Libc++ doesn't have this limitation so we can avoid \n+          # winpthreads if we switch to it.\n           #\n-          # Instead of relying on the MinGW version installed on appveryor we download\n-          # and install one ourselves so we won't be surprised by changes to appveyor's\n+          # Instead of relying on the MinGW version installed on CI we download\n+          # and install one ourselves so we won't be surprised by changes to CI's\n           # build image.\n           #\n           # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n-          # bucket, but they cleraly didn't originate there! The downloads originally\n+          # bucket, but they clearly didn't originate there! The downloads originally\n           # came from the mingw-w64 SourceForge download site. Unfortunately\n           # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n "}, {"sha": "57013e9194bc110d070bf463ef69f5d4b00f0139", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,6 +11,7 @@\n         - [Deny-by-default lints](lints/listing/deny-by-default.md)\n - [Codegen options](codegen-options/index.md)\n - [JSON Output](json.md)\n+- [Platform Support](platform-support.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)"}, {"sha": "b8d3c985cb5b615076add108107f12215c631bc7", "filename": "src/doc/rustc/src/platform-support.md", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,223 @@\n+# Platform Support\n+\n+<style type=\"text/css\">\n+    td code {\n+        white-space: nowrap;\n+    }\n+</style>\n+\n+Support for different platforms are organized into three tiers, each with a\n+different set of guarantees.\n+\n+Platforms are identified by their \"target triple\" which is the string to\n+inform the compiler what kind of output should be produced. The columns in the\n+tables below have the following meanings:\n+\n+* std:\n+    * \u2713 indicates the full standard library is available.\n+    * \\* indicates the target only supports [`no_std`] development.\n+    * ? indicates the standard library support is unknown or a work-in-progress.\n+* host: A \u2713 indicates that `rustc` and `cargo` can run on the host platform.\n+\n+[`no_std`]: https://rust-embedded.github.io/book/intro/no-std.html\n+\n+## Tier 1\n+\n+Tier 1 platforms can be thought of as \"guaranteed to work\".\n+Specifically they will each satisfy the following requirements:\n+\n+* Official binary releases are provided for the platform.\n+* Automated testing is set up to run tests for the platform.\n+* Landing changes to the `rust-lang/rust` repository's master branch is gated\n+  on tests passing.\n+* Documentation for how to use and how to build the platform is available.\n+\n+target | std | host | notes\n+-------|-----|------|-------\n+`i686-pc-windows-gnu` | \u2713 | \u2713 | 32-bit MinGW (Windows 7+)\n+`i686-pc-windows-msvc` | \u2713 | \u2713 | 32-bit MSVC (Windows 7+)\n+`i686-unknown-linux-gnu` | \u2713 | \u2713 | 32-bit Linux (kernel 2.6.32+, glibc 2.11+)\n+`x86_64-apple-darwin` | \u2713 | \u2713 | 64-bit OSX (10.7+, Lion+)\n+`x86_64-pc-windows-gnu` | \u2713 | \u2713 | 64-bit MinGW (Windows 7+)\n+`x86_64-pc-windows-msvc` | \u2713 | \u2713 | 64-bit MSVC (Windows 7+)\n+`x86_64-unknown-linux-gnu` | \u2713 | \u2713 | 64-bit Linux (kernel 2.6.32+, glibc 2.11+)\n+\n+## Tier 2\n+\n+Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests\n+are not run so it's not guaranteed to produce a working build, but platforms\n+often work to quite a good degree and patches are always welcome!\n+Specifically, these platforms are required to have each of the following:\n+\n+* Official binary releases are provided for the platform.\n+* Automated building is set up, but may not be running tests.\n+* Landing changes to the `rust-lang/rust` repository's master branch is gated on\n+    platforms **building**. For some platforms only the standard library is\n+    compiled, but for others `rustc` and `cargo` are too.\n+\n+target | std | host | notes\n+-------|-----|------|-------\n+`aarch64-apple-ios` | \u2713[^apple] |  | ARM64 iOS\n+`aarch64-fuchsia` | \u2713 |  | ARM64 Fuchsia\n+`aarch64-linux-android` | \u2713 |  | ARM64 Android\n+`aarch64-pc-windows-msvc` | \u2713 |  | ARM64 Windows MSVC\n+`aarch64-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (kernel 4.2, glibc 2.17)\n+`aarch64-unknown-linux-musl` | \u2713 |  | ARM64 Linux with MUSL\n+`aarch64-unknown-none` | * |  | Bare ARM64, hardfloat\n+`aarch64-unknown-none-softfloat` | * |  | Bare ARM64, softfloat\n+`arm-linux-androideabi` | \u2713 |  | ARMv7 Android\n+`arm-unknown-linux-gnueabi` | \u2713 | \u2713 | ARMv6 Linux (kernel 3.2, glibc 2.17)\n+`arm-unknown-linux-gnueabihf` | \u2713 | \u2713 | ARMv6 Linux, hardfloat (kernel 3.2, glibc 2.17)\n+`arm-unknown-linux-musleabi` | \u2713 |  | ARMv6 Linux with MUSL\n+`arm-unknown-linux-musleabihf` | \u2713 |  | ARMv6 Linux with MUSL, hardfloat\n+`armebv7r-none-eabi` | * |  | Bare ARMv7-R, Big Endian\n+`armebv7r-none-eabihf` | * |  | Bare ARMv7-R, Big Endian, hardfloat\n+`armv5te-unknown-linux-gnueabi` | \u2713 |  | ARMv5TE Linux (kernel 4.4, glibc 2.23)\n+`armv5te-unknown-linux-musleabi` | \u2713 |  | ARMv5TE Linux with MUSL\n+`armv7-linux-androideabi` | \u2713 |  | ARMv7a Android\n+`armv7a-none-eabi` | * |  | Bare ARMv7-A\n+`armv7r-none-eabi` | * |  | Bare ARMv7-R\n+`armv7r-none-eabihf` | * |  | Bare ARMv7-R, hardfloat\n+`armv7-unknown-linux-gnueabi` | \u2713 |   | ARMv7 Linux (kernel 4.15, glibc 2.27)\n+`armv7-unknown-linux-gnueabihf` | \u2713 | \u2713 | ARMv7 Linux, hardfloat (kernel 3.2, glibc 2.17)\n+`armv7-unknown-linux-musleabi` | \u2713 |   | ARMv7 Linux, MUSL\n+`armv7-unknown-linux-musleabihf` | \u2713 |  | ARMv7 Linux with MUSL\n+`asmjs-unknown-emscripten` | \u2713 |  | asm.js via Emscripten\n+`i586-pc-windows-msvc` | \u2713 |  | 32-bit Windows w/o SSE\n+`i586-unknown-linux-gnu` | \u2713 |  | 32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)\n+`i586-unknown-linux-musl` | \u2713 |  | 32-bit Linux w/o SSE, MUSL\n+`i686-linux-android` | \u2713 |  | 32-bit x86 Android\n+`i686-unknown-freebsd` | \u2713 | \u2713 | 32-bit FreeBSD\n+`i686-unknown-linux-musl` | \u2713 |  | 32-bit Linux with MUSL\n+`mips-unknown-linux-gnu` | \u2713 | \u2713 | MIPS Linux (kernel 4.4, glibc 2.23)\n+`mips-unknown-linux-musl` | \u2713 |  | MIPS Linux with MUSL\n+`mips64-unknown-linux-gnuabi64` | \u2713 | \u2713 | MIPS64 Linux, n64 ABI (kernel 4.4, glibc 2.23)\n+`mips64-unknown-linux-muslabi64` | \u2713 |  | MIPS64 Linux, n64 ABI, MUSL\n+`mips64el-unknown-linux-gnuabi64` | \u2713 | \u2713 | MIPS64 (LE) Linux, n64 ABI (kernel 4.4, glibc 2.23)\n+`mips64el-unknown-linux-muslabi64` | \u2713 |  | MIPS64 (LE) Linux, n64 ABI, MUSL\n+`mipsel-unknown-linux-gnu` | \u2713 | \u2713 | MIPS (LE) Linux (kernel 4.4, glibc 2.23)\n+`mipsel-unknown-linux-musl` | \u2713 |  | MIPS (LE) Linux with MUSL\n+`nvptx64-nvidia-cuda` | \u2713 |  | --emit=asm generates PTX code that [runs on NVIDIA GPUs]\n+`powerpc-unknown-linux-gnu` | \u2713 | \u2713 | PowerPC Linux (kernel 2.6.32, glibc 2.11)\n+`powerpc64-unknown-linux-gnu` | \u2713 | \u2713 | PPC64 Linux (kernel 2.6.32, glibc 2.11)\n+`powerpc64le-unknown-linux-gnu` | \u2713 | \u2713 | PPC64LE Linux (kernel 3.10, glibc 2.17)\n+`riscv32i-unknown-none-elf` | * |  | Bare RISC-V (RV32I ISA)\n+`riscv32imac-unknown-none-elf` | * |  | Bare RISC-V (RV32IMAC ISA)\n+`riscv32imc-unknown-none-elf` | * |  | Bare RISC-V (RV32IMC ISA)\n+`riscv64gc-unknown-linux-gnu` | \u2713 | \u2713 | RISC-V Linux (kernel 4.20, glibc 2.29)\n+`riscv64gc-unknown-none-elf` | * |  | Bare RISC-V (RV64IMAFDC ISA)\n+`riscv64imac-unknown-none-elf` | * |  | Bare RISC-V (RV64IMAC ISA)\n+`s390x-unknown-linux-gnu` | \u2713 | \u2713 | S390x Linux (kernel 2.6.32, glibc 2.11)\n+`sparc64-unknown-linux-gnu` | \u2713 |  | SPARC Linux (kernel 4.4, glibc 2.23)\n+`sparcv9-sun-solaris` | \u2713 |  | SPARC Solaris 10/11, illumos\n+`thumbv6m-none-eabi` | * |  | Bare Cortex-M0, M0+, M1\n+`thumbv7em-none-eabi` | * |  | Bare Cortex-M4, M7\n+`thumbv7em-none-eabihf` | * |  | Bare Cortex-M4F, M7F, FPU, hardfloat\n+`thumbv7m-none-eabi` | * |  | Bare Cortex-M3\n+`thumbv7neon-linux-androideabi` | \u2713 |  | Thumb2-mode ARMv7a Android with NEON\n+`thumbv7neon-unknown-linux-gnueabihf` | \u2713 |  | Thumb2-mode ARMv7a Linux with NEON (kernel 4.4, glibc 2.23)\n+`thumbv8m.base-none-eabi` | * |  | ARMv8-M Baseline\n+`thumbv8m.main-none-eabi` | * |  | ARMv8-M Mainline\n+`thumbv8m.main-none-eabihf` | * |  | ARMv8-M Baseline, hardfloat\n+`wasm32-unknown-emscripten` | \u2713 |  | WebAssembly via Emscripten\n+`wasm32-unknown-unknown` | \u2713 |  | WebAssembly\n+`wasm32-wasi` | \u2713 |  | WebAssembly with WASI\n+`x86_64-apple-ios` | \u2713[^apple] |  | 64-bit x86 iOS\n+`x86_64-fortanix-unknown-sgx` | \u2713 |  | [Fortanix ABI] for 64-bit Intel SGX\n+`x86_64-fuchsia` | \u2713 |  | 64-bit Fuchsia\n+`x86_64-linux-android` | \u2713 |  | 64-bit x86 Android\n+`x86_64-rumprun-netbsd` | \u2713 |  | 64-bit NetBSD Rump Kernel\n+`x86_64-sun-solaris` | \u2713 |  | 64-bit Solaris 10/11, illumos\n+`x86_64-unknown-cloudabi` | \u2713 |  | 64-bit CloudABI\n+`x86_64-unknown-freebsd` | \u2713 | \u2713 | 64-bit FreeBSD\n+`x86_64-unknown-illumos` | \u2713 | \u2713 | illumos\n+`x86_64-unknown-linux-gnux32` | \u2713 |  | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n+`x86_64-unknown-linux-musl` | \u2713 | \u2713 | 64-bit Linux with MUSL\n+`x86_64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/amd64\n+`x86_64-unknown-redox` | \u2713 |  | Redox OS\n+\n+[Fortanix ABI]: https://edp.fortanix.com/\n+\n+## Tier 3\n+\n+Tier 3 platforms are those which the Rust codebase has support for, but which\n+are not built or tested automatically, and may not work. Official builds are\n+not available.\n+\n+target | std | host | notes\n+-------|-----|------|-------\n+`aarch64-apple-darwin` | ? |  | ARM64 macOS\n+`aarch64-apple-tvos` | *[^apple] |  | ARM64 tvOS\n+`aarch64-unknown-cloudabi` | \u2713 |  | ARM64 CloudABI\n+`aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n+`aarch64-unknown-hermit` | ? |  |\n+`aarch64-unknown-netbsd` | ? |  |\n+`aarch64-unknown-openbsd` | \u2713 | \u2713 | ARM64 OpenBSD\n+`aarch64-unknown-redox` | ? |  | ARM64 Redox OS\n+`aarch64-uwp-windows-msvc` | ? |  |\n+`aarch64-wrs-vxworks` | ? |  |\n+`armv4t-unknown-linux-gnueabi` | ? |  |\n+`armv6-unknown-freebsd` | \u2713 | \u2713 | ARMv6 FreeBSD\n+`armv6-unknown-netbsd-eabihf` | ? |  |\n+`armv7-apple-ios` | \u2713[^apple] |  | ARMv7 iOS, Cortex-a8\n+`armv7-unknown-cloudabi-eabihf` | \u2713 |  | ARMv7 CloudABI, hardfloat\n+`armv7-unknown-freebsd` | \u2713 | \u2713 | ARMv7 FreeBSD\n+`armv7-unknown-netbsd-eabihf` | ? |  |\n+`armv7-wrs-vxworks-eabihf` | ? |  |\n+`armv7a-none-eabihf` | * | | ARM Cortex-A, hardfloat\n+`armv7s-apple-ios` | \u2713[^apple] |  |\n+`avr-unknown-unknown` | ? |  | AVR\n+`hexagon-unknown-linux-musl` | ? |  |\n+`i386-apple-ios` | \u2713[^apple] |  | 32-bit x86 iOS\n+`i686-apple-darwin` | \u2713 | \u2713 | 32-bit OSX (10.7+, Lion+)\n+`i686-pc-windows-msvc` | \u2713 |  | 32-bit Windows XP support\n+`i686-unknown-cloudabi` | \u2713 |  | 32-bit CloudABI\n+`i686-unknown-uefi` | ? |  | 32-bit UEFI\n+`i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n+`i686-unknown-netbsd` | \u2713 |  | NetBSD/i386 with SSE2\n+`i686-unknown-openbsd` | \u2713 | \u2713 | 32-bit OpenBSD\n+`i686-uwp-windows-gnu` | ? |  |\n+`i686-uwp-windows-msvc` | ? |  |\n+`i686-wrs-vxworks` | ? |  |\n+`mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n+`mipsel-unknown-linux-uclibc` | \u2713 |  | MIPS (LE) Linux with uClibc\n+`mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n+`mipsisa32r6-unknown-linux-gnu` | ? |  |\n+`mipsisa32r6el-unknown-linux-gnu` | ? |  |\n+`mipsisa64r6-unknown-linux-gnuabi64` | ? |  |\n+`mipsisa64r6el-unknown-linux-gnuabi64` | ? |  |\n+`msp430-none-elf` | * |  | 16-bit MSP430 microcontrollers\n+`powerpc-unknown-linux-gnuspe` | \u2713 |  | PowerPC SPE Linux\n+`powerpc-unknown-linux-musl` | ? |  |\n+`powerpc-unknown-netbsd` | ? |  |\n+`powerpc-wrs-vxworks` | ? |  |\n+`powerpc-wrs-vxworks-spe` | ? |  |\n+`powerpc64-unknown-freebsd` | \u2713 | \u2713 | PPC64 FreeBSD (ELFv1 and ELFv2)\n+`powerpc64-unknown-linux-musl` | ? |  |\n+`powerpc64-wrs-vxworks` | ? |  |\n+`powerpc64le-unknown-linux-musl` | ? |  |\n+`sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux\n+`sparc64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/sparc64\n+`sparc64-unknown-openbsd` | ? |  |\n+`thumbv7a-pc-windows-msvc` | ? |  |\n+`thumbv7a-uwp-windows-msvc` | \u2713 |  |\n+`thumbv7neon-unknown-linux-musleabihf` | ? |  | Thumb2-mode ARMv7a Linux with NEON, MUSL\n+`thumbv4t-none-eabi` | * |  | ARMv4T T32\n+`x86_64-apple-ios-macabi` | \u2713[^apple] |  | Apple Catalyst\n+`x86_64-apple-tvos` | *[^apple] | | x86 64-bit tvOS\n+`x86_64-linux-kernel` | ? |  | Linux kernel modules\n+`x86_64-pc-solaris` | ? |  |\n+`x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n+`x86_64-unknown-dragonfly` | \u2713 | \u2713 | 64-bit DragonFlyBSD\n+`x86_64-unknown-haiku` | \u2713 | \u2713 | 64-bit Haiku\n+`x86_64-unknown-hermit` | ? |  |\n+`x86_64-unknown-hermit-kernel` | ? |  | HermitCore kernel\n+`x86_64-unknown-l4re-uclibc` | ? |  |\n+`x86_64-unknown-openbsd` | \u2713 | \u2713 | 64-bit OpenBSD\n+`x86_64-unknown-uefi` | ? |  |\n+`x86_64-uwp-windows-gnu` | \u2713 |  |\n+`x86_64-uwp-windows-msvc` | \u2713 |  |\n+`x86_64-wrs-vxworks` | ? |  |\n+\n+[runs on NVIDIA GPUs]: https://github.com/japaric-archived/nvptx#targets\n+[^apple]: These targets are only available on macOS."}, {"sha": "c33b506cdaefbbe8c7b861e02d6b97bcec0a05ae", "filename": "src/doc/rustc/src/targets/built-in.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,9 +2,14 @@\n \n `rustc` ships with the ability to compile to many targets automatically, we\n call these \"built-in\" targets, and they generally correspond to targets that\n-the team is supporting directly.\n+the team is supporting directly. To see the list of built-in targets, you can\n+run `rustc --print target-list`.\n \n-To see the list of built-in targets, you can run `rustc --print target-list`,\n-or look at [the API\n-docs](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html#modules).\n-Each module there defines a builder for a particular target.\n\\ No newline at end of file\n+Typically, a target needs a compiled copy of the Rust standard library to\n+work. If using [rustup], then check out the documentation on\n+[Cross-compilation][rustup-cross] on how to download a pre-built standard\n+library built by the official Rust distributions. Most targets will need a\n+system linker, and possibly other things.\n+\n+[rustup]: https://github.com/rust-lang/rustup\n+[rustup-cross]: https://github.com/rust-lang/rustup#cross-compilation"}, {"sha": "28a5fe31fc4b5f328e0be7dc72cf3a7e09a54d80", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -18,7 +18,15 @@ It can be used to embed handwritten assembly in the assembly output generated by\n Generally this should not be necessary, but might be where the required performance or timing\n cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.\n \n-> **Note**: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.\n+> **Note**: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.\n+\n+Inline assembly is currently supported on the following architectures:\n+- x86 and x86-64\n+- ARM\n+- AArch64\n+- RISC-V\n+- NVPTX\n+- Hexagon\n \n ## Basic usage\n \n@@ -606,6 +614,10 @@ Some registers cannot be used for input or output operands:\n | RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n | Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n \n+In some cases LLVM will allocate a \"reserved register\" for `reg` operands even though this register cannot be explicitly specified. Assembly code making use of reserved registers should be careful since `reg` operands may alias with those registers. Reserved registers are:\n+- The frame pointer on all architectures.\n+- `r6` on ARM.\n+\n ## Template modifiers\n \n The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder."}, {"sha": "5e6a0340d12a0f35d12956b32dfc93595b5efe5b", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -611,11 +611,7 @@ macro_rules! which_arena_for_type {\n \n #[macro_export]\n macro_rules! declare_arena {\n-    // This macro has to take the same input as\n-    // `impl_arena_allocatable_decoders` which requires a second version of\n-    // each type. We ignore that type until we can fix\n-    // `impl_arena_allocatable_decoders`.\n-    ([], [$($a:tt $name:ident: $ty:ty, $_gen_ty:ty;)*], $tcx:lifetime) => {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n             pub dropless: $crate::DroplessArena,"}, {"sha": "6dff02486ff197a0d58a178b19a0c0d46758fe43", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 153, "deletions": 122, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -35,6 +35,7 @@ use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n+use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::fmt;\n use std::iter;\n@@ -52,7 +53,7 @@ mod tests;\n /// ```\n ///\n /// `'outer` is a label.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Copy, HashStable_Generic)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -65,7 +66,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -89,7 +90,7 @@ impl fmt::Display for Lifetime {\n /// along with a bunch of supporting information.\n ///\n /// E.g., `std::cmp::PartialEq`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n@@ -127,7 +128,7 @@ impl Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n ///\n /// E.g., `std`, `String` or `Box<T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -155,7 +156,7 @@ impl PathSegment {\n /// The arguments of a path segment.\n ///\n /// E.g., `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArgs {\n     /// The `<'a, A, B, C>` in `foo::bar::baz::<'a, A, B, C>`.\n     AngleBracketed(AngleBracketedArgs),\n@@ -187,7 +188,7 @@ impl GenericArgs {\n }\n \n /// Concrete argument in the sequence of generic args.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArg {\n     /// `'a` in `Foo<'a>`\n     Lifetime(Lifetime),\n@@ -208,7 +209,7 @@ impl GenericArg {\n }\n \n /// A path like `Foo<'a, T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n@@ -218,7 +219,7 @@ pub struct AngleBracketedArgs {\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n /// or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AngleBracketedArg {\n     /// Argument for a generic parameter.\n     Arg(GenericArg),\n@@ -239,7 +240,7 @@ impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n }\n \n /// A path like `Foo(A, B) -> C`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n@@ -268,7 +269,7 @@ pub use crate::node_id::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n /// A modifier on a bound, e.g., `?Sized` or `?const Trait`.\n ///\n /// Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n pub enum TraitBoundModifier {\n     /// No modifiers\n     None,\n@@ -289,7 +290,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -309,24 +310,54 @@ pub type GenericBounds = Vec<GenericBound>;\n /// Specifies the enforced ordering for generic parameters. In the future,\n /// if we wanted to relax this order, we could override `PartialEq` and\n /// `PartialOrd`, to allow the kinds to be unordered.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\n+#[derive(Hash, Clone, Copy)]\n pub enum ParamKindOrd {\n     Lifetime,\n     Type,\n-    Const,\n+    // `unordered` is only `true` if `sess.has_features().const_generics`\n+    // is active. Specifically, if it's only `min_const_generics`, it will still require\n+    // ordering consts after types.\n+    Const { unordered: bool },\n+}\n+\n+impl Ord for ParamKindOrd {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        use ParamKindOrd::*;\n+        let to_int = |v| match v {\n+            Lifetime => 0,\n+            Type | Const { unordered: true } => 1,\n+            // technically both consts should be ordered equally,\n+            // but only one is ever encountered at a time, so this is\n+            // fine.\n+            Const { unordered: false } => 2,\n+        };\n+\n+        to_int(*self).cmp(&to_int(*other))\n+    }\n }\n+impl PartialOrd for ParamKindOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl PartialEq for ParamKindOrd {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(other) == Ordering::Equal\n+    }\n+}\n+impl Eq for ParamKindOrd {}\n \n impl fmt::Display for ParamKindOrd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ParamKindOrd::Lifetime => \"lifetime\".fmt(f),\n             ParamKindOrd::Type => \"type\".fmt(f),\n-            ParamKindOrd::Const => \"const\".fmt(f),\n+            ParamKindOrd::Const { .. } => \"const\".fmt(f),\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime,\n@@ -340,7 +371,7 @@ pub enum GenericParamKind {\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -352,7 +383,7 @@ pub struct GenericParam {\n \n /// Represents lifetime, type and const parameters attached to a declaration of\n /// a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n     pub params: Vec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -375,7 +406,7 @@ impl Default for Generics {\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereClause {\n     /// `true` if we ate a `where` token: this can happen\n     /// if we parsed no predicates (e.g. `struct Foo where {}`).\n@@ -387,7 +418,7 @@ pub struct WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -410,7 +441,7 @@ impl WherePredicate {\n /// A type bound.\n ///\n /// E.g., `for<'c> Foo: Send + Clone + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -424,7 +455,7 @@ pub struct WhereBoundPredicate {\n /// A lifetime predicate.\n ///\n /// E.g., `'a: 'b + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n@@ -434,15 +465,15 @@ pub struct WhereRegionPredicate {\n /// An equality predicate (unsupported).\n ///\n /// E.g., `T = int`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -459,7 +490,7 @@ pub struct Crate {\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n@@ -472,7 +503,7 @@ pub enum NestedMetaItem {\n /// A spanned compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MetaItem {\n     pub path: Path,\n     pub kind: MetaItemKind,\n@@ -482,7 +513,7 @@ pub struct MetaItem {\n /// A compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -501,7 +532,7 @@ pub enum MetaItemKind {\n /// A block (`{ .. }`).\n ///\n /// E.g., `{ .. }` as in `fn foo() { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n     pub stmts: Vec<Stmt>,\n@@ -514,7 +545,7 @@ pub struct Block {\n /// A match pattern.\n ///\n /// Patterns appear in match statements and some other contexts, such as `let` and `if let`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n@@ -605,7 +636,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except is_shorthand is true\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n     pub ident: Ident,\n@@ -618,27 +649,27 @@ pub struct FieldPat {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BindingMode {\n     ByRef(Mutability),\n     ByValue(Mutability),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeEnd {\n     Included(RangeSyntax),\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeSyntax {\n     /// `...`\n     DotDotDot,\n     /// `..=`\n     DotDotEq,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`).\n     Wild,\n@@ -705,8 +736,8 @@ pub enum PatKind {\n     MacCall(MacCall),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n     Mut,\n     Not,\n@@ -739,7 +770,7 @@ impl Mutability {\n /// The kind of borrow in an `AddrOf` expression,\n /// e.g., `&place` or `&raw const place`.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum BorrowKind {\n     /// A normal borrow, `&$expr` or `&mut $expr`.\n     /// The resulting type is either `&'a T` or `&'a mut T`\n@@ -751,7 +782,7 @@ pub enum BorrowKind {\n     Raw,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n     Add,\n@@ -850,7 +881,7 @@ pub type BinOp = Spanned<BinOpKind>;\n /// Unary operator.\n ///\n /// Note that `&data` is not an operator, it's an `AddrOf` expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n     Deref,\n@@ -879,7 +910,7 @@ impl UnOp {\n }\n \n /// A statement\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n@@ -913,7 +944,7 @@ impl Stmt {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n@@ -929,7 +960,7 @@ pub enum StmtKind {\n     MacCall(P<(MacCall, MacStmtStyle, AttrVec)>),\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon (e.g., `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`).\n@@ -943,7 +974,7 @@ pub enum MacStmtStyle {\n }\n \n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Local {\n     pub id: NodeId,\n     pub pat: P<Pat>,\n@@ -964,7 +995,7 @@ pub struct Local {\n ///     _ => { println!(\"no match!\") },\n /// }\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     /// Match arm pattern, e.g. `10` in `match foo { 10 => {}, _ => {} }`\n@@ -979,7 +1010,7 @@ pub struct Arm {\n }\n \n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Field {\n     pub attrs: AttrVec,\n     pub id: NodeId,\n@@ -990,13 +1021,13 @@ pub struct Field {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n     Unsafe(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1007,14 +1038,14 @@ pub enum UnsafeSource {\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AnonConst {\n     pub id: NodeId,\n     pub value: P<Expr>,\n }\n \n /// An expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n@@ -1173,15 +1204,15 @@ impl Expr {\n }\n \n /// Limit types of a range (inclusive or exclusive)\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug)]\n pub enum RangeLimits {\n     /// Inclusive at the beginning, exclusive at the end\n     HalfOpen,\n     /// Inclusive at the beginning and end\n     Closed,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1338,7 +1369,7 @@ pub enum ExprKind {\n ///  ^~~~~    ^\n ///  ty       position = 0\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n \n@@ -1350,7 +1381,7 @@ pub struct QSelf {\n }\n \n /// A capture clause used in closures and `async` blocks.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CaptureBy {\n     /// `move |x| y + x`.\n     Value,\n@@ -1360,7 +1391,7 @@ pub enum CaptureBy {\n \n /// The movability of a generator / closure literal:\n /// whether a generator contains self-references, causing it to be `!Unpin`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum Movability {\n     /// May contain self-references, `!Unpin`.\n@@ -1371,7 +1402,7 @@ pub enum Movability {\n \n /// Represents a macro invocation. The `path` indicates which macro\n /// is being invoked, and the `args` are arguments passed to it.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n     pub args: P<MacArgs>,\n@@ -1385,7 +1416,7 @@ impl MacCall {\n }\n \n /// Arguments passed to an attribute or a function-like macro.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacArgs {\n     /// No arguments - `#[attr]`.\n     Empty,\n@@ -1446,7 +1477,7 @@ impl MacArgs {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n     Bracket,\n@@ -1473,14 +1504,14 @@ impl MacDelimiter {\n }\n \n /// Represents a macro definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n     pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, Eq, PartialEq)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n@@ -1492,7 +1523,7 @@ pub enum StrStyle {\n }\n \n /// An AST literal.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     /// The original literal token as written in source code.\n     pub token: token::Lit,\n@@ -1504,7 +1535,7 @@ pub struct Lit {\n }\n \n /// Same as `Lit`, but restricted to string literals.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n     /// The original literal token as written in source code.\n     pub style: StrStyle,\n@@ -1531,7 +1562,7 @@ impl StrLit {\n }\n \n /// Type of the integer literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitIntType {\n     /// e.g. `42_i32`.\n@@ -1543,7 +1574,7 @@ pub enum LitIntType {\n }\n \n /// Type of the float literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitFloatType {\n     /// A float literal with a suffix (`1f32` or `1E10f32`).\n@@ -1555,7 +1586,7 @@ pub enum LitFloatType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),\n@@ -1627,22 +1658,22 @@ impl LitKind {\n \n // N.B., If you change this, you'll probably want to change the corresponding\n // type structure in `middle/ty.rs` as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or free function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum FloatTy {\n     F32,\n     F64,\n@@ -1671,8 +1702,8 @@ impl FloatTy {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -1736,8 +1767,8 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -1800,7 +1831,7 @@ impl UintTy {\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1809,22 +1840,22 @@ pub struct AssocTyConstraint {\n }\n \n /// The kinds of an `AssocTyConstraint`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocTyConstraintKind {\n     /// E.g., `A = Bar` in `Foo<A = Bar>`.\n     Equality { ty: P<Ty> },\n     /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n     Bound { bounds: GenericBounds },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n@@ -1833,7 +1864,7 @@ pub struct BareFnTy {\n }\n \n /// The various kinds of type recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum TyKind {\n     /// A variable-length slice (`[T]`).\n     Slice(P<Ty>),\n@@ -1892,7 +1923,7 @@ impl TyKind {\n }\n \n /// Syntax used to declare a trait object.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum TraitObjectSyntax {\n     Dyn,\n     None,\n@@ -1901,14 +1932,14 @@ pub enum TraitObjectSyntax {\n /// Inline assembly operand explicit register or register class.\n ///\n /// E.g., `\"eax\"` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(Symbol),\n     RegClass(Symbol),\n }\n \n bitflags::bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+    #[derive(Encodable, Decodable, HashStable_Generic)]\n     pub struct InlineAsmOptions: u8 {\n         const PURE = 1 << 0;\n         const NOMEM = 1 << 1;\n@@ -1920,7 +1951,7 @@ bitflags::bitflags! {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum InlineAsmTemplatePiece {\n     String(String),\n     Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n@@ -1964,7 +1995,7 @@ impl InlineAsmTemplatePiece {\n /// Inline assembly operand.\n ///\n /// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum InlineAsmOperand {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -1997,7 +2028,7 @@ pub enum InlineAsmOperand {\n /// Inline assembly.\n ///\n /// E.g., `asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n@@ -2008,7 +2039,7 @@ pub struct InlineAsm {\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum LlvmAsmDialect {\n     Att,\n     Intel,\n@@ -2017,7 +2048,7 @@ pub enum LlvmAsmDialect {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `\"={eax}\"(result)` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub expr: P<Expr>,\n@@ -2028,7 +2059,7 @@ pub struct LlvmInlineAsmOutput {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `llvm_asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2043,7 +2074,7 @@ pub struct LlvmInlineAsm {\n /// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Param {\n     pub attrs: AttrVec,\n     pub ty: P<Ty>,\n@@ -2056,7 +2087,7 @@ pub struct Param {\n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n ///\n /// E.g., `&mut self` as in `fn foo(&mut self)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum SelfKind {\n     /// `self`, `mut self`\n     Value(Mutability),\n@@ -2134,7 +2165,7 @@ impl Param {\n ///\n /// Please note that it's different from `FnHeader` structure\n /// which contains metadata about function safety, asyncness, constness and ABI.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Param>,\n     pub output: FnRetTy,\n@@ -2156,20 +2187,20 @@ impl FnDecl {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum IsAuto {\n     Yes,\n     No,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Unsafe {\n     Yes(Span),\n     No,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug)]\n pub enum Async {\n     Yes { span: Span, closure_id: NodeId, return_impl_trait_id: NodeId },\n     No,\n@@ -2189,7 +2220,7 @@ impl Async {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Const {\n     Yes(Span),\n@@ -2198,13 +2229,13 @@ pub enum Const {\n \n /// Item defaultness.\n /// For details see the [RFC #2532](https://github.com/rust-lang/rfcs/pull/2532).\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum Defaultness {\n     Default(Span),\n     Final,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -2221,7 +2252,7 @@ impl fmt::Debug for ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FnRetTy {\n     /// Returns type is not specified.\n     ///\n@@ -2244,7 +2275,7 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2258,7 +2289,7 @@ pub struct Mod {\n /// Foreign module declaration.\n ///\n /// E.g., `extern { .. }` or `extern C { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ForeignMod {\n     pub abi: Option<StrLit>,\n     pub items: Vec<P<ForeignItem>>,\n@@ -2267,17 +2298,17 @@ pub struct ForeignMod {\n /// Global inline assembly.\n ///\n /// Also known as \"module-level assembly\" or \"file-scoped assembly\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n /// Enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Variant {\n     /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n@@ -2299,7 +2330,7 @@ pub struct Variant {\n }\n \n /// Part of `use` item to the right of its prefix.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     ///\n@@ -2314,7 +2345,7 @@ pub enum UseTreeKind {\n \n /// A tree of paths sharing common prefixes.\n /// Used in `use` items both at top-level and inside of braces in import groups.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct UseTree {\n     pub prefix: Path,\n     pub kind: UseTreeKind,\n@@ -2336,7 +2367,7 @@ impl UseTree {\n /// Distinguishes between `Attribute`s that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum AttrStyle {\n     Outer,\n     Inner,\n@@ -2349,19 +2380,19 @@ rustc_index::newtype_index! {\n     }\n }\n \n-impl rustc_serialize::Encodable for AttrId {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl rustc_serialize::Decodable for AttrId {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AttrId, D::Error> {\n+impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n+    fn decode(d: &mut D) -> Result<AttrId, D::Error> {\n         d.read_nil().map(|_| crate::attr::mk_attr_id())\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n@@ -2371,7 +2402,7 @@ pub struct AttrItem {\n pub type AttrVec = ThinVec<Attribute>;\n \n /// Metadata associated with an item.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n     pub id: AttrId,\n@@ -2381,7 +2412,7 @@ pub struct Attribute {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n     Normal(AttrItem),\n@@ -2398,13 +2429,13 @@ pub enum AttrKind {\n /// that the `ref_id` is for. The `impl_id` maps to the \"self type\" of this impl.\n /// If this impl is an `ItemKind::Impl`, the `impl_id` is redundant (it could be the\n /// same as the impl's `NodeId`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: Vec<GenericParam>,\n@@ -2425,7 +2456,7 @@ impl PolyTraitRef {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CrateSugar {\n     /// Source is `pub(crate)`.\n     PubCrate,\n@@ -2436,7 +2467,7 @@ pub enum CrateSugar {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -2453,7 +2484,7 @@ impl VisibilityKind {\n /// Field of a struct.\n ///\n /// E.g., `bar: usize` as in `struct Foo { bar: usize }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructField {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2466,7 +2497,7 @@ pub struct StructField {\n }\n \n /// Fields and constructor ids of enum variants and structs.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n@@ -2501,7 +2532,7 @@ impl VariantData {\n }\n \n /// An item definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2538,7 +2569,7 @@ impl<K: Into<ItemKind>> Item<K> {\n }\n \n /// `extern` qualifier on a function item or function type.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {\n     None,\n     Implicit,\n@@ -2555,7 +2586,7 @@ impl Extern {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafe,\n     pub asyncness: Async,\n@@ -2585,7 +2616,7 @@ impl Default for FnHeader {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n     ///\n@@ -2724,7 +2755,7 @@ pub type AssocItem = Item<AssocItemKind>;\n /// In an implementation, all items must be provided.\n /// The `Option`s below denote the bodies, where `Some(_)`\n /// means \"provided\" and conversely `None` means \"required\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocItemKind {\n     /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n     /// If `def` is parsed, then the constant is provided, and otherwise required.\n@@ -2772,7 +2803,7 @@ impl TryFrom<ItemKind> for AssocItemKind {\n }\n \n /// An item in `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ForeignItemKind {\n     /// A foreign static item (`static FOO: u8`).\n     Static(P<Ty>, Mutability, Option<P<Expr>>),"}, {"sha": "8ba55bf037b12bd15f1fdd1aeaeba8225442e215", "filename": "src/librustc_ast/ast/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fast%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fast%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,6 +3,9 @@ use super::*;\n // Are ASTs encodable?\n #[test]\n fn check_asts_encodable() {\n-    fn assert_encodable<T: rustc_serialize::Encodable>() {}\n+    fn assert_encodable<\n+        T: for<'a> rustc_serialize::Encodable<rustc_serialize::json::Encoder<'a>>,\n+    >() {\n+    }\n     assert_encodable::<Crate>();\n }"}, {"sha": "bd7d85167140dfe4e28a712edf85a4d17dfbf8dc", "filename": "src/librustc_ast/crate_disambiguator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fcrate_disambiguator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fcrate_disambiguator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fcrate_disambiguator.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,7 +9,7 @@ use std::fmt;\n /// Hash value constructed out of all the `-C metadata` arguments passed to the\n /// compiler. Together with the crate-name forms a unique global identifier for\n /// the crate.\n-#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, Encodable, Decodable)]\n pub struct CrateDisambiguator(Fingerprint);\n \n impl CrateDisambiguator {"}, {"sha": "fb5ce3118262782fc9e264f47a1264fd9f0d7f96", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -18,8 +18,7 @@\n #![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n #[macro_export]"}, {"sha": "1035e945538f5b10136b7b4547f8728ed9c6a646", "filename": "src/librustc_ast/node_id.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fnode_id.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,10 +1,8 @@\n-use rustc_serialize::{Decoder, Encoder};\n use rustc_span::ExpnId;\n use std::fmt;\n \n rustc_index::newtype_index! {\n     pub struct NodeId {\n-        ENCODABLE = custom\n         DEBUG_FORMAT = \"NodeId({})\"\n     }\n }\n@@ -34,15 +32,3 @@ impl fmt::Display for NodeId {\n         fmt::Display::fmt(&self.as_u32(), f)\n     }\n }\n-\n-impl rustc_serialize::UseSpecializedEncodable for NodeId {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.as_u32())\n-    }\n-}\n-\n-impl rustc_serialize::UseSpecializedDecodable for NodeId {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<NodeId, D::Error> {\n-        d.read_u32().map(NodeId::from_u32)\n-    }\n-}"}, {"sha": "e4a3cccb7ead1c9c30efed20cb687f30759fac55", "filename": "src/librustc_ast/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fptr.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -114,14 +114,14 @@ impl<T> fmt::Pointer for P<T> {\n     }\n }\n \n-impl<T: 'static + Decodable> Decodable for P<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n+impl<D: Decoder, T: 'static + Decodable<D>> Decodable<D> for P<T> {\n+    fn decode(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n     }\n }\n \n-impl<T: Encodable> Encodable for P<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n@@ -197,14 +197,14 @@ impl<'a, T> IntoIterator for &'a P<[T]> {\n     }\n }\n \n-impl<T: Encodable> Encodable for P<[T]> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<[T]> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&**self, s)\n     }\n }\n \n-impl<T: Decodable> Decodable for P<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for P<[T]> {\n+    fn decode(d: &mut D) -> Result<P<[T]>, D::Error> {\n         Ok(P::from_vec(Decodable::decode(d)?))\n     }\n }"}, {"sha": "46c4be0a33bf76af3b9ae1e8e287ac4792bda563", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -17,13 +17,13 @@ use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CommentKind {\n     Line,\n     Block,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum BinOpToken {\n     Plus,\n@@ -39,7 +39,7 @@ pub enum BinOpToken {\n }\n \n /// A delimiter token.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum DelimToken {\n     /// A round parenthesis (i.e., `(` or `)`).\n@@ -62,7 +62,7 @@ impl DelimToken {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n     Byte,\n@@ -77,7 +77,7 @@ pub enum LitKind {\n }\n \n /// A literal token.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     pub kind: LitKind,\n     pub symbol: Symbol,\n@@ -188,7 +188,7 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n     Eq,\n@@ -267,7 +267,7 @@ pub enum TokenKind {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n     pub span: Span,\n@@ -688,7 +688,7 @@ impl PartialEq<TokenKind> for Token {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Encodable, Decodable)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(P<ast::Item>),\n@@ -711,7 +711,7 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n-#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n     Item,\n     Block,"}, {"sha": "151acddae840e567c171362311ce6813f6603c5b", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -35,7 +35,7 @@ use std::{iter, mem};\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum TokenTree {\n     /// A single token\n     Token(Token),\n@@ -124,7 +124,7 @@ where\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n-#[derive(Clone, Debug, Default, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Default, Encodable, Decodable)]\n pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n@@ -133,7 +133,7 @@ pub type TreeAndJoint = (TokenTree, IsJoint);\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n pub enum IsJoint {\n     Joint,\n     NonJoint,\n@@ -408,7 +408,7 @@ impl Cursor {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub struct DelimSpan {\n     pub open: Span,\n     pub close: Span,"}, {"sha": "2ee94965756a5e0d72fc8bbe084b628f1c49f799", "filename": "src/librustc_ast/util/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fparser.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -222,7 +222,6 @@ impl AssocOp {\n             Greater | // `{ 42 } > 3`\n             GreaterEqual | // `{ 42 } >= 3`\n             AssignOp(_) | // `{ 42 } +=`\n-            LAnd | // `{ 42 } &&foo`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n             // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery."}, {"sha": "b65a88cb90e88501721432cced016e00185e3cef", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -50,6 +50,13 @@ impl<'a> FnKind<'a> {\n         }\n     }\n \n+    pub fn ident(&self) -> Option<&Ident> {\n+        match self {\n+            FnKind::Fn(_, ident, ..) => Some(ident),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn decl(&self) -> &'a FnDecl {\n         match self {\n             FnKind::Fn(_, _, sig, _, _) => &sig.decl,"}, {"sha": "3c2a063cf24814f6e66ec28976c01adcc86331f2", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -773,13 +773,13 @@ fn validate_generic_param_order<'a>(\n         err.span_suggestion(\n             span,\n             &format!(\n-                \"reorder the parameters: lifetimes, then types{}\",\n-                if sess.features_untracked().const_generics\n-                    || sess.features_untracked().min_const_generics\n-                {\n-                    \", then consts\"\n+                \"reorder the parameters: lifetimes{}\",\n+                if sess.features_untracked().const_generics {\n+                    \", then consts and types\"\n+                } else if sess.features_untracked().min_const_generics {\n+                    \", then types, then consts\"\n                 } else {\n-                    \"\"\n+                    \", then types\"\n                 },\n             ),\n             ordered_params.clone(),\n@@ -1156,7 +1156,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n                     GenericParamKind::Const { ref ty, kw_span: _ } => {\n                         let ty = pprust::ty_to_string(ty);\n-                        (ParamKindOrd::Const, Some(format!(\"const {}: {}\", param.ident, ty)))\n+                        let unordered = self.session.features_untracked().const_generics;\n+                        (\n+                            ParamKindOrd::Const { unordered },\n+                            Some(format!(\"const {}: {}\", param.ident, ty)),\n+                        )\n                     }\n                 };\n                 (kind, Some(&*param.bounds), param.ident.span, ident)"}, {"sha": "35bdf747f08d7d3e2be12f99fec0c32a6bdec0bc", "filename": "src/librustc_attr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,6 +16,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "3ddabcc17f8b696a86e088e2cd9fd8430e398993", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -20,6 +20,7 @@ enum AttrError {\n     MultipleItem(String),\n     UnknownMetaItem(String, &'static [&'static str]),\n     MissingSince,\n+    NonIdentFeature,\n     MissingFeature,\n     MultipleStabilityLevels,\n     UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n@@ -40,6 +41,9 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n         AttrError::MissingSince => {\n             struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n         }\n+        AttrError::NonIdentFeature => {\n+            struct_span_err!(diag, span, E0546, \"'feature' is not an identifier\").emit();\n+        }\n         AttrError::MissingFeature => {\n             struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n         }\n@@ -63,15 +67,15 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Encodable, Decodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Encodable, Decodable)]\n pub enum OptimizeAttr {\n     None,\n     Speed,\n@@ -126,15 +130,15 @@ pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAtt\n ///\n /// - `#[stable]`\n /// - `#[unstable]`\n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n }\n \n /// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct ConstStability {\n     pub level: StabilityLevel,\n@@ -146,7 +150,7 @@ pub struct ConstStability {\n }\n \n /// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n+#[derive(Encodable, Decodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue\n@@ -344,6 +348,14 @@ where\n \n                     match (feature, reason, issue) {\n                         (Some(feature), reason, Some(_)) => {\n+                            if !rustc_lexer::is_ident(&feature.as_str()) {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    attr.span,\n+                                    AttrError::NonIdentFeature,\n+                                );\n+                                continue;\n+                            }\n                             let level = Unstable { reason, issue: issue_num, is_soft };\n                             if sym::unstable == meta_name {\n                                 stab = Some(Stability { level, feature });\n@@ -620,7 +632,7 @@ pub fn eval_condition(\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone, HashStable_Generic)]\n+#[derive(Encodable, Decodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     /// The note to issue a reason.\n@@ -785,7 +797,7 @@ where\n     depr\n }\n \n-#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+#[derive(PartialEq, Debug, Encodable, Decodable, Copy, Clone)]\n pub enum ReprAttr {\n     ReprInt(IntType),\n     ReprC,\n@@ -796,7 +808,8 @@ pub enum ReprAttr {\n     ReprNoNiche,\n }\n \n-#[derive(Eq, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone, HashStable_Generic)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy),"}, {"sha": "149a950f7d417ca3977f15c5bacd141ab5863176", "filename": "src/librustc_attr/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_attr%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -6,8 +6,7 @@\n \n #![feature(or_patterns)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n mod builtin;"}, {"sha": "78cead02b7b7cc6fcdfaf1121a45a4b7032ae6e2", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -149,7 +149,7 @@ fn parse_args<'a>(\n                 return Err(err);\n             } else {\n                 // ...after that delegate to `expect` to also include the other expected tokens.\n-                return Err(p.expect(&token::Comma).err().unwrap());\n+                let _ = p.expect(&token::Comma)?;\n             }\n         }\n         first = false;\n@@ -359,24 +359,18 @@ impl<'a, 'b> Context<'a, 'b> {\n             // for `println!(\"{7:7$}\", 1);`\n             refs.sort();\n             refs.dedup();\n-            let (arg_list, mut sp) = if refs.len() == 1 {\n-                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n-                (\n-                    format!(\"argument {}\", refs[0]),\n-                    if spans.is_empty() {\n-                        MultiSpan::from_span(self.fmtsp)\n-                    } else {\n-                        MultiSpan::from_spans(spans)\n-                    },\n-                )\n+            let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n+            let sp = if self.arg_spans.is_empty() || spans.is_empty() {\n+                MultiSpan::from_span(self.fmtsp)\n+            } else {\n+                MultiSpan::from_spans(spans)\n+            };\n+            let arg_list = if refs.len() == 1 {\n+                format!(\"argument {}\", refs[0])\n             } else {\n-                let pos = MultiSpan::from_spans(spans.into_iter().map(|s| *s.unwrap()).collect());\n                 let reg = refs.pop().unwrap();\n-                (format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg,), pos)\n+                format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg)\n             };\n-            if self.arg_spans.is_empty() {\n-                sp = MultiSpan::from_span(self.fmtsp);\n-            }\n \n             e = self.ecx.struct_span_err(\n                 sp,\n@@ -1067,10 +1061,9 @@ pub fn expand_preparsed_format_args(\n         let args_unused = errs_len;\n \n         let mut diag = {\n-            if errs_len == 1 {\n-                let (sp, msg) = errs.into_iter().next().unwrap();\n-                let mut diag = cx.ecx.struct_span_err(sp, msg);\n-                diag.span_label(sp, msg);\n+            if let [(sp, msg)] = &errs[..] {\n+                let mut diag = cx.ecx.struct_span_err(*sp, *msg);\n+                diag.span_label(*sp, *msg);\n                 diag\n             } else {\n                 let mut diag = cx.ecx.struct_span_err("}, {"sha": "6f386c1287ca08a4d697425ee8377c8841ffba18", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -975,7 +975,6 @@ pub unsafe fn with_llvm_pmb(\n         (llvm::CodeGenOptLevel::Default, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n-        (llvm::CodeGenOptLevel::Other, ..) => bug!(\"CodeGenOptLevel::Other selected\"),\n     }\n \n     f(builder);"}, {"sha": "e3d90626e463bb327eedcd4e422b2a91481c4fbd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -728,20 +728,25 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // codegen. Note that this has a semantic difference in that the\n         // intrinsic can trap whereas `fptoui` never traps. That difference,\n         // however, is handled by `fptosui_may_trap` above.\n+        //\n+        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n+        // must be used instead.\n         if self.wasm_and_missing_nontrapping_fptoint() {\n             let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return self.call(intrinsic, &[val], None);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n             }\n         }\n         unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n@@ -750,18 +755,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         if self.wasm_and_missing_nontrapping_fptoint() {\n             let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return self.call(intrinsic, &[val], None);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n             }\n         }\n         unsafe { llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty, UNNAMED) }"}, {"sha": "5ce06a940d485bd286afeacf21ff0111b498afa4", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -41,15 +41,15 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             // some arbitrary byte value.\n             //\n             // FIXME: relay undef bytes to codegen as undef const bytes\n-            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n             llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n             // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n             // affect interpreter execution (we inspect the result after interpreter execution),\n             // and we properly interpret the relocation as a relocation pointer offset.\n-            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n+            alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n@@ -74,7 +74,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         // arbitrary byte value.\n         //\n         // FIXME: relay undef bytes to codegen as undef const bytes\n-        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n         llvals.push(cx.const_bytes(bytes));\n     }\n \n@@ -452,7 +452,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // BSS.\n                     let all_bytes_are_zero = alloc.relocations().is_empty()\n                         && alloc\n-                            .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n                             .all(|&byte| byte == 0);\n \n@@ -480,7 +480,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n                     let bytes =\n-                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len());\n+                        alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n                         bytes.as_ptr().cast(),"}, {"sha": "54570920219632db2956298b144631f3684b5ac9", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,7 +7,7 @@ use libc::c_uint;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage, Region};\n use rustc_codegen_ssa::traits::{\n-    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n+    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, MiscMethods, StaticMethods,\n };\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n@@ -44,6 +44,16 @@ impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n }\n \n impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    /// Calls llvm::createPGOFuncNameVar() with the given function instance's mangled function name.\n+    /// The LLVM API returns an llvm::GlobalVariable containing the function name, with the specific\n+    /// variable name and linkage required by LLVM InstrProf source-based coverage instrumentation.\n+    fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value {\n+        let llfn = self.cx.get_fn(instance);\n+        let mangled_fn_name = CString::new(self.tcx.symbol_name(instance).name)\n+            .expect(\"error converting function name to C string\");\n+        unsafe { llvm::LLVMRustCoverageCreatePGOFuncNameVar(llfn, mangled_fn_name.as_ptr()) }\n+    }\n+\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,"}, {"sha": "323c29e82d0dd33deb6378800613f3ae72ccdd42", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -215,19 +215,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             sym::count_code_region => {\n-                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n-                let mangled_fn = tcx.symbol_name(caller_instance);\n-                let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n-                let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n+                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n+\n+                let fn_name = self.create_pgo_func_name_var(caller_instance);\n                 let hash = args[FUNCTION_SOURCE_HASH].immediate();\n+                let num_counters = self.const_u32(coverageinfo.num_counters);\n                 let index = args[COUNTER_ID].immediate();\n                 debug!(\n                     \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n-                    instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    mangled_fn.name, hash, num_counters, index,\n+                    instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    fn_name, hash, num_counters, index,\n                 );\n-                self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n+                self.instrprof_increment(fn_name, hash, num_counters, index)\n             }\n             sym::va_start => self.va_start(args[0].immediate()),\n             sym::va_end => self.va_end(args[0].immediate()),"}, {"sha": "63b0aa64bd3d8dca8029397c0393b7e5cb5c76f0", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -337,17 +337,13 @@ impl AtomicOrdering {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum SynchronizationScope {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     SingleThread,\n     CrossThread,\n }\n \n impl SynchronizationScope {\n     pub fn from_generic(sc: rustc_codegen_ssa::common::SynchronizationScope) -> Self {\n         match sc {\n-            rustc_codegen_ssa::common::SynchronizationScope::Other => SynchronizationScope::Other,\n             rustc_codegen_ssa::common::SynchronizationScope::SingleThread => {\n                 SynchronizationScope::SingleThread\n             }\n@@ -362,9 +358,6 @@ impl SynchronizationScope {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum FileType {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     AssemblyFile,\n     ObjectFile,\n }\n@@ -391,9 +384,6 @@ pub enum MetadataType {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum AsmDialect {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     Att,\n     Intel,\n }\n@@ -411,9 +401,6 @@ impl AsmDialect {\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     None,\n     Less,\n     Default,\n@@ -513,9 +500,6 @@ pub enum DiagnosticLevel {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum ArchiveKind {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     K_GNU,\n     K_BSD,\n     K_DARWIN,\n@@ -1802,6 +1786,8 @@ extern \"C\" {\n         BufferOut: &RustString,\n     );\n \n+    pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n+    -> &'a Value;\n     pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n \n     #[allow(improper_ctypes)]"}, {"sha": "f0b50459837e93d3bb8793ad0800e64144e69f29", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -73,7 +73,8 @@ unsafe fn configure_llvm(sess: &Session) {\n                 llvm_c_strs.push(s);\n             }\n         };\n-        add(\"rustc\", true); // fake program name\n+        // Set the llvm \"program name\" to make usage and invalid argument messages more clear.\n+        add(\"rustc -Cllvm-args=\\\"...\\\" with\", true);\n         if sess.time_llvm_passes() {\n             add(\"-time-passes\", false);\n         }"}, {"sha": "5707d3cd0ed213a0e35ac170e1a9e352d3cf423f", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -33,5 +33,6 @@ rustc_fs_util = { path = \"../librustc_fs_util\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "5de7ffbcfcbfbe8fbf83702e4b127dbe23858a7e", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,4 +1,5 @@\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLib};\n@@ -23,7 +24,7 @@ use super::rpath::{self, RPathConfig};\n use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n \n use cc::windows_registry;\n-use tempfile::{Builder as TempFileBuilder, TempDir};\n+use tempfile::Builder as TempFileBuilder;\n \n use std::ffi::OsString;\n use std::path::{Path, PathBuf};\n@@ -70,35 +71,29 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             }\n         });\n \n-        let tmpdir = TempFileBuilder::new()\n-            .prefix(\"rustc\")\n-            .tempdir()\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n         if outputs.outputs.should_codegen() {\n+            let tmpdir = TempFileBuilder::new()\n+                .prefix(\"rustc\")\n+                .tempdir()\n+                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+            let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n             let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n             match crate_type {\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n-                    link_rlib::<B>(\n-                        sess,\n-                        codegen_results,\n-                        RlibFlavor::Normal,\n-                        &out_filename,\n-                        &tmpdir,\n-                    )\n-                    .build();\n+                    link_rlib::<B>(sess, codegen_results, RlibFlavor::Normal, &out_filename, &path)\n+                        .build();\n                 }\n                 CrateType::Staticlib => {\n-                    link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+                    link_staticlib::<B>(sess, codegen_results, &out_filename, &path);\n                 }\n                 _ => {\n                     link_natively::<B>(\n                         sess,\n                         crate_type,\n                         &out_filename,\n                         codegen_results,\n-                        tmpdir.path(),\n+                        path.as_ref(),\n                         target_cpu,\n                     );\n                 }\n@@ -107,10 +102,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                 sess.parse_sess.span_diagnostic.emit_artifact_notification(&out_filename, \"link\");\n             }\n         }\n-\n-        if sess.opts.cg.save_temps {\n-            let _ = tmpdir.into_path();\n-        }\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -279,8 +270,8 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &TempDir) -> PathBuf {\n-    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n+pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeTempDir) -> PathBuf {\n+    let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &metadata.raw_data);\n \n     if let Err(e) = result {\n@@ -301,7 +292,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n     flavor: RlibFlavor,\n     out_filename: &Path,\n-    tmpdir: &TempDir,\n+    tmpdir: &MaybeTempDir,\n ) -> B {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n@@ -406,7 +397,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n-    tempdir: &TempDir,\n+    tempdir: &MaybeTempDir,\n ) {\n     let mut ab =\n         link_rlib::<B>(sess, codegen_results, RlibFlavor::StaticlibBase, out_filename, tempdir);\n@@ -778,9 +769,22 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n }\n \n fn link_sanitizers(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n-    if crate_type != CrateType::Executable {\n+    // On macOS the runtimes are distributed as dylibs which should be linked to\n+    // both executables and dynamic shared objects. Everywhere else the runtimes\n+    // are currently distributed as static liraries which should be linked to\n+    // executables only.\n+    let needs_runtime = match crate_type {\n+        CrateType::Executable => true,\n+        CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n+            sess.target.target.options.is_like_osx\n+        }\n+        CrateType::Rlib | CrateType::Staticlib => false,\n+    };\n+\n+    if !needs_runtime {\n         return;\n     }\n+\n     let sanitizer = sess.opts.debugging_opts.sanitizer;\n     if sanitizer.contains(SanitizerSet::ADDRESS) {\n         link_sanitizer_runtime(sess, linker, \"asan\");"}, {"sha": "5100ef8ad4fd7cb5ab7590c6284c19c0bc59debd", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -35,7 +35,7 @@ pub fn disable_localization(linker: &mut Command) {\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct LinkerInfo {\n     exports: FxHashMap<CrateType, Vec<String>>,\n }"}, {"sha": "e7c789ad210267e5fb9c7a9a3f5bb4603dd5d314", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -190,7 +190,9 @@ fn exported_symbols_provider_local(\n         }\n     }\n \n-    if tcx.sess.opts.cg.profile_generate.enabled() {\n+    if tcx.sess.opts.debugging_opts.instrument_coverage\n+        || tcx.sess.opts.cg.profile_generate.enabled()\n+    {\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them.\n@@ -203,17 +205,6 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.opts.debugging_opts.instrument_coverage {\n-        // Similar to PGO profiling, preserve symbols used by LLVM InstrProf coverage profiling.\n-        const COVERAGE_WEAK_SYMBOLS: [&str; 3] =\n-            [\"__llvm_profile_filename\", \"__llvm_coverage_mapping\", \"__llvm_covmap\"];\n-\n-        symbols.extend(COVERAGE_WEAK_SYMBOLS.iter().map(|sym| {\n-            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, sym));\n-            (exported_symbol, SymbolExportLevel::C)\n-        }));\n-    }\n-\n     if tcx.sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n         // Similar to profiling, preserve weak msan symbol during LTO.\n         const MSAN_WEAK_SYMBOLS: [&str; 2] = [\"__msan_track_origins\", \"__msan_keep_going\"];"}, {"sha": "e04ed531bbff282912f14f7ad59116103d77be4c", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -72,9 +72,6 @@ pub enum AtomicOrdering {\n }\n \n pub enum SynchronizationScope {\n-    // FIXME: figure out if this variant is needed at all.\n-    #[allow(dead_code)]\n-    Other,\n     SingleThread,\n     CrossThread,\n }"}, {"sha": "73e33369175874fe83d3d4b7e48849d9ec5be056", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,6 +16,8 @@\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n //! have to be implemented by each backends.\n \n+#[macro_use]\n+extern crate rustc_macros;\n #[macro_use]\n extern crate tracing;\n #[macro_use]\n@@ -74,7 +76,7 @@ impl<M> ModuleCodegen<M> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct CompiledModule {\n     pub name: String,\n     pub kind: ModuleKind,\n@@ -87,7 +89,7 @@ pub struct CachedModuleCodegen {\n     pub source: WorkProduct,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Encodable, Decodable)]\n pub enum ModuleKind {\n     Regular,\n     Metadata,\n@@ -110,7 +112,7 @@ bitflags::bitflags! {\n /// identifiers (`CrateNum`) to `CrateSource`. The other fields map `CrateNum` to the crate's own\n /// additional properties, so that effectively we can retrieve each dependent crate's `CrateSource`\n /// and the corresponding properties without referencing information outside of a `CrateInfo`.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct CrateInfo {\n     pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,\n@@ -128,7 +130,7 @@ pub struct CrateInfo {\n     pub dependency_formats: Lrc<Dependencies>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct CodegenResults {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,"}, {"sha": "d8a530d98faa7df9f0228b1b11a10af891e030c1", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,6 +1,7 @@\n use crate::traits::*;\n use rustc_hir::def_id::CrateNum;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_session::config::DebugInfo;\n@@ -216,6 +217,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             LocalRef::Operand(None) => return,\n \n             LocalRef::Operand(Some(operand)) => {\n+                // Don't spill operands onto the stack in naked functions.\n+                // See: https://github.com/rust-lang/rust/issues/42779\n+                let attrs = bx.tcx().codegen_fn_attrs(self.instance.def_id());\n+                if attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+                    return;\n+                }\n+\n                 // \"Spill\" the value onto the stack, for debuginfo,\n                 // without forcing non-debuginfo uses of the local\n                 // to also load from the stack every single time."}, {"sha": "5602599b0c25b579aaaef4fb560344444dd7504f", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,6 +7,8 @@ pub trait CoverageInfoMethods: BackendTypes {\n }\n \n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n+    fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n+\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,"}, {"sha": "00dab143fdc553024ff93f3033999f592cedb4e0", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -17,6 +17,7 @@ jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n once_cell = { version = \"1\", features = [\"parking_lot\"] }\n rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_graphviz = { path = \"../librustc_graphviz\" }\n cfg-if = \"0.1.2\"\n crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }\n@@ -30,6 +31,7 @@ bitflags = \"1.2.1\"\n measureme = \"0.7.1\"\n libc = \"0.2\"\n stacker = \"0.1.9\"\n+tempfile = \"3.0.5\"\n \n [dependencies.parking_lot]\n version = \"0.10\""}, {"sha": "f8d631ce01e78139b7dd6c11abc9229a51b76813", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,5 +1,8 @@\n use crate::stable_hasher;\n-use rustc_serialize::opaque::{Decoder, EncodeResult, Encoder};\n+use rustc_serialize::{\n+    opaque::{self, EncodeResult},\n+    Decodable, Encodable,\n+};\n use std::mem;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy)]\n@@ -49,14 +52,14 @@ impl Fingerprint {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n \n-    pub fn encode_opaque(&self, encoder: &mut Encoder) -> EncodeResult {\n+    pub fn encode_opaque(&self, encoder: &mut opaque::Encoder) -> EncodeResult {\n         let bytes: [u8; 16] = unsafe { mem::transmute([self.0.to_le(), self.1.to_le()]) };\n \n         encoder.emit_raw_bytes(&bytes);\n         Ok(())\n     }\n \n-    pub fn decode_opaque(decoder: &mut Decoder<'_>) -> Result<Fingerprint, String> {\n+    pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {\n         let mut bytes = [0; 16];\n \n         decoder.read_raw_bytes(&mut bytes)?;\n@@ -83,18 +86,45 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n \n impl_stable_hash_via_hash!(Fingerprint);\n \n-impl rustc_serialize::UseSpecializedEncodable for Fingerprint {}\n+impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.encode_fingerprint(self)\n+    }\n+}\n \n-impl rustc_serialize::UseSpecializedDecodable for Fingerprint {}\n+impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        d.decode_fingerprint()\n+    }\n+}\n \n-impl rustc_serialize::SpecializedEncoder<Fingerprint> for Encoder {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n+pub trait FingerprintEncoder: rustc_serialize::Encoder {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error>;\n+}\n+\n+pub trait FingerprintDecoder: rustc_serialize::Decoder {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error>;\n+}\n+\n+impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {\n+    default fn encode_fingerprint(&mut self, _: &Fingerprint) -> Result<(), E::Error> {\n+        panic!(\"Cannot encode `Fingerprint` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl FingerprintEncoder for opaque::Encoder {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {\n         f.encode_opaque(self)\n     }\n }\n \n-impl<'a> rustc_serialize::SpecializedDecoder<Fingerprint> for Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n+impl<D: rustc_serialize::Decoder> FingerprintDecoder for D {\n+    default fn decode_fingerprint(&mut self) -> Result<Fingerprint, D::Error> {\n+        panic!(\"Cannot decode `Fingerprint` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n+impl FingerprintDecoder for opaque::Decoder<'_> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n         Fingerprint::decode_opaque(self)\n     }\n }"}, {"sha": "1937f615e701f8478c82db5877a5b8bc333fd117", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -29,6 +29,8 @@\n extern crate tracing;\n #[macro_use]\n extern crate cfg_if;\n+#[macro_use]\n+extern crate rustc_macros;\n \n #[inline(never)]\n #[cold]\n@@ -95,6 +97,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod temp_dir;\n \n pub struct OnDrop<F: Fn()>(pub F);\n "}, {"sha": "856eb73e6297a79ac5cc48051fb241080baab0c9", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,18 +16,7 @@ pub use index_map::SortedIndexMultiMap;\n /// stores data in a more compact way. It also supports accessing contiguous\n /// ranges of elements as a slice, and slices of already sorted elements can be\n /// inserted efficiently.\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    Default,\n-    Debug,\n-    RustcEncodable,\n-    RustcDecodable\n-)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug, Encodable, Decodable)]\n pub struct SortedMap<K: Ord, V> {\n     data: Vec<(K, V)>,\n }"}, {"sha": "02103de2e8df913d15a8ca458cce1b3e4d7d39c8", "filename": "src/librustc_data_structures/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsvh.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -48,14 +48,14 @@ impl fmt::Display for Svh {\n     }\n }\n \n-impl Encodable for Svh {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for Svh {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(self.as_u64().to_le())\n     }\n }\n \n-impl Decodable for Svh {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Svh, D::Error> {\n+impl<D: Decoder> Decodable<D> for Svh {\n+    fn decode(d: &mut D) -> Result<Svh, D::Error> {\n         d.read_u64().map(u64::from_le).map(Svh::new)\n     }\n }"}, {"sha": "0d9b3e3ca25c0a744e131615d47b60d6b76f4174", "filename": "src/librustc_data_structures/temp_dir.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ftemp_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ftemp_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftemp_dir.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,34 @@\n+use std::mem::ManuallyDrop;\n+use std::path::Path;\n+use tempfile::TempDir;\n+\n+/// This is used to avoid TempDir being dropped on error paths unintentionally.\n+#[derive(Debug)]\n+pub struct MaybeTempDir {\n+    dir: ManuallyDrop<TempDir>,\n+    // Whether the TempDir should be deleted on drop.\n+    keep: bool,\n+}\n+\n+impl Drop for MaybeTempDir {\n+    fn drop(&mut self) {\n+        // Safety: We are in the destructor, and no further access will\n+        // occur.\n+        let dir = unsafe { ManuallyDrop::take(&mut self.dir) };\n+        if self.keep {\n+            dir.into_path();\n+        }\n+    }\n+}\n+\n+impl AsRef<Path> for MaybeTempDir {\n+    fn as_ref(&self) -> &Path {\n+        self.dir.path()\n+    }\n+}\n+\n+impl MaybeTempDir {\n+    pub fn new(dir: TempDir, keep_on_drop: bool) -> MaybeTempDir {\n+        MaybeTempDir { dir: ManuallyDrop::new(dir), keep: keep_on_drop }\n+    }\n+}"}, {"sha": "4d673fd5cf98307ddc40b1e96779a6cbabb5e819", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,7 +3,7 @@ use crate::stable_hasher::{HashStable, StableHasher};\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n \n impl<T> ThinVec<T> {"}, {"sha": "fe60a99dde07205f2b88c1d5a35c9c5df1d15292", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,8 +1,6 @@\n use crate::fx::FxIndexSet;\n-use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n@@ -42,10 +40,10 @@ impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n struct Edge {\n     source: Index,\n     target: Index,\n@@ -402,66 +400,3 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n         candidates.truncate(j - dead);\n     }\n }\n-\n-impl<T> Encodable for TransitiveRelation<T>\n-where\n-    T: Clone + Encodable + Debug + Eq + Hash + Clone,\n-{\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"TransitiveRelation\", 2, |s| {\n-            s.emit_struct_field(\"elements\", 0, |s| self.elements.encode(s))?;\n-            s.emit_struct_field(\"edges\", 1, |s| self.edges.encode(s))?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<T> Decodable for TransitiveRelation<T>\n-where\n-    T: Clone + Decodable + Debug + Eq + Hash + Clone,\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            Ok(TransitiveRelation {\n-                elements: d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?,\n-                edges: d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?,\n-                closure: Lock::new(None),\n-            })\n-        })\n-    }\n-}\n-\n-impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-where\n-    T: HashStable<CTX> + Eq + Debug + Clone + Hash,\n-{\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        // We are assuming here that the relation graph has been built in a\n-        // deterministic way and we can just hash it the way it is.\n-        let TransitiveRelation {\n-            ref elements,\n-            ref edges,\n-            // \"closure\" is just a copy of the data above\n-            closure: _,\n-        } = *self;\n-\n-        elements.hash_stable(hcx, hasher);\n-        edges.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for Edge {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        let Edge { ref source, ref target } = *self;\n-\n-        source.hash_stable(hcx, hasher);\n-        target.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for Index {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        let Index(idx) = *self;\n-        idx.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "9cfefb1de632ba96313a0a738d1b14c15e146c14", "filename": "src/librustc_error_codes/error_codes/E0477.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0477.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0477.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0477.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -37,8 +37,7 @@ fn i_want_static_closure<F>(a: F)\n \n fn print_string(s: Mutex<MyString<'static>>) {\n \n-    i_want_static_closure(move || {     // error: this closure has lifetime 'a\n-                                        //        rather than 'static\n+    i_want_static_closure(move || {     // ok!\n         println!(\"{}\", s.lock().unwrap().data);\n     });\n }"}, {"sha": "dfe90ae89e4cb2a9837e60e7d50ff2dcc88e3dd7", "filename": "src/librustc_error_codes/error_codes/E0749.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,9 +11,19 @@ trait MyTrait {\n impl !MyTrait for u32 {\n     type Foo = i32; // error!\n }\n-# fn main() {}\n ```\n \n Negative impls are not allowed to have any items. Negative impls declare that a\n trait is **not** implemented (and never will be) and hence there is no need to\n specify the values for trait methods or other items.\n+\n+One way to fix this is to remove the items in negative impls:\n+\n+```\n+# #![feature(negative_impls)]\n+trait MyTrait {\n+    type Foo;\n+}\n+\n+impl !MyTrait for u32 {}\n+```"}, {"sha": "8794f7868f30296ab022c341db3ed635dcd22e29", "filename": "src/librustc_error_codes/error_codes/E0751.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0751.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,8 +5,8 @@ Erroneous code example:\n ```compile_fail,E0751\n trait MyTrait {}\n impl MyTrait for i32 { }\n-impl !MyTrait for i32 { }\n+impl !MyTrait for i32 { } // error!\n ```\n \n-Negative implementations are a promise that the trait will never be\n-implemented for the given types.\n+Negative implementations are a promise that the trait will never be implemented\n+for the given types. Therefore, both cannot exists at the same time."}, {"sha": "9736da80c2b7b178396f85e680e7ff358a15215c", "filename": "src/librustc_error_codes/error_codes/E0752.md", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,11 +1,19 @@\n-`fn main()` or the specified start function is not allowed to be\n-async. You might be seeing this error because your async runtime\n-library is not set up correctly.\n+The entry point of the program was marked as `async`.\n \n Erroneous code example:\n \n ```compile_fail,E0752\n-async fn main() -> Result<i32, ()> {\n-    Ok(1)\n+async fn main() -> Result<(), ()> { // error!\n+    Ok(())\n+}\n+```\n+\n+`fn main()` or the specified start function is not allowed to be `async`. Not\n+having a correct async runtime library setup may cause this error. To fix it,\n+declare the entry point without `async`:\n+\n+```\n+fn main() -> Result<(), ()> { // ok!\n+    Ok(())\n }\n ```"}, {"sha": "c17d61dae9faf2be4791631abd44e9ec04b6457a", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -13,6 +13,7 @@ doctest = false\n log = { package = \"tracing\", version = \"0.1\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\""}, {"sha": "cd4b5d56f36e6e7190a075aee564a8bc31e3ebb5", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n #[must_use]\n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct Diagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,\n@@ -24,14 +24,14 @@ pub struct Diagnostic {\n     pub sort_span: Span,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticId {\n     Error(String),\n     Lint(String),\n }\n \n /// For example a note attached to an error.\n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,"}, {"sha": "750d36d3d891a2804c116894187c1764c38a8dba", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -145,7 +145,7 @@ impl Emitter for JsonEmitter {\n \n // The following data types are provided just for serialisation.\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct Diagnostic {\n     /// The primary error message.\n     message: String,\n@@ -159,7 +159,7 @@ struct Diagnostic {\n     rendered: Option<String>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpan {\n     file_name: String,\n     byte_start: u32,\n@@ -186,7 +186,7 @@ struct DiagnosticSpan {\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpanLine {\n     text: String,\n \n@@ -196,7 +196,7 @@ struct DiagnosticSpanLine {\n     highlight_end: usize,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpanMacroExpansion {\n     /// span where macro was applied to generate this code; note that\n     /// this may itself derive from a macro (if\n@@ -210,15 +210,15 @@ struct DiagnosticSpanMacroExpansion {\n     def_site_span: DiagnosticSpan,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticCode {\n     /// The code itself.\n     code: String,\n     /// An explanation for the code.\n     explanation: Option<&'static str>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct ArtifactNotification<'a> {\n     /// The path of the artifact.\n     artifact: &'a Path,"}, {"sha": "e69e868c8ede5fa413a3588540e81f13ee47a94e", "filename": "src/librustc_errors/json/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,12 +10,12 @@ use rustc_span::{BytePos, Span};\n \n use std::str;\n \n-#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Decodable, Debug, PartialEq, Eq)]\n struct TestData {\n     spans: Vec<SpanTestData>,\n }\n \n-#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Decodable, Debug, PartialEq, Eq)]\n struct SpanTestData {\n     pub byte_start: u32,\n     pub byte_end: u32,"}, {"sha": "98e9972530ebd1d0c17a722a6151af22d1f62d4b", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -6,6 +6,9 @@\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n pub use emitter::ColorConfig;\n \n use log::debug;\n@@ -50,7 +53,7 @@ rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended. This suggestion should be\n     /// automatically applied.\n@@ -69,7 +72,7 @@ pub enum Applicability {\n     Unspecified,\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {\n     /// Hide the suggested code when displaying this suggestion inline.\n     HideCodeInline,\n@@ -94,7 +97,7 @@ impl SuggestionStyle {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct CodeSuggestion {\n     /// Each substitute can have multiple variants due to multiple\n     /// applicable suggestions\n@@ -129,13 +132,13 @@ pub struct CodeSuggestion {\n     pub applicability: Applicability,\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n /// See the docs on `CodeSuggestion::substitutions`\n pub struct Substitution {\n     pub parts: Vec<SubstitutionPart>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubstitutionPart {\n     pub span: Span,\n     pub snippet: String,\n@@ -943,7 +946,7 @@ impl HandlerInner {\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, PartialEq, Clone, Hash, Debug, Encodable, Decodable)]\n pub enum Level {\n     Bug,\n     Fatal,\n@@ -1012,7 +1015,7 @@ macro_rules! pluralize {\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable, Hash, PartialEq, Eq)]\n+#[derive(Clone, Copy, Debug, Encodable, Decodable, Hash, PartialEq, Eq)]\n pub struct ErrorReported;\n \n rustc_data_structures::impl_stable_hash_via_hash!(ErrorReported);"}, {"sha": "160bf57779970a58ab0b6369a5736534c634c5e4", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -173,7 +173,7 @@ pub struct StyledString {\n     pub style: Style,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum Style {\n     MainHeaderMsg,\n     HeaderMsg,"}, {"sha": "fbdb65b558790d4432003f63fb9f8b37b9aee521", "filename": "src/librustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -20,6 +20,7 @@ rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_parse = { path = \"../librustc_parse\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "7f631cb71afa86b9ff56b04acc2aadccb5c1854f", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,6 +8,9 @@\n #![feature(proc_macro_span)]\n #![feature(try_blocks)]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n extern crate proc_macro as pm;\n \n mod placeholders;"}, {"sha": "9920e0650a7f7a1742b2c3c9a30854bb0daec8e5", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::sync::Lrc;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n     tts: Vec<TokenTree>,\n@@ -37,7 +37,7 @@ impl Delimited {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct SequenceRepetition {\n     /// The sequence of token trees\n     tts: Vec<TokenTree>,\n@@ -49,7 +49,7 @@ struct SequenceRepetition {\n     num_captures: usize,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n struct KleeneToken {\n     span: Span,\n     op: KleeneOp,\n@@ -63,7 +63,7 @@ impl KleeneToken {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n@@ -75,7 +75,7 @@ enum KleeneOp {\n \n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n /// are \"first-class\" token trees. Useful for parsing macros.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n enum TokenTree {\n     Token(Token),\n     Delimited(DelimSpan, Lrc<Delimited>),"}, {"sha": "83a650443bcba59c6cffc07f204d5109fbad7459", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -319,18 +319,10 @@ pub struct Ident {\n }\n \n impl Ident {\n-    fn is_valid(string: &str) -> bool {\n-        let mut chars = string.chars();\n-        if let Some(start) = chars.next() {\n-            rustc_lexer::is_id_start(start) && chars.all(rustc_lexer::is_id_continue)\n-        } else {\n-            false\n-        }\n-    }\n     fn new(sess: &ParseSess, sym: Symbol, is_raw: bool, span: Span) -> Ident {\n         let sym = nfc_normalize(&sym.as_str());\n         let string = sym.as_str();\n-        if !Self::is_valid(&string) {\n+        if !rustc_lexer::is_ident(&string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n         if is_raw && !sym.can_be_raw() {"}, {"sha": "6ba396666070ab4fbca05381ee111235acf3549e", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -12,41 +12,41 @@ macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n             // HIR types\n-            [few] hir_krate: rustc_hir::Crate<$tcx>, rustc_hir::Crate<'_x>;\n-            [] arm: rustc_hir::Arm<$tcx>, rustc_hir::Arm<'_x>;\n-            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>, rustc_hir::InlineAsmOperand<'_x>;\n-            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n-            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n-            [] block: rustc_hir::Block<$tcx>, rustc_hir::Block<'_x>;\n-            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>, rustc_hir::BareFnTy<'_x>;\n-            [few] global_asm: rustc_hir::GlobalAsm, rustc_hir::GlobalAsm;\n-            [] generic_arg: rustc_hir::GenericArg<$tcx>, rustc_hir::GenericArg<'_x>;\n-            [] generic_args: rustc_hir::GenericArgs<$tcx>, rustc_hir::GenericArgs<'_x>;\n-            [] generic_bound: rustc_hir::GenericBound<$tcx>, rustc_hir::GenericBound<'_x>;\n-            [] generic_param: rustc_hir::GenericParam<$tcx>, rustc_hir::GenericParam<'_x>;\n-            [] expr: rustc_hir::Expr<$tcx>, rustc_hir::Expr<'_x>;\n-            [] field: rustc_hir::Field<$tcx>, rustc_hir::Field<'_x>;\n-            [] field_pat: rustc_hir::FieldPat<$tcx>, rustc_hir::FieldPat<'_x>;\n-            [] fn_decl: rustc_hir::FnDecl<$tcx>, rustc_hir::FnDecl<'_x>;\n-            [] foreign_item: rustc_hir::ForeignItem<$tcx>, rustc_hir::ForeignItem<'_x>;\n-            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>, rustc_hir::ImplItemRef<'_x>;\n-            [few] inline_asm: rustc_hir::InlineAsm<$tcx>, rustc_hir::InlineAsm<'_x>;\n-            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>, rustc_hir::LlvmInlineAsm<'_x>;\n-            [] local: rustc_hir::Local<$tcx>, rustc_hir::Local<'_x>;\n-            [few] macro_def: rustc_hir::MacroDef<$tcx>, rustc_hir::MacroDef<'_x>;\n-            [] param: rustc_hir::Param<$tcx>, rustc_hir::Param<'_x>;\n-            [] pat: rustc_hir::Pat<$tcx>, rustc_hir::Pat<'_x>;\n-            [] path: rustc_hir::Path<$tcx>, rustc_hir::Path<'_x>;\n-            [] path_segment: rustc_hir::PathSegment<$tcx>, rustc_hir::PathSegment<'_x>;\n-            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>, rustc_hir::PolyTraitRef<'_x>;\n-            [] qpath: rustc_hir::QPath<$tcx>, rustc_hir::QPath<'_x>;\n-            [] stmt: rustc_hir::Stmt<$tcx>, rustc_hir::Stmt<'_x>;\n-            [] struct_field: rustc_hir::StructField<$tcx>, rustc_hir::StructField<'_x>;\n-            [] trait_item_ref: rustc_hir::TraitItemRef, rustc_hir::TraitItemRef;\n-            [] ty: rustc_hir::Ty<$tcx>, rustc_hir::Ty<'_x>;\n-            [] type_binding: rustc_hir::TypeBinding<$tcx>, rustc_hir::TypeBinding<'_x>;\n-            [] variant: rustc_hir::Variant<$tcx>, rustc_hir::Variant<'_x>;\n-            [] where_predicate: rustc_hir::WherePredicate<$tcx>, rustc_hir::WherePredicate<'_x>;\n+            [few] hir_krate: rustc_hir::Crate<$tcx>,\n+            [] arm: rustc_hir::Arm<$tcx>,\n+            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>,\n+            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n+            [] attribute: rustc_ast::ast::Attribute,\n+            [] block: rustc_hir::Block<$tcx>,\n+            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n+            [few] global_asm: rustc_hir::GlobalAsm,\n+            [] generic_arg: rustc_hir::GenericArg<$tcx>,\n+            [] generic_args: rustc_hir::GenericArgs<$tcx>,\n+            [] generic_bound: rustc_hir::GenericBound<$tcx>,\n+            [] generic_param: rustc_hir::GenericParam<$tcx>,\n+            [] expr: rustc_hir::Expr<$tcx>,\n+            [] field: rustc_hir::Field<$tcx>,\n+            [] field_pat: rustc_hir::FieldPat<$tcx>,\n+            [] fn_decl: rustc_hir::FnDecl<$tcx>,\n+            [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n+            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n+            [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n+            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n+            [] local: rustc_hir::Local<$tcx>,\n+            [few] macro_def: rustc_hir::MacroDef<$tcx>,\n+            [] param: rustc_hir::Param<$tcx>,\n+            [] pat: rustc_hir::Pat<$tcx>,\n+            [] path: rustc_hir::Path<$tcx>,\n+            [] path_segment: rustc_hir::PathSegment<$tcx>,\n+            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>,\n+            [] qpath: rustc_hir::QPath<$tcx>,\n+            [] stmt: rustc_hir::Stmt<$tcx>,\n+            [] struct_field: rustc_hir::StructField<$tcx>,\n+            [] trait_item_ref: rustc_hir::TraitItemRef,\n+            [] ty: rustc_hir::Ty<$tcx>,\n+            [] type_binding: rustc_hir::TypeBinding<$tcx>,\n+            [] variant: rustc_hir::Variant<$tcx>,\n+            [] where_predicate: rustc_hir::WherePredicate<$tcx>,\n         ], $tcx);\n     )\n }"}, {"sha": "c4877be3f6415bb2c21b288e3327351805bdf0d6", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::hygiene::MacroKind;\n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum CtorOf {\n     /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit struct.\n@@ -18,7 +18,7 @@ pub enum CtorOf {\n     Variant,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n@@ -29,7 +29,7 @@ pub enum CtorKind {\n     Fictive,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n@@ -42,7 +42,7 @@ pub enum NonMacroAttrKind {\n     Registered,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum DefKind {\n     // Type namespace\n@@ -191,7 +191,7 @@ impl DefKind {\n }\n \n /// The resolution of a path or export.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),"}, {"sha": "5604e3a8dcaf95b074ad1e688521e44d1a79058a", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,7 +23,7 @@ use std::hash::Hash;\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n /// stores the `DefIndex` of its parent.\n /// There is one `DefPathTable` for each crate.\n-#[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Default, Decodable, Encodable)]\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n@@ -92,7 +92,7 @@ pub struct Definitions {\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, Encodable, Decodable)]\n pub struct DefKey {\n     /// The parent path.\n     pub parent: Option<DefIndex>,\n@@ -143,13 +143,13 @@ impl DefKey {\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, Encodable, Decodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n     pub disambiguator: u32,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Encodable, Decodable)]\n pub struct DefPath {\n     /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n@@ -244,7 +244,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function."}, {"sha": "928235adac30c15685203a59fa7a696e958f35b7", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 108, "deletions": 117, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,7 +23,7 @@ use smallvec::SmallVec;\n use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -37,7 +37,7 @@ pub struct Lifetime {\n     pub name: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n #[derive(HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n@@ -83,7 +83,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n@@ -182,7 +182,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -199,7 +199,7 @@ impl Path<'_> {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n@@ -242,13 +242,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n     Lifetime(Lifetime),\n     Type(Ty<'hir>),\n@@ -288,7 +288,7 @@ impl GenericArg<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n     pub args: &'hir [GenericArg<'hir>],\n@@ -348,7 +348,7 @@ impl GenericArgs<'_> {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n@@ -360,7 +360,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -384,7 +384,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -403,7 +403,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -418,7 +418,7 @@ pub enum GenericParamKind<'hir> {\n     },\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -448,7 +448,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub where_clause: WhereClause<'hir>,\n@@ -501,14 +501,14 @@ impl Generics<'hir> {\n \n /// Synthetic type parameters are converted to another form during lowering; this allows\n /// us to track the original form they had, and is useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum SyntheticTyParamKind {\n     ImplTrait,\n }\n \n /// A where-clause in a definition.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereClause<'hir> {\n     pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates aren't empty.\n@@ -535,7 +535,7 @@ impl WhereClause<'_> {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate<'hir>),\n@@ -556,7 +556,7 @@ impl WherePredicate<'_> {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -568,23 +568,23 @@ pub struct WhereBoundPredicate<'hir> {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: &'hir Ty<'hir>,\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n@@ -594,7 +594,7 @@ pub struct ModuleItems {\n }\n \n /// A type representing only the top-level module.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct CrateItem<'hir> {\n     pub module: Mod<'hir>,\n     pub attrs: &'hir [Attribute],\n@@ -607,7 +607,7 @@ pub struct CrateItem<'hir> {\n /// For more details, see the [rustc dev guide].\n ///\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Crate<'hir> {\n     pub item: CrateItem<'hir>,\n     pub exported_macros: &'hir [MacroDef<'hir>],\n@@ -715,7 +715,7 @@ impl Crate<'_> {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct MacroDef<'hir> {\n     pub ident: Ident,\n     pub vis: Visibility<'hir>,\n@@ -728,7 +728,7 @@ pub struct MacroDef<'hir> {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Block<'hir> {\n     /// Statements in a block.\n     pub stmts: &'hir [Stmt<'hir>],\n@@ -746,7 +746,7 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -824,7 +824,7 @@ impl Pat<'_> {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FieldPat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -840,7 +840,7 @@ pub struct FieldPat<'hir> {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -861,7 +861,7 @@ pub enum BindingAnnotation {\n     RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -876,7 +876,7 @@ impl fmt::Display for RangeEnd {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -932,7 +932,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [&'hir Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [&'hir Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1066,7 +1066,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1095,15 +1095,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n /// The contents of a statement.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1129,7 +1129,7 @@ impl StmtKind<'hir> {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1146,7 +1146,7 @@ pub struct Local<'hir> {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1160,12 +1160,12 @@ pub struct Arm<'hir> {\n     pub body: &'hir Expr<'hir>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Field<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1175,21 +1175,21 @@ pub struct Field<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1215,7 +1215,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n     pub value: Expr<'hir>,\n@@ -1233,7 +1233,7 @@ impl Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1256,7 +1256,7 @@ impl fmt::Display for GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n@@ -1357,14 +1357,14 @@ pub type Lit = Spanned<LitKind>;\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub body: BodyId,\n }\n \n /// An expression.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1543,7 +1543,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n     Box(&'hir Expr<'hir>),\n@@ -1660,7 +1660,7 @@ pub enum ExprKind<'hir> {\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n /// [`qpath_res`]: ../rustc_middle/ty/struct.TypeckResults.html#method.qpath_res\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1680,7 +1680,7 @@ pub enum QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1702,7 +1702,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n@@ -1739,7 +1739,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1761,7 +1761,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1780,7 +1780,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1791,7 +1791,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await { expr: Option<HirId> },\n@@ -1829,15 +1829,15 @@ impl From<GeneratorKind> for YieldSource {\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct MutTy<'hir> {\n     pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n     pub decl: &'hir FnDecl<'hir>,\n@@ -1846,7 +1846,7 @@ pub struct FnSig<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct TraitItemId {\n     pub hir_id: HirId,\n }\n@@ -1855,7 +1855,7 @@ pub struct TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1866,7 +1866,7 @@ pub struct TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -1876,7 +1876,7 @@ pub enum TraitFn<'hir> {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n@@ -1890,13 +1890,13 @@ pub enum TraitItemKind<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ImplItemId {\n     pub hir_id: HirId,\n }\n \n /// Represents anything within an `impl` block.\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1909,7 +1909,7 @@ pub struct ImplItem<'hir> {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n@@ -1947,7 +1947,7 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n@@ -1957,7 +1957,7 @@ pub struct TypeBinding<'hir> {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n@@ -1974,15 +1974,15 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum PrimTy {\n     Int(IntTy),\n@@ -1993,7 +1993,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -2002,7 +2002,7 @@ pub struct BareFnTy<'hir> {\n     pub param_names: &'hir [Ident],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n     pub generics: Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n@@ -2011,7 +2011,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n     FnReturn,\n@@ -2024,7 +2024,7 @@ pub enum OpaqueTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(&'hir Ty<'hir>),\n@@ -2063,7 +2063,7 @@ pub enum TyKind<'hir> {\n     Err,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum InlineAsmOperand<'hir> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -2105,15 +2105,15 @@ impl<'hir> InlineAsmOperand<'hir> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub operands: &'hir [InlineAsmOperand<'hir>],\n     pub options: InlineAsmOptions,\n     pub line_spans: &'hir [Span],\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -2122,8 +2122,9 @@ pub struct LlvmInlineAsmOutput {\n }\n \n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n-// it needs to be `Clone` and use plain `Vec<T>` instead of arena-allocated slice.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n+// it needs to be `Clone` and `Decodable` and use plain `Vec<T>` instead of\n+// arena-allocated slice.\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmInner {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2135,15 +2136,15 @@ pub struct LlvmInlineAsmInner {\n     pub dialect: LlvmAsmDialect,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct LlvmInlineAsm<'hir> {\n     pub inner: LlvmInlineAsmInner,\n     pub outputs_exprs: &'hir [Expr<'hir>],\n     pub inputs_exprs: &'hir [Expr<'hir>],\n }\n \n /// Represents a parameter in a function header.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Param<'hir> {\n     pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n@@ -2153,7 +2154,7 @@ pub struct Param<'hir> {\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n@@ -2166,7 +2167,7 @@ pub struct FnDecl<'hir> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2191,24 +2192,14 @@ impl ImplicitSelfKind {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum IsAsync {\n     Async,\n     NotAsync,\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    PartialEq,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    HashStable_Generic,\n-    Eq,\n-    Hash\n-)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2234,7 +2225,7 @@ impl Defaultness {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum FnRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n@@ -2255,7 +2246,7 @@ impl FnRetTy<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Encodable, Debug)]\n pub struct Mod<'hir> {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2264,23 +2255,23 @@ pub struct Mod<'hir> {\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ForeignMod<'hir> {\n     pub abi: Abi,\n     pub items: &'hir [ForeignItem<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n@@ -2297,7 +2288,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2319,7 +2310,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2338,7 +2329,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2351,7 +2342,7 @@ pub struct PolyTraitRef<'hir> {\n \n pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n@@ -2384,7 +2375,7 @@ impl VisibilityKind<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n@@ -2404,7 +2395,7 @@ impl StructField<'_> {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n@@ -2441,15 +2432,15 @@ impl VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Debug)]\n pub struct ItemId {\n     pub id: HirId,\n }\n \n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -2460,7 +2451,7 @@ pub struct Item<'hir> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n@@ -2485,13 +2476,13 @@ impl fmt::Display for Unsafety {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -2508,7 +2499,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2590,7 +2581,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     #[stable_hasher(project(name))]\n@@ -2606,7 +2597,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ImplItemRef<'hir> {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n@@ -2617,14 +2608,14 @@ pub struct ImplItemRef<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n     Type,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2636,7 +2627,7 @@ pub struct ForeignItem<'hir> {\n }\n \n /// An item within an `extern` block.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n     Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n@@ -2647,7 +2638,7 @@ pub enum ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Upvar {\n     // First span where it is accessed (there can be multiple).\n     pub span: Span,\n@@ -2658,7 +2649,7 @@ pub type CaptureModeMap = NodeMap<CaptureBy>;\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n+#[derive(Encodable, Decodable, Clone, Debug)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "fea850c12d9b0102d0423850ba384e6f50d6f3f4", "filename": "src/librustc_hir/hir_id.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir_id.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,7 +11,8 @@ use std::fmt;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Encodable, Decodable)]\n pub struct HirId {\n     pub owner: LocalDefId,\n     pub local_id: ItemLocalId,"}, {"sha": "b09657bd9b4a41962e74de68678e5593f0df30cb", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -45,7 +45,7 @@ macro_rules! language_item_table {\n \n         enum_from_u32! {\n             /// A representation of all the valid language items in Rust.\n-            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable)]\n             pub enum LangItem {\n                 $($variant,)*\n             }\n@@ -165,6 +165,7 @@ language_item_table! {\n     BoolImplItem,                  sym::bool,               bool_impl,               Target::Impl;\n     CharImplItem,                  sym::char,               char_impl,               Target::Impl;\n     StrImplItem,                   sym::str,                str_impl,                Target::Impl;\n+    ArrayImplItem,                 sym::array,              array_impl,              Target::Impl;\n     SliceImplItem,                 sym::slice,              slice_impl,              Target::Impl;\n     SliceU8ImplItem,               sym::slice_u8,           slice_u8_impl,           Target::Impl;\n     StrAllocImplItem,              sym::str_alloc,          str_alloc_impl,          Target::Impl;"}, {"sha": "a64565b20e7f48d30bf16b0f9a8f9e82776554de", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,9 +7,11 @@\n #![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n-#![feature(min_specialization)]\n #![recursion_limit = \"256\"]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n #[macro_use]\n extern crate rustc_data_structures;\n "}, {"sha": "2b597c7da80cbcbe7183bdc76c12f801abd54e51", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -18,6 +18,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "81e5410978d5df55b4afa6da578d71ba429bb321", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,8 +1,9 @@\n //! The data that we will serialize and deserialize.\n \n+use rustc_macros::{Decodable, Encodable};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct SerializedWorkProduct {\n     /// node that produced the work-product\n     pub id: WorkProductId,"}, {"sha": "8aaf1cb9cbc58057037bafedcf082b5810fc2af1", "filename": "src/librustc_index/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,5 +10,6 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../librustc_serialize\" }\n arrayvec = \"0.5.1\"\n+rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "c43d1a6830d1d8818887754f8b0b468d832eb2f5", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,6 +7,8 @@ use std::mem;\n use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Not, Range, Shl};\n use std::slice;\n \n+use rustc_macros::{Decodable, Encodable};\n+\n #[cfg(test)]\n mod tests;\n \n@@ -26,7 +28,7 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// will panic if the bitsets have differing domain sizes.\n ///\n /// [`GrowableBitSet`]: struct.GrowableBitSet.html\n-#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct BitSet<T: Idx> {\n     domain_size: usize,\n     words: Vec<Word>,\n@@ -700,7 +702,7 @@ impl<T: Idx> GrowableBitSet<T> {\n ///\n /// All operations that involve a row and/or column index will panic if the\n /// index exceeds the relevant bound.\n-#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n@@ -1108,7 +1110,7 @@ impl std::fmt::Debug for FiniteBitSet<u128> {\n \n /// A fixed-sized bitset type represented by an integer type. Indices outwith than the range\n /// representable by `T` are considered set.\n-#[derive(Copy, Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct FiniteBitSet<T: FiniteBitSetTy>(pub T);\n \n impl<T: FiniteBitSetTy> FiniteBitSet<T> {"}, {"sha": "63f63133a2c95b830f0fae6c17f784c9cf9ef7eb", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -320,14 +320,14 @@ macro_rules! newtype_index {\n                    derive [$($derives:ident,)+]\n                    $($tokens:tt)*) => (\n         $crate::newtype_index!(\n-            @derives      [$($derives,)+ RustcEncodable,]\n+            @derives      [$($derives,)+]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        $crate::newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@serializable $type);\n     );\n \n     // The case where no derives are added, but encodable is overridden. Don't\n@@ -357,22 +357,27 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    $($tokens:tt)*) => (\n         $crate::newtype_index!(\n-            @derives      [RustcEncodable,]\n+            @derives      []\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        $crate::newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@serializable $type);\n     );\n \n-    (@decodable $type:ident) => (\n-        impl ::rustc_serialize::Decodable for $type {\n-            fn decode<D: ::rustc_serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+    (@serializable $type:ident) => (\n+        impl<D: ::rustc_serialize::Decoder> ::rustc_serialize::Decodable<D> for $type {\n+            fn decode(d: &mut D) -> Result<Self, D::Error> {\n                 d.read_u32().map(Self::from_u32)\n             }\n         }\n+        impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for $type {\n+            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                e.emit_u32(self.private)\n+            }\n+        }\n     );\n \n     // Rewrite final without comma to one that includes comma\n@@ -483,14 +488,20 @@ pub struct IndexVec<I: Idx, T> {\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n-impl<I: Idx, T: Encodable> Encodable for IndexVec<I, T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&self.raw, s)\n+    }\n+}\n+\n+impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for &IndexVec<I, T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&self.raw, s)\n     }\n }\n \n-impl<I: Idx, T: Decodable> Decodable for IndexVec<I, T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         Decodable::decode(d).map(|v| IndexVec { raw: v, _marker: PhantomData })\n     }\n }"}, {"sha": "1ddf88c030660e318958322fbc9cb9bac06d93e3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,7 +2,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{Subtype, TyCtxtInferExt, ValuePairs};\n+use crate::infer::{Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -53,7 +53,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     }\n \n     fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, trait_def_id: DefId) {\n-        let tcx = self.tcx();\n         let trait_sp = self.tcx().def_span(trait_def_id);\n         let mut err = self\n             .tcx()\n@@ -85,9 +84,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             );\n         }\n \n-        if let Some((expected, found)) = tcx\n-            .infer_ctxt()\n-            .enter(|infcx| infcx.expected_found_str_ty(&ExpectedFound { expected, found }))\n+        if let Some((expected, found)) =\n+            self.infcx.expected_found_str_ty(&ExpectedFound { expected, found })\n         {\n             // Highlighted the differences when showing the \"expected/found\" note.\n             err.note_expected_found(&\"\", expected, &\"\", found);"}, {"sha": "ffe5fb172bea3ec4096a6e9d65e8a50414a46420", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,17 +7,14 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n-/// Combines a `region::ScopeTree` (which governs relationships between\n-/// scopes) and a `FreeRegionMap` (which governs relationships between\n-/// free regions) to yield a complete relation between concrete\n-/// regions.\n+/// Combines a `FreeRegionMap` and a `TyCtxt`.\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// The context used to fetch the region maps.\n+    /// The context used for debug messages\n     pub context: DefId,\n \n     /// Free-region relationships.\n@@ -34,7 +31,7 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default, HashStable)]\n+#[derive(Clone, Debug, Default)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //"}, {"sha": "701fca8e4b53488f80fcbc1184c1acaa8caa5201", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,6 +9,7 @@ use rustc_ast::{self, ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n@@ -974,6 +975,7 @@ fn encode_and_write_metadata(\n             .prefix(\"rmeta\")\n             .tempdir_in(out_filename.parent().unwrap())\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n         let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n         if let Err(e) = fs::rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));"}, {"sha": "7949a232b9b35a8c535c20ae8e05f8ff5c7eed9f", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -274,6 +274,16 @@ pub fn is_id_continue(c: char) -> bool {\n         || (c > '\\x7f' && unicode_xid::UnicodeXID::is_xid_continue(c))\n }\n \n+/// The passed string is lexically an identifier.\n+pub fn is_ident(string: &str) -> bool {\n+    let mut chars = string.chars();\n+    if let Some(start) = chars.next() {\n+        is_id_start(start) && chars.all(is_id_continue)\n+    } else {\n+        false\n+    }\n+}\n+\n impl Cursor<'_> {\n     /// Parses a token from the input string.\n     fn advance_token(&mut self) -> Token {"}, {"sha": "1f17c7dcba43f353a2c8a6eff75a22452bad2e1a", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -219,7 +219,7 @@ pub fn new_lint_store(no_interleave_lints: bool, internal_lints: bool) -> LintSt\n \n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n-/// `rustc::lint::builtin`).\n+/// `rustc_session::lint::builtin`).\n fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     macro_rules! add_lint_group {\n         ($name:expr, $($lint:ident),*) => ("}, {"sha": "ab1658b2229829e263195a5dc5706e2056e5ced9", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 29, "deletions": 61, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,7 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_span::symbol::SymbolStr;\n+use rustc_span::symbol::Symbol;\n \n declare_lint! {\n     pub NON_ASCII_IDENTS,\n@@ -39,7 +39,6 @@ impl EarlyLintPass for NonAsciiIdents {\n         use rustc_span::Span;\n         use std::collections::BTreeMap;\n         use unicode_security::GeneralSecurityProfile;\n-        use utils::CowBoxSymStr;\n \n         let check_non_ascii_idents = cx.builder.lint_level(NON_ASCII_IDENTS).0 != Level::Allow;\n         let check_uncommon_codepoints =\n@@ -58,6 +57,12 @@ impl EarlyLintPass for NonAsciiIdents {\n \n         let mut has_non_ascii_idents = false;\n         let symbols = cx.sess.parse_sess.symbol_gallery.symbols.lock();\n+\n+        // Sort by `Span` so that error messages make sense with respect to the\n+        // order of identifier locations in the code.\n+        let mut symbols: Vec<_> = symbols.iter().collect();\n+        symbols.sort_by_key(|k| k.1);\n+\n         for (symbol, &sp) in symbols.iter() {\n             let symbol_str = symbol.as_str();\n             if symbol_str.is_ascii() {\n@@ -77,33 +82,34 @@ impl EarlyLintPass for NonAsciiIdents {\n         }\n \n         if has_non_ascii_idents && check_confusable_idents {\n-            let mut skeleton_map: FxHashMap<CowBoxSymStr, (SymbolStr, Span, bool)> =\n+            let mut skeleton_map: FxHashMap<Symbol, (Symbol, Span, bool)> =\n                 FxHashMap::with_capacity_and_hasher(symbols.len(), Default::default());\n-            let mut str_buf = String::new();\n-            for (symbol, &sp) in symbols.iter() {\n-                fn calc_skeleton(symbol_str: &SymbolStr, buffer: &mut String) -> CowBoxSymStr {\n-                    use std::mem::replace;\n-                    use unicode_security::confusable_detection::skeleton;\n-                    buffer.clear();\n-                    buffer.extend(skeleton(symbol_str));\n-                    if *symbol_str == *buffer {\n-                        CowBoxSymStr::Interned(symbol_str.clone())\n-                    } else {\n-                        let owned = replace(buffer, String::new());\n-                        CowBoxSymStr::Owned(owned.into_boxed_str())\n-                    }\n-                }\n+            let mut skeleton_buf = String::new();\n+\n+            for (&symbol, &sp) in symbols.iter() {\n+                use unicode_security::confusable_detection::skeleton;\n+\n                 let symbol_str = symbol.as_str();\n                 let is_ascii = symbol_str.is_ascii();\n-                let skeleton = calc_skeleton(&symbol_str, &mut str_buf);\n+\n+                // Get the skeleton as a `Symbol`.\n+                skeleton_buf.clear();\n+                skeleton_buf.extend(skeleton(&symbol_str));\n+                let skeleton_sym = if *symbol_str == *skeleton_buf {\n+                    symbol\n+                } else {\n+                    Symbol::intern(&skeleton_buf)\n+                };\n+\n                 skeleton_map\n-                    .entry(skeleton)\n-                    .and_modify(|(existing_symbolstr, existing_span, existing_is_ascii)| {\n+                    .entry(skeleton_sym)\n+                    .and_modify(|(existing_symbol, existing_span, existing_is_ascii)| {\n                         if !*existing_is_ascii || !is_ascii {\n                             cx.struct_span_lint(CONFUSABLE_IDENTS, sp, |lint| {\n                                 lint.build(&format!(\n                                     \"identifier pair considered confusable between `{}` and `{}`\",\n-                                    existing_symbolstr, symbol_str\n+                                    existing_symbol.as_str(),\n+                                    symbol.as_str()\n                                 ))\n                                 .span_label(\n                                     *existing_span,\n@@ -113,12 +119,12 @@ impl EarlyLintPass for NonAsciiIdents {\n                             });\n                         }\n                         if *existing_is_ascii && !is_ascii {\n-                            *existing_symbolstr = symbol_str.clone();\n+                            *existing_symbol = symbol;\n                             *existing_span = sp;\n                             *existing_is_ascii = is_ascii;\n                         }\n                     })\n-                    .or_insert((symbol_str, sp, is_ascii));\n+                    .or_insert((symbol, sp, is_ascii));\n             }\n         }\n \n@@ -232,41 +238,3 @@ impl EarlyLintPass for NonAsciiIdents {\n         }\n     }\n }\n-\n-mod utils {\n-    use rustc_span::symbol::SymbolStr;\n-    use std::hash::{Hash, Hasher};\n-    use std::ops::Deref;\n-\n-    pub(super) enum CowBoxSymStr {\n-        Interned(SymbolStr),\n-        Owned(Box<str>),\n-    }\n-\n-    impl Deref for CowBoxSymStr {\n-        type Target = str;\n-\n-        fn deref(&self) -> &str {\n-            match self {\n-                CowBoxSymStr::Interned(interned) => interned,\n-                CowBoxSymStr::Owned(ref owned) => owned,\n-            }\n-        }\n-    }\n-\n-    impl Hash for CowBoxSymStr {\n-        #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            Hash::hash(&**self, state)\n-        }\n-    }\n-\n-    impl PartialEq<CowBoxSymStr> for CowBoxSymStr {\n-        #[inline]\n-        fn eq(&self, other: &CowBoxSymStr) -> bool {\n-            PartialEq::eq(&**self, &**other)\n-        }\n-    }\n-\n-    impl Eq for CowBoxSymStr {}\n-}"}, {"sha": "ecc8a192f18ea9566ba9c49b8aec4f02b01348ae", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -481,25 +481,27 @@ trait UnusedDelimLint {\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n-            let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' | '{' => {\n-                    if ate_left_paren {\n-                        false\n-                    } else {\n-                        ate_left_paren = true;\n-                        true\n+            let parens_removed = pattern\n+                .trim_matches(|c| match c {\n+                    '(' | '{' => {\n+                        if ate_left_paren {\n+                            false\n+                        } else {\n+                            ate_left_paren = true;\n+                            true\n+                        }\n                     }\n-                }\n-                ')' | '}' => {\n-                    if ate_right_paren {\n-                        false\n-                    } else {\n-                        ate_right_paren = true;\n-                        true\n+                    ')' | '}' => {\n+                        if ate_right_paren {\n+                            false\n+                        } else {\n+                            ate_right_paren = true;\n+                            true\n+                        }\n                     }\n-                }\n-                _ => false,\n-            });\n+                    _ => false,\n+                })\n+                .trim();\n \n             let replace = {\n                 let mut replace = if keep_space.0 {"}, {"sha": "7fb3b0e7ea6accba63fc307028c7426286fcfe05", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,6 +8,7 @@ use proc_macro::TokenStream;\n mod hash_stable;\n mod lift;\n mod query;\n+mod serialize;\n mod symbols;\n mod type_foldable;\n \n@@ -27,5 +28,11 @@ decl_derive!(\n     hash_stable::hash_stable_generic_derive\n );\n \n+decl_derive!([Decodable] => serialize::decodable_derive);\n+decl_derive!([Encodable] => serialize::encodable_derive);\n+decl_derive!([TyDecodable] => serialize::type_decodable_derive);\n+decl_derive!([TyEncodable] => serialize::type_encodable_derive);\n+decl_derive!([MetadataDecodable] => serialize::meta_decodable_derive);\n+decl_derive!([MetadataEncodable] => serialize::meta_encodable_derive);\n decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_foldable_derive);\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);"}, {"sha": "dbeb3c755044f543bdb2a64eceea3bc5f4ae7e2b", "filename": "src/librustc_macros/src/serialize.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,290 @@\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use syn::parse_quote;\n+\n+pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let decoder_ty = quote! { __D };\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! { 'tcx });\n+    }\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_middle::ty::codec::TyDecoder<'tcx>});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+pub fn meta_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! { 'tcx });\n+    }\n+    s.add_impl_generic(parse_quote! { '__a });\n+    let decoder_ty = quote! { DecodeContext<'__a, 'tcx> };\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+pub fn decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let decoder_ty = quote! { __D };\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_serialize::Decoder});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+fn decodable_body(\n+    s: synstructure::Structure<'_>,\n+    decoder_ty: TokenStream,\n+) -> proc_macro2::TokenStream {\n+    if let syn::Data::Union(_) = s.ast().data {\n+        panic!(\"cannot derive on union\")\n+    }\n+    let ty_name = s.ast().ident.to_string();\n+    let decode_body = match s.variants() {\n+        [vi] => {\n+            let construct = vi.construct(|field, index| decode_field(field, index, true));\n+            let n_fields = vi.ast().fields.len();\n+            quote! {\n+                ::rustc_serialize::Decoder::read_struct(\n+                    __decoder,\n+                    #ty_name,\n+                    #n_fields,\n+                    |__decoder| { ::std::result::Result::Ok(#construct) },\n+                )\n+            }\n+        }\n+        variants => {\n+            let match_inner: TokenStream = variants\n+                .iter()\n+                .enumerate()\n+                .map(|(idx, vi)| {\n+                    let construct = vi.construct(|field, index| decode_field(field, index, false));\n+                    quote! { #idx => { ::std::result::Result::Ok(#construct) } }\n+                })\n+                .collect();\n+            let names: TokenStream = variants\n+                .iter()\n+                .map(|vi| {\n+                    let variant_name = vi.ast().ident.to_string();\n+                    quote!(#variant_name,)\n+                })\n+                .collect();\n+            let message = format!(\n+                \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n+                ty_name,\n+                variants.len()\n+            );\n+            quote! {\n+                ::rustc_serialize::Decoder::read_enum(\n+                    __decoder,\n+                    #ty_name,\n+                    |__decoder| {\n+                        ::rustc_serialize::Decoder::read_enum_variant(\n+                            __decoder,\n+                            &[#names],\n+                            |__decoder, __variant_idx| {\n+                                match __variant_idx {\n+                                    #match_inner\n+                                    _ => return ::std::result::Result::Err(\n+                                        ::rustc_serialize::Decoder::error(__decoder, #message)),\n+                                }\n+                            })\n+                    }\n+                )\n+            }\n+        }\n+    };\n+\n+    s.bound_impl(\n+        quote!(::rustc_serialize::Decodable<#decoder_ty>),\n+        quote! {\n+            fn decode(\n+                __decoder: &mut #decoder_ty,\n+            ) -> ::std::result::Result<Self, <#decoder_ty as ::rustc_serialize::Decoder>::Error> {\n+                #decode_body\n+            }\n+        },\n+    )\n+}\n+\n+fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro2::TokenStream {\n+    let decode_inner_method = if let syn::Type::Reference(_) = field.ty {\n+        quote! { ::rustc_middle::ty::codec::RefDecodable::decode }\n+    } else {\n+        quote! { ::rustc_serialize::Decodable::decode }\n+    };\n+    let (decode_method, opt_field_name) = if is_struct {\n+        let field_name = field.ident.as_ref().map_or_else(|| index.to_string(), |i| i.to_string());\n+        (\n+            proc_macro2::Ident::new(\"read_struct_field\", proc_macro2::Span::call_site()),\n+            quote! { #field_name, },\n+        )\n+    } else {\n+        (\n+            proc_macro2::Ident::new(\"read_enum_variant_arg\", proc_macro2::Span::call_site()),\n+            quote! {},\n+        )\n+    };\n+\n+    quote! {\n+        match ::rustc_serialize::Decoder::#decode_method(\n+            __decoder, #opt_field_name #index, #decode_inner_method) {\n+            ::std::result::Result::Ok(__res) => __res,\n+            ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n+        }\n+    }\n+}\n+\n+pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! {'tcx});\n+    }\n+    let encoder_ty = quote! { __E };\n+    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_middle::ty::codec::TyEncoder<'tcx>});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, false)\n+}\n+\n+pub fn meta_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! {'tcx});\n+    }\n+    s.add_impl_generic(parse_quote! { '__a });\n+    let encoder_ty = quote! { EncodeContext<'__a, 'tcx> };\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, true)\n+}\n+\n+pub fn encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let encoder_ty = quote! { __E };\n+    s.add_impl_generic(parse_quote! { #encoder_ty: ::rustc_serialize::Encoder});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, false)\n+}\n+\n+fn encodable_body(\n+    mut s: synstructure::Structure<'_>,\n+    encoder_ty: TokenStream,\n+    allow_unreachable_code: bool,\n+) -> proc_macro2::TokenStream {\n+    if let syn::Data::Union(_) = s.ast().data {\n+        panic!(\"cannot derive on union\")\n+    }\n+\n+    s.bind_with(|binding| {\n+        // Handle the lack of a blanket reference impl.\n+        if let syn::Type::Reference(_) = binding.ast().ty {\n+            synstructure::BindStyle::Move\n+        } else {\n+            synstructure::BindStyle::Ref\n+        }\n+    });\n+\n+    let ty_name = s.ast().ident.to_string();\n+    let encode_body = match s.variants() {\n+        [_] => {\n+            let mut field_idx = 0usize;\n+            let encode_inner = s.each_variant(|vi| {\n+                vi.bindings()\n+                    .iter()\n+                    .map(|binding| {\n+                        let bind_ident = &binding.binding;\n+                        let field_name = binding\n+                            .ast()\n+                            .ident\n+                            .as_ref()\n+                            .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n+                        let result = quote! {\n+                            match ::rustc_serialize::Encoder::emit_struct_field(\n+                                __encoder,\n+                                #field_name,\n+                                #field_idx,\n+                                |__encoder|\n+                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                            ) {\n+                                ::std::result::Result::Ok(()) => (),\n+                                ::std::result::Result::Err(__err)\n+                                    => return ::std::result::Result::Err(__err),\n+                            }\n+                        };\n+                        field_idx += 1;\n+                        result\n+                    })\n+                    .collect::<TokenStream>()\n+            });\n+            quote! {\n+                ::rustc_serialize::Encoder::emit_struct(__encoder, #ty_name, #field_idx, |__encoder| {\n+                    ::std::result::Result::Ok(match *self { #encode_inner })\n+                })\n+            }\n+        }\n+        _ => {\n+            let mut variant_idx = 0usize;\n+            let encode_inner = s.each_variant(|vi| {\n+                let variant_name = vi.ast().ident.to_string();\n+                let mut field_idx = 0usize;\n+\n+                let encode_fields: TokenStream = vi\n+                    .bindings()\n+                    .iter()\n+                    .map(|binding| {\n+                        let bind_ident = &binding.binding;\n+                        let result = quote! {\n+                            match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n+                                __encoder,\n+                                #field_idx,\n+                                |__encoder|\n+                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                            ) {\n+                                ::std::result::Result::Ok(()) => (),\n+                                ::std::result::Result::Err(__err)\n+                                    => return ::std::result::Result::Err(__err),\n+                            }\n+                        };\n+                        field_idx += 1;\n+                        result\n+                    })\n+                    .collect();\n+\n+                let result = quote! { ::rustc_serialize::Encoder::emit_enum_variant(\n+                    __encoder,\n+                   #variant_name,\n+                   #variant_idx,\n+                   #field_idx,\n+                   |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n+                ) };\n+                variant_idx += 1;\n+                result\n+            });\n+            quote! {\n+                ::rustc_serialize::Encoder::emit_enum(__encoder, #ty_name, |__encoder| {\n+                    match *self {\n+                        #encode_inner\n+                    }\n+                })\n+            }\n+        }\n+    };\n+\n+    let lints = if allow_unreachable_code {\n+        quote! { #![allow(unreachable_code)] }\n+    } else {\n+        quote! {}\n+    };\n+\n+    s.bound_impl(\n+        quote!(::rustc_serialize::Encodable<#encoder_ty>),\n+        quote! {\n+            fn encode(\n+                &self,\n+                __encoder: &mut #encoder_ty,\n+            ) -> ::std::result::Result<(), <#encoder_ty as ::rustc_serialize::Encoder>::Error> {\n+                #lints\n+                #encode_body\n+            }\n+        },\n+    )\n+}"}, {"sha": "352665f0ab199e2d216e31f2b4e0b9d129e340d2", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -167,7 +167,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n             }\n         }\n \n-        macro_rules! symbols {\n+        macro_rules! define_symbols {\n             () => {\n                 #symbols_stream\n "}, {"sha": "6e3e4e55e42fd0539e3e4129cc4c94ad89d1e99d", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,6 +23,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n stable_deref_trait = \"1.0.0\"\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "e50fa34554d51acbed0fc7e135651bc6d912f045", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -15,6 +15,8 @@\n \n extern crate proc_macro;\n \n+#[macro_use]\n+extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n #[macro_use]"}, {"sha": "27f59ec26383f4c5c66ce8911dc6700a0bafc286", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 113, "deletions": 123, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,15 +7,15 @@ use crate::rmeta::*;\n use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::lang_items;\n@@ -26,11 +26,11 @@ use rustc_middle::middle::cstore::{CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::mir::{self, interpret, Body, Promoted};\n+use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n-use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder, UseSpecializedDecodable};\n+use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnDataDecodeMode;\n use rustc_span::source_map::{respan, Spanned};\n@@ -229,15 +229,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T, ()> {\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T], usize> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n     fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n@@ -278,6 +278,8 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = true;\n+\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n@@ -351,81 +353,105 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         if cnum == LOCAL_CRATE { self.cdata().cnum } else { self.cdata().cnum_map[cnum] }\n     }\n-}\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T, ()>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        self.read_lazy_with_meta(())\n+    fn decode_alloc_id(&mut self) -> Result<rustc_middle::mir::interpret::AllocId, Self::Error> {\n+        if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n+            alloc_decoding_session.decode_alloc_id(self)\n+        } else {\n+            bug!(\"Attempting to decode interpret::AllocId without CrateMetadata\")\n+        }\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T], usize>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n-        let len = self.read_usize()?;\n-        if len == 0 { Ok(Lazy::empty()) } else { self.read_lazy_with_meta(len) }\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for CrateNum {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<CrateNum, String> {\n+        let cnum = CrateNum::from_u32(d.read_u32()?);\n+        Ok(d.map_encoded_cnum_to_current(cnum))\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>, usize>> for DecodeContext<'a, 'tcx>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    fn specialized_decode(&mut self) -> Result<Lazy<Table<I, T>>, Self::Error> {\n-        let len = self.read_usize()?;\n-        self.read_lazy_with_meta(len)\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefIndex, String> {\n+        Ok(DefIndex::from_u32(d.read_u32()?))\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        let krate = CrateNum::decode(self)?;\n-        let index = DefIndex::decode(self)?;\n-\n-        Ok(DefId { krate, index })\n+impl<'a, 'tcx> FingerprintDecoder for DecodeContext<'a, 'tcx> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n+        Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        Ok(DefIndex::from_u32(self.read_u32()?))\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n+        let cdata = decoder.cdata();\n+        let sess = decoder.sess.unwrap();\n+        let cname = cdata.root.name;\n+        rustc_span::hygiene::decode_syntax_context(decoder, &cdata.hygiene_context, |_, id| {\n+            debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n+            Ok(cdata\n+                .root\n+                .syntax_contexts\n+                .get(&cdata, id)\n+                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n+                .decode((&cdata, sess)))\n+        })\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        Ok(DefId::decode(self)?.expect_local())\n-    }\n-}\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnId, String> {\n+        let local_cdata = decoder.cdata();\n+        let sess = decoder.sess.unwrap();\n+        let expn_cnum = Cell::new(None);\n+        let get_ctxt = |cnum| {\n+            expn_cnum.set(Some(cnum));\n+            if cnum == LOCAL_CRATE {\n+                &local_cdata.hygiene_context\n+            } else {\n+                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n+            }\n+        };\n \n-impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n-            alloc_decoding_session.decode_alloc_id(self)\n-        } else {\n-            bug!(\"Attempting to decode interpret::AllocId without CrateMetadata\")\n-        }\n+        rustc_span::hygiene::decode_expn_id(\n+            decoder,\n+            ExpnDataDecodeMode::Metadata(get_ctxt),\n+            |_this, index| {\n+                let cnum = expn_cnum.get().unwrap();\n+                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n+                // are stored in the owning crate, to avoid duplication.\n+                let crate_data = if cnum == LOCAL_CRATE {\n+                    local_cdata\n+                } else {\n+                    local_cdata.cstore.get_crate_data(cnum)\n+                };\n+                Ok(crate_data\n+                    .root\n+                    .expn_data\n+                    .get(&crate_data, index)\n+                    .unwrap()\n+                    .decode((&crate_data, sess)))\n+            },\n+        )\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let tag = u8::decode(self)?;\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Span, String> {\n+        let tag = u8::decode(decoder)?;\n \n         if tag == TAG_INVALID_SPAN {\n             return Ok(DUMMY_SP);\n         }\n \n         debug_assert!(tag == TAG_VALID_SPAN_LOCAL || tag == TAG_VALID_SPAN_FOREIGN);\n \n-        let lo = BytePos::decode(self)?;\n-        let len = BytePos::decode(self)?;\n-        let ctxt = SyntaxContext::decode(self)?;\n+        let lo = BytePos::decode(decoder)?;\n+        let len = BytePos::decode(decoder)?;\n+        let ctxt = SyntaxContext::decode(decoder)?;\n         let hi = lo + len;\n \n-        let sess = if let Some(sess) = self.sess {\n+        let sess = if let Some(sess) = decoder.sess {\n             sess\n         } else {\n             bug!(\"Cannot decode Span without Session.\")\n@@ -460,22 +486,22 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         // we can call `imported_source_files` for the proper crate, and binary search\n         // through the returned slice using our span.\n         let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            self.cdata().imported_source_files(sess)\n+            decoder.cdata().imported_source_files(sess)\n         } else {\n             // When we encode a proc-macro crate, all `Span`s should be encoded\n             // with `TAG_VALID_SPAN_LOCAL`\n-            if self.cdata().root.is_proc_macro_crate() {\n+            if decoder.cdata().root.is_proc_macro_crate() {\n                 // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE\n                 // since we don't have `cnum_map` populated.\n-                let cnum = u32::decode(self)?;\n+                let cnum = u32::decode(decoder)?;\n                 panic!(\n                     \"Decoding of crate {:?} tried to access proc-macro dep {:?}\",\n-                    self.cdata().root.name,\n+                    decoder.cdata().root.name,\n                     cnum\n                 );\n             }\n             // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above\n-            let cnum = CrateNum::decode(self)?;\n+            let cnum = CrateNum::decode(decoder)?;\n             debug!(\n                 \"SpecializedDecoder<Span>::specialized_decode: loading source files from cnum {:?}\",\n                 cnum\n@@ -485,16 +511,16 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // not worth it to maintain a per-CrateNum cache for `last_source_file_index`.\n             // We just set it to 0, to ensure that we don't try to access something out\n             // of bounds for our initial 'guess'\n-            self.last_source_file_index = 0;\n+            decoder.last_source_file_index = 0;\n \n-            let foreign_data = self.cdata().cstore.get_crate_data(cnum);\n+            let foreign_data = decoder.cdata().cstore.get_crate_data(cnum);\n             foreign_data.imported_source_files(sess)\n         };\n \n         let source_file = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same source_file.\n-            let last_source_file = &imported_source_files[self.last_source_file_index];\n+            let last_source_file = &imported_source_files[decoder.last_source_file_index];\n \n             if lo >= last_source_file.original_start_pos && lo <= last_source_file.original_end_pos\n             {\n@@ -507,7 +533,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n                 // Don't try to cache the index for foreign spans,\n                 // as this would require a map from CrateNums to indices\n                 if tag == TAG_VALID_SPAN_LOCAL {\n-                    self.last_source_file_index = index;\n+                    decoder.last_source_file_index = index;\n                 }\n                 &imported_source_files[index]\n             }\n@@ -540,19 +566,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        ty::codec::RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<T>\n+{\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        decoder.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<mir::ClearCrossCrate<T>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<[T]>\n+{\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        let len = decoder.read_usize()?;\n+        if len == 0 { Ok(Lazy::empty()) } else { decoder.read_lazy_with_meta(len) }\n+    }\n+}\n+\n+impl<'a, 'tcx, I: Idx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<Table<I, T>>\n where\n-    mir::ClearCrossCrate<T>: UseSpecializedDecodable,\n+    Option<T>: FixedSizeEncoding,\n {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n-        Ok(mir::ClearCrossCrate::Clear)\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        let len = decoder.read_usize()?;\n+        decoder.read_lazy_with_meta(len)\n     }\n }\n \n@@ -1840,57 +1884,3 @@ fn macro_kind(raw: &ProcMacro) -> MacroKind {\n         ProcMacro::Bang { .. } => MacroKind::Bang,\n     }\n }\n-\n-impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<SyntaxContext, Self::Error> {\n-        let cdata = self.cdata();\n-        let sess = self.sess.unwrap();\n-        let cname = cdata.root.name;\n-        rustc_span::hygiene::decode_syntax_context(self, &cdata.hygiene_context, |_, id| {\n-            debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n-            Ok(cdata\n-                .root\n-                .syntax_contexts\n-                .get(&cdata, id)\n-                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n-                .decode((&cdata, sess)))\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<ExpnId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ExpnId, Self::Error> {\n-        let local_cdata = self.cdata();\n-        let sess = self.sess.unwrap();\n-        let expn_cnum = Cell::new(None);\n-        let get_ctxt = |cnum| {\n-            expn_cnum.set(Some(cnum));\n-            if cnum == LOCAL_CRATE {\n-                &local_cdata.hygiene_context\n-            } else {\n-                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n-            }\n-        };\n-\n-        rustc_span::hygiene::decode_expn_id(\n-            self,\n-            ExpnDataDecodeMode::Metadata(get_ctxt),\n-            |_this, index| {\n-                let cnum = expn_cnum.get().unwrap();\n-                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n-                // are stored in the owning crate, to avoid duplication.\n-                let crate_data = if cnum == LOCAL_CRATE {\n-                    local_cdata\n-                } else {\n-                    local_cdata.cstore.get_crate_data(cnum)\n-                };\n-                Ok(crate_data\n-                    .root\n-                    .expn_data\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess)))\n-            },\n-        )\n-    }\n-}"}, {"sha": "e97e598765e98374d363a490a163f9f17e89c507", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 92, "deletions": 118, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,7 +3,7 @@ use crate::rmeta::*;\n \n use log::{debug, trace};\n use rustc_ast::ast;\n-use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n@@ -23,11 +23,11 @@ use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n };\n-use rustc_middle::mir::{self, interpret};\n+use rustc_middle::mir::interpret;\n use rustc_middle::traits::specialization_graph;\n-use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n+use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder, UseSpecializedEncodable};\n+use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext};\n use rustc_span::source_map::Spanned;\n@@ -38,7 +38,7 @@ use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::path::Path;\n \n-struct EncodeContext<'a, 'tcx> {\n+pub(super) struct EncodeContext<'a, 'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n@@ -107,100 +107,87 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T, ()>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_lazy_distance(*lazy)\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<T>\n+{\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<[T], usize>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n-        self.emit_usize(lazy.meta)?;\n-        if lazy.meta == 0 {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<[T]>\n+{\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_usize(self.meta)?;\n+        if self.meta == 0 {\n             return Ok(());\n         }\n-        self.emit_lazy_distance(*lazy)\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>, usize>> for EncodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<Table<I, T>>\n where\n     Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_encode(&mut self, lazy: &Lazy<Table<I, T>>) -> Result<(), Self::Error> {\n-        self.emit_usize(lazy.meta)?;\n-        self.emit_lazy_distance(*lazy)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n-        self.emit_u32(cnum.as_u32())\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_usize(self.meta)?;\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_id: &DefId) -> Result<(), Self::Error> {\n-        let DefId { krate, index } = *def_id;\n-\n-        krate.encode(self)?;\n-        index.encode(self)\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        s.emit_u32(self.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<SyntaxContext> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, ctxt: &SyntaxContext) -> Result<(), Self::Error> {\n-        rustc_span::hygiene::raw_encode_syntax_context(*ctxt, &self.hygiene_ctxt, self)\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<ExpnId> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         rustc_span::hygiene::raw_encode_expn_id(\n-            *expn,\n-            &self.hygiene_ctxt,\n+            *self,\n+            &s.hygiene_ctxt,\n             ExpnDataEncodeMode::Metadata,\n-            self,\n+            s,\n         )\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n-        self.emit_u32(def_index.as_u32())\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if span.is_dummy() {\n-            return TAG_INVALID_SPAN.encode(self);\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        if self.is_dummy() {\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let span = span.data();\n+        let span = self.data();\n \n         // The Span infrastructure should make sure that this invariant holds:\n         debug_assert!(span.lo <= span.hi);\n \n-        if !self.source_file_cache.0.contains(span.lo) {\n-            let source_map = self.tcx.sess.source_map();\n+        if !s.source_file_cache.0.contains(span.lo) {\n+            let source_map = s.tcx.sess.source_map();\n             let source_file_index = source_map.lookup_source_file_idx(span.lo);\n-            self.source_file_cache =\n+            s.source_file_cache =\n                 (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n \n-        if !self.source_file_cache.0.contains(span.hi) {\n+        if !s.source_file_cache.0.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n-            return TAG_INVALID_SPAN.encode(self);\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let source_files = self.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+        let source_files = s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n         // Record the fact that we need to encode the data for this `SourceFile`\n-        source_files.insert(self.source_file_cache.1);\n+        source_files.insert(s.source_file_cache.1);\n \n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n@@ -218,7 +205,7 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, hi) = if self.source_file_cache.0.is_imported() && !self.is_proc_macro {\n+        let (tag, lo, hi) = if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n             // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n             // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n             // are relative to the source map information for the 'foreign' crate whose CrateNum\n@@ -230,26 +217,26 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n             // Span that can be used without any additional trouble.\n             let external_start_pos = {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n-                match &*self.source_file_cache.0.external_src.lock() {\n+                match &*s.source_file_cache.0.external_src.lock() {\n                     ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n                     src => panic!(\"Unexpected external source {:?}\", src),\n                 }\n             };\n-            let lo = (span.lo - self.source_file_cache.0.start_pos) + external_start_pos;\n-            let hi = (span.hi - self.source_file_cache.0.start_pos) + external_start_pos;\n+            let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n+            let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n \n             (TAG_VALID_SPAN_FOREIGN, lo, hi)\n         } else {\n             (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n         };\n \n-        tag.encode(self)?;\n-        lo.encode(self)?;\n+        tag.encode(s)?;\n+        lo.encode(s)?;\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n         let len = hi - lo;\n-        len.encode(self)?;\n+        len.encode(s)?;\n \n         // Don't serialize any `SyntaxContext`s from a proc-macro crate,\n         // since we don't load proc-macro dependencies during serialization.\n@@ -282,101 +269,85 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // IMPORTANT: If this is ever changed, be sure to update\n         // `rustc_span::hygiene::raw_encode_expn_id` to handle\n         // encoding `ExpnData` for proc-macro crates.\n-        if self.is_proc_macro {\n-            SyntaxContext::root().encode(self)?;\n+        if s.is_proc_macro {\n+            SyntaxContext::root().encode(s)?;\n         } else {\n-            span.ctxt.encode(self)?;\n+            span.ctxt.encode(s)?;\n         }\n \n         if tag == TAG_VALID_SPAN_FOREIGN {\n-            // This needs to be two lines to avoid holding the `self.source_file_cache`\n-            // while calling `cnum.encode(self)`\n-            let cnum = self.source_file_cache.0.cnum;\n-            cnum.encode(self)?;\n+            // This needs to be two lines to avoid holding the `s.source_file_cache`\n+            // while calling `cnum.encode(s)`\n+            let cnum = s.source_file_cache.0.cnum;\n+            cnum.encode(s)?;\n         }\n \n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n-        self.specialized_encode(&def_id.to_def_id())\n+impl<'a, 'tcx> FingerprintEncoder for EncodeContext<'a, 'tcx> {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n+        f.encode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'b, 'c, 'tcx> SpecializedEncoder<&'a ty::TyS<'b>> for EncodeContext<'c, 'tcx>\n-where\n-    &'a ty::TyS<'b>: UseSpecializedEncodable,\n-{\n-    fn specialized_encode(&mut self, ty: &&'a ty::TyS<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(ty).is_some());\n-        let ty = unsafe { std::mem::transmute::<&&'a ty::TyS<'b>, &&'tcx ty::TyS<'tcx>>(ty) };\n-        ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n+impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = true;\n+\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n     }\n-}\n \n-impl<'a, 'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(predicate).is_some());\n-        let predicate =\n-            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n-        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n-            &mut encoder.predicate_shorthands\n-        })\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n     }\n-}\n \n-impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n-        index.encode(self)\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n+        &mut self.type_shorthands\n     }\n-}\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        f.encode_opaque(&mut self.opaque)\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<rustc_middle::ty::Predicate<'tcx>, usize> {\n+        &mut self.predicate_shorthands\n     }\n-}\n \n-impl<'a, 'tcx, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'a, 'tcx>\n-where\n-    mir::ClearCrossCrate<T>: UseSpecializedEncodable,\n-{\n-    fn specialized_encode(&mut self, _: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n-        Ok(())\n+    fn encode_alloc_id(\n+        &mut self,\n+        alloc_id: &rustc_middle::mir::interpret::AllocId,\n+    ) -> Result<(), Self::Error> {\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n+\n+        index.encode(self)\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n-    fn position(&self) -> usize {\n-        self.opaque.position()\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        (**self).encode(s)\n     }\n }\n \n /// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n-trait EncodeContentsForLazy<T: ?Sized + LazyMeta> {\n+trait EncodeContentsForLazy<'a, 'tcx, T: ?Sized + LazyMeta> {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> T::Meta;\n }\n \n-impl<T: Encodable> EncodeContentsForLazy<T> for &T {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for &T {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n         self.encode(ecx).unwrap()\n     }\n }\n \n-impl<T: Encodable> EncodeContentsForLazy<T> for T {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for T {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n         self.encode(ecx).unwrap()\n     }\n }\n \n-impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n+impl<'a, 'tcx, I, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, [T]> for I\n where\n     I: IntoIterator,\n-    I::Item: EncodeContentsForLazy<T>,\n+    I::Item: EncodeContentsForLazy<'a, 'tcx, T>,\n {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> usize {\n         self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n@@ -421,7 +392,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.emit_usize(distance)\n     }\n \n-    fn lazy<T: ?Sized + LazyMeta>(&mut self, value: impl EncodeContentsForLazy<T>) -> Lazy<T> {\n+    fn lazy<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        value: impl EncodeContentsForLazy<'a, 'tcx, T>,\n+    ) -> Lazy<T> {\n         let pos = NonZeroUsize::new(self.position()).unwrap();\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);"}, {"sha": "b15c20e515f495f2d7454ceee44706ae554a2cd0", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -26,8 +26,10 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+use decoder::DecodeContext;\n pub use decoder::{provide, provide_extern};\n crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n+use encoder::EncodeContext;\n use rustc_span::hygiene::SyntaxContextData;\n \n mod decoder;\n@@ -141,9 +143,6 @@ impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n     }\n }\n \n-impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n-impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n-\n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LazyState {\n@@ -172,7 +171,7 @@ macro_rules! Lazy {\n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n crate struct CrateRoot<'tcx> {\n     name: Symbol,\n     triple: TargetTriple,\n@@ -221,7 +220,7 @@ crate struct CrateRoot<'tcx> {\n     symbol_mangling_version: SymbolManglingVersion,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n crate struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n@@ -230,7 +229,7 @@ crate struct CrateDep {\n     pub extra_filename: String,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n crate struct TraitImpls {\n     trait_id: (u32, DefIndex),\n     impls: Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>,\n@@ -239,7 +238,7 @@ crate struct TraitImpls {\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n-        #[derive(RustcEncodable, RustcDecodable)]\n+        #[derive(MetadataEncodable, MetadataDecodable)]\n         crate struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<DefIndex, $T>)),+\n         }\n@@ -288,7 +287,7 @@ define_tables! {\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]\n enum EntryKind {\n     AnonConst(mir::ConstQualifs, Lazy<RenderedConst>),\n     Const(mir::ConstQualifs, Lazy<RenderedConst>),\n@@ -324,23 +323,23 @@ enum EntryKind {\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n struct RenderedConst(String);\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct ModData {\n     reexports: Lazy<[Export<hir::HirId>]>,\n     expansion: ExpnId,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n     param_names: Lazy<[Ident]>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct VariantData {\n     ctor_kind: CtorKind,\n     discr: ty::VariantDiscr,\n@@ -349,7 +348,7 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct TraitData {\n     unsafety: hir::Unsafety,\n     paren_sugar: bool,\n@@ -358,7 +357,7 @@ struct TraitData {\n     specialization_kind: ty::trait_def::TraitSpecializationKind,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct ImplData {\n     polarity: ty::ImplPolarity,\n     defaultness: hir::Defaultness,\n@@ -372,7 +371,7 @@ struct ImplData {\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable)]\n enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n@@ -404,14 +403,14 @@ impl AssocContainer {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct AssocFnData {\n     fn_data: FnData,\n     container: AssocContainer,\n     has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct GeneratorData<'tcx> {\n     layout: mir::GeneratorLayout<'tcx>,\n }"}, {"sha": "728ab0015d1e4e773618dcff0d967426496af680", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,7 +2,7 @@ use crate::rmeta::*;\n \n use log::debug;\n use rustc_index::vec::Idx;\n-use rustc_serialize::{opaque::Encoder, Encodable};\n+use rustc_serialize::opaque::Encoder;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n@@ -78,7 +78,7 @@ impl FixedSizeEncoding for u32 {\n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `Lazy<T>` impl, but in the general case we might not need / want to\n // fit every `usize` in `u32`.\n-impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n+impl<T> FixedSizeEncoding for Option<Lazy<T>> {\n     fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN);\n \n     fn from_bytes(b: &[u8]) -> Self {\n@@ -93,7 +93,7 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n     }\n }\n \n-impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n+impl<T> FixedSizeEncoding for Option<Lazy<[T]>> {\n     fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN * 2);\n \n     fn from_bytes(b: &[u8]) -> Self {"}, {"sha": "99889c74da0ec1c7187ec733d8c3b3a1594030c2", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 28, "deletions": 71, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,141 +11,98 @@\n macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n-            [] layouts: rustc_target::abi::Layout, rustc_target::abi::Layout;\n+            [] layouts: rustc_target::abi::Layout,\n             // AdtDef are interned and compared by address\n-            [] adt_def: rustc_middle::ty::AdtDef, rustc_middle::ty::AdtDef;\n-            [] steal_mir:\n-                rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n-                rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>;\n-            [decode] mir: rustc_middle::mir::Body<$tcx>, rustc_middle::mir::Body<'_x>;\n+            [] adt_def: rustc_middle::ty::AdtDef,\n+            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n+            [decode] mir: rustc_middle::mir::Body<$tcx>,\n             [] steal_promoted:\n                 rustc_middle::ty::steal::Steal<\n                     rustc_index::vec::IndexVec<\n                         rustc_middle::mir::Promoted,\n                         rustc_middle::mir::Body<$tcx>\n                     >\n                 >,\n-                rustc_middle::ty::steal::Steal<\n-                    rustc_index::vec::IndexVec<\n-                        rustc_middle::mir::Promoted,\n-                        rustc_middle::mir::Body<$tcx>\n-                    >\n-                >;\n             [decode] promoted:\n                 rustc_index::vec::IndexVec<\n                     rustc_middle::mir::Promoted,\n                     rustc_middle::mir::Body<$tcx>\n                 >,\n-                rustc_index::vec::IndexVec<\n-                    rustc_middle::mir::Promoted,\n-                    rustc_middle::mir::Body<'_x>\n-                >;\n-            [decode] typeck_results: rustc_middle::ty::TypeckResults<$tcx>, rustc_middle::ty::TypeckResults<'_x>;\n+            [decode] typeck_results: rustc_middle::ty::TypeckResults<$tcx>,\n             [decode] borrowck_result:\n                 rustc_middle::mir::BorrowCheckResult<$tcx>,\n-                rustc_middle::mir::BorrowCheckResult<'_x>;\n-            [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult, rustc_middle::mir::UnsafetyCheckResult;\n-            [] const_allocs: rustc_middle::mir::interpret::Allocation, rustc_middle::mir::interpret::Allocation;\n+            [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n+            [] const_allocs: rustc_middle::mir::interpret::Allocation,\n             // Required for the incremental on-disk cache\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;\n-            [] region_scope_tree: rustc_middle::middle::region::ScopeTree, rustc_middle::middle::region::ScopeTree;\n+            [few] mir_keys: rustc_hir::def_id::DefIdSet,\n+            [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::DropckOutlivesResult<'tcx>\n                     >\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y,\n-                        rustc_middle::traits::query::DropckOutlivesResult<'_z>\n-                    >\n-                >;\n             [] normalize_projection_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::NormalizationResult<'tcx>\n                     >\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y,\n-                        rustc_middle::traits::query::NormalizationResult<'_z>\n-                    >\n-                >;\n             [] implied_outlives_bounds:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         Vec<rustc_middle::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y,\n-                        Vec<rustc_middle::traits::query::OutlivesBound<'_z>>\n-                    >\n-                >;\n             [] type_op_subtype:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, ()>\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y, ()>\n-                >;\n             [] type_op_normalize_poly_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::PolyFnSig<'tcx>>\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::PolyFnSig<'_z>>\n-                >;\n             [] type_op_normalize_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::FnSig<'tcx>>\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::FnSig<'_z>>\n-                >;\n             [] type_op_normalize_predicate:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Predicate<'tcx>>\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::Predicate<'_z>>\n-                >;\n             [] type_op_normalize_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n-                rustc_middle::infer::canonical::Canonical<'_x,\n-                    rustc_middle::infer::canonical::QueryResponse<'_y, &'_z rustc_middle::ty::TyS<'_w>>\n-                >;\n-            [few] all_traits: Vec<rustc_hir::def_id::DefId>, Vec<rustc_hir::def_id::DefId>;\n-            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels, rustc_middle::middle::privacy::AccessLevels;\n-            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule, rustc_middle::middle::cstore::ForeignModule;\n-            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>, Vec<rustc_middle::middle::cstore::ForeignModule>;\n-            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>, rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>;\n-            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation, rustc_middle::traits::ObjectSafetyViolation;\n-            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>, rustc_middle::mir::mono::CodegenUnit<'_x>;\n-            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n-            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>, rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>;\n-            [] hir_id_set: rustc_hir::HirIdSet, rustc_hir::HirIdSet;\n+            [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n+            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n+            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n+            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n+            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n+            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n+            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n+            [] attribute: rustc_ast::ast::Attribute,\n+            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>,\n+            [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types\n-            [] tys: rustc_middle::ty::TyS<$tcx>, rustc_middle::ty::TyS<'_x>;\n-            [] predicates: rustc_middle::ty::PredicateInner<$tcx>, rustc_middle::ty::PredicateInner<'_x>;\n+            [] tys: rustc_middle::ty::TyS<$tcx>,\n+            [] predicates: rustc_middle::ty::PredicateInner<$tcx>,\n \n             // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>, rustc_middle::hir::map::IndexedHir<'_x>;\n-            [few] hir_definitions: rustc_hir::definitions::Definitions, rustc_hir::definitions::Definitions;\n-            [] hir_owner: rustc_middle::hir::Owner<$tcx>, rustc_middle::hir::Owner<'_x>;\n-            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>, rustc_middle::hir::OwnerNodes<'_x>;\n+            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>,\n+            [few] hir_definitions: rustc_hir::definitions::Definitions,\n+            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n+            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n-            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n+            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n \n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n-            [decode] span: rustc_span::Span, rustc_span::Span;\n-            [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>, rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>;\n+            [decode] span: rustc_span::Span,\n+            [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n         ], $tcx);\n     )\n }"}, {"sha": "a61b9af9bace43368b821c711dd4d577d520ee17", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -110,8 +110,7 @@ macro_rules! define_dep_nodes {\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n       ,)*\n     ) => (\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n         #[allow(non_camel_case_types)]\n         pub enum DepKind {\n             $($variant),*"}, {"sha": "be9e38aca65d10feeceb8e1d50b7fb208ef86ea5", "filename": "src/librustc_middle/hir/exports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fexports.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -13,7 +13,7 @@ use std::fmt::Debug;\n /// within.\n pub type ExportMap<Id> = FxHashMap<LocalDefId, Vec<Export<Id>>>;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Export<Id> {\n     /// The name of the target.\n     pub ident: Ident,"}, {"sha": "bcb56fae1709d94e2ca05ba1e0b4bed411260d1f", "filename": "src/librustc_middle/hir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fplace.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -4,7 +4,7 @@ use crate::ty::Ty;\n use rustc_hir::HirId;\n use rustc_target::abi::VariantIdx;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum PlaceBase {\n     /// A temporary variable\n     Rvalue,\n@@ -16,7 +16,7 @@ pub enum PlaceBase {\n     Upvar(ty::UpvarId),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum ProjectionKind {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref,\n@@ -36,7 +36,7 @@ pub enum ProjectionKind {\n     Subslice,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct Projection<'tcx> {\n     /// Type after the projection is being applied.\n     pub ty: Ty<'tcx>,\n@@ -48,7 +48,7 @@ pub struct Projection<'tcx> {\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n     pub base_ty: Ty<'tcx>,\n@@ -61,7 +61,7 @@ pub struct Place<'tcx> {\n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,"}, {"sha": "1e15ae49a0c384e1a25ad4fcc6dd9ed5e56b3a16", "filename": "src/librustc_middle/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -26,14 +26,13 @@ use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n-use rustc_serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewritten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct Canonical<'tcx, V> {\n     pub max_universe: ty::UniverseIndex,\n@@ -43,8 +42,6 @@ pub struct Canonical<'tcx, V> {\n \n pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n \n-impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n-\n /// A set of values corresponding to the canonical variables from some\n /// `Canonical`. You can give these values to\n /// `canonical_value.substitute` to substitute them into the canonical\n@@ -54,7 +51,7 @@ impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n /// vectors with the original values that were replaced by canonical\n /// variables. You will need to supply it later to instantiate the\n /// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n@@ -90,7 +87,7 @@ impl Default for OriginalQueryValues<'tcx> {\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n@@ -115,7 +112,7 @@ impl CanonicalVarInfo {\n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -160,7 +157,7 @@ impl CanonicalVarKind {\n /// 22.) can only be instantiated with integral/float types (e.g.,\n /// usize or f32). In order to faithfully reproduce a type, we need to\n /// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n     General(ty::UniverseIndex),"}, {"sha": "4c06472ceb8739fdadfb68d0f3548ceb6ce7669c", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -27,6 +27,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(cmp_min_max_by)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(const_fn_transmute)]"}, {"sha": "62a6198b9b402108b931b8bacfe1bc802ac5d871", "filename": "src/librustc_middle/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,7 +3,7 @@ use rustc_attr::{InlineAttr, OptimizeAttr};\n use rustc_session::config::SanitizerSet;\n use rustc_span::symbol::Symbol;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct CodegenFnAttrs {\n     pub flags: CodegenFnAttrFlags,\n     /// Parsed representation of the `#[inline]` attribute\n@@ -37,7 +37,7 @@ pub struct CodegenFnAttrs {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, HashStable)]\n+    #[derive(TyEncodable, TyDecodable, HashStable)]\n     pub struct CodegenFnAttrFlags: u32 {\n         /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n         /// the hot path."}, {"sha": "6a8f6c3e202038eb66cfb8c14441e95d1068bf9a", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -25,7 +25,7 @@ use std::path::{Path, PathBuf};\n \n /// Where a crate came from on the local filesystem. One of these three options\n /// must be non-None.\n-#[derive(PartialEq, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, HashStable, Encodable, Decodable)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n@@ -38,7 +38,7 @@ impl CrateSource {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+#[derive(Encodable, Decodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n #[derive(HashStable)]\n pub enum CrateDepKind {\n     /// A dependency that is only used for its macros.\n@@ -60,7 +60,7 @@ impl CrateDepKind {\n     }\n }\n \n-#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n pub enum LibSource {\n     Some(PathBuf),\n     MetadataOnly,\n@@ -80,13 +80,13 @@ impl LibSource {\n     }\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Debug, PartialEq, Clone, Encodable, Decodable, HashStable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n     pub name: Option<Symbol>,\n@@ -95,7 +95,7 @@ pub struct NativeLib {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,\n@@ -145,7 +145,7 @@ pub enum ExternCrateSource {\n     Path,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct EncodedMetadata {\n     pub raw_data: Vec<u8>,\n }"}, {"sha": "e079843bfbc3c9dbfbf372f6e664576a373ace02", "filename": "src/librustc_middle/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -19,7 +19,7 @@ pub type DependencyList = Vec<Linkage>;\n /// This is local to the tcx, and is generally relevant to one session.\n pub type Dependencies = Vec<(CrateType, DependencyList)>;\n \n-#[derive(Copy, Clone, PartialEq, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable, Encodable, Decodable)]\n pub enum Linkage {\n     NotLinked,\n     IncludedFromDylib,"}, {"sha": "276e45ce99b29a7490b0ace989b6f5b232a4dd0d", "filename": "src/librustc_middle/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,7 +8,7 @@ use rustc_macros::HashStable;\n /// kind of crate, including cdylibs which export very few things.\n /// `Rust` will only be exported if the crate produced is a Rust\n /// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum SymbolExportLevel {\n     C,\n     Rust,\n@@ -21,7 +21,7 @@ impl SymbolExportLevel {\n     }\n }\n \n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n     Generic(DefId, SubstsRef<'tcx>),"}, {"sha": "4c6ac82060485c9bb0ccb040cc76c6df75c634a3", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -80,7 +80,7 @@ use std::fmt;\n // placate the same deriving in `ty::FreeRegion`, but we may want to\n // actually attach a more meaningful ordering to scopes than the one\n // generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n@@ -104,7 +104,7 @@ impl fmt::Debug for Scope {\n     }\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum ScopeData {\n     Node,\n@@ -324,7 +324,7 @@ pub struct ScopeTree {\n     pub body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct YieldData {\n     /// The `Span` of the yield.\n     pub span: Span,"}, {"sha": "3d0144e9c8a9903e4b2d0f4545da5a6f5487fa2a", "filename": "src/librustc_middle/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,7 +11,7 @@ use rustc_macros::HashStable;\n /// The origin of a named lifetime definition.\n ///\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum LifetimeDefOrigin {\n     // Explicit binders like `fn foo<'a>(x: &'a u8)` or elided like `impl Foo<&u32>`\n     ExplicitOrElided,\n@@ -35,7 +35,7 @@ impl LifetimeDefOrigin {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n@@ -47,7 +47,7 @@ pub enum Region {\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Set1<T> {\n     Empty,\n     One(T),"}, {"sha": "bee8d13c762f976de14e357366fc8c8f8adec42c", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -14,7 +14,7 @@ use super::{\n     UninitBytesAccess,\n };\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = (), Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -154,10 +154,10 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n-    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// from `get_bytes_with_uninit_and_ptr` in that it does no relocation checks (even on the\n     /// edges) at all. It further ignores `AllocationExtra` callbacks.\n     /// This must not be used for reads affecting the interpreter execution.\n-    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+    pub fn inspect_with_uninit_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n         &self.bytes[range]\n     }\n \n@@ -172,8 +172,6 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n-\n /// Byte accessors.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Just a small local helper function to avoid a bit of code repetition.\n@@ -194,7 +192,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n+    /// `get_bytes_with_uninit_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n@@ -244,7 +242,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_uninit_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -302,19 +300,19 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n-    /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n+    /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        allow_ptr_and_undef: bool,\n+        allow_uninit_and_ptr: bool,\n     ) -> InterpResult<'tcx> {\n         // Check bounds and relocations on the edges.\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Check uninit and ptr.\n-        if !allow_ptr_and_undef {\n+        if !allow_uninit_and_ptr {\n             self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         }\n@@ -361,7 +359,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         // `get_bytes_unchecked` tests relocation edges.\n-        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        let bytes = self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n         if self.is_init(ptr, size).is_err() {\n@@ -594,7 +592,7 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n-    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n+    pub fn compress_uninit_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n@@ -636,8 +634,8 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         size: Size,\n         repeat: u64,\n     ) {\n-        // An optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization\n+        // bits if they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.init_mask.set_range_inbounds(\n                 dest.offset,\n@@ -666,7 +664,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Relocations.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n \n impl<Tag, Id> Relocations<Tag, Id> {\n@@ -747,7 +745,7 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,"}, {"sha": "059925088ce1d52d66266574111bfe509ba3dccb", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 169, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,21 +1,17 @@\n use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::layout::LayoutError;\n-use crate::ty::query::TyCtxtAt;\n-use crate::ty::{self, layout, tls, FnSig, Ty};\n+use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported};\n-use rustc_hir as hir;\n-use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n-use rustc_span::{def_id::DefId, Pos, Span};\n+use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt, mem};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum ErrorHandled {\n     /// Already reported an error for this evaluation, and the compilation is\n     /// *guaranteed* to fail. Warnings/lints *must not* produce `Reported`.\n@@ -34,167 +30,6 @@ CloneTypeFoldableAndLiftImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n-#[derive(Debug)]\n-pub struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub error: crate::mir::interpret::InterpError<'tcx>,\n-    pub stacktrace: Vec<FrameInfo<'tcx>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct FrameInfo<'tcx> {\n-    pub instance: ty::Instance<'tcx>,\n-    pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n-}\n-\n-impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n-                == DefPathData::ClosureExpr\n-            {\n-                write!(f, \"inside closure\")?;\n-            } else {\n-                write!(f, \"inside `{}`\", self.instance)?;\n-            }\n-            if !self.span.is_dummy() {\n-                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n-                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> ConstEvalErr<'tcx> {\n-    pub fn struct_error(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-    ) -> ErrorHandled {\n-        self.struct_generic(tcx, message, emit, None)\n-    }\n-\n-    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.struct_error(tcx, message, |mut e| e.emit())\n-    }\n-\n-    pub fn report_as_lint(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        lint_root: hir::HirId,\n-        span: Option<Span>,\n-    ) -> ErrorHandled {\n-        self.struct_generic(\n-            tcx,\n-            message,\n-            |mut lint: DiagnosticBuilder<'_>| {\n-                // Apply the span.\n-                if let Some(span) = span {\n-                    let primary_spans = lint.span.primary_spans().to_vec();\n-                    // point at the actual error as the primary span\n-                    lint.replace_span_with(span);\n-                    // point to the `const` statement as a secondary span\n-                    // they don't have any label\n-                    for sp in primary_spans {\n-                        if sp != span {\n-                            lint.span_label(sp, \"\");\n-                        }\n-                    }\n-                }\n-                lint.emit();\n-            },\n-            Some(lint_root),\n-        )\n-    }\n-\n-    /// Create a diagnostic for this const eval error.\n-    ///\n-    /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `emit` to do any final processing.\n-    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n-    /// function to dispose of the diagnostic properly.\n-    ///\n-    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n-    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    fn struct_generic(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-        lint_root: Option<hir::HirId>,\n-    ) -> ErrorHandled {\n-        let must_error = match self.error {\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(TypeckError(error_reported)) => {\n-                return ErrorHandled::Reported(error_reported);\n-            }\n-            // We must *always* hard error on these, even if the caller wants just a lint.\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n-            _ => false,\n-        };\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-\n-        let err_msg = match &self.error {\n-            InterpError::MachineStop(msg) => {\n-                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n-                // Should be turned into a string by now.\n-                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n-            }\n-            err => err.to_string(),\n-        };\n-\n-        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                for frame_info in &self.stacktrace {\n-                    err.span_label(frame_info.span, frame_info.to_string());\n-                }\n-            }\n-            // Let the caller finish the job.\n-            emit(err)\n-        };\n-\n-        if must_error {\n-            // The `message` makes little sense here, this is a more serious error than the\n-            // caller thinks anyway.\n-            // See <https://github.com/rust-lang/rust/pull/63152>.\n-            finish(struct_error(tcx, &err_msg), None);\n-            ErrorHandled::Reported(ErrorReported)\n-        } else {\n-            // Regular case.\n-            if let Some(lint_root) = lint_root {\n-                // Report as lint.\n-                let hir_id = self\n-                    .stacktrace\n-                    .iter()\n-                    .rev()\n-                    .find_map(|frame| frame.lint_root)\n-                    .unwrap_or(lint_root);\n-                tcx.struct_span_lint_hir(\n-                    rustc_session::lint::builtin::CONST_ERR,\n-                    hir_id,\n-                    tcx.span,\n-                    |lint| finish(lint.build(message), Some(err_msg)),\n-                );\n-                ErrorHandled::Linted\n-            } else {\n-                // Report as hard error.\n-                finish(struct_error(tcx, message), Some(err_msg));\n-                ErrorHandled::Reported(ErrorReported)\n-            }\n-        }\n-    }\n-}\n-\n pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n@@ -302,7 +137,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n }\n \n /// Details of why a pointer had to be in-bounds.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n     MemoryAccessTest,\n     NullPointerTest,"}, {"sha": "e607da29ce453c76e8ad46ca70b514bcb2cfcdc3", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -108,18 +108,18 @@ use rustc_data_structures::sync::{HashMapExt, Lock};\n use rustc_data_structures::tiny_list::TinyList;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Encodable};\n use rustc_target::abi::{Endian, Size};\n \n use crate::mir;\n-use crate::ty::codec::TyDecoder;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n-    struct_error, CheckInAllocMsg, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n-    FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    struct_error, CheckInAllocMsg, ConstEvalRawResult, ConstEvalResult, ErrorHandled, InterpError,\n+    InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType, ResourceExhaustionInfo,\n+    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};\n@@ -132,7 +132,7 @@ pub use self::pointer::{Pointer, PointerArithmetic};\n /// - A constant\n /// - A static\n /// - A const fn where all arguments (if any) are zero-sized types\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n@@ -182,17 +182,14 @@ impl fmt::Display for AllocId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for AllocId {}\n-impl rustc_serialize::UseSpecializedDecodable for AllocId {}\n-\n-#[derive(RustcDecodable, RustcEncodable)]\n+#[derive(TyDecodable, TyEncodable)]\n enum AllocDiscriminant {\n     Alloc,\n     Fn,\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n+pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<'tcx>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -333,7 +330,7 @@ impl<'s> AllocDecodingSession<'s> {\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let alloc = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    let alloc = <&'tcx Allocation as Decodable<_>>::decode(decoder)?;\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n@@ -351,7 +348,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n-                    let did = DefId::decode(decoder)?;\n+                    let did = <DefId as Decodable<D>>::decode(decoder)?;\n                     trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().create_static_alloc(did);\n                     Ok(alloc_id)\n@@ -369,7 +366,7 @@ impl<'s> AllocDecodingSession<'s> {\n \n /// An allocation in the global (tcx-managed) memory can be either a function pointer,\n /// a static, or a \"real\" allocation with some data in it.\n-#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum GlobalAlloc<'tcx> {\n     /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),"}, {"sha": "e3d5a085613aaddfacf6fb61e2aca34521349648", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -87,7 +87,7 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n ///\n /// `Pointer` is generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Tag = ()> {\n     pub alloc_id: AllocId,"}, {"sha": "dcc1f8b1a4b3cd673a198eab02a69b8d12abd111", "filename": "src/librustc_middle/mir/interpret/queries.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -74,4 +74,27 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.const_eval_validated(inputs)\n         }\n     }\n+\n+    /// Evaluate a static's initializer, returning the allocation of the initializer's memory.\n+    pub fn eval_static_initializer(\n+        self,\n+        def_id: DefId,\n+    ) -> Result<&'tcx mir::Allocation, ErrorHandled> {\n+        trace!(\"eval_static_initializer: Need to compute {:?}\", def_id);\n+        assert!(self.is_static(def_id));\n+        let instance = ty::Instance::mono(self, def_id);\n+        let gid = GlobalId { instance, promoted: None };\n+        self.eval_to_allocation(gid, ty::ParamEnv::reveal_all())\n+    }\n+\n+    /// Evaluate anything constant-like, returning the allocation of the final memory.\n+    fn eval_to_allocation(\n+        self,\n+        gid: GlobalId<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<&'tcx mir::Allocation, ErrorHandled> {\n+        trace!(\"eval_to_allocation: Need to compute {:?}\", gid);\n+        let raw_const = self.const_eval_raw(param_env.and(gid))?;\n+        Ok(self.global_alloc(raw_const.alloc_id).unwrap_memory())\n+    }\n }"}, {"sha": "4c47f25105d0f4eb5d049b5b5e32ab6692e5806e", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,7 +23,7 @@ pub struct RawConst<'tcx> {\n \n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n@@ -58,7 +58,7 @@ impl<'tcx> ConstValue<'tcx> {\n \n     pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n         if let ConstValue::Slice { data, start, end } = *self {\n-            ::std::str::from_utf8(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+            ::std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n                 .ok()\n         } else {\n             None\n@@ -108,7 +108,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n@@ -562,7 +562,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n pub enum ScalarMaybeUninit<Tag = ()> {\n     Scalar(Scalar<Tag>),\n     Uninit,"}, {"sha": "c53d631568219b23e5cd4e9b31304ffd6587d91a", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,6 +5,7 @@\n use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -73,7 +74,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n /// The various \"big phases\" that MIR goes through.\n ///\n /// Warning: ordering of variants is significant.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n     Build = 0,\n@@ -91,7 +92,7 @@ impl MirPhase {\n }\n \n /// The lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n     /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -413,7 +414,7 @@ impl<'tcx> Body<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock\n@@ -465,9 +466,13 @@ impl<T> ClearCrossCrate<T> {\n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {\n+impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n     #[inline]\n-    fn default_encode<E: rustc_serialize::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        if E::CLEAR_CROSS_CRATE {\n+            return Ok(());\n+        }\n+\n         match *self {\n             ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(e),\n             ClearCrossCrate::Set(ref val) => {\n@@ -477,12 +482,13 @@ impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<\n         }\n     }\n }\n-impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {\n+impl<'tcx, D: TyDecoder<'tcx>, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n     #[inline]\n-    fn default_decode<D>(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error>\n-    where\n-        D: rustc_serialize::Decoder,\n-    {\n+    fn decode(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error> {\n+        if D::CLEAR_CROSS_CRATE {\n+            return Ok(ClearCrossCrate::Clear);\n+        }\n+\n         let discr = u8::decode(d)?;\n \n         match discr {\n@@ -491,7 +497,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n                 let val = T::decode(d)?;\n                 Ok(ClearCrossCrate::Set(val))\n             }\n-            _ => unreachable!(),\n+            tag => Err(d.error(&format!(\"Invalid tag for ClearCrossCrate: {:?}\", tag))),\n         }\n     }\n }\n@@ -501,7 +507,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Most passes can work with it as a whole, within a single function.\n // The unofficial Cranelift backend, at least as of #65828, needs `SourceInfo` to implement `Eq` and\n // `Hash`. Please ping @bjorn3 if removing them.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n     /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -521,7 +527,7 @@ impl SourceInfo {\n ///////////////////////////////////////////////////////////////////////////\n // Borrow kinds\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -632,7 +638,7 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n@@ -654,7 +660,7 @@ pub struct VarBindingForm<'tcx> {\n     pub pat_span: Span,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable)]\n pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n     Var(VarBindingForm<'tcx>),\n@@ -665,7 +671,7 @@ pub enum BindingForm<'tcx> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -708,7 +714,7 @@ mod binding_form_impl {\n /// involved in borrow_check errors, e.g., explanations of where the\n /// temporaries come from, when their destructors are run, and/or how\n /// one might revise the code to satisfy the borrow checker's rules.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct BlockTailInfo {\n     /// If `true`, then the value resulting from evaluating this tail\n     /// expression is ignored by the block's expression context.\n@@ -725,7 +731,7 @@ pub struct BlockTailInfo {\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n /// argument, or the return place.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct LocalDecl<'tcx> {\n     /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n     ///\n@@ -857,10 +863,13 @@ pub struct LocalDecl<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(LocalDecl<'_>, 56);\n \n-/// Extra information about a some locals that's used for diagnostics. (Not\n-/// used for non-StaticRef temporaries, the return place, or anonymous function\n-/// parameters.)\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+/// Extra information about a some locals that's used for diagnostics and for\n+/// classifying variables into local variables, statics, etc, which is needed e.g.\n+/// for unsafety checking.\n+///\n+/// Not used for non-StaticRef temporaries, the return place, or anonymous\n+/// function parameters.\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum LocalInfo<'tcx> {\n     /// A user-defined local variable or function parameter\n     ///\n@@ -1003,7 +1012,7 @@ impl<'tcx> LocalDecl<'tcx> {\n }\n \n /// Debug information pertaining to a user variable.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct VarDebugInfo<'tcx> {\n     pub name: Symbol,\n \n@@ -1038,7 +1047,7 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct BasicBlockData<'tcx> {\n     /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n@@ -1061,7 +1070,7 @@ pub struct BasicBlockData<'tcx> {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),\n@@ -1072,7 +1081,7 @@ pub enum AssertKind<O> {\n     ResumedAfterPanic(GeneratorKind),\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum InlineAsmOperand<'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -1317,7 +1326,7 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct Statement<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n@@ -1343,7 +1352,7 @@ impl Statement<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n@@ -1396,7 +1405,7 @@ pub enum StatementKind<'tcx> {\n }\n \n /// Describes what kind of retag is to be performed.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n     /// The initial retag when entering a function.\n     FnEntry,\n@@ -1409,7 +1418,7 @@ pub enum RetagKind {\n }\n \n /// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, HashStable, PartialEq)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n     /// code.\n@@ -1451,7 +1460,7 @@ pub enum FakeReadCause {\n     ForIndex,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct LlvmInlineAsm<'tcx> {\n     pub asm: hir::LlvmInlineAsmInner,\n     pub outputs: Box<[Place<'tcx>]>,\n@@ -1496,18 +1505,16 @@ impl Debug for Statement<'_> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -1732,7 +1739,7 @@ rustc_index::newtype_index! {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct SourceScopeData {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n@@ -1742,7 +1749,7 @@ pub struct SourceScopeData {\n     pub local_data: ClearCrossCrate<SourceScopeLocalData>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n     /// An `HirId` with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n@@ -1755,7 +1762,7 @@ pub struct SourceScopeLocalData {\n \n /// These are values that can appear inside an rvalue. They are intentionally\n /// limited to prevent rvalues from being nested in one another.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n@@ -1889,7 +1896,7 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -1935,13 +1942,13 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n     Pointer(PointerCast),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),\n@@ -1958,7 +1965,7 @@ pub enum AggregateKind<'tcx> {\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,\n@@ -2006,15 +2013,15 @@ impl BinOp {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum NullOp {\n     /// Returns the size of a value of that type\n     SizeOf,\n     /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n@@ -2184,7 +2191,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2245,7 +2252,7 @@ impl Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct UserTypeProjections {\n     pub contents: Vec<(UserTypeProjection, Span)>,\n }\n@@ -2322,7 +2329,7 @@ impl<'tcx> UserTypeProjections {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,"}, {"sha": "5081295ab3f741de677d234d0f6a16d9673bd20f", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -242,7 +242,7 @@ pub struct CodegenUnit<'tcx> {\n /// Specifies the linkage type for a `MonoItem`.\n ///\n /// See https://llvm.org/docs/LangRef.html#linkage-types for more details about these variants.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,"}, {"sha": "b16a1d53fff1cdb2ea5e4f29bcad58e1d9becc1f", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -54,16 +54,16 @@ impl PredecessorCache {\n     }\n }\n \n-impl serialize::Encodable for PredecessorCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n-    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         serialize::Encodable::encode(&(), s)\n     }\n }\n \n-impl serialize::Decodable for PredecessorCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for PredecessorCache {\n     #[inline]\n-    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n     }\n }"}, {"sha": "0878e9313d8c5d6153a836330fc00fb85eb29de2", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,7 +16,7 @@ use std::fmt::{self, Debug};\n \n use super::{Field, SourceInfo};\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     /// Only permitted in regular `fn`s, prohibited in `const fn`s.\n     General,\n@@ -35,7 +35,7 @@ pub enum UnsafetyViolationKind {\n     UnsafeFnBorrowPacked,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnsafetyViolationDetails {\n     CallToUnsafeFunction,\n     UseOfInlineAssembly,\n@@ -120,15 +120,15 @@ impl UnsafetyViolationDetails {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub lint_root: hir::HirId,\n     pub kind: UnsafetyViolationKind,\n     pub details: UnsafetyViolationDetails,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n@@ -145,7 +145,7 @@ rustc_index::newtype_index! {\n }\n \n /// The layout of generator state.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n     pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n@@ -220,7 +220,7 @@ impl Debug for GeneratorLayout<'_> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n@@ -235,7 +235,7 @@ pub struct BorrowCheckResult<'tcx> {\n /// Each field corresponds to an implementer of the `Qualif` trait in\n /// `librustc_mir/transform/check_consts/qualifs.rs`. See that file for more information on each\n /// `Qualif`.\n-#[derive(Clone, Copy, Debug, Default, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, Default, TyEncodable, TyDecodable, HashStable)]\n pub struct ConstQualifs {\n     pub has_mut_interior: bool,\n     pub needs_drop: bool,\n@@ -291,7 +291,7 @@ pub struct ConstQualifs {\n /// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n /// cannot use `ReVar` (which is what we use internally within the rest of the\n /// NLL code).\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n@@ -307,7 +307,7 @@ pub struct ClosureRegionRequirements<'tcx> {\n \n /// Indicates an outlives-constraint between a type or between two\n /// free regions declared on the closure.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n     pub subject: ClosureOutlivesSubject<'tcx>,\n@@ -328,7 +328,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n ///\n /// See also `rustc_mir::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ConstraintCategory {\n     Return(ReturnConstraint),\n     Yield,\n@@ -365,15 +365,15 @@ pub enum ConstraintCategory {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(hir::HirId),\n }\n \n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being\n@@ -398,7 +398,7 @@ pub struct DestructuredConst<'tcx> {\n /// Coverage information summarized from a MIR if instrumented for source code coverage (see\n /// compiler option `-Zinstrument-coverage`). This information is generated by the\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct CoverageInfo {\n     /// The total number of coverage region counters added to the MIR `Body`.\n     pub num_counters: u32,"}, {"sha": "0ab783812241e343afe204964f0f614cb131efb2", "filename": "src/librustc_middle/mir/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,7 +16,7 @@ use std::slice;\n \n pub use super::query::*;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n     /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n@@ -194,7 +194,7 @@ pub enum TerminatorKind<'tcx> {\n         destination: Option<BasicBlock>,\n     },\n }\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,"}, {"sha": "ea9c8b7a415840b15e2adfedca48baea42093e5b", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -426,7 +426,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `ImplSourceUserDefinedData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n@@ -557,14 +557,14 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -573,7 +573,7 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -582,18 +582,18 @@ pub struct ImplSourceClosureData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(PartialEq, Eq, Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -606,17 +606,17 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "969404c68cab7084513835d141ce4e4c9a5231ab", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -23,7 +23,7 @@ use rustc_span::symbol::Ident;\n ///   parents of a given specializing impl, which is needed for extracting\n ///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct Graph {\n     /// All impls have a parent; the \"root\" impls have as their parent the `def_id`\n     /// of the trait.\n@@ -50,7 +50,7 @@ impl Graph {\n \n /// Children of a given impl, grouped into blanket/non-blanket varieties as is\n /// done in `TraitDef`.\n-#[derive(Default, RustcEncodable, RustcDecodable)]\n+#[derive(Default, TyEncodable, TyDecodable)]\n pub struct Children {\n     // Impls of a trait (or specializations of a given impl). To allow for\n     // quicker lookup, the impls are indexed by a simplified version of their"}, {"sha": "0ab07aea426c3c95d217133c567d291e0c0f8cc0", "filename": "src/librustc_middle/ty/adjustment.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fadjustment.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{DerefMutTraitLangItem, DerefTraitLangItem};\n use rustc_macros::HashStable;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum PointerCast {\n     /// Go from a fn-item type to a fn-pointer type.\n     ReifyFnPointer,\n@@ -76,7 +76,7 @@ pub enum PointerCast {\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n ///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n@@ -91,7 +91,7 @@ impl Adjustment<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -109,7 +109,7 @@ pub enum Adjust<'tcx> {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -143,13 +143,13 @@ impl<'tcx> OverloadedDeref<'tcx> {\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n /// capable mutable borrows.\n /// See #49434 for tracking.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum AllowTwoPhase {\n     Yes,\n     No,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n     Mut { allow_two_phase_borrow: AllowTwoPhase },\n     Not,\n@@ -164,7 +164,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n@@ -179,7 +179,7 @@ pub enum AutoBorrow<'tcx> {\n /// This struct can be obtained via the `coerce_impl_info` query.\n /// Demanding this struct also has the side-effect of reporting errors\n /// for inappropriate impls.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct CoerceUnsizedInfo {\n     /// If this is a \"custom coerce\" impl, then what kind of custom\n     /// coercion is it? This applies to impls of `CoerceUnsized` for\n@@ -188,7 +188,7 @@ pub struct CoerceUnsizedInfo {\n     pub custom_kind: Option<CustomCoerceUnsized>,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize),"}, {"sha": "3237147c8ba2f589f8d4478875b88c03d2d975af", "filename": "src/librustc_middle/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fbinding.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::BindingAnnotation;\n use rustc_hir::BindingAnnotation::*;\n use rustc_hir::Mutability;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Debug, Copy, HashStable)]\n pub enum BindingMode {\n     BindByReference(Mutability),\n     BindByValue(Mutability),"}, {"sha": "3a3caa55f60776f6a8a5b0bb52ac19cbc4960b0c", "filename": "src/librustc_middle/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcast.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -31,7 +31,7 @@ pub enum CastTy<'tcx> {\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum CastKind {\n     CoercionCast,\n     PtrPtrCast,"}, {"sha": "291648869fb69ed9d064aba56c9ffc84ccd62dc2", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 217, "deletions": 318, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -8,12 +8,15 @@\n \n use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n-use crate::mir::{self, interpret::Allocation};\n+use crate::mir::{\n+    self,\n+    interpret::{AllocId, Allocation},\n+};\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n use std::convert::{TryFrom, TryInto};\n use std::hash::Hash;\n@@ -25,46 +28,75 @@ use std::marker::DiscriminantKind;\n /// This offset is also chosen so that the first byte is never < 0x80.\n pub const SHORTHAND_OFFSET: usize = 0x80;\n \n-pub trait EncodableWithShorthand: Clone + Eq + Hash {\n-    type Variant: Encodable;\n+pub trait EncodableWithShorthand<'tcx, E: TyEncoder<'tcx>>: Copy + Eq + Hash {\n+    type Variant: Encodable<E>;\n     fn variant(&self) -> &Self::Variant;\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         &self.kind\n     }\n }\n \n-impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate<'tcx> {\n     type Variant = ty::PredicateKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         self.kind()\n     }\n }\n \n-pub trait TyEncoder: Encoder {\n-    fn position(&self) -> usize;\n+pub trait OpaqueEncoder: Encoder {\n+    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder;\n+    fn encoder_position(&self) -> usize;\n }\n \n-impl TyEncoder for opaque::Encoder {\n+impl OpaqueEncoder for rustc_serialize::opaque::Encoder {\n+    #[inline]\n+    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder {\n+        self\n+    }\n     #[inline]\n-    fn position(&self) -> usize {\n+    fn encoder_position(&self) -> usize {\n         self.position()\n     }\n }\n \n+pub trait TyEncoder<'tcx>: Encoder {\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n+    fn position(&self) -> usize;\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize>;\n+    fn encode_alloc_id(&mut self, alloc_id: &AllocId) -> Result<(), Self::Error>;\n+}\n+\n+/// Trait for decoding to a reference.\n+///\n+/// This is a separate trait from `Decodable` so that we can implement it for\n+/// upstream types, such as `FxHashSet`.\n+///\n+/// The `TyDecodable` derive macro will use this trait for fields that are\n+/// references (and don't use a type alias to hide that).\n+///\n+/// `Decodable` can still be implemented in cases where `Decodable` is required\n+/// by a trait bound.\n+pub trait RefDecodable<'tcx, D: TyDecoder<'tcx>> {\n+    fn decode(d: &mut D) -> Result<&'tcx Self, D::Error>;\n+}\n+\n /// Encode the given value or a previously cached shorthand.\n pub fn encode_with_shorthand<E, T, M>(encoder: &mut E, value: &T, cache: M) -> Result<(), E::Error>\n where\n-    E: TyEncoder,\n+    E: TyEncoder<'tcx>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n-    T: EncodableWithShorthand,\n+    T: EncodableWithShorthand<'tcx, E>,\n     <T::Variant as DiscriminantKind>::Discriminant: Ord + TryFrom<usize>,\n {\n-    let existing_shorthand = cache(encoder).get(value).cloned();\n+    let existing_shorthand = cache(encoder).get(value).copied();\n     if let Some(shorthand) = existing_shorthand {\n         return encoder.emit_usize(shorthand);\n     }\n@@ -89,13 +121,51 @@ where\n     // Check that the shorthand is a not longer than the\n     // full encoding itself, i.e., it's an obvious win.\n     if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n-        cache(encoder).insert(value.clone(), shorthand);\n+        cache(encoder).insert(*value, shorthand);\n     }\n \n     Ok(())\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n+    }\n+}\n+\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        encode_with_shorthand(e, self, TyEncoder::predicate_shorthands)\n+    }\n+}\n+\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.encode_alloc_id(self)\n+    }\n+}\n+\n+macro_rules! encodable_via_deref {\n+    ($($t:ty),+) => {\n+        $(impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for $t {\n+            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                (**self).encode(e)\n+            }\n+        })*\n+    }\n+}\n+\n+encodable_via_deref! {\n+    &'tcx ty::TypeckResults<'tcx>,\n+    ty::Region<'tcx>,\n+    &'tcx mir::Body<'tcx>,\n+    &'tcx mir::UnsafetyCheckResult,\n+    &'tcx mir::BorrowCheckResult<'tcx>\n+}\n+\n pub trait TyDecoder<'tcx>: Decoder {\n+    const CLEAR_CROSS_CRATE: bool;\n+\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn peek_byte(&self) -> u8;\n@@ -127,10 +197,12 @@ pub trait TyDecoder<'tcx>: Decoder {\n     fn positioned_at_shorthand(&self) -> bool {\n         (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n     }\n+\n+    fn decode_alloc_id(&mut self) -> Result<AllocId, Self::Error>;\n }\n \n #[inline]\n-pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n+pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -140,172 +212,157 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n+pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable>::decode(decoder)?))\n+    Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder)?))\n }\n \n-#[inline]\n-pub fn decode_cnum<D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n-    Ok(decoder.map_encoded_cnum_to_current(cnum))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n+    #[allow(rustc::usage_of_ty_tykind)]\n+    fn decode(decoder: &mut D) -> Result<Ty<'tcx>, D::Error> {\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        if decoder.positioned_at_shorthand() {\n+            let pos = decoder.read_usize()?;\n+            assert!(pos >= SHORTHAND_OFFSET);\n+            let shorthand = pos - SHORTHAND_OFFSET;\n+\n+            decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n+                decoder.with_position(shorthand, Ty::decode)\n+            })\n+        } else {\n+            let tcx = decoder.tcx();\n+            Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n+        }\n+    }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-#[inline]\n-pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    // Handle shorthands first, if we have an usize > 0x80.\n-    if decoder.positioned_at_shorthand() {\n-        let pos = decoder.read_usize()?;\n-        assert!(pos >= SHORTHAND_OFFSET);\n-        let shorthand = pos - SHORTHAND_OFFSET;\n-\n-        decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n-            decoder.with_position(shorthand, Ty::decode)\n-        })\n-    } else {\n-        let tcx = decoder.tcx();\n-        Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error> {\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        let predicate_kind = if decoder.positioned_at_shorthand() {\n+            let pos = decoder.read_usize()?;\n+            assert!(pos >= SHORTHAND_OFFSET);\n+            let shorthand = pos - SHORTHAND_OFFSET;\n+\n+            decoder.with_position(shorthand, ty::PredicateKind::decode)\n+        } else {\n+            ty::PredicateKind::decode(decoder)\n+        }?;\n+        let predicate = decoder.tcx().mk_predicate(predicate_kind);\n+        Ok(predicate)\n     }\n }\n \n-#[inline]\n-pub fn decode_predicate<D>(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    // Handle shorthands first, if we have an usize > 0x80.\n-    if decoder.positioned_at_shorthand() {\n-        let pos = decoder.read_usize()?;\n-        assert!(pos >= SHORTHAND_OFFSET);\n-        let shorthand = pos - SHORTHAND_OFFSET;\n-\n-        decoder.cached_predicate_for_shorthand(shorthand, |decoder| {\n-            decoder.with_position(shorthand, ty::Predicate::decode)\n-        })\n-    } else {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for SubstsRef<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let len = decoder.read_usize()?;\n         let tcx = decoder.tcx();\n-        Ok(tcx.mk_predicate(ty::PredicateKind::decode(decoder)?))\n+        Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n     }\n }\n \n-#[inline]\n-pub fn decode_spanned_predicates<D>(\n-    decoder: &mut D,\n-) -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let tcx = decoder.tcx();\n-    Ok(tcx.arena.alloc_from_iter(\n-        (0..decoder.read_usize()?)\n-            .map(|_| Decodable::decode(decoder))\n-            .collect::<Result<Vec<_>, _>>()?,\n-    ))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for mir::Place<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let local: mir::Local = Decodable::decode(decoder)?;\n+        let len = decoder.read_usize()?;\n+        let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n+            decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n+        Ok(mir::Place { local, projection })\n+    }\n }\n \n-#[inline]\n-pub fn decode_substs<D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    let tcx = decoder.tcx();\n-    Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Region<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let local: mir::Local = Decodable::decode(decoder)?;\n-    let len = decoder.read_usize()?;\n-    let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n-        decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n-    Ok(mir::Place { local, projection })\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for CanonicalVarInfos<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        let interned: Result<Vec<CanonicalVarInfo>, _> =\n+            (0..len).map(|_| Decodable::decode(decoder)).collect();\n+        Ok(decoder.tcx().intern_canonical_var_infos(interned?.as_slice()))\n+    }\n }\n \n-#[inline]\n-pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AllocId {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        decoder.decode_alloc_id()\n+    }\n }\n \n-#[inline]\n-pub fn decode_ty_slice<D>(decoder: &mut D) -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::SymbolName<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        Ok(ty::SymbolName::new(decoder.tcx(), &decoder.read_str()?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_adt_def<D>(decoder: &mut D) -> Result<&'tcx ty::AdtDef, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let def_id = DefId::decode(decoder)?;\n-    Ok(decoder.tcx().adt_def(def_id))\n+macro_rules! impl_decodable_via_ref {\n+    ($($t:ty),+) => {\n+        $(impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for $t {\n+            fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+                RefDecodable::decode(decoder)\n+            }\n+        })*\n+    }\n }\n \n-#[inline]\n-pub fn decode_symbol_name<D>(decoder: &mut D) -> Result<ty::SymbolName<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(ty::SymbolName::new(decoder.tcx(), &decoder.read_str()?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::AdtDef {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let def_id = <DefId as Decodable<D>>::decode(decoder)?;\n+        Ok(decoder.tcx().adt_def(def_id))\n+    }\n }\n \n-#[inline]\n-pub fn decode_existential_predicate_slice<D>(\n-    decoder: &mut D,\n-) -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    Ok(decoder.tcx().mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n }\n \n-#[inline]\n-pub fn decode_canonical_var_infos<D>(decoder: &mut D) -> Result<CanonicalVarInfos<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    let interned: Result<Vec<CanonicalVarInfo>, _> =\n-        (0..len).map(|_| Decodable::decode(decoder)).collect();\n-    Ok(decoder.tcx().intern_canonical_var_infos(interned?.as_slice()))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::ExistentialPredicate<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n }\n \n-#[inline]\n-pub fn decode_const<D>(decoder: &mut D) -> Result<&'tcx ty::Const<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::Const<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_allocation<D>(decoder: &mut D) -> Result<&'tcx Allocation, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for Allocation {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+    }\n+}\n+\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n+impl_decodable_via_ref! {\n+    &'tcx ty::TypeckResults<'tcx>,\n+    &'tcx ty::List<Ty<'tcx>>,\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx Allocation,\n+    &'tcx mir::Body<'tcx>,\n+    &'tcx mir::UnsafetyCheckResult,\n+    &'tcx mir::BorrowCheckResult<'tcx>\n }\n \n #[macro_export]\n@@ -320,42 +377,21 @@ macro_rules! __impl_decoder_methods {\n     }\n }\n \n-#[macro_export]\n macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n-     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty, $gen_ty:ty], $tcx:lifetime]) => {\n-         // FIXME(#36588): These impls are horribly unsound as they allow\n-         // the caller to pick any lifetime for `'tcx`, including `'static`.\n-        #[allow(unused_lifetimes)]\n-        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a $gen_ty>\n-        for $DecoderName<$($typaram),*>\n-        where &'_a $gen_ty: UseSpecializedDecodable\n-        {\n+     [[$name:ident: $ty:ty], $tcx:lifetime]) => {\n+        impl<$tcx, D: TyDecoder<$tcx>> RefDecodable<$tcx, D> for $ty {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&'_a $gen_ty, Self::Error> {\n-                unsafe {\n-                    std::mem::transmute::<\n-                        Result<&$tcx $ty, Self::Error>,\n-                        Result<&'_a $gen_ty, Self::Error>,\n-                    >(decode_arena_allocable(self))\n-                }\n+            fn decode(decoder: &mut D) -> Result<&$tcx Self, D::Error> {\n+                decode_arena_allocable(decoder)\n             }\n         }\n \n-        #[allow(unused_lifetimes)]\n-        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a [$gen_ty]>\n-        for $DecoderName<$($typaram),*>\n-        where &'_a [$gen_ty]: UseSpecializedDecodable\n-        {\n+        impl<$tcx, D: TyDecoder<$tcx>> RefDecodable<$tcx, D> for [$ty] {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&'_a [$gen_ty], Self::Error> {\n-                unsafe {\n-                    std::mem::transmute::<\n-                        Result<&$tcx [$ty], Self::Error>,\n-                        Result<&'_a [$gen_ty], Self::Error>,\n-                    >(decode_arena_allocable_slice(self))\n-                }\n+            fn decode(decoder: &mut D) -> Result<&$tcx Self, D::Error> {\n+                decode_arena_allocable_slice(decoder)\n             }\n         }\n     };\n@@ -364,38 +400,30 @@ macro_rules! impl_arena_allocatable_decoder {\n     };\n }\n \n-#[macro_export]\n macro_rules! impl_arena_allocatable_decoders {\n-    ($args:tt, [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         $(\n-            impl_arena_allocatable_decoder!($a [$args, [$name: $ty, $gen_ty], $tcx]);\n+            impl_arena_allocatable_decoder!($a [[$name: $ty], $tcx]);\n         )*\n     }\n }\n \n+rustc_hir::arena_types!(impl_arena_allocatable_decoders, [], 'tcx);\n+arena_types!(impl_arena_allocatable_decoders, [], 'tcx);\n+\n #[macro_export]\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n             use std::borrow::Cow;\n-            use std::mem::transmute;\n-\n-            use rustc_serialize::{Decoder, SpecializedDecoder, UseSpecializedDecodable};\n-\n-            use $crate::infer::canonical::CanonicalVarInfos;\n-            use $crate::ty;\n-            use $crate::ty::codec::*;\n-            use $crate::ty::subst::InternalSubsts;\n-            use rustc_hir::def_id::CrateNum;\n-\n-            use rustc_span::Span;\n+            use rustc_serialize::Decoder;\n \n             use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 type Error = String;\n \n-                __impl_decoder_methods! {\n+                $crate::__impl_decoder_methods! {\n                     read_nil -> ();\n \n                     read_u128 -> u128;\n@@ -423,135 +451,6 @@ macro_rules! implement_ty_decoder {\n                     self.opaque.error(err)\n                 }\n             }\n-\n-            // FIXME(#36588): These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for `'tcx`, including `'static`.\n-\n-            arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n-\n-            impl<$($typaram),*> SpecializedDecoder<CrateNum>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n-                    decode_cnum(self)\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::TyS<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n-            {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n-                    unsafe {\n-                        transmute::<\n-                            Result<ty::Ty<'tcx>, Self::Error>,\n-                            Result<&'_x ty::TyS<'_y>, Self::Error>,\n-                        >(decode_ty(self))\n-                    }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Predicate<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Predicate<'_x>, Self::Error> {\n-                    unsafe {\n-                        transmute::<\n-                            Result<ty::Predicate<'tcx>, Self::Error>,\n-                            Result<ty::Predicate<'_x>, Self::Error>,\n-                        >(decode_predicate(self))\n-                    }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x [(ty::Predicate<'_y>, Span)]>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x [(ty::Predicate<'_y>, Span)]: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                                      -> Result<&'_x [(ty::Predicate<'_y>, Span)], Self::Error>\n-                {\n-                    unsafe { transmute(decode_spanned_predicates(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x InternalSubsts<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x InternalSubsts<'_y>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self) -> Result<&'_x InternalSubsts<'_y>, Self::Error> {\n-                    unsafe { transmute(decode_substs(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<$crate::mir::Place<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(\n-                    &mut self\n-                ) -> Result<$crate::mir::Place<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_place(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Region<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Region<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_region(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, '_z, $($typaram),*> SpecializedDecoder<&'_x ty::List<&'_y ty::TyS<'_z>>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::List<&'_y ty::TyS<'_z>>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                                      -> Result<&'_x ty::List<&'_y ty::TyS<'_z>>, Self::Error> {\n-                    unsafe { transmute(decode_ty_slice(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x ty::AdtDef>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::AdtDef, Self::Error> {\n-                    unsafe { transmute(decode_adt_def(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::SymbolName<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::SymbolName<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_symbol_name(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::List<ty::ExistentialPredicate<'_y>>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::List<ty::ExistentialPredicate<'_y>>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                    -> Result<&'_x ty::List<ty::ExistentialPredicate<'_y>>, Self::Error> {\n-                        unsafe { transmute(decode_existential_predicate_slice(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<CanonicalVarInfos<'_x>>\n-                for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self)\n-                    -> Result<CanonicalVarInfos<'_x>, Self::Error> {\n-                        unsafe { transmute(decode_canonical_var_infos(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x $crate::ty::Const<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x $crate::ty::Const<'_y>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::Const<'_y>, Self::Error> {\n-                    unsafe { transmute(decode_const(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x $crate::mir::interpret::Allocation>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(\n-                    &mut self\n-                ) -> Result<&'_x $crate::mir::interpret::Allocation, Self::Error> {\n-                    unsafe { transmute(decode_allocation(self)) }\n-                }\n-            }\n         }\n-    };\n+    }\n }"}, {"sha": "e883c7c6dcd2264de133ae179b31b93356fcb73a", "filename": "src/librustc_middle/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -15,7 +15,7 @@ pub use int::*;\n pub use kind::*;\n \n /// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,"}, {"sha": "a4c177160f5d039b6b6baefb380e6cf2878e998a", "filename": "src/librustc_middle/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,7 +10,7 @@ use rustc_macros::HashStable;\n use rustc_target::abi::Size;\n \n /// Represents a constant in Rust.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum ConstKind<'tcx> {\n     /// A const generic parameter.\n@@ -68,7 +68,7 @@ impl<'tcx> ConstKind<'tcx> {\n }\n \n /// An inference variable for a const, for use in const generics.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum InferConst<'tcx> {\n     /// Infer the value of the const."}, {"sha": "ba1f78e337a8311be74df8039b05996b6a3ba6f9", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -263,7 +263,7 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n }\n \n /// All information necessary to validate and reveal an `impl Trait`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct ResolvedOpaqueTy<'tcx> {\n     /// The revealed type as seen by this function.\n     pub concrete_type: Ty<'tcx>,\n@@ -291,7 +291,7 @@ pub struct ResolvedOpaqueTy<'tcx> {\n ///\n /// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n /// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Type of the captured binding.\n     pub ty: Ty<'tcx>,\n@@ -305,7 +305,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n     pub expr: Option<hir::HirId>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(TyEncodable, TyDecodable, Debug)]\n pub struct TypeckResults<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n     pub hir_owner: LocalDefId,\n@@ -728,7 +728,7 @@ rustc_index::newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -787,7 +787,7 @@ impl CanonicalUserType<'tcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n@@ -1333,7 +1333,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn serialize_query_result_cache<E>(self, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: ty::codec::TyEncoder,\n+        E: ty::codec::OpaqueEncoder,\n     {\n         self.queries.on_disk_cache.serialize(self, encoder)\n     }"}, {"sha": "7456020ee9b679ff414c7c93c830672e4efcea83", "filename": "src/librustc_middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -17,7 +17,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n /// keys (in which case we use a DefPathHash as id-type) but in the general case\n /// the non-stable but fast to construct DefId-version is the better choice.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, TyEncodable, TyDecodable)]\n pub enum SimplifiedTypeGen<D>\n where\n     D: Copy + Debug + Ord + Eq,"}, {"sha": "27f50c240db67e61233673ff82d45584b0cbe9e3", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -85,8 +85,6 @@ impl FlagComputation {\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -109,8 +107,6 @@ impl FlagComputation {\n             }\n \n             &ty::Closure(_, substs) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 let substs = substs.as_closure();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -196,8 +192,6 @@ impl FlagComputation {\n             }\n \n             &ty::FnDef(_, substs) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 self.add_substs(substs);\n             }\n "}, {"sha": "492f8ce9ef1a9d1afd832535d5a91b7a7edf1b35", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -150,12 +150,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n     }\n \n-    /// Does this value contain closures, generators or functions such that it may require\n-    /// polymorphization?\n-    fn may_polymorphize(&self) -> bool {\n-        self.has_type_flags(TypeFlags::MAY_POLYMORPHIZE)\n-    }\n-\n     /// A visitor that does not recurse into types, works like `fn walk_shallow` in `Ty`.\n     fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> bool) -> bool {\n         pub struct Visitor<F>(F);"}, {"sha": "e6dafd4965bc9fb321568a1af6d9be3e738a7927", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -15,14 +15,14 @@ use std::fmt;\n /// Monomorphization happens on-the-fly and no monomorphized MIR is ever created. Instead, this type\n /// simply couples a potentially generic `InstanceDef` with some substs, and codegen and const eval\n /// will do all required substitution as they run.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///\n@@ -492,6 +492,20 @@ fn polymorphize<'tcx>(\n     let unused = tcx.unused_generic_params(def_id);\n     debug!(\"polymorphize: unused={:?}\", unused);\n \n+    // If this is a closure or generator then we need to handle the case where another closure\n+    // from the function is captured as an upvar and hasn't been polymorphized. In this case,\n+    // the unpolymorphized upvar closure would result in a polymorphized closure producing\n+    // multiple mono items (and eventually symbol clashes).\n+    let upvars_ty = if tcx.is_closure(def_id) {\n+        Some(substs.as_closure().tupled_upvars_ty())\n+    } else if tcx.type_of(def_id).is_generator() {\n+        Some(substs.as_generator().tupled_upvars_ty())\n+    } else {\n+        None\n+    };\n+    let has_upvars = upvars_ty.map(|ty| ty.tuple_fields().count() > 0).unwrap_or(false);\n+    debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n+\n     struct PolymorphizationFolder<'tcx> {\n         tcx: TyCtxt<'tcx>,\n     };\n@@ -512,14 +526,6 @@ fn polymorphize<'tcx>(\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n                     }\n                 }\n-                ty::FnDef(def_id, substs) => {\n-                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n-                    if substs == polymorphized_substs {\n-                        ty\n-                    } else {\n-                        self.tcx.mk_fn_def(def_id, polymorphized_substs)\n-                    }\n-                }\n                 ty::Generator(def_id, substs, movability) => {\n                     let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n                     if substs == polymorphized_substs {\n@@ -537,24 +543,31 @@ fn polymorphize<'tcx>(\n         let is_unused = unused.contains(param.index).unwrap_or(false);\n         debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n         match param.kind {\n-            // If parameter is a const or type parameter..\n+            // Upvar case: If parameter is a type parameter..\n+            ty::GenericParamDefKind::Type { .. } if\n+                // ..and has upvars..\n+                has_upvars &&\n+                // ..and this param has the same type as the tupled upvars..\n+                upvars_ty == Some(substs[param.index as usize].expect_ty()) => {\n+                    // ..then double-check that polymorphization marked it used..\n+                    debug_assert!(!is_unused);\n+                    // ..and polymorphize any closures/generators captured as upvars.\n+                    let upvars_ty = upvars_ty.unwrap();\n+                    let polymorphized_upvars_ty = upvars_ty.fold_with(\n+                        &mut PolymorphizationFolder { tcx });\n+                    debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n+                    ty::GenericArg::from(polymorphized_upvars_ty)\n+                },\n+\n+            // Simple case: If parameter is a const or type parameter..\n             ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n                 // ..and is within range and unused..\n                 unused.contains(param.index).unwrap_or(false) =>\n                     // ..then use the identity for this parameter.\n                     tcx.mk_param_from_def(param),\n \n-            // If the parameter does not contain any closures or generators, then use the\n-            // substitution directly.\n-            _ if !substs.may_polymorphize() => substs[param.index as usize],\n-\n-            // Otherwise, use the substitution after polymorphizing.\n-            _ => {\n-                let arg = substs[param.index as usize];\n-                let polymorphized_arg = arg.fold_with(&mut PolymorphizationFolder { tcx });\n-                debug!(\"polymorphize: arg={:?} polymorphized_arg={:?}\", arg, polymorphized_arg);\n-                ty::GenericArg::from(polymorphized_arg)\n-            }\n+            // Otherwise, use the parameter as before.\n+            _ => substs[param.index as usize],\n         }\n     })\n }"}, {"sha": "16e65d2cca4cbcfed06447c84d90c7dcc04053d0", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -165,7 +165,7 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n     SizeOverflow(Ty<'tcx>),\n@@ -876,6 +876,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     .iter_enumerated()\n                     .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n \n+                let mut niche_filling_layout = None;\n+\n                 // Niche-filling enum optimization.\n                 if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n                     let mut dataful_variant = None;\n@@ -972,7 +974,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             let largest_niche =\n                                 Niche::from_scalar(dl, offset, niche_scalar.clone());\n \n-                            return Ok(tcx.intern_layout(Layout {\n+                            niche_filling_layout = Some(Layout {\n                                 variants: Variants::Multiple {\n                                     tag: niche_scalar,\n                                     tag_encoding: TagEncoding::Niche {\n@@ -991,7 +993,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 largest_niche,\n                                 size,\n                                 align,\n-                            }));\n+                            });\n                         }\n                     }\n                 }\n@@ -1214,7 +1216,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n \n-                tcx.intern_layout(Layout {\n+                let tagged_layout = Layout {\n                     variants: Variants::Multiple {\n                         tag,\n                         tag_encoding: TagEncoding::Direct,\n@@ -1229,7 +1231,23 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi,\n                     align,\n                     size,\n-                })\n+                };\n+\n+                let best_layout = match (tagged_layout, niche_filling_layout) {\n+                    (tagged_layout, Some(niche_filling_layout)) => {\n+                        // Pick the smaller layout; otherwise,\n+                        // pick the layout with the larger niche; otherwise,\n+                        // pick tagged as it has simpler codegen.\n+                        cmp::min_by_key(tagged_layout, niche_filling_layout, |layout| {\n+                            let niche_size =\n+                                layout.largest_niche.as_ref().map_or(0, |n| n.available(dl));\n+                            (layout.size, cmp::Reverse(niche_size))\n+                        })\n+                    }\n+                    (tagged_layout, None) => tagged_layout,\n+                };\n+\n+                tcx.intern_layout(best_layout)\n             }\n \n             // Types with no meaningful known layout."}, {"sha": "fe390adf89f9fe70c32c94338f69807f3f7821e3", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -76,9 +76,16 @@ impl<T: fmt::Debug> fmt::Debug for List<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for List<T> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for List<T> {\n     #[inline]\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for &List<T> {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }"}, {"sha": "81e60a7fd3743371e6bec7e0912dffce8cf295f8", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -89,12 +89,11 @@ pub use self::query::queries;\n \n pub use self::consts::{Const, ConstInt, ConstKind, InferConst};\n \n+pub mod _match;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n-#[macro_use]\n pub mod codec;\n-pub mod _match;\n mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n@@ -171,7 +170,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -316,7 +315,7 @@ impl<'tcx> AssociatedItems<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -403,7 +402,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyDecodable, TyEncodable, HashStable)]\n pub enum Variance {\n     Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -575,10 +574,6 @@ bitflags! {\n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n         const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n-\n-        /// Does this value contain closures, generators or functions such that it may require\n-        /// polymorphization?\n-        const MAY_POLYMORPHIZE = 1 << 18;\n     }\n }\n \n@@ -656,27 +651,23 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n-\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -724,7 +715,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -735,7 +726,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -770,7 +761,7 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n@@ -791,7 +782,7 @@ impl GenericParamDefKind {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: Symbol,\n     pub def_id: DefId,\n@@ -835,7 +826,7 @@ pub struct GenericParamCount {\n ///\n /// The ordering of parameters is the same as in `Subst` (excluding child generics):\n /// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_count: usize,\n@@ -937,7 +928,7 @@ impl<'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Copy, Clone, Default, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n@@ -1029,9 +1020,6 @@ pub struct Predicate<'tcx> {\n     inner: &'tcx PredicateInner<'tcx>,\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for Predicate<'_> {}\n-impl rustc_serialize::UseSpecializedDecodable for Predicate<'_> {}\n-\n impl<'tcx> PartialEq for Predicate<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // `self.kind` is always interned.\n@@ -1107,15 +1095,15 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n     /// `for<'a>: ...`\n     ForAll(Binder<PredicateAtom<'tcx>>),\n     Atom(PredicateAtom<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateAtom<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n@@ -1265,7 +1253,7 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n@@ -1290,7 +1278,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n@@ -1299,7 +1287,7 @@ pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'t\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n@@ -1320,7 +1308,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n@@ -1589,7 +1577,7 @@ impl UniverseIndex {\n /// basically a name -- distinct bound regions within the same\n /// universe are just two regions with an unknown relationship to one\n /// another.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, PartialOrd, Ord)]\n pub struct Placeholder<T> {\n     pub universe: UniverseIndex,\n     pub name: T,\n@@ -1639,7 +1627,7 @@ pub type PlaceholderConst = Placeholder<BoundVar>;\n ///     a.foo::<7>();\n /// }\n /// ```\n-#[derive(Copy, Clone, Debug, TypeFoldable, Lift, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, Lift, TyEncodable, TyDecodable)]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[derive(Hash, HashStable)]\n pub struct WithOptConstParam<T> {\n@@ -2110,7 +2098,7 @@ impl<'tcx> VariantDef {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n@@ -2182,14 +2170,12 @@ impl Hash for AdtDef {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for &'tcx AdtDef {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for AdtDef {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n@@ -2233,7 +2219,7 @@ impl Into<DataTypeKind> for AdtKind {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, Default, HashStable)]\n+    #[derive(TyEncodable, TyDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {\n         const IS_C               = 1 << 0;\n         const IS_SIMD            = 1 << 1;\n@@ -2250,7 +2236,7 @@ bitflags! {\n }\n \n /// Represents the repr options provided by the user,\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default, HashStable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Default, HashStable)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: Option<Align>,\n@@ -2694,7 +2680,7 @@ impl<'tcx> FieldDef {\n ///\n /// You can get the environment type of a closure using\n /// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n@@ -3145,7 +3131,7 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]\n pub struct SymbolName<'tcx> {\n     /// `&str` gives a consistent ordering, which ensures reproducible builds.\n     pub name: &'tcx str,\n@@ -3170,12 +3156,3 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n-\n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for SymbolName<'tcx> {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.name)\n-    }\n-}\n-\n-// The decoding takes place in `decode_symbol_name()`.\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for SymbolName<'tcx> {}"}, {"sha": "87944db60de66d8e7b7ede44364d6756363e34bf", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1107,7 +1107,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n                 // this result to affect interpreter execution.\n-                let byte_str = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let byte_str = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 self.pretty_print_byte_str(byte_str)\n             }\n             (\n@@ -1117,7 +1117,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n-                let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n                 p!(write(\"{:?}\", s));\n                 Ok(self)"}, {"sha": "007b46b11769413aeb924d68f9404ca52c2b7c9e", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 162, "deletions": 201, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,28 +1,24 @@\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use crate::mir::interpret;\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n+use crate::mir::{self, interpret};\n+use crate::ty::codec::{OpaqueEncoder, RefDecodable, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder, FingerprintEncoder};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{\n-    opaque, Decodable, Decoder, Encodable, Encoder, SpecializedDecoder, SpecializedEncoder,\n-    UseSpecializedDecodable, UseSpecializedEncodable,\n-};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::hygiene::{\n     ExpnDataDecodeMode, ExpnDataEncodeMode, ExpnId, HygieneDecodeContext, HygieneEncodeContext,\n     SyntaxContext, SyntaxContextData,\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n-use rustc_span::symbol::Ident;\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n use std::mem;\n@@ -87,7 +83,7 @@ pub struct OnDiskCache<'sess> {\n }\n \n // This type is used only for serialization and deserialization.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n struct Footer {\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n@@ -105,10 +101,10 @@ type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n struct SourceFileIndex(u32);\n \n-#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, Encodable, Decodable)]\n struct AbsoluteBytePos(u32);\n \n impl AbsoluteBytePos {\n@@ -182,7 +178,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n     pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: TyEncoder,\n+        E: OpaqueEncoder,\n     {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n@@ -333,7 +329,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n             // Encode the position of the footer as the last 8 bytes of the\n             // file so we know where to look for it.\n-            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n+            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder.opaque())?;\n \n             // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n             // of the footer must be the last thing in the data stream.\n@@ -380,13 +376,13 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    pub fn try_load_query_result<T>(\n+    crate fn try_load_query_result<'tcx, T>(\n         &self,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Option<T>\n     where\n-        T: Decodable,\n+        T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         self.load_indexed(tcx, dep_node_index, &self.query_result_index, \"query result\")\n     }\n@@ -417,7 +413,7 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_tag: &'static str,\n     ) -> Option<T>\n     where\n-        T: Decodable,\n+        T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n@@ -427,14 +423,14 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    fn with_decoder<'tcx, T, F: FnOnce(&mut CacheDecoder<'sess, 'tcx>) -> T>(\n+    fn with_decoder<'a, 'tcx, T, F: FnOnce(&mut CacheDecoder<'sess, 'tcx>) -> T>(\n         &'sess self,\n         tcx: TyCtxt<'tcx>,\n         pos: AbsoluteBytePos,\n         f: F,\n     ) -> T\n     where\n-        T: Decodable,\n+        T: Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let cnum_map =\n             self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n@@ -492,7 +488,7 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read from the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and eventually\n /// will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a, 'tcx> {\n+crate struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n@@ -547,8 +543,8 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n-    T: Decodable + Eq + ::std::fmt::Debug,\n-    V: Decodable,\n+    T: Decodable<D> + Eq + ::std::fmt::Debug,\n+    V: Decodable<D>,\n     D: DecoderWithPosition,\n {\n     let start_pos = decoder.position();\n@@ -565,6 +561,8 @@ where\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = false;\n+\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -642,14 +640,19 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         self.cnum_map[cnum].unwrap_or_else(|| bug!(\"could not find new `CrateNum` for {:?}\", cnum))\n     }\n+\n+    fn decode_alloc_id(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+        let alloc_decoding_session = self.alloc_decoding_session;\n+        alloc_decoding_session.decode_alloc_id(self)\n+    }\n }\n \n-implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n+crate::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n-impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<SyntaxContext, Self::Error> {\n-        let syntax_contexts = self.syntax_contexts;\n-        rustc_span::hygiene::decode_syntax_context(self, self.hygiene_context, |this, id| {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let syntax_contexts = decoder.syntax_contexts;\n+        rustc_span::hygiene::decode_syntax_context(decoder, decoder.hygiene_context, |this, id| {\n             // This closure is invoked if we haven't already decoded the data for the `SyntaxContext` we are deserializing.\n             // We look up the position of the associated `SyntaxData` and decode it.\n             let pos = syntax_contexts.get(&id).unwrap();\n@@ -661,12 +664,12 @@ impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<ExpnId> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ExpnId, Self::Error> {\n-        let expn_data = self.expn_data;\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let expn_data = decoder.expn_data;\n         rustc_span::hygiene::decode_expn_id(\n-            self,\n-            ExpnDataDecodeMode::incr_comp(self.hygiene_context),\n+            decoder,\n+            ExpnDataDecodeMode::incr_comp(decoder.hygiene_context),\n             |this, index| {\n                 // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n                 // We look up the position of the associated `ExpnData` and decode it.\n@@ -683,85 +686,104 @@ impl<'a, 'tcx> SpecializedDecoder<ExpnId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let alloc_decoding_session = self.alloc_decoding_session;\n-        alloc_decoding_session.decode_alloc_id(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let tag: u8 = Decodable::decode(self)?;\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let tag: u8 = Decodable::decode(decoder)?;\n \n         if tag == TAG_INVALID_SPAN {\n             return Ok(DUMMY_SP);\n         } else {\n             debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        let file_lo_index = SourceFileIndex::decode(self)?;\n-        let line_lo = usize::decode(self)?;\n-        let col_lo = BytePos::decode(self)?;\n-        let len = BytePos::decode(self)?;\n-        let ctxt = SyntaxContext::decode(self)?;\n+        let file_lo_index = SourceFileIndex::decode(decoder)?;\n+        let line_lo = usize::decode(decoder)?;\n+        let col_lo = BytePos::decode(decoder)?;\n+        let len = BytePos::decode(decoder)?;\n+        let ctxt = SyntaxContext::decode(decoder)?;\n \n-        let file_lo = self.file_index_to_file(file_lo_index);\n+        let file_lo = decoder.file_index_to_file(file_lo_index);\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n         Ok(Span::new(lo, hi, ctxt))\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n-        // FIXME: Handle hygiene in incremental\n-        bug!(\"Trying to decode Ident for incremental\");\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let cnum = CrateNum::from_u32(u32::decode(d)?);\n+        Ok(d.map_encoded_cnum_to_current(cnum))\n     }\n }\n \n // This impl makes sure that we get a runtime error when we try decode a\n // `DefIndex` that is not contained in a `DefId`. Such a case would be problematic\n // because we would not know how to transform the `DefIndex` to the current\n // context.\n-impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        bug!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefIndex {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<DefIndex, String> {\n+        Err(d.error(\"trying to decode `DefIndex` outside the context of a `DefId`\"))\n     }\n }\n \n // Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n // compilation sessions. We use the `DefPathHash`, which is stable across\n // sessions, to map the old `DefId` to the new one.\n-impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         // Load the `DefPathHash` which is was we encoded the `DefId` as.\n-        let def_path_hash = DefPathHash::decode(self)?;\n+        let def_path_hash = DefPathHash::decode(d)?;\n \n         // Using the `DefPathHash`, we can lookup the new `DefId`.\n-        Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n+        Ok(d.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        Ok(DefId::decode(self)?.expect_local())\n+impl<'a, 'tcx> FingerprintDecoder for CacheDecoder<'a, 'tcx> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error> {\n+        Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n+    for &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>>\n+{\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n+    for &'tcx [rustc_ast::ast::InlineAsmTemplatePiece]\n+{\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n     }\n }\n \n //- ENCODING -------------------------------------------------------------------\n \n /// An encoder that can write the incr. comp. cache.\n-struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n+struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -774,7 +796,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -785,7 +807,7 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable, V: Encodable>(\n+    fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(\n         &mut self,\n         tag: T,\n         value: &V,\n@@ -800,170 +822,111 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n-        index.encode(self)\n+impl<'a, 'tcx> FingerprintEncoder for CacheEncoder<'a, 'tcx, rustc_serialize::opaque::Encoder> {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> opaque::EncodeResult {\n+        f.encode_opaque(self.encoder)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<SyntaxContext> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for SyntaxContext\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, ctxt: &SyntaxContext) -> Result<(), Self::Error> {\n-        rustc_span::hygiene::raw_encode_syntax_context(*ctxt, self.hygiene_context, self)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, s.hygiene_context, s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<ExpnId> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for ExpnId\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         rustc_span::hygiene::raw_encode_expn_id(\n-            *expn,\n-            self.hygiene_context,\n+            *self,\n+            s.hygiene_context,\n             ExpnDataEncodeMode::IncrComp,\n-            self,\n+            s,\n         )\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for Span\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if *span == DUMMY_SP {\n-            return TAG_INVALID_SPAN.encode(self);\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        if *self == DUMMY_SP {\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let span_data = span.data();\n-        let (file_lo, line_lo, col_lo) =\n-            match self.source_map.byte_pos_to_line_and_col(span_data.lo) {\n-                Some(pos) => pos,\n-                None => return TAG_INVALID_SPAN.encode(self),\n-            };\n+        let span_data = self.data();\n+        let (file_lo, line_lo, col_lo) = match s.source_map.byte_pos_to_line_and_col(span_data.lo) {\n+            Some(pos) => pos,\n+            None => return TAG_INVALID_SPAN.encode(s),\n+        };\n \n         if !file_lo.contains(span_data.hi) {\n-            return TAG_INVALID_SPAN.encode(self);\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n         let len = span_data.hi - span_data.lo;\n \n-        let source_file_index = self.source_file_index(file_lo);\n+        let source_file_index = s.source_file_index(file_lo);\n \n-        TAG_VALID_SPAN.encode(self)?;\n-        source_file_index.encode(self)?;\n-        line_lo.encode(self)?;\n-        col_lo.encode(self)?;\n-        len.encode(self)?;\n-        span_data.ctxt.encode(self)?;\n-        Ok(())\n+        TAG_VALID_SPAN.encode(s)?;\n+        source_file_index.encode(s)?;\n+        line_lo.encode(s)?;\n+        col_lo.encode(s)?;\n+        len.encode(s)?;\n+        span_data.ctxt.encode(s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Ident> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> TyEncoder<'tcx> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, _: &Ident) -> Result<(), Self::Error> {\n-        // We don't currently encode enough information to ensure hygiene works\n-        // with incremental, so panic rather than risk incremental bugs.\n+    const CLEAR_CROSS_CRATE: bool = false;\n \n-        // FIXME: handle hygiene in incremental.\n-        bug!(\"trying to encode `Ident` for incremental\");\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n     }\n-}\n-\n-impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n     fn position(&self) -> usize {\n-        self.encoder.position()\n+        self.encoder.encoder_position()\n     }\n-}\n-\n-impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n-        self.emit_u32(cnum.as_u32())\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n+        &mut self.type_shorthands\n     }\n-}\n-\n-impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b ty::TyS<'c>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-    &'b ty::TyS<'c>: UseSpecializedEncodable,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, ty: &&'b ty::TyS<'c>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(ty).is_some());\n-        let ty = unsafe { std::mem::transmute::<&&'b ty::TyS<'c>, &&'tcx ty::TyS<'tcx>>(ty) };\n-        ty_codec::encode_with_shorthand(self, ty, |encoder| &mut encoder.type_shorthands)\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx, E> SpecializedEncoder<ty::Predicate<'b>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(predicate).is_some());\n-        let predicate =\n-            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n-        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n-            &mut encoder.predicate_shorthands\n-        })\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize> {\n+        &mut self.predicate_shorthands\n     }\n-}\n+    fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n \n-impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n-        let def_path_hash = self.tcx.def_path_hash(*id);\n-        def_path_hash.encode(self)\n+        index.encode(self)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefId\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    #[inline]\n-    fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n-        id.to_def_id().encode(self)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        let def_path_hash = s.tcx.def_path_hash(*self);\n+        def_path_hash.encode(s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefIndex\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n+    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        f.encode_opaque(&mut self.encoder)\n-    }\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         #[inline]\n@@ -975,7 +938,7 @@ macro_rules! encoder_methods {\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n     type Error = E::Error;\n \n@@ -1014,32 +977,29 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n-impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n-\n-impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n-    fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n-        let start_pos = self.position();\n+impl Encodable<opaque::Encoder> for IntEncodedWithFixedSize {\n+    fn encode(&self, e: &mut opaque::Encoder) -> Result<(), !> {\n+        let start_pos = e.position();\n         for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            ((x.0 >> (i * 8)) as u8).encode(self)?;\n+            ((self.0 >> (i * 8)) as u8).encode(e)?;\n         }\n-        let end_pos = self.position();\n+        let end_pos = e.position();\n         assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n         Ok(())\n     }\n }\n \n-impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n+impl<'a> Decodable<opaque::Decoder<'a>> for IntEncodedWithFixedSize {\n+    fn decode(decoder: &mut opaque::Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n         let mut value: u64 = 0;\n-        let start_pos = self.position();\n+        let start_pos = decoder.position();\n \n         for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            let byte: u8 = Decodable::decode(self)?;\n+            let byte: u8 = Decodable::decode(decoder)?;\n             value |= (byte as u64) << (i * 8);\n         }\n \n-        let end_pos = self.position();\n+        let end_pos = decoder.position();\n         assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n \n         Ok(IntEncodedWithFixedSize(value))\n@@ -1053,8 +1013,8 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n ) -> Result<(), E::Error>\n where\n     Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n-    Q::Value: Encodable,\n-    E: 'a + TyEncoder,\n+    Q::Value: Encodable<CacheEncoder<'a, 'tcx, E>>,\n+    E: 'a + OpaqueEncoder,\n {\n     let _timer = tcx\n         .sess\n@@ -1066,15 +1026,16 @@ where\n \n     state.iter_results(|results| {\n         for (key, value, dep_node) in results {\n-            if Q::cache_on_disk(tcx, &key, Some(&value)) {\n+            if Q::cache_on_disk(tcx, &key, Some(value)) {\n                 let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n                 // Record position of the cache entry.\n-                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n+                query_result_index\n+                    .push((dep_node, AbsoluteBytePos::new(encoder.encoder.opaque().position())));\n \n                 // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag.\n-                encoder.encode_tagged(dep_node, &value)?;\n+                encoder.encode_tagged(dep_node, value)?;\n             }\n         }\n         Ok(())"}, {"sha": "9b1837356e3053df7778812c8de0e2b1864b1d49", "filename": "src/librustc_middle/ty/query/profiling_support.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,8 +1,9 @@\n use crate::ty::context::TyCtxt;\n+use crate::ty::WithOptConstParam;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_query_system::query::QueryCache;\n use rustc_query_system::query::QueryState;\n@@ -154,6 +155,49 @@ impl SpecIntoSelfProfilingString for DefIndex {\n     }\n }\n \n+impl SpecIntoSelfProfilingString for LocalDefId {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n+        builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: self.local_def_index })\n+    }\n+}\n+\n+impl<T: SpecIntoSelfProfilingString> SpecIntoSelfProfilingString for WithOptConstParam<T> {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n+        // We print `WithOptConstParam` values as tuples to make them shorter\n+        // and more readable, without losing information:\n+        //\n+        // \"WithOptConstParam { did: foo::bar, const_param_did: Some(foo::baz) }\"\n+        // becomes \"(foo::bar, foo::baz)\" and\n+        // \"WithOptConstParam { did: foo::bar, const_param_did: None }\"\n+        // becomes \"(foo::bar, _)\".\n+\n+        let did = StringComponent::Ref(self.did.to_self_profile_string(builder));\n+\n+        let const_param_did = if let Some(const_param_did) = self.const_param_did {\n+            let const_param_did = builder.def_id_to_string_id(const_param_did);\n+            StringComponent::Ref(const_param_did)\n+        } else {\n+            StringComponent::Value(\"_\")\n+        };\n+\n+        let components = [\n+            StringComponent::Value(\"(\"),\n+            did,\n+            StringComponent::Value(\", \"),\n+            const_param_did,\n+            StringComponent::Value(\")\"),\n+        ];\n+\n+        builder.profiler.alloc_string(&components[..])\n+    }\n+}\n+\n impl<T0, T1> SpecIntoSelfProfilingString for (T0, T1)\n where\n     T0: SpecIntoSelfProfilingString,"}, {"sha": "05cd1ae456b356b49a8011a55fe642d4d8c7a626", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -27,14 +27,14 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use ty::util::IntTypeExt;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, TyEncodable, TyDecodable, Copy)]\n #[derive(HashStable)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n@@ -43,7 +43,7 @@ pub struct FreeRegion {\n     pub bound_region: BoundRegion,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, TyEncodable, TyDecodable, Copy)]\n #[derive(HashStable)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n@@ -82,7 +82,7 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `librustc_ast/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n #[derive(HashStable)]\n #[rustc_diagnostic_item = \"TyKind\"]\n pub enum TyKind<'tcx> {\n@@ -215,7 +215,7 @@ impl TyKind<'tcx> {\n /// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n /// except through `tcx.err*()`.\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct DelaySpanBugEmitted(pub(super) ());\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -622,7 +622,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n@@ -673,8 +673,6 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n-\n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n@@ -770,7 +768,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -828,7 +826,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -884,7 +882,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g., `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n pub struct Binder<T>(T);\n \n impl<T> Binder<T> {\n@@ -1016,7 +1014,7 @@ impl<T> Binder<Option<T>> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n@@ -1086,7 +1084,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// - `inputs`: is the list of arguments and their modes.\n /// - `output`: is the return type.\n /// - `c_variadic`: indicates whether this is a C-variadic function.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n@@ -1147,7 +1145,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct ParamTy {\n     pub index: u32,\n@@ -1172,7 +1170,7 @@ impl<'tcx> ParamTy {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]\n pub struct ParamConst {\n     pub index: u32,\n@@ -1345,7 +1343,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// [1]: http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2]: http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-#[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, TyEncodable, TyDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n     /// Region bound in a type or fn declaration which will be\n     /// substituted 'early' -- that is, at the same time when type\n@@ -1383,32 +1381,30 @@ pub enum RegionKind {\n     ReErased,\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Region<'tcx> {}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n pub struct EarlyBoundRegion {\n     pub def_id: DefId,\n     pub index: u32,\n     pub name: Symbol,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct IntVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct FloatVid {\n     pub index: u32,\n }\n@@ -1425,7 +1421,7 @@ impl Atom for RegionVid {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum InferTy {\n     TyVar(TyVid),\n@@ -1444,14 +1440,14 @@ rustc_index::newtype_index! {\n     pub struct BoundVar { .. }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct BoundTy {\n     pub var: BoundVar,\n     pub kind: BoundTyKind,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundTyKind {\n     Anon,\n@@ -1465,7 +1461,7 @@ impl From<BoundVar> for BoundTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,"}, {"sha": "acd58ab7f967a6e60af7917aa41c272db3b4c55c", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,13 +1,14 @@\n // Type substitutions.\n \n use crate::infer::canonical::Canonical;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_serialize::{self, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{self, Decodable, Encodable};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n \n@@ -34,7 +35,7 @@ const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n@@ -168,14 +169,14 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx> Encodable for GenericArg<'tcx> {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx> Decodable for GenericArg<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {\n+    fn decode(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n         Ok(GenericArgKind::decode(d)?.pack())\n     }\n }\n@@ -396,8 +397,6 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n@@ -653,7 +652,7 @@ pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct UserSubsts<'tcx> {\n     /// The substitutions for the item as given by the user.\n@@ -680,7 +679,7 @@ pub struct UserSubsts<'tcx> {\n /// the impl (with the substs from `UserSubsts`) and apply those to\n /// the self type, giving `Foo<?A>`. Finally, we unify that with\n /// the self type here, which contains `?A` to be `&'static u32`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct UserSelfTy<'tcx> {\n     pub impl_def_id: DefId,"}, {"sha": "86fe3ac3751aff2247a57155a3eb50bf8003d181", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -47,7 +47,7 @@ pub struct TraitDef {\n \n /// Whether this trait is treated specially by the standard library\n /// specialization lint.\n-#[derive(HashStable, PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable, PartialEq, Clone, Copy, TyEncodable, TyDecodable)]\n pub enum TraitSpecializationKind {\n     /// The default. Specializing on this trait is not allowed.\n     None,"}, {"sha": "23507ac830d553c48a31e34a54896968753b7059", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1143,7 +1143,7 @@ pub fn needs_drop_components(\n     }\n }\n \n-#[derive(Copy, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]\n pub struct AlwaysRequiresDrop;\n \n /// Normalizes all opaque types in the given value, replacing them"}, {"sha": "044d27a6a9dc3d0dd21aeb8bf708cc01e933cdcb", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 157, "deletions": 13, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,12 +1,16 @@\n use std::error::Error;\n use std::fmt;\n \n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n+use rustc_hir as hir;\n use rustc_middle::mir::AssertKind;\n-use rustc_middle::ty::ConstInt;\n+use rustc_middle::ty::{layout::LayoutError, query::TyCtxtAt, ConstInt};\n use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n-use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+use crate::interpret::{\n+    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine,\n+};\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n@@ -48,15 +52,155 @@ impl fmt::Display for ConstEvalErrKind {\n \n impl Error for ConstEvalErrKind {}\n \n-/// Turn an interpreter error into something to report to the user.\n-/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-/// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n-    ecx: &InterpCx<'mir, 'tcx, M>,\n-    error: InterpErrorInfo<'tcx>,\n-    span: Option<Span>,\n-) -> ConstEvalErr<'tcx> {\n-    error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+/// When const-evaluation errors, this type is constructed with the resulting information,\n+/// and then used to emit the error as a lint or hard error.\n+#[derive(Debug)]\n+pub struct ConstEvalErr<'tcx> {\n+    pub span: Span,\n+    pub error: InterpError<'tcx>,\n+    pub stacktrace: Vec<FrameInfo<'tcx>>,\n+}\n+\n+impl<'tcx> ConstEvalErr<'tcx> {\n+    /// Turn an interpreter error into something to report to the user.\n+    /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+    /// Should be called only if the error is actually going to to be reported!\n+    pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        error: InterpErrorInfo<'tcx>,\n+        span: Option<Span>,\n+    ) -> ConstEvalErr<'tcx>\n+    where\n+        'tcx: 'mir,\n+    {\n+        error.print_backtrace();\n+        let stacktrace = ecx.generate_stacktrace();\n+        ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+    }\n+\n+    pub fn struct_error(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> ErrorHandled {\n+        self.struct_generic(tcx, message, emit, None)\n+    }\n+\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n+        self.struct_error(tcx, message, |mut e| e.emit())\n+    }\n+\n+    pub fn report_as_lint(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        lint_root: hir::HirId,\n+        span: Option<Span>,\n+    ) -> ErrorHandled {\n+        self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n+                if let Some(span) = span {\n+                    let primary_spans = lint.span.primary_spans().to_vec();\n+                    // point at the actual error as the primary span\n+                    lint.replace_span_with(span);\n+                    // point to the `const` statement as a secondary span\n+                    // they don't have any label\n+                    for sp in primary_spans {\n+                        if sp != span {\n+                            lint.span_label(sp, \"\");\n+                        }\n+                    }\n+                }\n+                lint.emit();\n+            },\n+            Some(lint_root),\n+        )\n+    }\n+\n+    /// Create a diagnostic for this const eval error.\n+    ///\n+    /// Sets the message passed in via `message` and adds span labels with detailed error\n+    /// information before handing control back to `emit` to do any final processing.\n+    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n+    /// function to dispose of the diagnostic properly.\n+    ///\n+    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n+    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n+    fn struct_generic(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+        lint_root: Option<hir::HirId>,\n+    ) -> ErrorHandled {\n+        let must_error = match self.error {\n+            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+                return ErrorHandled::TooGeneric;\n+            }\n+            err_inval!(TypeckError(error_reported)) => {\n+                return ErrorHandled::Reported(error_reported);\n+            }\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n+            _ => false,\n+        };\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+\n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n+            }\n+            err => err.to_string(),\n+        };\n+\n+        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            if let Some(span_msg) = span_msg {\n+                err.span_label(self.span, span_msg);\n+            }\n+            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+            if self.stacktrace.len() > 1 {\n+                for frame_info in &self.stacktrace {\n+                    err.span_label(frame_info.span, frame_info.to_string());\n+                }\n+            }\n+            // Let the caller finish the job.\n+            emit(err)\n+        };\n+\n+        if must_error {\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            finish(struct_error(tcx, &err_msg), None);\n+            ErrorHandled::Reported(ErrorReported)\n+        } else {\n+            // Regular case.\n+            if let Some(lint_root) = lint_root {\n+                // Report as lint.\n+                let hir_id = self\n+                    .stacktrace\n+                    .iter()\n+                    .rev()\n+                    .find_map(|frame| frame.lint_root)\n+                    .unwrap_or(lint_root);\n+                tcx.struct_span_lint_hir(\n+                    rustc_session::lint::builtin::CONST_ERR,\n+                    hir_id,\n+                    tcx.span,\n+                    |lint| finish(lint.build(message), Some(err_msg)),\n+                );\n+                ErrorHandled::Linted\n+            } else {\n+                // Report as hard error.\n+                finish(struct_error(tcx, message), Some(err_msg));\n+                ErrorHandled::Reported(ErrorReported)\n+            }\n+        }\n+    }\n }"}, {"sha": "4101f70b8206dbaacda90a9940e8e35b54168fe5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,13 +1,14 @@\n-use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n+\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -56,6 +57,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n+    // FIXME: since the DefId of a promoted is the DefId of its owner, this\n+    // means that promoteds in statics are actually interned like statics!\n+    // However, this is also currently crucial because we promote mutable\n+    // non-empty slices in statics to extend their lifetime, and this\n+    // ensures that they are put into a mutable allocation.\n+    // For other kinds of promoteds in statics (like array initializers), this is rather silly.\n     let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n         Some(m) => InternKind::Static(m),\n         None if cid.promoted.is_some() => InternKind::Promoted,\n@@ -213,7 +220,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error, None);\n+        let err = ConstEvalErr::new(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -312,7 +319,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n         .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error, None);\n+            let err = ConstEvalErr::new(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`"}, {"sha": "2d0e68d58943fe56ff4b09db84cf39615135508f", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -301,6 +301,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn init_frame_extra(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        // Enforce stack size limit. Add 1 because this is run before the new frame is pushed.\n+        if !ecx.tcx.sess.recursion_limit().value_within_limit(ecx.stack().len() + 1) {\n+            throw_exhaust!(StackFrameLimitReached)\n+        } else {\n+            Ok(frame)\n+        }\n+    }\n+\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}, {"sha": "525da87463a0e996475c291461b8de4612643e35", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 70, "deletions": 27, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,22 +1,22 @@\n use std::cell::Cell;\n+use std::fmt;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::{self as hir, def::DefKind, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n+    sign_extend, truncate, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{source_map::DUMMY_SP, Span};\n+use rustc_span::{Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n@@ -83,9 +83,19 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n-    /// Just continue the same as with `Resume`.\n-    pub loc: Option<mir::Location>,\n+    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// this frame (can happen e.g. during frame initialization, and during unwinding on\n+    /// frames without cleanup code).\n+    /// We basically abuse `Result` as `Either`.\n+    pub(super) loc: Result<mir::Location, Span>,\n+}\n+\n+/// What we store about a frame in an interpreter backtrace.\n+#[derive(Debug)]\n+pub struct FrameInfo<'tcx> {\n+    pub instance: ty::Instance<'tcx>,\n+    pub span: Span,\n+    pub lint_root: Option<hir::HirId>,\n }\n \n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n@@ -181,7 +191,33 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n-        self.loc.map(|loc| self.body.source_info(loc))\n+        self.loc.ok().map(|loc| self.body.source_info(loc))\n+    }\n+\n+    pub fn current_span(&self) -> Span {\n+        match self.loc {\n+            Ok(loc) => self.body.source_info(loc).span,\n+            Err(span) => span,\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr\n+            {\n+                write!(f, \"inside closure\")?;\n+            } else {\n+                write!(f, \"inside `{}`\", self.instance)?;\n+            }\n+            if !self.span.is_dummy() {\n+                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n+                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n+            }\n+            Ok(())\n+        })\n     }\n }\n \n@@ -297,11 +333,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline(always)]\n     pub fn cur_span(&self) -> Span {\n-        self.stack()\n-            .last()\n-            .and_then(|f| f.current_source_info())\n-            .map(|si| si.span)\n-            .unwrap_or(self.tcx.span)\n+        self.stack().last().map(|f| f.current_span()).unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -613,7 +645,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            loc: Some(mir::Location::START),\n+            loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -625,6 +657,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame = M::init_frame_extra(self, pre_frame)?;\n         self.stack_mut().push(frame);\n \n+        // Make sure all the constants required by this frame evaluate successfully (post-monomorphization check).\n+        for const_ in &body.required_consts {\n+            let span = const_.span;\n+            let const_ =\n+                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal);\n+            self.const_to_op(const_, None).map_err(|err| {\n+                // If there was an error, set the span of the current frame to this constant.\n+                // Avoiding doing this when evaluation succeeds.\n+                self.frame_mut().loc = Err(span);\n+                err\n+            })?;\n+        }\n+\n         // Locals are initially uninitialized.\n         let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n@@ -649,21 +694,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // done\n         self.frame_mut().locals = locals;\n-\n         M::after_stack_push(self)?;\n+        self.frame_mut().loc = Ok(mir::Location::START);\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n-        if !self.tcx.sess.recursion_limit().value_within_limit(self.stack().len()) {\n-            throw_exhaust!(StackFrameLimitReached)\n-        } else {\n-            Ok(())\n-        }\n+        Ok(())\n     }\n \n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().loc = Some(mir::Location { block: target, statement_index: 0 });\n+        self.frame_mut().loc = Ok(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -685,7 +726,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function does not need cleanup during\n     /// unwinding, and we will just keep propagating that upwards.\n     pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n-        self.frame_mut().loc = target.map(|block| mir::Location { block, statement_index: 0 });\n+        self.frame_mut().loc = match target {\n+            Some(block) => Ok(mir::Location { block, statement_index: 0 }),\n+            None => Err(self.frame_mut().body.span),\n+        };\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -713,8 +757,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                None => true,\n-                Some(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Err(_) => true,\n             }\n         );\n \n@@ -890,14 +934,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n         let mut frames = Vec::new();\n         for frame in self.stack().iter().rev() {\n-            let source_info = frame.current_source_info();\n-            let lint_root = source_info.and_then(|source_info| {\n+            let lint_root = frame.current_source_info().and_then(|source_info| {\n                 match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n                     mir::ClearCrossCrate::Clear => None,\n                 }\n             });\n-            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n+            let span = frame.current_span();\n \n             frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }"}, {"sha": "6c8ee72bc66c2e01e65435a34df0ceeb13fb7eb8", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -312,7 +312,8 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     let tcx = ecx.tcx;\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n-        // FIXME: what about array lengths, array initializers?\n+        // `Constant` includes array lengths.\n+        // `Promoted` includes non-`Copy` array initializers and `rustc_args_required_const` arguments.\n         InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n     };\n "}, {"sha": "fb3a670714b58ad0298612dc5261383d64f27b79", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -30,8 +30,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Assert that there is always such a frame.\n             .unwrap();\n         // Assert that the frame we look at is actually executing code currently\n-        // (`current_source_info` is None when we are unwinding and the frame does\n-        // not require cleanup).\n+        // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n         let loc = frame.loc.unwrap();\n         // If this is a `Call` terminator, use the `fn_span` instead.\n         let block = &frame.body.basic_blocks()[loc.block];"}, {"sha": "5cab4ba37e3a5be0e4e016c15cc088cbf93acff8", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -409,12 +409,4 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     ) -> Self::PointerTag {\n         ()\n     }\n-\n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<$mir, $tcx, Self>,\n-        frame: Frame<$mir, $tcx>,\n-    ) -> InterpResult<$tcx, Frame<$mir, $tcx>> {\n-        Ok(frame)\n-    }\n }"}, {"sha": "49d97ff7cecccfc93c40cfea1c632fd399749ba0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -14,13 +14,12 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n+use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, GlobalAlloc, GlobalId,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n+    AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, GlobalAlloc, InterpResult,\n+    Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n };\n use crate::util::pretty;\n \n@@ -119,17 +118,6 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n-/// Return the `tcx` allocation containing the initial value of the given static\n-pub fn get_static(tcx: TyCtxt<'tcx>, def_id: DefId) -> InterpResult<'tcx, &'tcx Allocation> {\n-    trace!(\"get_static: Need to compute {:?}\", def_id);\n-    let instance = Instance::mono(tcx, def_id);\n-    let gid = GlobalId { instance, promoted: None };\n-    // Use the raw query here to break validation cycles. Later uses of the static\n-    // will call the full query anyway.\n-    let raw_const = tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid))?;\n-    Ok(tcx.global_alloc(raw_const.alloc_id).unwrap_memory())\n-}\n-\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -489,7 +477,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n-                (get_static(tcx, def_id)?, Some(def_id))\n+                (tcx.eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n         M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n@@ -926,7 +914,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-        // (`get_bytes_with_undef_and_ptr` below checks that there are no\n+        // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n@@ -935,7 +923,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // This checks relocation edges on the src.\n         let src_bytes =\n-            self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n+            self.get_raw(src.alloc_id)?.get_bytes_with_uninit_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n             self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n@@ -948,7 +936,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n         // Prepare a copy of the initialization mask.\n-        let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n+        let compressed = self.get_raw(src.alloc_id)?.compress_uninit_range(src, size);\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}, {"sha": "a931b0bbe9777b4b02b9f831d96797b92293b9af", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -18,10 +18,10 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n+pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n-pub use self::memory::{get_static, AllocCheck, FnVal, Memory, MemoryKind};\n+pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::RefTracking;"}, {"sha": "0b58caef54d2bf2cb7cc679d9e7e8ed27dae89f2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -106,7 +106,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n                 }\n                 ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n-                        this.write_str(\"{undef \")?;\n+                        this.write_str(\"{uninit \")?;\n                         Ok(this)\n                     },\n                     |this| this.print_type(ty),"}, {"sha": "20fd8e43361d6561d9c3cb7c74e52c0d5ee8016b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -61,7 +61,7 @@ impl<Tag> MemPlaceMeta<Tag> {\n pub struct MemPlace<Tag = ()> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n-    /// However, it may never be undef.\n+    /// However, it may never be uninit.\n     pub ptr: Scalar<Tag>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n@@ -729,7 +729,7 @@ where\n                         \"Size mismatch when writing bits\"\n                     )\n                 }\n-                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // undef can have any size\n+                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n                 Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }"}, {"sha": "adecee3f7cb570e63aa420c5fa7adfd129105be3", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -47,8 +47,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let loc = match self.frame().loc {\n-            Some(loc) => loc,\n-            None => {\n+            Ok(loc) => loc,\n+            Err(_) => {\n                 // We are unwinding and this fn has no cleanup code.\n                 // Just go on unwinding.\n                 trace!(\"unwinding: skipping frame\");\n@@ -74,7 +74,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n-    fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n+    /// Runs the interpretation logic for the given `mir::Statement` at the current frame and\n+    /// statement counter. This also moves the statement counter forward.\n+    crate fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n \n         use rustc_middle::mir::StatementKind::*;\n@@ -281,7 +283,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Some(loc) = self.frame().loc {\n+            if let Ok(loc) = self.frame().loc {\n                 info!(\"// executing {:?}\", loc.block);\n             }\n         }"}, {"sha": "9cd20340138cf290bf539c05a9a9ecc9a7bb6e08", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -508,12 +508,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     }\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n-                    // undef. We should fix that, but let's start low.\n+                    // uninit. We should fix that, but let's start low.\n                 }\n                 Ok(true)\n             }\n             ty::RawPtr(..) => {\n-                // We are conservative with undef for integers, but try to\n+                // We are conservative with uninit for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place = try_validation!(\n@@ -807,12 +807,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the slow path.\n+                // We also accept uninit, for consistency with the slow path.\n                 match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}, {"sha": "fc9f7f1af622f8e7508a81e9cd35b7c9401995c3", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -269,15 +269,21 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n                 self.unused_parameters.clear(param.index);\n                 false\n             }\n-            ty::ConstKind::Unevaluated(_, _, Some(p)) => {\n+            ty::ConstKind::Unevaluated(def, _, Some(p))\n+                // Avoid considering `T` unused when constants are of the form:\n+                //   `<Self as Foo<T>>::foo::promoted[p]`\n+                if self.def_id == def.did && !self.tcx.generics_of(def.did).has_self =>\n+            {\n                 // If there is a promoted, don't look at the substs - since it will always contain\n                 // the generic parameters, instead, traverse the promoted MIR.\n-                let promoted = self.tcx.promoted_mir(self.def_id);\n+                let promoted = self.tcx.promoted_mir(def.did);\n                 self.visit_body(&promoted[p]);\n                 false\n             }\n-            ty::ConstKind::Unevaluated(def_id, unevaluated_substs, None) => {\n-                self.visit_child_body(def_id.did, unevaluated_substs);\n+            ty::ConstKind::Unevaluated(def, unevaluated_substs, None)\n+                if self.tcx.def_kind(def.did) == DefKind::AnonConst =>\n+            {\n+                self.visit_child_body(def.did, unevaluated_substs);\n                 false\n             }\n             _ => c.super_visit_with(self),"}, {"sha": "324289166b9fb0c913929dadcc63863979d8d44c", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -86,12 +86,11 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n                 .skip(1)\n                 .take(arg_count)\n                 .map(|(local, _)| Place::from(local))\n-                .filter(needs_retag)\n-                .collect::<Vec<_>>();\n+                .filter(needs_retag);\n             // Emit their retags.\n             basic_blocks[START_BLOCK].statements.splice(\n                 0..0,\n-                places.into_iter().map(|place| Statement {\n+                places.map(|place| Statement {\n                     source_info,\n                     kind: StatementKind::Retag(RetagKind::FnEntry, box (place)),\n                 }),\n@@ -101,29 +100,24 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // PART 2\n         // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n         // We collect the return destinations because we cannot mutate while iterating.\n-        let mut returns: Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n-        for block_data in basic_blocks.iter_mut() {\n-            match block_data.terminator().kind {\n-                TerminatorKind::Call { ref destination, .. } => {\n-                    // Remember the return destination for later\n-                    if let Some(ref destination) = destination {\n-                        if needs_retag(&destination.0) {\n-                            returns.push((\n-                                block_data.terminator().source_info,\n-                                destination.0,\n-                                destination.1,\n-                            ));\n-                        }\n+        let returns = basic_blocks\n+            .iter_mut()\n+            .filter_map(|block_data| {\n+                match block_data.terminator().kind {\n+                    TerminatorKind::Call { destination: Some(ref destination), .. }\n+                        if needs_retag(&destination.0) =>\n+                    {\n+                        // Remember the return destination for later\n+                        Some((block_data.terminator().source_info, destination.0, destination.1))\n                     }\n-                }\n-                TerminatorKind::Drop { .. } | TerminatorKind::DropAndReplace { .. } => {\n+\n                     // `Drop` is also a call, but it doesn't return anything so we are good.\n-                }\n-                _ => {\n+                    TerminatorKind::Drop { .. } | TerminatorKind::DropAndReplace { .. } => None,\n                     // Not a block ending in a Call -> ignore.\n+                    _ => None,\n                 }\n-            }\n-        }\n+            })\n+            .collect::<Vec<_>>();\n         // Now we go over the returns we collected to retag the return values.\n         for (source_info, dest_place, dest_block) in returns {\n             basic_blocks[dest_block].statements.insert("}, {"sha": "3b39d5f66b78fa81d4135acbe070e785bcc1384a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -26,7 +26,7 @@ use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n-use crate::const_eval::error_to_const_error;\n+use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n     self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n     LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n@@ -252,6 +252,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n         if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n+            trace!(\n+                \"mutating local {:?} which is restricted to its block. \\\n+                Will remove it from const-prop after block is finished.\",\n+                local\n+            );\n             ecx.machine.written_only_inside_own_block_locals.insert(local);\n         }\n         ecx.machine.stack[frame].locals[local].access_mut()\n@@ -276,6 +281,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        Ok(frame)\n+    }\n+\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n@@ -427,6 +440,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n+                trace!(\"InterpCx operation failed: {:?}\", error);\n                 // Some errors shouldn't come up because creating them causes\n                 // an allocation, which we should avoid. When that happens,\n                 // dedicated error variants should be introduced instead.\n@@ -451,7 +465,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);\n-                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n+                let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them\n@@ -969,10 +983,10 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n                         ConstPropMode::OnlyPropagateInto => {}\n                         other @ ConstPropMode::FullConstProp => {\n                             trace!(\n-                                \"local {:?} can't be propagated because of multiple assignments\",\n-                                local,\n+                                \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n+                                local, other,\n                             );\n-                            *other = ConstPropMode::OnlyPropagateInto;\n+                            *other = ConstPropMode::OnlyInsideOwnBlock;\n                         }\n                     }\n                 }\n@@ -1076,7 +1090,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 // ```rust\n                 // let mut x = 42;\n                 // x = SOME_MUTABLE_STATIC;\n-                // // x must now be undefined\n+                // // x must now be uninit\n                 // ```\n                 // FIXME: we overzealously erase the entire local, because that's easier to\n                 // implement.\n@@ -1089,6 +1103,20 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n             }\n         } else {\n             match statement.kind {\n+                StatementKind::SetDiscriminant { ref place, .. } => {\n+                    match self.ecx.machine.can_const_prop[place.local] {\n+                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                            if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n+                                trace!(\"propped discriminant into {:?}\", place);\n+                            } else {\n+                                Self::remove_const(&mut self.ecx, place.local);\n+                            }\n+                        }\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                }\n                 StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n                     let frame = self.ecx.frame_mut();\n                     frame.locals[local].value ="}, {"sha": "66989a902447d6076071f0936672459dc276f4e9", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -12,26 +12,24 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {\n                 // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n-                if let StatementKind::Assign(box (_, ref rhs)) = stmt.kind {\n-                    if let Rvalue::Aggregate(ref kind, _) = *rhs {\n-                        // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n-                        if let AggregateKind::Array(_) = **kind {\n-                            return None;\n-                        }\n-                    } else {\n+                match stmt.kind {\n+                    // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n+                    StatementKind::Assign(box (\n+                        _,\n+                        Rvalue::Aggregate(box AggregateKind::Array(_), _),\n+                    )) => {\n                         return None;\n                     }\n-                } else {\n-                    return None;\n+                    StatementKind::Assign(box (_, Rvalue::Aggregate(_, _))) => {}\n+                    _ => return None,\n                 }\n \n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n                 let (lhs, kind, operands) = match stmt.kind {\n-                    StatementKind::Assign(box (lhs, rvalue)) => match rvalue {\n-                        Rvalue::Aggregate(kind, operands) => (lhs, kind, operands),\n-                        _ => bug!(),\n-                    },\n+                    StatementKind::Assign(box (lhs, Rvalue::Aggregate(kind, operands))) => {\n+                        (lhs, kind, operands)\n+                    }\n                     _ => bug!(),\n                 };\n "}, {"sha": "500d66ece0676312e08461c17b9e24e11f515446", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -295,6 +295,21 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let (file_name, start_line, start_col, end_line, end_col) = self.code_region(&span);\n \n+        // FIXME(richkadel): Note that `const_str()` results in the creation of an `Allocation` to\n+        // hold one copy of each unique filename. It looks like that `Allocation` may translate into\n+        // the creation of an `@alloc` in LLVM IR that is never actually used by runtime code.\n+        //\n+        // Example LLVM IR:\n+        //\n+        // @alloc4 = private unnamed_addr constant <{ [43 x i8] }> \\\n+        //   <{ [43 x i8] c\"C:\\\\msys64\\\\home\\\\richkadel\\\\rust\\\\rust_basic.rs\" }>, align 1\n+        //\n+        // Can I flag the alloc as something not to be added to codegen? Or somehow remove it before\n+        // it gets added to the LLVM IR? Do we need some kind of reference counting to know it's\n+        // not used by any runtime code?\n+        //\n+        // This question is moot if I convert the Call Terminators to Statements, I believe:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20LLVM-compatible.20source-based.20cod.20compiler-team.23278/near/206731748\n         args.push(self.const_str(&file_name, inject_at));\n         args.push(self.const_u32(start_line, inject_at));\n         args.push(self.const_u32(start_col, inject_at));"}, {"sha": "74da6d5e629b3c0971c83dcf78320fc70a8c9c60", "filename": "src/librustc_mir/transform/match_branches.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -0,0 +1,93 @@\n+use crate::transform::{MirPass, MirSource};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+\n+pub struct MatchBranchSimplification;\n+\n+// What's the intent of this pass?\n+// If one block is found that switches between blocks which both go to the same place\n+// AND both of these blocks set a similar const in their ->\n+// condense into 1 block based on discriminant AND goto the destination afterwards\n+\n+impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(src.def_id());\n+        let bbs = body.basic_blocks_mut();\n+        'outer: for bb_idx in bbs.indices() {\n+            let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {\n+                TerminatorKind::SwitchInt {\n+                    discr: Operand::Move(ref place),\n+                    switch_ty,\n+                    ref targets,\n+                    ref values,\n+                    ..\n+                } if targets.len() == 2 && values.len() == 1 => {\n+                    (place, values[0], switch_ty, targets[0], targets[1])\n+                }\n+                // Only optimize switch int statements\n+                _ => continue,\n+            };\n+\n+            // Check that destinations are identical, and if not, then don't optimize this block\n+            if &bbs[first].terminator().kind != &bbs[second].terminator().kind {\n+                continue;\n+            }\n+\n+            // Check that blocks are assignments of consts to the same place or same statement,\n+            // and match up 1-1, if not don't optimize this block.\n+            let first_stmts = &bbs[first].statements;\n+            let scnd_stmts = &bbs[second].statements;\n+            if first_stmts.len() != scnd_stmts.len() {\n+                continue;\n+            }\n+            for (f, s) in first_stmts.iter().zip(scnd_stmts.iter()) {\n+                match (&f.kind, &s.kind) {\n+                    // If two statements are exactly the same just ignore them.\n+                    (f_s, s_s) if f_s == s_s => (),\n+\n+                    (\n+                        StatementKind::Assign(box (lhs_f, Rvalue::Use(Operand::Constant(f_c)))),\n+                        StatementKind::Assign(box (lhs_s, Rvalue::Use(Operand::Constant(s_c)))),\n+                    ) if lhs_f == lhs_s => {\n+                        if let Some(f_c) = f_c.literal.try_eval_bool(tcx, param_env) {\n+                            // This should also be a bool because it's writing to the same place\n+                            let s_c = s_c.literal.try_eval_bool(tcx, param_env).unwrap();\n+                            if f_c != s_c {\n+                                // have to check this here because f_c & s_c might have\n+                                // different spans.\n+                                continue;\n+                            }\n+                        }\n+                        continue 'outer;\n+                    }\n+                    // If there are not exclusively assignments, then ignore this\n+                    _ => continue 'outer,\n+                }\n+            }\n+            // Take owenership of items now that we know we can optimize.\n+            let discr = discr.clone();\n+            let (from, first) = bbs.pick2_mut(bb_idx, first);\n+\n+            let new_stmts = first.statements.iter().cloned().map(|mut s| {\n+                if let StatementKind::Assign(box (_, ref mut rhs)) = s.kind {\n+                    if let Rvalue::Use(Operand::Constant(c)) = rhs {\n+                        let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                        let const_cmp = Operand::const_from_scalar(\n+                            tcx,\n+                            switch_ty,\n+                            crate::interpret::Scalar::from_uint(val, size),\n+                            rustc_span::DUMMY_SP,\n+                        );\n+                        if let Some(c) = c.literal.try_eval_bool(tcx, param_env) {\n+                            let op = if c { BinOp::Eq } else { BinOp::Ne };\n+                            *rhs = Rvalue::BinaryOp(op, Operand::Move(discr), const_cmp);\n+                        }\n+                    }\n+                }\n+                s\n+            });\n+            from.statements.extend(new_stmts);\n+            from.terminator_mut().kind = first.terminator().kind.clone();\n+        }\n+    }\n+}"}, {"sha": "4f26f3bb45973b178c36fc8821c9bc24025221b8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -29,6 +29,7 @@ pub mod generator;\n pub mod inline;\n pub mod instcombine;\n pub mod instrument_coverage;\n+pub mod match_branches;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -408,6 +409,9 @@ fn run_post_borrowck_cleanup_passes<'tcx>(\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n+        // `Deaggregator` is conceptually part of MIR building, some backends rely on it happening\n+        // and it can help optimizations.\n+        &deaggregator::Deaggregator,\n     ];\n \n     run_passes(\n@@ -437,13 +441,9 @@ fn run_optimization_passes<'tcx>(\n         // with async primitives.\n         &generator::StateTransform,\n         &instcombine::InstCombine,\n+        &match_branches::MatchBranchSimplification,\n         &const_prop::ConstProp,\n         &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n-        // Run deaggregation here because:\n-        //   1. Some codegen backends require it\n-        //   2. It creates additional possibilities for some MIR optimizations to trigger\n-        // FIXME(#70073): Why is this done here and not in `post_borrowck_cleanup`?\n-        &deaggregator::Deaggregator,\n         &simplify_try::SimplifyArmIdentity,\n         &simplify_try::SimplifyBranchSame,\n         &copy_prop::CopyPropagation,\n@@ -460,9 +460,6 @@ fn run_optimization_passes<'tcx>(\n         &generator::StateTransform,\n         // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n         &const_prop::ConstProp,\n-        // Even if we don't do optimizations, still run deaggregation because some backends assume\n-        // that deaggregation always occurs.\n-        &deaggregator::Deaggregator,\n     ];\n \n     let pre_codegen_cleanup: &[&dyn MirPass<'tcx>] = &["}, {"sha": "94637bae44a7806cce8d6c3b9157890ebd74f512", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -101,7 +101,7 @@ impl TempState {\n /// of a larger candidate.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Candidate {\n-    /// Borrow of a constant temporary.\n+    /// Borrow of a constant temporary, candidate for lifetime extension.\n     Ref(Location),\n \n     /// Promotion of the `x` in `[x; 32]`."}, {"sha": "84082edd1933f61ec858fe2abba005a3ede99ec9", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -246,12 +246,14 @@ fn get_arm_identity_info<'a, 'tcx>(\n         tmp_assigned_vars.insert(*r);\n     }\n \n-    let mut dbg_info_to_adjust = Vec::new();\n-    for (i, var_info) in debug_info.iter().enumerate() {\n-        if tmp_assigned_vars.contains(var_info.place.local) {\n-            dbg_info_to_adjust.push(i);\n-        }\n-    }\n+    let dbg_info_to_adjust: Vec<_> =\n+        debug_info\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, var_info)| {\n+                if tmp_assigned_vars.contains(var_info.place.local) { Some(i) } else { None }\n+            })\n+            .collect();\n \n     Some(ArmIdentityInfo {\n         local_temp_0: local_tmp_s0,\n@@ -461,14 +463,14 @@ fn match_get_variant_field<'tcx>(\n     stmt: &Statement<'tcx>,\n ) -> Option<(Local, Local, VarField<'tcx>, &'tcx List<PlaceElem<'tcx>>)> {\n     match &stmt.kind {\n-        StatementKind::Assign(box (place_into, rvalue_from)) => match rvalue_from {\n-            Rvalue::Use(Operand::Copy(pf) | Operand::Move(pf)) => {\n-                let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(*pf)?;\n-                Some((local_into, local_from, vf, pf.projection))\n-            }\n-            _ => None,\n-        },\n+        StatementKind::Assign(box (\n+            place_into,\n+            Rvalue::Use(Operand::Copy(pf) | Operand::Move(pf)),\n+        )) => {\n+            let local_into = place_into.as_local()?;\n+            let (local_from, vf) = match_variant_field_place(*pf)?;\n+            Some((local_into, local_from, vf, pf.projection))\n+        }\n         _ => None,\n     }\n }\n@@ -479,14 +481,11 @@ fn match_get_variant_field<'tcx>(\n /// ```\n fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local, VarField<'tcx>)> {\n     match &stmt.kind {\n-        StatementKind::Assign(box (place_from, rvalue_into)) => match rvalue_into {\n-            Rvalue::Use(Operand::Move(place_into)) => {\n-                let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(*place_from)?;\n-                Some((local_into, local_from, vf))\n-            }\n-            _ => None,\n-        },\n+        StatementKind::Assign(box (place_from, Rvalue::Use(Operand::Move(place_into)))) => {\n+            let local_into = place_into.as_local()?;\n+            let (local_from, vf) = match_variant_field_place(*place_from)?;\n+            Some((local_into, local_from, vf))\n+        }\n         _ => None,\n     }\n }"}, {"sha": "4cca4d223c0cb6dd7c2f6cff5e71b762b549012b", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -99,26 +99,18 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n             if let TerminatorKind::SwitchInt { values, targets, .. } =\n                 &mut body.basic_blocks_mut()[bb].terminator_mut().kind\n             {\n-                let vals = &*values;\n-                let zipped = vals.iter().zip(targets.iter());\n-\n-                let mut matched_values = Vec::with_capacity(allowed_variants.len());\n-                let mut matched_targets = Vec::with_capacity(allowed_variants.len() + 1);\n-\n-                for (val, target) in zipped {\n-                    if allowed_variants.contains(val) {\n-                        matched_values.push(*val);\n-                        matched_targets.push(*target);\n-                    } else {\n-                        trace!(\"eliminating {:?} -> {:?}\", val, target);\n-                    }\n-                }\n-\n-                // handle the \"otherwise\" branch\n-                matched_targets.push(targets.pop().unwrap());\n-\n-                *values = matched_values.into();\n-                *targets = matched_targets;\n+                // take otherwise out early\n+                let otherwise = targets.pop().unwrap();\n+                assert_eq!(targets.len(), values.len());\n+                let mut i = 0;\n+                targets.retain(|_| {\n+                    let keep = allowed_variants.contains(&values[i]);\n+                    i += 1;\n+                    keep\n+                });\n+                targets.push(otherwise);\n+\n+                values.to_mut().retain(|var| allowed_variants.contains(var));\n             } else {\n                 unreachable!()\n             }"}, {"sha": "fa362c66fb2897a02661f19e2a50486830f1021e", "filename": "src/librustc_mir/transform/unreachable_prop.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -67,18 +67,13 @@ fn remove_successors<F>(\n where\n     F: Fn(BasicBlock) -> bool,\n {\n-    match *terminator_kind {\n-        TerminatorKind::Goto { target } if predicate(target) => Some(TerminatorKind::Unreachable),\n+    let terminator = match *terminator_kind {\n+        TerminatorKind::Goto { target } if predicate(target) => TerminatorKind::Unreachable,\n         TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n             let original_targets_len = targets.len();\n             let (otherwise, targets) = targets.split_last().unwrap();\n-            let retained = values\n-                .iter()\n-                .zip(targets.iter())\n-                .filter(|(_, &t)| !predicate(t))\n-                .collect::<Vec<_>>();\n-            let mut values = retained.iter().map(|&(v, _)| *v).collect::<Vec<_>>();\n-            let mut targets = retained.iter().map(|&(_, d)| *d).collect::<Vec<_>>();\n+            let (mut values, mut targets): (Vec<_>, Vec<_>) =\n+                values.iter().zip(targets.iter()).filter(|(_, &t)| !predicate(t)).unzip();\n \n             if !predicate(*otherwise) {\n                 targets.push(*otherwise);\n@@ -89,20 +84,21 @@ where\n             let retained_targets_len = targets.len();\n \n             if targets.is_empty() {\n-                Some(TerminatorKind::Unreachable)\n+                TerminatorKind::Unreachable\n             } else if targets.len() == 1 {\n-                Some(TerminatorKind::Goto { target: targets[0] })\n+                TerminatorKind::Goto { target: targets[0] }\n             } else if original_targets_len != retained_targets_len {\n-                Some(TerminatorKind::SwitchInt {\n+                TerminatorKind::SwitchInt {\n                     discr: discr.clone(),\n                     switch_ty,\n                     values: Cow::from(values),\n                     targets,\n-                })\n+                }\n             } else {\n-                None\n+                return None;\n             }\n         }\n-        _ => None,\n-    }\n+        _ => return None,\n+    };\n+    Some(terminator)\n }"}, {"sha": "c3dbac08ed800faa53580d697845f03e0cdc6c16", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -743,8 +743,8 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n         if let Some(&(tag, target_id)) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n             let j = i.bytes_usize();\n-            let offset =\n-                alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n+            let offset = alloc\n+                .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n             let relocation_width = |bytes| bytes * 3;\n@@ -803,7 +803,7 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n \n             // Checked definedness (and thus range) and relocations. This access also doesn't\n             // influence interpreter execution but is only for debugging.\n-            let c = alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + 1)[0];\n+            let c = alloc.inspect_with_uninit_and_ptr_outside_interpreter(j..j + 1)[0];\n             write!(w, \"{:02x}\", c)?;\n             if c.is_ascii_control() || c >= 0x80 {\n                 ascii.push('.');"}, {"sha": "215a0c7dfdf2712dbb1c6ad3909775e41d35b688", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::lang_items;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n@@ -798,22 +797,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         argument_scope: region::Scope,\n         ast_body: &'tcx hir::Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        let tcx = self.hir.tcx();\n-        let attrs = tcx.codegen_fn_attrs(fn_def_id);\n-        let naked = attrs.flags.contains(CodegenFnAttrFlags::NAKED);\n-\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n             let source_info =\n                 SourceInfo::outermost(arg_opt.map_or(self.fn_span, |arg| arg.pat.span));\n             let arg_local = self.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n \n-            // Emit function argument debuginfo only for non-naked functions.\n-            // See: https://github.com/rust-lang/rust/issues/42779\n-            if naked {\n-                continue;\n-            }\n-\n             // If this is a simple binding pattern, give debuginfo a nice name.\n             if let Some(arg) = arg_opt {\n                 if let Some(ident) = arg.pat.simple_ident() {\n@@ -826,6 +815,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n+        let tcx = self.hir.tcx();\n         let tcx_hir = tcx.hir();\n         let hir_typeck_results = self.hir.typeck_results();\n "}, {"sha": "8e2bee2646806c023dfbd5f889b4a7412c34135e", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -195,6 +195,29 @@ impl<'a> Parser<'a> {\n                     return Ok(expr);\n                 }\n             }\n+\n+            if (op.node == AssocOp::Equal || op.node == AssocOp::NotEqual)\n+                && self.token.kind == token::Eq\n+                && self.prev_token.span.hi() == self.token.span.lo()\n+            {\n+                // Look for JS' `===` and `!==` and recover \ud83d\ude07\n+                let sp = op.span.to(self.token.span);\n+                let sugg = match op.node {\n+                    AssocOp::Equal => \"==\",\n+                    AssocOp::NotEqual => \"!=\",\n+                    _ => unreachable!(),\n+                };\n+                self.struct_span_err(sp, &format!(\"invalid comparison operator `{}=`\", sugg))\n+                    .span_suggestion_short(\n+                        sp,\n+                        &format!(\"`{s}=` is not a valid comparison operator, use `{s}`\", s = sugg),\n+                        sugg.to_string(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+                self.bump();\n+            }\n+\n             let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n@@ -295,11 +318,18 @@ impl<'a> Parser<'a> {\n             // want to keep their span info to improve diagnostics in these cases in a later stage.\n             (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n             (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n             (true, Some(AssocOp::Add)) // `{ 42 } + 42\n             // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n             // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n+            if !self.look_ahead(1, |t| t.is_used_keyword()) => {\n+                // These cases are ambiguous and can't be identified in the parser alone.\n+                let sp = self.sess.source_map().start_point(self.token.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                false\n+            }\n+            (true, Some(AssocOp::LAnd)) => {\n+                // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`. Separated from the\n+                // above due to #74233.\n                 // These cases are ambiguous and can't be identified in the parser alone.\n                 let sp = self.sess.source_map().start_point(self.token.span);\n                 self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);"}, {"sha": "3ba5acd00a09a0dd92ac5cb03d66e1150d2ae6f5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -784,11 +784,18 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::OpaqueTy(..) => {\n-                // FIXME: This is some serious pessimization intended to workaround deficiencies\n-                // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n-                // reachable if they are returned via `impl Trait`, even from private functions.\n-                let exist_level = cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                self.reach(item.hir_id, exist_level).generics().predicates().ty();\n+                // HACK(jynelson): trying to infer the type of `impl trait` breaks `async-std` (and `pub async fn` in general)\n+                // Since rustdoc never need to do codegen and doesn't care about link-time reachability,\n+                // mark this as unreachable.\n+                // See https://github.com/rust-lang/rust/issues/75100\n+                if !self.tcx.sess.opts.actually_rustdoc {\n+                    // FIXME: This is some serious pessimization intended to workaround deficiencies\n+                    // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n+                    // reachable if they are returned via `impl Trait`, even from private functions.\n+                    let exist_level =\n+                        cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n+                    self.reach(item.hir_id, exist_level).generics().predicates().ty();\n+                }\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..)"}, {"sha": "c1ec452e001bb3a84c0575ed3f4ae7177f0c2525", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -15,6 +15,7 @@ log = { package = \"tracing\", version = \"0.1\" }\n rustc-rayon-core = \"0.3.0\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "e302784cc3e5fb5f78820d90b70ca436b0e700a1", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -50,7 +50,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n use std::hash::Hash;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub struct DepNode<K> {\n     pub kind: K,\n     pub hash: Fingerprint,\n@@ -152,7 +152,8 @@ impl<Ctxt: DepContext> DepNodeParams<Ctxt> for () {\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Encodable, Decodable)]\n pub struct WorkProductId {\n     hash: Fingerprint,\n }"}, {"sha": "d70306b4869218d9ecce39f793ad8e3dbeecd5a4", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -857,7 +857,7 @@ impl<K: DepKind> DepGraph<K> {\n /// may be added -- for example, new monomorphizations -- even if\n /// nothing in P changed!). We will compare that hash against the\n /// previous hash. If it matches up, we can reuse the object file.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Encodable, Decodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n     /// Saved file associated with this CGU."}, {"sha": "29357ce9449ce26f48df11c3ac0c12c743efa0a2", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,7 +3,7 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct PreviousDepGraph<K: DepKind> {\n     data: SerializedDepGraph<K>,\n     index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,"}, {"sha": "932c6d2a2f184260434bf38989fa5d9626f88dff", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,7 +9,7 @@ rustc_index::newtype_index! {\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n     pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,"}, {"sha": "db104398f16efa6bf00deb39e0dc8d1b45782752", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,6 +10,8 @@\n extern crate log;\n #[macro_use]\n extern crate rustc_data_structures;\n+#[macro_use]\n+extern crate rustc_macros;\n \n pub mod cache;\n pub mod dep_graph;"}, {"sha": "1839e1af45eeff7d004dc1bacc5efbacec42a89e", "filename": "src/librustc_query_system/query/caches.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fcaches.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -43,9 +43,8 @@ pub trait QueryCache: QueryStorage {\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n         OnMiss: FnOnce(Self::Key, QueryLookup<'_, CTX, Self::Key, Self::Sharded>) -> R;\n \n-    fn complete<CTX: QueryContext>(\n+    fn complete(\n         &self,\n-        tcx: CTX,\n         lock_sharded_storage: &mut Self::Sharded,\n         key: Self::Key,\n         value: Self::Value,\n@@ -112,9 +111,8 @@ impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n     }\n \n     #[inline]\n-    fn complete<CTX: QueryContext>(\n+    fn complete(\n         &self,\n-        _: CTX,\n         lock_sharded_storage: &mut Self::Sharded,\n         key: K,\n         value: V,\n@@ -195,9 +193,8 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V> {\n     }\n \n     #[inline]\n-    fn complete<CTX: QueryContext>(\n+    fn complete(\n         &self,\n-        _: CTX,\n         lock_sharded_storage: &mut Self::Sharded,\n         key: K,\n         value: V,"}, {"sha": "ae042cc808126bec5a2085fd74399789368d412a", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -264,7 +264,7 @@ where\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    fn complete(self, tcx: CTX, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored {\n+    fn complete(self, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n@@ -278,7 +278,7 @@ where\n                 QueryResult::Started(job) => job,\n                 QueryResult::Poisoned => panic!(),\n             };\n-            let result = state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n+            let result = state.cache.complete(&mut lock.cache, key, result, dep_node_index);\n             (job, result)\n         };\n \n@@ -432,7 +432,7 @@ where\n             tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n         }\n \n-        return job.complete(tcx, result, dep_node_index);\n+        return job.complete(result, dep_node_index);\n     }\n \n     let dep_node = query.to_dep_node(tcx, &key);\n@@ -458,7 +458,7 @@ where\n             })\n         });\n         if let Some((result, dep_node_index)) = loaded {\n-            return job.complete(tcx, result, dep_node_index);\n+            return job.complete(result, dep_node_index);\n         }\n     }\n \n@@ -609,7 +609,7 @@ where\n         }\n     }\n \n-    let result = job.complete(tcx, result, dep_node_index);\n+    let result = job.complete(result, dep_node_index);\n \n     (result, dep_node_index)\n }"}, {"sha": "de92204a7c2f07e33b875a264e12e33ce351f321", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -942,17 +942,6 @@ impl<'a> Resolver<'a> {\n             Some(suggestion) if suggestion.candidate == kw::Underscore => return false,\n             Some(suggestion) => suggestion,\n         };\n-        let msg = format!(\n-            \"{} {} with a similar name exists\",\n-            suggestion.res.article(),\n-            suggestion.res.descr()\n-        );\n-        err.span_suggestion(\n-            span,\n-            &msg,\n-            suggestion.candidate.to_string(),\n-            Applicability::MaybeIncorrect,\n-        );\n         let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n             LOCAL_CRATE => self.opt_span(def_id),\n             _ => Some(\n@@ -961,16 +950,48 @@ impl<'a> Resolver<'a> {\n                     .guess_head_span(self.cstore().get_span_untracked(def_id, self.session)),\n             ),\n         });\n-        if let Some(span) = def_span {\n+        if let Some(def_span) = def_span {\n+            if span.overlaps(def_span) {\n+                // Don't suggest typo suggestion for itself like in the followoing:\n+                // error[E0423]: expected function, tuple struct or tuple variant, found struct `X`\n+                //   --> $DIR/issue-64792-bad-unicode-ctor.rs:3:14\n+                //    |\n+                // LL | struct X {}\n+                //    | ----------- `X` defined here\n+                // LL |\n+                // LL | const Y: X = X(\"\u00f6\");\n+                //    | -------------^^^^^^- similarly named constant `Y` defined here\n+                //    |\n+                // help: use struct literal syntax instead\n+                //    |\n+                // LL | const Y: X = X {};\n+                //    |              ^^^^\n+                // help: a constant with a similar name exists\n+                //    |\n+                // LL | const Y: X = Y(\"\u00f6\");\n+                //    |              ^\n+                return false;\n+            }\n             err.span_label(\n-                self.session.source_map().guess_head_span(span),\n+                self.session.source_map().guess_head_span(def_span),\n                 &format!(\n                     \"similarly named {} `{}` defined here\",\n                     suggestion.res.descr(),\n                     suggestion.candidate.as_str(),\n                 ),\n             );\n         }\n+        let msg = format!(\n+            \"{} {} with a similar name exists\",\n+            suggestion.res.article(),\n+            suggestion.res.descr()\n+        );\n+        err.span_suggestion(\n+            span,\n+            &msg,\n+            suggestion.candidate.to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n         true\n     }\n "}, {"sha": "b3746ac2db2bdd36b863d322bed176933e9b7633", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 241, "deletions": 43, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -7,17 +7,18 @@ use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::ast::{self, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use log::debug;\n \n@@ -33,6 +34,7 @@ enum AssocSuggestion {\n crate enum MissingLifetimeSpot<'tcx> {\n     Generics(&'tcx hir::Generics<'tcx>),\n     HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n+    Static,\n }\n \n crate enum ForLifetimeSpanType {\n@@ -88,6 +90,18 @@ fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, Str\n }\n \n impl<'a> LateResolutionVisitor<'a, '_, '_> {\n+    fn def_span(&self, def_id: DefId) -> Option<Span> {\n+        match def_id.krate {\n+            LOCAL_CRATE => self.r.opt_span(def_id),\n+            _ => Some(\n+                self.r\n+                    .session\n+                    .source_map()\n+                    .guess_head_span(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n+            ),\n+        }\n+    }\n+\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n     pub(crate) fn smart_resolve_report_errors(\n@@ -162,16 +176,40 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         let code = source.error_code(res.is_some());\n         let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n+        let is_assoc_fn = self.self_type_is_available(span);\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-            && self.self_value_is_available(path[0].ident.span, span)\n-        {\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n                 span,\n                 \"you might have meant to use `self` here instead\",\n                 \"self\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n+            if !self.self_value_is_available(path[0].ident.span, span) {\n+                if let Some((FnKind::Fn(_, _, sig, ..), fn_span)) =\n+                    &self.diagnostic_metadata.current_function\n+                {\n+                    let (span, sugg) = if let Some(param) = sig.decl.inputs.get(0) {\n+                        (param.span.shrink_to_lo(), \"&self, \")\n+                    } else {\n+                        (\n+                            self.r\n+                                .session\n+                                .source_map()\n+                                .span_through_char(*fn_span, '(')\n+                                .shrink_to_hi(),\n+                            \"&self\",\n+                        )\n+                    };\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"if you meant to use `self`, you are also missing a `self` receiver \\\n+                         argument\",\n+                        sugg.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n         }\n \n         // Emit special messages for unresolved `Self` and `self`.\n@@ -200,7 +238,38 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 if fn_kind.decl().inputs.get(0).map(|p| p.is_self()).unwrap_or(false) {\n                     err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n                 } else {\n-                    err.span_label(*span, \"this function doesn't have a `self` parameter\");\n+                    let doesnt = if is_assoc_fn {\n+                        let (span, sugg) = fn_kind\n+                            .decl()\n+                            .inputs\n+                            .get(0)\n+                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                            .unwrap_or_else(|| {\n+                                (\n+                                    self.r\n+                                        .session\n+                                        .source_map()\n+                                        .span_through_char(*span, '(')\n+                                        .shrink_to_hi(),\n+                                    \"&self\",\n+                                )\n+                            });\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        \"doesn't\"\n+                    } else {\n+                        \"can't\"\n+                    };\n+                    if let Some(ident) = fn_kind.ident() {\n+                        err.span_label(\n+                            ident.span,\n+                            &format!(\"this function {} have a `self` parameter\", doesnt),\n+                        );\n+                    }\n                 }\n             }\n             return (err, Vec::new());\n@@ -339,8 +408,6 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n \n         // Try Levenshtein algorithm.\n         let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected, span);\n-        let levenshtein_worked = self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-\n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n@@ -351,14 +418,18 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 &path_str,\n                 &fallback_label,\n             ) {\n+                // We do this to avoid losing a secondary span when we override the main error span.\n+                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n                 return (err, candidates);\n             }\n         }\n \n-        // Fallback label.\n-        if !levenshtein_worked {\n+        if !self.type_ascription_suggestion(&mut err, base_span)\n+            && !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span)\n+        {\n+            // Fallback label.\n             err.span_label(base_span, fallback_label);\n-            self.type_ascription_suggestion(&mut err, base_span);\n+\n             match self.diagnostic_metadata.current_let_binding {\n                 Some((pat_sp, Some(ty_sp), None)) if ty_sp.contains(base_span) && could_be_expr => {\n                     err.span_suggestion_short(\n@@ -378,15 +449,15 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n     /// return the span of whole call and the span for all arguments expect the first one (`self`).\n     fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {\n         let mut has_self_arg = None;\n-        if let PathSource::Expr(parent) = source {\n-            match &parent?.kind {\n+        if let PathSource::Expr(Some(parent)) = source {\n+            match &parent.kind {\n                 ExprKind::Call(_, args) if !args.is_empty() => {\n                     let mut expr_kind = &args[0].kind;\n                     loop {\n                         match expr_kind {\n                             ExprKind::Path(_, arg_name) if arg_name.segments.len() == 1 => {\n                                 if arg_name.segments[0].ident.name == kw::SelfLower {\n-                                    let call_span = parent.unwrap().span;\n+                                    let call_span = parent.span;\n                                     let tail_args_span = if args.len() > 1 {\n                                         Some(Span::new(\n                                             args[1].span.lo(),\n@@ -518,6 +589,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                     }),\n                 ) if followed_by_brace => {\n                     if let Some(sp) = closing_brace {\n+                        err.span_label(span, fallback_label);\n                         err.multipart_suggestion(\n                             \"surround the struct literal with parentheses\",\n                             vec![\n@@ -550,7 +622,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         }\n                         _ => span,\n                     };\n-                    if let Some(span) = self.r.opt_span(def_id) {\n+                    if let Some(span) = self.def_span(def_id) {\n                         err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                     }\n                     let (tail, descr, applicability) = match source {\n@@ -581,12 +653,15 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         applicability,\n                     );\n                 }\n-                _ => {}\n+                _ => {\n+                    err.span_label(span, fallback_label);\n+                }\n             }\n         };\n \n         match (res, source) {\n             (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n+                err.span_label(span, fallback_label);\n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n                     \"use `!` to invoke the macro\",\n@@ -602,7 +677,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 if nightly_options::is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n-                    if let Some(span) = self.r.opt_span(def_id) {\n+                    if let Some(span) = self.def_span(def_id) {\n                         err.span_help(span, msg);\n                     } else {\n                         err.help(msg);\n@@ -680,10 +755,19 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 bad_struct_syntax_suggestion(def_id);\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), def_id), _) if ns == ValueNS => {\n-                if let Some(span) = self.r.opt_span(def_id) {\n+                if let Some(span) = self.def_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n-                err.span_label(span, format!(\"did you mean `{}( /* fields */ )`?\", path_str));\n+                let fields =\n+                    self.r.field_names.get(&def_id).map_or(\"/* fields */\".to_string(), |fields| {\n+                        vec![\"_\"; fields.len()].join(\", \")\n+                    });\n+                err.span_suggestion(\n+                    span,\n+                    \"use the tuple variant pattern syntax instead\",\n+                    format!(\"{}({})\", path_str, fields),\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n             (Res::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);\n@@ -869,7 +953,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         start.to(sm.next_point(start))\n     }\n \n-    fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) {\n+    fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) -> bool {\n         let sm = self.r.session.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n@@ -939,9 +1023,11 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                             \"expecting a type here because of type ascription\",\n                         );\n                     }\n+                    return show_label;\n                 }\n             }\n         }\n+        false\n     }\n \n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n@@ -1166,6 +1252,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n                     );\n                 }\n+                _ => {}\n             }\n         }\n         if nightly_options::is_nightly_build()\n@@ -1224,7 +1311,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         count: usize,\n-        lifetime_names: &FxHashSet<Ident>,\n+        lifetime_names: &FxHashSet<Symbol>,\n+        lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n@@ -1238,11 +1326,60 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ),\n         );\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n+                                name: &str,\n+                                formatter: &dyn Fn(&str) -> String| {\n+            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                self.missing_named_lifetime_spots.iter().rev().next()\n+            {\n+                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                let mut introduce_suggestion = vec![];\n+\n+                let a_to_z_repeat_n = |n| {\n+                    (b'a'..=b'z').map(move |c| {\n+                        let mut s = '\\''.to_string();\n+                        s.extend(std::iter::repeat(char::from(c)).take(n));\n+                        s\n+                    })\n+                };\n+\n+                // If all single char lifetime names are present, we wrap around and double the chars.\n+                let lt_name = (1..)\n+                    .flat_map(a_to_z_repeat_n)\n+                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                    .unwrap();\n+                let msg = format!(\n+                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                    span_type.descr(),\n+                    lt_name,\n+                );\n+                err.note(\n+                    \"for more information on higher-ranked polymorphism, visit \\\n+                    https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                );\n+                let for_sugg = span_type.suggestion(&lt_name);\n+                for param in params {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n+                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                        } else if snippet.starts_with(\"&'_ \") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[4..])));\n+                        }\n+                    }\n+                }\n+                introduce_suggestion.push((*for_span, for_sugg.to_string()));\n+                introduce_suggestion.push((span, formatter(&lt_name)));\n+                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+            }\n+\n             err.span_suggestion_verbose(\n                 span,\n                 &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                sugg,\n+                formatter(name),\n                 Applicability::MaybeIncorrect,\n             );\n         };\n@@ -1253,6 +1390,15 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 let should_break;\n                 introduce_suggestion.push(match missing {\n                     MissingLifetimeSpot::Generics(generics) => {\n+                        if generics.span == DUMMY_SP {\n+                            // Account for malformed generics in the HIR. This shouldn't happen,\n+                            // but if we make a mistake elsewhere, mainly by keeping something in\n+                            // `missing_named_lifetime_spots` that we shouldn't, like associated\n+                            // `const`s or making a mistake in the AST lowering we would provide\n+                            // non-sensical suggestions. Guard against that by skipping these.\n+                            // (#74264)\n+                            continue;\n+                        }\n                         msg = \"consider introducing a named lifetime parameter\".to_string();\n                         should_break = true;\n                         if let Some(param) = generics.params.iter().find(|p| match p.kind {\n@@ -1279,6 +1425,42 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         );\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n+                    MissingLifetimeSpot::Static => {\n+                        let (span, sugg) = match snippet.as_deref() {\n+                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                            Some(\"'_\") => (span, \"'static\".to_owned()),\n+                            Some(snippet) if !snippet.ends_with('>') => {\n+                                if snippet == \"\" {\n+                                    (\n+                                        span,\n+                                        std::iter::repeat(\"'static\")\n+                                            .take(count)\n+                                            .collect::<Vec<_>>()\n+                                            .join(\", \"),\n+                                    )\n+                                } else {\n+                                    (\n+                                        span.shrink_to_hi(),\n+                                        format!(\n+                                            \"<{}>\",\n+                                            std::iter::repeat(\"'static\")\n+                                                .take(count)\n+                                                .collect::<Vec<_>>()\n+                                                .join(\", \")\n+                                        ),\n+                                    )\n+                                }\n+                            }\n+                            _ => continue,\n+                        };\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"consider using the `'static` lifetime\",\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        continue;\n+                    }\n                 });\n                 for param in params {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n@@ -1299,41 +1481,57 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             }\n         };\n \n-        match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n-            (1, Some(name), Some(\"&\")) => {\n-                suggest_existing(err, format!(\"&{} \", name));\n+        let lifetime_names: Vec<_> = lifetime_names.into_iter().collect();\n+        match (&lifetime_names[..], snippet.as_deref()) {\n+            ([name], Some(\"&\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n             }\n-            (1, Some(name), Some(\"'_\")) => {\n-                suggest_existing(err, name.to_string());\n+            ([name], Some(\"'_\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n             }\n-            (1, Some(name), Some(\"\")) => {\n-                suggest_existing(err, format!(\"{}, \", name).repeat(count));\n+            ([name], Some(\"\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n             }\n-            (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n-                suggest_existing(\n-                    err,\n+            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n+                let f = |name: &str| {\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n                         std::iter::repeat(name.to_string())\n                             .take(count)\n                             .collect::<Vec<_>>()\n                             .join(\", \")\n-                    ),\n-                );\n+                    )\n+                };\n+                suggest_existing(err, &name.as_str()[..], &f);\n             }\n-            (0, _, Some(\"&\")) if count == 1 => {\n+            ([], Some(\"&\")) if count == 1 => {\n                 suggest_new(err, \"&'a \");\n             }\n-            (0, _, Some(\"'_\")) if count == 1 => {\n+            ([], Some(\"'_\")) if count == 1 => {\n                 suggest_new(err, \"'a\");\n             }\n-            (0, _, Some(snippet)) if !snippet.ends_with('>') && count == 1 => {\n-                suggest_new(err, &format!(\"{}<'a>\", snippet));\n+            ([], Some(snippet)) if !snippet.ends_with('>') => {\n+                if snippet == \"\" {\n+                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n+                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n+                    suggest_new(\n+                        err,\n+                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n+                    );\n+                } else {\n+                    suggest_new(\n+                        err,\n+                        &format!(\n+                            \"{}<{}>\",\n+                            snippet,\n+                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n+                        ),\n+                    );\n+                }\n             }\n-            (n, ..) if n > 1 => {\n-                let spans: Vec<Span> = lifetime_names.iter().map(|lt| lt.span).collect();\n-                err.span_note(spans, \"these named lifetimes are available to use\");\n+            (lts, ..) if lts.len() > 1 => {\n+                err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n                 if Some(\"\") == snippet.as_deref() {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders."}, {"sha": "2046419d984d0fd0be20c2e0fb0fe87f793cb2a2", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -711,18 +711,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n-        self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n         match trait_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Type(bounds, ref ty) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -757,31 +759,35 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     }\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_trait_item(self, trait_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n-        self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n         match impl_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n-                )\n+                );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n+                self.missing_named_lifetime_spots.push(generics.into());\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -810,14 +816,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_impl_item(self, impl_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n@@ -2315,6 +2323,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n+        let mut lifetime_spans = vec![];\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2326,7 +2335,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(*name);\n+                            lifetime_names.insert(name.name);\n+                            lifetime_spans.push(name.span);\n                         }\n                     }\n                     late_depth += 1;\n@@ -2344,12 +2354,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n                         Elide::Error(ref e) => {\n-                            if let Scope::Binder { ref lifetimes, .. } = s {\n-                                // collect named lifetimes for suggestions\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(*name);\n+                            let mut scope = s;\n+                            loop {\n+                                match scope {\n+                                    Scope::Binder { ref lifetimes, s, .. } => {\n+                                        // Collect named lifetimes for suggestions.\n+                                        for name in lifetimes.keys() {\n+                                            if let hir::ParamName::Plain(name) = name {\n+                                                lifetime_names.insert(name.name);\n+                                                lifetime_spans.push(name.span);\n+                                            }\n+                                        }\n+                                        scope = s;\n+                                    }\n+                                    Scope::ObjectLifetimeDefault { ref s, .. }\n+                                    | Scope::Elision { ref s, .. } => {\n+                                        scope = s;\n                                     }\n+                                    _ => break,\n                                 }\n                             }\n                             break Some(e);\n@@ -2373,14 +2395,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(Ident::with_dummy_span(kw::StaticLifetime));\n+                lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             span,\n             lifetime_refs.len(),\n             &lifetime_names,\n+            lifetime_spans,\n             error.map(|p| &p[..]).unwrap_or(&[]),\n         );\n         err.emit();"}, {"sha": "939e6a59ba0990e99bd9d0c6e90e5b2853228fe3", "filename": "src/librustc_serialize/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -11,3 +11,6 @@ path = \"lib.rs\"\n [dependencies]\n indexmap = \"1\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+\n+[dev-dependencies]\n+rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "3d274cb01507b004bcde7191709a66c6c6bb4ed4", "filename": "src/librustc_serialize/collection_impls.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fcollection_impls.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,8 +9,8 @@ use std::sync::Arc;\n \n use smallvec::{Array, SmallVec};\n \n-impl<A: Array<Item: Encodable>> Encodable for SmallVec<A> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -20,8 +20,8 @@ impl<A: Array<Item: Encodable>> Encodable for SmallVec<A> {\n     }\n }\n \n-impl<A: Array<Item: Decodable>> Decodable for SmallVec<A> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n+impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n+    fn decode(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = SmallVec::with_capacity(len);\n             // FIXME(#48994) - could just be collected into a Result<SmallVec, D::Error>\n@@ -33,8 +33,8 @@ impl<A: Array<Item: Decodable>> Decodable for SmallVec<A> {\n     }\n }\n \n-impl<T: Encodable> Encodable for LinkedList<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -44,8 +44,8 @@ impl<T: Encodable> Encodable for LinkedList<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for LinkedList<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n+    fn decode(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n             for i in 0..len {\n@@ -56,8 +56,8 @@ impl<T: Decodable> Decodable for LinkedList<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for VecDeque<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -67,8 +67,8 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for VecDeque<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n+    fn decode(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n             for i in 0..len {\n@@ -79,30 +79,28 @@ impl<T: Decodable> Decodable for VecDeque<T> {\n     }\n }\n \n-impl<K, V> Encodable for BTreeMap<K, V>\n+impl<S: Encoder, K, V> Encodable<S> for BTreeMap<K, V>\n where\n-    K: Encodable + PartialEq + Ord,\n-    V: Encodable,\n+    K: Encodable<S> + PartialEq + Ord,\n+    V: Encodable<S>,\n {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<K, V> Decodable for BTreeMap<K, V>\n+impl<D: Decoder, K, V> Decodable<D> for BTreeMap<K, V>\n where\n-    K: Decodable + PartialEq + Ord,\n-    V: Decodable,\n+    K: Decodable<D> + PartialEq + Ord,\n+    V: Decodable<D>,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n+    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n             for i in 0..len {\n@@ -115,27 +113,25 @@ where\n     }\n }\n \n-impl<T> Encodable for BTreeSet<T>\n+impl<S: Encoder, T> Encodable<S> for BTreeSet<T>\n where\n-    T: Encodable + PartialEq + Ord,\n+    T: Encodable<S> + PartialEq + Ord,\n {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<T> Decodable for BTreeSet<T>\n+impl<D: Decoder, T> Decodable<D> for BTreeSet<T>\n where\n-    T: Decodable + PartialEq + Ord,\n+    T: Decodable<D> + PartialEq + Ord,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n+    fn decode(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n             for i in 0..len {\n@@ -146,32 +142,30 @@ where\n     }\n }\n \n-impl<K, V, S> Encodable for HashMap<K, V, S>\n+impl<E: Encoder, K, V, S> Encodable<E> for HashMap<K, V, S>\n where\n-    K: Encodable + Eq,\n-    V: Encodable,\n+    K: Encodable<E> + Eq,\n+    V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<K, V, S> Decodable for HashMap<K, V, S>\n+impl<D: Decoder, K, V, S> Decodable<D> for HashMap<K, V, S>\n where\n-    K: Decodable + Hash + Eq,\n-    V: Decodable,\n+    K: Decodable<D> + Hash + Eq,\n+    V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n@@ -185,29 +179,37 @@ where\n     }\n }\n \n-impl<T, S> Encodable for HashSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for HashSet<T, S>\n where\n-    T: Encodable + Eq,\n+    T: Encodable<E> + Eq,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<T, S> Decodable for HashSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for &HashSet<T, S>\n where\n-    T: Decodable + Hash + Eq,\n+    T: Encodable<E> + Eq,\n+    S: BuildHasher,\n+{\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<D: Decoder, T, S> Decodable<D> for HashSet<T, S>\n+where\n+    T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n@@ -219,32 +221,30 @@ where\n     }\n }\n \n-impl<K, V, S> Encodable for indexmap::IndexMap<K, V, S>\n+impl<E: Encoder, K, V, S> Encodable<E> for indexmap::IndexMap<K, V, S>\n where\n-    K: Encodable + Hash + Eq,\n-    V: Encodable,\n+    K: Encodable<E> + Hash + Eq,\n+    V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n+            for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n                 e.emit_map_elt_val(i, |e| val.encode(e))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<K, V, S> Decodable for indexmap::IndexMap<K, V, S>\n+impl<D: Decoder, K, V, S> Decodable<D> for indexmap::IndexMap<K, V, S>\n where\n-    K: Decodable + Hash + Eq,\n-    V: Decodable,\n+    K: Decodable<D> + Hash + Eq,\n+    V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n@@ -258,29 +258,27 @@ where\n     }\n }\n \n-impl<T, S> Encodable for indexmap::IndexSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for indexmap::IndexSet<T, S>\n where\n-    T: Encodable + Hash + Eq,\n+    T: Encodable<E> + Hash + Eq,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n+            for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n-                i += 1;\n             }\n             Ok(())\n         })\n     }\n }\n \n-impl<T, S> Decodable for indexmap::IndexSet<T, S>\n+impl<D: Decoder, T, S> Decodable<D> for indexmap::IndexSet<T, S>\n where\n-    T: Decodable + Hash + Eq,\n+    T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n@@ -292,8 +290,8 @@ where\n     }\n }\n \n-impl<T: Encodable> Encodable for Rc<[T]> {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+impl<E: Encoder, T: Encodable<E>> Encodable<E> for Rc<[T]> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(index, |s| e.encode(s))?;\n@@ -303,8 +301,8 @@ impl<T: Encodable> Encodable for Rc<[T]> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Rc<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<[T]> {\n+    fn decode(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n             for index in 0..len {\n@@ -315,8 +313,8 @@ impl<T: Decodable> Decodable for Rc<[T]> {\n     }\n }\n \n-impl<T: Encodable> Encodable for Arc<[T]> {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+impl<E: Encoder, T: Encodable<E>> Encodable<E> for Arc<[T]> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(index, |s| e.encode(s))?;\n@@ -326,8 +324,8 @@ impl<T: Encodable> Encodable for Arc<[T]> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Arc<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<[T]> {\n+    fn decode(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n             for index in 0..len {"}, {"sha": "6c8965aa2e31f92bac37026d419bac493c67b6be", "filename": "src/librustc_serialize/json.rs", "status": "modified", "additions": 54, "deletions": 69, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fjson.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -47,17 +47,17 @@\n //!\n //! Rust provides a mechanism for low boilerplate encoding & decoding of values to and from JSON via\n //! the serialization API.\n-//! To be able to encode a piece of data, it must implement the `serialize::RustcEncodable` trait.\n-//! To be able to decode a piece of data, it must implement the `serialize::RustcDecodable` trait.\n+//! To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n+//! To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n //! The Rust compiler provides an annotation to automatically generate the code for these traits:\n-//! `#[derive(RustcDecodable, RustcEncodable)]`\n+//! `#[derive(Decodable, Encodable)]`\n //!\n //! The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n //! The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n //! A `json::Json` value can be encoded as a string or buffer using the functions described above.\n //! You can also use the `json::Encoder` object, which implements the `Encoder` trait.\n //!\n-//! When using `ToJson` the `RustcEncodable` trait implementation is not mandatory.\n+//! When using `ToJson` the `Encodable` trait implementation is not mandatory.\n //!\n //! # Examples of use\n //!\n@@ -68,29 +68,28 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n+//! use rustc_macros::{Decodable, Encodable};\n //! use rustc_serialize::json;\n //!\n //! // Automatically generate `Decodable` and `Encodable` trait implementations\n-//! #[derive(RustcDecodable, RustcEncodable)]\n+//! #[derive(Decodable, Encodable)]\n //! pub struct TestStruct  {\n //!     data_int: u8,\n //!     data_str: String,\n //!     data_vector: Vec<u8>,\n //! }\n //!\n-//! fn main() {\n-//!     let object = TestStruct {\n-//!         data_int: 1,\n-//!         data_str: \"homura\".to_string(),\n-//!         data_vector: vec![2,3,4,5],\n-//!     };\n+//! let object = TestStruct {\n+//!     data_int: 1,\n+//!     data_str: \"homura\".to_string(),\n+//!     data_vector: vec![2,3,4,5],\n+//! };\n //!\n-//!     // Serialize using `json::encode`\n-//!     let encoded = json::encode(&object).unwrap();\n+//! // Serialize using `json::encode`\n+//! let encoded = json::encode(&object).unwrap();\n //!\n-//!     // Deserialize using `json::decode`\n-//!     let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n-//! }\n+//! // Deserialize using `json::decode`\n+//! let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n //! ```\n //!\n //! ## Using the `ToJson` trait\n@@ -102,6 +101,7 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n+//! use rustc_macros::Encodable;\n //! use rustc_serialize::json::{self, ToJson, Json};\n //!\n //! // A custom data structure\n@@ -117,35 +117,34 @@\n //!     }\n //! }\n //!\n-//! // Only generate `RustcEncodable` trait implementation\n-//! #[derive(RustcEncodable)]\n+//! // Only generate `Encodable` trait implementation\n+//! #[derive(Encodable)]\n //! pub struct ComplexNumRecord {\n //!     uid: u8,\n //!     dsc: String,\n //!     val: Json,\n //! }\n //!\n-//! fn main() {\n-//!     let num = ComplexNum { a: 0.0001, b: 12.539 };\n-//!     let data: String = json::encode(&ComplexNumRecord{\n-//!         uid: 1,\n-//!         dsc: \"test\".to_string(),\n-//!         val: num.to_json(),\n-//!     }).unwrap();\n-//!     println!(\"data: {}\", data);\n-//!     // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n-//! }\n+//! let num = ComplexNum { a: 0.0001, b: 12.539 };\n+//! let data: String = json::encode(&ComplexNumRecord{\n+//!     uid: 1,\n+//!     dsc: \"test\".to_string(),\n+//!     val: num.to_json(),\n+//! }).unwrap();\n+//! println!(\"data: {}\", data);\n+//! // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n //! ```\n //!\n //! ### Verbose example of `ToJson` usage\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n+//! use rustc_macros::Decodable;\n //! use std::collections::BTreeMap;\n //! use rustc_serialize::json::{self, Json, ToJson};\n //!\n-//! // Only generate `RustcDecodable` trait implementation\n-//! #[derive(RustcDecodable)]\n+//! // Only generate `Decodable` trait implementation\n+//! #[derive(Decodable)]\n //! pub struct TestStruct {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -164,19 +163,17 @@\n //!     }\n //! }\n //!\n-//! fn main() {\n-//!     // Serialize using `ToJson`\n-//!     let input_data = TestStruct {\n-//!         data_int: 1,\n-//!         data_str: \"madoka\".to_string(),\n-//!         data_vector: vec![2,3,4,5],\n-//!     };\n-//!     let json_obj: Json = input_data.to_json();\n-//!     let json_str: String = json_obj.to_string();\n+//! // Serialize using `ToJson`\n+//! let input_data = TestStruct {\n+//!     data_int: 1,\n+//!     data_str: \"madoka\".to_string(),\n+//!     data_vector: vec![2,3,4,5],\n+//! };\n+//! let json_obj: Json = input_data.to_json();\n+//! let json_str: String = json_obj.to_string();\n //!\n-//!     // Deserialize like before\n-//!     let decoded: TestStruct = json::decode(&json_str).unwrap();\n-//! }\n+//! // Deserialize like before\n+//! let decoded: TestStruct = json::decode(&json_str).unwrap();\n //! ```\n \n use self::DecoderError::*;\n@@ -298,7 +295,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e)),\n@@ -309,7 +306,9 @@ pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: crate::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n+pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n+    object: &T,\n+) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -1150,8 +1149,8 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     }\n }\n \n-impl Encodable for Json {\n-    fn encode<E: crate::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+impl<E: crate::Encoder> Encodable<E> for Json {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -1269,34 +1268,22 @@ impl Json {\n \n     /// Returns `true` if the Json value is a `Number`.\n     pub fn is_number(&self) -> bool {\n-        match *self {\n-            Json::I64(_) | Json::U64(_) | Json::F64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::I64(_) | Json::U64(_) | Json::F64(_))\n     }\n \n     /// Returns `true` if the Json value is a `i64`.\n     pub fn is_i64(&self) -> bool {\n-        match *self {\n-            Json::I64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::I64(_))\n     }\n \n     /// Returns `true` if the Json value is a `u64`.\n     pub fn is_u64(&self) -> bool {\n-        match *self {\n-            Json::U64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::U64(_))\n     }\n \n     /// Returns `true` if the Json value is a `f64`.\n     pub fn is_f64(&self) -> bool {\n-        match *self {\n-            Json::F64(_) => true,\n-            _ => false,\n-        }\n+        matches!(*self, Json::F64(_))\n     }\n \n     /// If the Json value is a number, returns or cast it to a `i64`;\n@@ -1416,6 +1403,7 @@ enum ParserState {\n /// structure of the JSON stream.\n ///\n /// An example is `foo.bar[3].x`.\n+#[derive(Default)]\n pub struct Stack {\n     stack: Vec<InternalStackElement>,\n     str_buffer: Vec<u8>,\n@@ -1442,7 +1430,7 @@ enum InternalStackElement {\n \n impl Stack {\n     pub fn new() -> Stack {\n-        Stack { stack: Vec::new(), str_buffer: Vec::new() }\n+        Self::default()\n     }\n \n     /// Returns The number of elements in the Stack.\n@@ -1547,10 +1535,7 @@ impl Stack {\n \n     // Used by Parser to test whether the top-most element is an index.\n     fn last_is_index(&self) -> bool {\n-        match self.stack.last() {\n-            Some(InternalIndex(_)) => true,\n-            _ => false,\n-        }\n+        matches!(self.stack.last(), Some(InternalIndex(_)))\n     }\n \n     // Used by Parser to increment the index of the top-most element.\n@@ -2747,7 +2732,7 @@ impl<'a> fmt::Display for PrettyJson<'a> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n+impl<'a, T: for<'r> Encodable<Encoder<'r>>> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2767,7 +2752,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n+impl<'a, T: for<'x> Encodable<PrettyEncoder<'x>>> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };"}, {"sha": "265b3b95e956a9c0e9505cd3ab71be6cff89c26e", "filename": "src/librustc_serialize/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,7 +10,6 @@ Core encoding and decoding interfaces.\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(box_syntax)]\n-#![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n@@ -19,9 +18,6 @@ Core encoding and decoding interfaces.\n \n pub use self::serialize::{Decodable, Decoder, Encodable, Encoder};\n \n-pub use self::serialize::{SpecializationError, SpecializedDecoder, SpecializedEncoder};\n-pub use self::serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n-\n mod collection_impls;\n mod serialize;\n "}, {"sha": "fa4423e261d1c98ccaf8e2494969cce8a300038e", "filename": "src/librustc_serialize/opaque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fopaque.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -118,13 +118,13 @@ impl serialize::Encoder for Encoder {\n \n     #[inline]\n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        let as_u64: u64 = unsafe { ::std::mem::transmute(v) };\n+        let as_u64: u64 = v.to_bits();\n         self.emit_u64(as_u64)\n     }\n \n     #[inline]\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        let as_u32: u32 = unsafe { ::std::mem::transmute(v) };\n+        let as_u32: u32 = v.to_bits();\n         self.emit_u32(as_u32)\n     }\n "}, {"sha": "c0e23b89a60df3bc1cf64954116e18c931cb9c46", "filename": "src/librustc_serialize/serialize.rs", "status": "modified", "additions": 139, "deletions": 366, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fserialize.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -4,7 +4,6 @@\n Core encoding and decoding interfaces.\n */\n \n-use std::any;\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n@@ -380,282 +379,155 @@ pub trait Decoder {\n     fn error(&mut self, err: &str) -> Self::Error;\n }\n \n-pub trait Encodable {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;\n-}\n-\n-pub trait Decodable: Sized {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n-}\n-\n-impl Encodable for usize {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(*self)\n-    }\n-}\n-\n-impl Decodable for usize {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n-        d.read_usize()\n-    }\n-}\n-\n-impl Encodable for u8 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u8(*self)\n-    }\n-}\n-\n-impl Decodable for u8 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> {\n-        d.read_u8()\n-    }\n-}\n-\n-impl Encodable for u16 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u16(*self)\n-    }\n-}\n-\n-impl Decodable for u16 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> {\n-        d.read_u16()\n-    }\n-}\n-\n-impl Encodable for u32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(*self)\n-    }\n+/// Trait for types that can be serialized\n+///\n+/// This can be implemented using the `Encodable`, `TyEncodable` and\n+/// `MetadataEncodable` macros.\n+///\n+/// * `Encodable` should be used in crates that don't depend on\n+///   `rustc_middle`.\n+/// * `MetadataEncodable` is used in `rustc_metadata` for types that contain\n+///   `rustc_metadata::rmeta::Lazy`.\n+/// * `TyEncodable` should be used for types that are only serialized in crate\n+///   metadata or the incremental cache. This is most types in `rustc_middle`.\n+pub trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n }\n \n-impl Decodable for u32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> {\n-        d.read_u32()\n-    }\n-}\n+/// Trait for types that can be deserialized\n+///\n+/// This can be implemented using the `Decodable`, `TyDecodable` and\n+/// `MetadataDecodable` macros.\n+///\n+/// * `Decodable` should be used in crates that don't depend on\n+///   `rustc_middle`.\n+/// * `MetadataDecodable` is used in `rustc_metadata` for types that contain\n+///   `rustc_metadata::rmeta::Lazy`.\n+/// * `TyDecodable` should be used for types that are only serialized in crate\n+///   metadata or the incremental cache. This is most types in `rustc_middle`.\n+pub trait Decodable<D: Decoder>: Sized {\n+    fn decode(d: &mut D) -> Result<Self, D::Error>;\n+}\n+\n+macro_rules! direct_serialize_impls {\n+    ($($ty:ident $emit_method:ident $read_method:ident),*) => {\n+        $(\n+            impl<S: Encoder> Encodable<S> for $ty {\n+                fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+                    s.$emit_method(*self)\n+                }\n+            }\n \n-impl Encodable for ::std::num::NonZeroU32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+            impl<D: Decoder> Decodable<D> for $ty {\n+                fn decode(d: &mut D) -> Result<$ty, D::Error> {\n+                    d.$read_method()\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+direct_serialize_impls! {\n+    usize emit_usize read_usize,\n+    u8 emit_u8 read_u8,\n+    u16 emit_u16 read_u16,\n+    u32 emit_u32 read_u32,\n+    u64 emit_u64 read_u64,\n+    u128 emit_u128 read_u128,\n+    isize emit_isize read_isize,\n+    i8 emit_i8 read_i8,\n+    i16 emit_i16 read_i16,\n+    i32 emit_i32 read_i32,\n+    i64 emit_i64 read_i64,\n+    i128 emit_i128 read_i128,\n+    f32 emit_f32 read_f32,\n+    f64 emit_f64 read_f64,\n+    bool emit_bool read_bool,\n+    char emit_char read_char\n+}\n+\n+impl<S: Encoder> Encodable<S> for ::std::num::NonZeroU32 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(self.get())\n     }\n }\n \n-impl Decodable for ::std::num::NonZeroU32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+impl<D: Decoder> Decodable<D> for ::std::num::NonZeroU32 {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         d.read_u32().map(|d| ::std::num::NonZeroU32::new(d).unwrap())\n     }\n }\n \n-impl Encodable for u64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u64(*self)\n-    }\n-}\n-\n-impl Decodable for u64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> {\n-        d.read_u64()\n-    }\n-}\n-\n-impl Encodable for u128 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u128(*self)\n-    }\n-}\n-\n-impl Decodable for u128 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n-        d.read_u128()\n-    }\n-}\n-\n-impl Encodable for isize {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_isize(*self)\n-    }\n-}\n-\n-impl Decodable for isize {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n-        d.read_isize()\n-    }\n-}\n-\n-impl Encodable for i8 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_i8(*self)\n-    }\n-}\n-\n-impl Decodable for i8 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> {\n-        d.read_i8()\n-    }\n-}\n-\n-impl Encodable for i16 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_i16(*self)\n-    }\n-}\n-\n-impl Decodable for i16 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> {\n-        d.read_i16()\n-    }\n-}\n-\n-impl Encodable for i32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_i32(*self)\n-    }\n-}\n-\n-impl Decodable for i32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> {\n-        d.read_i32()\n-    }\n-}\n-\n-impl Encodable for i64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_i64(*self)\n-    }\n-}\n-\n-impl Decodable for i64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> {\n-        d.read_i64()\n-    }\n-}\n-\n-impl Encodable for i128 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_i128(*self)\n-    }\n-}\n-\n-impl Decodable for i128 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n-        d.read_i128()\n+impl<S: Encoder> Encodable<S> for str {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(self)\n     }\n }\n \n-impl Encodable for str {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for &str {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)\n     }\n }\n \n-impl Encodable for String {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for String {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(&self[..])\n     }\n }\n \n-impl Decodable for String {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n+impl<D: Decoder> Decodable<D> for String {\n+    fn decode(d: &mut D) -> Result<String, D::Error> {\n         Ok(d.read_str()?.into_owned())\n     }\n }\n \n-impl Encodable for f32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_f32(*self)\n-    }\n-}\n-\n-impl Decodable for f32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> {\n-        d.read_f32()\n-    }\n-}\n-\n-impl Encodable for f64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_f64(*self)\n-    }\n-}\n-\n-impl Decodable for f64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> {\n-        d.read_f64()\n-    }\n-}\n-\n-impl Encodable for bool {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_bool(*self)\n-    }\n-}\n-\n-impl Decodable for bool {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> {\n-        d.read_bool()\n-    }\n-}\n-\n-impl Encodable for char {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_char(*self)\n-    }\n-}\n-\n-impl Decodable for char {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> {\n-        d.read_char()\n-    }\n-}\n-\n-impl Encodable for () {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for () {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl Decodable for () {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> {\n+impl<D: Decoder> Decodable<D> for () {\n+    fn decode(d: &mut D) -> Result<(), D::Error> {\n         d.read_nil()\n     }\n }\n \n-impl<T> Encodable for PhantomData<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T> Encodable<S> for PhantomData<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl<T> Decodable for PhantomData<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n+impl<D: Decoder, T> Decodable<D> for PhantomData<T> {\n+    fn decode(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n         d.read_nil()?;\n         Ok(PhantomData)\n     }\n }\n \n-impl<T: Decodable> Decodable for Box<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<[T]> {\n+    fn decode(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n         Ok(v.into_boxed_slice())\n     }\n }\n \n-impl<T: Encodable> Encodable for Rc<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Rc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for Rc<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n+    fn decode(d: &mut D) -> Result<Rc<T>, D::Error> {\n         Ok(Rc::new(Decodable::decode(d)?))\n     }\n }\n \n-impl<T: Encodable> Encodable for [T] {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -665,8 +537,8 @@ impl<T: Encodable> Encodable for [T] {\n     }\n }\n \n-impl<T: Encodable> Encodable for Vec<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -676,8 +548,8 @@ impl<T: Encodable> Encodable for Vec<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Vec<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n+    fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n@@ -688,8 +560,8 @@ impl<T: Decodable> Decodable for Vec<T> {\n     }\n }\n \n-impl Encodable for [u8; 20] {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for [u8; 20] {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -699,8 +571,8 @@ impl Encodable for [u8; 20] {\n     }\n }\n \n-impl Decodable for [u8; 20] {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<[u8; 20], D::Error> {\n+impl<D: Decoder> Decodable<D> for [u8; 20] {\n+    fn decode(d: &mut D) -> Result<[u8; 20], D::Error> {\n         d.read_seq(|d, len| {\n             assert!(len == 20);\n             let mut v = [0u8; 20];\n@@ -712,11 +584,11 @@ impl Decodable for [u8; 20] {\n     }\n }\n \n-impl<'a, T: Encodable> Encodable for Cow<'a, [T]>\n+impl<'a, S: Encoder, T: Encodable<S>> Encodable<S> for Cow<'a, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -726,11 +598,11 @@ where\n     }\n }\n \n-impl<T: Decodable + ToOwned> Decodable for Cow<'static, [T]>\n+impl<D: Decoder, T: Decodable<D> + ToOwned> Decodable<D> for Cow<'static, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n+    fn decode(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n@@ -741,23 +613,23 @@ where\n     }\n }\n \n-impl<T: Encodable> Encodable for Option<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| match *self {\n             None => s.emit_option_none(),\n             Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n         })\n     }\n }\n \n-impl<T: Decodable> Decodable for Option<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n+    fn decode(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| if b { Ok(Some(Decodable::decode(d)?)) } else { Ok(None) })\n     }\n }\n \n-impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_enum(\"Result\", |s| match *self {\n             Ok(ref v) => {\n                 s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n@@ -769,8 +641,8 @@ impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n     }\n }\n \n-impl<T1: Decodable, T2: Decodable> Decodable for Result<T1, T2> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n+impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n+    fn decode(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n         d.read_enum(\"Result\", |d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n                 0 => Ok(Ok(d.read_enum_variant_arg(0, |d| T1::decode(d))?)),\n@@ -806,9 +678,9 @@ macro_rules! count {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<$($name:Decodable),+> Decodable for ($($name,)+) {\n+        impl<D: Decoder, $($name: Decodable<D>),+> Decodable<D> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)+), D::Error> {\n+            fn decode(d: &mut D) -> Result<($($name,)+), D::Error> {\n                 let len: usize = count!($($name)+);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n@@ -819,9 +691,9 @@ macro_rules! tuple {\n                 })\n             }\n         }\n-        impl<$($name:Encodable),+> Encodable for ($($name,)+) {\n+        impl<S: Encoder, $($name: Encodable<S>),+> Encodable<S> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+            fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n                 let mut n = 0;\n                 $(let $name = $name; n += 1;)+\n@@ -838,33 +710,33 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl Encodable for path::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for path::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)\n     }\n }\n \n-impl Encodable for path::PathBuf {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for path::PathBuf {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         path::Path::encode(self, e)\n     }\n }\n \n-impl Decodable for path::PathBuf {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n+impl<D: Decoder> Decodable<D> for path::PathBuf {\n+    fn decode(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = Decodable::decode(d)?;\n         Ok(path::PathBuf::from(bytes))\n     }\n }\n \n-impl<T: Encodable + Copy> Encodable for Cell<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S> + Copy> Encodable<S> for Cell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)\n     }\n }\n \n-impl<T: Decodable + Copy> Decodable for Cell<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n+    fn decode(d: &mut D) -> Result<Cell<T>, D::Error> {\n         Ok(Cell::new(Decodable::decode(d)?))\n     }\n }\n@@ -874,136 +746,37 @@ impl<T: Decodable + Copy> Decodable for Cell<T> {\n // `encoder.error(\"attempting to Encode borrowed RefCell\")`\n // from `encode` when `try_borrow` returns `None`.\n \n-impl<T: Encodable> Encodable for RefCell<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.borrow().encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for RefCell<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for RefCell<T> {\n+    fn decode(d: &mut D) -> Result<RefCell<T>, D::Error> {\n         Ok(RefCell::new(Decodable::decode(d)?))\n     }\n }\n \n-impl<T: Encodable> Encodable for Arc<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Arc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for Arc<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<T> {\n+    fn decode(d: &mut D) -> Result<Arc<T>, D::Error> {\n         Ok(Arc::new(Decodable::decode(d)?))\n     }\n }\n \n-// ___________________________________________________________________________\n-// Specialization-based interface for multi-dispatch Encodable/Decodable.\n-\n-/// Implement this trait on your `{Encodable,Decodable}::Error` types\n-/// to override the default panic behavior for missing specializations.\n-pub trait SpecializationError {\n-    /// Creates an error for a missing method specialization.\n-    /// Defaults to panicking with type, trait & method names.\n-    /// `S` is the encoder/decoder state type,\n-    /// `T` is the type being encoded/decoded, and\n-    /// the arguments are the names of the trait\n-    /// and method that should've been overridden.\n-    fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> Self;\n-}\n-\n-impl<E> SpecializationError for E {\n-    default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n-        panic!(\n-            \"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n-            any::type_name::<S>(),\n-            trait_name,\n-            any::type_name::<T>(),\n-            method_name\n-        );\n-    }\n-}\n-\n-/// Implement this trait on encoders, with `T` being the type\n-/// you want to encode (employing `UseSpecializedEncodable`),\n-/// using a strategy specific to the encoder.\n-pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder {\n-    /// Encode the value in a manner specific to this encoder state.\n-    fn specialized_encode(&mut self, value: &T) -> Result<(), Self::Error>;\n-}\n-\n-impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E {\n-    default fn specialized_encode(&mut self, value: &T) -> Result<(), E::Error> {\n-        value.default_encode(self)\n-    }\n-}\n-\n-/// Implement this trait on decoders, with `T` being the type\n-/// you want to decode (employing `UseSpecializedDecodable`),\n-/// using a strategy specific to the decoder.\n-pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder {\n-    /// Decode a value in a manner specific to this decoder state.\n-    fn specialized_decode(&mut self) -> Result<T, Self::Error>;\n-}\n-\n-impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n-    default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n-        T::default_decode(self)\n-    }\n-}\n-\n-/// Implement this trait on your type to get an `Encodable`\n-/// implementation which goes through `SpecializedEncoder`.\n-pub trait UseSpecializedEncodable {\n-    /// Defaults to returning an error (see `SpecializationError`).\n-    fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n-        Err(E::Error::not_found::<E, Self>(\"SpecializedEncoder\", \"specialized_encode\"))\n-    }\n-}\n-\n-impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n-    default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        E::specialized_encode(e, self)\n-    }\n-}\n-\n-/// Implement this trait on your type to get an `Decodable`\n-/// implementation which goes through `SpecializedDecoder`.\n-pub trait UseSpecializedDecodable: Sized {\n-    /// Defaults to returning an error (see `SpecializationError`).\n-    fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n-        Err(D::Error::not_found::<D, Self>(\"SpecializedDecoder\", \"specialized_decode\"))\n-    }\n-}\n-\n-impl<T: UseSpecializedDecodable> Decodable for T {\n-    default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n-        D::specialized_decode(d)\n-    }\n-}\n-\n-// Can't avoid specialization for &T and Box<T> impls,\n-// as proxy impls on them are blankets that conflict\n-// with the Encodable and Decodable impls above,\n-// which only have `default` on their methods\n-// for this exact reason.\n-// May be fixable in a simpler fashion via the\n-// more complex lattice model for specialization.\n-impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: ?Sized + Encodable<S>> Encodable<S> for Box<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n-impl<T: Decodable> UseSpecializedDecodable for Box<T> {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<T> {\n+    fn decode(d: &mut D) -> Result<Box<T>, D::Error> {\n         Ok(box Decodable::decode(d)?)\n     }\n }\n-impl<'a, T: Decodable> UseSpecializedDecodable for &'a T {}\n-impl<'a, T: Decodable> UseSpecializedDecodable for &'a [T] {}"}, {"sha": "e3a823127d93ea60621623ec8cb51e593ed4b192", "filename": "src/librustc_serialize/tests/json.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Ftests%2Fjson.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,6 +9,7 @@ use json::{\n     from_str, DecodeResult, Decoder, DecoderError, Encoder, EncoderError, Json, JsonEvent, Parser,\n     StackElement,\n };\n+use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::json;\n use rustc_serialize::{Decodable, Encodable};\n \n@@ -17,7 +18,7 @@ use std::io::prelude::*;\n use std::string;\n use Animal::*;\n \n-#[derive(RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Decodable, Eq, PartialEq, Debug)]\n struct OptionData {\n     opt: Option<usize>,\n }\n@@ -48,20 +49,20 @@ fn test_decode_option_malformed() {\n     );\n }\n \n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(PartialEq, Encodable, Decodable, Debug)]\n enum Animal {\n     Dog,\n     Frog(string::String, isize),\n }\n \n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(PartialEq, Encodable, Decodable, Debug)]\n struct Inner {\n     a: (),\n     b: usize,\n     c: Vec<string::String>,\n }\n \n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(PartialEq, Encodable, Decodable, Debug)]\n struct Outer {\n     inner: Vec<Inner>,\n }\n@@ -568,7 +569,7 @@ fn test_decode_struct() {\n     );\n }\n \n-#[derive(RustcDecodable)]\n+#[derive(Decodable)]\n struct FloatStruct {\n     f: f64,\n     a: Vec<f64>,\n@@ -616,20 +617,20 @@ fn test_multiline_errors() {\n     assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n }\n \n-#[derive(RustcDecodable)]\n+#[derive(Decodable)]\n #[allow(dead_code)]\n struct DecodeStruct {\n     x: f64,\n     y: bool,\n     z: string::String,\n     w: Vec<DecodeStruct>,\n }\n-#[derive(RustcDecodable)]\n+#[derive(Decodable)]\n enum DecodeEnum {\n     A(f64),\n     B(string::String),\n }\n-fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n+fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected: DecoderError) {\n     let res: DecodeResult<T> = match from_str(to_parse) {\n         Err(e) => Err(ParseError(e)),\n         Ok(json) => Decodable::decode(&mut Decoder::new(json)),\n@@ -933,7 +934,7 @@ fn test_prettyencoder_indent_level_param() {\n #[test]\n fn test_hashmap_with_enum_key() {\n     use std::collections::HashMap;\n-    #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n+    #[derive(Encodable, Eq, Hash, PartialEq, Decodable, Debug)]\n     enum Enum {\n         Foo,\n         #[allow(dead_code)]\n@@ -1254,7 +1255,7 @@ fn test_to_json() {\n #[test]\n fn test_encode_hashmap_with_arbitrary_key() {\n     use std::collections::HashMap;\n-    #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n+    #[derive(PartialEq, Eq, Hash, Encodable)]\n     struct ArbitraryType(usize);\n     let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n     hm.insert(ArbitraryType(1), true);"}, {"sha": "13b3676a56cd51b40cd0621633a440e886e84b45", "filename": "src/librustc_serialize/tests/opaque.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Ftests%2Fopaque.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,10 +1,11 @@\n #![allow(rustc::internal)]\n \n+use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::opaque::{Decoder, Encoder};\n use rustc_serialize::{Decodable, Encodable};\n use std::fmt::Debug;\n \n-#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n struct Struct {\n     a: (),\n     b: u8,\n@@ -27,11 +28,13 @@ struct Struct {\n     q: Option<u32>,\n }\n \n-fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) {\n+fn check_round_trip<T: Encodable<Encoder> + for<'a> Decodable<Decoder<'a>> + PartialEq + Debug>(\n+    values: Vec<T>,\n+) {\n     let mut encoder = Encoder::new(Vec::new());\n \n     for value in &values {\n-        Encodable::encode(&value, &mut encoder).unwrap();\n+        Encodable::encode(value, &mut encoder).unwrap();\n     }\n \n     let data = encoder.into_inner();\n@@ -225,7 +228,7 @@ fn test_struct() {\n     }]);\n }\n \n-#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n enum Enum {\n     Variant1,\n     Variant2(usize, f32),"}, {"sha": "cb6626d0f4bd5cd88346058f5b4b1aff81d6a91e", "filename": "src/librustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2FCargo.toml?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -12,6 +12,7 @@ path = \"lib.rs\"\n bitflags = \"1.2.1\"\n getopts = \"0.2\"\n log = { package = \"tracing\", version = \"0.1\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "c26c9bde3ee85114472d8f7e18d189d9b398ba7a", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -39,7 +39,7 @@ pub struct Config {\n }\n \n bitflags! {\n-    #[derive(Default, RustcEncodable, RustcDecodable)]\n+    #[derive(Default, Encodable, Decodable)]\n     pub struct SanitizerSet: u8 {\n         const ADDRESS = 1 << 0;\n         const LEAK    = 1 << 1;\n@@ -194,7 +194,8 @@ impl SwitchWithOptPath {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Encodable, Decodable)]\n pub enum SymbolManglingVersion {\n     Legacy,\n     V0,\n@@ -209,7 +210,8 @@ pub enum DebugInfo {\n     Full,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Encodable, Decodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -672,7 +674,7 @@ pub enum EntryFnType {\n \n impl_stable_hash_via_hash!(EntryFnType);\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, Encodable, Decodable)]\n pub enum CrateType {\n     Executable,\n     Dylib,"}, {"sha": "c2ea141a06fe31b71f9419b9d6155646c3f8bc68", "filename": "src/librustc_session/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -3,6 +3,8 @@\n \n #[macro_use]\n extern crate bitflags;\n+#[macro_use]\n+extern crate rustc_macros;\n \n pub mod cgu_reuse_tracker;\n pub mod utils;"}, {"sha": "a2bb8c4f91ff4d3ccf76dfa1f14567ee95580654", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -13,7 +13,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{MultiSpan, Span, Symbol};\n \n-use std::collections::BTreeMap;\n use std::path::PathBuf;\n use std::str;\n \n@@ -64,7 +63,7 @@ impl GatedSpans {\n #[derive(Default)]\n pub struct SymbolGallery {\n     /// All symbols occurred and their first occurrence span.\n-    pub symbols: Lock<BTreeMap<Symbol, Span>>,\n+    pub symbols: Lock<FxHashMap<Symbol, Span>>,\n }\n \n impl SymbolGallery {"}, {"sha": "e12364b7dac7cb355917994aa0855998076e3dec", "filename": "src/librustc_session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsearch_paths.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -33,7 +33,7 @@ impl SearchPathFile {\n     }\n }\n \n-#[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, Encodable, Decodable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "15447c01d1e55a5080e31c53fc84aacf6a3e8baa", "filename": "src/librustc_session/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_session%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Futils.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -10,7 +10,7 @@ impl Session {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub enum NativeLibKind {\n     /// Static library (e.g. `libfoo.a` on Linux or `foo.lib` on Windows/MSVC) included\n     /// when linking a final binary, but not when archiving an rlib."}, {"sha": "aae778217d3f1116a2b1e02ec4f65d341b9bffe2", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::{Decoder, Encoder};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::borrow::Borrow;\n use std::fmt;\n \n@@ -84,13 +84,14 @@ impl fmt::Display for CrateNum {\n \n /// As a local identifier, a `CrateNum` is only meaningful within its context, e.g. within a tcx.\n /// Therefore, make sure to include the context when encode a `CrateNum`.\n-impl rustc_serialize::UseSpecializedEncodable for CrateNum {\n-    fn default_encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_u32(self.as_u32())\n+impl<E: Encoder> Encodable<E> for CrateNum {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_u32(self.as_u32())\n     }\n }\n-impl rustc_serialize::UseSpecializedDecodable for CrateNum {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n+\n+impl<D: Decoder> Decodable<D> for CrateNum {\n+    default fn decode(d: &mut D) -> Result<CrateNum, D::Error> {\n         Ok(CrateNum::from_u32(d.read_u32()?))\n     }\n }\n@@ -104,8 +105,8 @@ impl ::std::fmt::Debug for CrateNum {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct DefPathHash(pub Fingerprint);\n \n impl Borrow<Fingerprint> for DefPathHash {\n@@ -120,16 +121,26 @@ rustc_index::newtype_index! {\n     /// particular definition. It should really be considered an interned\n     /// shorthand for a particular DefPath.\n     pub struct DefIndex {\n-        DEBUG_FORMAT = \"DefIndex({})\",\n+        ENCODABLE = custom // (only encodable in metadata)\n \n+        DEBUG_FORMAT = \"DefIndex({})\",\n         /// The crate root is always assigned index 0 by the AST Map code,\n         /// thanks to `NodeCollector::new`.\n         const CRATE_DEF_INDEX = 0,\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n-impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n+impl<E: Encoder> Encodable<E> for DefIndex {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `DefIndex` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for DefIndex {\n+    default fn decode(_: &mut D) -> Result<DefIndex, D::Error> {\n+        panic!(\"cannot decode `DefIndex` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n \n /// A `DefId` identifies a particular *definition*, by combining a crate\n /// index and a def index.\n@@ -168,19 +179,24 @@ impl DefId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for DefId {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        let krate = u64::from(self.krate.as_u32());\n-        let index = u64::from(self.index.as_u32());\n-        s.emit_u64((krate << 32) | index)\n+impl<E: Encoder> Encodable<E> for DefId {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_struct(\"DefId\", 2, |s| {\n+            s.emit_struct_field(\"krate\", 0, |s| self.krate.encode(s))?;\n+\n+            s.emit_struct_field(\"index\", 1, |s| self.index.encode(s))\n+        })\n     }\n }\n-impl rustc_serialize::UseSpecializedDecodable for DefId {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<DefId, D::Error> {\n-        let def_id = d.read_u64()?;\n-        let krate = CrateNum::from_u32((def_id >> 32) as u32);\n-        let index = DefIndex::from_u32((def_id & 0xffffffff) as u32);\n-        Ok(DefId { krate, index })\n+\n+impl<D: Decoder> Decodable<D> for DefId {\n+    default fn decode(d: &mut D) -> Result<DefId, D::Error> {\n+        d.read_struct(\"DefId\", 2, |d| {\n+            Ok(DefId {\n+                krate: d.read_struct_field(\"krate\", 0, Decodable::decode)?,\n+                index: d.read_struct_field(\"index\", 1, Decodable::decode)?,\n+            })\n+        })\n     }\n }\n \n@@ -239,8 +255,17 @@ impl fmt::Debug for LocalDefId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for LocalDefId {}\n-impl rustc_serialize::UseSpecializedDecodable for LocalDefId {}\n+impl<E: Encoder> Encodable<E> for LocalDefId {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        self.to_def_id().encode(s)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for LocalDefId {\n+    fn decode(d: &mut D) -> Result<LocalDefId, D::Error> {\n+        DefId::decode(d).map(|d| d.expect_local())\n+    }\n+}\n \n impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {"}, {"sha": "4d0c92f51d7ca7063c934486a78c7947e2b4b511", "filename": "src/librustc_span/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fedition.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,7 +5,7 @@ use std::str::FromStr;\n use rustc_macros::HashStable_Generic;\n \n /// The edition of the compiler (RFC 2052)\n-#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n+#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, Encodable, Decodable, Eq)]\n #[derive(HashStable_Generic)]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest"}, {"sha": "e8f4606b518cf3b1d3ed10fd2d28157aadee03d6", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -34,16 +34,14 @@ use log::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::{\n-    Decodable, Decoder, Encodable, Encoder, UseSpecializedDecodable, UseSpecializedEncodable,\n-};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n \n /// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n+#[derive(Debug, Encodable, Decodable, Clone)]\n pub struct SyntaxContextData {\n     outer_expn: ExpnId,\n     outer_transparency: Transparency,\n@@ -62,7 +60,7 @@ pub struct ExpnId(u32);\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n@@ -664,7 +662,7 @@ impl Span {\n \n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnData {\n     // --- The part unique to each expansion.\n     /// The kind of this expansion - macro or compiler desugaring.\n@@ -766,7 +764,7 @@ impl ExpnData {\n }\n \n /// Expansion kind.\n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum ExpnKind {\n     /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n@@ -794,7 +792,7 @@ impl ExpnKind {\n }\n \n /// The kind of macro invocation or definition.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum MacroKind {\n     /// A bang macro `foo!()`.\n@@ -830,7 +828,7 @@ impl MacroKind {\n }\n \n /// The kind of AST transform.\n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum AstPass {\n     StdImports,\n     TestHarness,\n@@ -848,7 +846,7 @@ impl AstPass {\n }\n \n /// The kind of compiler desugaring.\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum DesugaringKind {\n     /// We desugar `if c { i } else { e }` to `match $ExprKind::Use(c) { true => i, _ => e }`.\n     /// However, we do not want to blame `c` for unreachability but rather say that `i`\n@@ -867,7 +865,7 @@ pub enum DesugaringKind {\n }\n \n /// A location in the desugaring of a `for` loop\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum ForLoopLoc {\n     Head,\n     IntoIter,\n@@ -888,9 +886,6 @@ impl DesugaringKind {\n     }\n }\n \n-impl UseSpecializedEncodable for ExpnId {}\n-impl UseSpecializedDecodable for ExpnId {}\n-\n #[derive(Default)]\n pub struct HygieneEncodeContext {\n     /// All `SyntaxContexts` for which we have written `SyntaxContextData` into crate metadata.\n@@ -1137,6 +1132,7 @@ pub fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n     }\n     Ok(())\n }\n+\n pub fn for_all_data<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n     mut f: F,\n ) -> Result<(), E> {\n@@ -1147,6 +1143,18 @@ pub fn for_all_data<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Res\n     Ok(())\n }\n \n+impl<E: Encoder> Encodable<E> for ExpnId {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for ExpnId {\n+    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+        panic!(\"cannot decode `ExpnId` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n+\n pub fn for_all_expn_data<E, F: FnMut(u32, &ExpnData) -> Result<(), E>>(mut f: F) -> Result<(), E> {\n     let all_data = HygieneData::with(|data| data.expn_data.clone());\n     for (i, data) in all_data.into_iter().enumerate() {\n@@ -1218,5 +1226,14 @@ impl<'a> ExpnDataDecodeMode<'a, Box<dyn FnOnce(CrateNum) -> &'a HygieneDecodeCon\n     }\n }\n \n-impl UseSpecializedEncodable for SyntaxContext {}\n-impl UseSpecializedDecodable for SyntaxContext {}\n+impl<E: Encoder> Encodable<E> for SyntaxContext {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `SyntaxContext` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for SyntaxContext {\n+    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+        panic!(\"cannot decode `SyntaxContext` with `{}`\", std::any::type_name::<D>());\n+    }\n+}"}, {"sha": "c654dade2abd4ae60f9897e5eede270a153e9969", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -15,8 +15,7 @@\n #![feature(option_expect_none)]\n #![feature(refcell_take)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n use rustc_data_structures::AtomicRef;\n@@ -105,8 +104,8 @@ scoped_tls::scoped_thread_local!(pub static SESSION_GLOBALS: SessionGlobals);\n //\n // FIXME: We should use this enum or something like it to get rid of the\n // use of magic `/rust/1.x/...` paths across the board.\n-#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Decodable, Encodable)]\n pub enum RealFileName {\n     Named(PathBuf),\n     /// For de-virtualized paths (namely paths into libstd that have been mapped\n@@ -152,8 +151,8 @@ impl RealFileName {\n }\n \n /// Differentiates between real files and common virtual files.\n-#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Decodable, Encodable)]\n pub enum FileName {\n     Real(RealFileName),\n     /// Call to `quote!`.\n@@ -333,7 +332,7 @@ impl Ord for Span {\n ///   the error, and would be rendered with `^^^`.\n /// - They can have a *label*. In this case, the label is written next\n ///   to the mark in the snippet when we render.\n-#[derive(Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, Encodable, Decodable)]\n pub struct MultiSpan {\n     primary_spans: Vec<Span>,\n     span_labels: Vec<(Span, String)>,\n@@ -698,23 +697,22 @@ impl Default for Span {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for Span {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<E: Encoder> Encodable<E> for Span {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n         s.emit_struct(\"Span\", 2, |s| {\n             s.emit_struct_field(\"lo\", 0, |s| span.lo.encode(s))?;\n-\n             s.emit_struct_field(\"hi\", 1, |s| span.hi.encode(s))\n         })\n     }\n }\n-\n-impl rustc_serialize::UseSpecializedDecodable for Span {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n-        d.read_struct(\"Span\", 2, |d| {\n+impl<D: Decoder> Decodable<D> for Span {\n+    default fn decode(s: &mut D) -> Result<Span, D::Error> {\n+        s.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span::with_root_ctxt(lo, hi))\n+\n+            Ok(Span::new(lo, hi, SyntaxContext::root()))\n         })\n     }\n }\n@@ -889,7 +887,7 @@ impl From<Vec<Span>> for MultiSpan {\n }\n \n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the `SourceMap`.\n     pub pos: BytePos,\n@@ -898,7 +896,7 @@ pub struct MultiByteChar {\n }\n \n /// Identifies an offset of a non-narrow character in a `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub enum NonNarrowChar {\n     /// Represents a zero-width character.\n     ZeroWidth(BytePos),\n@@ -960,7 +958,7 @@ impl Sub<BytePos> for NonNarrowChar {\n }\n \n /// Identifies an offset of a character that was normalized away from `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub struct NormalizedPos {\n     /// The absolute offset of the character in the `SourceMap`.\n     pub pos: BytePos,\n@@ -1012,7 +1010,7 @@ impl ExternalSource {\n #[derive(Debug)]\n pub struct OffsetOverflowError;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub enum SourceFileHashAlgorithm {\n     Md5,\n     Sha1,\n@@ -1033,8 +1031,8 @@ impl FromStr for SourceFileHashAlgorithm {\n rustc_data_structures::impl_stable_hash_via_hash!(SourceFileHashAlgorithm);\n \n /// The hash of the on-disk source file used for debug info.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct SourceFileHash {\n     pub kind: SourceFileHashAlgorithm,\n     value: [u8; 20],\n@@ -1113,8 +1111,8 @@ pub struct SourceFile {\n     pub cnum: CrateNum,\n }\n \n-impl Encodable for SourceFile {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for SourceFile {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"SourceFile\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n@@ -1183,8 +1181,8 @@ impl Encodable for SourceFile {\n     }\n }\n \n-impl Decodable for SourceFile {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n+impl<D: Decoder> Decodable<D> for SourceFile {\n+    fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n         d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n@@ -1585,14 +1583,14 @@ impl Sub for BytePos {\n     }\n }\n \n-impl Encodable for BytePos {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(self.0)\n     }\n }\n \n-impl Decodable for BytePos {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n+impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {\n+    fn decode(d: &mut D) -> Result<BytePos, D::Error> {\n         Ok(BytePos(d.read_u32()?))\n     }\n }"}, {"sha": "29e589057b5e2945ca1ec038c8fd4a14b3691011", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -75,7 +75,7 @@ pub mod monotonic {\n     impl<T> !DerefMut for MonotonicVec<T> {}\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n@@ -118,7 +118,7 @@ impl FileLoader for RealFileLoader {\n // This is a `SourceFile` identifier that is used to correlate `SourceFile`s between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n pub struct StableSourceFileId(u128);\n \n // FIXME: we need a more globally consistent approach to the problem solved by"}, {"sha": "7843c04f25596e2f70d8cca544b9c918bf9a415d", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,9 +5,8 @@\n use rustc_arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n-use rustc_macros::{symbols, HashStable_Generic};\n+use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n \n use std::cmp::{Ord, PartialEq, PartialOrd};\n use std::fmt;\n@@ -1192,7 +1191,7 @@ symbols! {\n     }\n }\n \n-#[derive(Copy, Clone, Eq, HashStable_Generic)]\n+#[derive(Copy, Clone, Eq, HashStable_Generic, Encodable, Decodable)]\n pub struct Ident {\n     pub name: Symbol,\n     pub span: Span,\n@@ -1289,26 +1288,6 @@ impl fmt::Display for Ident {\n     }\n }\n \n-impl UseSpecializedEncodable for Ident {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"Ident\", 2, |s| {\n-            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"span\", 1, |s| self.span.encode(s))\n-        })\n-    }\n-}\n-\n-impl UseSpecializedDecodable for Ident {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        d.read_struct(\"Ident\", 2, |d| {\n-            Ok(Ident {\n-                name: d.read_struct_field(\"name\", 0, Decodable::decode)?,\n-                span: d.read_struct_field(\"span\", 1, Decodable::decode)?,\n-            })\n-        })\n-    }\n-}\n-\n /// This is the most general way to print identifiers.\n /// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n /// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n@@ -1452,15 +1431,15 @@ impl fmt::Display for Symbol {\n     }\n }\n \n-impl Encodable for Symbol {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for Symbol {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.with(|string| s.emit_str(string))\n     }\n }\n \n-impl Decodable for Symbol {\n+impl<D: Decoder> Decodable<D> for Symbol {\n     #[inline]\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Symbol, D::Error> {\n+    fn decode(d: &mut D) -> Result<Symbol, D::Error> {\n         Ok(Symbol::intern(&d.read_str()?))\n     }\n }\n@@ -1549,7 +1528,7 @@ pub mod sym {\n     use super::Symbol;\n     use std::convert::TryInto;\n \n-    symbols!();\n+    define_symbols!();\n \n     // Used from a macro in `librustc_feature/accepted.rs`\n     pub use super::kw::MacroRules as macro_rules;"}, {"sha": "4b565dd246f6da06feea1d999f18fe13ba63f533", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -235,7 +235,7 @@ pub enum Endian {\n }\n \n /// Size of a type in bytes.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct Size {\n     raw: u64,\n@@ -358,7 +358,7 @@ impl AddAssign for Size {\n }\n \n /// Alignment of a type in bytes (always a power of two).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct Align {\n     pow2: u8,\n@@ -415,7 +415,7 @@ impl Align {\n }\n \n /// A pair of alignments, ABI-mandated and preferred.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct AbiAndPrefAlign {\n     pub abi: Align,"}, {"sha": "c22644bf813a4a0e0ddb6bf6e2b623e1b104e4b3", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -13,7 +13,7 @@ macro_rules! def_reg_class {\n             $class:ident,\n         )*\n     }) => {\n-        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_regclass {\n             $($class,)*\n@@ -62,7 +62,7 @@ macro_rules! def_regs {\n         )*\n     }) => {\n         #[allow(unreachable_code)]\n-        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_reg {\n             $($reg,)*\n@@ -163,7 +163,7 @@ pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash)]\n pub enum InlineAsmArch {\n     X86,\n     X86_64,\n@@ -193,17 +193,7 @@ impl FromStr for InlineAsmArch {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmReg {\n     X86(X86InlineAsmReg),\n     Arm(ArmInlineAsmReg),\n@@ -293,17 +283,7 @@ impl InlineAsmReg {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmRegClass {\n     X86(X86InlineAsmRegClass),\n     Arm(ArmInlineAsmRegClass),\n@@ -429,17 +409,7 @@ impl InlineAsmRegClass {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(InlineAsmReg),\n     RegClass(InlineAsmRegClass),"}, {"sha": "62df63ceb1efd8cf5d890b1dc2266040ac371eeb", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -16,8 +16,7 @@\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n #[macro_use]"}, {"sha": "1e45739ca22b4a76f61c33be87661d35d4f19f5e", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -5,8 +5,8 @@ use rustc_macros::HashStable_Generic;\n #[cfg(test)]\n mod tests;\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Abi {\n     // N.B., this ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)"}, {"sha": "fa29ff3f8d80f6df5fd1d97ca1602ff97e37a62d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -161,7 +161,7 @@ flavor_mappings! {\n     ((LinkerFlavor::Lld(LldFlavor::Link)), \"lld-link\"),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable, HashStable_Generic)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,\n@@ -185,7 +185,7 @@ impl ToJson for PanicStrategy {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum RelroLevel {\n     Full,\n     Partial,\n@@ -229,7 +229,7 @@ impl ToJson for RelroLevel {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum MergeFunctions {\n     Disabled,\n     Trampolines,\n@@ -1734,7 +1734,7 @@ impl ToJson for Target {\n }\n \n /// Either a target triple string or a path to a JSON file.\n-#[derive(PartialEq, Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Hash, Encodable, Decodable)]\n pub enum TargetTriple {\n     TargetTriple(String),\n     TargetPath(PathBuf),"}, {"sha": "820f8716f05d1960309228734cff4d993288f755", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -270,6 +270,13 @@ impl AutoTraitFinder<'tcx> {\n     ) -> Option<(ty::ParamEnv<'tcx>, ty::ParamEnv<'tcx>)> {\n         let tcx = infcx.tcx;\n \n+        // Don't try to proess any nested obligations involving predicates\n+        // that are already in the `ParamEnv` (modulo regions): we already\n+        // know that they must hold.\n+        for predicate in param_env.caller_bounds() {\n+            fresh_preds.insert(self.clean_pred(infcx, predicate));\n+        }\n+\n         let mut select = SelectionContext::with_negative(&infcx, true);\n \n         let mut already_visited = FxHashSet::default();"}, {"sha": "316181ce7d4a9291f53f19464a9e0ad16dbac0bb", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -324,8 +324,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n \n         let ty = ty.super_fold_with(self);\n         match ty.kind {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n-                // (*)\n+            ty::Opaque(def_id, substs) => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty,\n@@ -353,9 +352,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             }\n \n             ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n-                // (*)\n-\n-                // (*) This is kind of hacky -- we need to be able to\n+                // This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n                 // otherwise we wind up a need to normalize when doing\n                 // trait matching (since you can have a trait"}, {"sha": "93652329305a5bc98482ff0b0eaeee2aaa5f5d5c", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -101,8 +101,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n         let ty = ty.super_fold_with(self);\n         match ty.kind {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n-                // (*)\n+            ty::Opaque(def_id, substs) => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty,\n@@ -140,8 +139,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             }\n \n             ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n-                // (*)\n-                // (*) This is kind of hacky -- we need to be able to\n+                // This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n                 // otherwise we wind up a need to normalize when doing\n                 // trait matching (since you can have a trait"}, {"sha": "3093ddbeaf1ae05de8418b436a00ff5dd51e31b3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -489,28 +489,31 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             kind,\n         );\n \n+        let unordered = sess.features_untracked().const_generics;\n         let kind_ord = match kind {\n             \"lifetime\" => ParamKindOrd::Lifetime,\n             \"type\" => ParamKindOrd::Type,\n-            \"constant\" => ParamKindOrd::Const,\n+            \"constant\" => ParamKindOrd::Const { unordered },\n             // It's more concise to match on the string representation, though it means\n             // the match is non-exhaustive.\n             _ => bug!(\"invalid generic parameter kind {}\", kind),\n         };\n         let arg_ord = match arg {\n             GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n             GenericArg::Type(_) => ParamKindOrd::Type,\n-            GenericArg::Const(_) => ParamKindOrd::Const,\n+            GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n         };\n \n-        // This note will be true as long as generic parameters are strictly ordered by their kind.\n-        let (first, last) =\n-            if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n-        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-\n-        if let Some(help) = help {\n-            err.help(help);\n+        // This note is only true when generic parameters are strictly ordered by their kind.\n+        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+            let (first, last) =\n+                if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n+            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+            if let Some(help) = help {\n+                err.help(help);\n+            }\n         }\n+\n         err.emit();\n     }\n \n@@ -672,7 +675,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                                         ParamKindOrd::Type\n                                                     }\n                                                     GenericParamDefKind::Const => {\n-                                                        ParamKindOrd::Const\n+                                                        ParamKindOrd::Const {\n+                                                            unordered: tcx\n+                                                                .sess\n+                                                                .features_untracked()\n+                                                                .const_generics,\n+                                                        }\n                                                     }\n                                                 },\n                                                 param,\n@@ -1615,6 +1623,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n+        borrowed: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -1829,15 +1838,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n-                        // FIXME: these can be redundant with E0106, but not always.\n-                        struct_span_err!(\n+                        let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n                             E0228,\n                             \"the lifetime bound for this object type cannot be deduced \\\n                              from context; please supply an explicit bound\"\n-                        )\n-                        .emit();\n+                        );\n+                        if borrowed {\n+                            // We will have already emitted an error E0106 complaining about a\n+                            // missing named lifetime in `&dyn Trait`, so we elide this one.\n+                            err.delay_as_bug();\n+                        } else {\n+                            err.emit();\n+                        }\n                         tcx.lifetimes.re_static\n                     })\n                 }\n@@ -2865,6 +2879,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n+        self.ast_ty_to_ty_inner(ast_ty, false)\n+    }\n+\n+    /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n+    /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n+    fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\", ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n@@ -2877,7 +2897,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(\"ast_ty_to_ty: r={:?}\", r);\n-                let t = self.ast_ty_to_ty(&mt.ty);\n+                let t = self.ast_ty_to_ty_inner(&mt.ty, true);\n                 tcx.mk_ref(r, ty::TypeAndMut { ty: t, mutbl: mt.mutbl })\n             }\n             hir::TyKind::Never => tcx.types.never,\n@@ -2895,7 +2915,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n-                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n+                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed)\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);"}, {"sha": "418ea29b84f2f53a9862d3c67b364099178e283e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-enum CastError {\n+pub enum CastError {\n     ErrorReported,\n \n     CastToBool,\n@@ -593,7 +593,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+    pub fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc_middle::ty::cast::CastTy::*;\n         use rustc_middle::ty::cast::IntTy::*;\n "}, {"sha": "4ea76a4a9e2abb462ce0cd3c6d8148f5c2032edd", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -34,6 +34,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_await(err, expr, expected, expr_ty);\n+        self.suggest_missing_parentheses(err, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n     }\n "}, {"sha": "9078dc40041aa376c9648aca6b14791d442677bd", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -649,6 +649,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     self.assemble_inherent_impl_for_primitive(lang_def_id);\n                 }\n             }\n+            ty::Array(_, _) => {\n+                let lang_def_id = lang_items.array_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl }) => {\n                 let (lang_def_id1, lang_def_id2) = match mutbl {\n                     hir::Mutability::Not => {"}, {"sha": "6957b6b2a05d08f74b458e558776caf5e9bd9b5a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -67,7 +67,7 @@ type parameter).\n pub mod _match;\n mod autoderef;\n mod callee;\n-mod cast;\n+pub mod cast;\n mod closure;\n pub mod coercion;\n mod compare_method;\n@@ -648,7 +648,7 @@ impl Inherited<'_, 'tcx> {\n }\n \n impl<'tcx> InheritedBuilder<'tcx> {\n-    fn enter<F, R>(&mut self, f: F) -> R\n+    pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n         F: for<'a> FnOnce(Inherited<'a, 'tcx>) -> R,\n     {\n@@ -1967,10 +1967,16 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             check_union(tcx, it.hir_id, it.span);\n         }\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n-            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n-            check_opaque(tcx, def_id, substs, it.span, &origin);\n+            // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n+            // `async-std` (and `pub async fn` in general).\n+            // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n+            // See https://github.com/rust-lang/rust/issues/75100\n+            if !tcx.sess.opts.actually_rustdoc {\n+                let def_id = tcx.hir().local_def_id(it.hir_id);\n+\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                check_opaque(tcx, def_id, substs, it.span, &origin);\n+            }\n         }\n         hir::ItemKind::TyAlias(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n@@ -5395,6 +5401,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_missing_parentheses(&self, err: &mut DiagnosticBuilder<'_>, expr: &hir::Expr<'_>) {\n+        let sp = self.tcx.sess.source_map().start_point(expr.span);\n+        if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n+            self.tcx.sess.parse_sess.expr_parentheses_needed(err, *sp, None);\n+        }\n+    }\n+\n     fn note_need_for_fn_pointer(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "1c78bef98527a6b988e4fe3363834d51747522ae", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1229,8 +1229,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     );\n \n-                    // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                    unmentioned_fields.retain(|&x| x.name != suggested_name);\n+                    // When we have a tuple struct used with struct we don't want to suggest using\n+                    // the (valid) struct syntax with numeric field names. Instead we want to\n+                    // suggest the expected syntax. We infer that this is the case by parsing the\n+                    // `Ident` into an unsized integer. The suggestion will be emitted elsewhere in\n+                    // `smart_resolve_context_dependent_help`.\n+                    if suggested_name.to_ident_string().parse::<usize>().is_err() {\n+                        // We don't want to throw `E0027` in case we have thrown `E0026` for them.\n+                        unmentioned_fields.retain(|&x| x.name != suggested_name);\n+                    }\n                 }\n             }\n         }"}, {"sha": "4bef9aecd2ecb2236e88a44b82dcddedf99a0376", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::autoderef::Autoderef;\n+use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n@@ -243,19 +244,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.typeck_results.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n+                hir::ExprKind::Index(ref base_expr, ..) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Index, expr, base_expr);\n                 }\n                 hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr);\n                 }\n                 _ => {}\n             }\n@@ -267,9 +260,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: PlaceOp,\n         expr: &hir::Expr<'_>,\n         base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n     ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?})\", op, expr, base_expr);\n         if !self.typeck_results.borrow().is_method_call(expr) {\n             debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n             return;\n@@ -284,6 +276,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .expect(\"place op takes something that is not a ref\")\n             .ty;\n \n+        let arg_ty = match op {\n+            PlaceOp::Deref => None,\n+            PlaceOp::Index => {\n+                // We would need to recover the `T` used when we resolve `<_ as Index<T>>::index`\n+                // in try_index_step. This is the subst at index 1.\n+                //\n+                // Note: we should *not* use `expr_ty` of index_expr here because autoderef\n+                // during coercions can cause type of index_expr to differ from `T` (#72002).\n+                // We also could not use `expr_ty_adjusted` of index_expr because reborrowing\n+                // during coercions can also cause type of index_expr to differ from `T`,\n+                // which can potentially cause regionck failure (#74933).\n+                Some(self.typeck_results.borrow().node_substs(expr.hir_id).type_at(1))\n+            }\n+        };\n+        let arg_tys = match arg_ty {\n+            None => &[],\n+            Some(ref ty) => slice::from_ref(ty),\n+        };\n+\n         let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n         let method = match method {\n             Some(ok) => self.register_infer_ok_obligations(ok),"}, {"sha": "cd7429f166f26aa6fc141461aa70ea9d1282a9fa", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -112,6 +112,16 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     item.span,\n                 );\n             }\n+            ty::Array(_, _) => {\n+                self.check_primitive_impl(\n+                    def_id,\n+                    lang_items.array_impl(),\n+                    None,\n+                    \"array\",\n+                    \"[T; N]\",\n+                    item.span,\n+                );\n+            }\n             ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Not })\n                 if matches!(inner.kind, ty::Slice(_)) =>\n             {"}, {"sha": "49843fa43dd8c8e7fc4dd5f1008cc0dca37ce9f7", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -74,11 +74,11 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n-// This is used by Clippy.\n+// These are used by Clippy.\n+pub mod check;\n pub mod expr_use_visitor;\n \n mod astconv;\n-mod check;\n mod check_unused;\n mod coherence;\n mod collect;\n@@ -390,6 +390,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n         tcx.sess.time(\"wf_checking\", || check::check_wf_new(tcx));\n     })?;\n \n+    // NOTE: This is copy/pasted in librustdoc/core.rs and should be kept in sync.\n     tcx.sess.time(\"item_types_checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n             tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));"}, {"sha": "801d06e61016961ef8a808004708c727044ddfbf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1083,25 +1083,37 @@ impl Clean<TypeKind> for hir::def::DefKind {\n \n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         let inner = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                MethodItem((sig, &self.generics, body, None).clean(cx))\n+                let mut m = (sig, &self.generics, body, None).clean(cx);\n+                if m.header.constness == hir::Constness::Const\n+                    && !is_min_const_fn(cx.tcx, local_did.to_def_id())\n+                {\n+                    m.header.constness = hir::Constness::NotConst;\n+                }\n+                MethodItem(m)\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                TyMethodItem(TyMethod { header: sig.header, decl, generics, all_types, ret_types })\n+                let mut t = TyMethod { header: sig.header, decl, generics, all_types, ret_types };\n+                if t.header.constness == hir::Constness::Const\n+                    && !is_min_const_fn(cx.tcx, local_did.to_def_id())\n+                {\n+                    t.header.constness = hir::Constness::NotConst;\n+                }\n+                TyMethodItem(t)\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 AssocTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1117,20 +1129,26 @@ impl Clean<Item> for hir::TraitItem<'_> {\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         let inner = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n-                MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n+                let mut m = (sig, &self.generics, body, Some(self.defaultness)).clean(cx);\n+                if m.header.constness == hir::Constness::Const\n+                    && !is_min_const_fn(cx.tcx, local_did.to_def_id())\n+                {\n+                    m.header.constness = hir::Constness::NotConst;\n+                }\n+                MethodItem(m)\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 let type_ = ty.clean(cx);\n                 let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                 TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n         };\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n@@ -2340,7 +2358,7 @@ impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext<'_>) -> Stability {\n         Stability {\n             level: stability::StabilityLevel::from_attr_level(&self.level),\n-            feature: Some(self.feature.to_string()).filter(|f| !f.is_empty()),\n+            feature: self.feature.to_string(),\n             since: match self.level {\n                 attr::Stable { ref since } => since.to_string(),\n                 _ => String::new(),"}, {"sha": "627f88df45c9fe00170d487dc13e5b0eaab59c45", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1525,7 +1525,7 @@ pub struct ProcMacro {\n #[derive(Clone, Debug)]\n pub struct Stability {\n     pub level: stability::StabilityLevel,\n-    pub feature: Option<String>,\n+    pub feature: String,\n     pub since: String,\n     pub unstable_reason: Option<String>,\n     pub issue: Option<NonZeroU32>,"}, {"sha": "168967cdeb7cf8e7e79858bafe2ecb21830a4f1b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -388,7 +388,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n             Bool => tcx.lang_items().bool_impl(),\n             Str => tcx.lang_items().str_impl(),\n             Slice => tcx.lang_items().slice_impl(),\n-            Array => tcx.lang_items().slice_impl(),\n+            Array => tcx.lang_items().array_impl(),\n             Tuple => None,\n             Unit => None,\n             RawPointer => tcx.lang_items().const_ptr_impl(),"}, {"sha": "b13acaae1bf234048cfd2858a33a01312808486d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -452,10 +452,20 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 // Certain queries assume that some checks were run elsewhere\n                 // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n                 // so type-check everything other than function bodies in this crate before running lints.\n+\n                 // NOTE: this does not call `tcx.analysis()` so that we won't\n                 // typeck function bodies or run the default rustc lints.\n                 // (see `override_queries` in the `config`)\n-                let _ = rustc_typeck::check_crate(tcx);\n+\n+                // HACK(jynelson) this calls an _extremely_ limited subset of `typeck`\n+                // and might break if queries change their assumptions in the future.\n+\n+                // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n+                tcx.sess.time(\"item_types_checking\", || {\n+                    for &module in tcx.hir().krate().modules.keys() {\n+                        tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+                    }\n+                });\n                 tcx.sess.abort_if_errors();\n                 sess.time(\"missing_docs\", || {\n                     rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);"}, {"sha": "fd67a66395d7ca2753c81775e9ebb05838bc54b0", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -95,6 +95,7 @@ pub fn render<T: Print, S: Print>(\n                            placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\\n                            type=\\\"search\\\">\\\n                 </div>\\\n+                <span class=\\\"help-button\\\">?</span>\n                 <a id=\\\"settings-menu\\\" href=\\\"{root_path}settings.html\\\">\\\n                     <img src=\\\"{static_root_path}wheel{suffix}.svg\\\" \\\n                          width=\\\"18\\\" \\\n@@ -138,7 +139,7 @@ pub fn render<T: Print, S: Print>(\n             if layout.logo.is_empty() {\n                 format!(\n                     \"<a href='{path}index.html'>\\\n-                     <div class='logo-container'>\\\n+                     <div class='logo-container rust-logo'>\\\n                      <img src='{static_root_path}rust-logo{suffix}.png' alt='logo'></div></a>\",\n                     path = p,\n                     static_root_path = static_root_path,"}, {"sha": "bd919205dd1761b76c9cd010df00fbd57cc5f1af", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1903,23 +1903,41 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n     }\n }\n \n-fn name_key(name: &str) -> (&str, u64, usize) {\n-    let end = name.bytes().rposition(|b| b.is_ascii_digit()).map_or(name.len(), |i| i + 1);\n-\n-    // find number at end\n-    let split = name[0..end].bytes().rposition(|b| !b.is_ascii_digit()).map_or(0, |i| i + 1);\n-\n-    // count leading zeroes\n-    let after_zeroes =\n-        name[split..end].bytes().position(|b| b != b'0').map_or(name.len(), |extra| split + extra);\n-\n-    // sort leading zeroes last\n-    let num_zeroes = after_zeroes - split;\n-\n-    match name[split..end].parse() {\n-        Ok(n) => (&name[..split], n, num_zeroes),\n-        Err(_) => (name, 0, num_zeroes),\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n     }\n+\n+    Ordering::Equal\n }\n \n fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n@@ -1962,7 +1980,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n         }\n         let lhs = i1.name.as_ref().map_or(\"\", |s| &**s);\n         let rhs = i2.name.as_ref().map_or(\"\", |s| &**s);\n-        name_key(lhs).cmp(&name_key(rhs))\n+        compare_names(lhs, rhs)\n     }\n \n     if cx.shared.sort_modules_alphabetically {\n@@ -2126,7 +2144,7 @@ fn stability_tags(item: &clean::Item) -> String {\n     if item\n         .stability\n         .as_ref()\n-        .map(|s| s.level == stability::Unstable && s.feature.as_deref() != Some(\"rustc_private\"))\n+        .map(|s| s.level == stability::Unstable && s.feature != \"rustc_private\")\n         == Some(true)\n     {\n         tags += &tag_html(\"unstable\", \"Experimental\");\n@@ -2177,25 +2195,25 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n     // Render unstable items. But don't render \"rustc_private\" crates (internal compiler crates).\n     // Those crates are permanently unstable so it makes no sense to render \"unstable\" everywhere.\n-    if let Some(stab) = item.stability.as_ref().filter(|stab| {\n-        stab.level == stability::Unstable && stab.feature.as_deref() != Some(\"rustc_private\")\n-    }) {\n+    if let Some(stab) = item\n+        .stability\n+        .as_ref()\n+        .filter(|stab| stab.level == stability::Unstable && stab.feature != \"rustc_private\")\n+    {\n         let mut message =\n             \"<span class='emoji'>\ud83d\udd2c</span> This is a nightly-only experimental API.\".to_owned();\n \n-        if let Some(feature) = stab.feature.as_deref() {\n-            let mut feature = format!(\"<code>{}</code>\", Escape(&feature));\n-            if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, stab.issue) {\n-                feature.push_str(&format!(\n-                    \"&nbsp;<a href=\\\"{url}{issue}\\\">#{issue}</a>\",\n-                    url = url,\n-                    issue = issue\n-                ));\n-            }\n-\n-            message.push_str(&format!(\" ({})\", feature));\n+        let mut feature = format!(\"<code>{}</code>\", Escape(&stab.feature));\n+        if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, stab.issue) {\n+            feature.push_str(&format!(\n+                \"&nbsp;<a href=\\\"{url}{issue}\\\">#{issue}</a>\",\n+                url = url,\n+                issue = issue\n+            ));\n         }\n \n+        message.push_str(&format!(\" ({})\", feature));\n+\n         if let Some(unstable_reason) = &stab.unstable_reason {\n             let mut ids = cx.id_map.borrow_mut();\n             message = format!(\n@@ -2395,7 +2413,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n-    name_key(&lhs).cmp(&name_key(&rhs))\n+    compare_names(&lhs, &rhs)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {"}, {"sha": "abf5f05fe58ab71e7f553f4a276278efbf6a1088", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -1,24 +1,40 @@\n use super::*;\n \n #[test]\n-fn test_name_key() {\n-    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n-    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n-    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n-    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n-    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n-    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n-    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n-    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n+fn test_compare_names() {\n+    for &(a, b) in &[\n+        (\"hello\", \"world\"),\n+        (\"\", \"world\"),\n+        (\"123\", \"hello\"),\n+        (\"123\", \"\"),\n+        (\"123test\", \"123\"),\n+        (\"hello\", \"\"),\n+        (\"hello\", \"hello\"),\n+        (\"hello123\", \"hello123\"),\n+        (\"hello123\", \"hello12\"),\n+        (\"hello12\", \"hello123\"),\n+        (\"hello01abc\", \"hello01xyz\"),\n+        (\"hello0abc\", \"hello0\"),\n+        (\"hello0\", \"hello0abc\"),\n+        (\"01\", \"1\"),\n+    ] {\n+        assert_eq!(compare_names(a, b), a.cmp(b), \"{:?} - {:?}\", a, b);\n+    }\n+    assert_eq!(compare_names(\"u8\", \"u16\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32\", \"u16\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u8_to_f64\", \"u16_to_f64\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32_to_f64\", \"u16_to_f64\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u16_to_f64\", \"u16_to_f64\"), Ordering::Equal);\n+    assert_eq!(compare_names(\"u16_to_f32\", \"u16_to_f64\"), Ordering::Less);\n }\n \n #[test]\n fn test_name_sorting() {\n     let names = [\n-        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit1\", \"Fruit01\", \"Fruit2\", \"Fruit02\",\n+        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit01\", \"Fruit1\", \"Fruit02\", \"Fruit2\",\n         \"Fruit20\", \"Fruit30x\", \"Fruit100\", \"Pear\",\n     ];\n     let mut sorted = names.to_owned();\n-    sorted.sort_by_key(|&s| name_key(s));\n+    sorted.sort_by(|&l, r| compare_names(l, r));\n     assert_eq!(names, sorted);\n }"}, {"sha": "462a696dee6ef3593ccd7df291ccbfd22e2111d1", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -408,9 +408,7 @@ function defocusSearchBar() {\n                 break;\n \n             case \"?\":\n-                if (ev.shiftKey) {\n-                    displayHelp(true, ev);\n-                }\n+                displayHelp(true, ev);\n                 break;\n             }\n         }\n@@ -473,7 +471,9 @@ function defocusSearchBar() {\n     }());\n \n     document.addEventListener(\"click\", function(ev) {\n-        if (hasClass(ev.target, \"collapse-toggle\")) {\n+        if (hasClass(ev.target, \"help-button\")) {\n+            displayHelp(true, ev);\n+        } else if (hasClass(ev.target, \"collapse-toggle\")) {\n             collapseDocs(ev.target, \"toggle\");\n         } else if (hasClass(ev.target.parentNode, \"collapse-toggle\")) {\n             collapseDocs(ev.target.parentNode, \"toggle\");"}, {"sha": "346ceacc928c472b368ebbc401f564170eb7691a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -674,7 +674,7 @@ a {\n }\n .search-container > div {\n \tdisplay: inline-flex;\n-\twidth: calc(100% - 34px);\n+\twidth: calc(100% - 63px);\n }\n #crate-search {\n \tmargin-top: 5px;\n@@ -1250,14 +1250,24 @@ h4 > .notable-traits {\n \toutline: none;\n }\n \n-#settings-menu {\n+#settings-menu, .help-button {\n \tposition: absolute;\n-\tright: 0;\n \ttop: 10px;\n+}\n+\n+#settings-menu {\n+\tright: 0;\n \toutline: none;\n }\n \n-#theme-picker, #settings-menu {\n+.help-button {\n+\tright: 30px;\n+\tfont-family: \"Fira Sans\",sans-serif;\n+\ttext-align: center;\n+\tfont-size: 17px;\n+}\n+\n+#theme-picker, #settings-menu, .help-button {\n \tpadding: 4px;\n \twidth: 27px;\n \theight: 29px;"}, {"sha": "6e8db1e9eb7926d079ee51cea67a6872cdc091f1", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -62,8 +62,11 @@ pre {\n \tbackground-color: #14191f;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #fff);\n+.logo-container.rust-logo > img {\n+\tfilter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff);\n }\n \n /* Improve the scrollbar display on firefox */\n@@ -489,7 +492,7 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #5c6773;\n \tbackground-color: #0f1419;\n }\n@@ -499,7 +502,8 @@ kbd {\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #e0e0e0;\n }\n "}, {"sha": "eeb1f0a3d4a0bfa7448dfc4575f7a23fb36dbd3a", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -34,8 +34,11 @@ pre {\n \tbackground-color: #505050;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #fff);\n+.logo-container.rust-logo > img {\n+\tfilter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff)\n }\n \n /* Improve the scrollbar display on firefox */\n@@ -383,13 +386,14 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #e0e0e0;\n \tbackground: #f0f0f0;\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #ffb900;\n }\n "}, {"sha": "9dea875b87747bd8c633478c41b2407927dd788b", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/bab15885c0ab1230186cc45290c6d6c224289f6b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=bab15885c0ab1230186cc45290c6d6c224289f6b", "patch": "@@ -45,8 +45,8 @@ pre {\n \tscrollbar-color: rgba(36, 37, 39, 0.6) #d9d9d9;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #aaa);\n+.logo-container.rust-logo > img {\n+\t/* No need for a border in here! */\n }\n \n /* Improve the scrollbar display on webkit-based browsers */\n@@ -377,13 +377,14 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #e0e0e0;\n \tbackground-color: #fff;\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #717171;\n }\n "}]}