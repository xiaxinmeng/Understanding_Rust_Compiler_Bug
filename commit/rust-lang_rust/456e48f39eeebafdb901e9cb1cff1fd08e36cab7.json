{"sha": "456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NmU0OGYzOWVlZWJhZmRiOTAxZTljYjFjZmYxZmQwOGUzNmNhYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-13T05:30:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-13T05:30:37Z"}, "message": "Auto merge of #87954 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\nr? `@Manishearth`", "tree": {"sha": "4dbef572c78be7845c41b72825c92f108fef04d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dbef572c78be7845c41b72825c92f108fef04d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "html_url": "https://github.com/rust-lang/rust/commit/456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd5427b68643391b56d51448ee5fdce1cd6f63f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd5427b68643391b56d51448ee5fdce1cd6f63f1", "html_url": "https://github.com/rust-lang/rust/commit/fd5427b68643391b56d51448ee5fdce1cd6f63f1"}, {"sha": "1ad54642008b185f5691e5cac1148147d29fc00f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad54642008b185f5691e5cac1148147d29fc00f", "html_url": "https://github.com/rust-lang/rust/commit/1ad54642008b185f5691e5cac1148147d29fc00f"}], "stats": {"total": 1686, "additions": 1311, "deletions": 375}, "files": [{"sha": "2216bb9f293d790506a5d116b4120018a34306a0", "filename": ".github/ISSUE_TEMPLATE/new_lint.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fnew_lint.md?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -15,8 +15,9 @@ labels: A-lint\n *What is the advantage of the recommended code over the original code*\n \n For example:\n-- Remove bounce checking inserted by ...\n-- Remove the need to duplicating/storing/typo ...\n+- Remove bounds check inserted by ...\n+- Remove the need to duplicate/store ...\n+- Remove typo ...\n \n ### Drawbacks\n "}, {"sha": "0339de77f3cecf4e3ebad3e91b302398a5da368f", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -49,13 +49,13 @@ jobs:\n         echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n \n     - name: Build\n-      run: cargo build --features deny-warnings,internal-lints\n+      run: cargo build --features deny-warnings,internal-lints,metadata-collector-lint\n \n     - name: Test\n-      run: cargo test --features deny-warnings,internal-lints\n+      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints\n+      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util"}, {"sha": "1f4d666c7a92c1f6761c2288a280c71ad586f2c3", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -112,13 +112,13 @@ jobs:\n         echo \"$SYSROOT/bin\" >> $GITHUB_PATH\n \n     - name: Build\n-      run: cargo build --features deny-warnings,internal-lints\n+      run: cargo build --features deny-warnings,internal-lints,metadata-collector-lint\n \n     - name: Test\n-      run: cargo test --features deny-warnings,internal-lints\n+      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints\n+      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util"}, {"sha": "56c00544c93a7892d7aa80a0ec05e6c70ad0734d", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -20,6 +20,8 @@ jobs:\n \n     - name: Setup Node.js\n       uses: actions/setup-node@v1.4.4\n+      with:\n+        node-version: '12.x'\n \n     - name: Install remark\n       run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended remark-gfm"}, {"sha": "2b89170073be513bca6869b916212e05d9fb2935", "filename": "CHANGELOG.md", "status": "modified", "additions": 136, "deletions": 5, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -6,11 +6,141 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[3ae8faf...master](https://github.com/rust-lang/rust-clippy/compare/3ae8faf...master)\n+[74d1561...master](https://github.com/rust-lang/rust-clippy/compare/74d1561...master)\n+\n+## Rust 1.55\n+\n+Current beta, release 2021-09-09\n+\n+[3ae8faf...74d1561](https://github.com/rust-lang/rust-clippy/compare/3ae8faf...74d1561)\n+\n+### Important Changes\n+\n+* Stabilized `cargo clippy --fix` :tada:\n+  [#7405](https://github.com/rust-lang/rust-clippy/pull/7405)\n+\n+### New Lints\n+\n+* [`rc_mutex`]\n+  [#7316](https://github.com/rust-lang/rust-clippy/pull/7316)\n+* [`nonstandard_macro_braces`]\n+  [#7299](https://github.com/rust-lang/rust-clippy/pull/7299)\n+* [`strlen_on_c_strings`]\n+  [#7243](https://github.com/rust-lang/rust-clippy/pull/7243)\n+* [`self_named_constructors`]\n+  [#7403](https://github.com/rust-lang/rust-clippy/pull/7403)\n+* [`disallowed_script_idents`]\n+  [#7400](https://github.com/rust-lang/rust-clippy/pull/7400)\n+* [`disallowed_type`]\n+  [#7315](https://github.com/rust-lang/rust-clippy/pull/7315)\n+* [`missing_enforced_import_renames`]\n+  [#7300](https://github.com/rust-lang/rust-clippy/pull/7300)\n+* [`extend_with_drain`]\n+  [#7270](https://github.com/rust-lang/rust-clippy/pull/7270)\n+\n+### Moves and Deprecations\n+\n+* Moved [`from_iter_instead_of_collect`] to `pedantic`\n+  [#7375](https://github.com/rust-lang/rust-clippy/pull/7375)\n+* Added `suspicious` as a new lint group for *code that is most likely wrong or useless*\n+  [#7350](https://github.com/rust-lang/rust-clippy/pull/7350)\n+  * Moved [`blanket_clippy_restriction_lints`] to `suspicious`\n+  * Moved [`empty_loop`] to `suspicious`\n+  * Moved [`eval_order_dependence`] to `suspicious`\n+  * Moved [`float_equality_without_abs`] to `suspicious`\n+  * Moved [`for_loops_over_fallibles`] to `suspicious`\n+  * Moved [`misrefactored_assign_op`] to `suspicious`\n+  * Moved [`mut_range_bound`] to `suspicious`\n+  * Moved [`mutable_key_type`] to `suspicious`\n+  * Moved [`suspicious_arithmetic_impl`] to `suspicious`\n+  * Moved [`suspicious_assignment_formatting`] to `suspicious`\n+  * Moved [`suspicious_else_formatting`] to `suspicious`\n+  * Moved [`suspicious_map`] to `suspicious`\n+  * Moved [`suspicious_op_assign_impl`] to `suspicious`\n+  * Moved [`suspicious_unary_op_formatting`] to `suspicious`\n+\n+### Enhancements\n+\n+* [`while_let_on_iterator`]: Now suggests `&mut iter` inside closures\n+  [#7262](https://github.com/rust-lang/rust-clippy/pull/7262)\n+* [`doc_markdown`]:\n+  * Now detects unbalanced ticks\n+    [#7357](https://github.com/rust-lang/rust-clippy/pull/7357)\n+  * Add `FreeBSD` to the default configuration as an allowed identifier\n+    [#7334](https://github.com/rust-lang/rust-clippy/pull/7334)\n+* [`wildcard_enum_match_arm`], [`match_wildcard_for_single_variants`]: Now allows wildcards for enums with unstable\n+  or hidden variants\n+  [#7407](https://github.com/rust-lang/rust-clippy/pull/7407)\n+* [`redundant_allocation`]: Now additionally supports the `Arc<>` type\n+  [#7308](https://github.com/rust-lang/rust-clippy/pull/7308)\n+* [`blacklisted_name`]: Now allows blacklisted names in test code\n+  [#7379](https://github.com/rust-lang/rust-clippy/pull/7379)\n+* [`redundant_closure`]: Suggests `&mut` for `FnMut`\n+  [#7437](https://github.com/rust-lang/rust-clippy/pull/7437)\n+* [`disallowed_method`], [`disallowed_type`]: The configuration values `disallowed-method` and `disallowed-type`\n+  no longer require fully qualified paths\n+  [#7345](https://github.com/rust-lang/rust-clippy/pull/7345)\n+* [`zst_offset`]: Fixed lint invocation after it was accidentally suppressed\n+  [#7396](https://github.com/rust-lang/rust-clippy/pull/7396)\n+\n+### False Positive Fixes\n+\n+* [`default_numeric_fallback`]: No longer lints on float literals as function arguments\n+  [#7446](https://github.com/rust-lang/rust-clippy/pull/7446)\n+* [`use_self`]: No longer lints on type parameters\n+  [#7288](https://github.com/rust-lang/rust-clippy/pull/7288)\n+* [`unimplemented`]: Now ignores the `assert` and `debug_assert` macros\n+  [#7439](https://github.com/rust-lang/rust-clippy/pull/7439)\n+* [`branches_sharing_code`]: Now always checks for block expressions\n+  [#7462](https://github.com/rust-lang/rust-clippy/pull/7462)\n+* [`field_reassign_with_default`]: No longer triggers in macros\n+  [#7160](https://github.com/rust-lang/rust-clippy/pull/7160)\n+* [`redundant_clone`]: No longer lints on required clones for borrowed data\n+  [#7346](https://github.com/rust-lang/rust-clippy/pull/7346)\n+* [`default_numeric_fallback`]: No longer triggers in external macros\n+  [#7325](https://github.com/rust-lang/rust-clippy/pull/7325)\n+* [`needless_bool`]: No longer lints in macros\n+  [#7442](https://github.com/rust-lang/rust-clippy/pull/7442)\n+* [`useless_format`]: No longer triggers when additional text is being appended\n+  [#7442](https://github.com/rust-lang/rust-clippy/pull/7442)\n+* [`assertions_on_constants`]: `cfg!(...)` is no longer considered to be a constant\n+  [#7319](https://github.com/rust-lang/rust-clippy/pull/7319)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`needless_collect`]: Now show correct lint messages for shadowed values\n+  [#7289](https://github.com/rust-lang/rust-clippy/pull/7289)\n+* [`wrong_pub_self_convention`]: The deprecated message now suggest the correct configuration value\n+  [#7382](https://github.com/rust-lang/rust-clippy/pull/7382)\n+* [`semicolon_if_nothing_returned`]: Allow missing semicolon in blocks with only one expression\n+  [#7326](https://github.com/rust-lang/rust-clippy/pull/7326)\n+\n+### ICE Fixes\n+\n+* [`zero_sized_map_values`]\n+  [#7470](https://github.com/rust-lang/rust-clippy/pull/7470)\n+* [`redundant_pattern_matching`]\n+  [#7471](https://github.com/rust-lang/rust-clippy/pull/7471)\n+* [`modulo_one`]\n+  [#7473](https://github.com/rust-lang/rust-clippy/pull/7473)\n+* [`use_self`]\n+  [#7428](https://github.com/rust-lang/rust-clippy/pull/7428)\n+\n+### Documentation Improvements\n+\n+* Reworked Clippy's website:\n+  [#7279](https://github.com/rust-lang/rust-clippy/pull/7279)\n+  [#7172](https://github.com/rust-lang/rust-clippy/issues/7172)\n+  * Added applicability information about lints\n+  * Added a link to jump into the implementation\n+  * Improved loading times\n+  * Adapted some styling\n+* Clippy now uses a lint to generate its documentation\n+  [#7298](https://github.com/rust-lang/rust-clippy/pull/7298)\n \n ## Rust 1.54\n \n-Current beta, release 2021-07-29\n+Current stable, released 2021-07-29\n \n [7c7683c...3ae8faf](https://github.com/rust-lang/rust-clippy/compare/7c7683c...3ae8faf)\n \n@@ -29,7 +159,7 @@ Current beta, release 2021-07-29\n ### Moves and Deprecations\n \n - Deprecate `pub_enum_variant_names` and `wrong_pub_self_convention` in favor of\n-  the new `avoid_breaking_exported_api` config option (see\n+  the new `avoid-breaking-exported-api` config option (see\n   [Enhancements](#1-54-enhancements))\n   [#7187](https://github.com/rust-lang/rust-clippy/pull/7187)\n - Move [`inconsistent_struct_constructor`] to `pedantic`\n@@ -51,7 +181,7 @@ Current beta, release 2021-07-29\n   [#7163](https://github.com/rust-lang/rust-clippy/pull/7163)\n - [`if_then_some_else_none`]: Now works with the MSRV config\n   [#7177](https://github.com/rust-lang/rust-clippy/pull/7177)\n-- Add `avoid_breaking_exported_api` config option for the lints\n+- Add `avoid-breaking-exported-api` config option for the lints\n   [`enum_variant_names`], [`large_types_passed_by_value`],\n   [`trivially_copy_pass_by_ref`], [`unnecessary_wraps`],\n   [`upper_case_acronyms`], and [`wrong_self_convention`]. We recommend to set\n@@ -138,7 +268,7 @@ Current beta, release 2021-07-29\n \n ## Rust 1.53\n \n-Current stable, released 2021-06-17\n+Released 2021-06-17\n \n [6ed6f1e...7c7683c](https://github.com/rust-lang/rust-clippy/compare/6ed6f1e...7c7683c)\n \n@@ -2869,6 +2999,7 @@ Released 2018-09-13\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n [`unusual_byte_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unusual_byte_groupings\n [`unwrap_in_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_in_result\n+[`unwrap_or_else_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_or_else_default\n [`unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\n [`upper_case_acronyms`]: https://rust-lang.github.io/rust-clippy/master/index.html#upper_case_acronyms\n [`use_debug`]: https://rust-lang.github.io/rust-clippy/master/index.html#use_debug"}, {"sha": "0be460d67a75f3e8bbb248782978eed3ba1a79fb", "filename": "clippy_lints/src/as_conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fas_conversions.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Expr, ExprKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -47,7 +47,7 @@ declare_lint_pass!(AsConversions => [AS_CONVERSIONS]);\n \n impl EarlyLintPass for AsConversions {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n "}, {"sha": "75561cfde369bc73bfd871eebfc42f55671a46bf", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -230,15 +230,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(&body.value);\n-                    lint_for_missing_headers(\n-                        cx,\n-                        item.def_id,\n-                        item.span,\n-                        sig,\n-                        headers,\n-                        Some(body_id),\n-                        fpu.panic_span,\n-                    );\n+                    lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(ref impl_) => {\n@@ -278,15 +270,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 panic_span: None,\n             };\n             fpu.visit_expr(&body.value);\n-            lint_for_missing_headers(\n-                cx,\n-                item.def_id,\n-                item.span,\n-                sig,\n-                headers,\n-                Some(body_id),\n-                fpu.panic_span,\n-            );\n+            lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n }"}, {"sha": "b64246515f34f79fab343e868120c52060605f1e", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -2,7 +2,7 @@\n \n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{Expr, ExprKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -49,7 +49,7 @@ declare_lint_pass!(ElseIfWithoutElse => [ELSE_IF_WITHOUT_ELSE]);\n \n impl EarlyLintPass for ElseIfWithoutElse {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n-        if in_external_macro(cx.sess(), item.span) {\n+        if in_external_macro(cx.sess, item.span) {\n             return;\n         }\n "}, {"sha": "04fc5887e8e8b21123d92d9bde53ed6179151560", "filename": "clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n         hir_id: hir::HirId,\n     ) {\n         too_many_arguments::check_fn(cx, kind, decl, span, hir_id, self.too_many_arguments_threshold);\n-        too_many_lines::check_fn(cx, span, body, self.too_many_lines_threshold);\n+        too_many_lines::check_fn(cx, kind, span, body, self.too_many_lines_threshold);\n         not_unsafe_ptr_arg_deref::check_fn(cx, kind, decl, body, hir_id);\n     }\n "}, {"sha": "008ef661b55f20a31c4e25e1e24e3a0de4b7a94a", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,4 +1,5 @@\n use rustc_hir as hir;\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_span::Span;\n@@ -8,8 +9,16 @@ use clippy_utils::source::snippet_opt;\n \n use super::TOO_MANY_LINES;\n \n-pub(super) fn check_fn(cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>, too_many_lines_threshold: u64) {\n-    if in_external_macro(cx.sess(), span) {\n+pub(super) fn check_fn(\n+    cx: &LateContext<'_>,\n+    kind: FnKind<'tcx>,\n+    span: Span,\n+    body: &'tcx hir::Body<'_>,\n+    too_many_lines_threshold: u64,\n+) {\n+    // Closures must be contained in a parent body, which will be checked for `too_many_lines`.\n+    // Don't check closures for `too_many_lines` to avoid duplicated lints.\n+    if matches!(kind, FnKind::Closure) || in_external_macro(cx.sess(), span) {\n         return;\n     }\n "}, {"sha": "3ce91d421baca8bc9efe4b9ae760c522c7f288ca", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -3,7 +3,7 @@\n \n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_ast::ast::{BinOpKind, Expr, ExprKind, UnOp};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -48,7 +48,7 @@ declare_lint_pass!(IfNotElse => [IF_NOT_ELSE]);\n \n impl EarlyLintPass for IfNotElse {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n-        if in_external_macro(cx.sess(), item.span) {\n+        if in_external_macro(cx.sess, item.span) {\n             return;\n         }\n         if let ExprKind::If(ref cond, _, Some(ref els)) = item.kind {"}, {"sha": "3736d237642fb61d30b3ddadbb8148fabd2d3ca5", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -2,7 +2,7 @@\n \n use clippy_utils::diagnostics::span_lint;\n use rustc_ast::ast::{Block, ItemKind, StmtKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -54,7 +54,7 @@ declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n \n impl EarlyLintPass for ItemsAfterStatements {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n-        if in_external_macro(cx.sess(), item.span) {\n+        if in_external_macro(cx.sess, item.span) {\n             return;\n         }\n \n@@ -68,7 +68,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n         // lint on all further items\n         for stmt in stmts {\n             if let StmtKind::Item(ref it) = *stmt {\n-                if in_external_macro(cx.sess(), it.span) {\n+                if in_external_macro(cx.sess, it.span) {\n                     return;\n                 }\n                 if let ItemKind::MacroDef(..) = it.kind {"}, {"sha": "a519ad90df54a2c84b5858e5234fe033cc3b95e7", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -207,8 +207,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.def_id)\n-        && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n+    if cx.access_levels.is_exported(visited_trait.def_id) && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n@@ -331,17 +330,15 @@ fn check_for_is_empty(\n             None,\n             None,\n         ),\n-        Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => {\n-            (\n-                format!(\n-                    \"{} `{}` has a public `len` method, but a private `is_empty` method\",\n-                    item_kind,\n-                    item_name.as_str(),\n-                ),\n-                Some(cx.tcx.def_span(is_empty.def_id)),\n-                None,\n-            )\n-        },\n+        Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => (\n+            format!(\n+                \"{} `{}` has a public `len` method, but a private `is_empty` method\",\n+                item_kind,\n+                item_name.as_str(),\n+            ),\n+            Some(cx.tcx.def_span(is_empty.def_id)),\n+            None,\n+        ),\n         Some(is_empty)\n             if !(is_empty.fn_has_self_parameter\n                 && check_is_empty_sig(cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind, output)) =>"}, {"sha": "dbdb4251b3bec2358c98cae5878f611b3f6401c9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -797,6 +797,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::UNNECESSARY_FILTER_MAP,\n         methods::UNNECESSARY_FOLD,\n         methods::UNNECESSARY_LAZY_EVALUATIONS,\n+        methods::UNWRAP_OR_ELSE_DEFAULT,\n         methods::UNWRAP_USED,\n         methods::USELESS_ASREF,\n         methods::WRONG_SELF_CONVENTION,\n@@ -1341,6 +1342,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(methods::UNNECESSARY_FOLD),\n         LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+        LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n         LintId::of(methods::USELESS_ASREF),\n         LintId::of(methods::WRONG_SELF_CONVENTION),\n         LintId::of(methods::ZST_OFFSET),\n@@ -1535,6 +1537,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::STRING_EXTEND_CHARS),\n         LintId::of(methods::UNNECESSARY_FOLD),\n         LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+        LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n         LintId::of(methods::WRONG_SELF_CONVENTION),\n         LintId::of(misc::TOPLEVEL_REF_ARG),\n         LintId::of(misc::ZERO_PTR),"}, {"sha": "0e5121ca3d73a9d0e5e0107aca96ef4c46f91a10", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -10,7 +10,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use std::iter;\n@@ -222,7 +222,7 @@ impl_lint_pass!(LiteralDigitGrouping => [\n \n impl EarlyLintPass for LiteralDigitGrouping {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n \n@@ -415,7 +415,7 @@ impl_lint_pass!(DecimalLiteralRepresentation => [DECIMAL_LITERAL_REPRESENTATION]\n \n impl EarlyLintPass for DecimalLiteralRepresentation {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n "}, {"sha": "6d9f6215ed418dd95087021c4ee57464ae33b7d0", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,13 +1,36 @@\n+use super::utils::make_iterator_snippet;\n use super::NEVER_LOOP;\n-use clippy_utils::diagnostics::span_lint;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Stmt, StmtKind};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n+use clippy_utils::source::snippet;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use std::iter::{once, Iterator};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(block, _, _, _) = expr.kind {\n+    if let ExprKind::Loop(block, _, source, _) = expr.kind {\n         match never_loop_block(block, expr.hir_id) {\n-            NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+            NeverLoopResult::AlwaysBreak => {\n+                span_lint_and_then(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\", |diag| {\n+                    if_chain! {\n+                        if let LoopSource::ForLoop = source;\n+                        if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n+                        if let Some((pat, iterator, _, for_span)) = higher::for_loop(parent_match);\n+                        then {\n+                            // Suggests using an `if let` instead. This is `Unspecified` because the\n+                            // loop may (probably) contain `break` statements which would be invalid\n+                            // in an `if let`.\n+                            diag.span_suggestion_verbose(\n+                                for_span.with_hi(iterator.span.hi()),\n+                                \"if you need the first element of the iterator, try writing\",\n+                                for_to_if_let_sugg(cx, iterator, pat),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    };\n+                });\n+            },\n             NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n         }\n     }\n@@ -170,3 +193,14 @@ fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n+\n+fn for_to_if_let_sugg(cx: &LateContext<'_>, iterator: &Expr<'_>, pat: &Pat<'_>) -> String {\n+    let pat_snippet = snippet(cx, pat.span, \"_\");\n+    let iter_snippet = make_iterator_snippet(cx, iterator, &mut Applicability::Unspecified);\n+\n+    format!(\n+        \"if let Some({pat}) = {iter}.next()\",\n+        pat = pat_snippet,\n+        iter = iter_snippet\n+    )\n+}"}, {"sha": "ef822e0cbe540225f9ad4317ecb19110973a70a0", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -7,7 +7,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Node, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Mutability, Node, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n@@ -48,7 +48,12 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n     // afterwards a mutable borrow of a field isn't necessary.\n     let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n-        \"&mut \"\n+        if cx.typeck_results().node_type(iter_expr.hir_id).ref_mutability() == Some(Mutability::Mut) {\n+            // Reborrow for mutable references. It may not be possible to get a mutable reference here.\n+            \"&mut *\"\n+        } else {\n+            \"&mut \"\n+        }\n     } else {\n         \"\"\n     };\n@@ -69,6 +74,8 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n struct IterExpr {\n     /// The span of the whole expression, not just the path and fields stored here.\n     span: Span,\n+    /// The HIR id of the whole expression, not just the path and fields stored here.\n+    hir_id: HirId,\n     /// The fields used, in order of child to parent.\n     fields: Vec<Symbol>,\n     /// The path being used.\n@@ -78,12 +85,14 @@ struct IterExpr {\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n     let span = e.span;\n+    let hir_id = e.hir_id;\n     let mut fields = Vec::new();\n     loop {\n         match e.kind {\n             ExprKind::Path(ref path) => {\n                 break Some(IterExpr {\n                     span,\n+                    hir_id,\n                     fields,\n                     path: cx.qpath_res(path, e.hir_id),\n                 });\n@@ -137,7 +146,7 @@ fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fie\n     match expr.kind {\n         ExprKind::Field(base, name) => {\n             if let Some((head_field, tail_fields)) = fields.split_first() {\n-                if name.name == *head_field && is_expr_same_field(cx, base, fields, path_res) {\n+                if name.name == *head_field && is_expr_same_field(cx, base, tail_fields, path_res) {\n                     return true;\n                 }\n                 // Check if the expression is a parent field"}, {"sha": "8829b8c5f4df45c4fc8bb730dc7b9c7365b87d9b", "filename": "clippy_lints/src/methods/extend_with_drain.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fextend_with_drain.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -16,7 +16,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n         //check source object\n         if let ExprKind::MethodCall(src_method, _, [drain_vec, drain_arg], _) = &arg.kind;\n         if src_method.ident.as_str() == \"drain\";\n-        if let src_ty = cx.typeck_results().expr_ty(drain_vec).peel_refs();\n+        let src_ty = cx.typeck_results().expr_ty(drain_vec);\n+        //check if actual src type is mutable for code suggestion\n+        let immutable = src_ty.is_mutable_ptr();\n+        let src_ty = src_ty.peel_refs();\n         if is_type_diagnostic_item(cx, src_ty, sym::vec_type);\n         //check drain range\n         if let src_ty_range = cx.typeck_results().expr_ty(drain_arg).peel_refs();\n@@ -30,8 +33,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg:\n                 \"use of `extend` instead of `append` for adding the full range of a second vector\",\n                 \"try this\",\n                 format!(\n-                    \"{}.append(&mut {})\",\n+                    \"{}.append({}{})\",\n                     snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+                    if immutable { \"\" } else { \"&mut \" },\n                     snippet_with_applicability(cx, drain_vec.span, \"..\", &mut applicability)\n                 ),\n                 applicability,"}, {"sha": "99c03844f49275e02461ca8a02c0195c81e96772", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{is_expr_path_def_path, paths, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_lint::{LateContext, LintContext};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n use rustc_span::sym;\n \n@@ -43,7 +44,7 @@ fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -\n \n     let call_site = expr.span.source_callsite();\n     if_chain! {\n-        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n+        if let Some(snippet) = snippet_opt(cx, call_site);\n         let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n         if let Some((_, elements)) = snippet_split.split_last();\n "}, {"sha": "08d3a7ce92bbea268cbdae460c78cc43e5bd3733", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -52,18 +52,32 @@ pub(super) fn check<'tcx>(\n         );\n     }\n \n-    // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type) {\n-        let func_snippet = snippet(cx, map_arg.span, \"..\");\n-        let hint = format!(\".and_then({})\", func_snippet);\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_FLATTEN,\n-            expr.span.with_lo(recv.span.hi()),\n-            \"called `map(..).flatten()` on an `Option`\",\n-            \"try using `and_then` instead\",\n-            hint,\n-            Applicability::MachineApplicable,\n-        );\n-    }\n+    // lint if caller of `.map().flatten()` is an Option or Result\n+    let caller_type = match cx.typeck_results().expr_ty(recv).kind() {\n+        ty::Adt(adt, _) => {\n+            if cx.tcx.is_diagnostic_item(sym::option_type, adt.did) {\n+                \"Option\"\n+            } else if cx.tcx.is_diagnostic_item(sym::result_type, adt.did) {\n+                \"Result\"\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => {\n+            return;\n+        },\n+    };\n+\n+    let func_snippet = snippet(cx, map_arg.span, \"..\");\n+    let hint = format!(\".and_then({})\", func_snippet);\n+    let lint_info = format!(\"called `map(..).flatten()` on an `{}`\", caller_type);\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_FLATTEN,\n+        expr.span.with_lo(recv.span.hi()),\n+        &lint_info,\n+        \"try using `and_then` instead\",\n+        hint,\n+        Applicability::MachineApplicable,\n+    );\n }"}, {"sha": "91606ed3b2bb0d9bc83dfddb0085208451d78415", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -56,6 +56,7 @@ mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_lazy_eval;\n+mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n mod utils;\n@@ -310,6 +311,31 @@ declare_clippy_lint! {\n     \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `_.unwrap_or_else(Default::default)` on `Option` and\n+    /// `Result` values.\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability, these can be written as `_.unwrap_or_default`, which is\n+    /// simpler and more concise.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    /// # let x = Some(1);\n+    ///\n+    /// // Bad\n+    /// x.unwrap_or_else(Default::default);\n+    /// x.unwrap_or_else(u32::default);\n+    ///\n+    /// // Good\n+    /// x.unwrap_or_default();\n+    /// ```\n+    pub UNWRAP_OR_ELSE_DEFAULT,\n+    style,\n+    \"using `.unwrap_or_else(Default::default)`, which is more succinctly expressed as `.unwrap_or_default()`\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n@@ -1766,6 +1792,7 @@ impl_lint_pass!(Methods => [\n     SHOULD_IMPLEMENT_TRAIT,\n     WRONG_SELF_CONVENTION,\n     OK_EXPECT,\n+    UNWRAP_OR_ELSE_DEFAULT,\n     MAP_UNWRAP_OR,\n     RESULT_MAP_OR_INTO_OPTION,\n     OPTION_MAP_OR_NONE,\n@@ -2172,7 +2199,10 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             },\n             (\"unwrap_or_else\", [u_arg]) => match method_call!(recv) {\n                 Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n-                _ => unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\"),\n+                _ => {\n+                    unwrap_or_else_default::check(cx, expr, recv, u_arg);\n+                    unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n+                },\n             },\n             _ => {},\n         }"}, {"sha": "c1d22e5d72c138d3a9c216eb571686d3a672e4f0", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::eager_or_lazy::is_lazyness_candidate;\n+use clippy_utils::is_trait_item;\n use clippy_utils::source::{snippet, snippet_with_applicability, snippet_with_macro_callsite};\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type};\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use clippy_utils::{contains_return, last_path_segment, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -34,15 +36,23 @@ pub(super) fn check<'tcx>(\n         or_has_args: bool,\n         span: Span,\n     ) -> bool {\n+        let is_default_default = || is_trait_item(cx, fun, sym::Default);\n+\n+        let implements_default = |arg, default_trait_id| {\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            implements_trait(cx, arg_ty, default_trait_id, &[])\n+        };\n+\n         if_chain! {\n             if !or_has_args;\n             if name == \"unwrap_or\";\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-            let path = last_path_segment(qpath).ident.name;\n-            if matches!(path, kw::Default | sym::new);\n-            let arg_ty = cx.typeck_results().expr_ty(arg);\n             if let Some(default_trait_id) = cx.tcx.get_diagnostic_item(sym::Default);\n-            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n+            let path = last_path_segment(qpath).ident.name;\n+            // needs to target Default::default in particular or be *::new and have a Default impl\n+            // available\n+            if (matches!(path, kw::Default) && is_default_default())\n+                || (matches!(path, sym::new) && implements_default(arg, default_trait_id));\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "677aa80e1b76ec4eb7a0d1d051af7e047060069b", "filename": "clippy_lints/src/methods/unwrap_or_else_default.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -0,0 +1,45 @@\n+//! Lint for `some_result_or_option.unwrap_or_else(Default::default)`\n+\n+use super::UNWRAP_OR_ELSE_DEFAULT;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, is_trait_item, source::snippet_with_applicability, ty::is_type_diagnostic_item,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    u_arg: &'tcx hir::Expr<'_>,\n+) {\n+    // something.unwrap_or_else(Default::default)\n+    // ^^^^^^^^^- recv          ^^^^^^^^^^^^^^^^- u_arg\n+    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- expr\n+    let recv_ty = cx.typeck_results().expr_ty(recv);\n+    let is_option = is_type_diagnostic_item(cx, recv_ty, sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, recv_ty, sym::result_type);\n+\n+    if_chain! {\n+        if is_option || is_result;\n+        if is_trait_item(cx, u_arg, sym::Default);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            span_lint_and_sugg(\n+                cx,\n+                UNWRAP_OR_ELSE_DEFAULT,\n+                expr.span,\n+                \"use of `.unwrap_or_else(..)` to construct default value\",\n+                \"try\",\n+                format!(\n+                    \"{}.unwrap_or_default()\",\n+                    snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "b32feab4ee3e7e5506b23875170ca01d6d4920b6", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -12,7 +12,7 @@ use clippy_utils::source::snippet_opt;\n use rustc_ast::ast::{Expr, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -307,7 +307,7 @@ impl EarlyLintPass for MiscEarlyLints {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n         double_neg::check(cx, expr);"}, {"sha": "fff533167ede2032d935dbc3edbc4228d51bfba4", "filename": "clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::source::snippet_opt;\n use rustc_ast::ast::{Pat, PatKind};\n-use rustc_lint::{EarlyContext, LintContext};\n+use rustc_lint::EarlyContext;\n \n use super::UNNEEDED_FIELD_PATTERN;\n \n@@ -48,7 +49,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n                             match field.pat.kind {\n                                 PatKind::Wild => {},\n                                 _ => {\n-                                    if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n+                                    if let Some(n) = snippet_opt(cx, field.span) {\n                                         normal.push(n);\n                                     }\n                                 },"}, {"sha": "ba8f9446af85e4a0850fdedffe1996e7d3b1aaf0", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -27,11 +27,15 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n+    /// fn fun(_a: &i32) {}\n+    ///\n     /// // Bad\n     /// let x: &i32 = &&&&&&5;\n+    /// fun(&x);\n     ///\n     /// // Good\n     /// let x: &i32 = &5;\n+    /// fun(x);\n     /// ```\n     pub NEEDLESS_BORROW,\n     style,"}, {"sha": "5a50cc48d61bfce7e62f03719cdbc2028adb8a57", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -422,7 +422,7 @@ fn check_and_warn<'a>(cx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n ///\n /// is transformed to\n ///\n-/// ```ignore\n+/// ```text\n ///     {\n ///         let x = 5;\n /// ```"}, {"sha": "9a6ddc72ce56a04ca17199e8b1baa700763dafcf", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -122,7 +122,7 @@ impl LateLintPass<'_> for NeedlessForEach {\n /// 2. Detect use of `return` in `Loop` in the closure body.\n ///\n /// NOTE: The functionality of this type is similar to\n-/// [`crate::utilts::visitors::find_all_ret_expressions`], but we can't use\n+/// [`clippy_utils::visitors::find_all_ret_expressions`], but we can't use\n /// `find_all_ret_expressions` instead of this type. The reasons are:\n /// 1. `find_all_ret_expressions` passes the argument of `ExprKind::Ret` to a callback, but what we\n ///    need here is `ExprKind::Ret` itself."}, {"sha": "28e9e6f438e3de59f8f63ef67acccbee8da82397", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n+use rustc_hir::{is_range_literal, BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::ops::Deref;\n@@ -68,12 +68,14 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n-                match res {\n-                    Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..) => {\n-                        !has_drop(cx, cx.typeck_results().expr_ty(expr))\n-                            && args.iter().all(|arg| has_no_effect(cx, arg))\n-                    },\n-                    _ => false,\n+                let def_matched = matches!(\n+                    res,\n+                    Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n+                );\n+                if def_matched || is_range_literal(expr) {\n+                    !has_drop(cx, cx.typeck_results().expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n+                } else {\n+                    false\n                 }\n             } else {\n                 false"}, {"sha": "f6254aa715a45f5e8b00a174448bc631b434b454", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -127,6 +127,7 @@ const ALLOWED_TO_BE_SIMILAR: &[&[&str]] = &[\n     &[\"qpath\", \"path\"],\n     &[\"lit\", \"lint\"],\n     &[\"wparam\", \"lparam\"],\n+    &[\"iter\", \"item\"],\n ];\n \n struct SimilarNamesNameVisitor<'a, 'tcx, 'b>(&'b mut SimilarNamesLocalVisitor<'a, 'tcx>);"}, {"sha": "ca660a9250db15f2332a71b44dfad2340c8d1f06", "filename": "clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -7,6 +7,7 @@ use clippy_utils::{diagnostics::span_lint_and_help, in_macro, is_direct_expn_of,\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -91,13 +92,23 @@ impl EarlyLintPass for MacroBraces {\n }\n \n fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, mac_braces: &'a MacroBraces) -> Option<MacroInfo<'a>> {\n+    let unnested_or_local = || {\n+        let nested = in_macro(span.ctxt().outer_expn_data().call_site);\n+        !nested\n+            || span\n+                .macro_backtrace()\n+                .last()\n+                .map_or(false, |e| e.macro_def_id.map_or(false, DefId::is_local))\n+    };\n     if_chain! {\n+        // Make sure we are only one level deep otherwise there are to many FP's\n         if in_macro(span);\n         if let Some((name, braces)) = find_matching_macro(span, &mac_braces.macro_braces);\n         if let Some(snip) = snippet_opt(cx, span.ctxt().outer_expn_data().call_site);\n         // we must check only invocation sites\n         // https://github.com/rust-lang/rust-clippy/issues/7422\n-        if snip.starts_with(name);\n+        if snip.starts_with(&format!(\"{}!\", name));\n+        if unnested_or_local();\n         // make formatting consistent\n         let c = snip.replace(\" \", \"\");\n         if !c.starts_with(&format!(\"{}!{}\", name, braces.0));"}, {"sha": "157b18c1f6b1fb8a8287c653f54827552aef5cf9", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -2,9 +2,9 @@ use std::cmp;\n use std::iter;\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_self_ty;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_copy;\n+use clippy_utils::{is_self, is_self_ty};\n use if_chain::if_chain;\n use rustc_ast::attr;\n use rustc_errors::Applicability;\n@@ -170,7 +170,7 @@ impl<'tcx> PassByRefOrValue {\n                         if size <= self.ref_min_size;\n                         if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {\n-                            let value_type = if is_self_ty(decl_ty) {\n+                            let value_type = if fn_body.and_then(|body| body.params.get(index)).map_or(false, is_self) {\n                                 \"self\".into()\n                             } else {\n                                 snippet(cx, decl_ty.span, \"_\").into()"}, {"sha": "7314bce83e03867d83c8e6f7e2300d9485360f60", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor as HirVisitor;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -63,7 +63,7 @@ impl<'ast> ast_visit::Visitor<'ast> for ReturnVisitor {\n \n impl EarlyLintPass for RedundantClosureCall {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n         if_chain! {"}, {"sha": "77b6e60d89398e61c55f2377bed0933d1125e20d", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -54,7 +54,8 @@ impl EarlyLintPass for DerefAddrOf {\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let sugg = if e.span.from_expansion() {\n-                    if let Ok(macro_source) = cx.sess.source_map().span_to_snippet(e.span) {\n+                    #[allow(clippy::option_if_let_else)]\n+                    if let Some(macro_source) = snippet_opt(cx, e.span) {\n                         // Remove leading whitespace from the given span\n                         // e.g: ` $visitor` turns into `$visitor`\n                         let trim_leading_whitespaces = |span| {"}, {"sha": "f126908e84b037716fcca1dfca70d532c6734e4c", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 101, "deletions": 115, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,15 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, eq_expr_value};\n+use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, StmtKind};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -70,9 +71,67 @@ impl<'tcx> LateLintPass<'tcx> for Swap {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n+        check_xor_swap(cx, block);\n     }\n }\n \n+fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, span: Span, is_xor_based: bool) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    if !can_mut_borrow_both(cx, e1, e2) {\n+        if let ExprKind::Index(lhs1, idx1) = e1.kind {\n+            if let ExprKind::Index(lhs2, idx2) = e2.kind {\n+                if eq_expr_value(cx, lhs1, lhs2) {\n+                    let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n+\n+                    if matches!(ty.kind(), ty::Slice(_))\n+                        || matches!(ty.kind(), ty::Array(_, _))\n+                        || is_type_diagnostic_item(cx, ty, sym::vec_type)\n+                        || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+                    {\n+                        let slice = Sugg::hir_with_applicability(cx, lhs1, \"<slice>\", &mut applicability);\n+                        span_lint_and_sugg(\n+                            cx,\n+                            MANUAL_SWAP,\n+                            span,\n+                            &format!(\"this looks like you are swapping elements of `{}` manually\", slice),\n+                            \"try\",\n+                            format!(\n+                                \"{}.swap({}, {})\",\n+                                slice.maybe_par(),\n+                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    let first = Sugg::hir_with_applicability(cx, e1, \"..\", &mut applicability);\n+    let second = Sugg::hir_with_applicability(cx, e2, \"..\", &mut applicability);\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_SWAP,\n+        span,\n+        &format!(\"this looks like you are swapping `{}` and `{}` manually\", first, second),\n+        |diag| {\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                applicability,\n+            );\n+            if !is_xor_based {\n+                diag.note(\"or maybe you should use `std::mem::replace`?\");\n+            }\n+        },\n+    );\n+}\n+\n /// Implementation of the `MANUAL_SWAP` lint.\n fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n@@ -96,121 +155,11 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {\n-                if let ExprKind::Field(lhs1, _) = lhs1.kind {\n-                    if let ExprKind::Field(lhs2, _) = lhs2.kind {\n-                        if lhs1.hir_id.owner == lhs2.hir_id.owner {\n-                            return;\n-                        }\n-                    }\n-                }\n-\n-                let mut applicability = Applicability::MachineApplicable;\n-\n-                let slice = check_for_slice(cx, lhs1, lhs2);\n-                let (replace, what, sugg) = if let Slice::NotSwappable = slice {\n-                    return;\n-                } else if let Slice::Swappable(slice, idx1, idx2) = slice {\n-                    if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                        (\n-                            false,\n-                            format!(\" elements of `{}`\", slice),\n-                            format!(\n-                                \"{}.swap({}, {})\",\n-                                slice.maybe_par(),\n-                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n-                            ),\n-                        )\n-                    } else {\n-                        (false, String::new(), String::new())\n-                    }\n-                } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (\n-                        true,\n-                        format!(\" `{}` and `{}`\", first, second),\n-                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n-                    )\n-                } else {\n-                    (true, String::new(), String::new())\n-                };\n-\n                 let span = w[0].span.to(second.span);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_SWAP,\n-                    span,\n-                    &format!(\"this looks like you are swapping{} manually\", what),\n-                    |diag| {\n-                        if !sugg.is_empty() {\n-                            diag.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                sugg,\n-                                applicability,\n-                            );\n-\n-                            if replace {\n-                                diag.note(\"or maybe you should use `std::mem::replace`?\");\n-                            }\n-                        }\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-enum Slice<'a> {\n-    /// `slice.swap(idx1, idx2)` can be used\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = vec![0, 1];\n-    /// let t = a[1];\n-    /// a[1] = a[0];\n-    /// a[0] = t;\n-    /// // can be written as\n-    /// a.swap(0, 1);\n-    /// ```\n-    Swappable(&'a Expr<'a>, &'a Expr<'a>, &'a Expr<'a>),\n-    /// The `swap` function cannot be used.\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = [vec![1, 2], vec![3, 4]];\n-    /// let t = a[0][1];\n-    /// a[0][1] = a[1][0];\n-    /// a[1][0] = t;\n-    /// ```\n-    NotSwappable,\n-    /// Not a slice\n-    None,\n-}\n-\n-/// Checks if both expressions are index operations into \"slice-like\" types.\n-fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n-    if let ExprKind::Index(lhs1, idx1) = lhs1.kind {\n-        if let ExprKind::Index(lhs2, idx2) = lhs2.kind {\n-            if eq_expr_value(cx, lhs1, lhs2) {\n-                let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n-\n-                if matches!(ty.kind(), ty::Slice(_))\n-                    || matches!(ty.kind(), ty::Array(_, _))\n-                    || is_type_diagnostic_item(cx, ty, sym::vec_type)\n-                    || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n-                {\n-                    return Slice::Swappable(lhs1, idx1, idx2);\n-                }\n-            } else {\n-                return Slice::NotSwappable;\n+                generate_swap_warning(cx, lhs1, lhs2, span, false);\n             }\n         }\n     }\n-\n-    Slice::None\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n@@ -262,3 +211,40 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n         }\n     }\n }\n+\n+/// Implementation of the xor case for `MANUAL_SWAP` lint.\n+fn check_xor_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n+    for window in block.stmts.windows(3) {\n+        if_chain! {\n+            if let Some((lhs0, rhs0)) = extract_sides_of_xor_assign(&window[0]);\n+            if let Some((lhs1, rhs1)) = extract_sides_of_xor_assign(&window[1]);\n+            if let Some((lhs2, rhs2)) = extract_sides_of_xor_assign(&window[2]);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs2, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n+            if eq_expr_value(cx, lhs1, rhs2);\n+            then {\n+                let span = window[0].span.to(window[2].span);\n+                generate_swap_warning(cx, lhs0, rhs0, span, true);\n+            }\n+        };\n+    }\n+}\n+\n+/// Returns the lhs and rhs of an xor assignment statement.  \n+fn extract_sides_of_xor_assign<'a, 'hir>(stmt: &'a Stmt<'hir>) -> Option<(&'a Expr<'hir>, &'a Expr<'hir>)> {\n+    if let StmtKind::Semi(expr) = stmt.kind {\n+        if let ExprKind::AssignOp(\n+            Spanned {\n+                node: BinOpKind::BitXor,\n+                ..\n+            },\n+            lhs,\n+            rhs,\n+        ) = expr.kind\n+        {\n+            return Some((lhs, rhs));\n+        }\n+    }\n+    None\n+}"}, {"sha": "371bb8b445a718eceba770325edb1a33fce9ce92", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -186,7 +186,7 @@ declare_clippy_lint! {\n     /// Checks for use of redundant allocations anywhere in the code.\n     ///\n     /// ### Why is this bad?\n-    /// Expressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, Arc<&T>`, `Arc<Rc<T>>`,\n+    /// Expressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, `Arc<&T>`, `Arc<Rc<T>>`,\n     /// `Arc<Arc<T>>`, `Arc<Box<T>>`, `Box<&T>`, `Box<Rc<T>>`, `Box<Arc<T>>`, `Box<Box<T>>`, add an unnecessary level of indirection.\n     ///\n     /// ### Example"}, {"sha": "c8a231341b7e1063828615e67f16678f06c22332", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -35,8 +35,6 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// #![feature(or_patterns)]\n-    ///\n     /// fn main() {\n     ///     if let Some(0 | 2) = Some(0) {}\n     /// }"}, {"sha": "1164ac4938fb6a28edce06017a0c0082869eaa83", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::position_before_rarrow;\n+use clippy_utils::source::{position_before_rarrow, snippet_opt};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_ast::visit::FnKind;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n@@ -125,17 +125,16 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n }\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n-    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        position_before_rarrow(&fn_source).map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-            (\n-                #[allow(clippy::cast_possible_truncation)]\n-                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                Applicability::MachineApplicable,\n-            )\n-        })\n-    } else {\n-        (ty.span, Applicability::MaybeIncorrect)\n-    };\n+    let (ret_span, appl) =\n+        snippet_opt(cx, span.with_hi(ty.span.hi())).map_or((ty.span, Applicability::MaybeIncorrect), |fn_source| {\n+            position_before_rarrow(&fn_source).map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n+        });\n     span_lint_and_sugg(\n         cx,\n         UNUSED_UNIT,"}, {"sha": "a28b1d78f7d463a90f593306b1343ea0dc417bec", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 100, "deletions": 34, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -36,13 +36,13 @@ impl TryConf {\n /// See (rust-clippy#7172)\n macro_rules! define_Conf {\n     ($(\n-        #[doc = $doc:literal]\n+        $(#[doc = $doc:literal])+\n         $(#[conf_deprecated($dep:literal)])?\n         ($name:ident: $ty:ty = $default:expr),\n     )*) => {\n         /// Clippy lint configuration\n         pub struct Conf {\n-            $(#[doc = $doc] pub $name: $ty,)*\n+            $($(#[doc = $doc])+ pub $name: $ty,)*\n         }\n \n         mod defaults {\n@@ -119,7 +119,7 @@ macro_rules! define_Conf {\n                                 stringify!($name),\n                                 stringify!($ty),\n                                 format!(\"{:?}\", super::defaults::$name()),\n-                                $doc,\n+                                concat!($($doc, '\\n',)*),\n                                 deprecation_reason,\n                             )\n                         },\n@@ -132,18 +132,30 @@ macro_rules! define_Conf {\n \n // N.B., this macro is parsed by util/lintlib.py\n define_Conf! {\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION. Suppress lints whenever the suggested change would cause breakage for other crates.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION.\n+    ///\n+    /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n+    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n+    ///\n+    /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n-    /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n+    /// Lint: BLACKLISTED_NAME.\n+    ///\n+    /// The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n-    /// Lint: COGNITIVE_COMPLEXITY. The maximum cognitive complexity a function can have\n+    /// Lint: COGNITIVE_COMPLEXITY.\n+    ///\n+    /// The maximum cognitive complexity a function can have\n     (cognitive_complexity_threshold: u64 = 25),\n-    /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY. Use the Cognitive Complexity lint instead.\n+    /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY.\n+    ///\n+    /// Use the Cognitive Complexity lint instead.\n     #[conf_deprecated(\"Please use `cognitive-complexity-threshold` instead\")]\n     (cyclomatic_complexity_threshold: Option<u64> = None),\n-    /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n+    /// Lint: DOC_MARKDOWN.\n+    ///\n+    /// The list of words this lint should not consider as identifiers needing ticks\n     (doc_valid_idents: Vec<String> = [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n@@ -164,55 +176,109 @@ define_Conf! {\n         \"MinGW\",\n         \"CamelCase\",\n     ].iter().map(ToString::to_string).collect()),\n-    /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n+    /// Lint: TOO_MANY_ARGUMENTS.\n+    ///\n+    /// The maximum number of argument a function or method can have\n     (too_many_arguments_threshold: u64 = 7),\n-    /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n+    /// Lint: TYPE_COMPLEXITY.\n+    ///\n+    /// The maximum complexity a type can have\n     (type_complexity_threshold: u64 = 250),\n-    /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n+    /// Lint: MANY_SINGLE_CHAR_NAMES.\n+    ///\n+    /// The maximum number of single char bindings a scope may have\n     (single_char_binding_names_threshold: u64 = 4),\n-    /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n+    /// Lint: BOXED_LOCAL, USELESS_VEC.\n+    ///\n+    /// The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n     (too_large_for_stack: u64 = 200),\n-    /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n+    /// Lint: ENUM_VARIANT_NAMES.\n+    ///\n+    /// The minimum number of enum variants for the lints about variant names to trigger\n     (enum_variant_name_threshold: u64 = 3),\n-    /// Lint: LARGE_ENUM_VARIANT. The maximum size of a enum's variant to avoid box suggestion\n+    /// Lint: LARGE_ENUM_VARIANT.\n+    ///\n+    /// The maximum size of a enum's variant to avoid box suggestion\n     (enum_variant_size_threshold: u64 = 200),\n-    /// Lint: VERBOSE_BIT_MASK. The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros'\n+    /// Lint: VERBOSE_BIT_MASK.\n+    ///\n+    /// The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros'\n     (verbose_bit_mask_threshold: u64 = 1),\n-    /// Lint: DECIMAL_LITERAL_REPRESENTATION. The lower bound for linting decimal literals\n+    /// Lint: DECIMAL_LITERAL_REPRESENTATION.\n+    ///\n+    /// The lower bound for linting decimal literals\n     (literal_representation_threshold: u64 = 16384),\n-    /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n+    /// Lint: TRIVIALLY_COPY_PASS_BY_REF.\n+    ///\n+    /// The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n     (trivial_copy_size_limit: Option<u64> = None),\n-    /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n+    /// Lint: LARGE_TYPE_PASS_BY_MOVE.\n+    ///\n+    /// The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n     (pass_by_value_size_limit: u64 = 256),\n-    /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n+    /// Lint: TOO_MANY_LINES.\n+    ///\n+    /// The maximum number of lines a function or method can have\n     (too_many_lines_threshold: u64 = 100),\n-    /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack\n+    /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS.\n+    ///\n+    /// The maximum allowed size for arrays on the stack\n     (array_size_threshold: u64 = 512_000),\n-    /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n+    /// Lint: VEC_BOX.\n+    ///\n+    /// The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n     (vec_box_size_threshold: u64 = 4096),\n-    /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n+    /// Lint: TYPE_REPETITION_IN_BOUNDS.\n+    ///\n+    /// The maximum number of bounds a trait can have to be linted\n     (max_trait_bounds: u64 = 3),\n-    /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bool fields a struct can have\n+    /// Lint: STRUCT_EXCESSIVE_BOOLS.\n+    ///\n+    /// The maximum number of bool fields a struct can have\n     (max_struct_bools: u64 = 3),\n-    /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bool parameters a function can have\n+    /// Lint: FN_PARAMS_EXCESSIVE_BOOLS.\n+    ///\n+    /// The maximum number of bool parameters a function can have\n     (max_fn_params_bools: u64 = 3),\n-    /// Lint: WILDCARD_IMPORTS. Whether to allow certain wildcard imports (prelude, super in tests).\n+    /// Lint: WILDCARD_IMPORTS.\n+    ///\n+    /// Whether to allow certain wildcard imports (prelude, super in tests).\n     (warn_on_all_wildcard_imports: bool = false),\n-    /// Lint: DISALLOWED_METHOD. The list of disallowed methods, written as fully qualified paths.\n+    /// Lint: DISALLOWED_METHOD.\n+    ///\n+    /// The list of disallowed methods, written as fully qualified paths.\n     (disallowed_methods: Vec<String> = Vec::new()),\n-    /// Lint: DISALLOWED_TYPE. The list of disallowed types, written as fully qualified paths.\n+    /// Lint: DISALLOWED_TYPE.\n+    ///\n+    /// The list of disallowed types, written as fully qualified paths.\n     (disallowed_types: Vec<String> = Vec::new()),\n-    /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n+    /// Lint: UNREADABLE_LITERAL.\n+    ///\n+    /// Should the fraction of a decimal be linted to include separators.\n     (unreadable_literal_lint_fractions: bool = true),\n-    /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n+    /// Lint: UPPER_CASE_ACRONYMS.\n+    ///\n+    /// Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n     (upper_case_acronyms_aggressive: bool = false),\n-    /// Lint: _CARGO_COMMON_METADATA. For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n+    /// Lint: _CARGO_COMMON_METADATA.\n+    ///\n+    /// For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n     (cargo_ignore_publish: bool = false),\n-    /// Lint: NONSTANDARD_MACRO_BRACES. Enforce the named macros always use the braces specified. <br> A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro is could be used with a full path two `MacroMatcher`s have to be added one with the full path `crate_name::macro_name` and one with just the macro name.\n+    /// Lint: NONSTANDARD_MACRO_BRACES.\n+    ///\n+    /// Enforce the named macros always use the braces specified.\n+    ///\n+    /// A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n+    /// is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n+    /// `crate_name::macro_name` and one with just the macro name.\n     (standard_macro_braces: Vec<crate::nonstandard_macro_braces::MacroMatcher> = Vec::new()),\n-    /// Lint: MISSING_ENFORCED_IMPORT_RENAMES. The list of imports to always rename, a fully qualified path followed by the rename.\n+    /// Lint: MISSING_ENFORCED_IMPORT_RENAMES.\n+    ///\n+    /// The list of imports to always rename, a fully qualified path followed by the rename.\n     (enforced_import_renames: Vec<crate::utils::conf::Rename> = Vec::new()),\n-    /// Lint: RESTRICTED_SCRIPTS. The list of unicode scripts allowed to be used in the scope.\n+    /// Lint: RESTRICTED_SCRIPTS.\n+    ///\n+    /// The list of unicode scripts allowed to be used in the scope.\n     (allowed_scripts: Vec<String> = vec![\"Latin\".to_string()]),\n }\n "}, {"sha": "a48a53850830f3e41dbd6f61a3ab59a66bab8ff2", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -82,7 +82,7 @@ This lint has the following configuration variables:\n /// `default`\n macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n     () => {\n-        \"* {name}: {ty}: {doc} (defaults to `{default}`)\\n\"\n+        \"* {name}: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n     };\n }\n \n@@ -344,11 +344,16 @@ fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n         if let Some(split_pos) = doc_comment.find('.');\n         then {\n             let mut doc_comment = doc_comment.to_string();\n-            let documentation = doc_comment.split_off(split_pos);\n+            let mut documentation = doc_comment.split_off(split_pos);\n \n+            // Extract lints\n             doc_comment.make_ascii_lowercase();\n             let lints: Vec<String> = doc_comment.split_off(DOC_START.len()).split(\", \").map(str::to_string).collect();\n \n+            // Format documentation correctly\n+            // split off leading `.` from lint name list and indent for correct formatting\n+            documentation = documentation.trim_start_matches('.').trim().replace(\"\\n \", \"\\n    \");\n+\n             Some((lints, documentation))\n         } else {\n             None"}, {"sha": "71cfa196fc335f93d7b62e5d0234e08a08f33780", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -65,7 +65,7 @@ pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: impl Into<Mult\n ///\n /// # Example\n ///\n-/// ```ignore\n+/// ```text\n /// error: constant division of 0.0 with 0.0 will always result in NaN\n ///   --> $DIR/zero_div_zero.rs:6:25\n ///    |\n@@ -103,7 +103,7 @@ pub fn span_lint_and_help<'a, T: LintContext>(\n ///\n /// # Example\n ///\n-/// ```ignore\n+/// ```text\n /// error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n ///   --> $DIR/drop_forget_ref.rs:10:5\n ///    |\n@@ -189,7 +189,7 @@ pub fn span_lint_hir_and_then(\n ///\n /// # Example\n ///\n-/// ```ignore\n+/// ```text\n /// error: This `.fold` can be more succinctly expressed as `.any`\n /// --> $DIR/methods.rs:390:13\n ///     |"}, {"sha": "884180f0586e38a237d4f7e8561115e6a8f6ea67", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -195,8 +195,8 @@ pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<Ve\n /// - `assert!`, `assert_eq!` and `assert_ne!`\n /// - `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!`\n /// For example:\n-/// `assert!(expr)` will return Some([expr])\n-/// `debug_assert_eq!(a, b)` will return Some([a, b])\n+/// `assert!(expr)` will return `Some([expr])`\n+/// `debug_assert_eq!(a, b)` will return `Some([a, b])`\n pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx Expr<'tcx>>> {\n     /// Try to match the AST for a pattern that contains a match, for example when two args are\n     /// compared\n@@ -283,7 +283,7 @@ pub struct FormatArgsExpn<'tcx> {\n \n     /// String literal expressions which represent the format string split by \"{}\"\n     pub format_string_parts: &'tcx [Expr<'tcx>],\n-    /// Symbols corresponding to [`format_string_parts`]\n+    /// Symbols corresponding to [`Self::format_string_parts`]\n     pub format_string_symbols: Vec<Symbol>,\n     /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n     pub args: &'tcx [Expr<'tcx>],"}, {"sha": "1d59d6bfea1b9792b314de615677809119efa94b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -326,6 +326,25 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n         .map_or(false, |did| is_diag_trait_item(cx, did, diag_item))\n }\n \n+/// Checks if the given expression is a path referring an item on the trait\n+/// that is marked with the given diagnostic item.\n+///\n+/// For checking method call expressions instead of path expressions, use\n+/// [`is_trait_method`].\n+///\n+/// For example, this can be used to find if an expression like `u64::default`\n+/// refers to an item of the trait `Default`, which is associated with the\n+/// `diag_item` of `sym::Default`.\n+pub fn is_trait_item(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n+    if let hir::ExprKind::Path(ref qpath) = expr.kind {\n+        cx.qpath_res(qpath, expr.hir_id)\n+            .opt_def_id()\n+            .map_or(false, |def_id| is_diag_trait_item(cx, def_id, diag_item))\n+    } else {\n+        false\n+    }\n+}\n+\n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n@@ -558,6 +577,54 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// This method will return tuple of projection stack and root of the expression,\n+/// used in `can_mut_borrow_both`.\n+///\n+/// For example, if `e` represents the `v[0].a.b[x]`\n+/// this method will return a tuple, composed of a `Vec`\n+/// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n+/// and a `Expr` for root of them, `v`\n+fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n+    let mut result = vec![];\n+    let root = loop {\n+        match e.kind {\n+            ExprKind::Index(ep, _) | ExprKind::Field(ep, _) => {\n+                result.push(e);\n+                e = ep;\n+            },\n+            _ => break e,\n+        };\n+    };\n+    result.reverse();\n+    (result, root)\n+}\n+\n+/// Checks if two expressions can be mutably borrowed simultaneously\n+/// and they aren't dependent on borrowing same thing twice\n+pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -> bool {\n+    let (s1, r1) = projection_stack(e1);\n+    let (s2, r2) = projection_stack(e2);\n+    if !eq_expr_value(cx, r1, r2) {\n+        return true;\n+    }\n+    for (x1, x2) in s1.iter().zip(s2.iter()) {\n+        match (&x1.kind, &x2.kind) {\n+            (ExprKind::Field(_, i1), ExprKind::Field(_, i2)) => {\n+                if i1 != i2 {\n+                    return true;\n+                }\n+            },\n+            (ExprKind::Index(_, i1), ExprKind::Index(_, i2)) => {\n+                if !eq_expr_value(cx, i1, i2) {\n+                    return false;\n+                }\n+            },\n+            _ => return false,\n+        }\n+    }\n+    false\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n     match expr.kind {"}, {"sha": "789079510c5e80fa7251536eeda79336d99e7777", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -168,7 +168,7 @@ pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n-/// Same as `snippet`, but it adapts the applicability level by following rules:\n+/// Same as [`snippet`], but it adapts the applicability level by following rules:\n ///\n /// - Applicability level `Unspecified` will never be changed.\n /// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`."}, {"sha": "4f9aaf396b806dbe0b7d56c8eab2298e9af18922", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -114,7 +114,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n \n /// Checks whether a type implements a trait.\n /// The function returns false in case the type contains an inference variable.\n-/// See also `get_trait_def_id`.\n+/// See also [`get_trait_def_id`](super::get_trait_def_id).\n pub fn implements_trait<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "ff2e0417435bfe72edb635fd725cb476cf47a335", "filename": "doc/basics.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -166,8 +166,8 @@ rustup component add clippy\n ```\n \n > **DO NOT** install using `cargo install --path . --force` since this will overwrite rustup\n-[proxies](https://rust-lang.github.io/rustup/concepts/proxies.html). That is, `~/.cargo/bin/cargo-clippy` and\n-`~/.cargo/bin/clippy-driver` should be hard or soft links to `~/.cargo/bin/rustup`. You can repair these by running\n-`rustup update`.\n+> [proxies](https://rust-lang.github.io/rustup/concepts/proxies.html). That is, `~/.cargo/bin/cargo-clippy` and\n+> `~/.cargo/bin/clippy-driver` should be hard or soft links to `~/.cargo/bin/rustup`. You can repair these by running\n+> `rustup update`.\n \n [glossary]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html"}, {"sha": "23887f178454972c47b777c305ded39a12d84fbf", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-07-29\"\n+channel = \"nightly-2021-08-12\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "33a3ef7513631aab7d1fb367d49c9993ab1c44ad", "filename": "tests/ui-toml/functions_maxlines/test.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+\n #![warn(clippy::too_many_lines)]\n \n // This function should be considered one line.\n@@ -20,6 +22,20 @@ fn too_many_lines() {\n     println!(\"This is bad.\");\n }\n \n+// This should only fail once (#7517).\n+async fn async_too_many_lines() {\n+    println!(\"This is bad.\");\n+    println!(\"This is bad.\");\n+}\n+\n+// This should fail only once, without failing on the closure.\n+fn closure_too_many_lines() {\n+    let _ = {\n+        println!(\"This is bad.\");\n+        println!(\"This is bad.\");\n+    };\n+}\n+\n // This should be considered one line.\n #[rustfmt::skip]\n fn comment_starts_after_code() {"}, {"sha": "7551cac9f504b968918e65f3d82ae0ee1b800cf0", "filename": "tests/ui-toml/functions_maxlines/test.stderr", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,5 +1,5 @@\n error: this function has too many lines (2/1)\n-  --> $DIR/test.rs:18:1\n+  --> $DIR/test.rs:20:1\n    |\n LL | / fn too_many_lines() {\n LL | |     println!(\"This is bad.\");\n@@ -9,8 +9,28 @@ LL | | }\n    |\n    = note: `-D clippy::too-many-lines` implied by `-D warnings`\n \n+error: this function has too many lines (4/1)\n+  --> $DIR/test.rs:26:1\n+   |\n+LL | / async fn async_too_many_lines() {\n+LL | |     println!(\"This is bad.\");\n+LL | |     println!(\"This is bad.\");\n+LL | | }\n+   | |_^\n+\n+error: this function has too many lines (4/1)\n+  --> $DIR/test.rs:32:1\n+   |\n+LL | / fn closure_too_many_lines() {\n+LL | |     let _ = {\n+LL | |         println!(\"This is bad.\");\n+LL | |         println!(\"This is bad.\");\n+LL | |     };\n+LL | | }\n+   | |_^\n+\n error: this function has too many lines (2/1)\n-  --> $DIR/test.rs:38:1\n+  --> $DIR/test.rs:54:1\n    |\n LL | / fn comment_before_code() {\n LL | |     let _ = \"test\";\n@@ -19,5 +39,5 @@ LL | |     the code but this line should still count. */ let _ = 5;\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "5b4adc868dff19259611c087a3623dfdacf2d3d0", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -32,13 +32,19 @@ macro_rules! type_pos {\n     };\n }\n \n+macro_rules! printlnfoo {\n+    ($thing:expr) => {\n+        println!(\"{}\", $thing)\n+    };\n+}\n+\n #[rustfmt::skip]\n fn main() {\n     let _ = vec! {1, 2, 3};\n     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n     let _ = quote!(let x = 1;);\n     let _ = quote::quote!(match match match);\n-    let _ = test!();\n+    let _ = test!(); // trigger when macro def is inside our own crate\n     let _ = vec![1,2,3];\n \n     let _ = quote::quote! {true || false};\n@@ -49,4 +55,6 @@ fn main() {\n     let _: type_pos!(usize) = vec![];\n \n     eprint!(\"test if user config overrides defaults\");\n+\n+    printlnfoo![\"test if printlnfoo is triggered by println\"];\n }"}, {"sha": "87e962b9228c4b74627e5d7623761b0f5a246141", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,48 +1,48 @@\n error: use of irregular braces for `vec!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:37:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:43:13\n    |\n LL |     let _ = vec! {1, 2, 3};\n    |             ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::nonstandard-macro-braces` implied by `-D warnings`\n help: consider writing `vec![1, 2, 3]`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:37:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:43:13\n    |\n LL |     let _ = vec! {1, 2, 3};\n    |             ^^^^^^^^^^^^^^\n \n error: use of irregular braces for `format!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:38:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:44:13\n    |\n LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `format!(\"ugh () stop being such a good compiler\", \"hello\")`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:38:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:44:13\n    |\n LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `quote!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:39:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:45:13\n    |\n LL |     let _ = quote!(let x = 1;);\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `quote! {let x = 1;}`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:39:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:45:13\n    |\n LL |     let _ = quote!(let x = 1;);\n    |             ^^^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `quote::quote!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:40:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:46:13\n    |\n LL |     let _ = quote::quote!(match match match);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `quote::quote! {match match match}`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:40:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:46:13\n    |\n LL |     let _ = quote::quote!(match match match);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,7 +53,7 @@ error: use of irregular braces for `vec!` macro\n LL |         vec!{0, 0, 0}\n    |         ^^^^^^^^^^^^^\n ...\n-LL |     let _ = test!();\n+LL |     let _ = test!(); // trigger when macro def is inside our own crate\n    |             ------- in this macro invocation\n    |\n help: consider writing `vec![0, 0, 0]`\n@@ -62,30 +62,30 @@ help: consider writing `vec![0, 0, 0]`\n LL |         vec!{0, 0, 0}\n    |         ^^^^^^^^^^^^^\n ...\n-LL |     let _ = test!();\n+LL |     let _ = test!(); // trigger when macro def is inside our own crate\n    |             ------- in this macro invocation\n    = note: this error originates in the macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: use of irregular braces for `type_pos!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:49:12\n+  --> $DIR/conf_nonstandard_macro_braces.rs:55:12\n    |\n LL |     let _: type_pos!(usize) = vec![];\n    |            ^^^^^^^^^^^^^^^^\n    |\n help: consider writing `type_pos![usize]`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:49:12\n+  --> $DIR/conf_nonstandard_macro_braces.rs:55:12\n    |\n LL |     let _: type_pos!(usize) = vec![];\n    |            ^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `eprint!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:51:5\n+  --> $DIR/conf_nonstandard_macro_braces.rs:57:5\n    |\n LL |     eprint!(\"test if user config overrides defaults\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `eprint![\"test if user config overrides defaults\"];`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:51:5\n+  --> $DIR/conf_nonstandard_macro_braces.rs:57:5\n    |\n LL |     eprint!(\"test if user config overrides defaults\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "624ca892add310fa3acd8197a9cd33c034781106", "filename": "tests/ui/auxiliary/test_macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fauxiliary%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fauxiliary%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Ftest_macro.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "previous_filename": "tests/auxiliary/test_macro.rs"}, {"sha": "e863870e7d61b01ae9dfe0992264b7707a2d0507", "filename": "tests/ui/extend_with_drain.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextend_with_drain.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -41,7 +41,12 @@ fn main() {\n \n     let mut heap = BinaryHeap::from(vec![1, 3]);\n     let mut heap2 = BinaryHeap::from(vec![]);\n-    heap2.extend(heap.drain())\n+    heap2.extend(heap.drain());\n+\n+    let mut x = vec![0, 1, 2, 3, 5];\n+    let ref_x = &mut x;\n+    let mut y = Vec::new();\n+    y.append(ref_x);\n }\n \n fn return_vector() -> Vec<u8> {"}, {"sha": "dcb36b5951cb28285a2b973b5aa19b692a009d9c", "filename": "tests/ui/extend_with_drain.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextend_with_drain.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -41,7 +41,12 @@ fn main() {\n \n     let mut heap = BinaryHeap::from(vec![1, 3]);\n     let mut heap2 = BinaryHeap::from(vec![]);\n-    heap2.extend(heap.drain())\n+    heap2.extend(heap.drain());\n+\n+    let mut x = vec![0, 1, 2, 3, 5];\n+    let ref_x = &mut x;\n+    let mut y = Vec::new();\n+    y.extend(ref_x.drain(..));\n }\n \n fn return_vector() -> Vec<u8> {"}, {"sha": "da14ddb25b373754412fe99adb23f80b0a71f60c", "filename": "tests/ui/extend_with_drain.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fextend_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextend_with_drain.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -18,5 +18,11 @@ error: use of `extend` instead of `append` for adding the full range of a second\n LL |     vec11.extend(return_vector().drain(..));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec11.append(&mut return_vector())`\n \n-error: aborting due to 3 previous errors\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/extend_with_drain.rs:49:5\n+   |\n+LL |     y.extend(ref_x.drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `y.append(ref_x)`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "97c26bc83ad4b4af2b919c4ecf53c30fcd4fd66a", "filename": "tests/ui/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -89,7 +89,7 @@ gen!(fn bar);\n // and should not cause an ICE\n // See #2707\n #[macro_use]\n-#[path = \"../auxiliary/test_macro.rs\"]\n+#[path = \"auxiliary/test_macro.rs\"]\n pub mod test_macro;\n __implicit_hasher_test_macro!(impl<K, V> for HashMap<K, V> where V: test_macro::A);\n "}, {"sha": "18846c898da051566ee99796f98af0724f91def5", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -5,6 +5,7 @@\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n #![allow(clippy::unnecessary_wraps)]\n+#![feature(result_flattening)]\n \n fn main() {\n     // mapping to Option on Iterator\n@@ -23,4 +24,7 @@ fn main() {\n \n     // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).and_then(|x| x);\n+\n+    // mapping to Result on Result\n+    let _: Result<_, &str> = (Ok(Ok(1))).and_then(|x| x);\n }"}, {"sha": "01db27876da703a698c4b0da0ccef2dcba2cf790", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -5,6 +5,7 @@\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n #![allow(clippy::unnecessary_wraps)]\n+#![feature(result_flattening)]\n \n fn main() {\n     // mapping to Option on Iterator\n@@ -23,4 +24,7 @@ fn main() {\n \n     // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n+\n+    // mapping to Result on Result\n+    let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n }"}, {"sha": "38457c8ea4dd4ad16de7cb16eb7c880c90d176cf", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,40 +1,46 @@\n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:16:46\n+  --> $DIR/map_flatten.rs:17:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:17:46\n+  --> $DIR/map_flatten.rs:18:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:18:46\n+  --> $DIR/map_flatten.rs:19:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:19:46\n+  --> $DIR/map_flatten.rs:20:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:22:46\n+  --> $DIR/map_flatten.rs:23:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:25:39\n+  --> $DIR/map_flatten.rs:26:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n-error: aborting due to 6 previous errors\n+error: called `map(..).flatten()` on an `Result`\n+  --> $DIR/map_flatten.rs:29:41\n+   |\n+LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "f49b23924efe8b5c52fb807098bf3fd5760c570b", "filename": "tests/ui/never_loop.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fnever_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fnever_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -75,6 +75,11 @@ LL | |             _ => return,\n LL | |         }\n LL | |     }\n    | |_____^\n+   |\n+help: if you need the first element of the iterator, try writing\n+   |\n+LL |     if let Some(x) = (0..10).next() {\n+   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: this loop never actually loops\n   --> $DIR/never_loop.rs:157:5"}, {"sha": "6b24675ac2d42a8a934a85989394ca2920c44895", "filename": "tests/ui/no_effect.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fno_effect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fno_effect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fno_effect.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -108,6 +108,12 @@ error: statement with no effect\n LL |     5..6;\n    |     ^^^^^\n \n+error: statement with no effect\n+  --> $DIR/no_effect.rs:83:5\n+   |\n+LL |     5..=6;\n+   |     ^^^^^^\n+\n error: statement with no effect\n   --> $DIR/no_effect.rs:84:5\n    |\n@@ -150,5 +156,5 @@ error: statement with no effect\n LL |     FooString { s: s };\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "c2f94d0e8575650272656acba755013a0de37ddb", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -18,6 +18,19 @@ fn or_fun_call() {\n         }\n     }\n \n+    struct FakeDefault;\n+    impl FakeDefault {\n+        fn default() -> Self {\n+            FakeDefault\n+        }\n+    }\n+\n+    impl Default for FakeDefault {\n+        fn default() -> Self {\n+            FakeDefault\n+        }\n+    }\n+\n     enum Enum {\n         A(i32),\n     }\n@@ -53,6 +66,12 @@ fn or_fun_call() {\n     let with_default_type = Some(1);\n     with_default_type.unwrap_or_default();\n \n+    let self_default = None::<FakeDefault>;\n+    self_default.unwrap_or_else(<FakeDefault>::default);\n+\n+    let real_default = None::<FakeDefault>;\n+    real_default.unwrap_or_default();\n+\n     let with_vec = Some(vec![1]);\n     with_vec.unwrap_or_default();\n "}, {"sha": "afaf92961b0274f75d9e5ffbbd2f40b606fb876a", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -18,6 +18,19 @@ fn or_fun_call() {\n         }\n     }\n \n+    struct FakeDefault;\n+    impl FakeDefault {\n+        fn default() -> Self {\n+            FakeDefault\n+        }\n+    }\n+\n+    impl Default for FakeDefault {\n+        fn default() -> Self {\n+            FakeDefault\n+        }\n+    }\n+\n     enum Enum {\n         A(i32),\n     }\n@@ -53,6 +66,12 @@ fn or_fun_call() {\n     let with_default_type = Some(1);\n     with_default_type.unwrap_or(u64::default());\n \n+    let self_default = None::<FakeDefault>;\n+    self_default.unwrap_or(<FakeDefault>::default());\n+\n+    let real_default = None::<FakeDefault>;\n+    real_default.unwrap_or(<FakeDefault as Default>::default());\n+\n     let with_vec = Some(vec![1]);\n     with_vec.unwrap_or(vec![]);\n "}, {"sha": "b2bcbd38c2df36061eefebf4f788821471955d6f", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,136 +1,148 @@\n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:33:19\n+  --> $DIR/or_fun_call.rs:46:19\n    |\n LL |     with_const_fn.unwrap_or(Duration::from_secs(5));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Duration::from_secs(5))`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:36:22\n+  --> $DIR/or_fun_call.rs:49:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/or_fun_call.rs:39:5\n+  --> $DIR/or_fun_call.rs:52:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:42:21\n+  --> $DIR/or_fun_call.rs:55:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:45:14\n+  --> $DIR/or_fun_call.rs:58:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:48:19\n+  --> $DIR/or_fun_call.rs:61:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/or_fun_call.rs:51:5\n+  --> $DIR/or_fun_call.rs:64:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/or_fun_call.rs:54:5\n+  --> $DIR/or_fun_call.rs:67:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:70:18\n+   |\n+LL |     self_default.unwrap_or(<FakeDefault>::default());\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(<FakeDefault>::default)`\n+\n+error: use of `unwrap_or` followed by a call to `default`\n+  --> $DIR/or_fun_call.rs:73:5\n+   |\n+LL |     real_default.unwrap_or(<FakeDefault as Default>::default());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `real_default.unwrap_or_default()`\n+\n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/or_fun_call.rs:57:5\n+  --> $DIR/or_fun_call.rs:76:5\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_vec.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:60:21\n+  --> $DIR/or_fun_call.rs:79:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:63:19\n+  --> $DIR/or_fun_call.rs:82:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:66:23\n+  --> $DIR/or_fun_call.rs:85:23\n    |\n LL |     map_vec.entry(42).or_insert(vec![]);\n    |                       ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:69:21\n+  --> $DIR/or_fun_call.rs:88:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:72:25\n+  --> $DIR/or_fun_call.rs:91:25\n    |\n LL |     btree_vec.entry(42).or_insert(vec![]);\n    |                         ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:75:21\n+  --> $DIR/or_fun_call.rs:94:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:83:21\n+  --> $DIR/or_fun_call.rs:102:21\n    |\n LL |     let _ = Some(1).unwrap_or(map[&1]);\n    |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:85:21\n+  --> $DIR/or_fun_call.rs:104:21\n    |\n LL |     let _ = Some(1).unwrap_or(map[&1]);\n    |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:109:35\n+  --> $DIR/or_fun_call.rs:128:35\n    |\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:113:10\n+  --> $DIR/or_fun_call.rs:132:10\n    |\n LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:141:14\n+  --> $DIR/or_fun_call.rs:160:14\n    |\n LL |         None.unwrap_or(s.as_mut_vec());\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| s.as_mut_vec())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:146:14\n+  --> $DIR/or_fun_call.rs:165:14\n    |\n LL |         None.unwrap_or(unsafe { s.as_mut_vec() });\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { s.as_mut_vec() })`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:148:14\n+  --> $DIR/or_fun_call.rs:167:14\n    |\n LL |         None.unwrap_or( unsafe { s.as_mut_vec() }    );\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| unsafe { s.as_mut_vec() })`\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "daa073414577c8bfd897f37fe8b9a944eb063fe3", "filename": "tests/ui/similar_names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fsimilar_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fsimilar_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -76,6 +76,9 @@ fn main() {\n     // names often used in win32 code (for example WindowProc)\n     let wparam: i32;\n     let lparam: i32;\n+\n+    let iter: i32;\n+    let item: i32;\n }\n \n fn foo() {"}, {"sha": "f621595abaea2ee295423dbcb04b990f63b7184c", "filename": "tests/ui/similar_names.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fsimilar_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fsimilar_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -72,13 +72,13 @@ LL |     let parser: i32;\n    |         ^^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:85:16\n+  --> $DIR/similar_names.rs:88:16\n    |\n LL |         bpple: sprang,\n    |                ^^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:84:16\n+  --> $DIR/similar_names.rs:87:16\n    |\n LL |         apple: spring,\n    |                ^^^^^^"}, {"sha": "ef518359ec5f373614727442c65526c05a5c1899", "filename": "tests/ui/swap.fixed", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -20,9 +21,7 @@ struct Bar {\n fn field() {\n     let mut bar = Bar { a: 1, b: 2 };\n \n-    let temp = bar.a;\n-    bar.a = bar.b;\n-    bar.b = temp;\n+    std::mem::swap(&mut bar.a, &mut bar.b);\n \n     let mut baz = vec![bar.clone(), bar.clone()];\n     let temp = baz[0].a;\n@@ -51,6 +50,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -60,13 +60,54 @@ fn vec() {\n     foo.swap(0, 1);\n }\n \n+fn xor_swap_locals() {\n+    // This is an xor-based swap of local variables.\n+    let mut a = 0;\n+    let mut b = 1;\n+    std::mem::swap(&mut a, &mut b)\n+}\n+\n+fn xor_field_swap() {\n+    // This is an xor-based swap of fields in a struct.\n+    let mut bar = Bar { a: 0, b: 1 };\n+    std::mem::swap(&mut bar.a, &mut bar.b)\n+}\n+\n+fn xor_slice_swap() {\n+    // This is an xor-based swap of a slice\n+    let foo = &mut [1, 2];\n+    foo.swap(0, 1)\n+}\n+\n+fn xor_no_swap() {\n+    // This is a sequence of xor-assignment statements that doesn't result in a swap.\n+    let mut a = 0;\n+    let mut b = 1;\n+    let mut c = 2;\n+    a ^= b;\n+    b ^= c;\n+    a ^= c;\n+    c ^= a;\n+}\n+\n+fn xor_unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    foo[0][1] ^= foo[1][0];\n+    foo[1][0] ^= foo[0][0];\n+    foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    std::mem::swap(&mut foo[0][1], &mut bar[1][0]);\n+}\n+\n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "8518659ccf316dbbf41ce2e9941b3874c5878092", "filename": "tests/ui/swap.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -55,6 +56,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -66,13 +68,62 @@ fn vec() {\n     foo.swap(0, 1);\n }\n \n+fn xor_swap_locals() {\n+    // This is an xor-based swap of local variables.\n+    let mut a = 0;\n+    let mut b = 1;\n+    a ^= b;\n+    b ^= a;\n+    a ^= b;\n+}\n+\n+fn xor_field_swap() {\n+    // This is an xor-based swap of fields in a struct.\n+    let mut bar = Bar { a: 0, b: 1 };\n+    bar.a ^= bar.b;\n+    bar.b ^= bar.a;\n+    bar.a ^= bar.b;\n+}\n+\n+fn xor_slice_swap() {\n+    // This is an xor-based swap of a slice\n+    let foo = &mut [1, 2];\n+    foo[0] ^= foo[1];\n+    foo[1] ^= foo[0];\n+    foo[0] ^= foo[1];\n+}\n+\n+fn xor_no_swap() {\n+    // This is a sequence of xor-assignment statements that doesn't result in a swap.\n+    let mut a = 0;\n+    let mut b = 1;\n+    let mut c = 2;\n+    a ^= b;\n+    b ^= c;\n+    a ^= c;\n+    c ^= a;\n+}\n+\n+fn xor_unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    foo[0][1] ^= foo[1][0];\n+    foo[1][0] ^= foo[0][0];\n+    foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    let temp = foo[0][1];\n+    foo[0][1] = bar[1][0];\n+    bar[1][0] = temp;\n+}\n+\n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "614d16ced40f1b5fd02cf899f86f5a0f38a9b6a5", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -1,31 +1,74 @@\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:24:5\n+   |\n+LL | /     let temp = bar.a;\n+LL | |     bar.a = bar.b;\n+LL | |     bar.b = temp;\n+   | |________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+   |\n+   = note: `-D clippy::manual-swap` implied by `-D warnings`\n+   = note: or maybe you should use `std::mem::replace`?\n+\n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:35:5\n+  --> $DIR/swap.rs:36:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n-   |\n-   = note: `-D clippy::manual-swap` implied by `-D warnings`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:44:5\n+  --> $DIR/swap.rs:45:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:62:5\n+  --> $DIR/swap.rs:64:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping `a` and `b` manually\n-  --> $DIR/swap.rs:83:7\n+  --> $DIR/swap.rs:75:5\n+   |\n+LL | /     a ^= b;\n+LL | |     b ^= a;\n+LL | |     a ^= b;\n+   | |___________^ help: try: `std::mem::swap(&mut a, &mut b)`\n+\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:83:5\n+   |\n+LL | /     bar.a ^= bar.b;\n+LL | |     bar.b ^= bar.a;\n+LL | |     bar.a ^= bar.b;\n+   | |___________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+\n+error: this looks like you are swapping elements of `foo` manually\n+  --> $DIR/swap.rs:91:5\n+   |\n+LL | /     foo[0] ^= foo[1];\n+LL | |     foo[1] ^= foo[0];\n+LL | |     foo[0] ^= foo[1];\n+   | |_____________________^ help: try: `foo.swap(0, 1)`\n+\n+error: this looks like you are swapping `foo[0][1]` and `bar[1][0]` manually\n+  --> $DIR/swap.rs:120:5\n+   |\n+LL | /     let temp = foo[0][1];\n+LL | |     foo[0][1] = bar[1][0];\n+LL | |     bar[1][0] = temp;\n+   | |____________________^ help: try: `std::mem::swap(&mut foo[0][1], &mut bar[1][0])`\n+   |\n+   = note: or maybe you should use `std::mem::replace`?\n+\n+error: this looks like you are swapping `a` and `b` manually\n+  --> $DIR/swap.rs:134:7\n    |\n LL |       ; let t = a;\n    |  _______^\n@@ -36,7 +79,7 @@ LL | |     b = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are swapping `c.0` and `a` manually\n-  --> $DIR/swap.rs:92:7\n+  --> $DIR/swap.rs:143:7\n    |\n LL |       ; let t = c.0;\n    |  _______^\n@@ -47,7 +90,7 @@ LL | |     a = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `a` and `b`\n-  --> $DIR/swap.rs:80:5\n+  --> $DIR/swap.rs:131:5\n    |\n LL | /     a = b;\n LL | |     b = a;\n@@ -57,13 +100,13 @@ LL | |     b = a;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `c.0` and `a`\n-  --> $DIR/swap.rs:89:5\n+  --> $DIR/swap.rs:140:5\n    |\n LL | /     c.0 = a;\n LL | |     a = c.0;\n    | |___________^ help: try: `std::mem::swap(&mut c.0, &mut a)`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "1a0123803a3ee9f482baf3d7141630a143d766fc", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -58,6 +58,8 @@ impl Foo {\n     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n \n     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n+\n+    fn bad_issue7518(self, other: &Self) {}\n }\n \n impl AsRef<u32> for Foo {"}, {"sha": "9c4c49ceac476f5f31ab13e24bef29d696ba3dc8", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -65,40 +65,46 @@ LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:72:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:62:35\n+   |\n+LL |     fn bad_issue7518(self, other: &Self) {}\n+   |                                   ^^^^^ help: consider passing by value instead: `Self`\n+\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:16\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:72:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:25\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:72:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:34\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:76:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:78:34\n    |\n LL |     fn trait_method(&self, _foo: &Foo);\n    |                                  ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:108:21\n+  --> $DIR/trivially_copy_pass_by_ref.rs:110:21\n    |\n LL |     fn foo_never(x: &i32) {\n    |                     ^^^^ help: consider passing by value instead: `i32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:113:15\n+  --> $DIR/trivially_copy_pass_by_ref.rs:115:15\n    |\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "7ac3f426c9775c5062aa3260f00a2e0247e6757e", "filename": "tests/ui/unwrap_or_else_default.fixed", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_or_else_default.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -0,0 +1,71 @@\n+// run-rustfix\n+\n+#![warn(clippy::unwrap_or_else_default)]\n+#![allow(dead_code)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+/// Checks implementation of the `UNWRAP_OR_ELSE_DEFAULT` lint.\n+fn unwrap_or_else_default() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo\n+        }\n+\n+        // fake default, we should not trigger on this\n+        fn default() -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    struct HasDefaultAndDuplicate;\n+\n+    impl HasDefaultAndDuplicate {\n+        fn default() -> Self {\n+            HasDefaultAndDuplicate\n+        }\n+    }\n+\n+    impl Default for HasDefaultAndDuplicate {\n+        fn default() -> Self {\n+            HasDefaultAndDuplicate\n+        }\n+    }\n+\n+    enum Enum {\n+        A(),\n+    }\n+\n+    fn make<T, V>(_: V) -> T {\n+        unimplemented!();\n+    }\n+\n+    let with_enum = Some(Enum::A());\n+    with_enum.unwrap_or_else(Enum::A);\n+\n+    let with_new = Some(vec![1]);\n+    with_new.unwrap_or_else(Vec::new);\n+\n+    let with_err: Result<_, ()> = Ok(vec![1]);\n+    with_err.unwrap_or_else(make);\n+\n+    // should not be changed\n+    let with_fake_default = None::<Foo>;\n+    with_fake_default.unwrap_or_else(Foo::default);\n+\n+    // should not be changed\n+    let with_fake_default2 = None::<HasDefaultAndDuplicate>;\n+    with_fake_default2.unwrap_or_else(<HasDefaultAndDuplicate>::default);\n+\n+    let with_real_default = None::<HasDefaultAndDuplicate>;\n+    with_real_default.unwrap_or_default();\n+\n+    let with_default_trait = Some(1);\n+    with_default_trait.unwrap_or_default();\n+\n+    let with_default_type = Some(1);\n+    with_default_type.unwrap_or_default();\n+}\n+\n+fn main() {}"}, {"sha": "82b727a039ed44fd18d5738c24a5cc2e3ec30c73", "filename": "tests/ui/unwrap_or_else_default.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_or_else_default.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -0,0 +1,71 @@\n+// run-rustfix\n+\n+#![warn(clippy::unwrap_or_else_default)]\n+#![allow(dead_code)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+/// Checks implementation of the `UNWRAP_OR_ELSE_DEFAULT` lint.\n+fn unwrap_or_else_default() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo\n+        }\n+\n+        // fake default, we should not trigger on this\n+        fn default() -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    struct HasDefaultAndDuplicate;\n+\n+    impl HasDefaultAndDuplicate {\n+        fn default() -> Self {\n+            HasDefaultAndDuplicate\n+        }\n+    }\n+\n+    impl Default for HasDefaultAndDuplicate {\n+        fn default() -> Self {\n+            HasDefaultAndDuplicate\n+        }\n+    }\n+\n+    enum Enum {\n+        A(),\n+    }\n+\n+    fn make<T, V>(_: V) -> T {\n+        unimplemented!();\n+    }\n+\n+    let with_enum = Some(Enum::A());\n+    with_enum.unwrap_or_else(Enum::A);\n+\n+    let with_new = Some(vec![1]);\n+    with_new.unwrap_or_else(Vec::new);\n+\n+    let with_err: Result<_, ()> = Ok(vec![1]);\n+    with_err.unwrap_or_else(make);\n+\n+    // should not be changed\n+    let with_fake_default = None::<Foo>;\n+    with_fake_default.unwrap_or_else(Foo::default);\n+\n+    // should not be changed\n+    let with_fake_default2 = None::<HasDefaultAndDuplicate>;\n+    with_fake_default2.unwrap_or_else(<HasDefaultAndDuplicate>::default);\n+\n+    let with_real_default = None::<HasDefaultAndDuplicate>;\n+    with_real_default.unwrap_or_else(<HasDefaultAndDuplicate as Default>::default);\n+\n+    let with_default_trait = Some(1);\n+    with_default_trait.unwrap_or_else(Default::default);\n+\n+    let with_default_type = Some(1);\n+    with_default_type.unwrap_or_else(u64::default);\n+}\n+\n+fn main() {}"}, {"sha": "feb215b09f662ef4e05dc536a7f6b1b25020fb07", "filename": "tests/ui/unwrap_or_else_default.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Funwrap_or_else_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funwrap_or_else_default.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -0,0 +1,22 @@\n+error: use of `.unwrap_or_else(..)` to construct default value\n+  --> $DIR/unwrap_or_else_default.rs:62:5\n+   |\n+LL |     with_real_default.unwrap_or_else(<HasDefaultAndDuplicate as Default>::default);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `with_real_default.unwrap_or_default()`\n+   |\n+   = note: `-D clippy::unwrap-or-else-default` implied by `-D warnings`\n+\n+error: use of `.unwrap_or_else(..)` to construct default value\n+  --> $DIR/unwrap_or_else_default.rs:65:5\n+   |\n+LL |     with_default_trait.unwrap_or_else(Default::default);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `with_default_trait.unwrap_or_default()`\n+\n+error: use of `.unwrap_or_else(..)` to construct default value\n+  --> $DIR/unwrap_or_else_default.rs:68:5\n+   |\n+LL |     with_default_type.unwrap_or_else(u64::default);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `with_default_type.unwrap_or_default()`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "cdcdd808c94445f2d33b2771ded4f95db9091644", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -334,6 +334,38 @@ fn issue7249() {\n     x();\n }\n \n+fn issue7510() {\n+    let mut it = 0..10;\n+    let it = &mut it;\n+    // Needs to reborrow `it` as the binding isn't mutable\n+    for x in &mut *it {\n+        if x % 2 == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"{}\", it.next().unwrap());\n+\n+    struct S<T>(T);\n+    let mut it = 0..10;\n+    let it = S(&mut it);\n+    // Needs to reborrow `it.0` as the binding isn't mutable\n+    for x in &mut *it.0 {\n+        if x % 2 == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"{}\", it.0.next().unwrap());\n+}\n+\n+fn exact_match_with_single_field() {\n+    struct S<T>(T);\n+    let mut s = S(0..10);\n+    // Don't lint. `s.0` is used inside the loop.\n+    while let Some(_) = s.0.next() {\n+        let _ = &mut s.0;\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "72f34257d1f46a631cf7596876dded1da71beedd", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -334,6 +334,38 @@ fn issue7249() {\n     x();\n }\n \n+fn issue7510() {\n+    let mut it = 0..10;\n+    let it = &mut it;\n+    // Needs to reborrow `it` as the binding isn't mutable\n+    while let Some(x) = it.next() {\n+        if x % 2 == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"{}\", it.next().unwrap());\n+\n+    struct S<T>(T);\n+    let mut it = 0..10;\n+    let it = S(&mut it);\n+    // Needs to reborrow `it.0` as the binding isn't mutable\n+    while let Some(x) = it.0.next() {\n+        if x % 2 == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"{}\", it.0.next().unwrap());\n+}\n+\n+fn exact_match_with_single_field() {\n+    struct S<T>(T);\n+    let mut s = S(0..10);\n+    // Don't lint. `s.0` is used inside the loop.\n+    while let Some(_) = s.0.next() {\n+        let _ = &mut s.0;\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "ff9b08996da5316dc807b48e9d8175a1370aa05d", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/456e48f39eeebafdb901e9cb1cff1fd08e36cab7/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=456e48f39eeebafdb901e9cb1cff1fd08e36cab7", "patch": "@@ -111,10 +111,22 @@ LL |         while let Some(x) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:339:5\n+  --> $DIR/while_let_on_iterator.rs:341:5\n+   |\n+LL |     while let Some(x) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut *it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:352:5\n+   |\n+LL |     while let Some(x) = it.0.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut *it.0`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:371:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 21 previous errors\n "}]}