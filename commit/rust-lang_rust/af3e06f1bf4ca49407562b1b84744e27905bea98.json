{"sha": "af3e06f1bf4ca49407562b1b84744e27905bea98", "node_id": "C_kwDOAAsO6NoAKGFmM2UwNmYxYmY0Y2E0OTQwNzU2MmIxYjg0NzQ0ZTI3OTA1YmVhOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-23T19:46:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-23T19:46:36Z"}, "message": "Auto merge of #106087 - Nilstrieb:rollup-2m3nies, r=Nilstrieb\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #105661 (implement the skeleton of the updated trait solver)\n - #105853 (Make the pre-push script work on directories with spaces)\n - #106043 (Move tests)\n - #106048 (Run `tidy` in its own job in PR CI)\n - #106055 (Check arg expressions properly on error in `confirm_builtin_call`)\n - #106067 (A few metadata nits)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ce0b3fc316a14a85207d47154204f8d60d8e944a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0b3fc316a14a85207d47154204f8d60d8e944a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3e06f1bf4ca49407562b1b84744e27905bea98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3e06f1bf4ca49407562b1b84744e27905bea98", "html_url": "https://github.com/rust-lang/rust/commit/af3e06f1bf4ca49407562b1b84744e27905bea98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3e06f1bf4ca49407562b1b84744e27905bea98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ff8ad035deebde575235db310eb27afb3af7a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ff8ad035deebde575235db310eb27afb3af7a8", "html_url": "https://github.com/rust-lang/rust/commit/c2ff8ad035deebde575235db310eb27afb3af7a8"}, {"sha": "659c218b3aadf1ea42de0e208c2d934763d8935d", "url": "https://api.github.com/repos/rust-lang/rust/commits/659c218b3aadf1ea42de0e208c2d934763d8935d", "html_url": "https://github.com/rust-lang/rust/commit/659c218b3aadf1ea42de0e208c2d934763d8935d"}], "stats": {"total": 1850, "additions": 1706, "deletions": 144}, "files": [{"sha": "23d3e71424b2b41b8490407f4f5d531de13eba64", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -41,16 +41,24 @@ jobs:\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n+    continue-on-error: \"${{ matrix.tidy }}\"\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n+            tidy: false\n+            os: ubuntu-20.04-xl\n+            env: {}\n+          - name: mingw-check-tidy\n+            tidy: true\n             os: ubuntu-20.04-xl\n             env: {}\n           - name: x86_64-gnu-llvm-13\n+            tidy: false\n             os: ubuntu-20.04-xl\n             env: {}\n           - name: x86_64-gnu-tools\n+            tidy: false\n             env:\n               CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n             os: ubuntu-20.04-xl"}, {"sha": "af14ee08a9981bd187a89ee1bdb1365a053a7aaa", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -399,6 +399,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n+                for arg in arg_exprs {\n+                    self.check_expr(arg);\n+                }\n+\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = &callee_expr.kind\n                     && let [segment] = path.segments\n                     && let Some(mut diag) = self\n@@ -486,7 +490,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         if let [callee_expr, rest @ ..] = arg_exprs {\n-            let callee_ty = self.check_expr(callee_expr);\n+            let callee_ty = self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr)?;\n+\n             // First, do a probe with `IsSuggestion(true)` to avoid emitting\n             // any strange errors. If it's successful, then we'll do a true\n             // method lookup."}, {"sha": "a722613e3310efacb04b8636609c2dff4772e5c7", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -151,7 +151,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// FIXME: This method should only be used for canonical queries and therefore be private.\n+    ///\n+    /// As the new solver does canonicalization slightly differently, this is also used there\n+    /// for now. This should hopefully change fairly soon.\n+    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow_mut()\n             .opaque_type_storage"}, {"sha": "dda5f4bac4289310140abef18ff316f57bf44132", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -1011,11 +1011,7 @@ impl CrateError {\n                 sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                sess.emit_err(StableCrateIdCollision {\n-                    span,\n-                    crate_name0: crate_name0,\n-                    crate_name1: crate_name1,\n-                });\n+                sess.emit_err(StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n                 sess.emit_err(DlError { span, err: s });\n@@ -1074,7 +1070,7 @@ impl CrateError {\n                     }\n                     sess.emit_err(NoCrateWithTriple {\n                         span,\n-                        crate_name: crate_name,\n+                        crate_name,\n                         locator_triple: locator.triple.triple(),\n                         add_info,\n                         found_crates,"}, {"sha": "99d8225a4c391381075f18b736bdb816771ffebe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -78,10 +78,6 @@ pub(crate) struct CrateMetadata {\n     blob: MetadataBlob,\n \n     // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `LazyValue`, `LazyArray`, or `LazyTable`, and therefore acts like a\n-    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    /// is being used to decode those values.\n     root: CrateRoot,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n@@ -688,10 +684,10 @@ impl MetadataBlob {\n     pub(crate) fn get_root(&self) -> CrateRoot {\n         let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n-        let pos = (((slice[offset + 0] as u32) << 24)\n-            | ((slice[offset + 1] as u32) << 16)\n-            | ((slice[offset + 2] as u32) << 8)\n-            | ((slice[offset + 3] as u32) << 0)) as usize;\n+\n+        let pos_bytes = slice[offset..][..4].try_into().unwrap();\n+        let pos = u32::from_be_bytes(pos_bytes) as usize;\n+\n         LazyValue::<CrateRoot>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n     }\n \n@@ -702,16 +698,14 @@ impl MetadataBlob {\n         writeln!(out, \"hash {} stable_crate_id {:?}\", root.hash, root.stable_crate_id)?;\n         writeln!(out, \"proc_macro {:?}\", root.proc_macro_data.is_some())?;\n         writeln!(out, \"=External Dependencies=\")?;\n+\n         for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+            let CrateDep { name, extra_filename, hash, host_hash, kind } = dep;\n+            let number = i + 1;\n+\n             writeln!(\n                 out,\n-                \"{} {}{} hash {} host_hash {:?} kind {:?}\",\n-                i + 1,\n-                dep.name,\n-                dep.extra_filename,\n-                dep.hash,\n-                dep.host_hash,\n-                dep.kind\n+                \"{number} {name}{extra_filename} hash {hash} host_hash {host_hash:?} kind {kind:?}\"\n             )?;\n         }\n         write!(out, \"\\n\")?;"}, {"sha": "26a41f633fffa460f861df4ef0f48de2513e21bc", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -416,11 +416,6 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n-#[derive(TyEncodable, TyDecodable)]\n-struct GeneratorData<'tcx> {\n-    layout: mir::GeneratorLayout<'tcx>,\n-}\n-\n // Tags used for encoding Spans:\n const TAG_VALID_SPAN_LOCAL: u8 = 0;\n const TAG_VALID_SPAN_FOREIGN: u8 = 1;"}, {"sha": "0b32f67a81e16bb3fcea96e999fdb1bf273b1f00", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -300,6 +300,16 @@ impl<'tcx, V> Canonical<'tcx, V> {\n         let Canonical { max_universe, variables, value } = self;\n         Canonical { max_universe, variables, value: map_op(value) }\n     }\n+\n+    /// Allows you to map the `value` of a canonical while keeping the same set of\n+    /// bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the name! See\n+    /// the comment of [Canonical::unchecked_map] for more details.\n+    pub fn unchecked_rebind<W>(self, value: W) -> Canonical<'tcx, W> {\n+        let Canonical { max_universe, variables, value: _ } = self;\n+        Canonical { max_universe, variables, value }\n+    }\n }\n \n pub type QueryOutlivesConstraint<'tcx> = ("}, {"sha": "6a149be3137ee69ecc0145939aa4e6701aded6ec", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -96,7 +96,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n \n-#[derive(Copy, Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable, PartialEq, Eq)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;"}, {"sha": "a4dd22801e69dc0d119ff34caf6b8a5a30df7107", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -180,6 +180,7 @@ impl Iterator for Ancestors<'_> {\n }\n \n /// Information about the most specialized definition of an associated item.\n+#[derive(Debug)]\n pub struct LeafDef {\n     /// The associated item described by this `LeafDef`.\n     pub item: ty::AssocItem,"}, {"sha": "f01d74539a12e1b9be8731abf0b56d9d7eb45cf5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -535,6 +535,17 @@ impl<'tcx> Predicate<'tcx> {\n         self\n     }\n \n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n+    pub fn is_coinductive(self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n+                tcx.trait_is_coinductive(data.def_id())\n+            }\n+            ty::PredicateKind::WellFormed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Whether this projection can be soundly normalized.\n     ///\n     /// Wf predicates must not be normalized, as normalization\n@@ -1018,6 +1029,24 @@ pub struct ProjectionPredicate<'tcx> {\n     pub term: Term<'tcx>,\n }\n \n+impl<'tcx> ProjectionPredicate<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.projection_ty.self_ty()\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ProjectionPredicate<'tcx> {\n+        Self { projection_ty: self.projection_ty.with_self_ty(tcx, self_ty), ..self }\n+    }\n+\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.projection_ty.trait_def_id(tcx)\n+    }\n+\n+    pub fn def_id(self) -> DefId {\n+        self.projection_ty.def_id\n+    }\n+}\n+\n pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n@@ -1054,18 +1083,6 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ProjectionPredicate<'tcx> {\n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        Self {\n-            projection_ty: tcx.mk_alias_ty(\n-                self.projection_ty.def_id,\n-                [self_ty.into()].into_iter().chain(self.projection_ty.substs.iter().skip(1)),\n-            ),\n-            ..self\n-        }\n-    }\n-}\n-\n pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }"}, {"sha": "f7e4c8215698eca6d36c3e52a9d2a79061b323ee", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -1169,7 +1169,7 @@ pub struct AliasTy<'tcx> {\n }\n \n impl<'tcx> AliasTy<'tcx> {\n-    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n@@ -1183,7 +1183,7 @@ impl<'tcx> AliasTy<'tcx> {\n     /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n     /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n     pub fn trait_ref_and_own_substs(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n         debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));\n@@ -1202,14 +1202,18 @@ impl<'tcx> AliasTy<'tcx> {\n     /// WARNING: This will drop the substs for generic associated types\n     /// consider calling [Self::trait_ref_and_own_substs] to get those\n     /// as well.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         tcx.mk_trait_ref(def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.substs.type_at(0)\n     }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n }\n \n #[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]"}, {"sha": "0c33e5bda1a55a2fe0d29047963b394b38d324ad", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -577,6 +577,10 @@ impl<T> EarlyBinder<T> {\n     pub fn rebind<U>(&self, value: U) -> EarlyBinder<U> {\n         EarlyBinder(value)\n     }\n+\n+    pub fn skip_binder(self) -> T {\n+        self.0\n+    }\n }\n \n impl<T> EarlyBinder<Option<T>> {"}, {"sha": "a30d1df4ede52bd3ffcdbf298b0f0d9f0d2e3d44", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -19,6 +19,7 @@\n #![feature(let_chains)]\n #![feature(if_let_guard)]\n #![feature(never_type)]\n+#![feature(result_option_inspect)]\n #![feature(type_alias_impl_trait)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n@@ -37,4 +38,5 @@ extern crate smallvec;\n pub mod autoderef;\n pub mod errors;\n pub mod infer;\n+pub mod solve;\n pub mod traits;"}, {"sha": "e9ddad11ff23e5707ad6297186d93846588e1e03", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,150 @@\n+//! Code shared by trait and projection goals for candidate assembly.\n+\n+use super::infcx_ext::InferCtxtExt;\n+use super::{\n+    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n+    EvalCtxt, Goal,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{\n+    canonical::{CanonicalVarValues, OriginalQueryValues},\n+    InferCtxt,\n+};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+use std::fmt::Debug;\n+\n+/// A candidate is a possible way to prove a goal.\n+///\n+/// It consists of both the `source`, which describes how that goal would be proven,\n+/// and the `result` when using the given `source`.\n+///\n+/// For the list of possible candidates, please look at the documentation of\n+/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n+#[derive(Debug, Clone)]\n+pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n+    pub(super) source: G::CandidateSource,\n+    pub(super) result: CanonicalResponse<'tcx>,\n+}\n+\n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n+    type CandidateSource: Debug + Copy;\n+\n+    fn self_ty(self) -> Ty<'tcx>;\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n+\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n+        impl_def_id: DefId,\n+    );\n+}\n+\n+/// An abstraction which correctly deals with the canonical results for candidates.\n+///\n+/// It also deduplicates the behavior between trait and projection predicates.\n+pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n+    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n+    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n+    candidates: Vec<Candidate<'tcx, G>>,\n+}\n+\n+impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n+    pub(super) fn assemble_and_evaluate_candidates(\n+        cx: &'a mut EvalCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx, G>,\n+    ) -> Vec<Candidate<'tcx, G>> {\n+        let (ref infcx, goal, var_values) =\n+            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+\n+        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+\n+        acx.assemble_impl_candidates(goal);\n+\n+        acx.candidates\n+    }\n+\n+    pub(super) fn try_insert_candidate(\n+        &mut self,\n+        source: G::CandidateSource,\n+        certainty: Certainty,\n+    ) {\n+        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+            Ok(result) => self.candidates.push(Candidate { source, result }),\n+            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        }\n+    }\n+\n+    /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n+    ///\n+    /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n+    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n+    /// this case as projections as self types add `\n+    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n+        let tcx = self.cx.tcx;\n+        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n+        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+            return\n+        };\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n+            let normalizes_to_goal = goal.with(\n+                tcx,\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    term: normalized_ty.into(),\n+                }),\n+            );\n+            let normalization_certainty =\n+                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n+                    Ok((_, certainty)) => certainty,\n+                    Err(NoSolution) => return,\n+                };\n+\n+            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+            let mut orig_values = OriginalQueryValues::default();\n+            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let normalized_candidates =\n+                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n+\n+            // Map each candidate from being canonical wrt the current inference context to being\n+            // canonical wrt the caller.\n+            for Candidate { source, result } in normalized_candidates {\n+                self.infcx.probe(|_| {\n+                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n+                        &self.infcx,\n+                        &orig_values,\n+                        result,\n+                    );\n+\n+                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n+                    //\n+                    // If we have an ambiguous candidate it hides that normalization\n+                    // caused an overflow which may cause issues.\n+                    self.try_insert_candidate(\n+                        source,\n+                        normalization_certainty.unify_and(candidate_certainty),\n+                    )\n+                })\n+            }\n+        })\n+    }\n+\n+    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n+        self.cx.tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(self.cx.tcx),\n+            goal.predicate.self_ty(),\n+            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+        );\n+    }\n+}"}, {"sha": "993b79890669c206a8da81d42f7c0b31091a3aab", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,257 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::CanonicalGoal;\n+use super::{EvalCtxt, QueryResult};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TyCtxt;\n+use std::{cmp::Ordering, collections::hash_map::Entry};\n+\n+#[derive(Debug, Clone)]\n+struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    response: QueryResult<'tcx>,\n+    // The lowest element on the stack on which this result\n+    // relies on. Starts out as just being the depth at which\n+    // we've proven this obligation, but gets lowered to the\n+    // depth of another goal if we rely on it in a cycle.\n+    depth: usize,\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+/// The cache used for goals which are currently in progress or which depend\n+/// on in progress results.\n+///\n+/// Once we're done with a goal we can store it in the global trait solver\n+/// cache of the `TyCtxt`. For goals which we're currently proving, or which\n+/// have only been proven via a coinductive cycle using a goal still on our stack\n+/// we have to use this separate data structure.\n+///\n+/// The current data structure is not perfect, so there may still be room for\n+/// improvement here. We have the following requirements:\n+///\n+/// ## Is there is a provisional entry for the given goal:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// self.entries.get(goal)\n+/// ```\n+///\n+/// ## Get all goals on the stack involved in a cycle:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let entry = self.entries.get(goal).unwrap();\n+/// let involved_goals = self.stack.iter().skip(entry.depth);\n+/// ```\n+///\n+/// ## Capping the depth of all entries\n+///\n+/// Needed whenever we encounter a cycle. The current implementation always\n+/// iterates over all entries instead of only the ones with a larger depth.\n+/// Changing this may result in notable performance improvements.\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let cycle_depth = self.entries.get(goal).unwrap().depth;\n+/// for e in &mut self.entries {\n+///     e.depth = e.depth.min(cycle_depth);\n+/// }\n+/// ```\n+///\n+/// ## Checking whether we have to rerun the current goal\n+///\n+/// A goal has to be rerun if its provisional result was used in a cycle\n+/// and that result is different from its final result. We update\n+/// [StackElem::has_been_used] for the deepest stack element involved in a cycle.\n+///\n+/// ## Moving all finished goals into the global cache\n+///\n+/// If `stack_elem.has_been_used` is true, iterate over all entries, moving the ones\n+/// with equal depth. If not, simply move this single entry.\n+pub(super) struct ProvisionalCache<'tcx> {\n+    stack: Vec<StackElem<'tcx>>,\n+    entries: FxHashMap<CanonicalGoal<'tcx>, ProvisionalEntry<'tcx>>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { stack: Vec::new(), entries: Default::default() }\n+    }\n+\n+    pub(super) fn current_depth(&self) -> usize {\n+        self.stack.len()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.entries.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(cache.stack.len()) {\n+                    return Err(self.deal_with_overflow());\n+                }\n+\n+                v.insert(ProvisionalEntry {\n+                    response: fixme_response_yes_no_constraints(),\n+                    depth: cache.stack.len(),\n+                });\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry) => {\n+                // FIXME: `ProvisionalEntry` should be `Copy`.\n+                let entry = entry.get().clone();\n+                cache.stack[entry.depth].has_been_used = true;\n+                for provisional_entry in cache.entries.values_mut() {\n+                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n+                }\n+\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself simply checking\n+                // the stack is enough.\n+                if cache.stack[entry.depth..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n+                {\n+                    Err(entry.response)\n+                } else {\n+                    Err(fixme_response_maybe_no_constraints())\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let cache = &mut self.provisional_cache;\n+        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let provisional_entry = cache.entries.get_mut(&goal).unwrap();\n+        // Check whether the current stack entry is the root of a cycle.\n+        //\n+        // If so, we either move all participants of that cycle to the global cache\n+        // or, in case the provisional response used in the cycle is not equal to the\n+        // final response, have to recompute the goal after updating the provisional\n+        // response to the final response of this iteration.\n+        if has_been_used {\n+            if provisional_entry.response == response {\n+                // We simply drop all entries according to an immutable condition, so\n+                // query instability is not a concern here.\n+                #[allow(rustc::potential_query_instability)]\n+                cache.entries.retain(|goal, entry| match entry.depth.cmp(&cache.stack.len()) {\n+                    Ordering::Less => true,\n+                    Ordering::Equal => {\n+                        Self::try_move_finished_goal_to_global_cache(\n+                            self.tcx,\n+                            &mut self.overflow_data,\n+                            &cache.stack,\n+                            // FIXME: these should be `Copy` :(\n+                            goal.clone(),\n+                            entry.response.clone(),\n+                        );\n+                        false\n+                    }\n+                    Ordering::Greater => bug!(\"entry with greater depth than the current leaf\"),\n+                });\n+\n+                true\n+            } else {\n+                provisional_entry.response = response;\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                false\n+            }\n+        } else {\n+            Self::try_move_finished_goal_to_global_cache(\n+                self.tcx,\n+                &mut self.overflow_data,\n+                &cache.stack,\n+                goal,\n+                response,\n+            );\n+            cache.entries.remove(&goal);\n+            true\n+        }\n+    }\n+\n+    fn try_move_finished_goal_to_global_cache(\n+        tcx: TyCtxt<'tcx>,\n+        overflow_data: &mut OverflowData,\n+        stack: &[StackElem<'tcx>],\n+        goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) {\n+        // We move goals to the global cache if we either did not hit an overflow or if it's\n+        // the root goal as that will now always hit the same overflow limit.\n+        //\n+        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+        // isn't impacted by the overflow as that goal still has unstable query dependencies\n+        // because it didn't go its full depth.\n+        //\n+        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+        if should_cache_globally {\n+            // FIXME: move the provisional entry to the global cache.\n+            let _ = (tcx, goal, response);\n+        }\n+    }\n+}\n+\n+fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}\n+\n+fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "80115d78d88d17aad9cbb4d77894a435c6be14d3", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,92 @@\n+use std::mem;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_infer::{\n+    infer::InferCtxt,\n+    traits::{query::NoSolution, FulfillmentError, PredicateObligation, TraitEngine},\n+};\n+use rustc_middle::ty;\n+\n+use super::{Certainty, EvalCtxt};\n+\n+/// A trait engine using the new trait solver.\n+///\n+/// This is mostly identical to how `evaluate_all` works inside of the\n+/// solver, except that the requirements are slightly different.\n+///\n+/// Unlike `evaluate_all` it is possible to add new obligations later on\n+/// and we also have to track diagnostics information by using `Obligation`\n+/// instead of `Goal`.\n+///\n+/// It is also likely that we want to use slightly different datastructures\n+/// here as this will have to deal with far more root goals than `evaluate_all`.\n+pub struct FulfillmentCtxt<'tcx> {\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> FulfillmentCtxt<'tcx> {\n+    pub fn new() -> FulfillmentCtxt<'tcx> {\n+        FulfillmentCtxt { obligations: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n+    fn register_predicate_obligation(\n+        &mut self,\n+        _infcx: &InferCtxt<'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        self.obligations.push(obligation);\n+    }\n+\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = self.select_where_possible(infcx);\n+        if !errors.is_empty() {\n+            return errors;\n+        }\n+\n+        if self.obligations.is_empty() {\n+            Vec::new()\n+        } else {\n+            unimplemented!(\"ambiguous obligations\")\n+        }\n+    }\n+\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = Vec::new();\n+        for i in 0.. {\n+            if !infcx.tcx.recursion_limit().value_within_limit(i) {\n+                unimplemented!(\"overflow\")\n+            }\n+\n+            let mut has_changed = false;\n+            for o in mem::take(&mut self.obligations) {\n+                let mut cx = EvalCtxt::new(infcx.tcx);\n+                let (changed, certainty) = match cx.evaluate_goal(infcx, o.clone().into()) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => unimplemented!(\"error\"),\n+                };\n+\n+                has_changed |= changed;\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => self.obligations.push(o),\n+                }\n+            }\n+\n+            if !has_changed {\n+                break;\n+            }\n+        }\n+\n+        errors\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.clone()\n+    }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        unimplemented!(\"Should be moved out of `TraitEngine`\")\n+    }\n+}"}, {"sha": "436f4eea6625bcdf45b7b3e66bec6cba9d4bee80", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,55 @@\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::Ty;\n+use rustc_span::DUMMY_SP;\n+\n+use crate::solve::ExternalConstraints;\n+\n+use super::{Certainty, QueryResult, Response};\n+\n+/// Methods used inside of the canonical queries of the solver.\n+pub(super) trait InferCtxtExt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx>;\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx> {\n+        self.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::MiscVariable,\n+            span: DUMMY_SP,\n+        })\n+    }\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self)?;\n+\n+        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n+    }\n+}\n+\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n+}"}, {"sha": "7f5e3208f4e7c0fd03dba54521b106c640ac214b", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,309 @@\n+//! The new trait solver, currently still WIP.\n+//!\n+//! As a user of the trait system, you can use `TyCtxt::evaluate_goal` to\n+//! interact with this solver.\n+//!\n+//! For a high-level overview of how this solver works, check out the relevant\n+//! section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section. If you read this before then ask me\n+//! about it on zulip.\n+\n+// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n+// preserves universes and creates a unique var (in the highest universe) for each\n+// appearance of a region.\n+\n+// FIXME: `CanonicalVarValues` should be interned and `Copy`.\n+\n+// FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n+\n+use std::mem;\n+\n+use rustc_infer::infer::canonical::OriginalQueryValues;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n+use rustc_span::DUMMY_SP;\n+\n+use self::infcx_ext::InferCtxtExt;\n+\n+mod assembly;\n+mod cache;\n+mod fulfill;\n+mod infcx_ext;\n+mod overflow;\n+mod project_goals;\n+mod trait_goals;\n+\n+pub use fulfill::FulfillmentCtxt;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n+    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n+        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct ExternalConstraints<'tcx> {\n+    // FIXME: implement this.\n+    regions: (),\n+    opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+}\n+\n+type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n+pub trait TyCtxtExt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        let mut cx = EvalCtxt::new(self);\n+        cx.evaluate_canonical_goal(goal)\n+    }\n+}\n+\n+struct EvalCtxt<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    provisional_cache: cache::ProvisionalCache<'tcx>,\n+    overflow_data: overflow::OverflowData,\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n+        EvalCtxt {\n+            tcx,\n+            provisional_cache: cache::ProvisionalCache::empty(),\n+            overflow_data: overflow::OverflowData::new(tcx),\n+        }\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n+        Ok((\n+            true, // FIXME: check whether `var_values` are an identity substitution.\n+            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+        ))\n+    }\n+\n+    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        match self.try_push_stack(goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // We may have to repeatedly recompute the goal in case of coinductive cycles,\n+        // check out the `cache` module for more information.\n+        //\n+        // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n+        loop {\n+            let result = self.compute_goal(goal);\n+\n+            // FIXME: `Response` should be `Copy`\n+            if self.try_finalize_goal(goal, result.clone()) {\n+                return result;\n+            }\n+        }\n+    }\n+\n+    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        // WARNING: We're looking at a canonical value without instantiating it here.\n+        //\n+        // We have to be incredibly careful to not change the order of bound variables or\n+        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n+        // of `PredicateKind` this is the case and it is and faster than instantiating and\n+        // recanonicalizing.\n+        let Goal { param_env, predicate } = canonical_goal.value;\n+        if let Some(kind) = predicate.kind().no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n+                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                ),\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n+                    .compute_projection_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n+                    .compute_type_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n+                    .compute_region_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(_, _, _)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n+                | ty::PredicateKind::ConstEvaluatable(_)\n+                | ty::PredicateKind::ConstEquate(_, _)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+            }\n+        } else {\n+            let (infcx, goal, var_values) =\n+                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n+            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n+            infcx.make_canonical_response(var_values, certainty)\n+        }\n+    }\n+\n+    fn compute_type_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+\n+    fn compute_region_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn evaluate_all(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let mut new_goals = Vec::new();\n+        self.repeat_while_none(|this| {\n+            let mut has_changed = Err(Certainty::Yes);\n+            for goal in goals.drain(..) {\n+                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => return Some(Err(NoSolution)),\n+                };\n+\n+                if changed {\n+                    has_changed = Ok(());\n+                }\n+\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => {\n+                        new_goals.push(goal);\n+                        has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                    }\n+                }\n+            }\n+\n+            match has_changed {\n+                Ok(()) => {\n+                    mem::swap(&mut new_goals, &mut goals);\n+                    None\n+                }\n+                Err(certainty) => Some(Ok(certainty)),\n+            }\n+        })\n+    }\n+}\n+\n+fn fixme_instantiate_canonical_query_response<'tcx>(\n+    _: &InferCtxt<'tcx>,\n+    _: &OriginalQueryValues<'tcx>,\n+    _: CanonicalResponse<'tcx>,\n+) -> Certainty {\n+    unimplemented!()\n+}"}, {"sha": "8d73a83aec96e119639b011ab134ff94176f964c", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,80 @@\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Limit;\n+\n+use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+\n+/// When detecting a solver overflow, we return ambiguity. Overflow can be\n+/// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n+///\n+/// This is in issue in case of exponential blowup, e.g. if each goal on the stack\n+/// has multiple nested (overflowing) candidates. To deal with this, we reduce the limit\n+/// used by the solver when hitting the default limit for the first time.\n+///\n+/// FIXME: Get tests where always using the `default_limit` results in a hang and refer\n+/// to them here. We can also improve the overflow strategy if necessary.\n+pub(super) struct OverflowData {\n+    default_limit: Limit,\n+    current_limit: Limit,\n+    /// When proving an **AND** we have to repeatedly iterate over the yet unproven goals.\n+    ///\n+    /// Because of this each iteration also increases the depth in addition to the stack\n+    /// depth.\n+    additional_depth: usize,\n+}\n+\n+impl OverflowData {\n+    pub(super) fn new(tcx: TyCtxt<'_>) -> OverflowData {\n+        let default_limit = tcx.recursion_limit();\n+        OverflowData { default_limit, current_limit: default_limit, additional_depth: 0 }\n+    }\n+\n+    #[inline]\n+    pub(super) fn did_overflow(&self) -> bool {\n+        self.default_limit.0 != self.current_limit.0\n+    }\n+\n+    #[inline]\n+    pub(super) fn has_overflow(&self, depth: usize) -> bool {\n+        self.current_limit.value_within_limit(depth + self.additional_depth)\n+    }\n+\n+    /// Updating the current limit when hitting overflow.\n+    fn deal_with_overflow(&mut self) {\n+        // When first hitting overflow we reduce the overflow limit\n+        // for all future goals to prevent hangs if there's an exponental\n+        // blowup.\n+        self.current_limit.0 = self.default_limit.0 / 8;\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+        self.overflow_data.deal_with_overflow();\n+        fixme_response_overflow_no_constraints()\n+    }\n+\n+    /// A `while`-loop which tracks overflow.\n+    pub(super) fn repeat_while_none(\n+        &mut self,\n+        mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let start_depth = self.overflow_data.additional_depth;\n+        let depth = self.provisional_cache.current_depth();\n+        while !self.overflow_data.has_overflow(depth) {\n+            if let Some(result) = loop_body(self) {\n+                self.overflow_data.additional_depth = start_depth;\n+                return result;\n+            }\n+\n+            self.overflow_data.additional_depth += 1;\n+        }\n+        self.overflow_data.additional_depth = start_depth;\n+        self.overflow_data.deal_with_overflow();\n+        Ok(Certainty::Maybe(MaybeCause::Overflow))\n+    }\n+}\n+\n+fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "b50f42c4d9416091243668ff3ddb0e3bc87da922", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,244 @@\n+use crate::traits::{specialization_graph, translate_substs};\n+\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::specialization_graph::LeafDef;\n+use rustc_infer::traits::{ObligationCause, Reveal};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::ProjectionPredicate;\n+use rustc_middle::ty::TypeVisitable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    Impl(DefId),\n+    ParamEnv(usize),\n+    Builtin,\n+}\n+\n+type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_projection_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        self.merge_project_candidates(candidates)\n+    }\n+\n+    fn merge_project_candidates(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(candidates.pop().unwrap().result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.project_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(candidates.pop().unwrap().result)\n+    }\n+\n+    fn project_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::Builtin, _) => unimplemented!(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n+\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n+    }\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n+    }\n+\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.trait_def_id(tcx)\n+    }\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let tcx = acx.cx.tcx;\n+        let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n+        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal_trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+\n+            let Some(assoc_def) = fetch_eligible_assoc_item_def(\n+                acx.infcx,\n+                goal.param_env,\n+                goal_trait_ref,\n+                goal.predicate.def_id(),\n+                impl_def_id\n+            ) else {\n+                return\n+            };\n+\n+            if !assoc_def.item.defaultness(tcx).has_value() {\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(assoc_def.item.def_id),\n+                    \"missing value for assoc item in impl\",\n+                );\n+            }\n+\n+            // Getting the right substitutions here is complex, e.g. given:\n+            // - a goal `<Vec<u32> as Trait<i32>>::Assoc<u64>`\n+            // - the applicable impl `impl<T> Trait<i32> for Vec<T>`\n+            // - and the impl which defines `Assoc` being `impl<T, U> Trait<U> for Vec<T>`\n+            //\n+            // We first rebase the goal substs onto the impl, going from `[Vec<u32>, i32, u64]`\n+            // to `[u32, u64]`.\n+            //\n+            // And then map these substs to the substs of the defining impl of `Assoc`, going\n+            // from `[u32, u64]` to `[u32, i32, u64]`.\n+            let impl_substs_with_gat = goal.predicate.projection_ty.substs.rebase_onto(\n+                tcx,\n+                goal_trait_ref.def_id,\n+                impl_trait_ref.substs,\n+            );\n+            let substs = translate_substs(\n+                acx.infcx,\n+                goal.param_env,\n+                impl_def_id,\n+                impl_substs_with_gat,\n+                assoc_def.defining_node,\n+            );\n+\n+            // Finally we construct the actual value of the associated type.\n+            let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n+            let ty = tcx.bound_type_of(assoc_def.item.def_id);\n+            let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n+                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n+                let kind =\n+                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n+                ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n+            } else {\n+                ty.map_bound(|ty| ty.into())\n+            };\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.term,  term.subst(tcx, substs))\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+\n+            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+}\n+\n+/// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n+///\n+/// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n+/// diverge.\n+#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+fn fetch_eligible_assoc_item_def<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    goal_trait_ref: ty::TraitRef<'tcx>,\n+    trait_assoc_def_id: DefId,\n+    impl_def_id: DefId,\n+) -> Option<LeafDef> {\n+    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+        .map_err(|ErrorGuaranteed { .. }| ())\n+        .ok()?;\n+\n+    let eligible = if node_item.is_final() {\n+        // Non-specializable items are always projectable.\n+        true\n+    } else {\n+        // Only reveal a specializable default if we're past type-checking\n+        // and the obligation is monomorphic, otherwise passes such as\n+        // transmute checking and polymorphic MIR optimizations could\n+        // get a result which isn't correct for all monomorphizations.\n+        if param_env.reveal() == Reveal::All {\n+            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            !poly_trait_ref.still_further_specializable()\n+        } else {\n+            debug!(?node_item.item.def_id, \"not eligible due to default\");\n+            false\n+        }\n+    };\n+\n+    if eligible { Some(node_item) } else { None }\n+}"}, {"sha": "10b45a77dabb0976f04eb22a1c14b58d04918ba4", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,180 @@\n+//! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n+\n+use std::iter;\n+\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::TraitPredicate;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// Some user-defined impl with the given `DefId`.\n+    Impl(DefId),\n+    /// The n-th caller bound in the `param_env` of our goal.\n+    ///\n+    /// This is pretty much always a bound from the `where`-clauses of the\n+    /// currently checked item.\n+    ParamEnv(usize),\n+    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (for syntax highlighting)\n+    /// trait Trait {\n+    ///     type Assoc: OtherTrait;\n+    /// }\n+    /// ```\n+    ///\n+    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n+    /// the bounds on `Trait::Assoc`.\n+    AliasBound(usize),\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n+    Builtin,\n+    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n+    /// at the constituent types of the `self_ty` to check whether the auto trait\n+    /// is implemented for those.\n+    AutoImpl,\n+}\n+\n+type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n+\n+impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n+\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n+    }\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n+    }\n+\n+    fn trait_def_id(self, _: TyCtxt<'tcx>) -> DefId {\n+        self.def_id()\n+    }\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let impl_trait_ref = acx.cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(acx.cx.tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+\n+            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_trait_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        self.merge_trait_candidates_discard_reservation_impls(candidates)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound(_), _)\n+            | (CandidateSource::Builtin, _)\n+            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // FIXME: reduce candidate to ambiguous\n+                // FIXME: replace `var_values` with identity, yeet external constraints.\n+                unimplemented!()\n+            }\n+        }\n+\n+        candidate\n+    }\n+}"}, {"sha": "5276da2e49c750743c4b9d26a2909eb843926de8", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -25,7 +25,6 @@ use rustc_data_structures::sso::SsoHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n@@ -1553,7 +1552,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.def_id)\n+                    specialization_graph::assoc_def(selcx.tcx(), impl_data.impl_def_id, obligation.predicate.def_id)\n                         .map_err(|ErrorGuaranteed { .. }| ())?;\n \n                 if node_item.is_final() {\n@@ -2113,7 +2112,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let Ok(assoc_ty) = assoc_def(selcx, impl_def_id, assoc_item_id) else {\n+    let Ok(assoc_ty) = specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations: nested };\n     };\n \n@@ -2210,7 +2209,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let mut obligations = data.nested;\n \n     let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-    let Ok(leaf_def) = assoc_def(selcx, data.impl_def_id, trait_fn_def_id) else {\n+    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations };\n     };\n     if !leaf_def.item.defaultness(tcx).has_value() {\n@@ -2347,58 +2346,6 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n     }\n }\n \n-/// Locate the definition of an associated type in the specialization hierarchy,\n-/// starting from the given impl.\n-///\n-/// Based on the \"projection mode\", this lookup may in fact only examine the\n-/// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_def(\n-    selcx: &SelectionContext<'_, '_>,\n-    impl_def_id: DefId,\n-    assoc_def_id: DefId,\n-) -> Result<specialization_graph::LeafDef, ErrorGuaranteed> {\n-    let tcx = selcx.tcx();\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraitDef::ancestors()),\n-    // so, in order to avoid unnecessary infinite recursion, we manually look\n-    // for the associated item at the given impl.\n-    // If there is no such item in that impl, this function will fail with a\n-    // cycle error if the specialization graph is currently being built.\n-    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n-        let item = tcx.associated_item(impl_item_id);\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        return Ok(specialization_graph::LeafDef {\n-            item: *item,\n-            defining_node: impl_node,\n-            finalizing_node: if item.defaultness(tcx).is_default() {\n-                None\n-            } else {\n-                Some(impl_node)\n-            },\n-        });\n-    }\n-\n-    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n-        Ok(assoc_item)\n-    } else {\n-        // This is saying that neither the trait nor\n-        // the impl contain a definition for this\n-        // associated type.  Normally this situation\n-        // could only arise through a compiler bug --\n-        // if the user wrote a bad item name, it\n-        // should have failed in astconv.\n-        bug!(\n-            \"No associated type `{}` for {}\",\n-            tcx.item_name(assoc_def_id),\n-            tcx.def_path_str(impl_def_id)\n-        )\n-    }\n-}\n-\n pub(crate) trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,"}, {"sha": "81e8f9e914c2373ceae19be1daf898dc54e1a2d8", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -1171,19 +1171,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: Iterator<Item = ty::Predicate<'tcx>>,\n     {\n-        cycle.all(|predicate| self.coinductive_predicate(predicate))\n-    }\n-\n-    fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n-                self.tcx().trait_is_coinductive(data.def_id())\n-            }\n-            ty::PredicateKind::WellFormed(_) => true,\n-            _ => false,\n-        };\n-        debug!(?predicate, ?result, \"coinductive_predicate\");\n-        result\n+        cycle.all(|predicate| predicate.is_coinductive(self.tcx()))\n     }\n \n     /// Further evaluates `candidate` to decide whether all type parameters match and whether nested"}, {"sha": "02b0667774028a37224a926b1d74bb9a92f52b6f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -1,6 +1,7 @@\n use super::OverlapError;\n \n use crate::traits;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n@@ -379,3 +380,51 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n }\n+\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+pub(crate) fn assoc_def(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: DefId,\n+    assoc_def_id: DefId,\n+) -> Result<LeafDef, ErrorGuaranteed> {\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraitDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n+        let &item = tcx.associated_item(impl_item_id);\n+        let impl_node = Node::Impl(impl_def_id);\n+        return Ok(LeafDef {\n+            item,\n+            defining_node: impl_node,\n+            finalizing_node: if item.defaultness(tcx).is_default() {\n+                None\n+            } else {\n+                Some(impl_node)\n+            },\n+        });\n+    }\n+\n+    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n+        Ok(assoc_item)\n+    } else {\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\n+            \"No associated type `{}` for {}\",\n+            tcx.item_name(assoc_def_id),\n+            tcx.def_path_str(impl_def_id)\n+        )\n+    }\n+}"}, {"sha": "78fee152eb9d4c198b33fecf3cbb0353f01af2b9", "filename": "src/ci/docker/host-x86_64/mingw-check-tidy/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:18.04\n+# FIXME: when bumping the version, remove the Python 3.6-specific changes in\n+# the reuse-requirements.in file, regenerate reuse-requirements.txt and remove\n+# this comment.\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  ninja-build \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python3 \\\n+  python3-pip \\\n+  python3-pkg-resources \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config \\\n+  mingw-w64 \\\n+  && rm -rf /var/lib/apt/lists/*\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+COPY host-x86_64/mingw-check/reuse-requirements.txt /tmp/\n+RUN pip3 install --no-deps --no-cache-dir --require-hashes -r /tmp/reuse-requirements.txt\n+\n+COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n+COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n+\n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n+ENV SCRIPT python3 ../x.py test --stage 0 src/tools/tidy"}, {"sha": "adf6bb4b37752431eee9885f32ac49bd9ea299a2", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -40,7 +40,6 @@ COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n-           python3 ../x.py test --stage 0 src/tools/tidy && \\\n            python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu --all-targets && \\\n            python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n            python3 ../x.py test --stage 0 src/tools/compiletest && \\"}, {"sha": "d33396dcc80fe42a03bf369027999a507b5e0db7", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -287,19 +287,27 @@ jobs:\n     env:\n       <<: [*shared-ci-variables, *public-variables]\n     if: github.event_name == 'pull_request'\n+    continue-on-error: ${{ matrix.tidy }}\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n             <<: *job-linux-xl\n+            tidy: false\n+\n+          - name: mingw-check-tidy\n+            <<: *job-linux-xl\n+            tidy: true\n \n           - name: x86_64-gnu-llvm-13\n             <<: *job-linux-xl\n+            tidy: false\n \n           - name: x86_64-gnu-tools\n+            <<: *job-linux-xl\n+            tidy: false\n             env:\n               CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n-            <<: *job-linux-xl\n \n   auto:\n     permissions:"}, {"sha": "2a3086338b4bfe0591961272c2ac9582213ae574", "filename": "src/etc/pre-push.sh", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fetc%2Fpre-push.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Fetc%2Fpre-push.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpre-push.sh?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -10,16 +10,8 @@ set -Eeuo pipefail\n # https://github.com/rust-lang/rust/issues/77620#issuecomment-705144570\n unset GIT_DIR\n ROOT_DIR=\"$(git rev-parse --show-toplevel)\"\n-COMMAND=\"$ROOT_DIR/x.py test tidy\"\n \n-if [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n-  COMMAND=\"python $COMMAND\"\n-elif ! command -v python &> /dev/null; then\n-  COMMAND=\"python3 $COMMAND\"\n-fi\n-\n-echo \"Running pre-push script '$COMMAND'\"\n+echo \"Running pre-push script $ROOT_DIR/x test tidy\"\n \n cd \"$ROOT_DIR\"\n-\n-$COMMAND\n+./x test tidy"}, {"sha": "7c626a01b1298dfdb64655d763eb2d31ba2721a4", "filename": "src/test/ui/fn/issue-3044.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-3044.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-3044.rs"}, {"sha": "1232b83c39171af52a5702476cc7823ef1e50816", "filename": "src/test/ui/fn/issue-3044.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-3044.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-3044.stderr"}, {"sha": "7beb91a28d270ee56d0c1b5bf00937ecbfdf9bc2", "filename": "src/test/ui/fn/issue-3904.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ffn%2Fissue-3904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-3904.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-3904.rs"}, {"sha": "8c6192a59dba28d79dfe644f07ce9c8ae27ab7a6", "filename": "src/test/ui/issues/issue-6470.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/src%2Ftest%2Fui%2Fissues%2Fissue-6470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/src%2Ftest%2Fui%2Fissues%2Fissue-6470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6470.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -1,17 +0,0 @@\n-// build-pass\n-#![allow(dead_code)]\n-#![allow(improper_ctypes)]\n-// pretty-expanded FIXME #23616\n-#![allow(non_snake_case)]\n-\n-pub mod Bar {\n-    pub struct Foo {\n-        v: isize,\n-    }\n-\n-    extern \"C\" {\n-        pub fn foo(v: *const Foo) -> Foo;\n-    }\n-}\n-\n-pub fn main() {}"}, {"sha": "7db56f1dce86cc13d9cfb9ad6b823906d9ccde65", "filename": "src/test/ui/late-bound-lifetimes/issue-36381.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-36381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-36381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flate-bound-lifetimes%2Fissue-36381.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-36381.rs"}, {"sha": "ea042a6c76bb474905870f161133726a778b1475", "filename": "src/test/ui/macros/issue-25385.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-25385.rs"}, {"sha": "39dbdd753a6ff4afe2ff3d49a9827e4d45a325b2", "filename": "src/test/ui/macros/issue-25385.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-25385.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-25385.stderr"}, {"sha": "72731cbb177db81ccf3bc64ba370d0f875de3ea4", "filename": "src/test/ui/match/issue-5530.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmatch%2Fissue-5530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fmatch%2Fissue-5530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-5530.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-5530.rs"}, {"sha": "3608d4a2f14ef98377c39353430d6aad3052fdad", "filename": "src/test/ui/resolve/auxiliary/issue-30535.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fauxiliary%2Fissue-30535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fauxiliary%2Fissue-30535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fauxiliary%2Fissue-30535.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/auxiliary/issue-30535.rs"}, {"sha": "d48f00d5acacbee69195e92075e2b9adf39072ab", "filename": "src/test/ui/resolve/issue-30535.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-30535.rs"}, {"sha": "e3692934b62adafc2169692c18788cd63d303c65", "filename": "src/test/ui/resolve/issue-30535.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-30535.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-30535.stderr"}, {"sha": "07d3a82b1ed9da3b0ffb06384e3c689b84665cd2", "filename": "src/test/ui/resolve/issue-39559-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-39559-2.rs"}, {"sha": "ea27e7bd2508f9ecc26f7bf14dd65577c2dcd5ba", "filename": "src/test/ui/resolve/issue-39559-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-39559-2.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-39559-2.stderr"}, {"sha": "58d25940733ced12546d2842451ae8b274d4b708", "filename": "src/test/ui/resolve/issue-39559.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-39559.rs"}, {"sha": "7626f827fc5ebb161f7eb0ca563b00311754443d", "filename": "src/test/ui/resolve/issue-39559.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-39559.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-39559.stderr"}, {"sha": "f712a2eedb7e9cdb095ad83c20fb752ee11ba689", "filename": "src/test/ui/static/issue-18118-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-18118-2.rs"}, {"sha": "4fc3ca78f961c4e086df6ec297d38f5f22883c55", "filename": "src/test/ui/static/issue-18118-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fissue-18118-2.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-18118-2.stderr"}, {"sha": "f58a3de281f1ae1123e7ec98c7057e050f72c947", "filename": "src/test/ui/static/issue-18118.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-18118.rs"}, {"sha": "49798a148dee1d543114a7a164d56754a75ea0cf", "filename": "src/test/ui/static/issue-18118.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fissue-18118.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-18118.stderr"}, {"sha": "58ee3d6409a7e19ed0b1d7c5b83c64fa0b649cbc", "filename": "src/test/ui/suggestions/fn-to-method-deeply-nested.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,13 @@\n+fn main() -> Result<(), ()> {\n+    a(b(c(d(e(\n+        //~^ ERROR cannot find function `a` in this scope\n+        //~| ERROR cannot find function `b` in this scope\n+        //~| ERROR cannot find function `c` in this scope\n+        //~| ERROR cannot find function `d` in this scope\n+        //~| ERROR cannot find function `e` in this scope\n+        z????????????????????????????????????????????????????????????????????????????????????????\n+        ?????????????????????????????????????????????????????????????????????????????????????????\n+        ??????????????????????????????????????????????????????????????????\n+        //~^^^ ERROR cannot find value `z` in this scope\n+    )))))\n+}"}, {"sha": "ce813ea7abae8acc4349f60798855012ce7e0e90", "filename": "src/test/ui/suggestions/fn-to-method-deeply-nested.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method-deeply-nested.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,39 @@\n+error[E0425]: cannot find value `z` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:8:9\n+   |\n+LL |         z????????????????????????????????????????????????????????????????????????????????????????\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find function `e` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:2:13\n+   |\n+LL |     a(b(c(d(e(\n+   |             ^ not found in this scope\n+\n+error[E0425]: cannot find function `d` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:2:11\n+   |\n+LL |     a(b(c(d(e(\n+   |           ^ not found in this scope\n+\n+error[E0425]: cannot find function `c` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:2:9\n+   |\n+LL |     a(b(c(d(e(\n+   |         ^ not found in this scope\n+\n+error[E0425]: cannot find function `b` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:2:7\n+   |\n+LL |     a(b(c(d(e(\n+   |       ^ not found in this scope\n+\n+error[E0425]: cannot find function `a` in this scope\n+  --> $DIR/fn-to-method-deeply-nested.rs:2:5\n+   |\n+LL |     a(b(c(d(e(\n+   |     ^ not found in this scope\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "09f7a8c513125265c14315d858b93ee1c13a26e8", "filename": "src/test/ui/test-attrs/issue-52557.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-52557.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-52557.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-52557.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-52557.rs"}, {"sha": "a3bb76d7e3b732992c4aeaad87dfaabf665976c5", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,28 @@\n+// known-bug\n+\n+// This should compile but fails with the current solver.\n+//\n+// This checks that the new solver uses `Ambiguous` when hitting the\n+// inductive cycle here when proving `exists<^0, ^1> (): Trait<^0, ^1>`\n+// which requires proving `Trait<?1, ?0>` but that has the same\n+// canonical representation.\n+trait Trait<T, U> {}\n+\n+impl<T, U> Trait<T, U> for ()\n+where\n+    (): Trait<U, T>,\n+    T: OtherTrait,\n+{}\n+\n+trait OtherTrait {}\n+impl OtherTrait for u32 {}\n+\n+fn require_trait<T, U>()\n+where\n+    (): Trait<T, U>\n+{}\n+\n+fn main() {\n+    require_trait::<_, _>();\n+    //~^ ERROR overflow evaluating\n+}"}, {"sha": "e4b84e07822d28c784896071f43f19244aff4da6", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,26 @@\n+error[E0275]: overflow evaluating the requirement `_: Sized`\n+  --> $DIR/inductive-canonical-cycle.rs:26:5\n+   |\n+LL |     require_trait::<_, _>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`inductive_canonical_cycle`)\n+note: required for `()` to implement `Trait<_, _>`\n+  --> $DIR/inductive-canonical-cycle.rs:11:12\n+   |\n+LL | impl<T, U> Trait<T, U> for ()\n+   |            ^^^^^^^^^^^     ^^\n+   = note: 128 redundant requirements hidden\n+   = note: required for `()` to implement `Trait<_, _>`\n+note: required by a bound in `require_trait`\n+  --> $DIR/inductive-canonical-cycle.rs:22:9\n+   |\n+LL | fn require_trait<T, U>()\n+   |    ------------- required by a bound in this\n+LL | where\n+LL |     (): Trait<T, U>\n+   |         ^^^^^^^^^^^ required by this bound in `require_trait`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "af57dbe33177d61e6cf28f83610cdb75e2cbacc1", "filename": "src/test/ui/typeck/check-args-on-fn-err-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    a((), 1i32 == 2u32);\n+    //~^ ERROR cannot find function `a` in this scope\n+    //~| ERROR mismatched types\n+}"}, {"sha": "301bb88dbacf6e2928348a69752a0dc31b3e7814", "filename": "src/test/ui/typeck/check-args-on-fn-err-2.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err-2.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,23 @@\n+error[E0308]: mismatched types\n+  --> $DIR/check-args-on-fn-err-2.rs:2:19\n+   |\n+LL |     a((), 1i32 == 2u32);\n+   |           ----    ^^^^ expected `i32`, found `u32`\n+   |           |\n+   |           expected because this is `i32`\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     a((), 1i32 == 2i32);\n+   |                    ~~~\n+\n+error[E0425]: cannot find function `a` in this scope\n+  --> $DIR/check-args-on-fn-err-2.rs:2:5\n+   |\n+LL |     a((), 1i32 == 2u32);\n+   |     ^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "04b98ddd952956411bec7d857aeb08ccc7e3d9f7", "filename": "src/test/ui/typeck/check-args-on-fn-err.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    unknown(1, |glyf| {\n+        //~^ ERROR: cannot find function `unknown` in this scope\n+        let actual = glyf;\n+    });\n+}"}, {"sha": "864d33e0e93bbc07aae97362bc60926863a75016", "filename": "src/test/ui/typeck/check-args-on-fn-err.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fcheck-args-on-fn-err.stderr?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find function `unknown` in this scope\n+  --> $DIR/check-args-on-fn-err.rs:2:5\n+   |\n+LL |     unknown(1, |glyf| {\n+   |     ^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "21a1a4c83800a09d4571b7ad322ad49ce34762ed", "filename": "src/test/ui/typeck/issue-22375.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fissue-22375.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftest%2Fui%2Ftypeck%2Fissue-22375.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-22375.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "previous_filename": "src/test/ui/issues/issue-22375.rs"}, {"sha": "f746bdeffd7ca18b5c731506086a87d15645bc1a", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -10,7 +10,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 939;\n-const ISSUES_ENTRY_LIMIT: usize = 2040;\n+const ISSUES_ENTRY_LIMIT: usize = 2020;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     for dir in Walk::new(&path.join(\"test/ui\")) {"}, {"sha": "c7158a51861e5f396d270c48475cf2ee3eee7dad", "filename": "triagebot.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3e06f1bf4ca49407562b1b84744e27905bea98/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af3e06f1bf4ca49407562b1b84744e27905bea98/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=af3e06f1bf4ca49407562b1b84744e27905bea98", "patch": "@@ -342,6 +342,10 @@ cc = [\"@BoxyUwU\"]\n message = \"Some changes occured in `rustc_ty_utils::consts.rs`\"\n cc = [\"@BoxyUwU\"]\n \n+[mentions.\"compiler/rustc_trait_selection/src/solve]\n+message = \"Some changes occurred to the core trait solver\"\n+cc = [\"@lcnr\"]\n+\n [mentions.\"compiler/rustc_trait_selection/src/traits/engine.rs\"]\n message = \"\"\"\n Some changes occurred in engine.rs, potentially modifying the public API \\"}]}