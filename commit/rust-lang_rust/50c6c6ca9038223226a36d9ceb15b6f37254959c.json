{"sha": "50c6c6ca9038223226a36d9ceb15b6f37254959c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYzZjNmNhOTAzODIyMzIyNmEzNmQ5Y2ViMTViNmYzNzI1NDk1OWM=", "commit": {"author": {"name": "Steven Allen", "email": "steven@stebalien.com", "date": "2015-04-22T22:44:17Z"}, "committer": {"name": "Steven Allen", "email": "steven@stebalien.com", "date": "2015-04-22T23:19:54Z"}, "message": "Address comments.\n\n1. Use next_back for last.\n2. Use slices for computing nth. It might be possible to use the same\ncode for both the mut/const case but I don't know how that will play\nwith compiler optimizations.", "tree": {"sha": "bb066fd6090473b6d0f59a11cd518d97dd3b8cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb066fd6090473b6d0f59a11cd518d97dd3b8cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50c6c6ca9038223226a36d9ceb15b6f37254959c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50c6c6ca9038223226a36d9ceb15b6f37254959c", "html_url": "https://github.com/rust-lang/rust/commit/50c6c6ca9038223226a36d9ceb15b6f37254959c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50c6c6ca9038223226a36d9ceb15b6f37254959c/comments", "author": {"login": "Stebalien", "id": 310393, "node_id": "MDQ6VXNlcjMxMDM5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/310393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stebalien", "html_url": "https://github.com/Stebalien", "followers_url": "https://api.github.com/users/Stebalien/followers", "following_url": "https://api.github.com/users/Stebalien/following{/other_user}", "gists_url": "https://api.github.com/users/Stebalien/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stebalien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stebalien/subscriptions", "organizations_url": "https://api.github.com/users/Stebalien/orgs", "repos_url": "https://api.github.com/users/Stebalien/repos", "events_url": "https://api.github.com/users/Stebalien/events{/privacy}", "received_events_url": "https://api.github.com/users/Stebalien/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stebalien", "id": 310393, "node_id": "MDQ6VXNlcjMxMDM5Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/310393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stebalien", "html_url": "https://github.com/Stebalien", "followers_url": "https://api.github.com/users/Stebalien/followers", "following_url": "https://api.github.com/users/Stebalien/following{/other_user}", "gists_url": "https://api.github.com/users/Stebalien/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stebalien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stebalien/subscriptions", "organizations_url": "https://api.github.com/users/Stebalien/orgs", "repos_url": "https://api.github.com/users/Stebalien/repos", "events_url": "https://api.github.com/users/Stebalien/events{/privacy}", "received_events_url": "https://api.github.com/users/Stebalien/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de8c79a53532c4a6de61b0dcde6ed9b133afa752", "url": "https://api.github.com/repos/rust-lang/rust/commits/de8c79a53532c4a6de61b0dcde6ed9b133afa752", "html_url": "https://github.com/rust-lang/rust/commit/de8c79a53532c4a6de61b0dcde6ed9b133afa752"}], "stats": {"total": 88, "additions": 46, "deletions": 42}, "files": [{"sha": "7bed0ef6daa1f91cc9e15aa1b1bde7118b665f0d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/50c6c6ca9038223226a36d9ceb15b6f37254959c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c6c6ca9038223226a36d9ceb15b6f37254959c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=50c6c6ca9038223226a36d9ceb15b6f37254959c", "patch": "@@ -674,51 +674,13 @@ macro_rules! iterator {\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    // There should be some way to use offset and optimize this to LEA but I don't\n-                    // know how to do that AND detect overflow...\n-                    let size = mem::size_of::<T>();\n-                    if size == 0 {\n-                        if let Some(new_ptr) = (self.ptr as usize).checked_add(n) {\n-                            if new_ptr < (self.end as usize) {\n-                                self.ptr = transmute(new_ptr + 1);\n-                                return Some(&mut *(1 as *mut _))\n-                            }\n-                        }\n-                    } else {\n-                        if let Some(new_ptr) = n.checked_mul(size).and_then(|offset| {\n-                            (self.ptr as usize).checked_add(offset)\n-                        }) {\n-                            if new_ptr < (self.end as usize) {\n-                                self.ptr = transmute(new_ptr + size);\n-                                return Some(transmute(new_ptr))\n-                            }\n-                        }\n-                    }\n-                    None\n-                }\n+                // Call helper method. Can't put the definition here because mut versus const.\n+                self.iter_nth(n)\n             }\n \n             #[inline]\n-            fn last(self) -> Option<$elem> {\n-                // We could just call next_back but this avoids the memory write.\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            Some(transmute(self.end.offset(-1)))\n-                        }\n-                    }\n-                }\n+            fn last(mut self) -> Option<$elem> {\n+                self.next_back()\n             }\n         }\n \n@@ -839,6 +801,27 @@ impl<'a, T> Iter<'a, T> {\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for Iter::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n+        match self.as_slice().get(n) {\n+            Some(elem_ref) => if mem::size_of::<T>() == 0 {\n+                unsafe {\n+                    self.ptr = transmute((elem_ref as *const _) as usize + 1);\n+                    Some(& *(1 as *const _))\n+                }\n+            } else {\n+                unsafe {\n+                    self.ptr = (elem_ref as *const _).offset(1);\n+                    Some(elem_ref)\n+                }\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct Iter -> *const T, &'a T}\n@@ -968,6 +951,27 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for IterMut::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n+        match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n+            Some(elem_ref) => if mem::size_of::<T>() == 0 {\n+                unsafe {\n+                    self.ptr = transmute((elem_ref as *mut _) as usize + 1);\n+                    Some(&mut *(1 as *mut _))\n+                }\n+            } else {\n+                unsafe {\n+                    self.ptr = (elem_ref as *mut _).offset(1);\n+                    Some(elem_ref)\n+                }\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}"}]}