{"sha": "55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZWRlN2VkOGU0ZjM3NTJjMzcxZjdkMDRkYTQ2OTViYTlhYTFjMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T21:14:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T21:14:28Z"}, "message": "Auto merge of #27234 - oli-obk:move_get_name_get_ident_to_impl, r=eddyb\n\nthis has quite some fallout. but also made lots of stuff more readable imo\r\n\r\n[breaking-change] for plugin authors", "tree": {"sha": "cde06ced567bd6cc6ad6abb68fa37818158fec33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cde06ced567bd6cc6ad6abb68fa37818158fec33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "html_url": "https://github.com/rust-lang/rust/commit/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba9224f35451e5d5ef7647bd2b40e5da80ce2735", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba9224f35451e5d5ef7647bd2b40e5da80ce2735", "html_url": "https://github.com/rust-lang/rust/commit/ba9224f35451e5d5ef7647bd2b40e5da80ce2735"}, {"sha": "00a5e66f818ad9d79cc4425f5564c7b07e3213a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/00a5e66f818ad9d79cc4425f5564c7b07e3213a6", "html_url": "https://github.com/rust-lang/rust/commit/00a5e66f818ad9d79cc4425f5564c7b07e3213a6"}], "stats": {"total": 967, "additions": 433, "deletions": 534}, "files": [{"sha": "12adb9050d59c865ad37cc2cda67fecda0523fbf", "filename": "src/doc/trpl/compiler-plugins.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -61,7 +61,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         (\"I\",    1)];\n \n     let text = match args {\n-        [TtToken(_, token::Ident(s, _))] => token::get_ident(s).to_string(),\n+        [TtToken(_, token::Ident(s, _))] => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);\n@@ -186,8 +186,7 @@ impl LintPass for Pass {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let name = token::get_ident(it.ident);\n-        if name.get() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "a193ffcc731d607799ac722fe43d8579b60550d8", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -47,8 +47,7 @@ impl PathElem {\n \n impl fmt::Display for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let slot = token::get_name(self.name());\n-        write!(f, \"{}\", slot)\n+        write!(f, \"{}\", self.name())\n     }\n }\n \n@@ -1073,18 +1072,18 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             match ii.node {\n                 ConstImplItem(..) => {\n                     format!(\"assoc const {} in {}{}\",\n-                            token::get_ident(ii.ident),\n+                            ii.ident,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n                 MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n-                            token::get_ident(ii.ident),\n+                            ii.ident,\n                             map.path_to_string(id), id_str)\n                 }\n                 TypeImplItem(_) => {\n                     format!(\"assoc type {} in {}{}\",\n-                            token::get_ident(ii.ident),\n+                            ii.ident,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n@@ -1103,13 +1102,13 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\",\n                     kind,\n-                    token::get_ident(ti.ident),\n+                    ti.ident,\n                     map.path_to_string(id),\n                     id_str)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n-                    token::get_ident(variant.node.name),\n+                    variant.node.name,\n                     map.path_to_string(id), id_str)\n         }\n         Some(NodeExpr(ref expr)) => {"}, {"sha": "623682a9cd5de0d18db80296ad2b0c0402be54e6", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -33,7 +33,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::visit;\n use log;\n \n@@ -181,19 +180,18 @@ impl<'a> CrateReader<'a> {\n     fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n             ast::ItemExternCrate(ref path_opt) => {\n-                let ident = token::get_ident(i.ident);\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       ident, path_opt);\n+                       i.ident, path_opt);\n                 let name = match *path_opt {\n                     Some(name) => {\n-                        validate_crate_name(Some(self.sess), name.as_str(),\n+                        validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n-                        name.as_str().to_string()\n+                        name.to_string()\n                     }\n-                    None => ident.to_string(),\n+                    None => i.ident.to_string(),\n                 };\n                 Some(CrateInfo {\n-                    ident: ident.to_string(),\n+                    ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n                     should_link: should_link(i),"}, {"sha": "5167014d4aba53b1c9ce80d619aff59eb1656a9d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -40,7 +40,6 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n@@ -83,11 +82,11 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n }\n \n fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n-    rbml_w.wr_tagged_str(tag_paths_data_name, &token::get_name(name));\n+    rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n \n fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n-    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_name(name));\n+    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &name.as_str());\n }\n \n fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n@@ -349,7 +348,7 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };\n-        rbml_w.wr_tagged_str(tag, &token::get_name(pe.name()));\n+        rbml_w.wr_tagged_str(tag, &pe.name().as_str());\n     }\n     rbml_w.end_tag();\n }\n@@ -359,13 +358,13 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    method_def_id: DefId,\n                                    method_name: ast::Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n-            exp.name, token::get_name(method_name));\n+            exp.name, method_name);\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n                          def_to_u64(method_def_id));\n     rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                          &format!(\"{}::{}\", exp.name,\n-                                            token::get_name(method_name)));\n+                                            method_name));\n     rbml_w.end_tag();\n }\n \n@@ -499,15 +498,12 @@ fn encode_reexports(ecx: &EncodeContext,\n                 rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n                                      def_to_u64(exp.def_id));\n                 rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n-                                     exp.name.as_str());\n+                                     &exp.name.as_str());\n                 rbml_w.end_tag();\n                 encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n-        }\n-        None => {\n-            debug!(\"(encoding info for module) found no reexports for {}\",\n-                   id);\n-        }\n+        },\n+        None => debug!(\"(encoding info for module) found no reexports for {}\", id),\n     }\n }\n \n@@ -539,7 +535,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         if let ast::ItemImpl(..) = item.node {\n             let (ident, did) = (item.ident, item.id);\n             debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n-                   token::get_ident(ident),\n+                   ident,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(local_def(did)));\n@@ -656,7 +652,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         });\n         rbml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n-               token::get_name(nm), id);\n+               nm, id);\n         encode_struct_field_family(rbml_w, field.vis);\n         encode_name(rbml_w, nm);\n         encode_bounds_and_type_for_item(rbml_w, ecx, id);\n@@ -816,7 +812,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n                                     impl_item_opt: Option<&ast::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n-           token::get_name(associated_const.name));\n+           associated_const.name);\n \n     rbml_w.start_tag(tag_items_data_item);\n \n@@ -854,7 +850,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     impl_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n-           token::get_name(m.name));\n+           m.name);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, m);\n@@ -899,7 +895,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              impl_item_opt: Option<&ast::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n-           token::get_name(associated_type.name));\n+           associated_type.name);\n \n     rbml_w.start_tag(tag_items_data_item);\n \n@@ -937,7 +933,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n-            let name = token::get_name(path1.node.name);\n+            let name = path1.node.name.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {\n             rbml_w.wr_tagged_bytes(tag, &[]);\n@@ -1562,7 +1558,7 @@ fn my_visit_foreign_item(ni: &ast::ForeignItem,\n                          index: &mut Vec<entry<i64>>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n-            token::get_ident(ni.ident));\n+            ni.ident);\n \n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n@@ -1748,7 +1744,7 @@ fn encode_defaulted(rbml_w: &mut Encoder, is_defaulted: bool) {\n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n     for &name in names {\n-        rbml_w.wr_tagged_str(tag_associated_type_name, &token::get_name(name));\n+        rbml_w.wr_tagged_str(tag_associated_type_name, &name.as_str());\n     }\n     rbml_w.end_tag();\n }"}, {"sha": "08975bab60020adf8529de9a82684d22ab00759e", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -149,8 +149,7 @@ impl<'a> MacroLoader<'a> {\n         let mut seen = HashSet::new();\n \n         for mut def in macros {\n-            let name = token::get_ident(def.ident);\n-            seen.insert(name.clone());\n+            let name = def.ident.name.as_str();\n \n             def.use_locally = match import.as_ref() {\n                 None => true,\n@@ -161,18 +160,19 @@ impl<'a> MacroLoader<'a> {\n                                                               \"allow_internal_unstable\");\n             debug!(\"load_macros: loaded: {:?}\", def);\n             self.macros.push(def);\n+            seen.insert(name);\n         }\n \n         if let Some(sel) = import.as_ref() {\n             for (name, span) in sel {\n-                if !seen.contains(name) {\n+                if !seen.contains(&name) {\n                     self.sess.span_err(*span, \"imported macro not found\");\n                 }\n             }\n         }\n \n         for (name, span) in &reexport {\n-            if !seen.contains(name) {\n+            if !seen.contains(&name) {\n                 self.sess.span_err(*span, \"reexported macro not found\");\n             }\n         }"}, {"sha": "1831c3518d70926e844423524e2ef8a29f56b76c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -26,7 +26,6 @@ use util::nodemap::FnvHashMap;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n-use syntax::parse::token;\n \n use rbml::writer::Encoder;\n \n@@ -136,7 +135,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             cx.diag.handler().bug(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n-            mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), token::get_name(name))\n+            mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n         }\n         ty::TyStruct(def, substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n@@ -155,7 +154,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::TyProjection(ref data) => {\n             mywrite!(w, \"P[\");\n             enc_trait_ref(w, cx, data.trait_ref);\n-            mywrite!(w, \"{}]\", token::get_name(data.item_name));\n+            mywrite!(w, \"{}]\", data.item_name);\n         }\n         ty::TyError => {\n             mywrite!(w, \"e\");\n@@ -251,7 +250,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n                      data.param_id,\n                      data.space.to_uint(),\n                      data.index,\n-                     token::get_name(data.name));\n+                     data.name);\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[\");\n@@ -302,7 +301,7 @@ fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n         ty::BrNamed(d, name) => {\n             mywrite!(w, \"[{}|{}]\",\n                      (cx.ds)(d),\n-                     token::get_name(name));\n+                     name);\n         }\n         ty::BrFresh(id) => {\n             mywrite!(w, \"f{}|\", id);\n@@ -410,7 +409,7 @@ pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|{}|\",\n-             token::get_name(v.name), (cx.ds)(v.def_id),\n+             v.name, (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index, (cx.ds)(v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n@@ -465,6 +464,6 @@ fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n     enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-    mywrite!(w, \"{}|\", token::get_name(data.projection_ty.item_name));\n+    mywrite!(w, \"{}|\", data.projection_ty.item_name);\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "9889ea92215a4a279e329be23497755207f17c1d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -34,7 +34,6 @@ use middle::ty::{self, Ty};\n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax;\n \n@@ -156,10 +155,10 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             ast::IITraitItem(_, ref ti) => ti.ident,\n             ast::IIImplItem(_, ref ii) => ii.ident\n         };\n-        debug!(\"Fn named: {}\", token::get_ident(ident));\n+        debug!(\"Fn named: {}\", ident);\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n-               token::get_ident(ident));\n+               ident);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n         match *ii {"}, {"sha": "12dd12f746fd49f49e1504381eb14f97247dfce0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -35,7 +35,6 @@ use syntax::ast_util;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor, FnKind};\n use util::nodemap::FnvHashMap;\n@@ -239,17 +238,17 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n                         if cx.tcx.enum_variants(def_id).iter().any(|variant|\n-                            token::get_name(variant.name) == token::get_name(ident.node.name)\n+                            variant.name == ident.node.name\n                                 && variant.args.is_empty()\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                &token::get_ident(ident.node), pat_ty);\n+                                ident.node, pat_ty);\n                             fileline_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                pat_ty, &token::get_ident(ident.node));\n+                                pat_ty, ident.node);\n                         }\n                     }\n                 }"}, {"sha": "298126be2fd4bb3b961ff33163a1890de67cc383", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -1036,8 +1036,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if let Struct(struct_id) = c {\n                 if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n-                    if let Some(f) = fields.iter().find(|f| f.ident.node.as_str()\n-                                                         == field_name.node.as_str()) {\n+                    // if the idents are compared run-pass/issue-19244 fails\n+                    if let Some(f) = fields.iter().find(|f| f.ident.node.name\n+                                                         == field_name.node.name) {\n                         return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n                     } else {\n                         signal!(e, MissingStructField);"}, {"sha": "663746ac2dd3ce500e8102272bdacc103eea7511", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -194,9 +194,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            ty::ReEarlyBound(ref data) => {\n-                (format!(\"{}\", token::get_name(data.name)), None)\n-            }\n+            ty::ReEarlyBound(ref data) => (data.name.to_string(), None),\n \n             // I believe these cases should not occur (except when debugging,\n             // perhaps)\n@@ -1056,7 +1054,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             // choice of lifetime name deterministic and thus easier to test.\n             let mut names = Vec::new();\n             for rn in region_names {\n-                let lt_name = token::get_name(*rn).to_string();\n+                let lt_name = rn.to_string();\n                 names.push(lt_name);\n             }\n             names.sort();\n@@ -1544,15 +1542,15 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n                 format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), token::get_name(type_name))\n+                        br_string(br), type_name)\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n-                        &token::get_name(name))\n+                        name)\n             }\n             infer::BoundRegionInCoherence(name) => {\n                 format!(\" for lifetime parameter `{}` in coherence check\",\n-                        &token::get_name(name))\n+                        name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n@@ -1838,7 +1836,7 @@ impl LifeGiver {\n     fn with_taken(taken: &[ast::LifetimeDef]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken {\n-            let lt_name = token::get_name(lt.lifetime.name).to_string();\n+            let lt_name = lt.lifetime.name.to_string();\n             taken_.insert(lt_name);\n         }\n         LifeGiver {"}, {"sha": "93899a5cf80364b7ec4d2d5dd298fd586fc1aebb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -21,7 +21,6 @@ use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -61,16 +60,14 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         if def_id.krate == ast::LOCAL_CRATE {\n             match self.tcx.map.get(def_id.node) {\n                 NodeForeignItem(ref item) if intrinsic => {\n-                    token::get_ident(item.ident) ==\n-                        token::intern_and_get_ident(\"transmute\")\n+                    item.ident.name == \"transmute\"\n                 }\n                 _ => false,\n             }\n         } else {\n             match csearch::get_item_path(self.tcx, def_id).last() {\n                 Some(ref last) if intrinsic => {\n-                    token::get_name(last.name()) ==\n-                        token::intern_and_get_ident(\"transmute\")\n+                    last.name() == \"transmute\"\n                 }\n                 _ => false,\n             }"}, {"sha": "87b8e72f56f1100ed8cb0e81e2260c3a5c40b653", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -122,7 +122,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_string, block_to_string};\n use syntax::ptr::P;\n use syntax::ast_util;\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { name, .. }) | Arg(_, name) => {\n-                token::get_name(name).to_string()\n+                name.to_string()\n             },\n             ImplicitRet => \"<implicit-ret>\".to_string(),\n             CleanExit => \"<clean-exit>\".to_string()"}, {"sha": "90e24213818a7146280e3e0ad81f5245cfd2a403", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -28,7 +28,6 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n use syntax::print::pprust::lifetime_to_string;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -664,7 +663,7 @@ impl<'a> LifetimeContext<'a> {\n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n         span_err!(self.sess, lifetime_ref.span, E0261,\n             \"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name));\n+                    lifetime_ref.name);\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -676,7 +675,7 @@ impl<'a> LifetimeContext<'a> {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n                     span_err!(self.sess, lifetime.lifetime.span, E0262,\n                         \"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.lifetime.name));\n+                                lifetime.lifetime.name);\n                 }\n             }\n \n@@ -688,7 +687,7 @@ impl<'a> LifetimeContext<'a> {\n                     span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n                         \"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.lifetime.name));\n+                                lifetime_j.lifetime.name);\n                 }\n             }\n "}, {"sha": "7dcf63fcafb40548c8e0a95f1423fc27efb36c15", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.ident.as_str() == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.ident.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));"}, {"sha": "a3b6794174170c4ea9e48fddd9d88dae6d289f52", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -5331,19 +5331,13 @@ impl<'tcx> ctxt<'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    ast::PatIdent(_, ref path1, _) => {\n-                        token::get_ident(path1.node)\n-                    }\n+                    ast::PatIdent(_, ref path1, _) => path1.node.name.as_str(),\n                     _ => {\n-                        self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n-                                               id, pat));\n-                    }\n+                        self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, pat));\n+                    },\n                 }\n-            }\n-            r => {\n-                self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n-                                       id, r));\n-            }\n+            },\n+            r => self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, r)),\n         }\n     }\n \n@@ -5435,9 +5429,9 @@ impl<'tcx> ctxt<'tcx> {\n         for f in fields { if f.name == name { return i; } i += 1; }\n         self.sess.bug(&format!(\n             \"no field named `{}` found in the list of fields `{:?}`\",\n-            token::get_name(name),\n+            name,\n             fields.iter()\n-                  .map(|f| token::get_name(f.name).to_string())\n+                  .map(|f| f.name.to_string())\n                   .collect::<Vec<String>>()));\n     }\n \n@@ -5854,13 +5848,13 @@ impl<'tcx> ctxt<'tcx> {\n                                       \"expected {} integer constant\",\n                                       sign_desc);\n                             current_disr_val = attempt_fresh_value();\n-                        }\n+                        },\n                         Err(ref err) => {\n                             span_err!(self.sess, err.span, E0080,\n                                       \"constant evaluation error: {}\",\n                                       err.description());\n                             current_disr_val = attempt_fresh_value();\n-                        }\n+                        },\n                     }\n                 },\n                 None => {\n@@ -5869,14 +5863,14 @@ impl<'tcx> ctxt<'tcx> {\n                             if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n                                 v\n                             } else {\n-                                self.report_discrim_overflow(v.span, v.node.name.as_str(),\n+                                self.report_discrim_overflow(v.span, &v.node.name.name.as_str(),\n                                                              repr_type, prev_disr_val);\n                                 attempt_fresh_value()\n                             }\n                         }\n-                        None => ty::INITIAL_DISCRIMINANT_VALUE\n+                        None => ty::INITIAL_DISCRIMINANT_VALUE,\n                     }\n-                }\n+                },\n             }\n \n             let variant_info = Rc::new(VariantInfo::from_ast_variant(self, &**v, current_disr_val));\n@@ -6511,7 +6505,7 @@ impl<'tcx> ctxt<'tcx> {\n                         byte!(20);\n                         hash!(p.space);\n                         hash!(p.idx);\n-                        hash!(token::get_name(p.name));\n+                        hash!(p.name.as_str());\n                     }\n                     TyInfer(_) => unreachable!(),\n                     TyError => byte!(21),\n@@ -6522,7 +6516,7 @@ impl<'tcx> ctxt<'tcx> {\n                     TyProjection(ref data) => {\n                         byte!(23);\n                         did(state, data.trait_ref.def_id);\n-                        hash!(token::get_name(data.item_name));\n+                        hash!(data.item_name.as_str());\n                     }\n                 }\n                 true"}, {"sha": "db0a291efbd07dda19fd817335cd2541991990ab", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -265,20 +265,20 @@ mod svh_visitor {\n             ExprCast(..)             => SawExprCast,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(content)),\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n             ExprMatch(..)            => SawExprMatch,\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, id)         => SawExprField(content(id.node)),\n+            ExprField(_, id)         => SawExprField(id.node.name.as_str()),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprRange(..)            => SawExprRange,\n             ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(content)),\n-            ExprAgain(id)            => SawExprAgain(id.map(content)),\n+            ExprBreak(id)            => SawExprBreak(id.map(|id| id.name.as_str())),\n+            ExprAgain(id)            => SawExprAgain(id.map(|id| id.name.as_str())),\n             ExprRet(..)              => SawExprRet,\n             ExprInlineAsm(ref asm)   => SawExprInlineAsm(asm),\n             ExprStruct(..)           => SawExprStruct,\n@@ -310,16 +310,6 @@ mod svh_visitor {\n         }\n     }\n \n-    // Ad-hoc overloading between Ident and Name to their intern table lookups.\n-    trait InternKey { fn get_content(self) -> token::InternedString; }\n-    impl InternKey for Ident {\n-        fn get_content(self) -> token::InternedString { token::get_ident(self) }\n-    }\n-    impl InternKey for Name {\n-        fn get_content(self) -> token::InternedString { token::get_name(self) }\n-    }\n-    fn content<K:InternKey>(k: K) -> token::InternedString { k.get_content() }\n-\n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n \n         fn visit_mac(&mut self, mac: &Mac) {\n@@ -355,15 +345,15 @@ mod svh_visitor {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n                         let s = &path.segments;\n                         assert_eq!(s.len(), 1);\n-                        content(s[0].identifier)\n+                        s[0].identifier.name.as_str()\n                     }\n                 }\n             }\n         }\n \n         fn visit_struct_def(&mut self, s: &StructDef, ident: Ident,\n                             g: &Generics, _: NodeId) {\n-            SawStructDef(content(ident)).hash(self.st);\n+            SawStructDef(ident.name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n@@ -401,15 +391,15 @@ mod svh_visitor {\n         // pattern, please move that method up above this comment.)\n \n         fn visit_ident(&mut self, _: Span, ident: Ident) {\n-            SawIdent(content(ident)).hash(self.st);\n+            SawIdent(ident.name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_ref(&mut self, l: &Lifetime) {\n-            SawLifetimeRef(content(l.name)).hash(self.st);\n+            SawLifetimeRef(l.name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_def(&mut self, l: &LifetimeDef) {\n-            SawLifetimeDef(content(l.lifetime.name)).hash(self.st);\n+            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n         }\n \n         // We do recursively walk the bodies of functions/methods"}, {"sha": "e050276fc76d465f93cd13b4a68983a51cb7f89d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -39,7 +39,6 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{FnDecl, Block, NodeId};\n@@ -1068,7 +1067,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push('.');\n-                        out.push_str(&token::get_name(fname));\n+                        out.push_str(&fname.as_str());\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');"}, {"sha": "2473cf8bbbdb8fcfa4883e90c72a5cc140bf5f2b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -53,7 +53,6 @@ use syntax::ast_util::{self, is_shift_binop, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n-use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n@@ -1043,7 +1042,7 @@ pub struct NonCamelCaseTypes;\n impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = token::get_ident(ident);\n+            let ident = ident.name.as_str();\n             if ident.is_empty() {\n                 return true;\n             }\n@@ -1064,7 +1063,7 @@ impl NonCamelCaseTypes {\n             )).collect::<Vec<_>>().concat()\n         }\n \n-        let s = token::get_ident(ident);\n+        let s = ident.name.as_str();\n \n         if !is_camel_case(ident) {\n             let c = to_camel_case(&s);\n@@ -1245,43 +1244,43 @@ impl LintPass for NonSnakeCase {\n         match fk {\n             visit::FkMethod(ident, _, _) => match method_context(cx, id, span) {\n                 MethodContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &token::get_ident(ident), Some(span))\n+                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n                 },\n                 MethodContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &token::get_ident(ident), Some(span))\n+                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n                 },\n                 _ => (),\n             },\n             visit::FkItemFn(ident, _, _, _, _, _) => {\n-                self.check_snake_case(cx, \"function\", &token::get_ident(ident), Some(span))\n+                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n             },\n             _ => (),\n         }\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         if let ast::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &token::get_ident(it.ident), Some(it.span));\n+            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n         if let ast::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &token::get_ident(trait_item.ident),\n+            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n     fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", &token::get_ident(t.lifetime.name.ident()),\n+        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         if let &ast::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(def::DefLocal(_)) = def {\n-                self.check_snake_case(cx, \"variable\", &token::get_ident(path1.node), Some(p.span));\n+                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n             }\n         }\n     }\n@@ -1290,7 +1289,7 @@ impl LintPass for NonSnakeCase {\n                         _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n             if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", &token::get_ident(ident),\n+                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n                                       Some(sf.span));\n             }\n         }\n@@ -1308,7 +1307,7 @@ pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = token::get_ident(ident);\n+        let s = ident.name.as_str();\n \n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n@@ -1489,7 +1488,7 @@ impl LintPass for UnusedImportBraces {\n                 if items.len() == 1 {\n                     if let ast::PathListIdent {ref name, ..} = items[0].node {\n                         let m = format!(\"braces around {} is unnecessary\",\n-                                        &token::get_ident(*name));\n+                                        name);\n                         cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n                                      &m[..]);\n                     }\n@@ -1525,10 +1524,12 @@ impl LintPass for NonShorthandFieldPatterns {\n             });\n             for fieldpat in field_pats {\n                 if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node.as_str() == fieldpat.node.ident.as_str() {\n+                    if ident.node.name == fieldpat.node.ident.name {\n+                        // FIXME: should this comparison really be done on the name?\n+                        // doing it on the ident will fail during compilation of libcore\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()))\n+                                              be removed\", ident.node))\n                     }\n                 }\n             }\n@@ -1641,7 +1642,7 @@ impl UnusedMut {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n-                    if !token::get_ident(ident).starts_with(\"_\") {\n+                    if !ident.name.as_str().starts_with(\"_\") {\n                         match mutables.entry(ident.name.usize()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },"}, {"sha": "2ffb4cbd4bfb07f472f88c2d21e77eb1dc30eb08", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -46,7 +46,6 @@ use rustc::util::nodemap::{NodeMap, NodeSet};\n use syntax::ast;\n use syntax::ast_util::{is_local, local_def};\n use syntax::codemap::Span;\n-use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n \n type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n@@ -682,8 +681,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ast::ItemEnum(..) => \"enum\",\n             _ => return Some((err_span, err_msg, None))\n         };\n-        let msg = format!(\"{} `{}` is private\", desc,\n-                          token::get_ident(item.ident));\n+        let msg = format!(\"{} `{}` is private\", desc, item.ident);\n         Some((err_span, err_msg, Some((span, msg))))\n     }\n \n@@ -715,7 +713,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         };\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\",\n-                                        token::get_name(name), struct_desc),\n+                                        name, struct_desc),\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n@@ -740,12 +738,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n         };\n \n-        let string = token::get_name(name);\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,\n                                              &format!(\"method `{}`\",\n-                                                     string)));\n+                                                     name)));\n     }\n \n     // Checks that a path is in scope.\n@@ -755,12 +752,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n-                let name = token::get_name(last);\n                 let origdid = path_res.def_id();\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, name))\n+                                   &format!(\"{} `{}`\", tyname, last))\n             };\n \n             match path_res.last_private {"}, {"sha": "27195d9635d730688f47d748cf3f343e6f0c2739", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -52,7 +52,7 @@ use syntax::ast::Visibility;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n@@ -222,7 +222,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             self.session.span_note(sp,\n                                  &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name)));\n+                                      name));\n                         }\n                     }\n                 }\n@@ -294,7 +294,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Build up the import directives.\n                 let shadowable = item.attrs.iter().any(|attr| {\n-                    attr.name() == token::get_name(special_idents::prelude_import.name)\n+                    attr.name() == special_idents::prelude_import.name.as_str()\n                 });\n                 let shadowable = if shadowable {\n                     Shadowable::Always\n@@ -306,12 +306,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let source_name =\n                             full_path.segments.last().unwrap().identifier.name;\n-                        if &token::get_name(source_name)[..] == \"mod\" ||\n-                           &token::get_name(source_name)[..] == \"self\" {\n+                        if source_name.as_str() == \"mod\" || source_name.as_str() == \"self\" {\n                             resolve_error(self,\n-                                            view_path.span,\n-                                            ResolutionError::SelfImportsOnlyAllowedWithin\n-                            );\n+                                          view_path.span,\n+                                          ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n                         let subclass = SingleImport(binding.name,\n@@ -763,7 +761,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                   debug!(\"(building reduced graph for external crate) ... \\\n                           adding trait item '{}'\",\n-                         token::get_name(trait_item_name));\n+                         trait_item_name);\n \n                   self.trait_item_map.insert((trait_item_name, def_id),\n                                              trait_item_def.def_id());\n@@ -849,7 +847,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         self.handle_external_def(def,\n                                                  def_visibility,\n                                                  &*child_name_bindings,\n-                                                 &token::get_name(name),\n+                                                 &name.as_str(),\n                                                  name,\n                                                  root);\n                     }\n@@ -883,7 +881,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     def_id,\n                                     |def_like, child_name, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n-                   token::get_name(child_name));\n+                   child_name);\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_name,\n@@ -937,7 +935,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import directive: {}::{}\",\n                        names_to_string(&module_.imports.borrow().last().unwrap().module_path),\n-                       token::get_name(target));\n+                       target);\n \n                 let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {"}, {"sha": "26f97f4470297a54ea2ce5bea4f8c69a578e18b8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -1275,7 +1275,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               name_search_type,\n                                               false) {\n                 Failed(None) => {\n-                    let segment_name = token::get_name(name);\n+                    let segment_name = name.as_str();\n                     let module_name = module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[..] {\n@@ -1688,27 +1688,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                  -> ResolveResult<ModulePrefixResult> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n-        let mut containing_module;\n-        let mut i;\n-        let first_module_path_string = token::get_name(module_path[0]);\n-        if \"self\" == &first_module_path_string[..] {\n-            containing_module =\n-                self.get_nearest_normal_module_parent_or_self(module_);\n-            i = 1;\n-        } else if \"super\" == &first_module_path_string[..] {\n-            containing_module =\n-                self.get_nearest_normal_module_parent_or_self(module_);\n-            i = 0;  // We'll handle `super` below.\n-        } else {\n-            return Success(NoPrefixFound);\n-        }\n+        let mut i = match &*module_path[0].as_str() {\n+            \"self\" => 1,\n+            \"super\" => 0,\n+            _ => return Success(NoPrefixFound),\n+        };\n+        let mut containing_module = self.get_nearest_normal_module_parent_or_self(module_);\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() {\n-            let string = token::get_name(module_path[i]);\n-            if \"super\" != &string[..] {\n-                break\n-            }\n+        while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&*containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n@@ -2761,7 +2749,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     self,\n                                     pattern.span,\n                                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                                        &*token::get_ident(ident))\n+                                        &ident.name.as_str())\n                                 );\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n@@ -2771,7 +2759,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     self,\n                                     pattern.span,\n                                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                                        &*token::get_ident(ident))\n+                                        &ident.name.as_str())\n                                 );\n                             }\n                             // Else, not bound in the same pattern: do\n@@ -2817,9 +2805,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         self,\n                                         path.span,\n                                         ResolutionError::NotAnEnumVariantStructOrConst(\n-                                            &*token::get_ident(\n-                                                path.segments.last().unwrap().identifier)\n-                                            )\n+                                            &path.segments\n+                                                 .last()\n+                                                 .unwrap()\n+                                                 .identifier\n+                                                 .name\n+                                                 .as_str())\n                                     );\n                                 } else {\n                                     let const_name = path.segments.last().unwrap()\n@@ -2835,7 +2826,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self,\n                             path.span,\n                             ResolutionError::UnresolvedEnumVariantStructOrConst(\n-                                &*token::get_ident(path.segments.last().unwrap().identifier))\n+                                &path.segments.last().unwrap().identifier.name.as_str())\n                         );\n                     }\n                     visit::walk_path(self, path);\n@@ -2872,8 +2863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     self,\n                                     path.span,\n                                     ResolutionError::NotAnAssociatedConst(\n-                                        &*token::get_ident(\n-                                            path.segments.last().unwrap().identifier)\n+                                        &path.segments.last().unwrap().identifier.name.as_str()\n                                     )\n                                 );\n                             }\n@@ -2883,7 +2873,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self,\n                             path.span,\n                             ResolutionError::UnresolvedAssociatedConst(\n-                                &*token::get_ident(path.segments.last().unwrap().identifier)\n+                                &path.segments.last().unwrap().identifier.name.as_str()\n                             )\n                         );\n                     }\n@@ -3304,7 +3294,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match search_result {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to local: {:?}\",\n-                       token::get_ident(ident),\n+                       ident,\n                        def);\n                 Some(def)\n             }\n@@ -3492,7 +3482,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         for rib in self.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {\n-                maybes.push(token::get_name(k));\n+                maybes.push(k.as_str());\n                 values.push(usize::MAX);\n             }\n         }\n@@ -3624,8 +3614,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope &&\n-                               &token::get_name(special_names::self_)[..] == path_name {\n+                            if method_scope && special_names::self_ == path_name {\n                                 resolve_error(\n                                     self,\n                                     expr.span,\n@@ -3706,7 +3695,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         resolve_error(self,\n                                       expr.span,\n-                                      ResolutionError::UndeclaredLabel(&*token::get_ident(label)))\n+                                      ResolutionError::UndeclaredLabel(&label.name.as_str()))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3912,7 +3901,7 @@ fn names_to_string(names: &[Name]) -> String {\n         } else {\n             result.push_str(\"::\")\n         }\n-        result.push_str(&token::get_name(*name));\n+        result.push_str(&name.as_str());\n     };\n     result\n }"}, {"sha": "732c627816c52f982fc146c388be941dee7f4253", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -26,7 +26,6 @@ use module_to_string;\n \n use rustc::middle::def::Export;\n use syntax::ast;\n-use syntax::parse::token;\n \n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n@@ -143,7 +142,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n-                               token::get_name(*name));\n+                               name);\n                         self.add_exports_of_namebindings(exports,\n                                                          *name,\n                                                          &*target.bindings,"}, {"sha": "0a88a3c0aefbb8f9360d6fb0047df7d64373fa49", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -31,7 +31,6 @@ use rustc::middle::privacy::*;\n \n use syntax::ast::{DefId, NodeId, Name};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token;\n use syntax::codemap::Span;\n \n use std::mem::replace;\n@@ -435,10 +434,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                (*child_name_bindings).clone());\n                     if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\",\n-                                          token::get_name(source));\n+                                          source);\n                         let note_msg =\n                             format!(\"Consider marking `{}` as `pub` in the imported module\",\n-                                    token::get_name(source));\n+                                    source);\n                         span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n                         self.resolver.session.span_note(directive.span, &note_msg);\n                         pub_err = true;\n@@ -450,9 +449,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                               (*child_name_bindings).clone());\n                     if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\",\n-                                          token::get_name(source));\n+                                          source);\n                         let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n-                                               token::get_name(source));\n+                                               source);\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n                         self.resolver.session.span_note(directive.span, &note_msg);\n                     }\n@@ -1041,9 +1040,7 @@ fn import_path_to_string(names: &[Name],\n \n fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n     match subclass {\n-        SingleImport(_, source) => {\n-            token::get_name(source).to_string()\n-        }\n+        SingleImport(_, source) => source.to_string(),\n         GlobImport => \"*\".to_string()\n     }\n }"}, {"sha": "5bdc76bd7c29896398717d44318b5550c1430761", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -306,7 +306,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, &token::get_name(e.name()))\n+        push(&mut n, &e.name().as_str())\n     }\n \n     match hash {"}, {"sha": "f1f39d43ee4145f16c755e4b5bdb5cdceb614756", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -40,7 +40,7 @@ use std::path::Path;\n \n use syntax::ast::{self, NodeId, DefId};\n use syntax::codemap::*;\n-use syntax::parse::token::{self, get_ident, keywords};\n+use syntax::parse::token::{self, keywords};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             return;\n         }\n \n-        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n+        debug!(\"process_method: {}:{}\", id, name);\n \n         let method_data = self.save_ctxt.get_method_data(id, name, span);\n \n@@ -459,7 +459,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         self.fmt.static_str(span,\n                             sub_span,\n                             id,\n-                            &get_ident((*ident).clone()),\n+                            &ident.name.as_str(),\n                             &qualname,\n                             &self.span.snippet(expr.span),\n                             &ty_to_string(&*typ),\n@@ -513,7 +513,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                           &enum_data.value);\n \n         for variant in &enum_definition.variants {\n-            let name = &get_ident(variant.node.name);\n+            let name = &variant.node.name.name.as_str();\n             let mut qualname = enum_data.qualname.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(name);\n@@ -886,7 +886,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                                sub_span,\n                                                item.id,\n                                                mod_id,\n-                                               &get_ident(ident),\n+                                               &ident.name.as_str(),\n                                                self.cur_scope);\n                         self.write_sub_paths_truncated(path, true);\n                     }\n@@ -900,7 +900,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                 if !name_string.is_empty() {\n                                     name_string.push_str(\", \");\n                                 }\n-                                name_string.push_str(n.as_str());\n+                                name_string.push_str(&n.as_str());\n                             }\n                         }\n \n@@ -940,11 +940,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             ast::ItemExternCrate(ref s) => {\n-                let name = get_ident(item.ident);\n-                let name = &name;\n                 let location = match *s {\n                     Some(s) => s.to_string(),\n-                    None => name.to_string(),\n+                    None => item.ident.to_string(),\n                 };\n                 let alias_span = self.span.span_for_last_ident(item.span);\n                 let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n@@ -955,7 +953,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           alias_span,\n                                           item.id,\n                                           cnum,\n-                                          name,\n+                                          &item.ident.name.as_str(),\n                                           &location,\n                                           self.cur_scope);\n             }"}, {"sha": "8d3be7c8c6070d47b49d39841b9432e75efe25b4", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -21,7 +21,7 @@ use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_util;\n use syntax::codemap::*;\n-use syntax::parse::token::{self, get_ident, keywords};\n+use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n@@ -227,7 +227,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n                 Data::VariableData(VariableData {\n                     id: item.id,\n-                    name: get_ident(item.ident).to_string(),\n+                    name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n@@ -241,7 +241,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n                 Data::VariableData(VariableData {\n                     id: item.id,\n-                    name: get_ident(item.ident).to_string(),\n+                    name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n@@ -259,7 +259,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n                 Data::ModData(ModData {\n                     id: item.id,\n-                    name: get_ident(item.ident).to_string(),\n+                    name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n@@ -323,16 +323,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n-                let name = get_ident(ident);\n                 let qualname = format!(\"::{}::{}\",\n                                        self.tcx.map.path_to_string(scope),\n-                                       name);\n+                                       ident);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n                                                .to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(VariableData {\n                     id: field.node.id,\n-                    name: get_ident(ident).to_string(),\n+                    name: ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: scope,\n@@ -404,7 +403,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, &token::get_name(name));\n+        let qualname = format!(\"{}::{}\", qualname, name);\n \n         let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n             .and_then(|new_id| {\n@@ -420,7 +419,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         FunctionData {\n             id: id,\n-            name: token::get_name(name).to_string(),\n+            name: name.to_string(),\n             qualname: qualname,\n             declaration: decl_id,\n             span: sub_span.unwrap(),\n@@ -454,7 +453,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                                 return Some(Data::VariableRefData(VariableRefData {\n-                                    name: get_ident(ident.node).to_string(),\n+                                    name: ident.node.to_string(),\n                                     span: sub_span.unwrap(),\n                                     scope: self.enclosing_scope(expr.id),\n                                     ref_id: f.id,\n@@ -464,7 +463,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n                         self.tcx.sess.span_bug(expr.span,\n                                                &format!(\"Couldn't find field {} on {:?}\",\n-                                                        &get_ident(ident.node), ty))\n+                                                        ident.node, ty))\n                     }\n                     _ => {\n                         debug!(\"Expected struct type, found {:?}\", ty);\n@@ -626,7 +625,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                               parent: NodeId)\n                               -> VariableRefData {\n         let fields = self.tcx.lookup_struct_fields(struct_id);\n-        let field_name = get_ident(field_ref.ident.node).to_string();\n+        let field_name = field_ref.ident.node.to_string();\n         for f in &fields {\n             if f.name == field_ref.ident.node.name {\n                 // We don't really need a sub-span here, but no harm done\n@@ -700,7 +699,7 @@ impl<'v> Visitor<'v> for PathCollector {\n             }\n             ast::PatIdent(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                       token::get_ident(path1.node),\n+                       path1.node,\n                        p.span,\n                        path1.span);\n                 let immut = match bm {"}, {"sha": "9f65050097ded009a66802a31eafb12f72495a08", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -617,7 +617,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n     pub fn name(&self, name: ast::Name) -> String {\n-        token::get_name(name).to_string()\n+        name.to_string()\n     }\n \n     pub fn node_id_to_string(&self, id: ast::NodeId) -> String {"}, {"sha": "6ccf7ccfa08c3d5ae7f763d2215ec3508d2ed2b9", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -1152,7 +1152,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             let name = if field.name == special_idents::unnamed_field.name {\n                 format!(\"__{}\", i)\n             } else {\n-                token::get_name(field.name).to_string()\n+                field.name.to_string()\n             };\n \n             let offset = if self.is_simd {\n@@ -1307,7 +1307,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n-                                                  &*(*self.variants)[i],\n+                                                  &*self.variants[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n                                                   self.span);\n@@ -1340,7 +1340,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n-                                              &*(*self.variants)[0],\n+                                              &*self.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -1369,8 +1369,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n-                let non_null_variant_name = token::get_name(non_null_variant.name);\n+                let non_null_variant = &self.variants[non_null_variant_index as usize];\n+                let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n                 let non_null_llvm_type = type_of::type_of(cx, nnty);\n@@ -1385,7 +1385,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_name(names[0]).to_string(),\n+                        Some(ref names) => names[0].to_string(),\n                         None => \"__0\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -1415,7 +1415,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let null_variant_name = self.variants[null_variant_index].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n                                                 null_variant_name);\n@@ -1440,7 +1440,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &*(*self.variants)[nndiscr as usize],\n+                                          &*self.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1456,7 +1456,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let null_variant_name = self.variants[null_variant_index].name;\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n@@ -1534,26 +1534,25 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n-    let variant_name = token::get_name(variant_info.name);\n-    let variant_name = &variant_name;\n+    let variant_name = variant_info.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n                                               cx,\n                                               enum_type,\n-                                              variant_name);\n+                                              &variant_name);\n \n     let metadata_stub = create_struct_stub(cx,\n                                            variant_llvm_type,\n-                                           variant_name,\n+                                           &variant_name,\n                                            unique_type_id,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n     let mut arg_names: Vec<_> = match variant_info.arg_names {\n         Some(ref names) => {\n             names.iter()\n-                 .map(|&name| token::get_name(name).to_string())\n+                 .map(|name| name.to_string())\n                  .collect()\n         }\n         None => {\n@@ -1609,7 +1608,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n-            let token = token::get_name(v.name);\n+            let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n@@ -1723,7 +1722,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n         };\n \n-        token::get_name(name)\n+        name.as_str()\n     }\n }\n \n@@ -1907,7 +1906,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_name(name).to_string();\n+    let var_name = name.to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[..]);\n     let var_scope = namespace_node.scope;"}, {"sha": "97baaa2e74bfd03994f7cb2bd4c4db8142507f9d", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -333,7 +333,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = String::from(&*token::get_name(name));\n+    let mut function_name = name.to_string();\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -494,7 +494,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               actual_self_type,\n                                                               codemap::DUMMY_SP);\n \n-                let name = token::get_name(special_idents::type_self.name);\n+                let name = special_idents::type_self.name.as_str();\n \n                 let name = CString::new(name.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n@@ -529,8 +529,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Again, only create type information if full debuginfo is enabled\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let ident = token::get_ident(ident);\n-                let name = CString::new(ident.as_bytes()).unwrap();\n+                let name = CString::new(ident.name.as_str().as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -563,7 +562,6 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = span_start(cx, span).file.name.clone();\n     let file_metadata = file_metadata(cx, &filename[..]);\n \n-    let name = token::get_name(variable_name);\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n@@ -573,7 +571,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let name = CString::new(name.as_bytes()).unwrap();\n+    let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n     match (variable_access, &[][..]) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {"}, {"sha": "fa92fb0baaea051012797f092b7e94a60ce792f8", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -36,14 +36,14 @@ impl NamespaceTreeNode {\n                 Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n                 None => {}\n             }\n-            let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.len()));\n+            let string = node.name.as_str();\n+            output.push_str(&string.len().to_string());\n             output.push_str(&string);\n         }\n \n         let mut name = String::from(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(&format!(\"{}\", item_name.len()));\n+        name.push_str(&item_name.len().to_string());\n         name.push_str(item_name);\n         name.push('E');\n         name\n@@ -93,7 +93,7 @@ pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<Namespace\n                         Some(ref node) => node.scope,\n                         None => ptr::null_mut()\n                     };\n-                    let namespace_name = token::get_name(name);\n+                    let namespace_name = name.as_str();\n                     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n                     let scope = unsafe {\n                         llvm::LLVMDIBuilderCreateNameSpace("}, {"sha": "4835cfc4a253f177277ff91f084272e0d81d6b5b", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -17,7 +17,6 @@ use middle::subst::{self, Substs};\n use middle::ty::{self, Ty};\n \n use syntax::ast;\n-use syntax::parse::token;\n \n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n@@ -179,8 +178,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n                 let mut path_element_count = 0;\n                 for path_element in path {\n-                    let name = token::get_name(path_element.name());\n-                    output.push_str(&name);\n+                    output.push_str(&path_element.name().as_str());\n                     output.push_str(\"::\");\n                     path_element_count += 1;\n                 }\n@@ -192,10 +190,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.pop();\n                 output.pop();\n             } else {\n-                let name = token::get_name(path.last()\n-                                               .expect(\"debuginfo: Empty item path?\")\n-                                               .name());\n-                output.push_str(&name);\n+                let name = path.last().expect(\"debuginfo: Empty item path?\").name();\n+                output.push_str(&name.as_str());\n             }\n         });\n     }"}, {"sha": "cafc0be74ba89e95edadb6197db253443ab24172", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -37,7 +37,6 @@ use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n-use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n use syntax::print::pprust;\n@@ -902,7 +901,7 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n         Some(ln) => ln.clone(),\n         None => match weak_lang_items::link_name(&i.attrs) {\n             Some(name) => name,\n-            None => token::get_ident(i.ident),\n+            None => i.ident.name.as_str(),\n         }\n     }\n }"}, {"sha": "32adcaa3a416771f7b9f3647313e92f01f70fa6b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use syntax::parse::token;\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let name = match &token::get_ident(item.ident)[..] {\n+    let name = match &*item.ident.name.as_str() {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -171,10 +171,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);\n-    let name = token::get_ident(foreign_item.ident);\n+    let name = foreign_item.ident.name.as_str();\n \n     // For `transmute` we can just trans the input expr directly into dest\n-    if &name[..] == \"transmute\" {\n+    if name == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n@@ -271,7 +271,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // (the first argument) and then trans the source value (the\n     // second argument) directly into the resulting destination\n     // address.\n-    if &name[..] == \"move_val_init\" {\n+    if name == \"move_val_init\" {\n         if let callee::ArgExprs(ref exprs) = args {\n             let (dest_expr, source_expr) = if exprs.len() != 2 {\n                 ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n@@ -354,7 +354,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n     // These are the only intrinsic functions that diverge.\n-    if &name[..] == \"abort\" {\n+    if name == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n@@ -387,7 +387,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-    let llval = match (simple, &name[..]) {\n+    let llval = match (simple, &*name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n         }"}, {"sha": "499e0911da8a0fb4611516d688d0d2b0632c619c", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -39,7 +39,6 @@ use trans::type_of::*;\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n-use syntax::parse::token;\n use syntax::{ast, attr, visit};\n use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n@@ -175,7 +174,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         csearch::get_item_path(tcx, method_id).last().unwrap().name()\n     };\n     debug!(\"trans_static_method_callee: method_id={:?}, expr_id={}, \\\n-            name={}\", method_id, expr_id, token::get_name(mname));\n+            name={}\", method_id, expr_id, mname);\n \n     // Find the substitutions for the fn itself. This includes\n     // type parameters that belong to the trait but also some that"}, {"sha": "3f936e40d4cab1e7f88dd7b9bfe2e189aeb01dba", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -903,7 +903,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     let candidate = try!(one_bound_for_assoc_type(tcx,\n                                                   candidates,\n                                                   &trait_ref.to_string(),\n-                                                  &token::get_name(binding.item_name),\n+                                                  &binding.item_name.as_str(),\n                                                   binding.span));\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n@@ -1150,8 +1150,8 @@ fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n \n     one_bound_for_assoc_type(tcx,\n                              suitable_bounds,\n-                             &token::get_name(ty_param_name),\n-                             &token::get_name(assoc_name),\n+                             &ty_param_name.as_str(),\n+                             &assoc_name.as_str(),\n                              span)\n }\n \n@@ -1236,7 +1236,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             match one_bound_for_assoc_type(tcx,\n                                            candidates,\n                                            \"Self\",\n-                                           &token::get_name(assoc_name),\n+                                           &assoc_name.as_str(),\n                                            span) {\n                 Ok(bound) => bound,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n@@ -1269,7 +1269,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                              span,\n                                              &ty.to_string(),\n                                              \"Trait\",\n-                                             &token::get_name(assoc_name));\n+                                             &assoc_name.as_str());\n             return (tcx.types.err, ty_path_def);\n         }\n     };\n@@ -1320,7 +1320,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                          span,\n                                          \"Type\",\n                                          &path_str,\n-                                         &token::get_ident(item_segment.identifier));\n+                                         &item_segment.identifier.name.as_str());\n         return tcx.types.err;\n     };\n "}, {"sha": "b853a5300e2b05893d5371885d520859b7ae412d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -27,7 +27,6 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::{Span, Spanned};\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n@@ -736,10 +735,10 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\",\n-                    token::get_ident(field.ident));\n+                    field.ident);\n                 span_note!(tcx.sess, *occupied.get(),\n                     \"field `{}` previously bound here\",\n-                    token::get_ident(field.ident));\n+                    field.ident);\n                 tcx.types.err\n             }\n             Vacant(vacant) => {\n@@ -749,7 +748,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n                             tcx.item_path_str(struct_id),\n-                            token::get_ident(field.ident));\n+                            field.ident);\n                         tcx.types.err\n                     })\n             }\n@@ -767,7 +766,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             .filter(|field| !used_fields.contains_key(&field.name)) {\n             span_err!(tcx.sess, span, E0027,\n                 \"pattern does not mention field `{}`\",\n-                token::get_name(field.name));\n+                field.name);\n         }\n     }\n }"}, {"sha": "6d8b757d167206dcac3f80027155211ee22cffa9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -16,7 +16,6 @@ use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n \n use super::assoc;\n \n@@ -85,7 +84,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         span_err!(tcx.sess, impl_m_span, E0049,\n             \"method `{}` has {} type parameter{} \\\n              but its trait declaration has {} type parameter{}\",\n-            token::get_name(trait_m.name),\n+            trait_m.name,\n             num_impl_m_type_params,\n             if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n             num_trait_m_type_params,\n@@ -97,7 +96,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         span_err!(tcx.sess, impl_m_span, E0050,\n             \"method `{}` has {} parameter{} \\\n              but the declaration in trait `{}` has {}\",\n-            token::get_name(trait_m.name),\n+            trait_m.name,\n             impl_m.fty.sig.0.inputs.len(),\n             if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n             tcx.item_path_str(trait_m.def_id),\n@@ -337,7 +336,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                    trait_fty);\n             span_err!(tcx.sess, impl_m_span, E0053,\n                       \"method `{}` has an incompatible type for trait: {}\",\n-                      token::get_name(trait_m.name),\n+                      trait_m.name,\n                       terr);\n             return;\n         }\n@@ -401,7 +400,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_err!(tcx.sess, span, E0195,\n                 \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                         token::get_name(impl_m.name));\n+                         impl_m.name);\n             return false;\n         }\n \n@@ -484,7 +483,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_err!(tcx.sess, impl_c_span, E0326,\n                       \"implemented const `{}` has an incompatible type for \\\n                       trait: {}\",\n-                      token::get_name(trait_c.name),\n+                      trait_c.name,\n                       terr);\n             return;\n         }"}, {"sha": "add46f7efb9ec8224ee6ca4e429712f168485a56", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -119,7 +119,7 @@ use syntax::ast_util::{self, local_def};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::emit_feature_err;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, InternedString};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                                                traits::VariableType(p.id));\n \n                 debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n-                       token::get_ident(path1.node),\n+                       path1.node,\n                        self.fcx.infcx().ty_to_string(\n                            self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n                        var_ty);\n@@ -662,7 +662,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       }\n       ast::ItemFn(..) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-          debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n+          debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n           match ccx.tcx.impl_trait_ref(local_def(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n@@ -718,7 +718,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n+        debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n \n         let impl_pty = ccx.tcx.lookup_item_type(ast_util::local_def(it.id));\n \n@@ -796,14 +796,14 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.ident.as_str() == s\n+                            t.ident.name == s\n                         }) {\n                             Some(_) => (),\n                             None => {\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident.as_str());\n+                                                           s, item.ident);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n@@ -865,7 +865,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // This is checked by resolve\n                 tcx.sess.span_bug(impl_item.span,\n                                   &format!(\"impl-item `{}` is not a member of `{:?}`\",\n-                                           token::get_name(ty_impl_item.name()),\n+                                           ty_impl_item.name(),\n                                            impl_trait_ref));\n             });\n         match impl_item.node {\n@@ -886,7 +886,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     span_err!(tcx.sess, impl_item.span, E0323,\n                               \"item `{}` is an associated const, \\\n                               which doesn't match its trait `{:?}`\",\n-                              token::get_name(impl_const.name),\n+                              impl_const.name,\n                               impl_trait_ref)\n                 }\n             }\n@@ -909,7 +909,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     span_err!(tcx.sess, impl_item.span, E0324,\n                               \"item `{}` is an associated method, \\\n                               which doesn't match its trait `{:?}`\",\n-                              token::get_name(impl_method.name),\n+                              impl_method.name,\n                               impl_trait_ref)\n                 }\n             }\n@@ -927,7 +927,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     span_err!(tcx.sess, impl_item.span, E0325,\n                               \"item `{}` is an associated type, \\\n                               which doesn't match its trait `{:?}`\",\n-                              token::get_name(impl_type.name),\n+                              impl_type.name,\n                               impl_trait_ref)\n                 }\n             }\n@@ -1009,7 +1009,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(<ast::Name>::as_str)\n+                  .map(|name| name.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"))\n     }\n \n@@ -1018,9 +1018,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         span_err!(tcx.sess, invalidator.span, E0399,\n                   \"the following trait items need to be reimplemented \\\n                    as `{}` was overridden: `{}`\",\n-                  invalidator.ident.as_str(),\n+                  invalidator.ident,\n                   invalidated_items.iter()\n-                                   .map(<ast::Name>::as_str)\n+                                   .map(|name| name.to_string())\n                                    .collect::<Vec<_>>().join(\"`, `\"))\n     }\n }\n@@ -2901,7 +2901,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 field.span,\n                 |actual| {\n                     format!(\"attempted to take value of method `{}` on type \\\n-                            `{}`\", token::get_ident(field.node), actual)\n+                            `{}`\", field.node, actual)\n                 },\n                 expr_t, None);\n \n@@ -2915,7 +2915,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     format!(\"attempted access of field `{}` on \\\n                             type `{}`, but no field with that \\\n                             name was found\",\n-                            token::get_ident(field.node),\n+                            field.node,\n                             actual)\n                 },\n                 expr_t, None);\n@@ -2931,24 +2931,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     fn suggest_field_names<'tcx>(id : DefId,\n                                  field : &ast::SpannedIdent,\n                                  tcx : &ty::ctxt<'tcx>,\n-                                 skip : Vec<&str>) {\n-        let ident = token::get_ident(field.node);\n-        let name = &ident;\n+                                 skip : Vec<InternedString>) {\n+        let name = field.node.name.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n         let fields = tcx.lookup_struct_fields(id);\n         let mut best = None;\n         for elem in &fields {\n             let n = elem.name.as_str();\n             // ignore already set fields\n-            if skip.iter().any(|&x| x == n) {\n+            if skip.iter().any(|x| *x == n) {\n                 continue;\n             }\n             // ignore private fields from non-local crates\n             if id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n                 continue;\n             }\n-            let dist = lev_distance(n, name);\n+            let dist = lev_distance(&n, &name);\n             if dist < best_dist {\n                 best = Some(n);\n                 best_dist = dist;\n@@ -3061,12 +3060,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                             class_id);\n                                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n                                         actual, variant_type.name.as_str(),\n-                                        token::get_ident(field.ident.node))\n+                                        field.ident.node)\n                             }\n                             None => {\n                                 format!(\"structure `{}` has no field named `{}`\",\n                                         actual,\n-                                        token::get_ident(field.ident.node))\n+                                        field.ident.node)\n                             }\n                         },\n                         struct_ty,\n@@ -3083,7 +3082,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Some((_, true)) => {\n                     span_err!(fcx.tcx().sess, field.ident.span, E0062,\n                         \"field `{}` specified more than once\",\n-                        token::get_ident(field.ident.node));\n+                        field.ident.node);\n                     error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n@@ -3117,7 +3116,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let (_, seen) = *class_field_map.get(&name).unwrap();\n                     if !seen {\n                         missing_fields.push(\n-                            format!(\"`{}`\", &token::get_name(name)))\n+                            format!(\"`{}`\", name))\n                     }\n                 }\n \n@@ -5059,7 +5058,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         if !*b {\n             span_err!(ccx.tcx.sess, span, E0091,\n                 \"type parameter `{}` is unused\",\n-                token::get_ident(tps[i].ident));\n+                tps[i].ident);\n         }\n     }\n }\n@@ -5073,7 +5072,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n \n     let tcx = ccx.tcx;\n-    let name = token::get_ident(it.ident);\n+    let name = it.ident.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");"}, {"sha": "cfb7dfc54aaea399ff245a7d28dd3e2934aa8290", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -23,7 +23,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token::special_idents;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -422,7 +422,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n         if impl_params.contains(&method_param.name) {\n             span_err!(tcx.sess, span, E0194,\n                 \"type parameter `{}` shadows another type parameter of the same name\",\n-                          token::get_name(method_param.name));\n+                          method_param.name);\n         }\n     }\n }"}, {"sha": "418d592c9627bd09c42ca173127cecdd8e61d94c", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -383,14 +383,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))\n+                                         name)\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                        span_err!(tcx.sess, span, E0205,\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))\n+                                         name)\n                 }\n                 Err(ty::TypeIsStructural) => {\n                        span_err!(tcx.sess, span, E0206,"}, {"sha": "5b65f7808307292a8780dbe62ce2a599ceda149b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -91,7 +91,6 @@ use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::visit;\n \n@@ -795,7 +794,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n-    debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n+    debug!(\"convert: item {} with id {}\", it.ident, it.id);\n     match it.node {\n         // These don't define types.\n         ast::ItemExternCrate(_) | ast::ItemUse(_) |\n@@ -1086,7 +1085,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 Some(prev_span) => {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n-                              token::get_name(result.name));\n+                              result.name);\n                     span_note!(tcx.sess, *prev_span, \"previously declared here\");\n                     true\n                 },"}, {"sha": "11a0e0eaa496e65dc68ffa1c9dae050a600a3437", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -745,19 +745,19 @@ impl Lifetime {\n \n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.name).to_string())\n+        Lifetime(self.name.to_string())\n     }\n }\n \n impl Clean<Lifetime> for ast::LifetimeDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.lifetime.name).to_string())\n+        Lifetime(self.lifetime.name.to_string())\n     }\n }\n \n impl Clean<Lifetime> for ty::RegionParameterDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.name).to_string())\n+        Lifetime(self.name.to_string())\n     }\n }\n \n@@ -766,7 +766,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n-                Some(Lifetime(token::get_name(name).to_string())),\n+                Some(Lifetime(name.to_string())),\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |\n@@ -1695,7 +1695,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::TyProjection(ref data) => data.clean(cx),\n \n-            ty::TyParam(ref p) => Generic(token::get_name(p.name).to_string()),\n+            ty::TyParam(ref p) => Generic(p.name.to_string()),\n \n             ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n@@ -2048,7 +2048,7 @@ impl Clean<PathSegment> for ast::PathSegment {\n fn path_to_string(p: &ast::Path) -> String {\n     let mut s = String::new();\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n+    for i in p.segments.iter().map(|x| x.identifier.name.as_str()) {\n         if !first || p.global {\n             s.push_str(\"::\");\n         } else {\n@@ -2061,13 +2061,13 @@ fn path_to_string(p: &ast::Path) -> String {\n \n impl Clean<String> for ast::Ident {\n     fn clean(&self, _: &DocContext) -> String {\n-        token::get_ident(*self).to_string()\n+        self.to_string()\n     }\n }\n \n impl Clean<String> for ast::Name {\n     fn clean(&self, _: &DocContext) -> String {\n-        token::get_name(*self).to_string()\n+        self.to_string()\n     }\n }\n \n@@ -2532,14 +2532,14 @@ fn name_from_pat(p: &ast::Pat) -> String {\n     match p.node {\n         PatWild(PatWildSingle) => \"_\".to_string(),\n         PatWild(PatWildMulti) => \"..\".to_string(),\n-        PatIdent(_, ref p, _) => token::get_ident(p.node).to_string(),\n+        PatIdent(_, ref p, _) => p.node.to_string(),\n         PatEnum(ref p, _) => path_to_string(p),\n         PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n                                 which is not allowed in function arguments\"),\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n-                                  format!(\"{}: {}\", fp.ident.as_str(), name_from_pat(&*fp.pat)))\n+                                  format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n@@ -2603,7 +2603,7 @@ fn resolve_type(cx: &DocContext,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n         def::DefSelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(token::get_name(special_idents::type_self.name).to_string());\n+            return Generic(special_idents::type_self.name.to_string());\n         }\n         def::DefSelfTy(..) | def::DefTyParam(..) => true,\n         _ => false,"}, {"sha": "3facaef7b287f761f7433e806c5c8453097de564", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -75,7 +75,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 continue\n             },\n             token::Shebang(s) => {\n-                try!(write!(out, \"{}\", Escape(s.as_str())));\n+                try!(write!(out, \"{}\", Escape(&s.as_str())));\n                 continue\n             },\n             // If this '&' token is directly adjacent to another token, assume\n@@ -141,7 +141,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             // keywords are also included in the identifier set\n             token::Ident(ident, _is_mod_sep) => {\n-                match &token::get_ident(ident)[..] {\n+                match &*ident.name.as_str() {\n                     \"ref\" | \"mut\" => \"kw-2\",\n \n                     \"self\" => \"self\","}, {"sha": "db173d08308158e6e99c73dea98c14501978ee2a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -87,10 +87,6 @@ pub struct Ident {\n impl Ident {\n     /// Construct an identifier with the given name and an empty context:\n     pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n-\n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.name.as_str()\n-    }\n }\n \n impl fmt::Debug for Ident {\n@@ -108,13 +104,13 @@ impl fmt::Display for Ident {\n impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n-        write!(f, \"{:?}({})\", token::get_name(*self), nm)\n+        write!(f, \"{}({})\", self, nm)\n     }\n }\n \n impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&token::get_name(*self), f)\n+        fmt::Display::fmt(&self.as_str(), f)\n     }\n }\n \n@@ -134,13 +130,10 @@ impl PartialEq for Ident {\n             // one example and its non-hygienic counterpart would be:\n             //      syntax::parse::token::Token::mtwt_eq\n             //      syntax::ext::tt::macro_parser::token_name_eq\n-            panic!(\"not allowed to compare these idents: {}, {}. \\\n+            panic!(\"not allowed to compare these idents: {:?}, {:?}. \\\n                    Probably related to issue \\\\#6993\", self, other);\n         }\n     }\n-    fn ne(&self, other: &Ident) -> bool {\n-        ! self.eq(other)\n-    }\n }\n \n /// A SyntaxContext represents a chain of macro-expandings\n@@ -166,12 +159,15 @@ pub const ILLEGAL_CTXT : SyntaxContext = 1;\n            RustcEncodable, RustcDecodable, Clone, Copy)]\n pub struct Name(pub u32);\n \n+impl<T: AsRef<str>> PartialEq<T> for Name {\n+    fn eq(&self, other: &T) -> bool {\n+        self.as_str() == other.as_ref()\n+    }\n+}\n+\n impl Name {\n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        unsafe {\n-            // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute::<&str,&str>(&token::get_name(*self))\n-        }\n+    pub fn as_str(&self) -> token::InternedString {\n+        token::InternedString::new_from_name(*self)\n     }\n \n     pub fn usize(&self) -> usize {\n@@ -189,7 +185,7 @@ pub type Mrk = u32;\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&token::get_ident(*self))\n+        s.emit_str(&self.name.as_str())\n     }\n }\n \n@@ -1073,7 +1069,7 @@ impl TokenTree {\n     pub fn len(&self) -> usize {\n         match *self {\n             TtToken(_, token::DocComment(name)) => {\n-                match doc_comment_style(name.as_str()) {\n+                match doc_comment_style(&name.as_str()) {\n                     AttrOuter => 2,\n                     AttrInner => 3\n                 }\n@@ -1096,11 +1092,11 @@ impl TokenTree {\n                 TtToken(sp, token::Pound)\n             }\n             (&TtToken(sp, token::DocComment(name)), 1)\n-            if doc_comment_style(name.as_str()) == AttrInner => {\n+            if doc_comment_style(&name.as_str()) == AttrInner => {\n                 TtToken(sp, token::Not)\n             }\n             (&TtToken(sp, token::DocComment(name)), _) => {\n-                let stripped = strip_doc_comment_decoration(name.as_str());\n+                let stripped = strip_doc_comment_decoration(&name.as_str());\n                 TtDelimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,"}, {"sha": "83d3c9c4ec5ead137b3d52e35b45ce142b4961e7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -25,9 +25,7 @@ use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.iter().map(|i| {\n-        token::get_ident(*i).to_string()\n-    }).collect::<Vec<String>>().join(\"::\")\n+    idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n \n pub fn local_def(id: NodeId) -> DefId {"}, {"sha": "48fd05a7550fcd5e57f79a97327072de9f79c222", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -63,7 +63,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             // Previously used errors.\n             Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n                 ecx.span_warn(span, &format!(\n-                    \"diagnostic code {} already used\", &token::get_ident(code)\n+                    \"diagnostic code {} already used\", code\n                 ));\n                 ecx.span_note(previous_span, \"previous invocation\");\n             }\n@@ -74,7 +74,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             // Unregistered errors.\n             None => {\n                 ecx.span_err(span, &format!(\n-                    \"used diagnostic code {} not registered\", &token::get_ident(code)\n+                    \"used diagnostic code {} not registered\", code\n                 ));\n             }\n         }\n@@ -110,7 +110,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         if !msg.starts_with(\"\\n\") || !msg.ends_with(\"\\n\") {\n             ecx.span_err(span, &format!(\n                 \"description for error code {} doesn't start and end with a newline\",\n-                token::get_ident(*code)\n+                code\n             ));\n         }\n \n@@ -122,7 +122,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ecx.span_err(span, &format!(\n                 \"description for error code {} contains a line longer than {} characters.\\n\\\n                  if you're inserting a long URL use the footnote style to bypass this check.\",\n-                token::get_ident(*code), MAX_DESCRIPTION_WIDTH\n+                code, MAX_DESCRIPTION_WIDTH\n             ));\n         }\n     });\n@@ -134,12 +134,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         };\n         if diagnostics.insert(code.name, info).is_some() {\n             ecx.span_err(span, &format!(\n-                \"diagnostic code {} already registered\", &token::get_ident(*code)\n+                \"diagnostic code {} already registered\", code\n             ));\n         }\n     });\n-    let sym = Ident::new(token::gensym(&(\n-        \"__register_diagnostic_\".to_string() + &token::get_ident(*code)\n+    let sym = Ident::new(token::gensym(&format!(\n+        \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec![\n         ecx.item_mod(\n@@ -163,7 +163,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             &ast::TtToken(_, token::Ident(ref crate_name, _)),\n             // DIAGNOSTICS ident.\n             &ast::TtToken(_, token::Ident(ref name, _))\n-        ) => (crate_name.as_str(), name),\n+        ) => (*&crate_name, name),\n         _ => unreachable!()\n     };\n \n@@ -172,7 +172,10 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n         .ok().expect(\"unable to determine target arch from $CFG_COMPILER_HOST_TRIPLE\");\n \n     with_registered_diagnostics(|diagnostics| {\n-        if let Err(e) = output_metadata(ecx, &target_triple, crate_name, &diagnostics) {\n+        if let Err(e) = output_metadata(ecx,\n+                                        &target_triple,\n+                                        &crate_name.name.as_str(),\n+                                        &diagnostics) {\n             ecx.span_bug(span, &format!(\n                 \"error writing metadata for triple `{}` and crate `{}`, error: {}, cause: {:?}\",\n                 target_triple, crate_name, e.description(), e.cause()\n@@ -187,8 +190,8 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 diagnostics.iter().filter_map(|(code, info)| {\n                     info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n-                            ecx.expr_str(span, token::get_name(*code)),\n-                            ecx.expr_str(span, token::get_name(description))\n+                            ecx.expr_str(span, code.as_str()),\n+                            ecx.expr_str(span, description.as_str())\n                         ])\n                     })\n                 }).collect();"}, {"sha": "b91c54ae97220f54e85a4f5a281c37b069ae075a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -629,9 +629,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n-        let field_name = token::get_ident(ident);\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_usize(field_name.len()),\n+            lo: sp.lo - Pos::from_usize(ident.name.as_str().len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };"}, {"sha": "24436c4520db39518e329496a3735b4c02bfa4c1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n         } else {\n             match *e {\n                 ast::TtToken(_, token::Ident(ident, _)) => {\n-                    res_str.push_str(&token::get_ident(ident))\n+                    res_str.push_str(&ident.name.as_str())\n                 },\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n@@ -49,7 +49,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         }\n     }\n-    let res = str_to_ident(&res_str[..]);\n+    let res = str_to_ident(&res_str);\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "085d9d60937fb85f7499b5c3d70a88a8ffdcdd58", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -128,7 +128,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n                                 vec!(\n-                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n+                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 cx.expr_usize(trait_span, nfields),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n             ))\n@@ -140,10 +140,10 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let mut variants = Vec::new();\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, token::get_ident(name)));\n+            for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n+                variants.push(cx.expr_str(v_span, ident.name.as_str()));\n \n-                let path = cx.path(trait_span, vec![substr.type_ident, name]);\n+                let path = cx.path(trait_span, vec![substr.type_ident, ident]);\n                 let decoded = decode_static_fields(cx,\n                                                    v_span,\n                                                    path,\n@@ -175,7 +175,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n                                 vec!(\n-                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n+                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n             ))\n         }\n@@ -211,9 +211,9 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n         }\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n-            let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n-                let arg = getarg(cx, span, token::get_ident(name), i);\n-                cx.field_imm(span, name, arg)\n+            let fields = fields.iter().enumerate().map(|(i, &(ident, span))| {\n+                let arg = getarg(cx, span, ident.name.as_str(), i);\n+                cx.field_imm(span, ident, arg)\n             }).collect();\n             cx.expr_struct(trait_span, outer_pat_path, fields)\n         }"}, {"sha": "ae4d337b9f6c84d015fc3a259f6ac216d146d642", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -186,7 +186,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     ..\n                 }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => token::get_ident(id),\n+                    Some(id) => id.name.as_str(),\n                     None => {\n                         token::intern_and_get_ident(&format!(\"_field{}\", i))\n                     }\n@@ -223,7 +223,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n                                 vec!(\n-                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n+                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 cx.expr_usize(trait_span, fields.len()),\n                 blk\n             ))\n@@ -263,7 +263,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, token::get_ident(variant.node.name));\n+            let name = cx.expr_str(trait_span, variant.node.name.name.as_str());\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            vec!(name,\n@@ -275,7 +275,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n                                           vec!(\n-                cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n+                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 blk\n             ));\n             cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))"}, {"sha": "3a478884c6abb30c2a45e0007e89a359c412ea15", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -59,7 +59,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n-    let name = match *substr.fields {\n+    let ident = match *substr.fields {\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n         EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n@@ -69,7 +69,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n     let span = Span { expn_id: cx.backtrace(), .. span };\n-    let name = cx.expr_lit(span, ast::Lit_::LitStr(token::get_ident(name),\n+    let name = cx.expr_lit(span, ast::Lit_::LitStr(ident.name.as_str(),\n                                                    ast::StrStyle::CookedStr));\n     let mut expr = substr.nonself_args[0].clone();\n \n@@ -102,7 +102,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                 for field in fields {\n                     let name = cx.expr_lit(field.span, ast::Lit_::LitStr(\n-                            token::get_ident(field.name.clone().unwrap()),\n+                            field.name.unwrap().name.as_str(),\n                             ast::StrStyle::CookedStr));\n \n                     // Use double indirection to make sure this works for unsized types"}, {"sha": "6e49b190f7c21076042f3888dc4f5e686b9672d9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -545,14 +545,13 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                 // let compilation continue\n                 return None;\n             }\n-            let extname = pth.segments[0].identifier;\n-            let extnamestr = token::get_ident(extname);\n-            match fld.cx.syntax_env.find(&extname.name) {\n+            let extname = pth.segments[0].identifier.name;\n+            match fld.cx.syntax_env.find(&extname) {\n                 None => {\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                &extnamestr));\n+                                &extname));\n \n                     // let compilation continue\n                     None\n@@ -562,7 +561,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                         fld.cx.bt_push(ExpnInfo {\n                                 call_site: span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr.to_string(),\n+                                    name: extname.to_string(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                     allow_internal_unstable: allow_internal_unstable,\n@@ -589,7 +588,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n-                                            &extnamestr[..]\n+                                            extname\n                                             ));\n                                 return None;\n                             }\n@@ -600,7 +599,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    &extnamestr));\n+                                    extname));\n                         None\n                     }\n                 }\n@@ -712,19 +711,18 @@ pub fn expand_item_mac(it: P<ast::Item>,\n             node: MacInvocTT(ref pth, ref tts, _),\n             ..\n         }) => {\n-            (pth.segments[0].identifier, pth.span, (*tts).clone())\n+            (pth.segments[0].identifier.name, pth.span, (*tts).clone())\n         }\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n     let items = {\n-        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n+        let expanded = match fld.cx.syntax_env.find(&extname) {\n             None => {\n                 fld.cx.span_err(path_span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr));\n+                                        extname));\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -735,14 +733,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         fld.cx\n                             .span_err(path_span,\n                                       &format!(\"macro {}! expects no ident argument, given '{}'\",\n-                                               extnamestr,\n-                                               token::get_ident(it.ident)));\n+                                               extname,\n+                                               it.ident));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.to_string(),\n+                            name: extname.to_string(),\n                             format: MacroBang,\n                             span: span,\n                             allow_internal_unstable: allow_internal_unstable,\n@@ -756,13 +754,13 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                &extnamestr));\n+                                                extname));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.to_string(),\n+                            name: extname.to_string(),\n                             format: MacroBang,\n                             span: span,\n                             allow_internal_unstable: allow_internal_unstable,\n@@ -783,7 +781,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.to_string(),\n+                            name: extname.to_string(),\n                             format: MacroBang,\n                             span: None,\n                             // `macro_rules!` doesn't directly allow\n@@ -828,7 +826,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            &extnamestr));\n+                                            extname));\n                     return SmallVector::zero();\n                 }\n             }\n@@ -847,7 +845,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    &extnamestr));\n+                                    extname));\n             return SmallVector::zero();\n         }\n     };\n@@ -1096,13 +1094,12 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }\n-        let extname = pth.segments[0].identifier;\n-        let extnamestr = token::get_ident(extname);\n-        let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n+        let extname = pth.segments[0].identifier.name;\n+        let marked_after = match fld.cx.syntax_env.find(&extname) {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr));\n+                                        extname));\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -1112,7 +1109,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.to_string(),\n+                            name: extname.to_string(),\n                             format: MacroBang,\n                             span: tt_span,\n                             allow_internal_unstable: allow_internal_unstable,\n@@ -1132,7 +1129,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 pth.span,\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n-                                    &extnamestr\n+                                    extname\n                                     )\n                             );\n                             return DummyResult::raw_pat(span);\n@@ -1145,7 +1142,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            &extnamestr));\n+                                            extname));\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -2121,8 +2118,7 @@ mod tests {\n                         = varref.segments.iter().map(|s| s.identifier)\n                         .collect();\n                     println!(\"varref #{}: {:?}, resolves to {}\",idx, varref_idents, varref_name);\n-                    let string = token::get_ident(final_varref_ident);\n-                    println!(\"varref's first segment's string: \\\"{}\\\"\", &string[..]);\n+                    println!(\"varref's first segment's string: \\\"{}\\\"\", final_varref_ident);\n                     println!(\"binding #{}: {}, resolves to {}\",\n                              binding_idx, bindings[binding_idx], binding_name);\n                     mtwt::with_sctable(|x| mtwt::display_sctable(x));\n@@ -2174,11 +2170,7 @@ foo_module!();\n         // find the xx binding\n         let bindings = crate_bindings(&cr);\n         let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| {\n-                let ident = token::get_ident(**b);\n-                let string = &ident[..];\n-                \"xx\" == string\n-            }).collect();\n+            bindings.iter().filter(|b| b.name == \"xx\").collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[..];\n         let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n             (1, Some(b)) => *b,\n@@ -2190,7 +2182,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == &*token::get_ident(p.segments[0].identifier)\n+            && p.segments[0].identifier.name == \"xx\"\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "5a2b9c0eea4d059013d456e29e2de5029b85adcb", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -121,8 +121,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     return None;\n                 }\n             };\n-            let interned_name = token::get_ident(ident);\n-            let name = &interned_name[..];\n+            let name: &str = &ident.name.as_str();\n \n             panictry!(p.expect(&token::Eq));\n             let e = p.parse_expr();"}, {"sha": "b8168297190562b611cc573559f11bcb511640d8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -407,7 +407,7 @@ fn id_ext(str: &str) -> ast::Ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, token::get_ident(ident));\n+    let e_str = cx.expr_str(sp, ident.name.as_str());\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n@@ -416,7 +416,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n \n // Lift a name to the expr that evaluates to that name\n fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, token::get_ident(ident));\n+    let e_str = cx.expr_str(sp, ident.name.as_str());\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),"}, {"sha": "8da36b2c1e1f6c05ea3b0581d56859e6e4c5822d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -76,7 +76,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n-                   .map(|x| token::get_ident(*x).to_string())\n+                   .map(|x| x.to_string())\n                    .collect::<Vec<String>>()\n                    .join(\"::\");\n     base::MacEager::expr(cx.expr_str("}, {"sha": "4556bd5f8e590b842fe837d1026b09ec8b287f29", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -223,11 +223,10 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         *idx += 1;\n                     }\n                     Occupied(..) => {\n-                        let string = token::get_ident(bind_name);\n                         panic!(p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               &string)))\n+                                               bind_name)))\n                     }\n                 }\n             }\n@@ -460,9 +459,7 @@ pub fn parse(sess: &ParseSess,\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n                       TtToken(_, MatchNt(bind, name, _, _)) => {\n-                        (format!(\"{} ('{}')\",\n-                                token::get_ident(name),\n-                                token::get_ident(bind))).to_string()\n+                        format!(\"{} ('{}')\", name, bind)\n                       }\n                       _ => panic!()\n                     } }).collect::<Vec<String>>().join(\" or \");\n@@ -484,11 +481,10 @@ pub fn parse(sess: &ParseSess,\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.top_elts.get_tt(ei.idx) {\n-                  TtToken(span, MatchNt(_, name, _, _)) => {\n-                    let name_string = token::get_ident(name);\n+                  TtToken(span, MatchNt(_, ident, _, _)) => {\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, span, &name_string))));\n+                        parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n                     ei.idx += 1;\n                     ei.match_cur += 1;\n                   }"}, {"sha": "adc88c329a31731e00093645bb1df3ec7fba8757", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -56,10 +56,9 @@ impl<'a> ParserAnyMacro<'a> {\n             let span = parser.span;\n             parser.span_err(span, &msg[..]);\n \n-            let name = token::get_ident(self.macro_ident);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}` is likely invalid in this context\",\n-                               name);\n+                               self.macro_ident);\n             parser.span_note(self.site_span, &msg[..]);\n         }\n     }\n@@ -154,7 +153,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n         println!(\"{}! {{ {} }}\",\n-                 token::get_ident(name),\n+                 name,\n                  print::pprust::tts_to_string(arg));\n     }\n \n@@ -326,7 +325,7 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n             TtToken(sp, MatchNt(ref name, ref frag_spec, _, _)) => {\n                 // ii. If T is a simple NT, look ahead to the next token T' in\n                 // M. If T' is in the set FOLLOW(NT), continue. Else; reject.\n-                if can_be_followed_by_any(frag_spec.as_str()) {\n+                if can_be_followed_by_any(&frag_spec.name.as_str()) {\n                     continue\n                 } else {\n                     let next_token = match tokens.peek() {\n@@ -340,13 +339,13 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                             // possibility that the sequence occurred\n                             // zero times (in which case we need to\n                             // look at the token that follows the\n-                            // sequence, which may itself a sequence,\n+                            // sequence, which may itself be a sequence,\n                             // and so on).\n                             cx.span_err(sp,\n                                         &format!(\"`${0}:{1}` is followed by a \\\n                                                   sequence repetition, which is not \\\n                                                   allowed for `{1}` fragments\",\n-                                                 name.as_str(), frag_spec.as_str())\n+                                                 name, frag_spec)\n                                         );\n                             Eof\n                         },\n@@ -359,7 +358,7 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                     let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n \n                     // If T' is in the set FOLLOW(NT), continue. Else, reject.\n-                    match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n+                    match (&next_token, is_in_follow(cx, &next_token, &frag_spec.name.as_str())) {\n                         (_, Err(msg)) => {\n                             cx.span_err(sp, &msg);\n                             continue\n@@ -369,7 +368,7 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                         (next, Ok(false)) => {\n                             cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n                                                       is not allowed for `{1}` fragments\",\n-                                                     name.as_str(), frag_spec.as_str(),\n+                                                     name, frag_spec,\n                                                      token_to_string(next)));\n                             continue\n                         },\n@@ -495,14 +494,14 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq => Ok(true),\n-                    Ident(i, _) if i.as_str() == \"if\" || i.as_str() == \"in\" => Ok(true),\n+                    Ident(i, _) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     Comma | FatArrow | Colon | Eq | Gt | Semi => Ok(true),\n-                    Ident(i, _) if i.as_str() == \"as\" => Ok(true),\n+                    Ident(i, _) if i.name == \"as\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "0ca755c97b1582e212341262136a2c77855f7615", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -140,11 +140,9 @@ impl Add for LockstepIterSize {\n                 LisContradiction(_) => other,\n                 LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n                 LisConstraint(r_len, r_id) => {\n-                    let l_n = token::get_ident(l_id.clone());\n-                    let r_n = token::get_ident(r_id);\n                     LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                              '{:?}' has {} items, but '{:?}' has {}\",\n-                                              l_n, l_len, r_n, r_len).to_string())\n+                                              '{}' has {} items, but '{}' has {}\",\n+                                              l_id, l_len, r_id, r_len))\n                 }\n             },\n         }\n@@ -308,8 +306,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             MatchedSeq(..) => {\n                                 panic!(r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n-                                    &format!(\"variable '{:?}' is still repeating at this depth\",\n-                                            token::get_ident(ident))));\n+                                    &format!(\"variable '{}' is still repeating at this depth\",\n+                                            ident)));\n                             }\n                         }\n                     }"}, {"sha": "53b57cdfaa1ad4f50bd8625fa9cfe4c2a281b0ff", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -582,7 +582,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        if !token::get_name(name).is_ascii() {\n+        if !name.as_str().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }"}, {"sha": "70da512e898854c0927a98b91ef51547d73da611", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -15,6 +15,7 @@ use codemap::{self, Span, CodeMap, FileMap};\n use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n+use parse::token::InternedString;\n use ptr::P;\n use str::char_at;\n \n@@ -439,7 +440,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n                       sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    match suffix {\n+    match suffix.as_ref().map(|s| &**s) {\n         Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n         Some(\"f64\") => ast::LitFloat(data, ast::TyF64),\n         Some(suf) => {\n@@ -457,12 +458,13 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n         None => ast::LitFloatUnsuffixed(data)\n     }\n }\n-pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+pub fn float_lit(s: &str, suffix: Option<InternedString>,\n+                 sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let data = token::intern_and_get_ident(&*s);\n-    filtered_float_lit(data, suffix, sd, sp)\n+    let data = token::intern_and_get_ident(&s);\n+    filtered_float_lit(data, suffix.as_ref().map(|s| &**s), sd, sp)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -557,7 +559,11 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+pub fn integer_lit(s: &str,\n+                   suffix: Option<InternedString>,\n+                   sd: &SpanHandler,\n+                   sp: Span)\n+                   -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -579,27 +585,26 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     }\n \n     // 1f64 and 2f32 etc. are valid float literals.\n-    match suffix {\n-        Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n+    if let Some(ref suf) = suffix {\n+        if looks_like_width_suffix(&['f'], suf) {\n             match base {\n                 16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n                 8 => sd.span_err(sp, \"octal float literal is not supported\"),\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n             let ident = token::intern_and_get_ident(&*s);\n-            return filtered_float_lit(ident, suffix, sd, sp)\n+            return filtered_float_lit(ident, Some(&**suf), sd, sp)\n         }\n-        _ => {}\n     }\n \n     if base != 10 {\n         s = &s[2..];\n     }\n \n-    if let Some(suf) = suffix {\n+    if let Some(ref suf) = suffix {\n         if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n-        ty = match suf {\n+        ty = match &**suf {\n             \"isize\" => ast::SignedIntLit(ast::TyIs, ast::Plus),\n             \"i8\"  => ast::SignedIntLit(ast::TyI8, ast::Plus),\n             \"i16\" => ast::SignedIntLit(ast::TyI16, ast::Plus),\n@@ -739,8 +744,8 @@ mod tests {\n                 Some(&ast::TtToken(_, token::Ident(name_zip, token::Plain))),\n                 Some(&ast::TtDelimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.as_str() == \"macro_rules\"\n-            && name_zip.as_str() == \"zip\" => {\n+            if name_macro_rules.name == \"macro_rules\"\n+            && name_zip.name == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -755,21 +760,21 @@ mod tests {\n                             (\n                                 2,\n                                 Some(&ast::TtToken(_, token::Dollar)),\n-                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                                Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if first_delimed.delim == token::Paren\n-                            && name.as_str() == \"a\" => {},\n+                            && ident.name == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n                         match (tts.len(), tts.get(0), tts.get(1)) {\n                             (\n                                 2,\n                                 Some(&ast::TtToken(_, token::Dollar)),\n-                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                                Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && name.as_str() == \"a\" => {},\n+                            && ident.name == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },"}, {"sha": "5a72477d4ac7eb9cdecbb2e832e0a39291b311b6", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -92,10 +92,8 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n         match self.token {\n-            token::Ident(sid, _) => {\n-                token::get_ident(sid) == ident\n-            }\n-            _ => false\n+            token::Ident(sid, _) => sid.name == ident,\n+            _ => false,\n         }\n     }\n "}, {"sha": "2cae6a4be6520e74247ee3c8e2f77a5debb9046c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -288,7 +288,7 @@ impl TokenType {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n             TokenType::Operator => \"an operator\".to_string(),\n-            TokenType::Keyword(kw) => format!(\"`{}`\", token::get_name(kw.to_name())),\n+            TokenType::Keyword(kw) => format!(\"`{}`\", kw.to_name()),\n         }\n     }\n }\n@@ -1023,7 +1023,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n-        token::get_ident(id)\n+        id.name.as_str()\n     }\n \n     /// Is the current token one of the keywords that signals a bare function\n@@ -1498,41 +1498,41 @@ impl<'a> Parser<'a> {\n             }\n             token::Literal(lit, suf) => {\n                 let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).0)),\n-                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).0)),\n+                    token::Byte(i) => (true, LitByte(parse::byte_lit(&i.as_str()).0)),\n+                    token::Char(i) => (true, LitChar(parse::char_lit(&i.as_str()).0)),\n \n                     // there are some valid suffixes for integer and\n                     // float literals, so all the handling is done\n                     // internally.\n                     token::Integer(s) => {\n-                        (false, parse::integer_lit(s.as_str(),\n+                        (false, parse::integer_lit(&s.as_str(),\n                                                    suf.as_ref().map(|s| s.as_str()),\n                                                    &self.sess.span_diagnostic,\n                                                    self.last_span))\n                     }\n                     token::Float(s) => {\n-                        (false, parse::float_lit(s.as_str(),\n+                        (false, parse::float_lit(&s.as_str(),\n                                                  suf.as_ref().map(|s| s.as_str()),\n                                                   &self.sess.span_diagnostic,\n                                                  self.last_span))\n                     }\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(&parse::str_lit(s.as_str())),\n+                         LitStr(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n                                 ast::CookedStr))\n                     }\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitStr(\n-                            token::intern_and_get_ident(&parse::raw_str_lit(s.as_str())),\n+                            token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n                             ast::RawStr(n)))\n                     }\n                     token::Binary(i) =>\n-                        (true, LitBinary(parse::binary_lit(i.as_str()))),\n+                        (true, LitBinary(parse::binary_lit(&i.as_str()))),\n                     token::BinaryRaw(i, _) =>\n                         (true,\n-                         LitBinary(Rc::new(i.as_str().as_bytes().iter().cloned().collect()))),\n+                         LitBinary(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -2448,7 +2448,7 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::SubstNt(name, _) =>\n                     return Err(self.fatal(&format!(\"unknown macro variable `{}`\",\n-                                       token::get_ident(name)))),\n+                                       name))),\n                 _ => {}\n             }\n         }\n@@ -4736,7 +4736,7 @@ impl<'a> Parser<'a> {\n             if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))));\n+                    class_name)));\n             }\n \n             try!(self.bump());\n@@ -4775,7 +4775,7 @@ impl<'a> Parser<'a> {\n             if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))));\n+                    class_name)));\n             }\n \n             generics.where_clause = try!(self.parse_where_clause());\n@@ -4920,8 +4920,7 @@ impl<'a> Parser<'a> {\n     /// Returns either a path to a module, or .\n     pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath\n     {\n-        let mod_string = token::get_ident(id);\n-        let mod_name = mod_string.to_string();\n+        let mod_name = id.to_string();\n         let default_path_str = format!(\"{}.rs\", mod_name);\n         let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n         let default_path = dir_path.join(&default_path_str);\n@@ -5009,7 +5008,7 @@ impl<'a> Parser<'a> {\n \n         self.eval_src_mod_from_path(path,\n                                     owns_directory,\n-                                    token::get_ident(id).to_string(),\n+                                    id.to_string(),\n                                     id_sp)\n     }\n \n@@ -5213,7 +5212,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(start_span,\n                         &format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\",\n-                                token::get_ident(ident)));\n+                                ident));\n                 }\n                 kind = StructVariantKind(struct_def);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -5281,8 +5280,7 @@ impl<'a> Parser<'a> {\n                 let sp = self.span;\n                 self.expect_no_suffix(sp, \"ABI spec\", suf);\n                 try!(self.bump());\n-                let the_string = s.as_str();\n-                match abi::lookup(the_string) {\n+                match abi::lookup(&s.as_str()) {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n                         let last_span = self.last_span;\n@@ -5291,7 +5289,7 @@ impl<'a> Parser<'a> {\n                             &format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().join(\", \"),\n-                                    the_string));\n+                                    s));\n                         Ok(None)\n                     }\n                 }"}, {"sha": "bd479255438153e09759fba7245a42174f22706d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -647,6 +647,12 @@ impl InternedString {\n             string: string,\n         }\n     }\n+\n+    #[inline]\n+    pub fn new_from_name(name: ast::Name) -> InternedString {\n+        let interner = get_ident_interner();\n+        InternedString::new_from_rc_str(interner.get(name))\n+    }\n }\n \n impl Deref for InternedString {\n@@ -678,7 +684,7 @@ impl<'a> PartialEq<&'a str> for InternedString {\n     }\n }\n \n-impl<'a> PartialEq<InternedString > for &'a str {\n+impl<'a> PartialEq<InternedString> for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n         PartialEq::eq(*self, &other.string[..])\n@@ -691,7 +697,7 @@ impl<'a> PartialEq<InternedString > for &'a str {\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[..])))\n+        Ok(intern(try!(d.read_str()).as_ref()).as_str())\n     }\n }\n \n@@ -701,25 +707,11 @@ impl Encodable for InternedString {\n     }\n }\n \n-/// Returns the string contents of a name, using the thread-local interner.\n-#[inline]\n-pub fn get_name(name: ast::Name) -> InternedString {\n-    let interner = get_ident_interner();\n-    InternedString::new_from_rc_str(interner.get(name))\n-}\n-\n-/// Returns the string contents of an identifier, using the thread-local\n-/// interner.\n-#[inline]\n-pub fn get_ident(ident: ast::Ident) -> InternedString {\n-    get_name(ident.name)\n-}\n-\n /// Interns and returns the string contents of an identifier, using the\n /// thread-local interner.\n #[inline]\n pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    get_name(intern(s))\n+    intern(s).as_str()\n }\n \n /// Maps a string to its interned representation."}, {"sha": "6cfe85bc37e8171324258cbcda76f322457931f9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -251,40 +251,40 @@ pub fn token_to_string(tok: &Token) -> String {\n         /* Literals */\n         token::Literal(lit, suf) => {\n             let mut out = match lit {\n-                token::Byte(b)           => format!(\"b'{}'\", b.as_str()),\n-                token::Char(c)           => format!(\"'{}'\", c.as_str()),\n-                token::Float(c)          => c.as_str().to_string(),\n-                token::Integer(c)        => c.as_str().to_string(),\n-                token::Str_(s)           => format!(\"\\\"{}\\\"\", s.as_str()),\n+                token::Byte(b)           => format!(\"b'{}'\", b),\n+                token::Char(c)           => format!(\"'{}'\", c),\n+                token::Float(c)          => c.to_string(),\n+                token::Integer(c)        => c.to_string(),\n+                token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n                 token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                                                     delim=repeat(\"#\", n),\n-                                                    string=s.as_str()),\n-                token::Binary(v)         => format!(\"b\\\"{}\\\"\", v.as_str()),\n+                                                    string=s),\n+                token::Binary(v)         => format!(\"b\\\"{}\\\"\", v),\n                 token::BinaryRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n                                                     delim=repeat(\"#\", n),\n-                                                    string=s.as_str()),\n+                                                    string=s),\n             };\n \n             if let Some(s) = suf {\n-                out.push_str(s.as_str())\n+                out.push_str(&s.as_str())\n             }\n \n             out\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => token::get_ident(s).to_string(),\n-        token::Lifetime(s)          => format!(\"{}\", token::get_ident(s)),\n+        token::Ident(s, _)          => s.to_string(),\n+        token::Lifetime(s)          => s.to_string(),\n         token::Underscore           => \"_\".to_string(),\n \n         /* Other */\n-        token::DocComment(s)        => s.as_str().to_string(),\n+        token::DocComment(s)        => s.to_string(),\n         token::SubstNt(s, _)        => format!(\"${}\", s),\n         token::MatchNt(s, t, _, _)  => format!(\"${}:{}\", s, t),\n         token::Eof                  => \"<eof>\".to_string(),\n         token::Whitespace           => \" \".to_string(),\n         token::Comment              => \"/* */\".to_string(),\n-        token::Shebang(s)           => format!(\"/* shebang: {}*/\", s.as_str()),\n+        token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n         token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n \n@@ -819,7 +819,7 @@ impl<'a> State<'a> {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")));\n                 if let Some(p) = *optional_path {\n-                    let val = token::get_name(p);\n+                    let val = p.as_str();\n                     if val.contains(\"-\") {\n                         try!(self.print_string(&val, ast::CookedStr));\n                     } else {\n@@ -2009,7 +2009,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n-        try!(word(&mut self.s, &token::get_ident(ident)));\n+        try!(word(&mut self.s, &ident.name.as_str()));\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n@@ -2018,7 +2018,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        try!(word(&mut self.s, &token::get_name(name)));\n+        try!(word(&mut self.s, &name.as_str()));\n         self.ann.post(self, NodeName(&name))\n     }\n "}, {"sha": "9787f2537c6b5e825e3fbeef0fa6907f3ba68036", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -160,8 +160,7 @@ impl fold::Folder for PreludeInjector {\n                     style: ast::AttrOuter,\n                     value: P(ast::MetaItem {\n                         span: self.span,\n-                        node: ast::MetaWord(token::get_name(\n-                                special_idents::prelude_import.name)),\n+                        node: ast::MetaWord(special_idents::prelude_import.name.as_str()),\n                     }),\n                     is_sugared_doc: false,\n                 },"}, {"sha": "11de43a6b92afea3d3ec756eb8e53ab36aaf747f", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -20,7 +20,6 @@ extern crate syntax;\n extern crate rustc;\n \n use syntax::ast;\n-use syntax::parse::token;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n@@ -36,11 +35,10 @@ impl LintPass for Pass {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let name = token::get_ident(it.ident);\n-        if &name[..] == \"lintme\" {\n-            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n-        } else if &name[..] == \"pleaselintme\" {\n-            cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\");\n+        match &*it.ident.name.as_str() {\n+            \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n+            \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n+            _ => {}\n         }\n     }\n }"}, {"sha": "967b168d000786b14bbac6924a566f1a8e4f5041", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -20,7 +20,6 @@ extern crate syntax;\n extern crate rustc;\n \n use syntax::ast;\n-use syntax::parse::token;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n@@ -34,8 +33,7 @@ impl LintPass for Pass {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let name = token::get_ident(it.ident);\n-        if &name[..] == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "e6f375354aa3a1a989650c655da8303e9fc24c08", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ede7ed8e4f3752c371f7d04da4695ba9aa1c26/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=55ede7ed8e4f3752c371f7d04da4695ba9aa1c26", "patch": "@@ -18,8 +18,8 @@ extern crate syntax;\n extern crate rustc;\n \n use syntax::codemap::Span;\n-use syntax::parse::token;\n use syntax::ast::{TokenTree, TtToken};\n+use syntax::parse::token;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n use rustc::plugin::Registry;\n@@ -40,7 +40,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         (\"I\",    1)];\n \n     let text = match args {\n-        [TtToken(_, token::Ident(s, _))] => token::get_ident(s).to_string(),\n+        [TtToken(_, token::Ident(s, _))] => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);"}]}