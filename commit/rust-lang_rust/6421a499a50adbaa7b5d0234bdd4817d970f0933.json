{"sha": "6421a499a50adbaa7b5d0234bdd4817d970f0933", "node_id": "C_kwDOAAsO6NoAKDY0MjFhNDk5YTUwYWRiYWE3YjVkMDIzNGJkZDQ4MTdkOTcwZjA5MzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T09:32:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T09:32:03Z"}, "message": "Auto merge of #93176 - danielhenrymantilla:stack-pinning-macro, r=m-ou-se\n\nAdd a stack-`pin!`-ning macro to `core::pin`.\n\n  - https://github.com/rust-lang/rust/issues/93178\n\n`pin!` allows pinning a value to the stack. Thanks to being implemented in the stdlib, which gives access to `macro` macros, and to the private `.pointer` field of the `Pin` wrapper, [it was recently discovered](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/pin!.20.E2.80.94.20the.20.22definitive.22.20edition.20.28a.20rhs-compatible.20pin-nin.2E.2E.2E/near/268731241) ([archive link](https://zulip-archive.rust-lang.org/stream/187312-wg-async-foundations/topic/A.20rhs-compatible.20pin-ning.20macro.html#268731241)), contrary to popular belief, that it is actually possible to implement and feature such a macro:\n\n```rust\nlet foo: Pin<&mut PhantomPinned> = pin!(PhantomPinned);\nstuff(foo);\n```\nor, directly:\n\n```rust\nstuff(pin!(PhantomPinned));\n```\n\n  - For context, historically, this used to require one of the two following syntaxes:\n\n      - ```rust\n        let foo = PhantomPinned;\n        pin!(foo);\n        stuff(foo);\n        ```\n\n      -  ```rust\n         pin! {\n             let foo = PhantomPinned;\n         }\n         stuff(foo);\n         ```\n\nThis macro thus allows, for instance, doing things like:\n\n```diff\nfn block_on<T>(fut: impl Future<Output = T>) -> T {\n    // Pin the future so it can be polled.\n-   let mut fut = Box::pin(fut);\n+   let mut fut = pin!(fut);\n\n    // Create a new context to be passed to the future.\n    let t = thread::current();\n    let waker = Arc::new(ThreadWaker(t)).into();\n    let mut cx = Context::from_waker(&waker);\n\n    // Run the future to completion.\n    loop {\n        match fut.as_mut().poll(&mut cx) {\n            Poll::Ready(res) => return res,\n            Poll::Pending => thread::park(),\n        }\n    }\n}\n```\n\n  - _c.f._, https://doc.rust-lang.org/1.58.1/alloc/task/trait.Wake.html\n\nAnd so on, and so forth.\n\nI don't think such an API can get better than that, barring full featured language support (`&pin` references or something), so I see no reason not to start experimenting with featuring this in the stdlib already \ud83d\ude42\n\n  - cc `@rust-lang/wg-async-foundations` \\[EDIT: this doesn't seem to have pinged anybody \ud83d\ude29, thanks `@yoshuawuyts` for the real ping\\]\n\nr? `@joshtriplett`\n\n___\n\n# Docs preview\n\nhttps://user-images.githubusercontent.com/9920355/150605731-1f45c2eb-c9b0-4ce3-b17f-2784fb75786e.mp4\n\n___\n\n# Implementation\n\nThe implementation ends up being dead simple (so much it's embarrassing):\n\n```rust\npub macro pin($value:expr $(,)?) {\n    Pin { pointer: &mut { $value } }\n}\n```\n\n_and voil\u00e0_!\n\n  - The key for it working lies in [the rules governing the scope of anonymous temporaries](https://doc.rust-lang.org/1.58.1/reference/destructors.html#temporary-lifetime-extension).\n\n<details><summary>Comments and context</summary>\n\nThis is `Pin::new_unchecked(&mut { $value })`, so, for starters, let's\nreview such a hypothetical macro (that any user-code could define):\n```rust\nmacro_rules! pin {( $value:expr ) => (\n    match &mut { $value } { at_value => unsafe { // Do not wrap `$value` in an `unsafe` block.\n        $crate::pin::Pin::<&mut _>::new_unchecked(at_value)\n    }}\n)}\n```\n\nSafety:\n  - `type P = &mut _`. There are thus no pathological `Deref{,Mut}` impls that would break `Pin`'s invariants.\n  - `{ $value }` is braced, making it a _block expression_, thus **moving** the given `$value`, and making it _become an **anonymous** temporary_.\n    By virtue of being anonynomous, it can no longer be accessed, thus preventing any attemps to `mem::replace` it or `mem::forget` it, _etc._\n\nThis gives us a `pin!` definition that is sound, and which works, but only in certain scenarios:\n\n  - If the `pin!(value)` expression is _directly_ fed to a function call:\n    `let poll = pin!(fut).poll(cx);`\n\n  - If the `pin!(value)` expression is part of a scrutinee:\n\n    ```rust\n    match pin!(fut) { pinned_fut => {\n        pinned_fut.as_mut().poll(...);\n        pinned_fut.as_mut().poll(...);\n    }} // <- `fut` is dropped here.\n    ```\n\nAlas, it doesn't work for the more straight-forward use-case: `let` bindings.\n\n```rust\nlet pinned_fut = pin!(fut); // <- temporary value is freed at the end of this statement\npinned_fut.poll(...) // error[E0716]: temporary value dropped while borrowed\n                     // note: consider using a `let` binding to create a longer lived value\n```\n\n  - Issues such as this one are the ones motivating https://github.com/rust-lang/rfcs/pull/66\n\nThis makes such a macro incredibly unergonomic in practice, and the reason most macros out there had to take the path of being a statement/binding macro (_e.g._, `pin!(future);`) instead of featuring the more intuitive ergonomics of an expression macro.\n\nLuckily, there is a way to avoid the problem. Indeed, the problem stems from the fact that a temporary is dropped at the end of its enclosing statement when it is part of the parameters given to function call, which has precisely been the case with our `Pin::new_unchecked()`!\n\nFor instance,\n\n```rust\nlet p = Pin::new_unchecked(&mut <temporary>);\n```\n\nbecomes:\n\n```rust\nlet p = { let mut anon = <temporary>; &mut anon };\n```\n\nHowever, when using a literal braced struct to construct the value, references to temporaries can then be taken. This makes Rust change the lifespan of such temporaries so that they are, instead, dropped _at the end of the enscoping block_.\n\nFor instance,\n```rust\nlet p = Pin { pointer: &mut <temporary> };\n```\n\nbecomes:\n\n```rust\nlet mut anon = <temporary>;\nlet p = Pin { pointer: &mut anon };\n```\n\nwhich is *exactly* what we want.\n\nFinally, we don't hit problems _w.r.t._ the privacy of the `pointer` field, or the unqualified `Pin` name, thanks to `decl_macro`s being _fully_ hygienic (`def_site` hygiene).\n\n</details>\n\n___\n\n# TODO\n\n  - [x] Add compile-fail tests with attempts to break the `Pin` invariants thanks to the macro (_e.g._, try to access the private `.pointer` field, or see what happens if such a pin is used outside its enscoping scope (borrow error));\n  - [ ] Follow-up stuff:\n      - [ ] Try to experiment with adding `pin!` to the prelude: this may require to be handled with some extra care, as it may lead to issues reminiscent of those of `assert_matches!`: https://github.com/rust-lang/rust/issues/82913\n      - [x] Create the tracking issue.", "tree": {"sha": "b52aead74a0b84eb9047223a3dbec2d5622f485f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52aead74a0b84eb9047223a3dbec2d5622f485f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6421a499a50adbaa7b5d0234bdd4817d970f0933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6421a499a50adbaa7b5d0234bdd4817d970f0933", "html_url": "https://github.com/rust-lang/rust/commit/6421a499a50adbaa7b5d0234bdd4817d970f0933", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6421a499a50adbaa7b5d0234bdd4817d970f0933/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6655109f58b7d0f4cae7e04eab476e389c9b9a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6655109f58b7d0f4cae7e04eab476e389c9b9a0f", "html_url": "https://github.com/rust-lang/rust/commit/6655109f58b7d0f4cae7e04eab476e389c9b9a0f"}, {"sha": "bf2a9dc3750a69ec952be6eec75cb312a15c94b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2a9dc3750a69ec952be6eec75cb312a15c94b1", "html_url": "https://github.com/rust-lang/rust/commit/bf2a9dc3750a69ec952be6eec75cb312a15c94b1"}], "stats": {"total": 405, "additions": 404, "deletions": 1}, "files": [{"sha": "6b952e5aef13e9dd1811f17fddd3e025697fa771", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -161,6 +161,9 @@ declare_features! (\n     (active, staged_api, \"1.0.0\", None, None),\n     /// Added for testing E0705; perma-unstable.\n     (active, test_2018_feature, \"1.31.0\", None, Some(Edition::Edition2018)),\n+    /// Allows non-`unsafe` \u2014and thus, unsound\u2014 access to `Pin` constructions.\n+    /// Marked `incomplete` since perma-unstable and unsound.\n+    (incomplete, unsafe_pin_internals, \"1.60.0\", None, None),\n     /// Use for stable + negative coherence and strict coherence depending on trait's\n     /// rustc_strict_coherence value.\n     (active, with_negative_coherence, \"1.60.0\", None, None),"}, {"sha": "ebc0e72bba6ab6b23bf73a3ec303da7ca7a2a1b5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -1455,6 +1455,7 @@ symbols! {\n         unsafe_block_in_unsafe_fn,\n         unsafe_cell,\n         unsafe_no_drop_flag,\n+        unsafe_pin_internals,\n         unsize,\n         unsized_fn_params,\n         unsized_locals,"}, {"sha": "dec1b5270d58b559534c7472997539de55d44575", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 248, "deletions": 1, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -406,7 +406,14 @@ use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n #[repr(transparent)]\n #[derive(Copy, Clone)]\n pub struct Pin<P> {\n-    pointer: P,\n+    // FIXME(#93176): this field is made `#[unstable] #[doc(hidden)] pub` to:\n+    //   - deter downstream users from accessing it (which would be unsound!),\n+    //   - let the `pin!` macro access it (such a macro requires using struct\n+    //     literal syntax in order to benefit from lifetime extension).\n+    // Long-term, `unsafe` fields or macro hygiene are expected to offer more robust alternatives.\n+    #[unstable(feature = \"unsafe_pin_internals\", issue = \"none\")]\n+    #[doc(hidden)]\n+    pub pointer: P,\n }\n \n // The following implementations aren't derived in order to avoid soundness\n@@ -909,3 +916,243 @@ impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n+\n+/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning[^1] a `value: T` _locally_[^2].\n+///\n+/// Unlike [`Box::pin`], this does not involve a heap allocation.\n+///\n+/// [^1]: If the (type `T` of the) given value does not implement [`Unpin`], then this\n+/// effectively pins the `value` in memory, where it will be unable to be moved.\n+/// Otherwise, <code>[Pin]<[&mut] T></code> behaves like <code>[&mut] T</code>, and operations such\n+/// as [`mem::replace()`][crate::mem::replace] will allow extracting that value, and therefore,\n+/// moving it.\n+/// See [the `Unpin` section of the `pin` module][self#unpin] for more info.\n+///\n+/// [^2]: This is usually dubbed \"stack\"-pinning. And whilst local values are almost always located\n+/// in the stack (_e.g._, when within the body of a non-`async` function), the truth is that inside\n+/// the body of an `async fn` or block \u2014more generally, the body of a generator\u2014 any locals crossing\n+/// an `.await` point \u2014a `yield` point\u2014 end up being part of the state captured by the `Future` \u2014by\n+/// the `Generator`\u2014, and thus will be stored wherever that one is.\n+///\n+/// ## Examples\n+///\n+/// ### Basic usage\n+///\n+/// ```rust\n+/// #![feature(pin_macro)]\n+/// # use core::marker::PhantomPinned as Foo;\n+/// use core::pin::{pin, Pin};\n+///\n+/// fn stuff(foo: Pin<&mut Foo>) {\n+///     // \u2026\n+///     # let _ = foo;\n+/// }\n+///\n+/// let pinned_foo = pin!(Foo { /* \u2026 */ });\n+/// stuff(pinned_foo);\n+/// // or, directly:\n+/// stuff(pin!(Foo { /* \u2026 */ }));\n+/// ```\n+///\n+/// ### Manually polling a `Future` (wihout `Unpin` bounds)\n+///\n+/// ```rust\n+/// #![feature(pin_macro)]\n+/// use std::{\n+///     future::Future,\n+///     pin::pin,\n+///     task::{Context, Poll},\n+///     thread,\n+/// };\n+/// # use std::{sync::Arc, task::Wake, thread::Thread};\n+///\n+/// # /// A waker that wakes up the current thread when called.\n+/// # struct ThreadWaker(Thread);\n+/// #\n+/// # impl Wake for ThreadWaker {\n+/// #     fn wake(self: Arc<Self>) {\n+/// #         self.0.unpark();\n+/// #     }\n+/// # }\n+/// #\n+/// /// Runs a future to completion.\n+/// fn block_on<Fut: Future>(fut: Fut) -> Fut::Output {\n+///     let waker_that_unparks_thread = // \u2026\n+///         # Arc::new(ThreadWaker(thread::current())).into();\n+///     let mut cx = Context::from_waker(&waker_that_unparks_thread);\n+///     // Pin the future so it can be polled.\n+///     let mut pinned_fut = pin!(fut);\n+///     loop {\n+///         match pinned_fut.as_mut().poll(&mut cx) {\n+///             Poll::Pending => thread::park(),\n+///             Poll::Ready(res) => return res,\n+///         }\n+///     }\n+/// }\n+/// #\n+/// # assert_eq!(42, block_on(async { 42 }));\n+/// ```\n+///\n+/// ### With `Generator`s\n+///\n+/// ```rust\n+/// #![feature(generators, generator_trait, pin_macro)]\n+/// use core::{\n+///     ops::{Generator, GeneratorState},\n+///     pin::pin,\n+/// };\n+///\n+/// fn generator_fn() -> impl Generator<Yield = usize, Return = ()> /* not Unpin */ {\n+///  // Allow generator to be self-referential (not `Unpin`)\n+///  // vvvvvv        so that locals can cross yield points.\n+///     static || {\n+///         let foo = String::from(\"foo\"); // --+\n+///         yield 0;                         // | <- crosses yield point!\n+///         println!(\"{}\", &foo); // <----------+\n+///         yield foo.len();\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut generator = pin!(generator_fn());\n+///     match generator.as_mut().resume(()) {\n+///         GeneratorState::Yielded(0) => {},\n+///         _ => unreachable!(),\n+///     }\n+///     match generator.as_mut().resume(()) {\n+///         GeneratorState::Yielded(3) => {},\n+///         _ => unreachable!(),\n+///     }\n+///     match generator.resume(()) {\n+///         GeneratorState::Yielded(_) => unreachable!(),\n+///         GeneratorState::Complete(()) => {},\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Remarks\n+///\n+/// Precisely because a value is pinned to local storage, the resulting <code>[Pin]<[&mut] T></code>\n+/// reference ends up borrowing a local tied to that block: it can't escape it.\n+///\n+/// The following, for instance, fails to compile:\n+///\n+/// ```rust,compile_fail\n+/// #![feature(pin_macro)]\n+/// use core::pin::{pin, Pin};\n+/// # use core::{marker::PhantomPinned as Foo, mem::drop as stuff};\n+///\n+/// let x: Pin<&mut Foo> = {\n+///     let x: Pin<&mut Foo> = pin!(Foo { /* \u2026 */ });\n+///     x\n+/// }; // <- Foo is dropped\n+/// stuff(x); // Error: use of dropped value\n+/// ```\n+///\n+/// <details><summary>Error message</summary>\n+///\n+/// ```console\n+/// error[E0716]: temporary value dropped while borrowed\n+///   --> src/main.rs:9:28\n+///    |\n+/// 8  | let x: Pin<&mut Foo> = {\n+///    |     - borrow later stored here\n+/// 9  |     let x: Pin<&mut Foo> = pin!(Foo { /* \u2026 */ });\n+///    |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+/// 10 |     x\n+/// 11 | }; // <- Foo is dropped\n+///    | - temporary value is freed at the end of this statement\n+///    |\n+///    = note: consider using a `let` binding to create a longer lived value\n+/// ```\n+///\n+/// </details>\n+///\n+/// This makes [`pin!`] **unsuitable to pin values when intending to _return_ them**. Instead, the\n+/// value is expected to be passed around _unpinned_ until the point where it is to be consumed,\n+/// where it is then useful and even sensible to pin the value locally using [`pin!`].\n+///\n+/// If you really need to return a pinned value, consider using [`Box::pin`] instead.\n+///\n+/// On the other hand, pinning to the stack[<sup>2</sup>](#fn2) using [`pin!`] is likely to be\n+/// cheaper than pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n+/// even needing an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n+/// constructor.\n+///\n+/// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin\n+#[unstable(feature = \"pin_macro\", issue = \"93178\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[allow_internal_unstable(unsafe_pin_internals)]\n+pub macro pin($value:expr $(,)?) {\n+    // This is `Pin::new_unchecked(&mut { $value })`, so, for starters, let's\n+    // review such a hypothetical macro (that any user-code could define):\n+    //\n+    // ```rust\n+    // macro_rules! pin {( $value:expr ) => (\n+    //     match &mut { $value } { at_value => unsafe { // Do not wrap `$value` in an `unsafe` block.\n+    //         $crate::pin::Pin::<&mut _>::new_unchecked(at_value)\n+    //     }}\n+    // )}\n+    // ```\n+    //\n+    // Safety:\n+    //   - `type P = &mut _`. There are thus no pathological `Deref{,Mut}` impls\n+    //     that would break `Pin`'s invariants.\n+    //   - `{ $value }` is braced, making it a _block expression_, thus **moving**\n+    //     the given `$value`, and making it _become an **anonymous** temporary_.\n+    //     By virtue of being anonynomous, it can no longer be accessed, thus\n+    //     preventing any attemps to `mem::replace` it or `mem::forget` it, _etc._\n+    //\n+    // This gives us a `pin!` definition that is sound, and which works, but only\n+    // in certain scenarios:\n+    //   - If the `pin!(value)` expression is _directly_ fed to a function call:\n+    //     `let poll = pin!(fut).poll(cx);`\n+    //   - If the `pin!(value)` expression is part of a scrutinee:\n+    //     ```rust\n+    //     match pin!(fut) { pinned_fut => {\n+    //         pinned_fut.as_mut().poll(...);\n+    //         pinned_fut.as_mut().poll(...);\n+    //     }} // <- `fut` is dropped here.\n+    //     ```\n+    // Alas, it doesn't work for the more straight-forward use-case: `let` bindings.\n+    // ```rust\n+    // let pinned_fut = pin!(fut); // <- temporary value is freed at the end of this statement\n+    // pinned_fut.poll(...) // error[E0716]: temporary value dropped while borrowed\n+    //                      // note: consider using a `let` binding to create a longer lived value\n+    // ```\n+    //   - Issues such as this one are the ones motivating https://github.com/rust-lang/rfcs/pull/66\n+    //\n+    // This makes such a macro incredibly unergonomic in practice, and the reason most macros\n+    // out there had to take the path of being a statement/binding macro (_e.g._, `pin!(future);`)\n+    // instead of featuring the more intuitive ergonomics of an expression macro.\n+    //\n+    // Luckily, there is a way to avoid the problem. Indeed, the problem stems from the fact that a\n+    // temporary is dropped at the end of its enclosing statement when it is part of the parameters\n+    // given to function call, which has precisely been the case with our `Pin::new_unchecked()`!\n+    // For instance,\n+    // ```rust\n+    // let p = Pin::new_unchecked(&mut <temporary>);\n+    // ```\n+    // becomes:\n+    // ```rust\n+    // let p = { let mut anon = <temporary>; &mut anon };\n+    // ```\n+    //\n+    // However, when using a literal braced struct to construct the value, references to temporaries\n+    // can then be taken. This makes Rust change the lifespan of such temporaries so that they are,\n+    // instead, dropped _at the end of the enscoping block_.\n+    // For instance,\n+    // ```rust\n+    // let p = Pin { pointer: &mut <temporary> };\n+    // ```\n+    // becomes:\n+    // ```rust\n+    // let mut anon = <temporary>;\n+    // let p = Pin { pointer: &mut anon };\n+    // ```\n+    // which is *exactly* what we want.\n+    //\n+    // See https://doc.rust-lang.org/1.58.1/reference/destructors.html#temporary-lifetime-extension\n+    // for more info.\n+    $crate::pin::Pin::<&mut _> { pointer: &mut { $value } }\n+}"}, {"sha": "65be0c320c26f307290bc11b222357a1446a81ca", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -45,6 +45,7 @@\n #![feature(inline_const)]\n #![feature(is_sorted)]\n #![feature(pattern)]\n+#![feature(pin_macro)]\n #![feature(sort_internals)]\n #![feature(slice_take)]\n #![feature(maybe_uninit_uninit_array)]\n@@ -122,6 +123,7 @@ mod ops;\n mod option;\n mod pattern;\n mod pin;\n+mod pin_macro;\n mod ptr;\n mod result;\n mod simd;"}, {"sha": "79c8c166c58d9d8381ffb7cbbce5a1edeea987c5", "filename": "library/core/tests/pin_macro.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Ftests%2Fpin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/library%2Fcore%2Ftests%2Fpin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fpin_macro.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,33 @@\n+// edition:2021\n+use core::{\n+    marker::PhantomPinned,\n+    mem::{drop as stuff, transmute},\n+    pin::{pin, Pin},\n+};\n+\n+#[test]\n+fn basic() {\n+    let it: Pin<&mut PhantomPinned> = pin!(PhantomPinned);\n+    stuff(it);\n+}\n+\n+#[test]\n+fn extension_works_through_block() {\n+    let it: Pin<&mut PhantomPinned> = { pin!(PhantomPinned) };\n+    stuff(it);\n+}\n+\n+#[test]\n+fn extension_works_through_unsafe_block() {\n+    // \"retro-type-inference\" works as well.\n+    let it: Pin<&mut PhantomPinned> = unsafe { pin!(transmute(())) };\n+    stuff(it);\n+}\n+\n+#[test]\n+fn unsize_coercion() {\n+    let slice: Pin<&mut [PhantomPinned]> = pin!([PhantomPinned; 2]);\n+    stuff(slice);\n+    let dyn_obj: Pin<&mut dyn Send> = pin!([PhantomPinned; 2]);\n+    stuff(dyn_obj);\n+}"}, {"sha": "3915ee7dc5d23196249c8499452744471076cfbb", "filename": "src/test/rustdoc-js-std/typed-query.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Ftyped-query.js?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -8,5 +8,7 @@ const EXPECTED = {\n         { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'println' },\n         { 'path': 'std', 'name': 'eprintln' },\n+        { 'path': 'std::pin', 'name': 'pin' },\n+        { 'path': 'core::pin', 'name': 'pin' },\n     ],\n };"}, {"sha": "0680d234403047ed7d9a1c0a3f6dda1563e8624d", "filename": "src/test/ui/feature-gates/feature-gate-unsafe_pin_internals.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+#![forbid(incomplete_features, unsafe_code)]\n+#![feature(unsafe_pin_internals)]\n+//~^ ERROR the feature `unsafe_pin_internals` is incomplete and may not be safe to use\n+\n+use core::{marker::PhantomPinned, pin::Pin};\n+\n+/// The `unsafe_pin_internals` is indeed unsound.\n+fn non_unsafe_pin_new_unchecked<T>(pointer: &mut T) -> Pin<&mut T> {\n+    Pin { pointer }\n+}\n+\n+fn main() {\n+    let mut self_referential = PhantomPinned;\n+    let _: Pin<&mut PhantomPinned> = non_unsafe_pin_new_unchecked(&mut self_referential);\n+    core::mem::forget(self_referential); // move and disable drop glue!\n+}"}, {"sha": "4d0c931b404e6ed3a45af324da64b3f8468cf2d1", "filename": "src/test/ui/feature-gates/feature-gate-unsafe_pin_internals.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_pin_internals.stderr?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,14 @@\n+error: the feature `unsafe_pin_internals` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/feature-gate-unsafe_pin_internals.rs:3:12\n+   |\n+LL | #![feature(unsafe_pin_internals)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/feature-gate-unsafe_pin_internals.rs:2:11\n+   |\n+LL | #![forbid(incomplete_features, unsafe_code)]\n+   |           ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "120d08894f8f7b89a1b9ae8d371efeae12b26c63", "filename": "src/test/ui/pin-macro/cant_access_internals.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+#![feature(pin_macro)]\n+\n+use core::{\n+    marker::PhantomPinned,\n+    mem,\n+    pin::{pin, Pin},\n+};\n+\n+fn main() {\n+    let mut phantom_pinned = pin!(PhantomPinned);\n+    mem::take(phantom_pinned.pointer); //~ ERROR use of unstable library feature 'unsafe_pin_internals'\n+}"}, {"sha": "060c9c48c21c8640aa657325d3d7e90786674c90", "filename": "src/test/ui/pin-macro/cant_access_internals.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpin-macro%2Fcant_access_internals.stderr?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: use of unstable library feature 'unsafe_pin_internals'\n+  --> $DIR/cant_access_internals.rs:12:15\n+   |\n+LL |     mem::take(phantom_pinned.pointer);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(unsafe_pin_internals)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ca2b6cf759376af6e9a0e82113773b01066947c4", "filename": "src/test/ui/pin-macro/lifetime_errors_on_promotion_misusage.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,29 @@\n+// edition:2018\n+#![feature(pin_macro)]\n+\n+use core::{\n+    convert::identity,\n+    marker::PhantomPinned,\n+    mem::drop as stuff,\n+    pin::pin,\n+};\n+\n+fn function_call_stops_borrow_extension() {\n+    let phantom_pinned = identity(pin!(PhantomPinned));\n+    //~^ ERROR temporary value dropped while borrowed\n+    stuff(phantom_pinned)\n+}\n+\n+fn promotion_only_works_for_the_innermost_block() {\n+    let phantom_pinned = {\n+        let phantom_pinned = pin!(PhantomPinned);\n+        //~^ ERROR temporary value dropped while borrowed\n+        phantom_pinned\n+    };\n+    stuff(phantom_pinned)\n+}\n+\n+fn main() {\n+    function_call_stops_borrow_extension();\n+    promotion_only_works_for_the_innermost_block();\n+}"}, {"sha": "4971263af08ad1864f36a5dbf81bfecedd319411", "filename": "src/test/ui/pin-macro/lifetime_errors_on_promotion_misusage.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpin-macro%2Flifetime_errors_on_promotion_misusage.stderr?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -0,0 +1,31 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/lifetime_errors_on_promotion_misusage.rs:12:35\n+   |\n+LL |     let phantom_pinned = identity(pin!(PhantomPinned));\n+   |                                   ^^^^^^^^^^^^^^^^^^^ - temporary value is freed at the end of this statement\n+   |                                   |\n+   |                                   creates a temporary which is freed while still in use\n+LL |\n+LL |     stuff(phantom_pinned)\n+   |           -------------- borrow later used here\n+   |\n+   = note: consider using a `let` binding to create a longer lived value\n+   = note: this error originates in the macro `pin` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/lifetime_errors_on_promotion_misusage.rs:19:30\n+   |\n+LL |     let phantom_pinned = {\n+   |         -------------- borrow later stored here\n+LL |         let phantom_pinned = pin!(PhantomPinned);\n+   |                              ^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+...\n+LL |     };\n+   |     - temporary value is freed at the end of this statement\n+   |\n+   = note: consider using a `let` binding to create a longer lived value\n+   = note: this error originates in the macro `pin` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0716`."}]}