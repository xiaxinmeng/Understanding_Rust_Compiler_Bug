{"sha": "20213fcca420f6b6a0b8990a4647edad39148c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMjEzZmNjYTQyMGY2YjZhMGI4OTkwYTQ2NDdlZGFkMzkxNDhjMDc=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T02:46:23Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T23:37:59Z"}, "message": "A round of code cleaning for the primary scheduler code. Comments have been updated, a minor amount of support type restructing has happened, methods have been reordered, and some duplicate code has been purged.", "tree": {"sha": "30a4f20a9026ff1680dc3ece0b17de85bf6c762c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30a4f20a9026ff1680dc3ece0b17de85bf6c762c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20213fcca420f6b6a0b8990a4647edad39148c07", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20213fcca420f6b6a0b8990a4647edad39148c07", "html_url": "https://github.com/rust-lang/rust/commit/20213fcca420f6b6a0b8990a4647edad39148c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20213fcca420f6b6a0b8990a4647edad39148c07/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83835b0e7680188b46db5869f49672fef33ff40", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83835b0e7680188b46db5869f49672fef33ff40", "html_url": "https://github.com/rust-lang/rust/commit/f83835b0e7680188b46db5869f49672fef33ff40"}], "stats": {"total": 476, "additions": 201, "deletions": 275}, "files": [{"sha": "6a624b1c1358261c52c233085c1de43dd765db48", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 199, "deletions": 272, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=20213fcca420f6b6a0b8990a4647edad39148c07", "patch": "@@ -31,10 +31,11 @@ use rand::{XorShiftRng, RngUtil};\n use iterator::{range};\n use vec::{OwnedVector};\n \n-/// The Scheduler is responsible for coordinating execution of Coroutines\n-/// on a single thread. When the scheduler is running it is owned by\n-/// thread local storage and the running task is owned by the\n-/// scheduler.\n+/// A scheduler is responsible for coordinating the execution of Tasks\n+/// on a single thread. The scheduler runs inside a slightly modified\n+/// Rust Task. When not running this task is stored in the scheduler\n+/// struct. The scheduler struct acts like a baton, all scheduling\n+/// actions are transfers of the baton.\n ///\n /// XXX: This creates too many callbacks to run_sched_once, resulting\n /// in too much allocation and too many events.\n@@ -64,11 +65,12 @@ pub struct Scheduler {\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n-    /// The scheduler runs on a special task.\n+    /// The scheduler runs on a special task. When it is not running\n+    /// it is stored here instead of the work queue.\n     sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    priv cleanup_job: Option<CleanupJob>,\n+    cleanup_job: Option<CleanupJob>,\n     metrics: SchedMetrics,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n@@ -81,27 +83,9 @@ pub struct Scheduler {\n     idle_callback: ~PausibleIdleCallback\n }\n \n-enum CleanupJob {\n-    DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n-}\n-\n-pub struct SchedHandle {\n-    priv remote: ~RemoteCallbackObject,\n-    priv queue: MessageQueue<SchedMessage>,\n-    sched_id: uint\n-}\n-\n-pub enum SchedMessage {\n-    Wake,\n-    Shutdown,\n-    PinnedTask(~Task),\n-    TaskFromFriend(~Task)\n-}\n-\n impl Scheduler {\n \n-    pub fn sched_id(&self) -> uint { to_uint(self) }\n+    // * Initialization Functions\n \n     pub fn new(event_loop: ~EventLoopObject,\n                work_queue: WorkQueue<~Task>,\n@@ -115,8 +99,6 @@ impl Scheduler {\n \n     }\n \n-    // When you create a scheduler it isn't yet \"in\" a task, so the\n-    // task field is None.\n     pub fn new_special(event_loop: ~EventLoopObject,\n                        work_queue: WorkQueue<~Task>,\n                        work_queues: ~[WorkQueue<~Task>],\n@@ -185,7 +167,6 @@ impl Scheduler {\n         let sched = Local::take::<Scheduler>();\n \n         rtdebug!(\"starting scheduler %u\", sched.sched_id());\n-\n         sched.run();\n \n         // Now that we are done with the scheduler, clean up the\n@@ -231,11 +212,11 @@ impl Scheduler {\n         }\n     }\n \n-    // One iteration of the scheduler loop, always run at least once.\n+    // * Execution Functions - Core Loop Logic\n \n     // The model for this function is that you continue through it\n     // until you either use the scheduler while performing a schedule\n-    // action, in which case you give it away and do not return, or\n+    // action, in which case you give it away and return early, or\n     // you reach the end and sleep. In the case that a scheduler\n     // action is performed the loop is evented such that this function\n     // is called again.\n@@ -251,39 +232,18 @@ impl Scheduler {\n         // end of this function without performing an action.\n         sched.idle_callback.resume();\n \n-        // Our first task is to read mail to see if we have important\n-        // messages.\n-\n-        // 1) A wake message is easy, mutate sched struct and return\n-        //    it.\n-        // 2) A shutdown is also easy, shutdown.\n-        // 3) A pinned task - we resume immediately and do not return\n-        //    here.\n-        // 4) A message from another scheduler with a non-homed task\n-        //    to run here.\n-\n-        let result = sched.interpret_message_queue();\n-        let sched = match result {\n-            Some(sched) => {\n-                // We did not resume a task, so we returned.\n-                sched\n-            }\n-            None => {\n-                return;\n-            }\n+        // First we check for scheduler messages, these are higher\n+        // priority than regular tasks.\n+        let sched = match sched.interpret_message_queue() {\n+            Some(sched) => sched,\n+            None => return\n         };\n \n-        // Second activity is to try resuming a task from the queue.\n-\n-        let result = sched.do_work();\n-        let mut sched = match result {\n-            Some(sched) => {\n-                // Failed to dequeue a task, so we return.\n-                sched\n-            }\n-            None => {\n-                return;\n-            }\n+        // This helper will use a randomized work-stealing algorithm\n+        // to find work.\n+        let mut sched = match sched.do_work() {\n+            Some(sched) => sched,\n+            None => return\n         };\n \n         // If we got here then there was no work to do.\n@@ -310,67 +270,10 @@ impl Scheduler {\n         Local::put(sched);\n     }\n \n-    pub fn make_handle(&mut self) -> SchedHandle {\n-        let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n-\n-        return SchedHandle {\n-            remote: remote,\n-            queue: self.message_queue.clone(),\n-            sched_id: self.sched_id()\n-        };\n-    }\n-\n-    /// Schedule a task to be executed later.\n-    ///\n-    /// Pushes the task onto the work stealing queue and tells the\n-    /// event loop to run it later. Always use this instead of pushing\n-    /// to the work queue directly.\n-    pub fn enqueue_task(&mut self, task: ~Task) {\n-\n-        let this = self;\n-\n-        rtdebug!(\"enqueuing task\");\n-\n-        // We push the task onto our local queue clone.\n-        this.work_queue.push(task);\n-\n-        // There is definitely work to be done later. Make sure we wake up for it.\n-        this.idle_callback.resume();\n-\n-        // We've made work available. Notify a\n-        // sleeping scheduler.\n-\n-        // XXX: perf. Check for a sleeper without\n-        // synchronizing memory.  It's not critical\n-        // that we always find it.\n-\n-        // XXX: perf. If there's a sleeper then we\n-        // might as well just send it the task\n-        // directly instead of pushing it to the\n-        // queue. That is essentially the intent here\n-        // and it is less work.\n-        match this.sleeper_list.pop() {\n-            Some(handle) => {\n-                let mut handle = handle;\n-                handle.send(Wake)\n-            }\n-            None => { (/* pass */) }\n-        };\n-    }\n-\n-    /// As enqueue_task, but with the possibility for the blocked task to\n-    /// already have been killed.\n-    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map_move |task| {\n-            self.enqueue_task(task);\n-        };\n-    }\n-\n-    // * Scheduler-context operations\n-\n     // This function returns None if the scheduler is \"used\", or it\n-    // returns the still-available scheduler. Note: currently\n-    // considers *any* message receive a use and returns None.\n+    // returns the still-available scheduler. At this point all\n+    // message-handling will count as a turn of work, and as a result\n+    // return None.\n     fn interpret_message_queue(~self) -> Option<~Scheduler> {\n \n         let mut this = self;\n@@ -383,7 +286,8 @@ impl Scheduler {\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                this.sched_schedule_task(task).map_move(Local::put);\n+                this.process_task(task,\n+                                  Scheduler::resume_task_immediately_cl).map_move(Local::put);\n                 return None;\n             }\n             Some(Wake) => {\n@@ -411,7 +315,6 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 this.no_sleep = true;\n                 this.sleepy = false;\n-\n                 Local::put(this);\n                 return None;\n             }\n@@ -421,30 +324,19 @@ impl Scheduler {\n         }\n     }\n \n-    /// Given an input Coroutine sends it back to its home scheduler.\n-    fn send_task_home(task: ~Task) {\n-        let mut task = task;\n-        let mut home = task.take_unwrap_home();\n-        match home {\n-            Sched(ref mut home_handle) => {\n-                home_handle.send(PinnedTask(task));\n-            }\n-            AnySched => {\n-                rtabort!(\"error: cannot send anysched task home\");\n-            }\n-        }\n-    }\n+    fn do_work(~self) -> Option<~Scheduler> {\n+        let mut this = self;\n \n-    /// Take a non-homed task we aren't allowed to run here and send\n-    /// it to the designated friend scheduler to execute.\n-    fn send_to_friend(&mut self, task: ~Task) {\n-        rtdebug!(\"sending a task to friend\");\n-        match self.friend_handle {\n-            Some(ref mut handle) => {\n-                handle.send(TaskFromFriend(task));\n+        rtdebug!(\"scheduler calling do work\");\n+        match this.find_work() {\n+            Some(task) => {\n+                rtdebug!(\"found some work! processing the task\");\n+                return this.process_task(task,\n+                                         Scheduler::resume_task_immediately_cl);\n             }\n             None => {\n-                rtabort!(\"tried to send task to a friend but scheduler has no friends\");\n+                rtdebug!(\"no work was found, returning the scheduler struct\");\n+                return Some(this);\n             }\n         }\n     }\n@@ -468,8 +360,8 @@ impl Scheduler {\n             None => {\n                 // Our naive stealing, try kinda hard.\n                 rtdebug!(\"scheduler trying to steal\");\n-                let _len = self.work_queues.len();\n-                return self.try_steals(2);\n+                let len = self.work_queues.len();\n+                return self.try_steals(len/2);\n             }\n         }\n     }\n@@ -483,7 +375,8 @@ impl Scheduler {\n             let work_queues = &mut self.work_queues;\n             match work_queues[index].steal() {\n                 Some(task) => {\n-                    rtdebug!(\"found task by stealing\"); return Some(task)\n+                    rtdebug!(\"found task by stealing\");\n+                    return Some(task)\n                 }\n                 None => ()\n             }\n@@ -492,8 +385,11 @@ impl Scheduler {\n         return None;\n     }\n \n-    // Given a task, execute it correctly.\n-    fn process_task(~self, task: ~Task) -> Option<~Scheduler> {\n+    // * Task Routing Functions - Make sure tasks send up in the right\n+    // place.\n+\n+    fn process_task(~self, task: ~Task,\n+                    schedule_fn: SchedulingFn) -> Option<~Scheduler> {\n         let mut this = self;\n         let mut task = task;\n \n@@ -510,15 +406,13 @@ impl Scheduler {\n                 } else {\n                     rtdebug!(\"running task here\");\n                     task.give_home(Sched(home_handle));\n-                    this.resume_task_immediately(task);\n-                    return None;\n+                    return schedule_fn(this, task);\n                 }\n             }\n             AnySched if this.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 task.give_home(AnySched);\n-                this.resume_task_immediately(task);\n-                return None;\n+                return schedule_fn(this, task);\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n@@ -529,98 +423,71 @@ impl Scheduler {\n         }\n     }\n \n-    // Bundle the helpers together.\n-    fn do_work(~self) -> Option<~Scheduler> {\n-        let mut this = self;\n-\n-        rtdebug!(\"scheduler calling do work\");\n-        match this.find_work() {\n-            Some(task) => {\n-                rtdebug!(\"found some work! processing the task\");\n-                return this.process_task(task);\n+    fn send_task_home(task: ~Task) {\n+        let mut task = task;\n+        let mut home = task.take_unwrap_home();\n+        match home {\n+            Sched(ref mut home_handle) => {\n+                home_handle.send(PinnedTask(task));\n             }\n-            None => {\n-                rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some(this);\n+            AnySched => {\n+                        rtabort!(\"error: cannot send anysched task home\");\n             }\n         }\n     }\n \n-    /// Called by a running task to end execution, after which it will\n-    /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(~self) {\n-        // Similar to deschedule running task and then, but cannot go through\n-        // the task-blocking path. The task is already dying.\n-        let mut this = self;\n-        let stask = this.sched_task.take_unwrap();\n-        do this.change_task_context(stask) |sched, mut dead_task| {\n-            let coroutine = dead_task.coroutine.take_unwrap();\n-            coroutine.recycle(&mut sched.stack_pool);\n+    /// Take a non-homed task we aren't allowed to run here and send\n+    /// it to the designated friend scheduler to execute.\n+    fn send_to_friend(&mut self, task: ~Task) {\n+        rtdebug!(\"sending a task to friend\");\n+        match self.friend_handle {\n+            Some(ref mut handle) => {\n+                handle.send(TaskFromFriend(task));\n+            }\n+            None => {\n+                rtabort!(\"tried to send task to a friend but scheduler has no friends\");\n+            }\n         }\n     }\n \n-    // Scheduling a task requires a few checks to make sure the task\n-    // ends up in the appropriate location. The run_anything flag on\n-    // the scheduler and the home on the task need to be checked. This\n-    // helper performs that check. It takes a function that specifies\n-    // how to queue the the provided task if that is the correct\n-    // action. This is a \"core\" function that requires handling the\n-    // returned Option correctly.\n-\n-    pub fn schedule_task(~self, task: ~Task,\n-                         schedule_fn: ~fn(sched: ~Scheduler, task: ~Task))\n-        -> Option<~Scheduler> {\n-\n-        // is the task home?\n-        let is_home = task.is_home_no_tls(&self);\n+    /// Schedule a task to be executed later.\n+    ///\n+    /// Pushes the task onto the work stealing queue and tells the\n+    /// event loop to run it later. Always use this instead of pushing\n+    /// to the work queue directly.\n+    pub fn enqueue_task(&mut self, task: ~Task) {\n \n-        // does the task have a home?\n-        let homed = task.homed();\n+        let this = self;\n \n-        let mut this = self;\n+        // We push the task onto our local queue clone.\n+        this.work_queue.push(task);\n+        this.idle_callback.resume();\n \n-        if is_home || (!homed && this.run_anything) {\n-            // here we know we are home, execute now OR we know we\n-            // aren't homed, and that this sched doesn't care\n-            rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n-            schedule_fn(this, task);\n-            return None;\n-        } else if !homed && !this.run_anything {\n-            // the task isn't homed, but it can't be run here\n-            this.send_to_friend(task);\n-            return Some(this);\n-        } else {\n-            // task isn't home, so don't run it here, send it home\n-            Scheduler::send_task_home(task);\n-            return Some(this);\n-        }\n-    }\n+        // We've made work available. Notify a\n+        // sleeping scheduler.\n \n-    // There are two contexts in which schedule_task can be called:\n-    // inside the scheduler, and inside a task. These contexts handle\n-    // executing the task slightly differently. In the scheduler\n-    // context case we want to receive the scheduler as an input, and\n-    // manually deal with the option. In the task context case we want\n-    // to use TLS to find the scheduler, and deal with the option\n-    // inside the helper.\n-\n-    pub fn sched_schedule_task(~self, task: ~Task) -> Option<~Scheduler> {\n-        do self.schedule_task(task) |sched, next_task| {\n-            sched.resume_task_immediately(next_task);\n-        }\n+        // XXX: perf. Check for a sleeper without\n+        // synchronizing memory.  It's not critical\n+        // that we always find it.\n+        match this.sleeper_list.pop() {\n+            Some(handle) => {\n+                        let mut handle = handle;\n+                handle.send(Wake)\n+            }\n+            None => { (/* pass */) }\n+        };\n     }\n \n-    // Task context case - use TLS.\n-    pub fn run_task(task: ~Task) {\n-        let sched = Local::take::<Scheduler>();\n-        let opt = do sched.schedule_task(task) |sched, next_task| {\n-            do sched.switch_running_tasks_and_then(next_task) |sched, last_task| {\n-                sched.enqueue_blocked_task(last_task);\n-            }\n+    /// As enqueue_task, but with the possibility for the blocked task to\n+    /// already have been killed.\n+    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n+        do blocked_task.wake().map_move |task| {\n+            self.enqueue_task(task);\n         };\n-        opt.map_move(Local::put);\n     }\n \n+    // * Core Context Switching Functions\n+\n     // The primary function for changing contexts. In the current\n     // design the scheduler is just a slightly modified GreenTask, so\n     // all context swaps are from Task to Task. The only difference\n@@ -650,7 +517,7 @@ impl Scheduler {\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n-        this.enqueue_cleanup_job(GiveTask(current_task, f_opaque));\n+        this.cleanup_job = Some(CleanupJob::new(current_task, f_opaque));\n \n         // The scheduler is then placed inside the next task.\n         let mut next_task = next_task;\n@@ -666,12 +533,9 @@ impl Scheduler {\n                 transmute_mut_region(*next_task.sched.get_mut_ref());\n \n             let current_task: &mut Task = match sched.cleanup_job {\n-                Some(GiveTask(ref task, _)) => {\n+                Some(CleanupJob { task: ref task, _ }) => {\n                     transmute_mut_region(*transmute_mut_unsafe(task))\n                 }\n-                Some(DoNothing) => {\n-                    rtabort!(\"no next task\");\n-                }\n                 None => {\n                     rtabort!(\"no cleanup job\");\n                 }\n@@ -705,19 +569,42 @@ impl Scheduler {\n         }\n     }\n \n-    // Old API for task manipulation implemented over the new core\n-    // function.\n+    // Returns a mutable reference to both contexts involved in this\n+    // swap. This is unsafe - we are getting mutable internal\n+    // references to keep even when we don't own the tasks. It looks\n+    // kinda safe because we are doing transmutes before passing in\n+    // the arguments.\n+    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n+        (&'a mut Context, &'a mut Context) {\n+        let current_task_context =\n+            &mut current_task.coroutine.get_mut_ref().saved_context;\n+        let next_task_context =\n+                &mut next_task.coroutine.get_mut_ref().saved_context;\n+        unsafe {\n+            (transmute_mut_region(current_task_context),\n+             transmute_mut_region(next_task_context))\n+        }\n+    }\n+\n+    // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self, task: ~Task) {\n+    pub fn resume_task_immediately(~self, task: ~Task) -> Option<~Scheduler> {\n         do self.change_task_context(task) |sched, stask| {\n             sched.sched_task = Some(stask);\n         }\n+        return None;\n+    }\n+\n+    fn resume_task_immediately_cl(sched: ~Scheduler,\n+                                  task: ~Task) -> Option<~Scheduler> {\n+        sched.resume_task_immediately(task)\n     }\n \n+\n     pub fn resume_blocked_task_immediately(~self, blocked_task: BlockedTask) {\n         match blocked_task.wake() {\n-            Some(task) => self.resume_task_immediately(task),\n-            None => Local::put(self),\n+            Some(task) => { self.resume_task_immediately(task); }\n+            None => Local::put(self)\n         };\n     }\n \n@@ -756,54 +643,75 @@ impl Scheduler {\n         }\n     }\n \n-    // A helper that looks up the scheduler and runs a task later by\n-    // enqueuing it.\n+    fn switch_task(sched: ~Scheduler, task: ~Task) -> Option<~Scheduler> {\n+        do sched.switch_running_tasks_and_then(task) |sched, last_task| {\n+            sched.enqueue_blocked_task(last_task);\n+        };\n+        return None;\n+    }\n+\n+    // * Task Context Helpers\n+\n+    /// Called by a running task to end execution, after which it will\n+    /// be recycled by the scheduler for reuse in a new task.\n+    pub fn terminate_current_task(~self) {\n+        // Similar to deschedule running task and then, but cannot go through\n+        // the task-blocking path. The task is already dying.\n+        let mut this = self;\n+        let stask = this.sched_task.take_unwrap();\n+        do this.change_task_context(stask) |sched, mut dead_task| {\n+            let coroutine = dead_task.coroutine.take_unwrap();\n+            coroutine.recycle(&mut sched.stack_pool);\n+        }\n+    }\n+\n+    pub fn run_task(task: ~Task) {\n+        let sched = Local::take::<Scheduler>();\n+        sched.process_task(task, Scheduler::switch_task).map_move(Local::put);\n+    }\n+\n     pub fn run_task_later(next_task: ~Task) {\n-        // We aren't performing a scheduler operation, so we want to\n-        // put the Scheduler back when we finish.\n         let next_task = Cell::new(next_task);\n         do Local::borrow::<Scheduler,()> |sched| {\n             sched.enqueue_task(next_task.take());\n         };\n     }\n \n-    // Returns a mutable reference to both contexts involved in this\n-    // swap. This is unsafe - we are getting mutable internal\n-    // references to keep even when we don't own the tasks. It looks\n-    // kinda safe because we are doing transmutes before passing in\n-    // the arguments.\n-    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n-        (&'a mut Context, &'a mut Context) {\n-        let current_task_context =\n-            &mut current_task.coroutine.get_mut_ref().saved_context;\n-        let next_task_context =\n-            &mut next_task.coroutine.get_mut_ref().saved_context;\n-        unsafe {\n-            (transmute_mut_region(current_task_context),\n-             transmute_mut_region(next_task_context))\n-        }\n-    }\n+    // * Utility Functions\n \n-    pub fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n-        self.cleanup_job = Some(job);\n-    }\n+    pub fn sched_id(&self) -> uint { to_uint(self) }\n \n     pub fn run_cleanup_job(&mut self) {\n-        rtdebug!(\"running cleanup job\");\n         let cleanup_job = self.cleanup_job.take_unwrap();\n-        match cleanup_job {\n-            DoNothing => { }\n-            GiveTask(task, f) => f.to_fn()(self, task)\n-        }\n+        cleanup_job.run(self);\n+    }\n+\n+    pub fn make_handle(&mut self) -> SchedHandle {\n+        let remote = self.event_loop.remote_callback(Scheduler::run_sched_once);\n+\n+        return SchedHandle {\n+            remote: remote,\n+            queue: self.message_queue.clone(),\n+            sched_id: self.sched_id()\n+        };\n     }\n }\n \n-// The cases for the below function.\n-enum ResumeAction {\n-    SendHome,\n-    Requeue,\n-    ResumeNow,\n-    Homeless\n+// Supporting types\n+\n+type SchedulingFn = ~fn(~Scheduler, ~Task) -> Option<~Scheduler>;\n+\n+pub enum SchedMessage {\n+    Wake,\n+    Shutdown,\n+    PinnedTask(~Task),\n+    TaskFromFriend(~Task)\n+}\n+\n+pub struct SchedHandle {\n+    priv remote: ~RemoteCallbackObject,\n+    priv queue: MessageQueue<SchedMessage>,\n+    sched_id: uint\n }\n \n impl SchedHandle {\n@@ -813,6 +721,25 @@ impl SchedHandle {\n     }\n }\n \n+struct CleanupJob {\n+    task: ~Task,\n+    f: UnsafeTaskReceiver\n+}\n+\n+impl CleanupJob {\n+    pub fn new(task: ~Task, f: UnsafeTaskReceiver) -> CleanupJob {\n+        CleanupJob {\n+            task: task,\n+            f: f\n+        }\n+    }\n+\n+    pub fn run(self, sched: &mut Scheduler) {\n+        let CleanupJob { task: task, f: f } = self;\n+        f.to_fn()(sched, task)\n+    }\n+}\n+\n // XXX: Some hacks to put a &fn in Scheduler without borrowck\n // complaining\n type UnsafeTaskReceiver = raw::Closure;"}, {"sha": "698c59805a4cf306bb64182b9bd327886aabd0f2", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=20213fcca420f6b6a0b8990a4647edad39148c07", "patch": "@@ -360,7 +360,7 @@ impl Coroutine {\n \n                 // Again - might work while safe, or it might not.\n                 do Local::borrow::<Scheduler,()> |sched| {\n-                    (sched).run_cleanup_job();\n+                    sched.run_cleanup_job();\n                 }\n \n                 // To call the run method on a task we need a direct"}, {"sha": "8a2541e73b384da8c851b3796d23900e3025a072", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20213fcca420f6b6a0b8990a4647edad39148c07/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=20213fcca420f6b6a0b8990a4647edad39148c07", "patch": "@@ -38,8 +38,7 @@ pub fn default_sched_threads() -> uint {\n pub fn dumb_println(s: &str) {\n     use io::WriterUtil;\n     let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-    dbg.write_str(s);\n-    dbg.write_str(\"\\n\");\n+    dbg.write_str(s + \"\\n\");\n }\n \n pub fn abort(msg: &str) -> ! {"}]}