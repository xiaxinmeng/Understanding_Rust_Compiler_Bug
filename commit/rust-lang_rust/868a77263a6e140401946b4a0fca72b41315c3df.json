{"sha": "868a77263a6e140401946b4a0fca72b41315c3df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGE3NzI2M2E2ZTE0MDQwMTk0NmI0YTBmY2E3MmI0MTMxNWMzZGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-17T17:51:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-17T17:51:42Z"}, "message": "more consistency and clarification", "tree": {"sha": "cc03ffbffa359dbabfc0c0299203efc30f010a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc03ffbffa359dbabfc0c0299203efc30f010a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868a77263a6e140401946b4a0fca72b41315c3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868a77263a6e140401946b4a0fca72b41315c3df", "html_url": "https://github.com/rust-lang/rust/commit/868a77263a6e140401946b4a0fca72b41315c3df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868a77263a6e140401946b4a0fca72b41315c3df/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470e9d2789cf589b701594ce69b76bb530c67483", "url": "https://api.github.com/repos/rust-lang/rust/commits/470e9d2789cf589b701594ce69b76bb530c67483", "html_url": "https://github.com/rust-lang/rust/commit/470e9d2789cf589b701594ce69b76bb530c67483"}], "stats": {"total": 30, "additions": 17, "deletions": 13}, "files": [{"sha": "1cab8026514ea4cc93e31f05926f07458ef88d2a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/868a77263a6e140401946b4a0fca72b41315c3df/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868a77263a6e140401946b4a0fca72b41315c3df/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=868a77263a6e140401946b4a0fca72b41315c3df", "patch": "@@ -4,7 +4,8 @@\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n //! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n-//! given allocation is destroyed, the pointed-to value is also destroyed.\n+//! given allocation is destroyed, the value stored in that allocation (often\n+//! referred to as \"inner value\") is also dropped.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,8 +22,10 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the allocation has\n-//! already been dropped.\n+//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n+//! already been dropped. In other words, `Weak` pointers do not keep the value\n+//! inside the allocation alive; however, they *do* keep the allocation\n+//! (the backing store for the value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -46,8 +49,8 @@\n //!\n //! # Cloning references\n //!\n-//! Creating a new reference from an existing reference counted pointer is done using the\n-//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//! Creating a new reference to the same allocation as an existing reference counted pointer\n+//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -109,8 +112,8 @@\n //!\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n-//!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` pointing at the same `Owner`, it will remain\n+//!     // single `Rc<Owner>`, not the `Owner` allocation it points to. As long as there are\n+//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n //!     // allocated. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n@@ -365,7 +368,7 @@ impl<T> Rc<T> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n-    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n     /// passed in.\n@@ -679,7 +682,7 @@ impl<T: ?Sized> Rc<T> {\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1551,12 +1554,13 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n /// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n /// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n-/// managed by [`Rc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Rc`] pointers, since mutual owning references\n+/// managed by [`Rc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents."}]}