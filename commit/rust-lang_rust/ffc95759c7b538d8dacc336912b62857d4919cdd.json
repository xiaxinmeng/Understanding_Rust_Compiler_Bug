{"sha": "ffc95759c7b538d8dacc336912b62857d4919cdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYzk1NzU5YzdiNTM4ZDhkYWNjMzM2OTEyYjYyODU3ZDQ5MTljZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-30T14:24:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-30T14:24:39Z"}, "message": "Merge #1739\n\n1739: move lsp-server to a separate repository r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "3f0e4056ba2e4b3799b72d71d709783aa6dffc49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f0e4056ba2e4b3799b72d71d709783aa6dffc49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffc95759c7b538d8dacc336912b62857d4919cdd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdaTGnCRBK7hj4Ov3rIwAAdHIIAGcLayiqLnMSiBaX2ICE+VPJ\n5CKGMl1VFGaXg8f9bXcUpjawnKD9ot8fAeONBADr2fjMR/b99IOLiyy0xVx6i7L9\nyLkHTWC6jJXJcLmMGPkDC07gjt+kjAdCYRNwUGAgdTQrTo9s0gd31O09Zt1V4I+5\npC/j8XJKEzwQuM/pnVH/ozp1v2SCe8JSRZNgUUR/rEnXaxvl+OXIOrKOYKFkwS1j\nYHexpQOOZmJXsYeoUa/cP6eN0ZWqfD1uNIfGvqe7s9eT7Vv3vICx9XQODYXYDpEa\nV5uWSVRhXhwZN6vOH5lfd5+OdEc9V1BGOvkLtQ/TUjIPWOJSG0G/SlodBFxyGHE=\n=p6+J\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f0e4056ba2e4b3799b72d71d709783aa6dffc49\nparent 7d72ca80003b7915ed7fc64907b5b6dc5c88dacd\nparent 72a3722470e5297c72dcaccaf2f113e7b758606d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567175079 +0000\ncommitter GitHub <noreply@github.com> 1567175079 +0000\n\nMerge #1739\n\n1739: move lsp-server to a separate repository r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc95759c7b538d8dacc336912b62857d4919cdd", "html_url": "https://github.com/rust-lang/rust/commit/ffc95759c7b538d8dacc336912b62857d4919cdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffc95759c7b538d8dacc336912b62857d4919cdd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "html_url": "https://github.com/rust-lang/rust/commit/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd"}, {"sha": "72a3722470e5297c72dcaccaf2f113e7b758606d", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a3722470e5297c72dcaccaf2f113e7b758606d", "html_url": "https://github.com/rust-lang/rust/commit/72a3722470e5297c72dcaccaf2f113e7b758606d"}], "stats": {"total": 866, "additions": 141, "deletions": 725}, "files": [{"sha": "17e60aa8219fc44ac9c78b4a70b87598b38274e0", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -214,23 +214,6 @@ dependencies = [\n  \"bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"console\"\n-version = \"0.7.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"clicolors-control 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"encode_unicode 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.62 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"console\"\n version = \"0.8.0\"\n@@ -472,18 +455,6 @@ name = \"fuchsia-zircon-sys\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"gen_lsp_server\"\n-version = \"0.2.0\"\n-dependencies = [\n- \"crossbeam-channel 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lsp-types 0.60.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"getrandom\"\n version = \"0.1.10\"\n@@ -539,7 +510,7 @@ name = \"indicatif\"\n version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"console 0.7.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"console 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"number_prefix 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -689,6 +660,17 @@ dependencies = [\n  \"cfg-if 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"lsp-server\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"crossbeam-channel 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"lsp-types\"\n version = \"0.60.0\"\n@@ -1092,8 +1074,8 @@ version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.14.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gen_lsp_server 0.2.0\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lsp-server 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.60.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_ide_api 0.1.0\",\n@@ -1899,7 +1881,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n \"checksum clicolors-control 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73abfd4c73d003a674ce5d2933fca6ce6c42480ea84a5ffe0a2dc39ed56300f9\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n-\"checksum console 0.7.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ca57c2c14b8a2bf3105bc9d15574aad80babf6a9c44b1058034cdf8bd169628\"\n \"checksum console 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b147390a412132d75d10dd3b7b175a69cf5fd95032f7503c7091b8831ba10242\"\n \"checksum crossbeam 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d818a4990769aac0c7ff1360e233ef3a41adcb009ebb2036bf6915eb0f6b23c\"\n \"checksum crossbeam-channel 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8ec7fcd21571dc78f96cc96243cab8d8f035247c3efd16c687be154c3fa9efa\"\n@@ -1956,6 +1937,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n \"checksum lock_api 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n \"checksum log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n+\"checksum lsp-server 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"47632ec528046c1a39f14448f1ee7d66d4b7b83e1771590b62e6c08665dea053\"\n \"checksum lsp-types 0.60.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fe3edefcd66dde1f7f1df706f46520a3c93adc5ca4bc5747da6621195e894efd\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \"checksum memchr 2.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88579771288728879b57485cc7d6b07d648c9f0141eb955f8ab7f9d45394468e\""}, {"sha": "7011aa1bfb92ec0312d8b9e371e8ecc473538b3b", "filename": "crates/gen_lsp_server/Cargo.toml", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2FCargo.toml?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,18 +0,0 @@\n-[package]\n-edition = \"2018\"\n-name = \"gen_lsp_server\"\n-version = \"0.2.0\"\n-authors = [\"rust-analyzer developers\"]\n-repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n-license = \"MIT OR Apache-2.0\"\n-description = \"Generic LSP server scaffold.\"\n-\n-[dependencies]\n-lsp-types = \"0.60.0\"\n-log = \"0.4.3\"\n-serde_json = \"1.0.34\"\n-serde = { version = \"1.0.83\", features = [\"derive\"] }\n-crossbeam-channel = \"0.3.5\"\n-\n-[dev-dependencies]\n-flexi_logger = \"0.14.0\""}, {"sha": "f49965064973b8176ba5333bf837a8fe74ac91cc", "filename": "crates/gen_lsp_server/examples/01_gen_lsp_server.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fexamples%2F01_gen_lsp_server.rs?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,47 +0,0 @@\n-use std::error::Error;\r\n-\r\n-use crossbeam_channel::{Receiver, Sender};\r\n-use gen_lsp_server::{handle_shutdown, run_server, stdio_transport, RawMessage, RawResponse};\r\n-use lsp_types::{\r\n-    request::{GotoDefinition, GotoDefinitionResponse},\r\n-    InitializeParams, ServerCapabilities,\r\n-};\r\n-\r\n-fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\r\n-    let (receiver, sender, io_threads) = stdio_transport();\r\n-    run_server(ServerCapabilities::default(), receiver, sender, main_loop)?;\r\n-    io_threads.join()?;\r\n-    Ok(())\r\n-}\r\n-\r\n-fn main_loop(\r\n-    _params: InitializeParams,\r\n-    receiver: &Receiver<RawMessage>,\r\n-    sender: &Sender<RawMessage>,\r\n-) -> Result<(), Box<dyn Error + Sync + Send>> {\r\n-    for msg in receiver {\r\n-        match msg {\r\n-            RawMessage::Request(req) => {\r\n-                let req = match handle_shutdown(req, sender) {\r\n-                    None => return Ok(()),\r\n-                    Some(req) => req,\r\n-                };\r\n-                match req.cast::<GotoDefinition>() {\r\n-                    Ok((id, _params)) => {\r\n-                        let resp = RawResponse::ok::<GotoDefinition>(\r\n-                            id,\r\n-                            &Some(GotoDefinitionResponse::Array(Vec::new())),\r\n-                        );\r\n-                        sender.send(RawMessage::Response(resp))?;\r\n-                        continue;\r\n-                    }\r\n-                    Err(req) => req,\r\n-                };\r\n-                // ...\r\n-            }\r\n-            RawMessage::Response(_resp) => (),\r\n-            RawMessage::Notification(_not) => (),\r\n-        }\r\n-    }\r\n-    Ok(())\r\n-}\r"}, {"sha": "3c48106c5f6ec15db7a03be00f6bd5aad18faa99", "filename": "crates/gen_lsp_server/examples/02_gen_lsp_server_with_logging.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fexamples%2F02_gen_lsp_server_with_logging.rs?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,120 +0,0 @@\n-//! A minimal example LSP server that can only respond to the `gotoDefinition` request. To use\r\n-//! this example, execute it and then send an `initialize` request.\r\n-//!\r\n-//! ```no_run\r\n-//! Content-Length: 85\r\n-//!\r\n-//! {\"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1, \"params\": {\"capabilities\": {}}}\r\n-//! ```\r\n-//!\r\n-//! This will respond with a server respose. Then send it a `initialized` notification which will\r\n-//! have no response.\r\n-//!\r\n-//! ```no_run\r\n-//! Content-Length: 59\r\n-//!\r\n-//! {\"jsonrpc\": \"2.0\", \"method\": \"initialized\", \"params\": {}}\r\n-//! ```\r\n-//!\r\n-//! Once these two are sent, then we enter the main loop of the server. The only request this\r\n-//! example can handle is `gotoDefinition`:\r\n-//!\r\n-//! ```no_run\r\n-//! Content-Length: 159\r\n-//!\r\n-//! {\"jsonrpc\": \"2.0\", \"method\": \"textDocument/definition\", \"id\": 2, \"params\": {\"textDocument\": {\"uri\": \"file://temp\"}, \"position\": {\"line\": 1, \"character\": 1}}}\r\n-//! ```\r\n-//!\r\n-//! To finish up without errors, send a shutdown request:\r\n-//!\r\n-//! ```no_run\r\n-//! Content-Length: 67\r\n-//!\r\n-//! {\"jsonrpc\": \"2.0\", \"method\": \"shutdown\", \"id\": 3, \"params\": null}\r\n-//! ```\r\n-//!\r\n-//! The server will exit the main loop and finally we send a `shutdown` notification to stop\r\n-//! the server.\r\n-//!\r\n-//! ```\r\n-//! Content-Length: 54\r\n-//!\r\n-//! {\"jsonrpc\": \"2.0\", \"method\": \"exit\", \"params\": null}\r\n-//! ```\r\n-\r\n-use std::error::Error;\r\n-\r\n-use crossbeam_channel::{Receiver, Sender};\r\n-use gen_lsp_server::{\r\n-    handle_shutdown, run_server, stdio_transport, RawMessage, RawRequest, RawResponse,\r\n-};\r\n-use log::info;\r\n-use lsp_types::{\r\n-    request::{GotoDefinition, GotoDefinitionResponse},\r\n-    InitializeParams, ServerCapabilities,\r\n-};\r\n-\r\n-fn main() -> Result<(), Box<dyn Error + Sync + Send>> {\r\n-    // Set up logging. Because `stdio_transport` gets a lock on stdout and stdin, we must have\r\n-    // our logging only write out to stderr.\r\n-    flexi_logger::Logger::with_str(\"info\").start().unwrap();\r\n-    info!(\"starting generic LSP server\");\r\n-\r\n-    // Create the transport. Includes the stdio (stdin and stdout) versions but this could\r\n-    // also be implemented to use sockets or HTTP.\r\n-    let (receiver, sender, io_threads) = stdio_transport();\r\n-\r\n-    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).\r\n-    run_server(ServerCapabilities::default(), receiver, sender, main_loop)?;\r\n-    io_threads.join()?;\r\n-\r\n-    // Shut down gracefully.\r\n-    info!(\"shutting down server\");\r\n-    Ok(())\r\n-}\r\n-\r\n-fn main_loop(\r\n-    _params: InitializeParams,\r\n-    receiver: &Receiver<RawMessage>,\r\n-    sender: &Sender<RawMessage>,\r\n-) -> Result<(), Box<dyn Error + Sync + Send>> {\r\n-    info!(\"starting example main loop\");\r\n-    for msg in receiver {\r\n-        info!(\"got msg: {:?}\", msg);\r\n-        match msg {\r\n-            RawMessage::Request(req) => {\r\n-                let req = match log_handle_shutdown(req, sender) {\r\n-                    None => return Ok(()),\r\n-                    Some(req) => req,\r\n-                };\r\n-                info!(\"got request: {:?}\", req);\r\n-                match req.cast::<GotoDefinition>() {\r\n-                    Ok((id, params)) => {\r\n-                        info!(\"got gotoDefinition request #{}: {:?}\", id, params);\r\n-                        let resp = RawResponse::ok::<GotoDefinition>(\r\n-                            id,\r\n-                            &Some(GotoDefinitionResponse::Array(Vec::new())),\r\n-                        );\r\n-                        info!(\"sending gotoDefinition response: {:?}\", resp);\r\n-                        sender.send(RawMessage::Response(resp))?;\r\n-                        continue;\r\n-                    }\r\n-                    Err(req) => req,\r\n-                };\r\n-                // ...\r\n-            }\r\n-            RawMessage::Response(resp) => {\r\n-                info!(\"got response: {:?}\", resp);\r\n-            }\r\n-            RawMessage::Notification(not) => {\r\n-                info!(\"got notification: {:?}\", not);\r\n-            }\r\n-        }\r\n-    }\r\n-    Ok(())\r\n-}\r\n-\r\n-pub fn log_handle_shutdown(req: RawRequest, sender: &Sender<RawMessage>) -> Option<RawRequest> {\r\n-    info!(\"handle_shutdown: {:?}\", req);\r\n-    handle_shutdown(req, sender)\r\n-}\r"}, {"sha": "0984e3e25a3bf24b1e4bdfadd45fb9e29dcb4f73", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,136 +0,0 @@\n-//! A language server scaffold, exposing a synchronous crossbeam-channel based API.\n-//! This crate handles protocol handshaking and parsing messages, while you\n-//! control the message dispatch loop yourself.\n-//!\n-//! Run with `RUST_LOG=gen_lsp_server=debug` to see all the messages.\n-//!\n-//! ```no_run\n-//! use std::error::Error;\n-//! use crossbeam_channel::{Sender, Receiver};\n-//! use lsp_types::{ServerCapabilities, InitializeParams, request::{GotoDefinition, GotoDefinitionResponse}};\n-//! use gen_lsp_server::{run_server, stdio_transport, handle_shutdown, RawMessage, RawResponse};\n-//!\n-//! fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n-//!     let (receiver, sender, io_threads) = stdio_transport();\n-//!     run_server(\n-//!         ServerCapabilities::default(),\n-//!         receiver,\n-//!         sender,\n-//!         main_loop,\n-//!     )?;\n-//!     io_threads.join()?;\n-//!     Ok(())\n-//! }\n-//!\n-//! fn main_loop(\n-//!     _params: InitializeParams,\n-//!     receiver: &Receiver<RawMessage>,\n-//!     sender: &Sender<RawMessage>,\n-//! ) -> Result<(), Box<dyn Error + Send + Sync>> {\n-//!     for msg in receiver {\n-//!         match msg {\n-//!             RawMessage::Request(req) => {\n-//!                 let req = match handle_shutdown(req, sender) {\n-//!                     None => return Ok(()),\n-//!                     Some(req) => req,\n-//!                 };\n-//!                 match req.cast::<GotoDefinition>() {\n-//!                     Ok((id, _params)) => {\n-//!                         let resp = RawResponse::ok::<GotoDefinition>(\n-//!                             id,\n-//!                             &Some(GotoDefinitionResponse::Array(Vec::new())),\n-//!                         );\n-//!                         sender.send(RawMessage::Response(resp))?;\n-//!                         continue;\n-//!                     },\n-//!                     Err(req) => req,\n-//!                 };\n-//!                 // ...\n-//!             }\n-//!             RawMessage::Response(_resp) => (),\n-//!             RawMessage::Notification(_not) => (),\n-//!         }\n-//!     }\n-//!     Ok(())\n-//! }\n-//! ```\n-\n-use std::error::Error;\n-\n-mod msg;\n-mod stdio;\n-\n-use crossbeam_channel::{Receiver, Sender};\n-use lsp_types::{\n-    notification::{Exit, Initialized},\n-    request::{Initialize, Shutdown},\n-    InitializeParams, InitializeResult, ServerCapabilities,\n-};\n-\n-pub type Result<T> = std::result::Result<T, Box<dyn Error + Send + Sync>>;\n-pub use crate::{\n-    msg::{ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse, RawResponseError},\n-    stdio::{stdio_transport, Threads},\n-};\n-\n-/// Main entry point: runs the server from initialization to shutdown.\n-/// To attach server to standard input/output streams, use the `stdio_transport`\n-/// function to create corresponding `sender` and `receiver` pair.\n-///\n-/// `server` should use the `handle_shutdown` function to handle the `Shutdown`\n-/// request.\n-pub fn run_server(\n-    caps: ServerCapabilities,\n-    receiver: Receiver<RawMessage>,\n-    sender: Sender<RawMessage>,\n-    server: impl FnOnce(InitializeParams, &Receiver<RawMessage>, &Sender<RawMessage>) -> Result<()>,\n-) -> Result<()> {\n-    log::info!(\"lsp server initializes\");\n-    let params = initialize(&receiver, &sender, caps)?;\n-    log::info!(\"lsp server initialized, serving requests\");\n-    server(params, &receiver, &sender)?;\n-    log::info!(\"lsp server waiting for exit notification\");\n-    match receiver.recv() {\n-        Ok(RawMessage::Notification(n)) => n\n-            .cast::<Exit>()\n-            .map_err(|n| format!(\"unexpected notification during shutdown: {:?}\", n))?,\n-        m => Err(format!(\"unexpected message during shutdown: {:?}\", m))?,\n-    }\n-    log::info!(\"lsp server shutdown complete\");\n-    Ok(())\n-}\n-\n-/// If `req` is `Shutdown`, respond to it and return `None`, otherwise return `Some(req)`\n-pub fn handle_shutdown(req: RawRequest, sender: &Sender<RawMessage>) -> Option<RawRequest> {\n-    match req.cast::<Shutdown>() {\n-        Ok((id, ())) => {\n-            let resp = RawResponse::ok::<Shutdown>(id, &());\n-            let _ = sender.send(RawMessage::Response(resp));\n-            None\n-        }\n-        Err(req) => Some(req),\n-    }\n-}\n-\n-fn initialize(\n-    receiver: &Receiver<RawMessage>,\n-    sender: &Sender<RawMessage>,\n-    caps: ServerCapabilities,\n-) -> Result<InitializeParams> {\n-    let (id, params) = match receiver.recv() {\n-        Ok(RawMessage::Request(req)) => match req.cast::<Initialize>() {\n-            Err(req) => Err(format!(\"expected initialize request, got {:?}\", req))?,\n-            Ok(req) => req,\n-        },\n-        msg => Err(format!(\"expected initialize request, got {:?}\", msg))?,\n-    };\n-    let resp = RawResponse::ok::<Initialize>(id, &InitializeResult { capabilities: caps });\n-    sender.send(RawMessage::Response(resp)).unwrap();\n-    match receiver.recv() {\n-        Ok(RawMessage::Notification(n)) => {\n-            n.cast::<Initialized>().map_err(|_| \"expected initialized notification\")?;\n-        }\n-        _ => Err(\"expected initialized notification\".to_string())?,\n-    }\n-    Ok(params)\n-}"}, {"sha": "2928e4f8bdef52455432345aebfd4f4eb8e2ccf2", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,205 +0,0 @@\n-use std::io::{BufRead, Write};\n-\n-use lsp_types::{notification::Notification, request::Request};\n-use serde::{Deserialize, Serialize};\n-use serde_json::{from_str, from_value, to_string, to_value, Value};\n-\n-use crate::Result;\n-\n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-#[serde(untagged)]\n-pub enum RawMessage {\n-    Request(RawRequest),\n-    Notification(RawNotification),\n-    Response(RawResponse),\n-}\n-\n-impl From<RawRequest> for RawMessage {\n-    fn from(raw: RawRequest) -> RawMessage {\n-        RawMessage::Request(raw)\n-    }\n-}\n-\n-impl From<RawNotification> for RawMessage {\n-    fn from(raw: RawNotification) -> RawMessage {\n-        RawMessage::Notification(raw)\n-    }\n-}\n-\n-impl From<RawResponse> for RawMessage {\n-    fn from(raw: RawResponse) -> RawMessage {\n-        RawMessage::Response(raw)\n-    }\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct RawRequest {\n-    pub id: u64,\n-    pub method: String,\n-    pub params: Value,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct RawResponse {\n-    // JSON RPC allows this to be null if it was impossible\n-    // to decode the request's id. Ignore this special case\n-    // and just die horribly.\n-    pub id: u64,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub result: Option<Value>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub error: Option<RawResponseError>,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct RawResponseError {\n-    pub code: i32,\n-    pub message: String,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub data: Option<Value>,\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-#[allow(unused)]\n-pub enum ErrorCode {\n-    ParseError = -32700,\n-    InvalidRequest = -32600,\n-    MethodNotFound = -32601,\n-    InvalidParams = -32602,\n-    InternalError = -32603,\n-    ServerErrorStart = -32099,\n-    ServerErrorEnd = -32000,\n-    ServerNotInitialized = -32002,\n-    UnknownErrorCode = -32001,\n-    RequestCanceled = -32800,\n-    ContentModified = -32801,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct RawNotification {\n-    pub method: String,\n-    pub params: Value,\n-}\n-\n-impl RawMessage {\n-    pub fn read(r: &mut impl BufRead) -> Result<Option<RawMessage>> {\n-        let text = match read_msg_text(r)? {\n-            None => return Ok(None),\n-            Some(text) => text,\n-        };\n-        let msg = from_str(&text)?;\n-        Ok(Some(msg))\n-    }\n-    pub fn write(self, w: &mut impl Write) -> Result<()> {\n-        #[derive(Serialize)]\n-        struct JsonRpc {\n-            jsonrpc: &'static str,\n-            #[serde(flatten)]\n-            msg: RawMessage,\n-        }\n-        let text = to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n-        write_msg_text(w, &text)?;\n-        Ok(())\n-    }\n-}\n-\n-impl RawRequest {\n-    pub fn new<R>(id: u64, params: &R::Params) -> RawRequest\n-    where\n-        R: Request,\n-        R::Params: serde::Serialize,\n-    {\n-        RawRequest { id, method: R::METHOD.to_string(), params: to_value(params).unwrap() }\n-    }\n-    pub fn cast<R>(self) -> ::std::result::Result<(u64, R::Params), RawRequest>\n-    where\n-        R: Request,\n-        R::Params: serde::de::DeserializeOwned,\n-    {\n-        if self.method != R::METHOD {\n-            return Err(self);\n-        }\n-        let id = self.id;\n-        let params: R::Params = from_value(self.params).unwrap();\n-        Ok((id, params))\n-    }\n-}\n-\n-impl RawResponse {\n-    pub fn ok<R>(id: u64, result: &R::Result) -> RawResponse\n-    where\n-        R: Request,\n-        R::Result: serde::Serialize,\n-    {\n-        RawResponse { id, result: Some(to_value(&result).unwrap()), error: None }\n-    }\n-    pub fn err(id: u64, code: i32, message: String) -> RawResponse {\n-        let error = RawResponseError { code, message, data: None };\n-        RawResponse { id, result: None, error: Some(error) }\n-    }\n-}\n-\n-impl RawNotification {\n-    pub fn new<N>(params: &N::Params) -> RawNotification\n-    where\n-        N: Notification,\n-        N::Params: serde::Serialize,\n-    {\n-        RawNotification { method: N::METHOD.to_string(), params: to_value(params).unwrap() }\n-    }\n-    pub fn is<N>(&self) -> bool\n-    where\n-        N: Notification,\n-    {\n-        self.method == N::METHOD\n-    }\n-    pub fn cast<N>(self) -> ::std::result::Result<N::Params, RawNotification>\n-    where\n-        N: Notification,\n-        N::Params: serde::de::DeserializeOwned,\n-    {\n-        if !self.is::<N>() {\n-            return Err(self);\n-        }\n-        Ok(from_value(self.params).unwrap())\n-    }\n-}\n-\n-fn read_msg_text(inp: &mut impl BufRead) -> Result<Option<String>> {\n-    let mut size = None;\n-    let mut buf = String::new();\n-    loop {\n-        buf.clear();\n-        if inp.read_line(&mut buf)? == 0 {\n-            return Ok(None);\n-        }\n-        if !buf.ends_with(\"\\r\\n\") {\n-            Err(format!(\"malformed header: {:?}\", buf))?;\n-        }\n-        let buf = &buf[..buf.len() - 2];\n-        if buf.is_empty() {\n-            break;\n-        }\n-        let mut parts = buf.splitn(2, \": \");\n-        let header_name = parts.next().unwrap();\n-        let header_value = parts.next().ok_or_else(|| format!(\"malformed header: {:?}\", buf))?;\n-        if header_name == \"Content-Length\" {\n-            size = Some(header_value.parse::<usize>()?);\n-        }\n-    }\n-    let size = size.ok_or(\"no Content-Length\")?;\n-    let mut buf = buf.into_bytes();\n-    buf.resize(size, 0);\n-    inp.read_exact(&mut buf)?;\n-    let buf = String::from_utf8(buf)?;\n-    log::debug!(\"< {}\", buf);\n-    Ok(Some(buf))\n-}\n-\n-fn write_msg_text(out: &mut impl Write, msg: &str) -> Result<()> {\n-    log::debug!(\"> {}\", msg);\n-    write!(out, \"Content-Length: {}\\r\\n\\r\\n\", msg.len())?;\n-    out.write_all(msg.as_bytes())?;\n-    out.flush()?;\n-    Ok(())\n-}"}, {"sha": "f8931f2dcea7fdea2fe40ecdbed7c7b2fcb16ac5", "filename": "crates/gen_lsp_server/src/stdio.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d72ca80003b7915ed7fc64907b5b6dc5c88dacd/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs?ref=7d72ca80003b7915ed7fc64907b5b6dc5c88dacd", "patch": "@@ -1,57 +0,0 @@\n-use std::{\n-    io::{stdin, stdout},\n-    thread,\n-};\n-\n-use crossbeam_channel::{bounded, Receiver, Sender};\n-use lsp_types::notification::Exit;\n-\n-use crate::{RawMessage, Result};\n-\n-pub fn stdio_transport() -> (Receiver<RawMessage>, Sender<RawMessage>, Threads) {\n-    let (writer_sender, writer_receiver) = bounded::<RawMessage>(16);\n-    let writer = thread::spawn(move || {\n-        let stdout = stdout();\n-        let mut stdout = stdout.lock();\n-        writer_receiver.into_iter().try_for_each(|it| it.write(&mut stdout))?;\n-        Ok(())\n-    });\n-    let (reader_sender, reader_receiver) = bounded::<RawMessage>(16);\n-    let reader = thread::spawn(move || {\n-        let stdin = stdin();\n-        let mut stdin = stdin.lock();\n-        while let Some(msg) = RawMessage::read(&mut stdin)? {\n-            let is_exit = match &msg {\n-                RawMessage::Notification(n) => n.is::<Exit>(),\n-                _ => false,\n-            };\n-\n-            reader_sender.send(msg).unwrap();\n-\n-            if is_exit {\n-                break;\n-            }\n-        }\n-        Ok(())\n-    });\n-    let threads = Threads { reader, writer };\n-    (reader_receiver, writer_sender, threads)\n-}\n-\n-pub struct Threads {\n-    reader: thread::JoinHandle<Result<()>>,\n-    writer: thread::JoinHandle<Result<()>>,\n-}\n-\n-impl Threads {\n-    pub fn join(self) -> Result<()> {\n-        match self.reader.join() {\n-            Ok(r) => r?,\n-            Err(_) => Err(\"reader panicked\")?,\n-        }\n-        match self.writer.join() {\n-            Ok(r) => r,\n-            Err(_) => Err(\"writer panicked\")?,\n-        }\n-    }\n-}"}, {"sha": "084a20cd98815a64eaa9ad36e55caf61073a4a48", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -21,7 +21,7 @@ thread_worker = { path = \"../thread_worker\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_ide_api = { path = \"../ra_ide_api\" }\n-gen_lsp_server = { path = \"../gen_lsp_server\" }\n+lsp-server = \"0.1.0\"\n ra_project_model = { path = \"../ra_project_model\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_vfs_glob = { path = \"../ra_vfs_glob\" }"}, {"sha": "1debe766082b4fb805b5c56cbb2d0a660f0da328", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -1,5 +1,5 @@\n use flexi_logger::{Duplicate, Logger};\n-use gen_lsp_server::{run_server, stdio_transport};\n+use lsp_server::{run_server, stdio_transport, LspServerError};\n \n use ra_lsp_server::{show_message, Result, ServerConfig};\n use ra_prof;\n@@ -29,9 +29,11 @@ fn main() -> Result<()> {\n }\n \n fn main_inner() -> Result<()> {\n-    let (receiver, sender, threads) = stdio_transport();\n+    let (sender, receiver, io_threads) = stdio_transport();\n     let cwd = std::env::current_dir()?;\n-    run_server(ra_lsp_server::server_capabilities(), receiver, sender, |params, r, s| {\n+    let caps = serde_json::to_value(ra_lsp_server::server_capabilities()).unwrap();\n+    run_server(caps, sender, receiver, |params, s, r| {\n+        let params: lsp_types::InitializeParams = serde_json::from_value(params)?;\n         let root = params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n \n         let workspace_roots = params\n@@ -62,9 +64,13 @@ fn main_inner() -> Result<()> {\n             .unwrap_or_default();\n \n         ra_lsp_server::main_loop(workspace_roots, params.capabilities, server_config, r, s)\n+    })\n+    .map_err(|err| match err {\n+        LspServerError::ProtocolError(err) => err.into(),\n+        LspServerError::ServerError(err) => err,\n     })?;\n     log::info!(\"shutting down IO...\");\n-    threads.join()?;\n+    io_threads.join()?;\n     log::info!(\"... IO is down\");\n     Ok(())\n }"}, {"sha": "fb357b36bb5eb9c2b0f193dd3dc0e6b8043b9aac", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 76, "deletions": 65, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -5,9 +5,7 @@ pub(crate) mod pending_requests;\n use std::{error::Error, fmt, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, Receiver, RecvError, Sender};\n-use gen_lsp_server::{\n-    handle_shutdown, ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse,\n-};\n+use lsp_server::{handle_shutdown, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{ClientCapabilities, NumberOrString};\n use ra_ide_api::{Canceled, FeatureFlags, FileId, LibraryData};\n use ra_prof::profile;\n@@ -53,8 +51,8 @@ pub fn main_loop(\n     ws_roots: Vec<PathBuf>,\n     client_caps: ClientCapabilities,\n     config: ServerConfig,\n-    msg_receiver: &Receiver<RawMessage>,\n-    msg_sender: &Sender<RawMessage>,\n+    msg_receiver: &Receiver<Message>,\n+    msg_sender: &Sender<Message>,\n ) -> Result<()> {\n     log::info!(\"server_config: {:#?}\", config);\n     // FIXME: support dynamic workspace loading.\n@@ -146,37 +144,41 @@ pub fn main_loop(\n \n #[derive(Debug)]\n enum Task {\n-    Respond(RawResponse),\n-    Notify(RawNotification),\n+    Respond(Response),\n+    Notify(Notification),\n }\n \n enum Event {\n-    Msg(RawMessage),\n+    Msg(Message),\n     Task(Task),\n     Vfs(VfsTask),\n     Lib(LibraryData),\n }\n \n impl fmt::Debug for Event {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let debug_verbose_not = |not: &RawNotification, f: &mut fmt::Formatter| {\n-            f.debug_struct(\"RawNotification\").field(\"method\", &not.method).finish()\n+        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter| {\n+            f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n         };\n \n         match self {\n-            Event::Msg(RawMessage::Notification(not)) => {\n-                if not.is::<req::DidOpenTextDocument>() || not.is::<req::DidChangeTextDocument>() {\n+            Event::Msg(Message::Notification(not)) => {\n+                if notification_is::<req::DidOpenTextDocument>(not)\n+                    || notification_is::<req::DidChangeTextDocument>(not)\n+                {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n             Event::Task(Task::Notify(not)) => {\n-                if not.is::<req::PublishDecorations>() || not.is::<req::PublishDiagnostics>() {\n+                if notification_is::<req::PublishDecorations>(not)\n+                    || notification_is::<req::PublishDiagnostics>(not)\n+                {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n             Event::Task(Task::Respond(resp)) => {\n                 return f\n-                    .debug_struct(\"RawResponse\")\n+                    .debug_struct(\"Response\")\n                     .field(\"id\", &resp.id)\n                     .field(\"error\", &resp.error)\n                     .finish();\n@@ -194,8 +196,8 @@ impl fmt::Debug for Event {\n \n fn main_loop_inner(\n     pool: &ThreadPool,\n-    msg_sender: &Sender<RawMessage>,\n-    msg_receiver: &Receiver<RawMessage>,\n+    msg_sender: &Sender<Message>,\n+    msg_receiver: &Receiver<Message>,\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n     state: &mut WorldState,\n@@ -249,10 +251,9 @@ fn main_loop_inner(\n                 in_flight_libraries -= 1;\n             }\n             Event::Msg(msg) => match msg {\n-                RawMessage::Request(req) => {\n-                    let req = match handle_shutdown(req, msg_sender) {\n-                        Some(req) => req,\n-                        None => return Ok(()),\n+                Message::Request(req) => {\n+                    if handle_shutdown(&req, msg_sender) {\n+                        return Ok(());\n                     };\n                     on_request(\n                         state,\n@@ -264,11 +265,11 @@ fn main_loop_inner(\n                         req,\n                     )?\n                 }\n-                RawMessage::Notification(not) => {\n+                Message::Notification(not) => {\n                     on_notification(msg_sender, state, pending_requests, &mut subs, not)?;\n                     state_changed = true;\n                 }\n-                RawMessage::Response(resp) => log::error!(\"unexpected response: {:?}\", resp),\n+                Message::Response(resp) => log::error!(\"unexpected response: {:?}\", resp),\n             },\n         };\n \n@@ -313,13 +314,13 @@ fn main_loop_inner(\n \n fn on_task(\n     task: Task,\n-    msg_sender: &Sender<RawMessage>,\n+    msg_sender: &Sender<Message>,\n     pending_requests: &mut PendingRequests,\n     state: &mut WorldState,\n ) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some(completed) = pending_requests.finish(response.id) {\n+            if let Some(completed) = pending_requests.finish(&response.id) {\n                 log::info!(\"handled req#{} in {:?}\", completed.id, completed.duration);\n                 state.complete_request(completed);\n                 msg_sender.send(response.into()).unwrap();\n@@ -336,9 +337,9 @@ fn on_request(\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n-    msg_sender: &Sender<RawMessage>,\n+    msg_sender: &Sender<Message>,\n     request_received: Instant,\n-    req: RawRequest,\n+    req: Request,\n ) -> Result<()> {\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n@@ -388,22 +389,20 @@ fn on_request(\n }\n \n fn on_notification(\n-    msg_sender: &Sender<RawMessage>,\n+    msg_sender: &Sender<Message>,\n     state: &mut WorldState,\n     pending_requests: &mut PendingRequests,\n     subs: &mut Subscriptions,\n-    not: RawNotification,\n+    not: Notification,\n ) -> Result<()> {\n-    let not = match not.cast::<req::Cancel>() {\n+    let not = match notification_cast::<req::Cancel>(not) {\n         Ok(params) => {\n-            let id = match params.id {\n-                NumberOrString::Number(id) => id,\n-                NumberOrString::String(id) => {\n-                    panic!(\"string id's not supported: {:?}\", id);\n-                }\n+            let id: RequestId = match params.id {\n+                NumberOrString::Number(id) => id.into(),\n+                NumberOrString::String(id) => id.into(),\n             };\n-            if pending_requests.cancel(id) {\n-                let response = RawResponse::err(\n+            if pending_requests.cancel(&id) {\n+                let response = Response::new_err(\n                     id,\n                     ErrorCode::RequestCanceled as i32,\n                     \"canceled by client\".to_string(),\n@@ -414,7 +413,7 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match not.cast::<req::DidOpenTextDocument>() {\n+    let not = match notification_cast::<req::DidOpenTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n@@ -427,7 +426,7 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match not.cast::<req::DidChangeTextDocument>() {\n+    let not = match notification_cast::<req::DidChangeTextDocument>(not) {\n         Ok(mut params) => {\n             let uri = params.text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n@@ -438,21 +437,21 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match not.cast::<req::DidCloseTextDocument>() {\n+    let not = match notification_cast::<req::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n             if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n                 subs.remove_sub(FileId(file_id.0));\n             }\n             let params = req::PublishDiagnosticsParams { uri, diagnostics: Vec::new() };\n-            let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n+            let not = notification_new::<req::PublishDiagnostics>(params);\n             msg_sender.send(not.into()).unwrap();\n             return Ok(());\n         }\n         Err(not) => not,\n     };\n-    let not = match not.cast::<req::DidChangeConfiguration>() {\n+    let not = match notification_cast::<req::DidChangeConfiguration>(not) {\n         Ok(_params) => {\n             return Ok(());\n         }\n@@ -463,11 +462,11 @@ fn on_notification(\n }\n \n struct PoolDispatcher<'a> {\n-    req: Option<RawRequest>,\n+    req: Option<Request>,\n     pool: &'a ThreadPool,\n     world: &'a mut WorldState,\n     pending_requests: &'a mut PendingRequests,\n-    msg_sender: &'a Sender<RawMessage>,\n+    msg_sender: &'a Sender<Message>,\n     sender: &'a Sender<Task>,\n     request_received: Instant,\n }\n@@ -522,21 +521,21 @@ impl<'a> PoolDispatcher<'a> {\n         Ok(self)\n     }\n \n-    fn parse<R>(&mut self) -> Option<(u64, R::Params)>\n+    fn parse<R>(&mut self) -> Option<(RequestId, R::Params)>\n     where\n         R: req::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n     {\n         let req = self.req.take()?;\n-        let (id, params) = match req.cast::<R>() {\n+        let (id, params) = match req.extract::<R::Params>(R::METHOD) {\n             Ok(it) => it,\n             Err(req) => {\n                 self.req = Some(req);\n                 return None;\n             }\n         };\n         self.pending_requests.start(PendingRequest {\n-            id,\n+            id: id.clone(),\n             method: R::METHOD.to_string(),\n             received: self.request_received,\n         });\n@@ -548,7 +547,7 @@ impl<'a> PoolDispatcher<'a> {\n             None => (),\n             Some(req) => {\n                 log::error!(\"unknown request: {:?}\", req);\n-                let resp = RawResponse::err(\n+                let resp = Response::new_err(\n                     req.id,\n                     ErrorCode::MethodNotFound as i32,\n                     \"unknown request\".to_string(),\n@@ -559,34 +558,30 @@ impl<'a> PoolDispatcher<'a> {\n     }\n }\n \n-fn result_to_task<R>(id: u64, result: Result<R::Result>) -> Task\n+fn result_to_task<R>(id: RequestId, result: Result<R::Result>) -> Task\n where\n     R: req::Request + 'static,\n     R::Params: DeserializeOwned + Send + 'static,\n     R::Result: Serialize + 'static,\n {\n     let response = match result {\n-        Ok(resp) => RawResponse::ok::<R>(id, &resp),\n+        Ok(resp) => Response::new_ok(id, &resp),\n         Err(e) => match e.downcast::<LspError>() {\n-            Ok(lsp_error) => RawResponse::err(id, lsp_error.code, lsp_error.message),\n+            Ok(lsp_error) => Response::new_err(id, lsp_error.code, lsp_error.message),\n             Err(e) => {\n                 if is_canceled(&e) {\n                     // FIXME: When https://github.com/Microsoft/vscode-languageserver-node/issues/457\n                     // gets fixed, we can return the proper response.\n                     // This works around the issue where \"content modified\" error would continuously\n                     // show an message pop-up in VsCode\n-                    // RawResponse::err(\n+                    // Response::err(\n                     //     id,\n                     //     ErrorCode::ContentModified as i32,\n                     //     \"content modified\".to_string(),\n                     // )\n-                    RawResponse {\n-                        id,\n-                        result: Some(serde_json::to_value(&()).unwrap()),\n-                        error: None,\n-                    }\n+                    Response::new_ok(id, ())\n                 } else {\n-                    RawResponse::err(id, ErrorCode::InternalError as i32, e.to_string())\n+                    Response::new_err(id, ErrorCode::InternalError as i32, e.to_string())\n                 }\n             }\n         },\n@@ -613,7 +608,7 @@ fn update_file_notifications_on_threadpool(\n                         }\n                     }\n                     Ok(params) => {\n-                        let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n+                        let not = notification_new::<req::PublishDiagnostics>(params);\n                         sender.send(Task::Notify(not)).unwrap();\n                     }\n                 }\n@@ -626,7 +621,7 @@ fn update_file_notifications_on_threadpool(\n                         }\n                     }\n                     Ok(params) => {\n-                        let not = RawNotification::new::<req::PublishDecorations>(&params);\n+                        let not = notification_new::<req::PublishDecorations>(params);\n                         sender.send(Task::Notify(not)).unwrap();\n                     }\n                 }\n@@ -635,17 +630,33 @@ fn update_file_notifications_on_threadpool(\n     });\n }\n \n-pub fn show_message(\n-    typ: req::MessageType,\n-    message: impl Into<String>,\n-    sender: &Sender<RawMessage>,\n-) {\n+pub fn show_message(typ: req::MessageType, message: impl Into<String>, sender: &Sender<Message>) {\n     let message = message.into();\n     let params = req::ShowMessageParams { typ, message };\n-    let not = RawNotification::new::<req::ShowMessage>(&params);\n+    let not = notification_new::<req::ShowMessage>(params);\n     sender.send(not.into()).unwrap();\n }\n \n fn is_canceled(e: &Box<dyn std::error::Error + Send + Sync>) -> bool {\n     e.downcast_ref::<Canceled>().is_some()\n }\n+\n+fn notification_is<N: lsp_types::notification::Notification>(notification: &Notification) -> bool {\n+    notification.method == N::METHOD\n+}\n+\n+fn notification_cast<N>(notification: Notification) -> std::result::Result<N::Params, Notification>\n+where\n+    N: lsp_types::notification::Notification,\n+    N::Params: DeserializeOwned,\n+{\n+    notification.extract(N::METHOD)\n+}\n+\n+fn notification_new<N>(params: N::Params) -> Notification\n+where\n+    N: lsp_types::notification::Notification,\n+    N::Params: Serialize,\n+{\n+    Notification::new(N::METHOD.to_string(), params)\n+}"}, {"sha": "eb805a6d3918ae1717df2c769177a1b6a2e9aaaa", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -1,6 +1,6 @@\n use std::{fmt::Write as _, io::Write as _};\n \n-use gen_lsp_server::ErrorCode;\n+use lsp_server::ErrorCode;\n use lsp_types::{\n     CodeAction, CodeActionResponse, CodeLens, Command, CompletionItem, Diagnostic,\n     DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange, FoldingRangeKind,"}, {"sha": "7a99fc679901f90b62da269b2c48c106bed63369", "filename": "crates/ra_lsp_server/src/main_loop/pending_requests.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -1,17 +1,18 @@\n use std::time::{Duration, Instant};\n \n+use lsp_server::RequestId;\n use rustc_hash::FxHashMap;\n \n #[derive(Debug)]\n pub struct CompletedRequest {\n-    pub id: u64,\n+    pub id: RequestId,\n     pub method: String,\n     pub duration: Duration,\n }\n \n #[derive(Debug)]\n pub(crate) struct PendingRequest {\n-    pub(crate) id: u64,\n+    pub(crate) id: RequestId,\n     pub(crate) method: String,\n     pub(crate) received: Instant,\n }\n@@ -28,20 +29,20 @@ impl From<PendingRequest> for CompletedRequest {\n \n #[derive(Debug, Default)]\n pub(crate) struct PendingRequests {\n-    map: FxHashMap<u64, PendingRequest>,\n+    map: FxHashMap<RequestId, PendingRequest>,\n }\n \n impl PendingRequests {\n     pub(crate) fn start(&mut self, request: PendingRequest) {\n-        let id = request.id;\n-        let prev = self.map.insert(id, request);\n+        let id = request.id.clone();\n+        let prev = self.map.insert(id.clone(), request);\n         assert!(prev.is_none(), \"duplicate request with id {}\", id);\n     }\n-    pub(crate) fn cancel(&mut self, id: u64) -> bool {\n-        self.map.remove(&id).is_some()\n+    pub(crate) fn cancel(&mut self, id: &RequestId) -> bool {\n+        self.map.remove(id).is_some()\n     }\n-    pub(crate) fn finish(&mut self, id: u64) -> Option<CompletedRequest> {\n-        self.map.remove(&id).map(CompletedRequest::from)\n+    pub(crate) fn finish(&mut self, id: &RequestId) -> Option<CompletedRequest> {\n+        self.map.remove(id).map(CompletedRequest::from)\n     }\n }\n "}, {"sha": "73d7f8fb9bcfccea3e23119294ce03bc5f96179d", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -4,7 +4,7 @@ use std::{\n };\n \n use crossbeam_channel::{unbounded, Receiver};\n-use gen_lsp_server::ErrorCode;\n+use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n use ra_ide_api::{"}, {"sha": "45b4cacf6a2d7d2b542499d17efb8143c6aeaeaa", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc95759c7b538d8dacc336912b62857d4919cdd/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=ffc95759c7b538d8dacc336912b62857d4919cdd", "patch": "@@ -8,13 +8,10 @@ use std::{\n \n use crossbeam_channel::{after, select, Receiver};\n use flexi_logger::Logger;\n-use gen_lsp_server::{RawMessage, RawNotification, RawRequest};\n+use lsp_server::{Message, Notification, Request};\n use lsp_types::{\n-    notification::DidOpenTextDocument,\n-    notification::{Notification, ShowMessage},\n-    request::{Request, Shutdown},\n-    ClientCapabilities, DidOpenTextDocumentParams, GotoCapability, TextDocumentClientCapabilities,\n-    TextDocumentIdentifier, TextDocumentItem, Url,\n+    request::Shutdown, ClientCapabilities, DidOpenTextDocumentParams, GotoCapability,\n+    TextDocumentClientCapabilities, TextDocumentIdentifier, TextDocumentItem, Url,\n };\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n@@ -84,9 +81,9 @@ pub fn project(fixture: &str) -> Server {\n \n pub struct Server {\n     req_id: Cell<u64>,\n-    messages: RefCell<Vec<RawMessage>>,\n+    messages: RefCell<Vec<Message>>,\n     dir: TempDir,\n-    worker: Worker<RawMessage, RawMessage>,\n+    worker: Worker<Message, Message>,\n }\n \n impl Server {\n@@ -100,7 +97,7 @@ impl Server {\n \n         let roots = if roots.is_empty() { vec![path] } else { roots };\n \n-        let worker = Worker::<RawMessage, RawMessage>::spawn(\n+        let worker = Worker::<Message, Message>::spawn(\n             \"test server\",\n             128,\n             move |msg_receiver, msg_sender| {\n@@ -128,7 +125,8 @@ impl Server {\n         let res = Server { req_id: Cell::new(1), dir, messages: Default::default(), worker };\n \n         for (path, text) in files {\n-            res.send_notification(RawNotification::new::<DidOpenTextDocument>(\n+            res.send_notification(Notification::new(\n+                \"textDocument/didOpen\".to_string(),\n                 &DidOpenTextDocumentParams {\n                     text_document: TextDocumentItem {\n                         uri: Url::from_file_path(path).unwrap(),\n@@ -149,16 +147,16 @@ impl Server {\n \n     pub fn notification<N>(&self, params: N::Params)\n     where\n-        N: Notification,\n+        N: lsp_types::notification::Notification,\n         N::Params: Serialize,\n     {\n-        let r = RawNotification::new::<N>(&params);\n+        let r = Notification::new(N::METHOD.to_string(), params);\n         self.send_notification(r)\n     }\n \n     pub fn request<R>(&self, params: R::Params, expected_resp: Value)\n     where\n-        R: Request,\n+        R: lsp_types::request::Request,\n         R::Params: Serialize,\n     {\n         let actual = self.send_request::<R>(params);\n@@ -175,23 +173,23 @@ impl Server {\n \n     pub fn send_request<R>(&self, params: R::Params) -> Value\n     where\n-        R: Request,\n+        R: lsp_types::request::Request,\n         R::Params: Serialize,\n     {\n         let id = self.req_id.get();\n         self.req_id.set(id + 1);\n \n-        let r = RawRequest::new::<R>(id, &params);\n+        let r = Request::new(id.into(), R::METHOD.to_string(), params);\n         self.send_request_(r)\n     }\n-    fn send_request_(&self, r: RawRequest) -> Value {\n-        let id = r.id;\n-        self.worker.sender().send(RawMessage::Request(r)).unwrap();\n+    fn send_request_(&self, r: Request) -> Value {\n+        let id = r.id.clone();\n+        self.worker.sender().send(r.into()).unwrap();\n         while let Some(msg) = self.recv() {\n             match msg {\n-                RawMessage::Request(req) => panic!(\"unexpected request: {:?}\", req),\n-                RawMessage::Notification(_) => (),\n-                RawMessage::Response(res) => {\n+                Message::Request(req) => panic!(\"unexpected request: {:?}\", req),\n+                Message::Notification(_) => (),\n+                Message::Response(res) => {\n                     assert_eq!(res.id, id);\n                     if let Some(err) = res.error {\n                         panic!(\"error response: {:#?}\", err);\n@@ -203,15 +201,16 @@ impl Server {\n         panic!(\"no response\");\n     }\n     pub fn wait_until_workspace_is_loaded(&self) {\n-        self.wait_for_message_cond(1, &|msg: &RawMessage| match msg {\n-            RawMessage::Notification(n) if n.method == ShowMessage::METHOD => {\n-                let msg = n.clone().cast::<req::ShowMessage>().unwrap();\n+        self.wait_for_message_cond(1, &|msg: &Message| match msg {\n+            Message::Notification(n) if n.method == \"window/showMessage\" => {\n+                let msg =\n+                    n.clone().extract::<req::ShowMessageParams>(\"window/showMessage\").unwrap();\n                 msg.message.starts_with(\"workspace loaded\")\n             }\n             _ => false,\n         })\n     }\n-    fn wait_for_message_cond(&self, n: usize, cond: &dyn Fn(&RawMessage) -> bool) {\n+    fn wait_for_message_cond(&self, n: usize, cond: &dyn Fn(&Message) -> bool) {\n         let mut total = 0;\n         for msg in self.messages.borrow().iter() {\n             if cond(msg) {\n@@ -225,14 +224,14 @@ impl Server {\n             }\n         }\n     }\n-    fn recv(&self) -> Option<RawMessage> {\n+    fn recv(&self) -> Option<Message> {\n         recv_timeout(&self.worker.receiver()).map(|msg| {\n             self.messages.borrow_mut().push(msg.clone());\n             msg\n         })\n     }\n-    fn send_notification(&self, not: RawNotification) {\n-        self.worker.sender().send(RawMessage::Notification(not)).unwrap();\n+    fn send_notification(&self, not: Notification) {\n+        self.worker.sender().send(Message::Notification(not)).unwrap();\n     }\n \n     pub fn path(&self) -> &Path {\n@@ -246,7 +245,7 @@ impl Drop for Server {\n     }\n }\n \n-fn recv_timeout(receiver: &Receiver<RawMessage>) -> Option<RawMessage> {\n+fn recv_timeout(receiver: &Receiver<Message>) -> Option<Message> {\n     let timeout = Duration::from_secs(120);\n     select! {\n         recv(receiver) -> msg => msg.ok(),"}]}