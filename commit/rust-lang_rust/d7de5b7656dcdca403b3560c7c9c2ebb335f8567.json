{"sha": "d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZGU1Yjc2NTZkY2RjYTQwM2IzNTYwYzdjOWMyZWJiMzM1Zjg1Njc=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-04T14:27:21Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-04T14:27:21Z"}, "message": "Allow comments after attributes on enum fields", "tree": {"sha": "41ed9fb4cd58f7c7463600815d36c3c9eed31661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ed9fb4cd58f7c7463600815d36c3c9eed31661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "html_url": "https://github.com/rust-lang/rust/commit/d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e25e628a152bb78cd42b0b81852a63d6e0ab204", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e25e628a152bb78cd42b0b81852a63d6e0ab204", "html_url": "https://github.com/rust-lang/rust/commit/3e25e628a152bb78cd42b0b81852a63d6e0ab204"}], "stats": {"total": 98, "additions": 74, "deletions": 24}, "files": [{"sha": "777b9df1f05a40d7f7d569ef9463cf44ae3f8164", "filename": "src/items.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "patch": "@@ -456,15 +456,30 @@ impl<'a> FmtVisitor<'a> {\n             return Some(self.snippet(span));\n         }\n \n+        let context = self.get_context();\n         let indent = self.block_indent;\n-        let mut result = try_opt!(field.node.attrs.rewrite(&self.get_context(),\n-                                                           Shape::indented(indent, self.config)));\n+        let mut result = try_opt!(field\n+                                      .node\n+                                      .attrs\n+                                      .rewrite(&context, Shape::indented(indent, self.config)));\n         if !result.is_empty() {\n-            result.push('\\n');\n-            result.push_str(&indent.to_string(self.config));\n+            let shape = Shape {\n+                width: context.config.max_width(),\n+                indent: self.block_indent,\n+                offset: self.block_indent.alignment,\n+            };\n+            let missing_comment =\n+                rewrite_missing_comment_on_field(&context,\n+                                                 shape,\n+                                                 field.node.attrs[field.node.attrs.len() - 1]\n+                                                     .span\n+                                                     .hi,\n+                                                 field.span.lo,\n+                                                 &mut result)\n+                    .unwrap_or(String::new());\n+            result.push_str(&missing_comment);\n         }\n \n-        let context = self.get_context();\n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) |\n             ast::VariantData::Struct(..) => {\n@@ -1194,6 +1209,31 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n      })\n }\n \n+fn rewrite_missing_comment_on_field(context: &RewriteContext,\n+                                    shape: Shape,\n+                                    lo: BytePos,\n+                                    hi: BytePos,\n+                                    result: &mut String)\n+                                    -> Option<String> {\n+    let possibly_comment_snippet = context.snippet(mk_sp(lo, hi));\n+    let newline_index = possibly_comment_snippet.find('\\n');\n+    let comment_index = possibly_comment_snippet.find('/');\n+    match (newline_index, comment_index) {\n+        (Some(i), Some(j)) if i > j => result.push(' '),\n+        _ => {\n+            result.push('\\n');\n+            result.push_str(&shape.indent.to_string(context.config));\n+        }\n+    }\n+    let trimmed = possibly_comment_snippet.trim();\n+    if trimmed.is_empty() {\n+        None\n+    } else {\n+        rewrite_comment(trimmed, false, shape, context.config)\n+            .map(|s| format!(\"{}\\n{}\", s, shape.indent.to_string(context.config)))\n+    }\n+}\n+\n impl Rewrite for ast::StructField {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if contains_skip(&self.attrs) {\n@@ -1208,25 +1248,12 @@ impl Rewrite for ast::StructField {\n                                                                        context.config)));\n         // Try format missing comments after attributes\n         let missing_comment = if !self.attrs.is_empty() {\n-            let possibly_comment_snippet =\n-                context.snippet(mk_sp(self.attrs[self.attrs.len() - 1].span.hi, self.span.lo));\n-            let newline_index = possibly_comment_snippet.find('\\n');\n-            let comment_index = possibly_comment_snippet.find('/');\n-            match (newline_index, comment_index) {\n-                (Some(i), Some(j)) if i > j => attr_str.push(' '),\n-                _ => {\n-                    attr_str.push('\\n');\n-                    attr_str.push_str(&shape.indent.to_string(context.config));\n-                }\n-            }\n-            let trimmed = possibly_comment_snippet.trim();\n-            if trimmed.is_empty() {\n-                String::new()\n-            } else {\n-                rewrite_comment(trimmed, false, shape, context.config).map_or(String::new(), |s| {\n-                    format!(\"{}\\n{}\", s, shape.indent.to_string(context.config))\n-                })\n-            }\n+            rewrite_missing_comment_on_field(context,\n+                                             shape,\n+                                             self.attrs[self.attrs.len() - 1].span.hi,\n+                                             self.span.lo,\n+                                             &mut attr_str)\n+                .unwrap_or(String::new())\n         } else {\n             String::new()\n         };"}, {"sha": "0e2e2c066c3b05a76b85087bebe2cb43c1e5e5a7", "filename": "tests/source/enum.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/tests%2Fsource%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/tests%2Fsource%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fenum.rs?ref=d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "patch": "@@ -98,3 +98,14 @@ fn nested_enum_test() {\n    pub  struct  EmtpyWithComment {\n     // FIXME: Implement this struct\n }\n+\n+// #1115\n+pub enum Bencoding<'i> {\n+    Str(&'i [u8]),\n+    Int(i64),\n+    List(Vec<Bencoding<'i>>),\n+    /// A bencoded dict value. The first element the slice of bytes in the source that the dict is\n+    /// composed of. The second is the dict, decoded into an ordered map.\n+    // TODO make Dict \"structlike\" AKA name the two values.\n+    Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),\n+}"}, {"sha": "3e0e46d3fae97950b9014ebfaae60d493b617040", "filename": "tests/target/enum.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7de5b7656dcdca403b3560c7c9c2ebb335f8567/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "patch": "@@ -127,3 +127,15 @@ fn nested_enum_test() {\n pub struct EmtpyWithComment {\n     // FIXME: Implement this struct\n }\n+\n+// #1115\n+pub enum Bencoding<'i> {\n+    Str(&'i [u8]),\n+    Int(i64),\n+    List(Vec<Bencoding<'i>>),\n+    /// A bencoded dict value. The first element the slice of bytes in the\n+    /// source that the dict is\n+    /// composed of. The second is the dict, decoded into an ordered map.\n+    // TODO make Dict \"structlike\" AKA name the two values.\n+    Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),\n+}"}]}