{"sha": "31ed1641615bd57d9f4897dbe93e97f185fc5273", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZWQxNjQxNjE1YmQ1N2Q5ZjQ4OTdkYmU5M2U5N2YxODVmYzUyNzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-21T17:57:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-21T17:57:45Z"}, "message": "Merge #8134\n\n8134: Correct the paths of submodules from the include! macro r=edwin0cheng a=sticnarf\n\nThis PR should fix #7846. It mostly follows the instructions from @edwin0cheng in that issue.\n\nCo-authored-by: Yilin Chen <sticnarf@gmail.com>", "tree": {"sha": "c1b252604b48d2379c4735b535deaec9489d2d1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1b252604b48d2379c4735b535deaec9489d2d1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ed1641615bd57d9f4897dbe93e97f185fc5273", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgV4kZCRBK7hj4Ov3rIwAAdHIIAFVfBwEqLJSejOMHofh5ZC/y\nk59XfxrMvtVV2wwe/tk7D8M0sHuaiK9fwvvE2OvCa4h5D9OE6sa0Mpe/ANKIO8sv\nzn8Ee2l0GKsenokMjc3U3tnfVoKmdDqH+92gfdxTxsJf/FvwlSoO1xix8vd9sYso\nuIyozjoRF7Q+3tGnOsvCmU2WHFQUN1kS5uPQaWeOQ156lo5hs6YmVEbpPuAM6Nml\nkeCBa7EfWbyLQ55bODH4BVzt/MxhUoa1aeZ5m1A6b06N3UhzQlhmamK1ZRyHrgJV\nKmlnFjq1hW85tzELcUSj8CMIWl2zaZGsG/cRfjiuKyLdSic6Lsa5OLU49/Le7yk=\n=wwS0\n-----END PGP SIGNATURE-----\n", "payload": "tree c1b252604b48d2379c4735b535deaec9489d2d1a\nparent 35868c4f7dc479dd5f731a2785ec6a203046ea9c\nparent 7b693470c4fc61fff08c435cc3a2a646e88678cb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616349465 +0000\ncommitter GitHub <noreply@github.com> 1616349465 +0000\n\nMerge #8134\n\n8134: Correct the paths of submodules from the include! macro r=edwin0cheng a=sticnarf\n\nThis PR should fix #7846. It mostly follows the instructions from @edwin0cheng in that issue.\n\nCo-authored-by: Yilin Chen <sticnarf@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ed1641615bd57d9f4897dbe93e97f185fc5273", "html_url": "https://github.com/rust-lang/rust/commit/31ed1641615bd57d9f4897dbe93e97f185fc5273", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ed1641615bd57d9f4897dbe93e97f185fc5273/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35868c4f7dc479dd5f731a2785ec6a203046ea9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/35868c4f7dc479dd5f731a2785ec6a203046ea9c", "html_url": "https://github.com/rust-lang/rust/commit/35868c4f7dc479dd5f731a2785ec6a203046ea9c"}, {"sha": "7b693470c4fc61fff08c435cc3a2a646e88678cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b693470c4fc61fff08c435cc3a2a646e88678cb", "html_url": "https://github.com/rust-lang/rust/commit/7b693470c4fc61fff08c435cc3a2a646e88678cb"}], "stats": {"total": 138, "additions": 108, "deletions": 30}, "files": [{"sha": "d9cec0e27ac4298a4b78a5500d3114c5df91dba2", "filename": "crates/hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=31ed1641615bd57d9f4897dbe93e97f185fc5273", "patch": "@@ -62,21 +62,26 @@ impl ModDir {\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> Result<(FileId, bool, ModDir), String> {\n-        let file_id = file_id.original_file(db.upcast());\n+        let orig_file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = Vec::new();\n         match attr_path {\n             Some(attr_path) => {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None => {\n-                candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n-                candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n+                if file_id.is_include_macro(db.upcast()) {\n+                    candidate_files.push(format!(\"{}.rs\", name));\n+                    candidate_files.push(format!(\"{}/mod.rs\", name));\n+                } else {\n+                    candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n+                    candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n+                }\n             }\n         };\n \n         for candidate in candidate_files.iter() {\n-            let path = AnchoredPath { anchor: file_id, path: candidate.as_str() };\n+            let path = AnchoredPath { anchor: orig_file_id, path: candidate.as_str() };\n             if let Some(file_id) = db.resolve_path(path) {\n                 let is_mod_rs = candidate.ends_with(\"/mod.rs\");\n "}, {"sha": "4d52904b94bf2aa3f77ed56b23c741ccc08cac65", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=31ed1641615bd57d9f4897dbe93e97f185fc5273", "patch": "@@ -43,7 +43,7 @@ macro_rules! register_builtin {\n                 db: &dyn AstDatabase,\n                 arg_id: EagerMacroId,\n                 tt: &tt::Subtree,\n-            ) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+            ) -> ExpandResult<Option<ExpandedEager>> {\n                 let expander = match *self {\n                     $( EagerExpander::$e_kind => $e_expand, )*\n                 };\n@@ -61,6 +61,20 @@ macro_rules! register_builtin {\n     };\n }\n \n+#[derive(Debug)]\n+pub struct ExpandedEager {\n+    pub(crate) subtree: tt::Subtree,\n+    pub(crate) fragment: FragmentKind,\n+    /// The included file ID of the include macro.\n+    pub(crate) included_file: Option<FileId>,\n+}\n+\n+impl ExpandedEager {\n+    fn new(subtree: tt::Subtree, fragment: FragmentKind) -> Self {\n+        ExpandedEager { subtree, fragment, included_file: None }\n+    }\n+}\n+\n pub fn find_builtin_macro(\n     ident: &name::Name,\n     krate: CrateId,\n@@ -280,7 +294,7 @@ fn compile_error_expand(\n     _db: &dyn AstDatabase,\n     _id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let err = match &*tt.token_trees {\n         [tt::TokenTree::Leaf(tt::Leaf::Literal(it))] => {\n             let text = it.text.as_str();\n@@ -294,14 +308,14 @@ fn compile_error_expand(\n         _ => mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into()),\n     };\n \n-    ExpandResult { value: Some((quote! {}, FragmentKind::Items)), err: Some(err) }\n+    ExpandResult { value: Some(ExpandedEager::new(quote! {}, FragmentKind::Items)), err: Some(err) }\n }\n \n fn concat_expand(\n     _db: &dyn AstDatabase,\n     _arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let mut err = None;\n     let mut text = String::new();\n     for (i, t) in tt.token_trees.iter().enumerate() {\n@@ -325,7 +339,7 @@ fn concat_expand(\n             }\n         }\n     }\n-    ExpandResult { value: Some((quote!(#text), FragmentKind::Expr)), err }\n+    ExpandResult { value: Some(ExpandedEager::new(quote!(#text), FragmentKind::Expr)), err }\n }\n \n fn relative_file(\n@@ -361,21 +375,27 @@ fn include_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let res = (|| {\n         let path = parse_string(tt)?;\n         let file_id = relative_file(db, arg_id.into(), &path, false)?;\n \n-        Ok(parse_to_token_tree(&db.file_text(file_id))\n+        let subtree = parse_to_token_tree(&db.file_text(file_id))\n             .ok_or_else(|| mbe::ExpandError::ConversionError)?\n-            .0)\n+            .0;\n+        Ok((subtree, file_id))\n     })();\n \n     match res {\n-        Ok(res) => {\n+        Ok((subtree, file_id)) => {\n             // FIXME:\n             // Handle include as expression\n-            ExpandResult::ok(Some((res, FragmentKind::Items)))\n+\n+            ExpandResult::ok(Some(ExpandedEager {\n+                subtree,\n+                fragment: FragmentKind::Items,\n+                included_file: Some(file_id),\n+            }))\n         }\n         Err(e) => ExpandResult::only_err(e),\n     }\n@@ -385,7 +405,7 @@ fn include_bytes_expand(\n     _db: &dyn AstDatabase,\n     _arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     if let Err(e) = parse_string(tt) {\n         return ExpandResult::only_err(e);\n     }\n@@ -398,14 +418,14 @@ fn include_bytes_expand(\n             id: tt::TokenId::unspecified(),\n         }))],\n     };\n-    ExpandResult::ok(Some((res, FragmentKind::Expr)))\n+    ExpandResult::ok(Some(ExpandedEager::new(res, FragmentKind::Expr)))\n }\n \n fn include_str_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let path = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => return ExpandResult::only_err(e),\n@@ -418,14 +438,14 @@ fn include_str_expand(\n     let file_id = match relative_file(db, arg_id.into(), &path, true) {\n         Ok(file_id) => file_id,\n         Err(_) => {\n-            return ExpandResult::ok(Some((quote!(\"\"), FragmentKind::Expr)));\n+            return ExpandResult::ok(Some(ExpandedEager::new(quote!(\"\"), FragmentKind::Expr)));\n         }\n     };\n \n     let text = db.file_text(file_id);\n     let text = &*text;\n \n-    ExpandResult::ok(Some((quote!(#text), FragmentKind::Expr)))\n+    ExpandResult::ok(Some(ExpandedEager::new(quote!(#text), FragmentKind::Expr)))\n }\n \n fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Option<String> {\n@@ -437,7 +457,7 @@ fn env_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => return ExpandResult::only_err(e),\n@@ -461,14 +481,14 @@ fn env_expand(\n     });\n     let expanded = quote! { #s };\n \n-    ExpandResult { value: Some((expanded, FragmentKind::Expr)), err }\n+    ExpandResult { value: Some(ExpandedEager::new(expanded, FragmentKind::Expr)), err }\n }\n \n fn option_env_expand(\n     db: &dyn AstDatabase,\n     arg_id: EagerMacroId,\n     tt: &tt::Subtree,\n-) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+) -> ExpandResult<Option<ExpandedEager>> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => return ExpandResult::only_err(e),\n@@ -479,7 +499,7 @@ fn option_env_expand(\n         Some(s) => quote! { std::option::Some(#s) },\n     };\n \n-    ExpandResult::ok(Some((expanded, FragmentKind::Expr)))\n+    ExpandResult::ok(Some(ExpandedEager::new(expanded, FragmentKind::Expr)))\n }\n \n #[cfg(test)]\n@@ -553,16 +573,18 @@ mod tests {\n                         subtree: Arc::new(parsed_args.clone()),\n                         krate,\n                         call: call_id,\n+                        included_file: None,\n                     }\n                 });\n \n-                let (subtree, fragment) = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n+                let expanded = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n                 let eager = EagerCallLoc {\n                     def,\n-                    fragment,\n-                    subtree: Arc::new(subtree),\n+                    fragment: expanded.fragment,\n+                    subtree: Arc::new(expanded.subtree),\n                     krate,\n                     call: call_id,\n+                    included_file: expanded.included_file,\n                 };\n \n                 let id: MacroCallId = db.intern_eager_expansion(eager).into();"}, {"sha": "9eedc84614334fce1ffbb1399147b8ec962617ab", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=31ed1641615bd57d9f4897dbe93e97f185fc5273", "patch": "@@ -124,6 +124,7 @@ pub fn expand_eager_macro(\n             subtree: Arc::new(parsed_args.clone()),\n             krate,\n             call: call_id,\n+            included_file: None,\n         }\n     });\n     let arg_file_id: MacroCallId = arg_id.into();\n@@ -143,9 +144,15 @@ pub fn expand_eager_macro(\n     if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n         let res = eager.expand(db, arg_id, &subtree);\n \n-        let (subtree, fragment) = diagnostic_sink.expand_result_option(res)?;\n-        let eager =\n-            EagerCallLoc { def, fragment, subtree: Arc::new(subtree), krate, call: call_id };\n+        let expanded = diagnostic_sink.expand_result_option(res)?;\n+        let eager = EagerCallLoc {\n+            def,\n+            fragment: expanded.fragment,\n+            subtree: Arc::new(expanded.subtree),\n+            krate,\n+            call: call_id,\n+            included_file: expanded.included_file,\n+        };\n \n         Ok(db.intern_eager_expansion(eager))\n     } else {"}, {"sha": "b8045fda95cb53016c7b4a16ec6b0fcb27a048b4", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=31ed1641615bd57d9f4897dbe93e97f185fc5273", "patch": "@@ -84,7 +84,11 @@ impl HirFileId {\n                     }\n                     MacroCallId::EagerMacro(id) => {\n                         let loc = db.lookup_intern_eager_expansion(id);\n-                        loc.call.file_id\n+                        if let Some(included_file) = loc.included_file {\n+                            return included_file;\n+                        } else {\n+                            loc.call.file_id\n+                        }\n                     }\n                 };\n                 file_id.original_file(db)\n@@ -188,6 +192,21 @@ impl HirFileId {\n             }\n         }\n     }\n+\n+    /// Return whether this file is an include macro\n+    pub fn is_include_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+        match self.0 {\n+            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n+                MacroCallId::EagerMacro(id) => {\n+                    let loc = db.lookup_intern_eager_expansion(id);\n+                    return loc.included_file.is_some();\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+        false\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -315,6 +334,8 @@ pub struct EagerCallLoc {\n     pub(crate) subtree: Arc<tt::Subtree>,\n     pub(crate) krate: CrateId,\n     pub(crate) call: AstId<ast::MacroCall>,\n+    // The included file ID of the include macro.\n+    pub(crate) included_file: Option<FileId>,\n }\n \n /// ExpansionInfo mainly describes how to map text range between src and expanded macro"}, {"sha": "12951fb16c1daff342e4a7df83639619a9411632", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ed1641615bd57d9f4897dbe93e97f185fc5273/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=31ed1641615bd57d9f4897dbe93e97f185fc5273", "patch": "@@ -606,6 +606,29 @@ fn bar() -> u32 {0}\n     );\n }\n \n+#[test]\n+fn infer_builtin_macros_include_child_mod() {\n+    check_types(\n+        r#\"\n+//- /main.rs\n+#[rustc_builtin_macro]\n+macro_rules! include {() => {}}\n+\n+include!(\"f/foo.rs\");\n+\n+fn main() {\n+    bar::bar();\n+}          //^ u32\n+\n+//- /f/foo.rs\n+pub mod bar;\n+\n+//- /f/bar.rs\n+pub fn bar() -> u32 {0}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_builtin_macros_include_str() {\n     check_types("}]}