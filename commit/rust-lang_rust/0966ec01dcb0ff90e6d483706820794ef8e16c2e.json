{"sha": "0966ec01dcb0ff90e6d483706820794ef8e16c2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NjZlYzAxZGNiMGZmOTBlNmQ0ODM3MDY4MjA3OTRlZjhlMTZjMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-11T18:46:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-11T18:46:28Z"}, "message": "auto merge of #10407 : alexcrichton/rust/no-fixed-stack-segment, r=brson\n\nThe commit messages have more details, but this removes all analysis and usage related to fixed_stack_segment and rust_stack attributes. It's now the assumption that we always have \"enough stack\" and we'll implement detection of stack overflow through other means.\r\n\r\nThe stack overflow detection is currently implemented for rust functions, but it is unimplemented for C functions (we still don't have guard pages).", "tree": {"sha": "7d2032464a17a0ecb160828be5197587a545752d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d2032464a17a0ecb160828be5197587a545752d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0966ec01dcb0ff90e6d483706820794ef8e16c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0966ec01dcb0ff90e6d483706820794ef8e16c2e", "html_url": "https://github.com/rust-lang/rust/commit/0966ec01dcb0ff90e6d483706820794ef8e16c2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0966ec01dcb0ff90e6d483706820794ef8e16c2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d9b95fada7c97ac1c63099bab1d45ba120958ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d9b95fada7c97ac1c63099bab1d45ba120958ec", "html_url": "https://github.com/rust-lang/rust/commit/4d9b95fada7c97ac1c63099bab1d45ba120958ec"}, {"sha": "1f192430956704ddf263aba0cfb5b8856c547beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f192430956704ddf263aba0cfb5b8856c547beb", "html_url": "https://github.com/rust-lang/rust/commit/1f192430956704ddf263aba0cfb5b8856c547beb"}], "stats": {"total": 1310, "additions": 262, "deletions": 1048}, "files": [{"sha": "371e0e2f3e4524588d7197b077d76bf268affe2a", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 25, "deletions": 143, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -19,10 +19,9 @@ extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n-    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+    println!(\"max compressed length of a 100 byte buffer: {}\", x);\n }\n ~~~~\n \n@@ -36,11 +35,6 @@ interfaces that aren't thread-safe, and almost any function that takes a pointer\n valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n-Finally, the `#[fixed_stack_segment]` annotation that appears on\n-`main()` instructs the Rust compiler that when `main()` executes, it\n-should request a \"very large\" stack segment.  More details on\n-stack management can be found in the following sections.\n-\n When declaring the argument types to a foreign function, the Rust compiler will not check if the\n declaration is correct, so specifying it correctly is part of keeping the binding correct at\n runtime.\n@@ -81,8 +75,6 @@ length is number of elements currently contained, and the capacity is the total\n the allocated memory. The length is less than or equal to the capacity.\n \n ~~~~ {.xfail-test}\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n         snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n@@ -94,36 +86,6 @@ The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, b\n guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n signature.\n \n-The `validate_compressed_buffer` wrapper is also annotated with two\n-attributes `#[fixed_stack_segment]` and `#[inline(never)]`. The\n-purpose of these attributes is to guarantee that there will be\n-sufficient stack for the C function to execute. This is necessary\n-because Rust, unlike C, does not assume that the stack is allocated in\n-one continuous chunk. Instead, we rely on a *segmented stack* scheme,\n-in which the stack grows and shrinks as necessary.  C code, however,\n-expects one large stack, and so callers of C functions must request a\n-large stack segment to ensure that the C routine will not run off the\n-end of the stack.\n-\n-The compiler includes a lint mode that will report an error if you\n-call a C function without a `#[fixed_stack_segment]` attribute. More\n-details on the lint mode are given in a later section.\n-\n-You may be wondering why we include a `#[inline(never)]` directive.\n-This directive informs the compiler never to inline this function.\n-While not strictly necessary, it is usually a good idea to use an\n-`#[inline(never)]` directive in concert with `#[fixed_stack_segment]`.\n-The reason is that if a fn annotated with `fixed_stack_segment` is\n-inlined, then its caller also inherits the `fixed_stack_segment`\n-annotation. This means that rather than requesting a large stack\n-segment only for the duration of the call into C, the large stack\n-segment would be used for the entire duration of the caller. This is\n-not necessarily *bad* -- it can for example be more efficient,\n-particularly if `validate_compressed_buffer()` is called multiple\n-times in a row -- but it does work against the purpose of the\n-segmented stack scheme, which is to keep stacks small and thus\n-conserve address space.\n-\n The `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be\n allocated to hold the output too.\n \n@@ -134,8 +96,6 @@ the true length after compression for setting the length.\n \n ~~~~ {.xfail-test}\n pub fn compress(src: &[u8]) -> ~[u8] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -156,8 +116,6 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n \n ~~~~ {.xfail-test}\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -181,98 +139,28 @@ pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n-# Automatic wrappers\n-\n-Sometimes writing Rust wrappers can be quite tedious.  For example, if\n-function does not take any pointer arguments, often there is no need\n-for translating types. In such cases, it is usually still a good idea\n-to have a Rust wrapper so as to manage the segmented stacks, but you\n-can take advantage of the (standard) `externfn!` macro to remove some\n-of the tedium.\n-\n-In the initial section, we showed an extern block that added a call\n-to a specific snappy API:\n-\n-~~~~ {.xfail-test}\n-use std::libc::size_t;\n-\n-#[link_args = \"-lsnappy\"]\n-extern {\n-    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-}\n-\n-#[fixed_stack_segment]\n-fn main() {\n-    let x = unsafe { snappy_max_compressed_length(100) };\n-    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n-}\n-~~~~\n-\n-To avoid the need to create a wrapper fn for `snappy_max_compressed_length()`,\n-and also to avoid the need to think about `#[fixed_stack_segment]`, we\n-could simply use the `externfn!` macro instead, as shown here:\n-\n-~~~~ {.xfail-test}\n-use std::libc::size_t;\n-\n-externfn!(#[link_args = \"-lsnappy\"]\n-          fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n-\n-fn main() {\n-    let x = unsafe { snappy_max_compressed_length(100) };\n-    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n-}\n-~~~~\n-\n-As you can see from the example, `externfn!` replaces the extern block\n-entirely. After macro expansion, it will create something like this:\n-\n-~~~~ {.xfail-test}\n-use std::libc::size_t;\n-\n-// Automatically generated by\n-//   externfn!(#[link_args = \"-lsnappy\"]\n-//             fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n-unsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return snappy_max_compressed_length(source_length);\n-\n-    #[link_args = \"-lsnappy\"]\n-    extern {\n-        fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-    }\n-}\n-\n-fn main() {\n-    let x = unsafe { snappy_max_compressed_length(100) };\n-    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n-}\n-~~~~\n-\n-# Segmented stacks and the linter\n-\n-By default, whenever you invoke a non-Rust fn, the `cstack` lint will\n-check that one of the following conditions holds:\n-\n-1. The call occurs inside of a fn that has been annotated with\n-   `#[fixed_stack_segment]`;\n-2. The call occurs inside of an `extern fn`;\n-3. The call occurs within a stack closure created by some other\n-   safe fn.\n-\n-All of these conditions ensure that you are running on a large stack\n-segment. However, they are sometimes too strict. If your application\n-will be making many calls into C, it is often beneficial to promote\n-the `#[fixed_stack_segment]` attribute higher up the call chain.  For\n-example, the Rust compiler actually labels main itself as requiring a\n-`#[fixed_stack_segment]`. In such cases, the linter is just an\n-annoyance, because all C calls that occur from within the Rust\n-compiler are made on a large stack. Another situation where this\n-frequently occurs is on a 64-bit architecture, where large stacks are\n-the default. In cases, you can disable the linter by including a\n-`#[allow(cstack)]` directive somewhere, which permits violations of\n-the \"cstack\" rules given above (you can also use `#[warn(cstack)]` to\n-convert the errors into warnings, if you prefer).\n+# Stack management\n+\n+Rust tasks by default run on a \"large stack\". This is actually implemented as a\n+reserving a large segment of the address space and then lazily mapping in pages\n+as they are needed. When calling an external C function, the code is invoked on\n+the same stack as the rust stack. This means that there is no extra\n+stack-switching mechanism in place because it is assumed that the large stack\n+for the rust task is plenty for the C function to have.\n+\n+A planned future improvement (net yet implemented at the time of this writing)\n+is to have a guard page at the end of every rust stack. No rust function will\n+hit this guard page (due to rust's usage of LLVM's __morestack). The intention\n+for this unmapped page is to prevent infinite recursion in C from overflowing\n+onto other rust stacks. If the guard page is hit, then the process will be\n+terminated with a message saying that the guard page was hit.\n+\n+For normal external function usage, this all means that there shouldn't be any\n+need for any extra effort on a user's perspective. The C stack naturally\n+interleaves with the rust stack, and it's \"large enough\" for both to\n+interoperate. If, however, it is determined that a larger stack is necessary,\n+there are appropriate functions in the task spawning API to control the size of\n+the stack of the task which is spawned.\n \n # Destructors\n \n@@ -296,9 +184,6 @@ pub struct Unique<T> {\n \n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n-        #[fixed_stack_segment];\n-        #[inline(never)];\n-\n         unsafe {\n             let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n@@ -322,9 +207,6 @@ impl<T: Send> Unique<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {\n-        #[fixed_stack_segment];\n-        #[inline(never)];\n-\n         unsafe {\n             let x = intrinsics::init(); // dummy value to swap in\n             // moving the object out is needed to call the destructor\n@@ -384,8 +266,8 @@ extern {\n }\n \n fn main() {\n-    println(fmt!(\"You have readline version %d installed.\",\n-                 rl_readline_version as int));\n+    println!(\"You have readline version {} installed.\",\n+             rl_readline_version as int);\n }\n ~~~\n "}, {"sha": "205e0be41cb02d488dadebbb9d78814f403f22aa", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -162,7 +162,6 @@ mod tests {\n     }\n \n     impl Runnable for LibcFree {\n-        #[fixed_stack_segment]\n         fn run(~self) {\n             unsafe {\n                 libc::free(self.mem)\n@@ -171,9 +170,6 @@ mod tests {\n     }\n \n     fn malloc(n: size_t) -> CVec<u8> {\n-        #[fixed_stack_segment];\n-        #[inline(never)];\n-\n         unsafe {\n             let mem = libc::malloc(n);\n "}, {"sha": "83a3ef60a8aff6aa54183d3cc13a000640118792", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -47,8 +47,6 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n@@ -75,8 +73,6 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;"}, {"sha": "106dc5bf5c9da682e786dbe8759ae2e2b3c3734c", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -38,6 +38,8 @@ Rust extras are part of the standard Rust distribution.\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n+#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n use std::str::{StrSlice, OwnedStr};\n "}, {"sha": "04f045c961ff53565f704b3ca8674c0fbf957d73", "filename": "src/libextra/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -220,8 +220,6 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n }\n \n fn usage(binary: &str, helpstr: &str) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n     println(groups::usage(message, optgroups()));\n     println(\"\");"}, {"sha": "aed42e8d7fe965cb59cafb4d43adb78db14e8868", "filename": "src/libextra/time.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -63,8 +63,6 @@ impl Ord for Timespec {\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n pub fn get_time() -> Timespec {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let mut sec = 0i64;\n         let mut nsec = 0i32;\n@@ -79,8 +77,6 @@ pub fn get_time() -> Timespec {\n  * in nanoseconds since an unspecified epoch.\n  */\n pub fn precise_time_ns() -> u64 {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let mut ns = 0u64;\n         rustrt::precise_time_ns(&mut ns);\n@@ -98,8 +94,6 @@ pub fn precise_time_s() -> f64 {\n }\n \n pub fn tzset() {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         rustrt::rust_tzset();\n     }\n@@ -143,8 +137,6 @@ pub fn empty_tm() -> Tm {\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -160,8 +152,6 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -179,8 +169,6 @@ pub fn now() -> Tm {\n impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n     pub fn to_timespec(&self) -> Timespec {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             let sec = match self.tm_gmtoff {\n                 0_i32 => rustrt::rust_timegm(self),\n@@ -969,7 +957,6 @@ mod tests {\n     use std::libc;\n \n     #[cfg(windows)]\n-    #[fixed_stack_segment]\n     fn set_time_zone() {\n         // Windows crt doesn't see any environment variable set by\n         // `SetEnvironmentVariable`, which `os::setenv` internally uses."}, {"sha": "880d79ac48a935f23c451995fbe648617f770be4", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -278,9 +278,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"loop checking\", (), |_|\n          middle::check_loop::check_crate(ty_cx, crate));\n \n-    time(time_passes, \"stack checking\", (), |_|\n-         middle::stack_check::stack_check_crate(ty_cx, crate));\n-\n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n@@ -428,7 +425,6 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n     return false;\n }\n \n-#[fixed_stack_segment]\n pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n     // We need nested scopes here, because the intermediate results can keep\n@@ -703,12 +699,7 @@ pub fn build_session_options(binary: @str,\n     }\n \n     if debugging_opts & session::debug_llvm != 0 {\n-        set_llvm_debug();\n-\n-        fn set_llvm_debug() {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe { llvm::LLVMSetDebug(1); }\n-        }\n+        unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n     let output_type ="}, {"sha": "798418f52dc74d707ecb92353ad2e1faea7efaa2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -19,11 +19,8 @@\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs, struct_variant, managed_boxes)];\n-\n-// Rustc tasks always run on a fixed_stack_segment, so code in this\n-// module can call C functions (in particular, LLVM functions) with\n-// impunity.\n-#[allow(cstack)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n+#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n extern mod extra;\n extern mod syntax;\n@@ -81,7 +78,6 @@ pub mod middle {\n     pub mod reachable;\n     pub mod graph;\n     pub mod cfg;\n-    pub mod stack_check;\n }\n \n pub mod front {"}, {"sha": "14af20f0cb9eed3b5a4b774f61d2ba491fed95e5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// LLVM wrappers are intended to be called from trans,\n-// which already runs in a #[fixed_stack_segment]\n-#[allow(cstack)];\n #[allow(non_uppercase_pattern_statics)];\n \n use std::c_str::ToCStr;"}, {"sha": "21a9b1904dd042aa758abd9b7651da30775c8d1e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -63,7 +63,6 @@ use syntax::visit::Visitor;\n #[deriving(Clone, Eq)]\n pub enum lint {\n     ctypes,\n-    cstack,\n     unused_imports,\n     unnecessary_qualification,\n     while_true,\n@@ -136,13 +135,6 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n-    (\"cstack\",\n-     LintSpec {\n-        lint: cstack,\n-        desc: \"only invoke foreign functions from fixedstacksegment fns\",\n-        default: deny\n-     }),\n-\n     (\"unused_imports\",\n      LintSpec {\n         lint: unused_imports,"}, {"sha": "fdb7f1508fb47a64d9497fa7a9a7383952f48af1", "filename": "src/librustc/middle/stack_check.rs", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=4d9b95fada7c97ac1c63099bab1d45ba120958ec", "patch": "@@ -1,182 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Lint mode to detect cases where we call non-Rust fns, which do not\n-have a stack growth check, from locations not annotated to request\n-large stacks.\n-\n-*/\n-\n-use middle::lint;\n-use middle::ty;\n-use syntax::ast;\n-use syntax::ast_map;\n-use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-use util::ppaux::Repr;\n-\n-#[deriving(Clone)]\n-struct Context {\n-    safe_stack: bool\n-}\n-\n-struct StackCheckVisitor {\n-    tcx: ty::ctxt,\n-}\n-\n-impl Visitor<Context> for StackCheckVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:Context) {\n-        stack_check_item(self, i, e);\n-    }\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:Span, n:ast::NodeId, e:Context) {\n-        stack_check_fn(self, fk, fd, b, s, n, e);\n-    }\n-    fn visit_expr(&mut self, ex:@ast::Expr, e:Context) {\n-        stack_check_expr(self, ex, e);\n-    }\n-}\n-\n-pub fn stack_check_crate(tcx: ty::ctxt,\n-                         crate: &ast::Crate) {\n-    let new_cx = Context { safe_stack: false };\n-    let mut visitor = StackCheckVisitor { tcx: tcx };\n-    visit::walk_crate(&mut visitor, crate, new_cx);\n-}\n-\n-fn stack_check_item(v: &mut StackCheckVisitor,\n-                    item: @ast::item,\n-                    in_cx: Context) {\n-    match item.node {\n-        ast::item_fn(_, ast::extern_fn, _, _, _) => {\n-            // an extern fn is already being called from C code...\n-            let new_cx = Context {safe_stack: true};\n-            visit::walk_item(v, item, new_cx);\n-        }\n-        ast::item_fn(*) => {\n-            let safe_stack = fixed_stack_segment(item.attrs);\n-            let new_cx = Context {safe_stack: safe_stack};\n-            visit::walk_item(v, item, new_cx);\n-        }\n-        ast::item_impl(_, _, _, ref methods) => {\n-            // visit_method() would make this nicer\n-            for &method in methods.iter() {\n-                let safe_stack = fixed_stack_segment(method.attrs);\n-                let new_cx = Context {safe_stack: safe_stack};\n-                visit::walk_method_helper(v, method, new_cx);\n-            }\n-        }\n-        ast::item_trait(_, _, ref methods) => {\n-            for method in methods.iter() {\n-                match *method {\n-                    ast::provided(@ref method) => {\n-                        let safe_stack = fixed_stack_segment(method.attrs);\n-                        let new_cx = Context {safe_stack: safe_stack};\n-                        visit::walk_method_helper(v, method, new_cx);\n-                    }\n-                    ast::required(*) => ()\n-                }\n-            }\n-        }\n-        _ => {\n-            visit::walk_item(v, item, in_cx);\n-        }\n-    }\n-\n-    fn fixed_stack_segment(attrs: &[ast::Attribute]) -> bool {\n-        attr::contains_name(attrs, \"fixed_stack_segment\")\n-    }\n-}\n-\n-fn stack_check_fn<'a>(v: &mut StackCheckVisitor,\n-                      fk: &visit::fn_kind,\n-                      decl: &ast::fn_decl,\n-                      body: &ast::Block,\n-                      sp: Span,\n-                      id: ast::NodeId,\n-                      in_cx: Context) {\n-    let safe_stack = match *fk {\n-        visit::fk_method(*) | visit::fk_item_fn(*) => {\n-            in_cx.safe_stack // see stack_check_item above\n-        }\n-        visit::fk_anon(*) | visit::fk_fn_block => {\n-            match ty::get(ty::node_id_to_type(v.tcx, id)).sty {\n-                ty::ty_bare_fn(*) |\n-                ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-                    false\n-                }\n-                _ => {\n-                    in_cx.safe_stack\n-                }\n-            }\n-        }\n-    };\n-    let new_cx = Context {safe_stack: safe_stack};\n-    debug!(\"stack_check_fn(safe_stack={}, id={:?})\", safe_stack, id);\n-    visit::walk_fn(v, fk, decl, body, sp, id, new_cx);\n-}\n-\n-fn stack_check_expr<'a>(v: &mut StackCheckVisitor,\n-                        expr: @ast::Expr,\n-                        cx: Context) {\n-    debug!(\"stack_check_expr(safe_stack={}, expr={})\",\n-           cx.safe_stack, expr.repr(v.tcx));\n-    if !cx.safe_stack {\n-        match expr.node {\n-            ast::ExprCall(callee, _, _) => {\n-                let callee_ty = ty::expr_ty(v.tcx, callee);\n-                debug!(\"callee_ty={}\", callee_ty.repr(v.tcx));\n-                match ty::get(callee_ty).sty {\n-                    ty::ty_bare_fn(ref fty) => {\n-                        if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n-                            call_to_extern_fn(v, callee);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    visit::walk_expr(v, expr, cx);\n-}\n-\n-fn call_to_extern_fn(v: &mut StackCheckVisitor, callee: @ast::Expr) {\n-    // Permit direct calls to extern fns that are annotated with\n-    // #[rust_stack]. This is naturally a horrible pain to achieve.\n-    match callee.node {\n-        ast::ExprPath(*) => {\n-            match v.tcx.def_map.find(&callee.id) {\n-                Some(&ast::DefFn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n-                    match v.tcx.items.find(&id.node) {\n-                        Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n-                            if attr::contains_name(item.attrs, \"rust_stack\") {\n-                                return;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    v.tcx.sess.add_lint(lint::cstack,\n-                         callee.id,\n-                         callee.span,\n-                         format!(\"invoking non-Rust fn in fn without \\\n-                              \\\\#[fixed_stack_segment]\"));\n-}"}, {"sha": "c6b663634f30341d37959389cee008e8169abcc4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -495,12 +495,6 @@ pub fn set_always_inline(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::AlwaysInlineAttribute)\n }\n \n-pub fn set_fixed_stack_segment(f: ValueRef) {\n-    do \"fixed-stack-segment\".with_c_str |buf| {\n-        unsafe { llvm::LLVMAddFunctionAttrString(f, buf); }\n-    }\n-}\n-\n pub fn set_no_split_stack(f: ValueRef) {\n     do \"no-split-stack\".with_c_str |buf| {\n         unsafe { llvm::LLVMAddFunctionAttrString(f, buf); }\n@@ -1889,7 +1883,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      self_arg: self_arg,\n                      param_substs: Option<@param_substs>,\n                      id: ast::NodeId,\n-                     attributes: &[ast::Attribute],\n+                     _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: &fn(@mut FunctionContext)) {\n     ccx.stats.n_closures += 1;\n@@ -1919,12 +1913,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n-    // Set the fixed stack segment flag if necessary.\n-    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n-        set_no_inline(fcx.llfn);\n-        set_fixed_stack_segment(fcx.llfn);\n-    }\n-\n     bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n \n     maybe_load_env(fcx);"}, {"sha": "38bffd4f6e51593f5ca29e037fbf9fe82049b71b", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -25,7 +25,6 @@ use middle::trans::glue;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::attr;\n use util::ppaux::ty_to_str;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n@@ -35,7 +34,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        item: &ast::foreign_item,\n                        path: ast_map::path,\n                        substs: @param_substs,\n-                       attributes: &[ast::Attribute],\n+                       _attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n@@ -149,11 +148,6 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n \n     set_always_inline(fcx.llfn);\n \n-    // Set the fixed stack segment flag if necessary.\n-    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n-        set_fixed_stack_segment(fcx.llfn);\n-    }\n-\n     let mut bcx = fcx.entry_bcx.unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n "}, {"sha": "cb9ced6b19d5b68269165b00dcaac0d8c10f9163", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(cstack)]; // each rendering task runs on a fixed stack segment.\n-\n //! Markdown formatting for rustdoc\n //!\n //! This module implements markdown formatting through the sundown C-library"}, {"sha": "4b6092abb48e01f763d13736e32d85bcd0e9b04f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -717,7 +717,6 @@ impl Context {\n                       port: &SharedPort<Work>,\n                       chan: &SharedChan<Work>,\n                       prog_chan: &SharedChan<Progress>) {\n-                #[fixed_stack_segment]; // we hit markdown FFI *a lot*\n                 local_data::set(cache_key, cache);\n \n                 loop {"}, {"sha": "56cf073cbdf63800e173f49e4f156a9c5cb672e8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -462,7 +462,6 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n \n #[cfg(target_os = \"win32\")]\n pub fn chmod_read_only(p: &Path) -> bool {\n-    #[fixed_stack_segment];\n     unsafe {\n         do p.with_c_str |src_buf| {\n             libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int\n@@ -472,7 +471,6 @@ pub fn chmod_read_only(p: &Path) -> bool {\n \n #[cfg(not(target_os = \"win32\"))]\n pub fn chmod_read_only(p: &Path) -> bool {\n-    #[fixed_stack_segment];\n     unsafe {\n         do p.with_c_str |src_buf| {\n             libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0"}, {"sha": "b65e1b7ba0286b5a91f1d061fabd57ca0cb2bbec", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -2319,7 +2319,7 @@ fn test_c_dependency_ok() {\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+              \\nfn main() { unsafe { f(); } }\");\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n@@ -2340,7 +2340,7 @@ fn test_c_dependency_no_rebuilding() {\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+              \\nfn main() { unsafe { f(); } }\");\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n@@ -2371,7 +2371,7 @@ fn test_c_dependency_yes_rebuilding() {\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+              \\nfn main() { unsafe { f(); } }\");\n     let c_file_name = dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n     writeFile(&c_file_name, \"void f() {}\");\n "}, {"sha": "67fa424af1ae444859d1697e44dff3e95b6ed699", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -361,7 +361,6 @@ impl FileWatcher {\n     }\n     fn seek_common(&mut self, pos: i64, whence: c_int) ->\n         Result<u64, IoError>{\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             match libc::lseek(self.fd, pos as libc::off_t, whence) {\n                 -1 => {"}, {"sha": "599cd01c46096b276e5dbb2068b7ce5322b4ad3e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -44,6 +44,8 @@ via `close` and `delete` methods.\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n+#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n use std::cast::transmute;\n use std::cast;"}, {"sha": "8e649bbc17abfb61188870a76be236e35c2c3bba", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -35,7 +35,6 @@ use uvll::sockaddr;\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[fixed_stack_segment]\n fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: &fn(*sockaddr) -> T) -> T {\n     let malloc = match addr.ip {\n         Ipv4Addr(*) => uvll::rust_malloc_ip4_addr,\n@@ -51,7 +50,6 @@ fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: &fn(*sockaddr) -> T) -> T {\n     }\n }\n \n-#[fixed_stack_segment]\n pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n     unsafe {\n         let ip_size = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n@@ -112,7 +110,6 @@ enum SocketNameKind {\n     Udp\n }\n \n-#[fixed_stack_segment]\n fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoError> {\n     unsafe {\n         let getsockname = match sk {"}, {"sha": "c802803251090deecd82751909d825b101ffadc0", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 177, "deletions": 220, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -364,8 +364,6 @@ pub enum uv_membership {\n }\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = uv_handle_size(handle);\n     let p = malloc(size);\n@@ -374,14 +372,10 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n }\n \n pub unsafe fn free_handle(v: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     free(v)\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n     let size = uv_req_size(req);\n     let p = malloc(size);\n@@ -390,155 +384,132 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n }\n \n pub unsafe fn free_req(v: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     free(v)\n }\n \n #[test]\n fn handle_sanity_check() {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n fn request_sanity_check() {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n     }\n }\n \n // XXX Event loops ignore SIGPIPE by default.\n pub unsafe fn loop_new() -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_loop_new();\n }\n \n-pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_udp_handle_from_send_req(send_req);\n-}\n-\n pub unsafe fn uv_write(req: *uv_write_t,\n                        stream: *uv_stream_t,\n                        buf_in: &[uv_buf_t],\n                        cb: uv_write_cb) -> c_int {\n-    externfn!(fn uv_write(req: *uv_write_t, stream: *uv_stream_t,\n-                          buf_in: *uv_buf_t, buf_cnt: c_int,\n-                          cb: uv_write_cb) -> c_int)\n+    extern {\n+        fn uv_write(req: *uv_write_t, stream: *uv_stream_t,\n+                    buf_in: *uv_buf_t, buf_cnt: c_int,\n+                    cb: uv_write_cb) -> c_int;\n+    }\n \n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n \n+pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n+                          handle: *uv_udp_t,\n+                          buf_in: &[uv_buf_t],\n+                          addr: *sockaddr,\n+                          cb: uv_udp_send_cb) -> c_int {\n+    extern {\n+        fn uv_udp_send(req: *uv_write_t, stream: *uv_stream_t,\n+                       buf_in: *uv_buf_t, buf_cnt: c_int, addr: *sockaddr,\n+                       cb: uv_udp_send_cb) -> c_int;\n+    }\n+\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n+}\n+\n+pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+    return rust_uv_get_udp_handle_from_send_req(send_req);\n+}\n+\n pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_process_pid(p);\n }\n \n pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n                                         flags: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_set_stdio_container_flags(c, flags);\n }\n \n pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n                                      fd: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_set_stdio_container_fd(c, fd);\n }\n \n pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n                                          stream: *uv_stream_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n     rust_set_stdio_container_stream(c, stream);\n }\n \n // data access helpers\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_result_from_fs_req(req)\n }\n pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_ptr_from_fs_req(req)\n }\n pub unsafe fn get_path_from_fs_req(req: *uv_fs_t) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_path_from_fs_req(req)\n }\n pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_loop_from_fs_req(req)\n }\n pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_loop_from_getaddrinfo_req(req)\n }\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_get_stream_handle_from_connect_req(connect);\n }\n pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_get_stream_handle_from_write_req(write_req);\n }\n pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_get_data_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n }\n pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     return rust_uv_get_data_for_req(req as *c_void);\n }\n pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n }\n pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_populate_uv_stat(req_in, stat_out)\n }\n pub unsafe fn guess_handle(handle: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     rust_uv_guess_handle(handle)\n }\n \n@@ -594,172 +565,158 @@ extern {\n                                        stream: *uv_stream_t);\n     fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n     fn rust_uv_guess_handle(fd: c_int) -> c_int;\n-}\n-\n-// generic uv functions\n-externfn!(fn uv_loop_delete(l: *uv_loop_t))\n-externfn!(fn uv_handle_size(ty: uv_handle_type) -> size_t)\n-externfn!(fn uv_req_size(ty: uv_req_type) -> size_t)\n-externfn!(fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int)\n-externfn!(fn uv_close(h: *uv_handle_t, cb: uv_close_cb))\n-externfn!(fn uv_walk(l: *uv_loop_t, cb: uv_walk_cb, arg: *c_void))\n-externfn!(fn uv_buf_init(base: *c_char, len: c_uint) -> uv_buf_t)\n-externfn!(fn uv_strerror(err: c_int) -> *c_char)\n-externfn!(fn uv_err_name(err: c_int) -> *c_char)\n-externfn!(fn uv_listen(s: *uv_stream_t, backlog: c_int,\n-                       cb: uv_connection_cb) -> c_int)\n-externfn!(fn uv_accept(server: *uv_stream_t, client: *uv_stream_t) -> c_int)\n-externfn!(fn uv_read_start(stream: *uv_stream_t,\n-                           on_alloc: uv_alloc_cb,\n-                           on_read: uv_read_cb) -> c_int)\n-externfn!(fn uv_read_stop(stream: *uv_stream_t) -> c_int)\n-\n-// idle bindings\n-externfn!(fn uv_idle_init(l: *uv_loop_t, i: *uv_idle_t) -> c_int)\n-externfn!(fn uv_idle_start(i: *uv_idle_t, cb: uv_idle_cb) -> c_int)\n-externfn!(fn uv_idle_stop(i: *uv_idle_t) -> c_int)\n-\n-// async bindings\n-externfn!(fn uv_async_init(l: *uv_loop_t, a: *uv_async_t,\n-                           cb: uv_async_cb) -> c_int)\n-externfn!(fn uv_async_send(a: *uv_async_t))\n-\n-// tcp bindings\n-externfn!(fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int)\n-externfn!(fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,\n-                            addr: *sockaddr, cb: uv_connect_cb) -> c_int)\n-externfn!(fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int)\n-externfn!(fn uv_ip4_name(src: *sockaddr, dst: *c_char,\n-                         size: size_t) -> c_int)\n-externfn!(fn uv_ip6_name(src: *sockaddr, dst: *c_char,\n-                         size: size_t) -> c_int)\n-externfn!(fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int)\n-externfn!(fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n-                              delay: c_uint) -> c_int)\n-externfn!(fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int)\n-externfn!(fn uv_tcp_getsockname(h: *uv_tcp_t, name: *sockaddr,\n-                                len: *mut c_int) -> c_int)\n-externfn!(fn uv_tcp_getpeername(h: *uv_tcp_t, name: *sockaddr,\n-                                len: *mut c_int) -> c_int)\n-externfn!(fn uv_ip4_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int)\n-externfn!(fn uv_ip6_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int)\n-\n-// udp bindings\n-externfn!(fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int)\n-externfn!(fn uv_udp_bind(h: *uv_udp_t, addr: *sockaddr, flags: c_uint) -> c_int)\n-externfn!(fn uv_udp_recv_start(server: *uv_udp_t,\n-                               on_alloc: uv_alloc_cb,\n-                               on_recv: uv_udp_recv_cb) -> c_int)\n-externfn!(fn uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                   interface_addr: *c_char,\n-                                   membership: uv_membership) -> c_int)\n-externfn!(fn uv_udp_recv_stop(server: *uv_udp_t) -> c_int)\n-externfn!(fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int)\n-externfn!(fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n-externfn!(fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n-externfn!(fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int)\n-externfn!(fn uv_udp_getsockname(h: *uv_udp_t, name: *sockaddr,\n-                                len: *mut c_int) -> c_int)\n-\n-pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n-                          handle: *uv_udp_t,\n-                          buf_in: &[uv_buf_t],\n-                          addr: *sockaddr,\n-                          cb: uv_udp_send_cb) -> c_int {\n-    externfn!(fn uv_udp_send(req: *uv_write_t, stream: *uv_stream_t,\n-                             buf_in: *uv_buf_t, buf_cnt: c_int, addr: *sockaddr,\n-                             cb: uv_udp_send_cb) -> c_int)\n \n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = buf_in.len() as i32;\n-    return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n+    // generic uv functions\n+    pub fn uv_loop_delete(l: *uv_loop_t);\n+    pub fn uv_handle_size(ty: uv_handle_type) -> size_t;\n+    pub fn uv_req_size(ty: uv_req_type) -> size_t;\n+    pub fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int;\n+    pub fn uv_close(h: *uv_handle_t, cb: uv_close_cb);\n+    pub fn uv_walk(l: *uv_loop_t, cb: uv_walk_cb, arg: *c_void);\n+    pub fn uv_buf_init(base: *c_char, len: c_uint) -> uv_buf_t;\n+    pub fn uv_strerror(err: c_int) -> *c_char;\n+    pub fn uv_err_name(err: c_int) -> *c_char;\n+    pub fn uv_listen(s: *uv_stream_t, backlog: c_int,\n+                     cb: uv_connection_cb) -> c_int;\n+    pub fn uv_accept(server: *uv_stream_t, client: *uv_stream_t) -> c_int;\n+    pub fn uv_read_start(stream: *uv_stream_t,\n+                         on_alloc: uv_alloc_cb,\n+                         on_read: uv_read_cb) -> c_int;\n+    pub fn uv_read_stop(stream: *uv_stream_t) -> c_int;\n+\n+    // idle bindings\n+    pub fn uv_idle_init(l: *uv_loop_t, i: *uv_idle_t) -> c_int;\n+    pub fn uv_idle_start(i: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    pub fn uv_idle_stop(i: *uv_idle_t) -> c_int;\n+\n+    // async bindings\n+    pub fn uv_async_init(l: *uv_loop_t, a: *uv_async_t,\n+                         cb: uv_async_cb) -> c_int;\n+    pub fn uv_async_send(a: *uv_async_t);\n+\n+    // tcp bindings\n+    pub fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int;\n+    pub fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,\n+                          addr: *sockaddr, cb: uv_connect_cb) -> c_int;\n+    pub fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int;\n+    pub fn uv_ip4_name(src: *sockaddr, dst: *c_char,\n+                       size: size_t) -> c_int;\n+    pub fn uv_ip6_name(src: *sockaddr, dst: *c_char,\n+                       size: size_t) -> c_int;\n+    pub fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int;\n+    pub fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n+                            delay: c_uint) -> c_int;\n+    pub fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int;\n+    pub fn uv_tcp_getsockname(h: *uv_tcp_t, name: *sockaddr,\n+                              len: *mut c_int) -> c_int;\n+    pub fn uv_tcp_getpeername(h: *uv_tcp_t, name: *sockaddr,\n+                              len: *mut c_int) -> c_int;\n+    pub fn uv_ip4_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int;\n+    pub fn uv_ip6_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int;\n+\n+    // udp bindings\n+    pub fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int;\n+    pub fn uv_udp_bind(h: *uv_udp_t, addr: *sockaddr, flags: c_uint) -> c_int;\n+    pub fn uv_udp_recv_start(server: *uv_udp_t,\n+                             on_alloc: uv_alloc_cb,\n+                             on_recv: uv_udp_recv_cb) -> c_int;\n+    pub fn uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                 interface_addr: *c_char,\n+                                 membership: uv_membership) -> c_int;\n+    pub fn uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n+    pub fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n+    pub fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    pub fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    pub fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n+    pub fn uv_udp_getsockname(h: *uv_udp_t, name: *sockaddr,\n+                              len: *mut c_int) -> c_int;\n+\n+    // timer bindings\n+    pub fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int;\n+    pub fn uv_timer_start(t: *uv_timer_t, cb: uv_timer_cb,\n+                          timeout: libc::uint64_t,\n+                          repeat: libc::uint64_t) -> c_int;\n+    pub fn uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+\n+    // fs operations\n+    pub fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                      flags: c_int, mode: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                        cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: size_t, offset: i64, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                      len: size_t, offset: i64, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                      cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_fstat(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_mkdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_rmdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                         flags: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_req_cleanup(req: *uv_fs_t);\n+    pub fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                           cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                           offset: i64, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                          cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                         dst: *c_char, flags: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_rename(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                        dst: *c_char, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_utime(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       atime: c_double, mtime: c_double,\n+                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                      dst: *c_char, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                       uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_chmod(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                       cb: uv_fs_cb) -> c_int;\n+\n+    // getaddrinfo\n+    pub fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+                          getaddrinfo_cb: uv_getaddrinfo_cb,\n+                          node: *c_char, service: *c_char,\n+                          hints: *addrinfo) -> c_int;\n+    pub fn uv_freeaddrinfo(ai: *addrinfo);\n+\n+    // process spawning\n+    pub fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n+                    options: *uv_process_options_t) -> c_int;\n+    pub fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+\n+    // pipes\n+    pub fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int;\n+    pub fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n+    pub fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n+    pub fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                           name: *c_char, cb: uv_connect_cb);\n+\n+    // tty\n+    pub fn uv_tty_init(l: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                       readable: c_int) -> c_int;\n+    pub fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n+    pub fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                              height: *c_int) -> c_int;\n+\n+    // signals\n+    pub fn uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n+    pub fn uv_signal_start(h: *uv_signal_t, cb: uv_signal_cb,\n+                           signum: c_int) -> c_int;\n+    pub fn uv_signal_stop(handle: *uv_signal_t) -> c_int;\n }\n \n-// timer bindings\n-externfn!(fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int)\n-externfn!(fn uv_timer_start(t: *uv_timer_t, cb: uv_timer_cb,\n-                            timeout: libc::uint64_t,\n-                            repeat: libc::uint64_t) -> c_int)\n-externfn!(fn uv_timer_stop(handle: *uv_timer_t) -> c_int)\n-\n-// fs operations\n-externfn!(fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                        flags: c_int, mode: c_int, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                          cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                         len: size_t, offset: i64, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                        len: size_t, offset: i64, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                         cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                        cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_fstat(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                         cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_mkdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                         mode: c_int, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_rmdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                         cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                           flags: c_int, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_req_cleanup(req: *uv_fs_t))\n-externfn!(fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                         cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                             cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n-                             offset: i64, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                            cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                           dst: *c_char, flags: c_int, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_rename(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                          dst: *c_char, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_utime(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                         atime: c_double, mtime: c_double,\n-                         cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                        dst: *c_char, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                         uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_chmod(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                         mode: c_int, cb: uv_fs_cb) -> c_int)\n-externfn!(fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                         cb: uv_fs_cb) -> c_int)\n-\n-// getaddrinfo\n-externfn!(fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n-                            getaddrinfo_cb: uv_getaddrinfo_cb,\n-                            node: *c_char, service: *c_char,\n-                            hints: *addrinfo) -> c_int)\n-externfn!(fn uv_freeaddrinfo(ai: *addrinfo))\n-\n-// process spawning\n-externfn!(fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n-                      options: *uv_process_options_t) -> c_int)\n-externfn!(fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int)\n-\n-// pipes\n-externfn!(fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int)\n-externfn!(fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int)\n-externfn!(fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int)\n-externfn!(fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                             name: *c_char, cb: uv_connect_cb))\n-\n-// tty\n-externfn!(fn uv_tty_init(l: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n-                         readable: c_int) -> c_int)\n-externfn!(fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int)\n-externfn!(fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                                height: *c_int) -> c_int)\n-\n-// signals\n-externfn!(fn uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int)\n-externfn!(fn uv_signal_start(h: *uv_signal_t, cb: uv_signal_cb,\n-                             signum: c_int) -> c_int)\n-externfn!(fn uv_signal_stop(handle: *uv_signal_t) -> c_int)\n-\n // libuv requires various system libraries to successfully link on some\n // platforms\n #[cfg(target_os = \"linux\")]"}, {"sha": "4d5c68ab7177b943e0aa499ff26fb7c4a985d609", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -40,7 +40,9 @@ An example of creating and using a C string would be:\n \n ```rust\n use std::libc;\n-externfn!(fn puts(s: *libc::c_char))\n+extern {\n+    fn puts(s: *libc::c_char);\n+}\n \n let my_string = \"Hello, world!\";\n \n@@ -179,7 +181,6 @@ impl CString {\n \n impl Drop for CString {\n     fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n         if self.owns_buffer_ {\n             unsafe {\n                 libc::free(self.buf as *libc::c_void)\n@@ -260,7 +261,6 @@ static BUF_LEN: uint = 128;\n \n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n-        #[fixed_stack_segment]; #[inline(never)];\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n         do cs.with_mut_ref |buf| {\n             check_for_null(*self, buf);\n@@ -269,7 +269,6 @@ impl<'self> ToCStr for &'self [u8] {\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n-        #[fixed_stack_segment]; #[inline(never)];\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n@@ -460,16 +459,12 @@ mod tests {\n \n     #[test]\n     fn test_unwrap() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         let c_str = \"hello\".to_c_str();\n         unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n     }\n \n     #[test]\n     fn test_with_ref() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n         assert!(!c_str.is_null());"}, {"sha": "967aee9135d8ca12e22a56f48dbfdfaa8b09afe0", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -64,6 +64,8 @@\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n+#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::rt::io tests have an I/O interface to run on top"}, {"sha": "190f6a7c86f7b06d30df414a18fa837dc3c0cdd4", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -2857,11 +2857,7 @@ pub mod funcs {\n \n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n-                #[rust_stack]\n-                #[inline]\n                 pub fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n-                #[rust_stack]\n-                #[inline]\n                 pub fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n             }\n         }\n@@ -3059,11 +3055,9 @@ pub mod funcs {\n             // doesn't link it correctly on i686, so we're going\n             // through a C function that mysteriously does work.\n             pub unsafe fn opendir(dirname: *c_char) -> *DIR {\n-                #[fixed_stack_segment]; #[inline(never)];\n                 rust_opendir(dirname)\n             }\n             pub unsafe fn readdir(dirp: *DIR) -> *dirent_t {\n-                #[fixed_stack_segment]; #[inline(never)];\n                 rust_readdir(dirp)\n             }\n "}, {"sha": "684fb9c76d941989b88cbd2e148ec7be01fcb7a0", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -277,7 +277,6 @@ fn get_with<T: 'static, U>(key: Key<T>,\n }\n \n fn abort() -> ! {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe { libc::abort() }\n }\n "}, {"sha": "a0dddffd85184faeb1663230ef187cdcfdeaee54", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline] #[fixed_stack_segment] #[inline(never)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "8cb7fa180018646958da64909d3bcae7fde04695", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -43,7 +43,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline] #[fixed_stack_segment] #[inline(never)]\n+                #[inline]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "ff24c35d4e641123ba9792ce2bc66054b132175a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -47,7 +47,6 @@ pub use os::consts::*;\n \n /// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::close(fd)\n     }\n@@ -58,7 +57,6 @@ static BUF_BYTES : uint = 2048u;\n \n #[cfg(unix)]\n pub fn getcwd() -> Path {\n-    #[fixed_stack_segment]; #[inline(never)];\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n@@ -73,7 +71,6 @@ pub fn getcwd() -> Path {\n \n #[cfg(windows)]\n pub fn getcwd() -> Path {\n-    #[fixed_stack_segment]; #[inline(never)];\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n     let mut buf = [0 as u16, ..BUF_BYTES];\n@@ -99,7 +96,6 @@ pub mod win32 {\n \n     pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n-        #[fixed_stack_segment]; #[inline(never)];\n \n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -153,8 +149,10 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n         };\n     }\n \n-    externfn!(fn rust_take_env_lock());\n-    externfn!(fn rust_drop_env_lock());\n+    extern {\n+        fn rust_take_env_lock();\n+        fn rust_drop_env_lock();\n+    }\n }\n \n /// Returns a vector of (variable, value) pairs for all the environment\n@@ -163,7 +161,6 @@ pub fn env() -> ~[(~str,~str)] {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n-            #[fixed_stack_segment]; #[inline(never)];\n             use c_str;\n             use str::StrSlice;\n \n@@ -185,8 +182,6 @@ pub fn env() -> ~[(~str,~str)] {\n         }\n         #[cfg(unix)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n             extern {\n                 fn rust_env_pairs() -> **libc::c_char;\n             }\n@@ -225,7 +220,6 @@ pub fn env() -> ~[(~str,~str)] {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             let s = do n.with_c_str |buf| {\n@@ -244,8 +238,6 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         do with_env_lock {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n@@ -263,7 +255,6 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             do n.with_c_str |nbuf| {\n@@ -280,8 +271,6 @@ pub fn setenv(n: &str, v: &str) {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         do with_env_lock {\n             use os::win32::as_utf16_p;\n@@ -298,7 +287,6 @@ pub fn setenv(n: &str, v: &str) {\n pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 do n.with_c_str |nbuf| {\n@@ -309,7 +297,6 @@ pub fn unsetenv(n: &str) {\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 use os::win32::as_utf16_p;\n@@ -330,7 +317,6 @@ pub struct Pipe {\n \n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         let mut fds = Pipe {input: 0 as c_int,\n                             out: 0 as c_int };\n@@ -341,7 +327,6 @@ pub fn pipe() -> Pipe {\n \n #[cfg(windows)]\n pub fn pipe() -> Pipe {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         // Windows pipes work subtly differently than unix pipes, and their\n         // inheritance has to be handled in a different way that I do not\n@@ -360,7 +345,6 @@ pub fn pipe() -> Pipe {\n }\n \n fn dup2(src: c_int, dst: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::dup2(src, dst)\n     }\n@@ -377,7 +361,6 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n     fn load_self() -> Option<~[u8]> {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n@@ -415,7 +398,6 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> Option<~[u8]> {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n             use vec;\n@@ -434,7 +416,6 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn load_self() -> Option<~[u8]> {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             do fill_utf16_buf_and_decode() |buf, sz| {\n@@ -555,7 +536,6 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.as_str().unwrap()) |buf| {\n@@ -566,7 +546,6 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n@@ -581,7 +560,6 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn errno_location() -> *c_int {\n-        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __error() -> *c_int;\n@@ -594,7 +572,6 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn errno_location() -> *c_int {\n-        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __errno_location() -> *c_int;\n@@ -612,7 +589,6 @@ pub fn errno() -> int {\n #[cfg(windows)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n     use libc::types::os::arch::extra::DWORD;\n \n     #[link_name = \"kernel32\"]\n@@ -634,8 +610,6 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"freebsd\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n                       -> c_int {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n             #[nolink]\n             extern {\n                 fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n@@ -651,7 +625,6 @@ pub fn last_os_error() -> ~str {\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n-            #[fixed_stack_segment]; #[inline(never)];\n             #[nolink]\n             extern {\n                 fn __xpg_strerror_r(errnum: c_int,\n@@ -679,8 +652,6 @@ pub fn last_os_error() -> ~str {\n \n     #[cfg(windows)]\n     fn strerror() -> ~str {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPWSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -758,8 +729,6 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n  */\n #[cfg(target_os = \"macos\")]\n fn real_args() -> ~[~str] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as c_int,\n                             *_NSGetArgv() as **c_char);\n@@ -781,7 +750,6 @@ fn real_args() -> ~[~str] {\n \n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n-    #[fixed_stack_segment]; #[inline(never)];\n     use vec;\n \n     let mut nArgs: c_int = 0;\n@@ -858,17 +826,13 @@ fn round_up(from: uint, to: uint) -> uint {\n \n #[cfg(unix)]\n pub fn page_size() -> uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         libc::sysconf(libc::_SC_PAGESIZE) as uint\n     }\n }\n \n #[cfg(windows)]\n pub fn page_size() -> uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         let mut info = libc::SYSTEM_INFO::new();\n         libc::GetSystemInfo(&mut info);\n@@ -979,8 +943,6 @@ impl to_str::ToStr for MapError {\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::off_t;\n \n         let mut addr: *c_void = ptr::null();\n@@ -1043,8 +1005,6 @@ impl MemoryMap {\n impl Drop for MemoryMap {\n     /// Unmap the mapping. Fails the task if `munmap` fails.\n     fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             match libc::munmap(self.data as *c_void, self.len) {\n                 0 => (),\n@@ -1062,8 +1022,6 @@ impl Drop for MemoryMap {\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n         let mut lpAddress: LPVOID = ptr::mut_null();\n@@ -1156,8 +1114,6 @@ impl MemoryMap {\n     /// Granularity of MapAddr() and MapOffset() parameter values.\n     /// This may be greater than the value returned by page_size().\n     pub fn granularity() -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             let mut info = libc::SYSTEM_INFO::new();\n             libc::GetSystemInfo(&mut info);\n@@ -1172,8 +1128,6 @@ impl Drop for MemoryMap {\n     /// Unmap the mapping. Fails the task if any of `VirtualFree`, `UnmapViewOfFile`, or\n     /// `CloseHandle` fail.\n     fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n         use libc::consts::os::extra::FALSE;\n \n@@ -1490,25 +1444,19 @@ mod tests {\n \n     #[test]\n     fn memory_map_file() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n         use rt::io;\n         use rt::io::fs;\n \n         #[cfg(unix)]\n-        #[fixed_stack_segment]\n-        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n             unsafe {\n                 assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n             }\n         }\n         #[cfg(windows)]\n-        #[fixed_stack_segment]\n-        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n            unsafe {\n                assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);"}, {"sha": "73d5c72a728863b2b38d10e4ad07a26ec0346c86", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -71,7 +71,7 @@ impl OSRng {\n     /// Create a new `OSRng`.\n     #[cfg(windows)]\n     pub fn new() -> OSRng {\n-        externfn!(fn rust_win32_rand_acquire(phProv: *mut HCRYPTPROV))\n+        extern { fn rust_win32_rand_acquire(phProv: *mut HCRYPTPROV); }\n \n         let mut hcp = 0;\n         unsafe {rust_win32_rand_acquire(&mut hcp)};\n@@ -106,7 +106,10 @@ impl Rng for OSRng {\n         unsafe { cast::transmute(v) }\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {\n-        externfn!(fn rust_win32_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD, pbBuffer: *mut BYTE))\n+        extern {\n+            fn rust_win32_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD,\n+                                   pbBuffer: *mut BYTE);\n+        }\n \n         do v.as_mut_buf |ptr, len| {\n             unsafe {rust_win32_rand_gen(self.hcryptprov, len as DWORD, ptr)}\n@@ -123,7 +126,7 @@ impl Drop for OSRng {\n \n     #[cfg(windows)]\n     fn drop(&mut self) {\n-        externfn!(fn rust_win32_rand_release(hProv: HCRYPTPROV))\n+        extern { fn rust_win32_rand_release(hProv: HCRYPTPROV); }\n \n         unsafe {rust_win32_rand_release(self.hcryptprov)}\n     }"}, {"sha": "48e588790268586d9acbfe5364269ac6614bd93b", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -117,9 +117,11 @@ mod imp {\n         }\n     }\n \n-    externfn!(fn rust_take_global_args_lock())\n-    externfn!(fn rust_drop_global_args_lock())\n-    externfn!(fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>)\n+    extern {\n+        fn rust_take_global_args_lock();\n+        fn rust_drop_global_args_lock();\n+        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n+    }\n \n     #[cfg(test)]\n     mod tests {"}, {"sha": "a8f762c4c8fc127934b027eac2d22127cf1ddcb4", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -236,7 +236,6 @@ impl Drop for BasicPausible {\n }\n \n fn time() -> Time {\n-    #[fixed_stack_segment]; #[inline(never)];\n     extern {\n         fn get_time(sec: &mut i64, nsec: &mut i32);\n     }"}, {"sha": "fcc30ded9542a620f0c63566cc5257a4b903489c", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -119,7 +119,6 @@ impl Context {\n }\n \n extern {\n-    #[rust_stack]\n     fn swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n \n@@ -376,7 +375,6 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     unsafe fn target_record_sp_limit(limit: uint) {\n         return record_sp_limit(limit as *c_void);\n         extern {\n-            #[rust_stack]\n             fn record_sp_limit(limit: *c_void);\n         }\n     }\n@@ -450,7 +448,6 @@ pub unsafe fn get_sp_limit() -> uint {\n     unsafe fn target_get_sp_limit() -> uint {\n         return get_sp_limit() as uint;\n         extern {\n-            #[rust_stack]\n             fn get_sp_limit() -> *c_void;\n         }\n     }"}, {"sha": "8decaea1f4725358fc77ed847f3de577afb1e9ea", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -49,8 +49,6 @@ pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n }\n \n #[cfg(windows)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n     use cast::transmute;\n     use c_str::ToCStr;"}, {"sha": "d1bd450afe2756d8b5e9ae9dbcaa92d0b40e4e27", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -17,7 +17,7 @@ use os;\n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n \n-static mut MIN_STACK: uint = 4000000;\n+static mut MIN_STACK: uint = 2000000;\n static mut DEBUG_BORROW: bool = false;\n static mut POISON_ON_FREE: bool = false;\n "}, {"sha": "c6e2724b0f2027918a1f4035de2936b40ea428a1", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ use unstable::raw;\n use mem::size_of;\n \n extern {\n-    #[rust_stack]\n     fn abort();\n }\n \n@@ -36,8 +35,6 @@ fn align_to(size: uint, align: uint) -> uint {\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n pub unsafe fn malloc_raw(size: uint) -> *c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     let p = malloc(size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -48,8 +45,6 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n \n /// A wrapper around libc::realloc, aborting on out-of-memory\n pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     let p = realloc(ptr, size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -100,8 +95,6 @@ pub unsafe fn exchange_free_(ptr: *c_char) {\n }\n \n pub unsafe fn exchange_free(ptr: *c_char) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     free(ptr as *c_void);\n }\n "}, {"sha": "69d1159bf91a003d6ce3bb903cc42db8d88114bb", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -98,7 +98,6 @@ impl FileDesc {\n }\n \n impl Reader for FileDesc {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n@@ -121,7 +120,6 @@ impl Reader for FileDesc {\n }\n \n impl Writer for FileDesc {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn write(&mut self, buf: &[u8]) {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n@@ -137,7 +135,6 @@ impl Writer for FileDesc {\n }\n \n impl Drop for FileDesc {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&mut self) {\n         if self.close_on_drop {\n             unsafe { libc::close(self.fd); }\n@@ -158,7 +155,6 @@ impl CFile {\n }\n \n impl Reader for CFile {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let ret = do keep_going(buf) |buf, len| {\n             unsafe {\n@@ -176,14 +172,12 @@ impl Reader for CFile {\n         }\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n     fn eof(&mut self) -> bool {\n         unsafe { libc::feof(self.file) != 0 }\n     }\n }\n \n impl Writer for CFile {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn write(&mut self, buf: &[u8]) {\n         let ret = do keep_going(buf) |buf, len| {\n             unsafe {\n@@ -196,7 +190,6 @@ impl Writer for CFile {\n         }\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n     fn flush(&mut self) {\n         if unsafe { libc::fflush(self.file) } < 0 {\n             raise_error();\n@@ -205,7 +198,6 @@ impl Writer for CFile {\n }\n \n impl Seek for CFile {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn tell(&self) -> u64 {\n         let ret = unsafe { libc::ftell(self.file) };\n         if ret < 0 {\n@@ -214,7 +206,6 @@ impl Seek for CFile {\n         return ret as u64;\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n     fn seek(&mut self, pos: i64, style: SeekStyle) {\n         let whence = match style {\n             SeekSet => libc::SEEK_SET,\n@@ -228,7 +219,6 @@ impl Seek for CFile {\n }\n \n impl Drop for CFile {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&mut self) {\n         unsafe { libc::fclose(self.file); }\n     }\n@@ -242,7 +232,6 @@ mod tests {\n     use rt::io::{io_error, SeekSet};\n     use super::*;\n \n-    #[test] #[fixed_stack_segment]\n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with\n@@ -278,7 +267,6 @@ mod tests {\n         }\n     }\n \n-    #[test] #[fixed_stack_segment]\n     #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n     fn test_cfile() {\n         unsafe {\n@@ -358,7 +346,6 @@ mod old_os {\n     #[cfg(unix)]\n     /// Indicates whether a path represents a directory\n     pub fn path_is_dir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do p.with_c_str |buf| {\n                 rustrt::rust_path_is_dir(buf) != 0 as c_int\n@@ -369,7 +356,6 @@ mod old_os {\n \n     #[cfg(windows)]\n     pub fn path_is_dir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n                 rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n@@ -380,7 +366,6 @@ mod old_os {\n     #[cfg(unix)]\n     /// Indicates whether a path exists\n     pub fn path_exists(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do p.with_c_str |buf| {\n                 rustrt::rust_path_exists(buf) != 0 as c_int\n@@ -390,7 +375,6 @@ mod old_os {\n \n     #[cfg(windows)]\n     pub fn path_exists(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n                 rustrt::rust_path_exists_u16(buf) != 0 as c_int\n@@ -404,7 +388,6 @@ mod old_os {\n \n         #[cfg(windows)]\n         fn mkdir(p: &Path, _mode: c_int) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 use os::win32::as_utf16_p;\n                 // FIXME: turn mode into something useful? #2623\n@@ -417,7 +400,6 @@ mod old_os {\n \n         #[cfg(unix)]\n         fn mkdir(p: &Path, mode: c_int) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             do p.with_c_str |buf| {\n                 unsafe {\n                     libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n@@ -457,7 +439,6 @@ mod old_os {\n             #[cfg(target_os = \"freebsd\")]\n             #[cfg(target_os = \"macos\")]\n             unsafe fn get_list(p: &Path) -> ~[Path] {\n-                #[fixed_stack_segment]; #[inline(never)];\n                 use libc::{dirent_t};\n                 use libc::{opendir, readdir, closedir};\n                 extern {\n@@ -488,7 +469,6 @@ mod old_os {\n             }\n             #[cfg(windows)]\n             unsafe fn get_list(p: &Path) -> ~[Path] {\n-                #[fixed_stack_segment]; #[inline(never)];\n                 use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n                 use libc::{wcslen, free};\n                 use libc::funcs::extra::kernel32::{\n@@ -568,7 +548,6 @@ mod old_os {\n \n         #[cfg(windows)]\n         fn rmdir(p: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 use os::win32::as_utf16_p;\n                 return do as_utf16_p(p.as_str().unwrap()) |buf| {\n@@ -579,7 +558,6 @@ mod old_os {\n \n         #[cfg(unix)]\n         fn rmdir(p: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             do p.with_c_str |buf| {\n                 unsafe {\n                     libc::rmdir(buf) == (0 as c_int)\n@@ -594,7 +572,6 @@ mod old_os {\n \n         #[cfg(windows)]\n         fn unlink(p: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 use os::win32::as_utf16_p;\n                 return do as_utf16_p(p.as_str().unwrap()) |buf| {\n@@ -605,7 +582,6 @@ mod old_os {\n \n         #[cfg(unix)]\n         fn unlink(p: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 do p.with_c_str |buf| {\n                     libc::unlink(buf) == (0 as c_int)\n@@ -616,7 +592,6 @@ mod old_os {\n \n     /// Renames an existing file or directory\n     pub fn rename_file(old: &Path, new: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n            do old.with_c_str |old_buf| {\n                 do new.with_c_str |new_buf| {\n@@ -632,7 +607,6 @@ mod old_os {\n \n         #[cfg(windows)]\n         fn do_copy_file(from: &Path, to: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 use os::win32::as_utf16_p;\n                 return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n@@ -646,7 +620,6 @@ mod old_os {\n \n         #[cfg(unix)]\n         fn do_copy_file(from: &Path, to: &Path) -> bool {\n-            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 let istream = do from.with_c_str |fromp| {\n                     do \"rb\".with_c_str |modebuf| {"}, {"sha": "9bf0ed63e8c4ba0b3474c467f0bab2b3665f3f78", "filename": "src/libstd/rt/io/native/process.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -69,8 +69,6 @@ impl Process {\n                stdin: Option<file::fd_t>,\n                stdout: Option<file::fd_t>,\n                stderr: Option<file::fd_t>) -> Process {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         let (in_pipe, in_fd) = match stdin {\n             None => {\n                 let pipe = os::pipe();\n@@ -208,7 +206,6 @@ impl Process {\n \n         #[cfg(windows)]\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            #[fixed_stack_segment]; #[inline(never)];\n             match signal {\n                 io::process::PleaseExitSignal |\n                 io::process::MustDieSignal => {\n@@ -226,7 +223,6 @@ impl Process {\n \n         #[cfg(not(windows))]\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            #[fixed_stack_segment]; #[inline(never)];\n             libc::funcs::posix88::signal::kill(pid, signal as c_int);\n             Ok(())\n         }\n@@ -254,8 +250,6 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n         TRUE, FALSE,\n@@ -439,8 +433,6 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n \n@@ -455,7 +447,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n     unsafe fn set_environ(_envp: *c_void) {}\n     #[cfg(target_os = \"macos\")]\n     unsafe fn set_environ(envp: *c_void) {\n-        externfn!(fn _NSGetEnviron() -> *mut *c_void);\n+        extern { fn _NSGetEnviron() -> *mut *c_void; }\n \n         *_NSGetEnviron() = envp;\n     }\n@@ -603,7 +595,6 @@ fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n \n #[cfg(windows)]\n fn free_handle(handle: *()) {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n@@ -629,8 +620,6 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::types::os::arch::extra::DWORD;\n         use libc::consts::os::extra::{\n             SYNCHRONIZE,\n@@ -676,8 +665,6 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         use libc::funcs::posix01::wait::*;\n \n         #[cfg(target_os = \"linux\")]"}, {"sha": "3f013d5cac9fbac32e83ca517a48d97513582aa5", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -154,7 +154,6 @@ mod test {\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n-    #[fixed_stack_segment]\n     fn sigint() {\n         unsafe {\n             libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);"}, {"sha": "e829c77cec131dc5a1606701d550b12cabf87d5a", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -69,7 +69,6 @@ enum StdSource {\n     File(~RtioFileStream),\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n     do with_local_io |io| {\n         let fd = unsafe { libc::dup(fd) };\n@@ -91,7 +90,6 @@ fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// See `stdout()` for notes about this function.\n-#[fixed_stack_segment] #[inline(never)]\n pub fn stdin() -> StdReader {\n     do src(libc::STDIN_FILENO, true) |src| { StdReader { inner: src } }\n }"}, {"sha": "f35b657d9ddce00b06ac197031ff0a5d2afb0464", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -26,8 +26,6 @@ use tls = rt::thread_local_storage;\n static mut RT_TLS_KEY: tls::Key = -1;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub fn init_tls_key() {\n     unsafe {\n         rust_initialize_rt_tls_key(&mut RT_TLS_KEY);"}, {"sha": "f346380ff7a479edeb9ba6617f6f706da1750e06", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -135,7 +135,6 @@ fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n     if longest_match >= 0 { return 1; } else { return 0; }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n /// Set log level for every entry in crate_map according to the sepecification\n /// in settings\n fn update_log_settings(crate_map: &CrateMap, settings: ~str) {"}, {"sha": "f18b4dc4234ec9ba627d6dae2b255992baadaf83", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -463,8 +463,6 @@ pub fn in_green_task_context() -> bool {\n }\n \n pub fn new_event_loop() -> ~rtio::EventLoop {\n-    #[fixed_stack_segment]; #[allow(cstack)];\n-\n     match crate_map::get_crate_map() {\n         None => {}\n         Some(map) => {"}, {"sha": "f4e5811acd31290d9acb8e2874287954698eb04d", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -853,7 +853,6 @@ fn new_sched_rng() -> XorShiftRng {\n     XorShiftRng::new()\n }\n #[cfg(unix)]\n-#[fixed_stack_segment] #[inline(never)]\n fn new_sched_rng() -> XorShiftRng {\n     use libc;\n     use mem;"}, {"sha": "4358390da9f710be8201bf4659892716d3144224", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -21,8 +21,6 @@ pub struct StackSegment {\n \n impl StackSegment {\n     pub fn new(size: uint) -> StackSegment {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             // Crate a block of uninitialized values\n             let mut stack = vec::with_capacity(size);\n@@ -54,8 +52,6 @@ impl StackSegment {\n \n impl Drop for StackSegment {\n     fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             // XXX: Using the FFI to call a C macro. Slow\n             rust_valgrind_stack_deregister(self.valgrind_id);"}, {"sha": "7620a4371c14bfc11bf4dd90630a30e51ab0a055", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -509,16 +509,13 @@ impl Unwinder {\n         }\n \n         extern {\n-            #[rust_stack]\n             fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n                         code: *c_void,\n                         data: *c_void) -> uintptr_t;\n         }\n     }\n \n     pub fn begin_unwind(&mut self, cause: ~Any) -> ! {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         self.unwinding = true;\n         self.cause = Some(cause);\n         unsafe {\n@@ -537,9 +534,8 @@ impl Unwinder {\n /// truly consider it to be stack overflow rather than allocating a new stack.\n #[no_mangle]      // - this is called from C code\n #[no_split_stack] // - it would be sad for this function to trigger __morestack\n-#[doc(hidden)] // XXX: this function shouldn't have to be `pub` to get exported\n-               //      so it can be linked against, we should have a better way\n-               //      of specifying that.\n+#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n+                  //   irrelevant for documentation purposes.\n pub extern \"C\" fn rust_stack_exhausted() {\n     use rt::in_green_task_context;\n     use rt::task::Task;"}, {"sha": "3db9c049eb2df6ecad9e0871c85d29585e99565c", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -143,8 +143,6 @@ mod darwin_fd_limit {\n     static RLIMIT_NOFILE: libc::c_int = 8;\n \n     pub unsafe fn raise_fd_limit() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n         use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n@@ -362,7 +360,6 @@ pub fn cleanup_task(mut task: ~Task) {\n }\n \n /// Get a port number, starting at 9600, for use in tests\n-#[fixed_stack_segment] #[inline(never)]\n pub fn next_test_port() -> u16 {\n     unsafe {\n         return rust_dbg_next_port(base_port() as libc::uintptr_t) as u16;\n@@ -373,7 +370,6 @@ pub fn next_test_port() -> u16 {\n }\n \n /// Get a temporary path which could be the location of a unix socket\n-#[fixed_stack_segment] #[inline(never)]\n pub fn next_test_unix() -> Path {\n     if cfg!(unix) {\n         os::tmpdir().join(rand::task_rng().gen_ascii_str(20))"}, {"sha": "5e535d994f9ef4cbc27576c1c6728b73579d7774", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -68,8 +68,6 @@ impl Thread {\n #[cfg(windows)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n                         tramp: ~~fn()) -> rust_thread {\n-    #[fixed_stack_segment];\n-\n     unsafe {\n         let ptr: *mut libc::c_void = cast::transmute(tramp);\n         CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start, ptr, 0, ptr::mut_null())\n@@ -78,16 +76,13 @@ fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_threa\n \n #[cfg(windows)]\n fn native_thread_join(native: rust_thread) {\n-    #[fixed_stack_segment];\n     use libc::consts::os::extra::INFINITE;\n     unsafe { WaitForSingleObject(native, INFINITE); }\n }\n \n #[cfg(unix)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n                         tramp: ~~fn()) -> rust_thread {\n-    #[fixed_stack_segment];\n-\n     use unstable::intrinsics;\n     let mut native: libc::pthread_t = unsafe { intrinsics::uninit() };\n \n@@ -107,13 +102,11 @@ fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_threa\n \n #[cfg(unix)]\n fn native_thread_join(native: rust_thread) {\n-    #[fixed_stack_segment];\n     unsafe { assert!(pthread_join(native, ptr::null()) == 0) }\n }\n \n impl Drop for Thread {\n     fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n         assert!(self.joined);\n     }\n }"}, {"sha": "8fa64852846a836bee4ec75e9354c2dbedb2980c", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -20,8 +20,6 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     assert_eq!(0, pthread_key_create(key, null()));\n }\n@@ -49,29 +47,14 @@ type pthread_key_t = ::libc::c_uint;\n #[cfg(unix)]\n extern {\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n-\n-    // This function is a very cheap operation on both osx and unix. On osx, it\n-    // turns out it's just three instructions, and on unix it's a cheap function\n-    // which only uses a very small amount of stack.\n-    //\n-    // This is not marked as such because we think it has a small stack, but\n-    // rather we would like to be able to fetch information from\n-    // thread-local-storage when a task is running very low on its stack budget.\n-    // For example, this is invoked whenever stack overflow is detected, and we\n-    // obviously have very little budget to deal with (certainly not anything\n-    // close to a fixed_stack_segment)\n-    #[rust_stack]\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n-    #[rust_stack]\n     fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n }\n \n #[cfg(windows)]\n pub type Key = DWORD;\n \n #[cfg(windows)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n     *key = TlsAlloc();\n@@ -91,13 +74,7 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n #[cfg(windows)]\n extern \"system\" {\n     fn TlsAlloc() -> DWORD;\n-\n-    // See the reasoning in pthread_getspecific as to why this has the\n-    // 'rust_stack' attribute, as this function was also verified to only\n-    // require a small amount of stack.\n-    #[rust_stack]\n     fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n-    #[rust_stack]\n     fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }\n "}, {"sha": "50f73becef2b8b84f5ecdb17298e1954346aa24f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -24,8 +24,6 @@ pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     unsafe {\n         return rust_get_num_cpus();\n     }\n@@ -146,7 +144,6 @@ memory and partly incapable of presentation to others.\",\n     abort();\n \n     fn abort() -> ! {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe { libc::abort() }\n     }\n }"}, {"sha": "844f61dda0ba5be63213f529b87a9f0cf0478d82", "filename": "src/libstd/run.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -296,7 +296,6 @@ impl Process {\n  *\n  * The process's exit code\n  */\n-#[fixed_stack_segment] #[inline(never)]\n pub fn process_status(prog: &str, args: &[~str]) -> int {\n     let mut prog = Process::new(prog, args, ProcessOptions {\n         env: None,"}, {"sha": "51c11b69972fbd2238ccd1598a5335ab37f54f3b", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -1145,12 +1145,14 @@ fn test_spawn_sched_childs_on_default_sched() {\n mod testrt {\n     use libc;\n \n-    externfn!(fn rust_dbg_lock_create() -> *libc::c_void)\n-    externfn!(fn rust_dbg_lock_destroy(lock: *libc::c_void))\n-    externfn!(fn rust_dbg_lock_lock(lock: *libc::c_void))\n-    externfn!(fn rust_dbg_lock_unlock(lock: *libc::c_void))\n-    externfn!(fn rust_dbg_lock_wait(lock: *libc::c_void))\n-    externfn!(fn rust_dbg_lock_signal(lock: *libc::c_void))\n+    extern {\n+        pub fn rust_dbg_lock_create() -> *libc::c_void;\n+        pub fn rust_dbg_lock_destroy(lock: *libc::c_void);\n+        pub fn rust_dbg_lock_lock(lock: *libc::c_void);\n+        pub fn rust_dbg_lock_unlock(lock: *libc::c_void);\n+        pub fn rust_dbg_lock_wait(lock: *libc::c_void);\n+        pub fn rust_dbg_lock_signal(lock: *libc::c_void);\n+    }\n }\n \n #[test]"}, {"sha": "1ce228250c971ba0a6af4ce70226a182bfa10bf8", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -144,21 +144,16 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n         do filename.with_c_str |raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence. `atomically` asserts that we don't do anything that\n@@ -184,13 +179,9 @@ pub mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         dlsym(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         dlclose(handle); ()\n     }\n \n@@ -225,21 +216,18 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n         do os::win32::as_utf16_p(filename.as_str().unwrap()) |raw_name| {\n             LoadLibraryW(raw_name)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n         let handle = ptr::null();\n         GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n         handle\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n-        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do atomically {\n                 SetLastError(0);\n@@ -257,11 +245,9 @@ pub mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n-        #[fixed_stack_segment]; #[inline(never)];\n         GetProcAddress(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n-        #[fixed_stack_segment]; #[inline(never)];\n         FreeLibrary(handle); ()\n     }\n "}, {"sha": "f0b94c10fdce73528ec66d728d1e9cd22ffed42f", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -369,28 +369,16 @@ extern \"rust-intrinsic\" {\n     pub fn powif32(a: f32, x: i32) -> f32;\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n-    // the following kill the stack canary without\n-    // `fixed_stack_segment`. This possibly only affects the f64\n-    // variants, but it's hard to be sure since it seems to only\n-    // occur with fairly specific arguments.\n-    #[fixed_stack_segment]\n     pub fn sinf32(x: f32) -> f32;\n-    #[fixed_stack_segment]\n     pub fn sinf64(x: f64) -> f64;\n \n-    #[fixed_stack_segment]\n     pub fn cosf32(x: f32) -> f32;\n-    #[fixed_stack_segment]\n     pub fn cosf64(x: f64) -> f64;\n \n-    #[fixed_stack_segment]\n     pub fn powf32(a: f32, x: f32) -> f32;\n-    #[fixed_stack_segment]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n-    #[fixed_stack_segment]\n     pub fn expf32(x: f32) -> f32;\n-    #[fixed_stack_segment]\n     pub fn expf64(x: f64) -> f64;\n \n     pub fn exp2f32(x: f32) -> f32;"}, {"sha": "ea03ea6f551c2a2dece7c1ff0bfb5047c5cd4ddf", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -72,7 +72,6 @@ fn test_run_in_bare_thread_exchange() {\n /// can't run correctly un-altered. Valgrind is there to help\n /// you notice weirdness in normal, un-doctored code paths!\n pub fn running_on_valgrind() -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n     unsafe { rust_running_on_valgrind() != 0 }\n }\n "}, {"sha": "a08b914ca314ac883e5c53ae1a3533ab5501bcc6", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -475,12 +475,14 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-externfn!(fn rust_create_little_lock() -> rust_little_lock)\n-externfn!(fn rust_destroy_little_lock(lock: rust_little_lock))\n-externfn!(fn rust_lock_little_lock(lock: rust_little_lock))\n-externfn!(fn rust_unlock_little_lock(lock: rust_little_lock))\n-externfn!(fn rust_signal_little_lock(lock: rust_little_lock))\n-externfn!(fn rust_wait_little_lock(lock: rust_little_lock))\n+extern {\n+    fn rust_create_little_lock() -> rust_little_lock;\n+    fn rust_destroy_little_lock(lock: rust_little_lock);\n+    fn rust_lock_little_lock(lock: rust_little_lock);\n+    fn rust_unlock_little_lock(lock: rust_little_lock);\n+    fn rust_signal_little_lock(lock: rust_little_lock);\n+    fn rust_wait_little_lock(lock: rust_little_lock);\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "838ce4a630948590238cf2d40af7a223f3a60c59", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -201,7 +201,6 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n \n     let stderr = @mut io::stderr() as @mut io::Writer;\n     fn is_stderr_screen() -> bool {\n-        #[fixed_stack_segment];\n         use std::libc;\n         unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n     }"}, {"sha": "f8155ae2e6bc33242955de69bbc5ee4753286b91", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -959,84 +959,6 @@ pub fn std_macros() -> @str {\n             pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n         )\n     )\n-\n-    /// externfn! declares a wrapper for an external function.\n-    /// It is intended to be used like:\n-    ///\n-    /// externfn!(#[nolink]\n-    ///           fn memcmp(cx: *u8, ct: *u8, n: u32) -> u32)\n-    ///\n-    /// Due to limitations in the macro parser, this pattern must be\n-    /// implemented with 4 distinct patterns (with attrs / without\n-    /// attrs CROSS with args / without ARGS).\n-    ///\n-    /// Also, this macro grammar allows for any number of return types\n-    /// because I couldn't figure out the syntax to specify at most one.\n-    macro_rules! externfn(\n-        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n-            pub unsafe fn $name() $(-> $ret_ty),* {\n-                // Note: to avoid obscure bug in macros, keep these\n-                // attributes *internal* to the fn\n-                #[fixed_stack_segment];\n-                #[inline(never)];\n-                #[allow(missing_doc)];\n-\n-                return $name();\n-\n-                extern {\n-                    fn $name() $(-> $ret_ty),*;\n-                }\n-            }\n-        );\n-        (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n-            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n-                // Note: to avoid obscure bug in macros, keep these\n-                // attributes *internal* to the fn\n-                #[fixed_stack_segment];\n-                #[inline(never)];\n-                #[allow(missing_doc)];\n-\n-                return $name($($arg_name),*);\n-\n-                extern {\n-                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n-                }\n-            }\n-        );\n-        ($($attrs:attr)* fn $name:ident () $(-> $ret_ty:ty),*) => (\n-            pub unsafe fn $name() $(-> $ret_ty),* {\n-                // Note: to avoid obscure bug in macros, keep these\n-                // attributes *internal* to the fn\n-                #[fixed_stack_segment];\n-                #[inline(never)];\n-                #[allow(missing_doc)];\n-\n-                return $name();\n-\n-                $($attrs)*\n-                extern {\n-                    fn $name() $(-> $ret_ty),*;\n-                }\n-            }\n-        );\n-        ($($attrs:attr)* fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n-            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n-                // Note: to avoid obscure bug in macros, keep these\n-                // attributes *internal* to the fn\n-                #[fixed_stack_segment];\n-                #[inline(never)];\n-                #[allow(missing_doc)];\n-\n-                return $name($($arg_name),*);\n-\n-                $($attrs)*\n-                extern {\n-                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n-                }\n-            }\n-        )\n-    )\n-\n }\"#\n }\n "}, {"sha": "247be194b90feb88e95cfca6d8ff064e3d266d3c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -22,6 +22,8 @@\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs, managed_boxes)];\n+#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n+#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n extern mod extra;\n "}, {"sha": "e77efce7f5876497169769a30fa7b43681d255cd", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -25,7 +25,6 @@ pub mod rustrt {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "37efa5768af7cd819dc7b2fc159448cc10281832", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -91,7 +91,6 @@ fn vector<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n     }\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let args = os::args();\n     let n_keys = {"}, {"sha": "079ec7c50bbc22617df011a35eb5bd948487d813", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -91,7 +91,6 @@ fn fannkuch_redux(n: i32) -> i32 {\n     }\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let n: i32 = FromStr::from_str(os::args()[1]).unwrap();\n     println!(\"Pfannkuchen({}) = {}\", n as int, fannkuch_redux(n) as int);"}, {"sha": "11274905a4ea6e2adf0fd30f73364ed01bbd4f57", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -184,7 +184,6 @@ impl RandomFasta {\n     }\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n "}, {"sha": "f2ba0d40ebc69290bce9292ab197ca6058177a66", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -243,8 +243,6 @@ fn read_stdin() -> ~[u8] {\n     }\n }\n \n-#[inline(never)]\n-#[fixed_stack_segment]\n fn generate_frequencies(frequencies: &mut Table,\n                         mut input: &[u8],\n                         frame: i32) {\n@@ -264,8 +262,6 @@ fn generate_frequencies(frequencies: &mut Table,\n     }\n }\n \n-#[inline(never)]\n-#[fixed_stack_segment]\n fn print_frequencies(frequencies: &Table, frame: i32) {\n     let mut vector = ~[];\n     for frequencies.each |entry| {\n@@ -289,7 +285,6 @@ fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n     frequencies.lookup(Code::pack(occurrence), PrintCallback(occurrence))\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let input = read_stdin();\n "}, {"sha": "6af0e04a8dd4efab591e10ecb580f5f1327186d7", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -8,7 +8,6 @@ use std::os;\n static ITER: uint = 50;\n static LIMIT: f64 = 2.0;\n \n-#[fixed_stack_segment]\n fn main() {\n     unsafe {\n         let w: i32 = FromStr::from_str(os::args()[1]).unwrap();"}, {"sha": "355adc39c7177492b208f5164abe58ea47fe5de5", "filename": "src/test/bench/shootout-pidigits.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -161,7 +161,6 @@ fn pidigits(n: u32) {\n     }\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let n: u32 = FromStr::from_str(os::args()[1]).get();\n     pidigits(n);"}, {"sha": "d0e13865347d80149a8c0b9cc921c04c1ac98fe3", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -90,7 +90,6 @@ static COMPLEMENTS: [u8, ..256] = [\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n ];\n \n-#[fixed_stack_segment]\n fn main() {\n     unsafe {\n         let mode = \"r\";"}, {"sha": "6a9837fb832ca6593271ad742c150b9705524941", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -52,7 +52,6 @@ fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n     mult_Atv(tmp, out);\n }\n \n-#[fixed_stack_segment]\n fn main() {\n     let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n     let mut u = vec::from_elem(n, 1f64);"}, {"sha": "8ccd92316e922dce42ae243761dfd3ebb9f6361d", "filename": "src/test/compile-fail/extern-cstack-lint.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Ftest%2Fcompile-fail%2Fextern-cstack-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Ftest%2Fcompile-fail%2Fextern-cstack-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-cstack-lint.rs?ref=4d9b95fada7c97ac1c63099bab1d45ba120958ec", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern fn f() {\n-}\n-\n-extern fn call1() {\n-    f(); // OK from another extern fn!\n-}\n-\n-fn call2() {\n-    f(); //~ ERROR invoking non-Rust fn\n-}\n-\n-\n-fn main() {}"}, {"sha": "11fe02eaef50e99449231f460950e285efbc7b61", "filename": "src/test/compile-fail/lint-cstack.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Ftest%2Fcompile-fail%2Flint-cstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d9b95fada7c97ac1c63099bab1d45ba120958ec/src%2Ftest%2Fcompile-fail%2Flint-cstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-cstack.rs?ref=4d9b95fada7c97ac1c63099bab1d45ba120958ec", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern {\n-    fn rust_get_test_int() -> std::libc::intptr_t;\n-}\n-\n-trait A {\n-    fn foo() {\n-        unsafe {\n-            rust_get_test_int(); //~ ERROR invoking non-Rust fn\n-        }\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "50cc9ceb94e91a1f9c69470c6222ccee50057d0d", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -10,7 +10,6 @@\n \n // Exercise the unused_unsafe attribute in some positive and negative cases\n \n-#[allow(cstack)];\n #[deny(unused_unsafe)];\n \n mod foo {"}, {"sha": "3156cd9af3276ef8fba39523b1bf8c4217158cd0", "filename": "src/test/compile-fail/variadic-ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -18,7 +18,6 @@ extern {\n \n extern \"C\" fn bar(f: int, x: u8) {}\n \n-#[fixed_stack_segment]\n fn main() {\n     unsafe {\n         foo(); //~ ERROR: this function takes at least 2 parameters but 0 parameters were supplied"}, {"sha": "a9c6141c18b46fe72515f0eae2c343ca27042068", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ extern mod anonexternmod;\n \n use anonexternmod::rust_get_test_int;\n \n-#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         rust_get_test_int();"}, {"sha": "3323aa4e2cde6dbc689dcce78aebd79f20d4ae10", "filename": "src/test/run-pass/anon-extern-mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -15,7 +15,6 @@ extern {\n     fn rust_get_test_int() -> libc::intptr_t;\n }\n \n-#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         let _ = rust_get_test_int();"}, {"sha": "940f62789bbc388be712fd0c76fd0236d4cf6fef", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -18,12 +18,10 @@ mod libc {\n     }\n }\n \n-#[fixed_stack_segment]\n fn atol(s: ~str) -> int {\n     s.with_c_str(|x| unsafe { libc::atol(x) as int })\n }\n \n-#[fixed_stack_segment]\n fn atoll(s: ~str) -> i64 {\n     s.with_c_str(|x| unsafe { libc::atoll(x) as i64 })\n }"}, {"sha": "e9cd860bd226eacc01894b6cd4f6f674a2b552a9", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -60,8 +60,6 @@ fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(windows)]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        #[fixed_stack_segment];\n-\n         use std::libc::types::os::arch::extra::DWORD;\n         use std::libc::funcs::extra::kernel32::{CloseHandle, GetExitCodeProcess, OpenProcess};\n         use std::libc::consts::os::extra::{FALSE, PROCESS_QUERY_INFORMATION, STILL_ACTIVE };"}, {"sha": "f55be369b57df546b81aba970579a6bc579c413d", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -28,7 +28,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "5bda762a68bcf1249726832fe6b2b354d33f8996", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -29,7 +29,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "34d2b577f202c0210ccc5033437acc996e6e216f", "filename": "src/test/run-pass/extern-call-direct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-direct.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -13,8 +13,6 @@\n extern fn f(x: uint) -> uint { x * 2 }\n \n pub fn main() {\n-    #[fixed_stack_segment];\n-\n     let x = f(22);\n     assert_eq!(x, 44);\n }"}, {"sha": "6222b681dc994a1448af99ea8110250d8ebd3a85", "filename": "src/test/run-pass/extern-call-indirect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -28,7 +28,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "548336962f5100124b8dfaac9d4ceca87c1b72be", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -33,7 +33,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "f1255c7e8f1ef743fe9fe5f7fa2b0ba3be7f8dd2", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -13,7 +13,6 @@\n \n extern mod externcallback(vers = \"0.1\");\n \n-#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = {}\", n);"}, {"sha": "bb6a68dfda407880bf2bbd290bdee5dc1e515764", "filename": "src/test/run-pass/extern-pass-TwoU16s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -22,7 +22,6 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU16s(v: TwoU16s) -> TwoU16s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU16s {one: 22, two: 23};"}, {"sha": "3389c56c83bf00afd777789a2f270c409f0a8721", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -20,7 +20,6 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU32s(v: TwoU32s) -> TwoU32s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU32s {one: 22, two: 23};"}, {"sha": "caba29a26679022865ed5e1a576a0632a4903a8d", "filename": "src/test/run-pass/extern-pass-TwoU64s-ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -20,7 +20,6 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(u: TwoU64s) -> TwoU64s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "1b5e661ed8e8396b58f447188ade413ffd52eb95", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -25,7 +25,6 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "8757f9593f77074b413435c572e617e18c0596ef", "filename": "src/test/run-pass/extern-pass-TwoU8s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -22,7 +22,6 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU8s(v: TwoU8s) -> TwoU8s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU8s {one: 22, two: 23};"}, {"sha": "0cdfaf29a0582a44e9934eb12c26fa256ab508c8", "filename": "src/test/run-pass/extern-pass-char.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ extern {\n     pub fn rust_dbg_extern_identity_u8(v: u8) -> u8;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u8, rust_dbg_extern_identity_u8(22_u8));"}, {"sha": "cb0a061a7abd831e2d42e185b43e5c3bf1834e50", "filename": "src/test/run-pass/extern-pass-double.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -12,7 +12,6 @@ extern {\n     pub fn rust_dbg_extern_identity_double(v: f64) -> f64;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22.0_f64, rust_dbg_extern_identity_double(22.0_f64));"}, {"sha": "aa54f014046127c735d695d8d74b1fec1177af95", "filename": "src/test/run-pass/extern-pass-u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ extern {\n     pub fn rust_dbg_extern_identity_u32(v: u32) -> u32;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u32, rust_dbg_extern_identity_u32(22_u32));"}, {"sha": "7c39080a5689732dc778d8554e015c0e12a31eee", "filename": "src/test/run-pass/extern-pass-u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ extern {\n     pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u64, rust_dbg_extern_identity_u64(22_u64));"}, {"sha": "ba671a1c4949f3bf82ea231708f881591fcbcd9b", "filename": "src/test/run-pass/extern-return-TwoU16s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -16,7 +16,6 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU16s() -> TwoU16s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU16s();"}, {"sha": "90562f0f6b1cec5419f334d707acc5a6b9fdfbc7", "filename": "src/test/run-pass/extern-return-TwoU32s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -16,7 +16,6 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU32s() -> TwoU32s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU32s();"}, {"sha": "a28795b93e0bb402bdf3a2cf0398862cd82aaece", "filename": "src/test/run-pass/extern-return-TwoU64s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -18,7 +18,6 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU64s() -> TwoU64s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU64s();"}, {"sha": "5d2fd14075844f46379e416535bd9445d590e38f", "filename": "src/test/run-pass/extern-return-TwoU8s.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -16,7 +16,6 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU8s() -> TwoU8s;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU8s();"}, {"sha": "21706848c81cf8328a5d9495bf123a510f5fd928", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -33,7 +33,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         rustrt::rust_dbg_call(cb, n)"}, {"sha": "45841e22896d77da1ef7859e34fbdd25f2945210", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -29,7 +29,6 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         task::deschedule();"}, {"sha": "283efa2ac7c6f31345a4716a59daafc3100a45fa", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -2,8 +2,10 @@ use std::cast;\n use std::libc;\n use std::unstable::run_in_bare_thread;\n \n-externfn!(fn rust_dbg_call(cb: extern \"C\" fn(libc::uintptr_t),\n-                           data: libc::uintptr_t) -> libc::uintptr_t)\n+extern {\n+    fn rust_dbg_call(cb: extern \"C\" fn(libc::uintptr_t),\n+                     data: libc::uintptr_t) -> libc::uintptr_t;\n+}\n \n pub fn main() {\n     unsafe {"}, {"sha": "66d3bda30e6f210b68b06ad6d17e082f9306304d", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -29,7 +29,6 @@ mod rustrt2 {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt1::rust_get_test_int();"}, {"sha": "d05680651f7dde5663daf7f2e8a3ce896893cc5e", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -20,7 +20,6 @@ mod libc {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn strlen(str: ~str) -> uint {\n     // C string is terminated with a zero\n     do str.with_c_str |buf| {"}, {"sha": "0702d49cfc11200486261ce4e80345e70654dafd", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -18,7 +18,6 @@ mod rustrt {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt::rust_get_test_int();"}, {"sha": "7e79311c5ad1f28da6f295538752b967e01634a1", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -17,7 +17,6 @@\n \n extern mod foreign_lib;\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let _foo = foreign_lib::rustrt::rust_get_test_int();"}, {"sha": "5bbbe323722b9323adeeb62d8b4ac74a7f0d8e33", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -19,7 +19,6 @@ fn to_c_int(v: &mut int) -> &mut c_int {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn lgamma(n: c_double, value: &mut int) -> c_double {\n     unsafe {\n         return m::lgamma(n, to_c_int(value));"}, {"sha": "860b23849c6ffcd203be9f094bb3ac9de31f3b57", "filename": "src/test/run-pass/issue-6470.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fissue-6470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fissue-6470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6470.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -14,7 +14,6 @@ pub mod Bar {\n     }\n \n     extern {\n-        #[rust_stack]\n         pub fn foo(v: *Foo) -> Foo;\n     }\n }"}, {"sha": "5d89a2d5b3c8dc288733e58ecfd4e954ec80205c", "filename": "src/test/run-pass/lint-cstack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Flint-cstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Flint-cstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-cstack.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -15,7 +15,6 @@ extern {\n }\n \n trait A {\n-    #[fixed_stack_segment]\n     fn foo() {\n         unsafe {\n             rust_get_test_int();"}, {"sha": "ba3b40867bb9ba5218e2caa2dd027d0979501948", "filename": "src/test/run-pass/newtype-struct-with-dtor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -4,7 +4,6 @@ use std::libc;\n pub struct Fd(c_int);\n \n impl Drop for Fd {\n-    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&mut self) {\n         unsafe {\n             libc::close(**self);"}, {"sha": "c5d631336337a6499a713fffe89d0a3b029d200f", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -6,7 +6,6 @@ mod a {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         a::free(transmute(0));"}, {"sha": "2446fb2a94a964062b04a53f22fa0ab9ee7870e6", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -27,7 +27,6 @@ struct Ccx {\n     x: int\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         cast::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n@@ -39,7 +38,6 @@ fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);"}, {"sha": "bdadcbdb72958eec1c4998ec4bc405dc04f8f806", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -21,7 +21,6 @@ use std::rt::io;\n use std::rt::io::fs;\n \n fn rename_directory() {\n-    #[fixed_stack_segment];\n     unsafe {\n         static U_RWX: i32 = (libc::S_IRUSR | libc::S_IWUSR | libc::S_IXUSR) as i32;\n "}, {"sha": "bdfc747c8bc77339e0f3f44228acec4ea97bb0ed", "filename": "src/test/run-pass/static-mut-foreign.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -26,7 +26,6 @@ fn static_bound_set(a: &'static mut libc::c_int) {\n     *a = 3;\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n unsafe fn run() {\n     assert!(rust_dbg_static_mut == 3);\n     rust_dbg_static_mut = 4;"}, {"sha": "7edaad3748ae7225d0a0985a5eb591eac2f1bee2", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -23,7 +23,6 @@ mod rustrt {\n     }\n }\n \n-#[fixed_stack_segment] #[inline(never)]\n fn test1() {\n     unsafe {\n         let q = Quad { a: 0xaaaa_aaaa_aaaa_aaaa_u64,\n@@ -43,8 +42,6 @@ fn test1() {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-#[fixed_stack_segment]\n-#[inline(never)]\n fn test2() {\n     unsafe {\n         let f = Floats { a: 1.234567890e-15_f64,"}, {"sha": "d82e2890ae8d3c95206c3378753f05e4085fac2f", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -22,7 +22,6 @@ unsafe fn check<T>(expected: &str, f: &fn(*mut c_char) -> T) {\n     assert_eq!(expected, res.as_str().unwrap());\n }\n \n-#[fixed_stack_segment]\n pub fn main() {\n \n     unsafe {\n@@ -43,8 +42,6 @@ pub fn main() {\n \n         // A function that takes a function pointer\n         unsafe fn call(p: extern \"C\" unsafe fn(*mut c_char, *c_char, ...) -> c_int) {\n-            #[fixed_stack_segment];\n-\n             // Call with just the named parameter via fn pointer\n             do \"Hello World\\n\".with_c_str |c| {\n                 check(\"Hello World\\n\", |s| p(s, c));"}, {"sha": "522e5fd978ead309168c71dc427caeea76e74dd7", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0966ec01dcb0ff90e6d483706820794ef8e16c2e/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=0966ec01dcb0ff90e6d483706820794ef8e16c2e", "patch": "@@ -28,7 +28,6 @@ mod kernel32 {\n \n \n #[cfg(windows)]\n-#[fixed_stack_segment]\n pub fn main() {\n     let heap = unsafe { kernel32::GetProcessHeap() };\n     let mem = unsafe { kernel32::HeapAlloc(heap, 0u32, 100u32) };"}]}