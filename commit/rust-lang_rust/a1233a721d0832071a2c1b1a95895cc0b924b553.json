{"sha": "a1233a721d0832071a2c1b1a95895cc0b924b553", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjMzYTcyMWQwODMyMDcxYTJjMWIxYTk1ODk1Y2MwYjkyNGI1NTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-15T18:33:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-16T08:10:12Z"}, "message": "adjust Miri to Pointer type overhaul", "tree": {"sha": "534c4b88a31c57b9919f5aa320de1fb453702639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/534c4b88a31c57b9919f5aa320de1fb453702639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1233a721d0832071a2c1b1a95895cc0b924b553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1233a721d0832071a2c1b1a95895cc0b924b553", "html_url": "https://github.com/rust-lang/rust/commit/a1233a721d0832071a2c1b1a95895cc0b924b553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1233a721d0832071a2c1b1a95895cc0b924b553/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4a9a36d20eb59e38773bac8c5ddeb26d3da08bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a9a36d20eb59e38773bac8c5ddeb26d3da08bd", "html_url": "https://github.com/rust-lang/rust/commit/a4a9a36d20eb59e38773bac8c5ddeb26d3da08bd"}], "stats": {"total": 1409, "additions": 750, "deletions": 659}, "files": [{"sha": "5a8f07263f35b707b1730e6b6d61a7f4dc4884ce", "filename": "src/bin/miri.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -10,6 +10,7 @@ extern crate rustc_session;\n \n use std::convert::TryFrom;\n use std::env;\n+use std::num::NonZeroU64;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n@@ -412,11 +413,16 @@ fn main() {\n                     }\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-alloc-id=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap().parse()\n+                    let id = match arg\n+                        .strip_prefix(\"-Zmiri-track-alloc-id=\")\n+                        .unwrap()\n+                        .parse()\n+                        .ok()\n+                        .and_then(NonZeroU64::new)\n                     {\n-                        Ok(id) => id,\n-                        Err(err) =>\n-                            panic!(\"-Zmiri-track-alloc-id requires a valid `u64` argument: {}\", err),\n+                        Some(id) => id,\n+                        None =>\n+                            panic!(\"-Zmiri-track-alloc-id requires a valid non-zero `u64` argument\"),\n                     };\n                     miri_config.tracked_alloc_id = Some(miri::AllocId(id));\n                 }"}, {"sha": "6a64c1cb693698d374da064d9c78956c24b8d50a", "filename": "src/data_race.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -73,9 +73,9 @@ use rustc_middle::{mir, ty::layout::TyAndLayout};\n use rustc_target::abi::Size;\n \n use crate::{\n-    ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MemoryKind, MiriEvalContext,\n-    MiriEvalContextExt, MiriMemoryKind, OpTy, Pointer, RangeMap, Scalar, ScalarMaybeUninit, Tag,\n-    ThreadId, VClock, VTimestamp, VectorIdx,\n+    AllocId, AllocRange, ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MemoryKind,\n+    MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, OpTy, Pointer, RangeMap, Scalar,\n+    ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp, VectorIdx,\n };\n \n pub type AllocExtra = VClockAlloc;\n@@ -561,7 +561,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             if lt { &rhs } else { &old }\n         };\n \n-        this.allow_data_races_mut(|this| this.write_immediate_to_mplace(**new_val, place))?;\n+        this.allow_data_races_mut(|this| this.write_immediate(**new_val, &(*place).into()))?;\n \n         this.validate_atomic_rmw(&place, atomic)?;\n \n@@ -713,18 +713,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             Ok(())\n         }\n     }\n-\n-    fn reset_vector_clocks(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        if let Some(data_race) = &mut this.memory.extra.data_race {\n-            if data_race.multi_threaded.get() {\n-                let alloc_meta =\n-                    this.memory.get_alloc_extra_mut(ptr.alloc_id)?.0.data_race.as_mut().unwrap();\n-                alloc_meta.reset_clocks(ptr.offset, size);\n-            }\n-        }\n-        Ok(())\n-    }\n }\n \n /// Vector clock metadata for a logical memory allocation.\n@@ -769,14 +757,6 @@ impl VClockAlloc {\n         }\n     }\n \n-    fn reset_clocks(&mut self, offset: Size, len: Size) {\n-        let alloc_ranges = self.alloc_ranges.get_mut();\n-        for (_, range) in alloc_ranges.iter_mut(offset, len) {\n-            // Reset the portion of the range\n-            *range = MemoryCellClocks::new(0, VectorIdx::MAX_INDEX);\n-        }\n-    }\n-\n     // Find an index, if one exists where the value\n     // in `l` is greater than the value in `r`.\n     fn find_gt_index(l: &VClock, r: &VClock) -> Option<VectorIdx> {\n@@ -820,8 +800,7 @@ impl VClockAlloc {\n         range: &MemoryCellClocks,\n         action: &str,\n         is_atomic: bool,\n-        pointer: Pointer<Tag>,\n-        len: Size,\n+        ptr_dbg: Pointer<AllocId>,\n     ) -> InterpResult<'tcx> {\n         let (current_index, current_clocks) = global.current_thread_state();\n         let write_clock;\n@@ -863,15 +842,12 @@ impl VClockAlloc {\n \n         // Throw the data-race detection.\n         throw_ub_format!(\n-            \"Data race detected between {} on {} and {} on {}, memory({:?},offset={},size={})\\\n-            \\n(current vector clock = {:?}, conflicting timestamp = {:?})\",\n+            \"Data race detected between {} on {} and {} on {} at {:?} (current vector clock = {:?}, conflicting timestamp = {:?})\",\n             action,\n             current_thread_info,\n             other_action,\n             other_thread_info,\n-            pointer.alloc_id,\n-            pointer.offset.bytes(),\n-            len.bytes(),\n+            ptr_dbg,\n             current_clocks.clock,\n             other_clock\n         )\n@@ -884,17 +860,23 @@ impl VClockAlloc {\n     /// atomic read operations.\n     pub fn read<'tcx>(\n         &self,\n-        pointer: Pointer<Tag>,\n-        len: Size,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         if global.multi_threaded.get() {\n             let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n-            for (_, range) in alloc_ranges.iter_mut(pointer.offset, len) {\n+            for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&*clocks, index) {\n                     // Report data-race.\n-                    return Self::report_data_race(global, range, \"Read\", false, pointer, len);\n+                    return Self::report_data_race(\n+                        global,\n+                        range,\n+                        \"Read\",\n+                        false,\n+                        Pointer::new(alloc_id, offset),\n+                    );\n                 }\n             }\n             Ok(())\n@@ -906,23 +888,22 @@ impl VClockAlloc {\n     // Shared code for detecting data-races on unique access to a section of memory\n     fn unique_access<'tcx>(\n         &mut self,\n-        pointer: Pointer<Tag>,\n-        len: Size,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n         write_type: WriteType,\n         global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n         if global.multi_threaded.get() {\n             let (index, clocks) = global.current_thread_state();\n-            for (_, range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n+            for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n-                        pointer,\n-                        len,\n+                        Pointer::new(alloc_id, offset),\n                     );\n                 }\n             }\n@@ -938,11 +919,11 @@ impl VClockAlloc {\n     /// operation\n     pub fn write<'tcx>(\n         &mut self,\n-        pointer: Pointer<Tag>,\n-        len: Size,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n         global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Write, global)\n+        self.unique_access(alloc_id, range, WriteType::Write, global)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -951,11 +932,11 @@ impl VClockAlloc {\n     /// operation\n     pub fn deallocate<'tcx>(\n         &mut self,\n-        pointer: Pointer<Tag>,\n-        len: Size,\n+        alloc_id: AllocId,\n+        range: AllocRange,\n         global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Deallocate, global)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, global)\n     }\n }\n \n@@ -1002,12 +983,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         result\n     }\n \n-    /// Generic atomic operation implementation,\n-    /// this accesses memory via get_raw instead of\n-    /// get_raw_mut, due to issues calling get_raw_mut\n-    /// for atomic loads from read-only memory.\n-    /// FIXME: is this valid, or should get_raw_mut be used for\n-    /// atomic-stores/atomic-rmw?\n+    /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n@@ -1023,25 +999,24 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.memory.extra.data_race {\n             if data_race.multi_threaded.get() {\n+                let size = place.layout.size;\n+                let (alloc_id, base_offset, ptr) = this.memory.ptr_get_alloc(place.ptr)?;\n                 // Load and log the atomic operation.\n                 // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n-                let place_ptr = place.ptr.assert_ptr();\n-                let size = place.layout.size;\n                 let alloc_meta =\n-                    &this.memory.get_alloc_extra(place_ptr.alloc_id)?.data_race.as_ref().unwrap();\n+                    &this.memory.get_alloc_extra(alloc_id)?.data_race.as_ref().unwrap();\n                 log::trace!(\n-                    \"Atomic op({}) with ordering {:?} on memory({:?}, offset={}, size={})\",\n+                    \"Atomic op({}) with ordering {:?} on {:?} (size={})\",\n                     description,\n                     &atomic,\n-                    place_ptr.alloc_id,\n-                    place_ptr.offset.bytes(),\n+                    ptr,\n                     size.bytes()\n                 );\n \n                 // Perform the atomic operation.\n                 data_race.maybe_perform_sync_operation(|index, mut clocks| {\n-                    for (_, range) in\n-                        alloc_meta.alloc_ranges.borrow_mut().iter_mut(place_ptr.offset, size)\n+                    for (offset, range) in\n+                        alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n                     {\n                         if let Err(DataRace) = op(range, &mut *clocks, index, atomic) {\n                             mem::drop(clocks);\n@@ -1050,8 +1025,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                                 range,\n                                 description,\n                                 true,\n-                                place_ptr,\n-                                size,\n+                                Pointer::new(alloc_id, offset),\n                             )\n                             .map(|_| true);\n                         }\n@@ -1063,12 +1037,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n                 // Log changes to atomic memory.\n                 if log::log_enabled!(log::Level::Trace) {\n-                    for (_, range) in alloc_meta.alloc_ranges.borrow().iter(place_ptr.offset, size)\n+                    for (_offset, range) in alloc_meta.alloc_ranges.borrow().iter(base_offset, size)\n                     {\n                         log::trace!(\n-                            \"Updated atomic memory({:?}, offset={}, size={}) to {:#?}\",\n-                            place.ptr.assert_ptr().alloc_id,\n-                            place_ptr.offset.bytes(),\n+                            \"Updated atomic memory({:?}, size={}) to {:#?}\",\n+                            ptr,\n                             size.bytes(),\n                             range.atomic_ops\n                         );"}, {"sha": "b5b75a7fc318419169d76597e42efba677bac968", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -134,7 +134,7 @@ pub fn report_error<'tcx, 'mir>(\n             let helps = match e.kind() {\n                 Unsupported(UnsupportedOpInfo::NoMirFor(..)) =>\n                     vec![(None, format!(\"make sure to use a Miri sysroot, which you can prepare with `cargo miri setup`\"))],\n-                Unsupported(UnsupportedOpInfo::ReadBytesAsPointer | UnsupportedOpInfo::ThreadLocalStatic(_) | UnsupportedOpInfo::ReadExternStatic(_)) =>\n+                Unsupported(UnsupportedOpInfo::ThreadLocalStatic(_) | UnsupportedOpInfo::ReadExternStatic(_)) =>\n                     panic!(\"Error should never be raised by Miri: {:?}\", e.kind()),\n                 Unsupported(_) =>\n                     vec![(None, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\"))],"}, {"sha": "ae9ff9c1f5a426388a3f2f9f15bdf0ef24d09b20", "filename": "src/eval.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -164,15 +164,16 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     // Third argument (`argv`): created from `config.args`.\n     let argv = {\n         // Put each argument in memory, collect pointers.\n-        let mut argvs = Vec::<Scalar<Tag>>::new();\n+        let mut argvs = Vec::<Immediate<Tag>>::new();\n         for arg in config.args.iter() {\n             // Make space for `0` terminator.\n             let size = u64::try_from(arg.len()).unwrap().checked_add(1).unwrap();\n             let arg_type = tcx.mk_array(tcx.types.u8, size);\n             let arg_place =\n                 ecx.allocate(ecx.layout_of(arg_type)?, MiriMemoryKind::Machine.into())?;\n             ecx.write_os_str_to_c_str(OsStr::new(arg), arg_place.ptr, size)?;\n-            argvs.push(arg_place.ptr);\n+            ecx.mark_immutable(&*arg_place);\n+            argvs.push(arg_place.to_ref(&ecx));\n         }\n         // Make an array with all these pointers, in the Miri memory.\n         let argvs_layout = ecx.layout_of(\n@@ -181,24 +182,26 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Machine.into())?;\n         for (idx, arg) in argvs.into_iter().enumerate() {\n             let place = ecx.mplace_field(&argvs_place, idx)?;\n-            ecx.write_scalar(arg, &place.into())?;\n+            ecx.write_immediate(arg, &place.into())?;\n         }\n-        ecx.memory.mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n+        ecx.mark_immutable(&*argvs_place);\n         // A pointer to that place is the 3rd argument for main.\n-        let argv = argvs_place.ptr;\n+        let argv = argvs_place.to_ref(&ecx);\n         // Store `argc` and `argv` for macOS `_NSGetArg{c,v}`.\n         {\n             let argc_place =\n                 ecx.allocate(ecx.machine.layouts.isize, MiriMemoryKind::Machine.into())?;\n             ecx.write_scalar(argc, &argc_place.into())?;\n-            ecx.machine.argc = Some(argc_place.ptr);\n+            ecx.mark_immutable(&*argc_place);\n+            ecx.machine.argc = Some(*argc_place);\n \n             let argv_place = ecx.allocate(\n                 ecx.layout_of(tcx.mk_imm_ptr(tcx.types.unit))?,\n                 MiriMemoryKind::Machine.into(),\n             )?;\n-            ecx.write_scalar(argv, &argv_place.into())?;\n-            ecx.machine.argv = Some(argv_place.ptr);\n+            ecx.write_immediate(argv, &argv_place.into())?;\n+            ecx.mark_immutable(&*argv_place);\n+            ecx.machine.argv = Some(*argv_place);\n         }\n         // Store command line as UTF-16 for Windows `GetCommandLineW`.\n         {\n@@ -217,12 +220,13 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             let cmd_type = tcx.mk_array(tcx.types.u16, u64::try_from(cmd_utf16.len()).unwrap());\n             let cmd_place =\n                 ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Machine.into())?;\n-            ecx.machine.cmd_line = Some(cmd_place.ptr);\n+            ecx.machine.cmd_line = Some(*cmd_place);\n             // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n             for (idx, &c) in cmd_utf16.iter().enumerate() {\n                 let place = ecx.mplace_field(&cmd_place, idx)?;\n                 ecx.write_scalar(Scalar::from_u16(c), &place.into())?;\n             }\n+            ecx.mark_immutable(&*cmd_place);\n         }\n         argv\n     };\n@@ -233,7 +237,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     ecx.call_function(\n         start_instance,\n         Abi::Rust,\n-        &[main_ptr.into(), argc.into(), argv.into()],\n+        &[Scalar::from_pointer(main_ptr, &ecx).into(), argc.into(), argv],\n         Some(&ret_place.into()),\n         StackPopCleanup::None { cleanup: true },\n     )?;\n@@ -285,8 +289,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n             }\n             ecx.process_diagnostics(info);\n         }\n-        let return_code =\n-            ecx.read_scalar(&ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n+        let return_code = ecx.read_scalar(&ret_place.into())?.to_machine_isize(&ecx)?;\n         Ok(return_code)\n     })();\n "}, {"sha": "363aefa62d2f81594296cc30196c4ec4dcdae265", "filename": "src/helpers.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -53,18 +53,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n         let const_val = this.eval_to_allocation(cid)?;\n         let const_val = this.read_scalar(&const_val.into())?;\n-        return Ok(const_val);\n+        return Ok(const_val.check_init()?);\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n     fn eval_libc(&mut self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.eval_context_mut().eval_path_scalar(&[\"libc\", name])?.check_init()\n+        self.eval_context_mut().eval_path_scalar(&[\"libc\", name])\n     }\n \n     /// Helper function to get a `libc` constant as an `i32`.\n@@ -75,9 +75,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Helper function to get a `windows` constant as a `Scalar`.\n     fn eval_windows(&mut self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.eval_context_mut()\n-            .eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])?\n-            .check_init()\n+        self.eval_context_mut().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n     }\n \n     /// Helper function to get a `windows` constant as an `u64`.\n@@ -107,17 +105,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n \n-    /// Test if this immediate equals 0.\n-    fn is_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n+    /// Test if this pointer equals 0.\n+    fn ptr_is_null(&self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_ref();\n         let null = Scalar::null_ptr(this);\n-        this.ptr_eq(val, null)\n-    }\n-\n-    /// Turn a Scalar into an Option<NonNullScalar>\n-    fn test_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n-        let this = self.eval_context_ref();\n-        Ok(if this.is_null(val)? { None } else { Some(val) })\n+        this.ptr_eq(Scalar::from_maybe_pointer(ptr, this), null)\n     }\n \n     /// Get the `Place` for a local\n@@ -128,7 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Generate some random bytes, and write them to `dest`.\n-    fn gen_random(&mut self, ptr: Scalar<Tag>, len: u64) -> InterpResult<'tcx> {\n+    fn gen_random(&mut self, ptr: Pointer<Option<Tag>>, len: u64) -> InterpResult<'tcx> {\n         // Some programs pass in a null pointer and a length of 0\n         // to their platform's random-generation function (e.g. getrandom())\n         // on Linux. For compatibility with these programs, we don't perform\n@@ -195,13 +187,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter\n-    /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n+    /// Visits the memory covered by `place`, sensitive to freezing: the 2nd parameter\n+    /// of `action` will be true if this is frozen, false if this is in an `UnsafeCell`.\n+    /// The range is relative to `place`.\n+    ///\n+    /// Assumes that the `place` has a proper pointer in it.\n     fn visit_freeze_sensitive(\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n-        mut action: impl FnMut(Pointer<Tag>, Size, bool) -> InterpResult<'tcx>,\n+        mut action: impl FnMut(AllocRange, bool) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n@@ -214,29 +209,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Store how far we proceeded into the place so far. Everything to the left of\n         // this offset has already been handled, in the sense that the frozen parts\n         // have had `action` called on them.\n-        let mut end_ptr = place.ptr.assert_ptr();\n+        let ptr = place.ptr.into_pointer_or_addr().unwrap();\n+        let start_offset = ptr.into_parts().1 as Size; // we just compare offsets, the abs. value never matters\n+        let mut cur_offset = start_offset;\n         // Called when we detected an `UnsafeCell` at the given offset and size.\n-        // Calls `action` and advances `end_ptr`.\n-        let mut unsafe_cell_action = |unsafe_cell_ptr: Scalar<Tag>, unsafe_cell_size: Size| {\n-            let unsafe_cell_ptr = unsafe_cell_ptr.assert_ptr();\n-            debug_assert_eq!(unsafe_cell_ptr.alloc_id, end_ptr.alloc_id);\n-            debug_assert_eq!(unsafe_cell_ptr.tag, end_ptr.tag);\n+        // Calls `action` and advances `cur_ptr`.\n+        let mut unsafe_cell_action = |unsafe_cell_ptr: Pointer<Option<Tag>>,\n+                                      unsafe_cell_size: Size| {\n+            let unsafe_cell_ptr = unsafe_cell_ptr.into_pointer_or_addr().unwrap();\n+            debug_assert_eq!(unsafe_cell_ptr.provenance, ptr.provenance);\n             // We assume that we are given the fields in increasing offset order,\n             // and nothing else changes.\n-            let unsafe_cell_offset = unsafe_cell_ptr.offset;\n-            let end_offset = end_ptr.offset;\n-            assert!(unsafe_cell_offset >= end_offset);\n-            let frozen_size = unsafe_cell_offset - end_offset;\n-            // Everything between the end_ptr and this `UnsafeCell` is frozen.\n+            let unsafe_cell_offset = unsafe_cell_ptr.into_parts().1 as Size; // we just compare offsets, the abs. value never matters\n+            assert!(unsafe_cell_offset >= cur_offset);\n+            let frozen_size = unsafe_cell_offset - cur_offset;\n+            // Everything between the cur_ptr and this `UnsafeCell` is frozen.\n             if frozen_size != Size::ZERO {\n-                action(end_ptr, frozen_size, /*frozen*/ true)?;\n+                action(alloc_range(cur_offset - start_offset, frozen_size), /*frozen*/ true)?;\n             }\n+            cur_offset += frozen_size;\n             // This `UnsafeCell` is NOT frozen.\n             if unsafe_cell_size != Size::ZERO {\n-                action(unsafe_cell_ptr, unsafe_cell_size, /*frozen*/ false)?;\n+                action(\n+                    alloc_range(cur_offset - start_offset, unsafe_cell_size),\n+                    /*frozen*/ false,\n+                )?;\n             }\n-            // Update end end_ptr.\n-            end_ptr = unsafe_cell_ptr.wrapping_offset(unsafe_cell_size, this);\n+            cur_offset += unsafe_cell_size;\n             // Done\n             Ok(())\n         };\n@@ -264,7 +263,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         // The part between the end_ptr and the end of the place is also frozen.\n         // So pretend there is a 0-sized `UnsafeCell` at the end.\n-        unsafe_cell_action(place.ptr.ptr_wrapping_offset(size, this), Size::ZERO)?;\n+        unsafe_cell_action(place.ptr.wrapping_offset(size, this), Size::ZERO)?;\n         // Done!\n         return Ok(());\n \n@@ -347,7 +346,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         // Gather the subplaces and sort them before visiting.\n                         let mut places =\n                             fields.collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n-                        places.sort_by_key(|place| place.ptr.assert_ptr().offset);\n+                        // we just compare offsets, the abs. value never matters\n+                        places.sort_by_key(|place| {\n+                            place.ptr.into_pointer_or_addr().unwrap().into_parts().1 as Size\n+                        });\n                         self.walk_aggregate(place, places.into_iter().map(Ok))\n                     }\n                     FieldsShape::Union { .. } | FieldsShape::Primitive => {\n@@ -379,9 +381,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let mut offset = Size::from_bytes(0);\n \n         for &imm in imms {\n-            this.write_immediate_to_mplace(\n+            this.write_immediate(\n                 *imm,\n-                &place.offset(offset, MemPlaceMeta::None, imm.layout, &*this.tcx)?,\n+                &place.offset(offset, MemPlaceMeta::None, imm.layout, &*this.tcx)?.into(),\n             )?;\n             offset += imm.layout.size;\n         }\n@@ -567,12 +569,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`\n     /// if the value in the `timespec` struct is invalid. Some libc functions will return\n     /// `EINVAL` in this case.\n-    fn read_timespec(\n-        &mut self,\n-        timespec_ptr_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, Option<Duration>> {\n+    fn read_timespec(&mut self, tp: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx, Option<Duration>> {\n         let this = self.eval_context_mut();\n-        let tp = this.deref_operand(timespec_ptr_op)?;\n         let seconds_place = this.mplace_field(&tp, 0)?;\n         let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n         let seconds = seconds_scalar.to_machine_isize(this)?;\n@@ -593,14 +591,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n \n-    fn read_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, &'a [u8]>\n+    fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, &'a [u8]>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n         let size1 = Size::from_bytes(1);\n-        let ptr = this.force_ptr(sptr)?; // We need to read at least 1 byte, so we can eagerly get a ptr.\n \n         // Step 1: determine the length.\n         let mut len = Size::ZERO;\n@@ -620,12 +617,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.memory.read_bytes(ptr.into(), len)\n     }\n \n-    fn read_wide_str(&self, sptr: Scalar<Tag>) -> InterpResult<'tcx, Vec<u16>> {\n+    fn read_wide_str(&self, mut ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, Vec<u16>> {\n         let this = self.eval_context_ref();\n         let size2 = Size::from_bytes(2);\n         let align2 = Align::from_bytes(2).unwrap();\n \n-        let mut ptr = this.force_ptr(sptr)?; // We need to read at least 1 wchar, so we can eagerly get a ptr.\n         let mut wchars = Vec::new();\n         loop {\n             // FIXME: We are re-getting the allocation each time around the loop.\n@@ -709,6 +705,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         self.check_abi_and_shim_symbol_clash(abi, exp_abi, link_name)?;\n         check_arg_count(args)\n     }\n+\n+    /// Mark a machine allocation that was just created as immutable.\n+    fn mark_immutable(&mut self, mplace: &MemPlace<Tag>) {\n+        let this = self.eval_context_mut();\n+        this.memory\n+            .mark_immutable(mplace.ptr.into_pointer_or_addr().unwrap().provenance.alloc_id)\n+            .unwrap();\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "665a13418401d507917d76e6a853709890def500", "filename": "src/intptrcast.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -38,55 +38,55 @@ impl Default for GlobalState {\n }\n \n impl<'mir, 'tcx> GlobalState {\n-    pub fn int_to_ptr(\n-        int: u64,\n+    pub fn ptr_from_addr(\n+        addr: u64,\n         memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> Pointer<Option<Tag>> {\n+        trace!(\"Casting 0x{:x} to a pointer\", addr);\n         let global_state = memory.extra.intptrcast.borrow();\n-        let pos = global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr);\n-\n-        // The int must be in-bounds after being cast to a pointer, so we error\n-        // with `CheckInAllocMsg::InboundsTest`.\n-        Ok(match pos {\n-            Ok(pos) => {\n-                let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n-                // `int` is equal to the starting address for an allocation, the offset should be\n-                // zero. The pointer is untagged because it was created from a cast\n-                Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged)\n-            }\n-            Err(0) => throw_ub!(DanglingIntPointer(int, CheckInAllocMsg::InboundsTest)),\n+        let pos = global_state.int_to_ptr_map.binary_search_by_key(&addr, |(addr, _)| *addr);\n+\n+        let alloc_id = match pos {\n+            Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n+            Err(0) => None,\n             Err(pos) => {\n                 // This is the largest of the adresses smaller than `int`,\n                 // i.e. the greatest lower bound (glb)\n                 let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n-                // This never overflows because `int >= glb`\n-                let offset = int - glb;\n-                // If the offset exceeds the size of the allocation, this access is illegal\n-                if offset <= memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead)?.0.bytes() {\n-                    // This pointer is untagged because it was created from a cast\n-                    Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged)\n+                // This never overflows because `addr >= glb`\n+                let offset = addr - glb;\n+                // If the offset exceeds the size of the allocation, don't use this `alloc_id`.\n+                if offset\n+                    <= memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap().0.bytes()\n+                {\n+                    Some(alloc_id)\n                 } else {\n-                    throw_ub!(DanglingIntPointer(int, CheckInAllocMsg::InboundsTest))\n+                    None\n                 }\n             }\n-        })\n+        };\n+        // Pointers created from integers are untagged.\n+        Pointer::new(\n+            alloc_id.map(|alloc_id| Tag { alloc_id, sb: SbTag::Untagged }),\n+            Size::from_bytes(addr),\n+        )\n     }\n \n-    pub fn ptr_to_int(\n-        ptr: Pointer<Tag>,\n+    fn alloc_base_addr(\n         memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-    ) -> InterpResult<'tcx, u64> {\n+        alloc_id: AllocId,\n+    ) -> u64 {\n         let mut global_state = memory.extra.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n-        let id = ptr.alloc_id;\n-\n-        // There is nothing wrong with a raw pointer being cast to an integer only after\n-        // it became dangling.  Hence `MaybeDead`.\n-        let (size, align) = memory.get_size_and_align(id, AllocCheck::MaybeDead)?;\n \n-        let base_addr = match global_state.base_addr.entry(id) {\n+        match global_state.base_addr.entry(alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n+                // There is nothing wrong with a raw pointer being cast to an integer only after\n+                // it became dangling.  Hence `MaybeDead`.\n+                let (size, align) =\n+                    memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap();\n+\n                 // This allocation does not have a base address yet, pick one.\n                 // Leave some space to the previous allocation, to give it some chance to be less aligned.\n                 let slack = {\n@@ -99,29 +99,50 @@ impl<'mir, 'tcx> GlobalState {\n                 let base_addr = Self::align_addr(base_addr, align.bytes());\n                 entry.insert(base_addr);\n                 trace!(\n-                    \"Assigning base address {:#x} to allocation {:?} (slack: {}, align: {})\",\n+                    \"Assigning base address {:#x} to allocation {:?} (size: {}, align: {}, slack: {})\",\n                     base_addr,\n-                    id,\n-                    slack,\n+                    alloc_id,\n+                    size.bytes(),\n                     align.bytes(),\n+                    slack,\n                 );\n \n                 // Remember next base address.  If this allocation is zero-sized, leave a gap\n                 // of at least 1 to avoid two allocations having the same base address.\n                 global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n-                global_state.int_to_ptr_map.push((base_addr, id));\n+                global_state.int_to_ptr_map.push((base_addr, alloc_id));\n \n                 base_addr\n             }\n-        };\n+        }\n+    }\n+\n+    /// Convert a relative (tcx) pointer to an absolute address.\n+    pub fn rel_ptr_to_addr(\n+        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+        ptr: Pointer<AllocId>,\n+    ) -> u64 {\n+        let (alloc_id, offset) = ptr.into_parts(); // offset is relative\n+        let base_addr = GlobalState::alloc_base_addr(memory, alloc_id);\n \n-        // Sanity check that the base address is aligned.\n-        debug_assert_eq!(base_addr % align.bytes(), 0);\n         // Add offset with the right kind of pointer-overflowing arithmetic.\n         let dl = memory.data_layout();\n-        Ok(dl.overflowing_offset(base_addr, ptr.offset.bytes()).0)\n+        dl.overflowing_offset(base_addr, offset.bytes()).0\n+    }\n+\n+    pub fn abs_ptr_to_rel(\n+        memory: &Memory<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+        ptr: Pointer<Tag>,\n+    ) -> Size {\n+        let (tag, addr) = ptr.into_parts(); // addr is absolute\n+        let base_addr = GlobalState::alloc_base_addr(memory, tag.alloc_id);\n+\n+        // Wrapping \"addr - base_addr\"\n+        let dl = memory.data_layout();\n+        let neg_base_addr = (base_addr as i64).wrapping_neg();\n+        Size::from_bytes(dl.overflowing_signed_offset(addr.bytes(), neg_base_addr).0)\n     }\n \n     /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple"}, {"sha": "f8d8aacce3c9e8f19bca57d3931ad1168542668c", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -65,13 +65,14 @@ pub use crate::eval::{\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{\n     AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,\n-    MiriMemoryKind, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    MiriMemoryKind, Tag, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, Stack, Stacks, Tag,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, Stack,\n+    Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "90e3d06aba99c1c5ea796e5dfc96cb7551c339cf", "filename": "src/machine.rs", "status": "modified", "additions": 109, "deletions": 90, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -119,6 +119,35 @@ impl fmt::Display for MiriMemoryKind {\n     }\n }\n \n+/// Pointer provenance (tag).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct Tag {\n+    pub alloc_id: AllocId,\n+    // Stacked Borrows tag.\n+    pub sb: SbTag,\n+}\n+\n+impl Provenance for Tag {\n+    const OFFSET_IS_ADDR: bool = true;\n+\n+    fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (tag, addr) = ptr.into_parts(); // address is absolute\n+        write!(f, \"0x{:x}\", addr.bytes())?;\n+        // Forward `alternate` flag to `alloc_id` printing.\n+        if f.alternate() {\n+            write!(f, \"[{:#?}]\", tag.alloc_id)?;\n+        } else {\n+            write!(f, \"[{:?}]\", tag.alloc_id)?;\n+        }\n+        // Print Stacked Borrows tag.\n+        write!(f, \"{:?}\", tag.sb)\n+    }\n+\n+    fn get_alloc_id(self) -> AllocId {\n+        self.alloc_id\n+    }\n+}\n+\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n@@ -136,8 +165,8 @@ pub struct MemoryExtra {\n     pub data_race: Option<data_race::MemoryExtra>,\n     pub intptrcast: intptrcast::MemoryExtra,\n \n-    /// Mapping extern static names to their canonical allocation.\n-    extern_statics: FxHashMap<Symbol, AllocId>,\n+    /// Mapping extern static names to their base pointer.\n+    extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n \n     /// The random number generator used for resolving non-determinism.\n     /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n@@ -183,11 +212,10 @@ impl MemoryExtra {\n     fn add_extern_static<'tcx, 'mir>(\n         this: &mut MiriEvalContext<'mir, 'tcx>,\n         name: &str,\n-        ptr: Scalar<Tag>,\n+        ptr: Pointer<Option<Tag>>,\n     ) {\n-        let ptr = ptr.assert_ptr();\n-        assert_eq!(ptr.offset, Size::ZERO);\n-        this.memory.extra.extern_statics.try_insert(Symbol::intern(name), ptr.alloc_id).unwrap();\n+        let ptr = ptr.into_pointer_or_addr().unwrap();\n+        this.memory.extra.extern_statics.try_insert(Symbol::intern(name), ptr).unwrap();\n     }\n \n     /// Sets up the \"extern statics\" for this machine.\n@@ -257,9 +285,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n     /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<Scalar<Tag>>,\n-    pub(crate) argv: Option<Scalar<Tag>>,\n-    pub(crate) cmd_line: Option<Scalar<Tag>>,\n+    pub(crate) argc: Option<MemPlace<Tag>>,\n+    pub(crate) argv: Option<MemPlace<Tag>>,\n+    pub(crate) cmd_line: Option<MemPlace<Tag>>,\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n@@ -487,82 +515,107 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn thread_local_static_alloc_id(\n+    fn thread_local_static_base_pointer(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n-        ecx.get_or_create_thread_local_alloc_id(def_id)\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        ecx.get_or_create_thread_local_alloc(def_id)\n     }\n \n-    fn extern_static_alloc_id(\n+    fn extern_static_base_pointer(\n         memory: &Memory<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n         let attrs = memory.tcx.get_attrs(def_id);\n         let link_name = match memory.tcx.sess.first_attr_value_str_by_name(&attrs, sym::link_name) {\n             Some(name) => name,\n             None => memory.tcx.item_name(def_id),\n         };\n-        if let Some(&id) = memory.extra.extern_statics.get(&link_name) {\n-            Ok(id)\n+        if let Some(&ptr) = memory.extra.extern_statics.get(&link_name) {\n+            Ok(ptr)\n         } else {\n             throw_unsup_format!(\"`extern` static {:?} is not supported by Miri\", def_id)\n         }\n     }\n \n     fn init_allocation_extra<'b>(\n-        memory_extra: &MemoryExtra,\n+        mem: &Memory<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n-        if Some(id) == memory_extra.tracked_alloc_id {\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>> {\n+        if Some(id) == mem.extra.tracked_alloc_id {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(id));\n         }\n \n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n-            let (stacks, base_tag) =\n-                Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind);\n-            (Some(stacks), base_tag)\n+        let stacks = if let Some(stacked_borrows) = &mem.extra.stacked_borrows {\n+            Some(Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))\n         } else {\n-            // No stacks, no tag.\n-            (None, Tag::Untagged)\n+            None\n         };\n-        let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n+        let race_alloc = if let Some(data_race) = &mem.extra.data_race {\n             Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size(), kind))\n         } else {\n             None\n         };\n-        let mut stacked_borrows = memory_extra.stacked_borrows.as_ref().map(|sb| sb.borrow_mut());\n-        let alloc: Allocation<Tag, Self::AllocExtra> = alloc.with_tags_and_extra(\n-            |alloc| {\n-                if let Some(stacked_borrows) = &mut stacked_borrows {\n-                    // Only globals may already contain pointers at this point\n-                    assert_eq!(kind, MiriMemoryKind::Global.into());\n-                    stacked_borrows.global_base_ptr(alloc)\n-                } else {\n-                    Tag::Untagged\n-                }\n-            },\n+        let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n+            &mem.tcx,\n             AllocExtra { stacked_borrows: stacks, data_race: race_alloc },\n+            |ptr| Evaluator::tag_alloc_base_pointer(mem, ptr),\n         );\n-        (Cow::Owned(alloc), base_tag)\n+        Cow::Owned(alloc)\n+    }\n+\n+    fn tag_alloc_base_pointer(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer<AllocId>,\n+    ) -> Pointer<Tag> {\n+        let absolute_addr = intptrcast::GlobalState::rel_ptr_to_addr(&mem, ptr);\n+        let sb_tag = if let Some(stacked_borrows) = &mem.extra.stacked_borrows {\n+            stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n+        } else {\n+            SbTag::Untagged\n+        };\n+        Pointer::new(Tag { alloc_id: ptr.provenance, sb: sb_tag }, Size::from_bytes(absolute_addr))\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_from_addr(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<Self::PointerTag>> {\n+        intptrcast::GlobalState::ptr_from_addr(addr, mem)\n+    }\n+\n+    /// Convert a pointer with provenance into an allocation-offset pair,\n+    /// or a `None` with an absolute address if that conversion is not possible.\n+    fn ptr_get_alloc(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+    ) -> (AllocId, Size) {\n+        let rel = intptrcast::GlobalState::abs_ptr_to_rel(mem, ptr);\n+        (ptr.provenance.alloc_id, rel)\n     }\n \n     #[inline(always)]\n     fn memory_read(\n         memory_extra: &Self::MemoryExtra,\n         alloc_extra: &AllocExtra,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        tag: Tag,\n+        range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(ptr, size, memory_extra.data_race.as_ref().unwrap())?;\n+            data_race.read(tag.alloc_id, range, memory_extra.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_read(ptr, size, memory_extra.stacked_borrows.as_ref().unwrap())\n+            stacked_borrows.memory_read(\n+                tag.alloc_id,\n+                tag.sb,\n+                range,\n+                memory_extra.stacked_borrows.as_ref().unwrap(),\n+            )\n         } else {\n             Ok(())\n         }\n@@ -572,16 +625,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn memory_written(\n         memory_extra: &mut Self::MemoryExtra,\n         alloc_extra: &mut AllocExtra,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        tag: Tag,\n+        range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n+            data_race.write(tag.alloc_id, range, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_written(\n-                ptr,\n-                size,\n+                tag.alloc_id,\n+                tag.sb,\n+                range,\n                 memory_extra.stacked_borrows.as_mut().unwrap(),\n             )\n         } else {\n@@ -593,46 +647,27 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn memory_deallocated(\n         memory_extra: &mut Self::MemoryExtra,\n         alloc_extra: &mut AllocExtra,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        tag: Tag,\n+        range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        if Some(ptr.alloc_id) == memory_extra.tracked_alloc_id {\n-            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(ptr.alloc_id));\n+        if Some(tag.alloc_id) == memory_extra.tracked_alloc_id {\n+            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(tag.alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n+            data_race.deallocate(tag.alloc_id, range, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_deallocated(\n-                ptr,\n-                size,\n+                tag.alloc_id,\n+                tag.sb,\n+                range,\n                 memory_extra.stacked_borrows.as_mut().unwrap(),\n             )\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn after_static_mem_initialized(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.data_race.is_some() {\n-            ecx.reset_vector_clocks(ptr, size)?;\n-        }\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_global_base_pointer(memory_extra: &MemoryExtra, id: AllocId) -> Self::PointerTag {\n-        if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n-            stacked_borrows.borrow_mut().global_base_ptr(id)\n-        } else {\n-            Tag::Untagged\n-        }\n-    }\n-\n     #[inline(always)]\n     fn retag(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -701,20 +736,4 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         res\n     }\n-\n-    #[inline(always)]\n-    fn int_to_ptr(\n-        memory: &Memory<'mir, 'tcx, Self>,\n-        int: u64,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        intptrcast::GlobalState::int_to_ptr(int, memory)\n-    }\n-\n-    #[inline(always)]\n-    fn ptr_to_int(\n-        memory: &Memory<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-    ) -> InterpResult<'tcx, u64> {\n-        intptrcast::GlobalState::ptr_to_int(ptr, memory)\n-    }\n }"}, {"sha": "1ae2083d5661c852e377b003044023b4fefa9363", "filename": "src/mono_hash_map.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -72,15 +72,31 @@ impl<K: Hash + Eq, V> AllocMap<K, V> for MonoHashMap<K, V> {\n     /// returns owned data, that is put into the map and returned.\n     #[inline(always)]\n     fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n-        let val: *const V = match self.0.borrow_mut().entry(k) {\n-            Entry::Occupied(entry) => &**entry.get(),\n-            Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n-        };\n+        // We cannot hold borrow_mut while calling `vacant`, since that might have to do lookups in this very map.\n+        if let Some(v) = self.0.borrow().get(&k) {\n+            let val: *const V = &**v;\n+            // This is safe because `val` points into a `Box`, that we know will not move and\n+            // will also not be dropped as long as the shared reference `self` is live.\n+            return unsafe { Ok(&*val) };\n+        }\n+        let new_val = Box::new(vacant()?);\n+        let val: *const V = &**self.0.borrow_mut().try_insert(k, new_val).ok().unwrap();\n         // This is safe because `val` points into a `Box`, that we know will not move and\n         // will also not be dropped as long as the shared reference `self` is live.\n         unsafe { Ok(&*val) }\n     }\n \n+    /// Read-only lookup (avoid read-acquiring the RefCell).\n+    fn get(&self, k: K) -> Option<&V> {\n+        let val: *const V = match self.0.borrow().get(&k) {\n+            Some(v) => &**v,\n+            None => return None,\n+        };\n+        // This is safe because `val` points into a `Box`, that we know will not move and\n+        // will also not be dropped as long as the shared reference `self` is live.\n+        unsafe { Some(&*val) }\n+    }\n+\n     #[inline(always)]\n     fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n         match self.0.get_mut().entry(k) {"}, {"sha": "59099469a332261520773b0ddec9caee728d83b3", "filename": "src/operator.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -45,9 +45,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n             Lt | Le | Gt | Ge => {\n                 // Just compare the integers.\n-                // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n-                let left = self.force_bits(left.to_scalar()?, left.layout.size)?;\n-                let right = self.force_bits(right.to_scalar()?, right.layout.size)?;\n+                let left = left.to_scalar()?.to_bits(left.layout.size)?;\n+                let right = right.to_scalar()?.to_bits(right.layout.size)?;\n                 let res = match bin_op {\n                     Lt => left < right,\n                     Le => left <= right,\n@@ -62,11 +61,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 let pointee_ty =\n                     left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n                 let ptr = self.ptr_offset_inbounds(\n-                    left.to_scalar()?,\n+                    self.scalar_to_ptr(left.to_scalar()?),\n                     pointee_ty,\n                     right.to_scalar()?.to_machine_isize(self)?,\n                 )?;\n-                (ptr, false, left.layout.ty)\n+                (Scalar::from_maybe_pointer(ptr, self), false, left.layout.ty)\n             }\n \n             _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op),\n@@ -76,9 +75,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n         // Just compare the integers.\n-        // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n-        let left = self.force_bits(left, size)?;\n-        let right = self.force_bits(right, size)?;\n+        let left = left.to_bits(size)?;\n+        let right = right.to_bits(size)?;\n         Ok(left == right)\n     }\n }"}, {"sha": "1ac3a22f7ed3d960c43b6051b71e6f05355d600f", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -44,9 +44,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n                 // Note that we never actually read or write anything from/to this pointer -\n                 // all of the data is represented by the pointer value itself.\n-                let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n-                fn_ptr.offset = Size::from_bytes(pos.0);\n-                Scalar::Ptr(fn_ptr)\n+                let fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+                fn_ptr.wrapping_offset(Size::from_bytes(pos.0), this)\n             })\n             .collect();\n \n@@ -61,11 +60,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.allocate(this.layout_of(array_ty).unwrap(), MiriMemoryKind::Rust.into())?;\n         for (i, ptr) in ptrs.into_iter().enumerate() {\n             let place = this.mplace_index(&alloc, i as u64)?;\n-            this.write_immediate_to_mplace(ptr.into(), &place)?;\n+            this.write_pointer(ptr, &place.into())?;\n         }\n \n         this.write_immediate(\n-            Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this),\n+            Immediate::new_slice(\n+                Scalar::from_maybe_pointer(alloc.ptr, this),\n+                len.try_into().unwrap(),\n+                this,\n+            ),\n             dest,\n         )?;\n         Ok(())\n@@ -87,21 +90,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unknown `miri_resolve_frame` flags {}\", flags);\n         }\n \n-        let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n+        let ptr = this.read_pointer(ptr)?;\n+        // Take apart the pointer, we need its pieces.\n+        let (alloc_id, offset, ptr) = this.memory.ptr_get_alloc(ptr)?;\n \n-        let fn_instance = if let Some(GlobalAlloc::Function(instance)) =\n-            this.tcx.get_global_alloc(ptr.alloc_id)\n-        {\n-            instance\n-        } else {\n-            throw_ub_format!(\"expected function pointer, found {:?}\", ptr);\n-        };\n+        let fn_instance =\n+            if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(alloc_id) {\n+                instance\n+            } else {\n+                throw_ub_format!(\"expected function pointer, found {:?}\", ptr);\n+            };\n \n         // Reconstruct the original function pointer,\n         // which we pass to user code.\n-        let mut fn_ptr = ptr;\n-        fn_ptr.offset = Size::from_bytes(0);\n-        let fn_ptr = Scalar::Ptr(fn_ptr);\n+        let fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(fn_instance));\n \n         let num_fields = dest.layout.layout.fields.count();\n \n@@ -113,7 +115,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             );\n         }\n \n-        let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n+        let pos = BytePos(offset.bytes().try_into().unwrap());\n         let name = fn_instance.to_string();\n \n         let lo = tcx.sess.source_map().lookup_char_pos(pos);\n@@ -139,15 +141,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        this.write_immediate(name_alloc.to_ref(), &this.mplace_field(&dest, 0)?.into())?;\n-        this.write_immediate(filename_alloc.to_ref(), &this.mplace_field(&dest, 1)?.into())?;\n+        this.write_immediate(name_alloc.to_ref(this), &this.mplace_field(&dest, 0)?.into())?;\n+        this.write_immediate(filename_alloc.to_ref(this), &this.mplace_field(&dest, 1)?.into())?;\n         this.write_scalar(lineno_alloc, &this.mplace_field(&dest, 2)?.into())?;\n         this.write_scalar(colno_alloc, &this.mplace_field(&dest, 3)?.into())?;\n \n         // Support a 4-field struct for now - this is deprecated\n         // and slated for removal.\n         if num_fields == 5 {\n-            this.write_scalar(fn_ptr, &this.mplace_field(&dest, 4)?.into())?;\n+            this.write_pointer(fn_ptr, &this.mplace_field(&dest, 4)?.into())?;\n         }\n \n         Ok(())"}, {"sha": "ddd2b615889819fd801599065379eaf402a9b1e1", "filename": "src/shims/env.rs", "status": "modified", "additions": 47, "deletions": 55, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -28,7 +28,7 @@ fn windows_check_buffer_size((success, len): (bool, u64)) -> u32 {\n pub struct EnvVars<'tcx> {\n     /// Stores pointers to the environment variables. These variables must be stored as\n     /// null-terminated target strings (c_str or wide_str) with the `\"{name}={value}\"` format.\n-    map: FxHashMap<OsString, Pointer<Tag>>,\n+    map: FxHashMap<OsString, Pointer<Option<Tag>>>,\n \n     /// Place where the `environ` static is stored. Lazily initialized, but then never changes.\n     pub(crate) environ: Option<MPlaceTy<'tcx, Tag>>,\n@@ -75,8 +75,8 @@ impl<'tcx> EnvVars<'tcx> {\n         }\n         // Deallocate environ var list.\n         let environ = ecx.machine.env_vars.environ.unwrap();\n-        let old_vars_ptr = ecx.read_scalar(&environ.into())?.check_init()?;\n-        ecx.memory.deallocate(ecx.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n+        let old_vars_ptr = ecx.read_pointer(&environ.into())?;\n+        ecx.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Env.into())?;\n         Ok(())\n     }\n }\n@@ -85,7 +85,7 @@ fn alloc_env_var_as_c_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n     ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-) -> InterpResult<'tcx, Pointer<Tag>> {\n+) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n@@ -96,7 +96,7 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n     ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-) -> InterpResult<'tcx, Pointer<Tag>> {\n+) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n@@ -105,25 +105,25 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn getenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn getenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(\n             target_os == \"linux\" || target_os == \"macos\",\n             \"`getenv` is only available for the UNIX target family\"\n         );\n \n-        let name_ptr = this.read_scalar(name_op)?.check_init()?;\n+        let name_ptr = this.read_pointer(name_op)?;\n         let name = this.read_os_str_from_c_str(name_ptr)?;\n         Ok(match this.machine.env_vars.map.get(name) {\n             Some(var_ptr) => {\n                 // The offset is used to strip the \"{name}=\" part of the string.\n-                Scalar::from(var_ptr.offset(\n+                var_ptr.offset(\n                     Size::from_bytes(u64::try_from(name.len()).unwrap().checked_add(1).unwrap()),\n                     this,\n-                )?)\n+                )?\n             }\n-            None => Scalar::null_ptr(&*this.tcx),\n+            None => Pointer::null(),\n         })\n     }\n \n@@ -139,7 +139,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentVariableW\");\n \n-        let name_ptr = this.read_scalar(name_op)?.check_init()?;\n+        let name_ptr = this.read_pointer(name_op)?;\n         let name = this.read_os_str_from_wide_str(name_ptr)?;\n         Ok(match this.machine.env_vars.map.get(&name) {\n             Some(var_ptr) => {\n@@ -148,11 +148,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let name_offset_bytes = u64::try_from(name.len()).unwrap()\n                     .checked_add(1).unwrap()\n                     .checked_mul(2).unwrap();\n-                let var_ptr =\n-                    Scalar::from(var_ptr.offset(Size::from_bytes(name_offset_bytes), this)?);\n+                let var_ptr = var_ptr.offset(Size::from_bytes(name_offset_bytes), this)?;\n                 let var = this.read_os_str_from_wide_str(var_ptr)?;\n \n-                let buf_ptr = this.read_scalar(buf_op)?.check_init()?;\n+                let buf_ptr = this.read_pointer(buf_op)?;\n                 // `buf_size` represents the size in characters.\n                 let buf_size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n                 windows_check_buffer_size(this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?)\n@@ -166,23 +165,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn GetEnvironmentStringsW(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn GetEnvironmentStringsW(&mut self) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentStringsW\");\n \n         // Info on layout of environment blocks in Windows:\n         // https://docs.microsoft.com/en-us/windows/win32/procthread/environment-variables\n         let mut env_vars = std::ffi::OsString::new();\n         for &item in this.machine.env_vars.map.values() {\n-            let env_var = this.read_os_str_from_wide_str(Scalar::from(item))?;\n+            let env_var = this.read_os_str_from_wide_str(item)?;\n             env_vars.push(env_var);\n             env_vars.push(\"\\0\");\n         }\n         // Allocate environment block & Store environment variables to environment block.\n         // Final null terminator(block terminator) is added by `alloc_os_str_to_wide_str`.\n         let envblock_ptr = this.alloc_os_str_as_wide_str(&env_vars, MiriMemoryKind::Env.into())?;\n         // If the function succeeds, the return value is a pointer to the environment block of the current process.\n-        Ok(envblock_ptr.into())\n+        Ok(envblock_ptr)\n     }\n \n     #[allow(non_snake_case)]\n@@ -193,12 +192,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n-        let env_block_ptr = this.read_scalar(env_block_op)?.check_init()?;\n-        let result = this.memory.deallocate(\n-            this.force_ptr(env_block_ptr)?,\n-            None,\n-            MiriMemoryKind::Env.into(),\n-        );\n+        let env_block_ptr = this.read_pointer(env_block_op)?;\n+        let result = this.memory.deallocate(env_block_ptr, None, MiriMemoryKind::Env.into());\n         // If the function succeeds, the return value is nonzero.\n         Ok(result.is_ok() as i32)\n     }\n@@ -215,11 +210,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`setenv` is only available for the UNIX target family\"\n         );\n \n-        let name_ptr = this.read_scalar(name_op)?.check_init()?;\n-        let value_ptr = this.read_scalar(value_op)?.check_init()?;\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let value_ptr = this.read_pointer(value_op)?;\n \n         let mut new = None;\n-        if !this.is_null(name_ptr)? {\n+        if !this.ptr_is_null(name_ptr)? {\n             let name = this.read_os_str_from_c_str(name_ptr)?;\n             if !name.is_empty() && !name.to_string_lossy().contains('=') {\n                 let value = this.read_os_str_from_c_str(value_ptr)?;\n@@ -250,10 +245,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let mut this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n \n-        let name_ptr = this.read_scalar(name_op)?.check_init()?;\n-        let value_ptr = this.read_scalar(value_op)?.check_init()?;\n+        let name_ptr = this.read_pointer(name_op)?;\n+        let value_ptr = this.read_pointer(value_op)?;\n \n-        if this.is_null(name_ptr)? {\n+        if this.ptr_is_null(name_ptr)? {\n             // ERROR CODE is not clearly explained in docs.. For now, throw UB instead.\n             throw_ub_format!(\"pointer to environment variable name is NULL\");\n         }\n@@ -263,7 +258,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"environment variable name is an empty string\");\n         } else if name.to_string_lossy().contains('=') {\n             throw_unsup_format!(\"environment variable name contains '='\");\n-        } else if this.is_null(value_ptr)? {\n+        } else if this.ptr_is_null(value_ptr)? {\n             // Delete environment variable `{name}`\n             if let Some(var) = this.machine.env_vars.map.remove(&name) {\n                 this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n@@ -289,9 +284,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`unsetenv` is only available for the UNIX target family\"\n         );\n \n-        let name_ptr = this.read_scalar(name_op)?.check_init()?;\n+        let name_ptr = this.read_pointer(name_op)?;\n         let mut success = None;\n-        if !this.is_null(name_ptr)? {\n+        if !this.ptr_is_null(name_ptr)? {\n             let name = this.read_os_str_from_c_str(name_ptr)?.to_owned();\n             if !name.is_empty() && !name.to_string_lossy().contains('=') {\n                 success = Some(this.machine.env_vars.map.remove(&name));\n@@ -315,22 +310,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         buf_op: &OpTy<'tcx, Tag>,\n         size_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(\n             target_os == \"linux\" || target_os == \"macos\",\n             \"`getcwd` is only available for the UNIX target family\"\n         );\n \n+        let buf = this.read_pointer(&buf_op)?;\n+        let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n+\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"getcwd\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n-            return Ok(Scalar::null_ptr(&*this.tcx));\n+            return Ok(Pointer::null());\n         }\n \n-        let buf = this.read_scalar(&buf_op)?.check_init()?;\n-        let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n@@ -343,7 +339,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Err(e) => this.set_last_error_from_io_error(e.kind())?,\n         }\n \n-        Ok(Scalar::null_ptr(&*this.tcx))\n+        Ok(Pointer::null())\n     }\n \n     #[allow(non_snake_case)]\n@@ -355,15 +351,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n \n+        let size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n+        let buf = this.read_pointer(buf_op)?;\n+\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"GetCurrentDirectoryW\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n             return Ok(0);\n         }\n \n-        let size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n-        let buf = this.read_scalar(buf_op)?.check_init()?;\n-\n         // If we cannot get the current directory, we return 0\n         match env::current_dir() {\n             Ok(cwd) =>\n@@ -381,15 +377,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`getcwd` is only available for the UNIX target family\"\n         );\n \n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n+\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"chdir\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n             return Ok(-1);\n         }\n \n-        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n-\n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),\n             Err(e) => {\n@@ -409,15 +405,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n \n+        let path = this.read_path_from_wide_str(this.read_pointer(path_op)?)?;\n+\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"SetCurrentDirectoryW\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n             return Ok(0);\n         }\n \n-        let path = this.read_path_from_wide_str(this.read_scalar(path_op)?.check_init()?)?;\n-\n         match env::set_current_dir(path) {\n             Ok(()) => Ok(1),\n             Err(e) => {\n@@ -433,12 +429,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         // Deallocate the old environ list, if any.\n         if let Some(environ) = this.machine.env_vars.environ {\n-            let old_vars_ptr = this.read_scalar(&environ.into())?.check_init()?;\n-            this.memory.deallocate(\n-                this.force_ptr(old_vars_ptr)?,\n-                None,\n-                MiriMemoryKind::Env.into(),\n-            )?;\n+            let old_vars_ptr = this.read_pointer(&environ.into())?;\n+            this.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Env.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n             // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n@@ -448,20 +440,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Collect all the pointers to each variable in a vector.\n-        let mut vars: Vec<Scalar<Tag>> =\n-            this.machine.env_vars.map.values().map(|&ptr| ptr.into()).collect();\n+        let mut vars: Vec<Pointer<Option<Tag>>> =\n+            this.machine.env_vars.map.values().copied().collect();\n         // Add the trailing null pointer.\n-        vars.push(Scalar::null_ptr(this));\n+        vars.push(Pointer::null());\n         // Make an array with all these pointers inside Miri.\n         let tcx = this.tcx;\n         let vars_layout =\n             this.layout_of(tcx.mk_array(tcx.types.usize, u64::try_from(vars.len()).unwrap()))?;\n         let vars_place = this.allocate(vars_layout, MiriMemoryKind::Env.into())?;\n         for (idx, var) in vars.into_iter().enumerate() {\n             let place = this.mplace_field(&vars_place, idx)?;\n-            this.write_scalar(var, &place.into())?;\n+            this.write_pointer(var, &place.into())?;\n         }\n-        this.write_scalar(vars_place.ptr, &this.machine.env_vars.environ.unwrap().into())?;\n+        this.write_pointer(vars_place.ptr, &this.machine.env_vars.environ.unwrap().into())?;\n \n         Ok(())\n     }"}, {"sha": "35c151b72f60cb25e6a2147228fa5db1e28989ac", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -72,51 +72,49 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         size: u64,\n         zero_init: bool,\n         kind: MiriMemoryKind,\n-    ) -> InterpResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let this = self.eval_context_mut();\n         if size == 0 {\n-            Ok(Scalar::null_ptr(this))\n+            Ok(Pointer::null())\n         } else {\n             let align = this.min_align(size, kind);\n             let ptr = this.memory.allocate(Size::from_bytes(size), align, kind.into())?;\n             if zero_init {\n                 // We just allocated this, the access is definitely in-bounds.\n                 this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(size as usize)).unwrap();\n             }\n-            Ok(Scalar::Ptr(ptr))\n+            Ok(ptr.into())\n         }\n     }\n \n-    fn free(&mut self, ptr: Scalar<Tag>, kind: MiriMemoryKind) -> InterpResult<'tcx> {\n+    fn free(&mut self, ptr: Pointer<Option<Tag>>, kind: MiriMemoryKind) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if !this.is_null(ptr)? {\n-            let ptr = this.force_ptr(ptr)?;\n+        if !this.ptr_is_null(ptr)? {\n             this.memory.deallocate(ptr, None, kind.into())?;\n         }\n         Ok(())\n     }\n \n     fn realloc(\n         &mut self,\n-        old_ptr: Scalar<Tag>,\n+        old_ptr: Pointer<Option<Tag>>,\n         new_size: u64,\n         kind: MiriMemoryKind,\n-    ) -> InterpResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let this = self.eval_context_mut();\n         let new_align = this.min_align(new_size, kind);\n-        if this.is_null(old_ptr)? {\n+        if this.ptr_is_null(old_ptr)? {\n             if new_size == 0 {\n-                Ok(Scalar::null_ptr(this))\n+                Ok(Pointer::null())\n             } else {\n                 let new_ptr =\n                     this.memory.allocate(Size::from_bytes(new_size), new_align, kind.into())?;\n-                Ok(Scalar::Ptr(new_ptr))\n+                Ok(new_ptr.into())\n             }\n         } else {\n-            let old_ptr = this.force_ptr(old_ptr)?;\n             if new_size == 0 {\n                 this.memory.deallocate(old_ptr, None, kind.into())?;\n-                Ok(Scalar::null_ptr(this))\n+                Ok(Pointer::null())\n             } else {\n                 let new_ptr = this.memory.reallocate(\n                     old_ptr,\n@@ -125,7 +123,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     new_align,\n                     kind.into(),\n                 )?;\n-                Ok(Scalar::Ptr(new_ptr))\n+                Ok(new_ptr.into())\n             }\n         }\n     }\n@@ -313,12 +311,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n                 let &[ref ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n-                let ptr = this.force_ptr(ptr)?;\n-                if ptr.offset != Size::ZERO {\n+                let ptr = this.read_pointer(ptr)?;\n+                let (alloc_id, offset, _) = this.memory.ptr_get_alloc(ptr)?;\n+                if offset != Size::ZERO {\n                     throw_unsup_format!(\"pointer passed to miri_static_root must point to beginning of an allocated block\");\n                 }\n-                this.machine.static_roots.push(ptr.alloc_id);\n+                this.machine.static_roots.push(alloc_id);\n             }\n \n             // Obtains a Miri backtrace. See the README for details.\n@@ -339,7 +337,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C)?;\n-                this.write_scalar(res, dest)?;\n+                this.write_pointer(res, dest)?;\n             }\n             \"calloc\" => {\n                 let &[ref items, ref len] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -348,19 +346,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let size =\n                     items.checked_mul(len).ok_or_else(|| err_ub_format!(\"overflow during calloc size computation\"))?;\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C)?;\n-                this.write_scalar(res, dest)?;\n+                this.write_pointer(res, dest)?;\n             }\n             \"free\" => {\n                 let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n                 let &[ref old_ptr, ref new_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let old_ptr = this.read_scalar(old_ptr)?.check_init()?;\n+                let old_ptr = this.read_pointer(old_ptr)?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n-                this.write_scalar(res, dest)?;\n+                this.write_pointer(res, dest)?;\n             }\n \n             // Rust allocation\n@@ -376,7 +374,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n-                this.write_scalar(ptr, dest)?;\n+                this.write_pointer(ptr, dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n                 let &[ref size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n@@ -390,15 +388,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n                 // We just allocated this, the access is definitely in-bounds.\n                 this.memory.write_bytes(ptr.into(), iter::repeat(0u8).take(usize::try_from(size).unwrap())).unwrap();\n-                this.write_scalar(ptr, dest)?;\n+                this.write_pointer(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n                 let &[ref ptr, ref old_size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 // No need to check old_size/align; we anyway check that they match the allocation.\n-                let ptr = this.force_ptr(ptr)?;\n                 this.memory.deallocate(\n                     ptr,\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n@@ -407,7 +404,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_realloc\" => {\n                 let &[ref ptr, ref old_size, ref align, ref new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n@@ -421,14 +418,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     align,\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n-                this.write_scalar(new_ptr, dest)?;\n+                this.write_pointer(new_ptr, dest)?;\n             }\n \n             // C memory handling functions\n             \"memcmp\" => {\n                 let &[ref left, ref right, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let left = this.read_scalar(left)?.check_init()?;\n-                let right = this.read_scalar(right)?.check_init()?;\n+                let left = this.read_pointer(left)?;\n+                let right = this.read_pointer(right)?;\n                 let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n \n                 let result = {\n@@ -447,7 +444,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"memrchr\" => {\n                 let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 if let Some(idx) = this\n@@ -457,15 +454,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .rev()\n                     .position(|&c| c == val)\n                 {\n-                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), this)?;\n-                    this.write_scalar(new_ptr, dest)?;\n+                    let new_ptr = ptr.offset(Size::from_bytes(num - idx as u64 - 1), this)?;\n+                    this.write_pointer(new_ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;\n                 }\n             }\n             \"memchr\" => {\n                 let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 let idx = this\n@@ -474,15 +471,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .iter()\n                     .position(|&c| c == val);\n                 if let Some(idx) = idx {\n-                    let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), this)?;\n-                    this.write_scalar(new_ptr, dest)?;\n+                    let new_ptr = ptr.offset(Size::from_bytes(idx as u64), this)?;\n+                    this.write_pointer(new_ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;\n                 }\n             }\n             \"strlen\" => {\n                 let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n             }"}, {"sha": "5a3a782382dd5253e918c39af901bc4916e9d809", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -71,7 +71,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ty = instance.substs.type_at(0);\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let byte_count = ty_layout.size.checked_mul(count, this).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `write_bytes`\")"}, {"sha": "b05fa76a934fc787b4f45c40d02689321ca964ca", "filename": "src/shims/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -74,22 +74,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(false);\n         }\n \n-        let req_align =\n-            this.force_bits(this.read_scalar(align_op)?.check_init()?, this.pointer_size())?;\n+        let req_align = this.read_scalar(align_op)?.to_machine_usize(this)?;\n \n         // Stop if the alignment is not a power of two.\n         if !req_align.is_power_of_two() {\n             this.start_panic(\"align_offset: align is not a power-of-two\", unwind)?;\n             return Ok(true); // nothing left to do\n         }\n \n-        let ptr_scalar = this.read_scalar(ptr_op)?.check_init()?;\n-\n-        if let Ok(ptr) = this.force_ptr(ptr_scalar) {\n+        let ptr = this.read_pointer(ptr_op)?;\n+        if let Ok(ptr) = ptr.into_pointer_or_addr() {\n             // Only do anything if we can identify the allocation this goes to.\n-            let cur_align =\n-                this.memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?.1.bytes();\n-            if u128::from(cur_align) >= req_align {\n+            let (_, cur_align) =\n+                this.memory.get_size_and_align(ptr.provenance.alloc_id, AllocCheck::MaybeDead)?;\n+            if cur_align.bytes() >= req_align {\n                 // If the allocation alignment is at least the required alignment we use the\n                 // real implementation.\n                 return Ok(false);"}, {"sha": "83bb344982c2a56aceed4e7248c803b7842ef0c8", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -50,19 +50,25 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n-    fn read_os_str_from_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, &'a OsStr>\n+    fn read_os_str_from_c_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Tag>>,\n+    ) -> InterpResult<'tcx, &'a OsStr>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n-        let bytes = this.read_c_str(sptr)?;\n+        let bytes = this.read_c_str(ptr)?;\n         bytes_to_os_str(bytes)\n     }\n \n     /// Helper function to read an OsString from a 0x0000-terminated sequence of u16,\n     /// which is what the Windows APIs usually handle.\n-    fn read_os_str_from_wide_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, OsString>\n+    fn read_os_str_from_wide_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Tag>>,\n+    ) -> InterpResult<'tcx, OsString>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n@@ -78,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(s.into())\n         }\n \n-        let u16_vec = self.eval_context_ref().read_wide_str(sptr)?;\n+        let u16_vec = self.eval_context_ref().read_wide_str(ptr)?;\n         u16vec_to_osstring(u16_vec)\n     }\n \n@@ -90,7 +96,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_c_str(\n         &mut self,\n         os_str: &OsStr,\n-        sptr: Scalar<Tag>,\n+        ptr: Pointer<Option<Tag>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let bytes = os_str_to_bytes(os_str)?;\n@@ -102,7 +108,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         self.eval_context_mut()\n             .memory\n-            .write_bytes(sptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n+            .write_bytes(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n         Ok((true, string_length))\n     }\n \n@@ -114,7 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_wide_str(\n         &mut self,\n         os_str: &OsStr,\n-        sptr: Scalar<Tag>,\n+        ptr: Pointer<Option<Tag>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(windows)]\n@@ -146,7 +152,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let mut alloc = this\n             .memory\n-            .get_mut(sptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .get_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n             .unwrap(); // not a ZST, so we will get a result\n         for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n             let offset = u64::try_from(offset).unwrap();\n@@ -161,39 +167,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         os_str: &OsStr,\n         memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0` terminator.\n         let this = self.eval_context_mut();\n \n         let arg_type = this.tcx.mk_array(this.tcx.types.u8, size);\n         let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind)?;\n         assert!(self.write_os_str_to_c_str(os_str, arg_place.ptr, size).unwrap().0);\n-        Ok(arg_place.ptr.assert_ptr())\n+        Ok(arg_place.ptr)\n     }\n \n     /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of `u16`.\n     fn alloc_os_str_as_wide_str(\n         &mut self,\n         os_str: &OsStr,\n         memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n         let this = self.eval_context_mut();\n \n         let arg_type = this.tcx.mk_array(this.tcx.types.u16, size);\n         let arg_place = this.allocate(this.layout_of(arg_type).unwrap(), memkind)?;\n         assert!(self.write_os_str_to_wide_str(os_str, arg_place.ptr, size).unwrap().0);\n-        Ok(arg_place.ptr.assert_ptr())\n+        Ok(arg_place.ptr)\n     }\n \n     /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n-    fn read_path_from_c_str<'a>(&'a self, sptr: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n+    fn read_path_from_c_str<'a>(\n+        &'a self,\n+        ptr: Pointer<Option<Tag>>,\n+    ) -> InterpResult<'tcx, Cow<'a, Path>>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n     {\n         let this = self.eval_context_ref();\n-        let os_str = this.read_os_str_from_c_str(sptr)?;\n+        let os_str = this.read_os_str_from_c_str(ptr)?;\n \n         Ok(match this.convert_path_separator(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n             Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n@@ -202,9 +211,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Read a null-terminated sequence of `u16`s, and perform path separator conversion if needed.\n-    fn read_path_from_wide_str(&self, sptr: Scalar<Tag>) -> InterpResult<'tcx, PathBuf> {\n+    fn read_path_from_wide_str(&self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, PathBuf> {\n         let this = self.eval_context_ref();\n-        let os_str = this.read_os_str_from_wide_str(sptr)?;\n+        let os_str = this.read_os_str_from_wide_str(ptr)?;\n \n         Ok(this\n             .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n@@ -217,27 +226,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_path_to_c_str(\n         &mut self,\n         path: &Path,\n-        sptr: Scalar<Tag>,\n+        ptr: Pointer<Option<Tag>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n         let os_str = this\n             .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n-        this.write_os_str_to_c_str(&os_str, sptr, size)\n+        this.write_os_str_to_c_str(&os_str, ptr, size)\n     }\n \n     /// Write a Path to the machine memory (as a null-terminated sequence of `u16`s),\n     /// adjusting path separators if needed.\n     fn write_path_to_wide_str(\n         &mut self,\n         path: &Path,\n-        sptr: Scalar<Tag>,\n+        ptr: Pointer<Option<Tag>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n         let os_str = this\n             .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n-        this.write_os_str_to_wide_str(&os_str, sptr, size)\n+        this.write_os_str_to_wide_str(&os_str, ptr, size)\n     }\n \n     fn convert_path_separator<'a>("}, {"sha": "04a8e9063f9ac21412372843bbca895992aed37e", "filename": "src/shims/panic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -84,14 +84,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Get all the arguments.\n         let &[ref try_fn, ref data, ref catch_fn] = check_arg_count(args)?;\n-        let try_fn = this.read_scalar(try_fn)?.check_init()?;\n+        let try_fn = this.read_pointer(try_fn)?;\n         let data = this.read_scalar(data)?.check_init()?;\n         let catch_fn = this.read_scalar(catch_fn)?.check_init()?;\n \n         // Now we make a function call, and pass `data` as first and only argument.\n         let f_instance = this.memory.get_fn(try_fn)?.as_instance()?;\n         trace!(\"try_fn: {:?}\", f_instance);\n-        let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n+        let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n         this.call_function(\n             f_instance,\n             Abi::Rust,\n@@ -145,9 +145,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let payload = this.active_thread_mut().panic_payload.take().unwrap();\n \n             // Push the `catch_fn` stackframe.\n-            let f_instance = this.memory.get_fn(catch_unwind.catch_fn)?.as_instance()?;\n+            let f_instance =\n+                this.memory.get_fn(this.scalar_to_ptr(catch_unwind.catch_fn))?.as_instance()?;\n             trace!(\"catch_fn: {:?}\", f_instance);\n-            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n+            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n             this.call_function(\n                 f_instance,\n                 Abi::Rust,\n@@ -177,7 +178,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.call_function(\n             panic,\n             Abi::Rust,\n-            &[msg.to_ref()],\n+            &[msg.to_ref(this)],\n             None,\n             StackPopCleanup::Goto { ret: None, unwind },\n         )"}, {"sha": "09dd7d9c7b86987ca2b1ac0d142fd80cd77e039b", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -28,7 +28,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"getenv\" => {\n                 let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getenv(name)?;\n-                this.write_scalar(result, dest)?;\n+                this.write_pointer(result, dest)?;\n             }\n             \"unsetenv\" => {\n                 let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -44,7 +44,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"getcwd\" => {\n                 let &[ref buf, ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getcwd(buf, size)?;\n-                this.write_scalar(result, dest)?;\n+                this.write_pointer(result, dest)?;\n             }\n             \"chdir\" => {\n                 let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -68,15 +68,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"read\" => {\n                 let &[ref fd, ref buf, ref count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n-                let buf = this.read_scalar(buf)?.check_init()?;\n+                let buf = this.read_pointer(buf)?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n                 let &[ref fd, ref buf, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n-                let buf = this.read_scalar(buf)?.check_init()?;\n+                let buf = this.read_pointer(buf)?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n                 let result = this.write(fd, buf, count)?;\n@@ -160,7 +160,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::C.into(),\n                     )?;\n-                    this.write_scalar(ptr, &ret.into())?;\n+                    this.write_pointer(ptr, &ret.into())?;\n                 }\n                 this.write_null(dest)?;\n             }\n@@ -169,11 +169,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"dlsym\" => {\n                 let &[ref handle, ref symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n-                let symbol = this.read_scalar(symbol)?.check_init()?;\n+                let symbol = this.read_pointer(symbol)?;\n                 let symbol_name = this.read_c_str(symbol)?;\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name, &this.tcx.sess.target.os)? {\n                     let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n-                    this.write_scalar(Scalar::from(ptr), dest)?;\n+                    this.write_pointer(ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;\n                 }\n@@ -208,12 +208,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_key_create\" => {\n                 let &[ref key, ref dtor] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key_place = this.deref_operand(key)?;\n-                let dtor = this.read_scalar(dtor)?.check_init()?;\n+                let dtor = this.read_pointer(dtor)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n-                let dtor = match this.test_null(dtor)? {\n-                    Some(dtor_ptr) => Some(this.memory.get_fn(dtor_ptr)?.as_instance()?),\n-                    None => None,\n+                let dtor = if !this.ptr_is_null(dtor)? {\n+                    Some(this.memory.get_fn(dtor)?.as_instance()?)\n+                } else {\n+                    None\n                 };\n \n                 // Figure out how large a pthread TLS key actually is.\n@@ -235,24 +236,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_key_delete\" => {\n                 let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n+                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n                 let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n+                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let &[ref key, ref new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n+                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n-                let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n-                this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n+                let new_data = this.read_scalar(new_ptr)?;\n+                this.machine.tls.store_tls(key, active_thread, new_data.check_init()?, &*this.tcx)?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -412,9 +413,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_atfork\" => {\n                 let &[ref prepare, ref parent, ref child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n-                this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n-                this.force_bits(this.read_scalar(child)?.check_init()?, this.memory.pointer_size())?;\n+                this.read_pointer(prepare)?;\n+                this.read_pointer(parent)?;\n+                this.read_pointer(child)?;\n                 // We do not support forking, so there is nothing to do here.\n                 this.write_null(dest)?;\n             }"}, {"sha": "a14a9c907eedce2e44484660aa1eff6789a16c0a", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -17,7 +17,6 @@ use rustc_target::abi::{Align, LayoutOf, Size};\n use crate::*;\n use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n use shims::time::system_time_to_duration;\n-use stacked_borrows::Tag;\n \n #[derive(Debug)]\n struct FileHandle {\n@@ -317,7 +316,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let path_scalar = this.read_scalar(path_op)?.check_init()?;\n+        let path_scalar = this.read_pointer(path_op)?;\n         let path = this.read_path_from_c_str(path_scalar)?.into_owned();\n \n         let metadata = match FileMetadata::from_path(this, &path, follow_symlink)? {\n@@ -582,7 +581,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n-        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n         let fd = options.open(&path).map(|file| {\n             let fh = &mut this.machine.file_handler;\n@@ -670,7 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn read(&mut self, fd: i32, buf: Scalar<Tag>, count: u64) -> InterpResult<'tcx, i64> {\n+    fn read(&mut self, fd: i32, buf: Pointer<Option<Tag>>, count: u64) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -718,7 +717,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn write(&mut self, fd: i32, buf: Scalar<Tag>, count: u64) -> InterpResult<'tcx, i64> {\n+    fn write(&mut self, fd: i32, buf: Pointer<Option<Tag>>, count: u64) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -788,7 +787,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`unlink`\")?;\n \n-        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n         let result = remove_file(path).map(|_| 0);\n         this.try_unwrap_io_result(result)\n@@ -814,8 +813,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`symlink`\")?;\n \n-        let target = this.read_path_from_c_str(this.read_scalar(target_op)?.check_init()?)?;\n-        let linkpath = this.read_path_from_c_str(this.read_scalar(linkpath_op)?.check_init()?)?;\n+        let target = this.read_path_from_c_str(this.read_pointer(target_op)?)?;\n+        let linkpath = this.read_path_from_c_str(this.read_pointer(linkpath_op)?)?;\n \n         let result = create_link(&target, &linkpath).map(|_| 0);\n         this.try_unwrap_io_result(result)\n@@ -877,11 +876,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.assert_target_os(\"linux\", \"statx\");\n         this.check_no_isolation(\"`statx`\")?;\n \n-        let statxbuf_scalar = this.read_scalar(statxbuf_op)?.check_init()?;\n-        let pathname_scalar = this.read_scalar(pathname_op)?.check_init()?;\n+        let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n+        let pathname_ptr = this.read_pointer(pathname_op)?;\n \n         // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n-        if this.is_null(statxbuf_scalar)? || this.is_null(pathname_scalar)? {\n+        if this.ptr_is_null(statxbuf_ptr)? || this.ptr_is_null(pathname_ptr)? {\n             let efault = this.eval_libc(\"EFAULT\")?;\n             this.set_last_error(efault)?;\n             return Ok(-1);\n@@ -898,13 +897,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let statx_ty = this\n                 .resolve_path(&[\"libc\", \"unix\", \"linux_like\", \"linux\", \"gnu\", \"statx\"])\n                 .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-            let statxbuf_ty = this.tcx.mk_mut_ptr(statx_ty);\n-            let statxbuf_layout = this.layout_of(statxbuf_ty)?;\n-            let statxbuf_imm = ImmTy::from_scalar(statxbuf_scalar, statxbuf_layout);\n-            this.ref_to_mplace(&statxbuf_imm)?\n+            let statx_layout = this.layout_of(statx_ty)?;\n+            MPlaceTy::from_aligned_ptr(statxbuf_ptr, statx_layout)\n         };\n \n-        let path = this.read_path_from_c_str(pathname_scalar)?.into_owned();\n+        let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n         let flags = this.read_scalar(flags_op)?.to_i32()?;\n         let empty_path_flag = flags & this.eval_libc(\"AT_EMPTY_PATH\")?.to_i32()? != 0;\n@@ -1037,17 +1034,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`rename`\")?;\n \n-        let oldpath_scalar = this.read_scalar(oldpath_op)?.check_init()?;\n-        let newpath_scalar = this.read_scalar(newpath_op)?.check_init()?;\n+        let oldpath_ptr = this.read_pointer(oldpath_op)?;\n+        let newpath_ptr = this.read_pointer(newpath_op)?;\n \n-        if this.is_null(oldpath_scalar)? || this.is_null(newpath_scalar)? {\n+        if this.ptr_is_null(oldpath_ptr)? || this.ptr_is_null(newpath_ptr)? {\n             let efault = this.eval_libc(\"EFAULT\")?;\n             this.set_last_error(efault)?;\n             return Ok(-1);\n         }\n \n-        let oldpath = this.read_path_from_c_str(oldpath_scalar)?;\n-        let newpath = this.read_path_from_c_str(newpath_scalar)?;\n+        let oldpath = this.read_path_from_c_str(oldpath_ptr)?;\n+        let newpath = this.read_path_from_c_str(newpath_ptr)?;\n \n         let result = rename(oldpath, newpath).map(|_| 0);\n \n@@ -1065,12 +1062,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         #[cfg_attr(not(unix), allow(unused_variables))]\n         let mode = if this.tcx.sess.target.os == \"macos\" {\n-            u32::from(this.read_scalar(mode_op)?.check_init()?.to_u16()?)\n+            u32::from(this.read_scalar(mode_op)?.to_u16()?)\n         } else {\n             this.read_scalar(mode_op)?.to_u32()?\n         };\n \n-        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n         #[cfg_attr(not(unix), allow(unused_mut))]\n         let mut builder = DirBuilder::new();\n@@ -1093,7 +1090,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`rmdir`\")?;\n \n-        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n+        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n         let result = remove_dir(path).map(|_| 0i32);\n \n@@ -1105,7 +1102,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`opendir`\")?;\n \n-        let name = this.read_path_from_c_str(this.read_scalar(name_op)?.check_init()?)?;\n+        let name = this.read_path_from_c_str(this.read_pointer(name_op)?)?;\n \n         let result = read_dir(name);\n \n@@ -1449,8 +1446,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"readlink\")?;\n \n-        let pathname = this.read_path_from_c_str(this.read_scalar(pathname_op)?.check_init()?)?;\n-        let buf = this.read_scalar(buf_op)?.check_init()?;\n+        let pathname = this.read_path_from_c_str(this.read_pointer(pathname_op)?)?;\n+        let buf = this.read_pointer(buf_op)?;\n         let bufsize = this.read_scalar(bufsize_op)?.to_machine_usize(this)?;\n \n         let result = std::fs::read_link(pathname);"}, {"sha": "0a9939fedd4cbd6cc70ef082cf56c0ec743e1d18", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -26,7 +26,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"__errno_location\" => {\n                 let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n-                this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n             }\n \n             // File related shims (but also see \"syscall\" below for statx)\n@@ -231,7 +231,7 @@ fn getrandom<'tcx>(\n     flags: &OpTy<'tcx, Tag>,\n     dest: &PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n-    let ptr = this.read_scalar(ptr)?.check_init()?;\n+    let ptr = this.read_pointer(ptr)?;\n     let len = this.read_scalar(len)?.to_machine_usize(this)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,"}, {"sha": "17ddca879e6843e1df5f89ae7899edd0ecd959f3", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -31,13 +31,8 @@ pub fn futex<'tcx>(\n     let op = this.read_scalar(&args[2])?.to_i32()?;\n     let val = this.read_scalar(&args[3])?.to_i32()?;\n \n-    // The raw pointer value is used to identify the mutex.\n-    // Not all mutex operations actually read from this address or even require this address to exist.\n-    // This will make FUTEX_WAKE fail on an integer cast to a pointer. But FUTEX_WAIT on\n-    // such a pointer can never work anyway, so that seems fine.\n-    let futex_ptr = this.force_ptr(addr.to_scalar()?)?;\n-\n     let thread = this.get_active_thread();\n+    let addr_scalar = addr.to_scalar()?;\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n@@ -57,14 +52,16 @@ pub fn futex<'tcx>(\n                     args.len()\n                 );\n             }\n-            let timeout = &args[4];\n-            let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n+\n+            // `deref_operand` but not actually dereferencing the ptr yet (it might be NULL!).\n+            let timeout = this.ref_to_mplace(&this.read_immediate(&args[4])?)?;\n+            let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n                 this.check_no_isolation(\n                     \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\",\n                 )?;\n-                let duration = match this.read_timespec(timeout)? {\n+                let duration = match this.read_timespec(&timeout)? {\n                     Some(duration) => duration,\n                     None => {\n                         let einval = this.eval_libc(\"EINVAL\")?;\n@@ -83,7 +80,7 @@ pub fn futex<'tcx>(\n             // The API requires `addr` to be a 4-byte aligned pointer, and will\n             // use the 4 bytes at the given address as an (atomic) i32.\n             this.memory.check_ptr_access_align(\n-                addr.to_scalar()?,\n+                this.scalar_to_ptr(addr_scalar),\n                 Size::from_bytes(4),\n                 Align::from_bytes(4).unwrap(),\n                 CheckInAllocMsg::MemoryAccessTest,\n@@ -111,7 +108,7 @@ pub fn futex<'tcx>(\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(futex_ptr, thread);\n+                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -123,7 +120,7 @@ pub fn futex<'tcx>(\n                         timeout_time,\n                         Box::new(move |this| {\n                             this.unblock_thread(thread);\n-                            this.futex_remove_waiter(futex_ptr, thread);\n+                            this.futex_remove_waiter(addr_scalar.to_machine_usize(this)?, thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n@@ -146,7 +143,7 @@ pub fn futex<'tcx>(\n         op if op == futex_wake => {\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(futex_ptr) {\n+                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}, {"sha": "d5996cc6a9ed16f12c343e25be2c824c2ab0140b", "filename": "src/shims/posix/macos/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -37,7 +37,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match dlsym {\n             Dlsym::getentropy => {\n                 let &[ref ptr, ref len] = check_arg_count(args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len)?;\n                 this.write_null(dest)?;"}, {"sha": "2f79b337ce386bd32383bb0ea21e6ff95ecdf714", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"__error\" => {\n                 let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n-                this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n             }\n \n             // File related shims\n@@ -74,7 +74,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Environment related shims\n             \"_NSGetEnviron\" => {\n                 let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n+                this.write_pointer(\n+                    this.machine.env_vars.environ.expect(\"machine must be initialized\").ptr,\n+                    dest,\n+                )?;\n             }\n \n             // Time related shims\n@@ -100,18 +103,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n                 let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n+                this.write_pointer(\n+                    this.machine.argc.expect(\"machine must be initialized\").ptr,\n+                    dest,\n+                )?;\n             }\n             \"_NSGetArgv\" => {\n                 let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n+                this.write_pointer(\n+                    this.machine.argv.expect(\"machine must be initialized\").ptr,\n+                    dest,\n+                )?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n                 let &[ref dtor, ref data] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let dtor = this.read_scalar(dtor)?.check_init()?;\n+                let dtor = this.read_pointer(dtor)?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.check_init()?;\n                 let active_thread = this.get_active_thread();\n@@ -138,7 +147,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_setname_np\" => {\n                 let &[ref name] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let name = this.read_scalar(name)?.check_init()?;\n+                let name = this.read_pointer(name)?;\n                 this.pthread_setname_np(name)?;\n             }\n "}, {"sha": "782765c7784bd72bc7f733a95b6f17923171a5f7", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,7 +1,6 @@\n use std::time::SystemTime;\n \n use crate::*;\n-use stacked_borrows::Tag;\n use thread::Time;\n \n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n@@ -364,8 +363,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let attr = this.read_scalar(attr_op)?.check_init()?;\n-        let kind = if this.is_null(attr)? {\n+        let attr = this.read_pointer(attr_op)?;\n+        let kind = if this.ptr_is_null(attr)? {\n             this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n         } else {\n             mutexattr_get_kind(this, attr_op)?.check_init()?\n@@ -657,8 +656,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let attr = this.read_scalar(attr_op)?.check_init()?;\n-        let clock_id = if this.is_null(attr)? {\n+        let attr = this.read_pointer(attr_op)?;\n+        let clock_id = if this.ptr_is_null(attr)? {\n             this.eval_libc(\"CLOCK_REALTIME\")?\n         } else {\n             condattr_get_clock_id(this, attr_op)?.check_init()?\n@@ -727,7 +726,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Extract the timeout.\n         let clock_id = cond_get_clock_id(this, cond_op)?.to_i32()?;\n-        let duration = match this.read_timespec(abstime_op)? {\n+        let duration = match this.read_timespec(&this.deref_operand(abstime_op)?)? {\n             Some(duration) => duration,\n             None => {\n                 let einval = this.eval_libc(\"EINVAL\")?;"}, {"sha": "9926c36c49ac44c7f225ee97d021822f208dfbeb", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -33,7 +33,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Read the function argument that will be sent to the new thread\n         // before the thread starts executing since reading after the\n         // context switch will incorrectly report a data-race.\n-        let fn_ptr = this.read_scalar(start_routine)?.check_init()?;\n+        let fn_ptr = this.read_pointer(start_routine)?;\n         let func_arg = this.read_immediate(arg)?;\n \n         // Finally switch to new thread so that we can push the first stackframe.\n@@ -70,7 +70,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        if !this.is_null(this.read_scalar(retval)?.check_init()?)? {\n+        if !this.ptr_is_null(this.read_pointer(retval)?)? {\n             // FIXME: implement reading the thread function's return place.\n             throw_unsup_format!(\"Miri supports pthread_join only with retval==NULL\");\n         }\n@@ -110,15 +110,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let option = this.read_scalar(option)?.to_i32()?;\n         if option == this.eval_libc_i32(\"PR_SET_NAME\")? {\n-            let address = this.read_scalar(arg2)?.check_init()?;\n+            let address = this.read_pointer(arg2)?;\n             let mut name = this.read_c_str(address)?.to_owned();\n             // The name should be no more than 16 bytes, including the null\n             // byte. Since `read_c_str` returns the string without the null\n             // byte, we need to truncate to 15.\n             name.truncate(15);\n             this.set_active_thread_name(name);\n         } else if option == this.eval_libc_i32(\"PR_GET_NAME\")? {\n-            let address = this.read_scalar(arg2)?.check_init()?;\n+            let address = this.read_pointer(arg2)?;\n             let mut name = this.get_active_thread_name().to_vec();\n             name.push(0u8);\n             assert!(name.len() <= 16);\n@@ -130,7 +130,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_setname_np(&mut self, name: Scalar<Tag>) -> InterpResult<'tcx> {\n+    fn pthread_setname_np(&mut self, name: Pointer<Option<Tag>>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n "}, {"sha": "1db9d85debdc19eec9583800016cd988df2f2e56", "filename": "src/shims/time.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,7 +1,6 @@\n use std::convert::TryFrom;\n use std::time::{Duration, Instant, SystemTime};\n \n-use crate::stacked_borrows::Tag;\n use crate::*;\n use helpers::{immty_from_int_checked, immty_from_uint_checked};\n use thread::Time;\n@@ -63,8 +62,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"`gettimeofday`\")?;\n \n         // Using tz is obsolete and should always be null\n-        let tz = this.read_scalar(tz_op)?.check_init()?;\n-        if !this.is_null(tz)? {\n+        let tz = this.read_pointer(tz_op)?;\n+        if !this.ptr_is_null(tz)? {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n             return Ok(-1);\n@@ -206,7 +205,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"`nanosleep`\")?;\n \n-        let duration = match this.read_timespec(req_op)? {\n+        let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n             Some(duration) => duration,\n             None => {\n                 let einval = this.eval_libc(\"EINVAL\")?;"}, {"sha": "cf8b8e3e1b887ad99af90327ab333b010282a358", "filename": "src/shims/tls.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -109,19 +109,17 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: TlsKey,\n         thread_id: ThreadId,\n-        new_data: Option<Scalar<Tag>>,\n+        new_data: Scalar<Tag>,\n+        cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(TlsEntry { data, .. }) => {\n-                match new_data {\n-                    Some(scalar) => {\n-                        trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, scalar);\n-                        data.insert(thread_id, scalar);\n-                    }\n-                    None => {\n-                        trace!(\"TLS key {} for thread {:?} removed\", key, thread_id);\n-                        data.remove(&thread_id);\n-                    }\n+                if new_data.to_machine_usize(cx)? != 0 {\n+                    trace!(\"TLS key {} for thread {:?} stored: {:?}\", key, thread_id, new_data);\n+                    data.insert(thread_id, new_data);\n+                } else {\n+                    trace!(\"TLS key {} for thread {:?} removed\", key, thread_id);\n+                    data.remove(&thread_id);\n                 }\n                 Ok(())\n             }\n@@ -250,11 +248,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"thread_local_key\",\n             \"p_thread_callback\",\n         ])?;\n-        let thread_callback = this.memory.get_fn(thread_callback.check_init()?)?.as_instance()?;\n+        let thread_callback =\n+            this.memory.get_fn(this.scalar_to_ptr(thread_callback))?.as_instance()?;\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n         let reason = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", \"DLL_THREAD_DETACH\"])?;\n-        let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n+        let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n         this.call_function(\n             thread_callback,\n             Abi::System { unwind: false },\n@@ -277,7 +276,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n             trace!(\"Running macos dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n \n-            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n+            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n             this.call_function(\n                 instance,\n                 Abi::C { unwind: false },\n@@ -315,9 +314,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key =\n                 Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n-            assert!(!this.is_null(ptr).unwrap(), \"data can't be NULL when dtor is called!\");\n+            assert!(\n+                !ptr.to_machine_usize(this).unwrap() != 0,\n+                \"data can't be NULL when dtor is called!\"\n+            );\n \n-            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n+            let ret_place = MPlaceTy::dangling(this.machine.layouts.unit).into();\n             this.call_function(\n                 instance,\n                 Abi::C { unwind: false },\n@@ -349,6 +351,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n+        trace!(\"schedule_next_tls_dtor_for_active_thread on thread {:?}\", active_thread);\n \n         if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n             // This is the first time we got asked to schedule a destructor. The"}, {"sha": "0eebd6aca5bd43df707475400b5cd50e2c69d5f4", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -43,7 +43,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"GetEnvironmentStringsW\" => {\n                 let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n-                this.write_scalar(result, dest)?;\n+                this.write_pointer(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n                 let &[ref env_block] =\n@@ -78,7 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n-                let buf = this.read_scalar(buf)?.check_init()?;\n+                let buf = this.read_pointer(buf)?;\n                 let n = this.read_scalar(n)?.to_u32()?;\n                 let written_place = this.deref_operand(written_ptr)?;\n                 // Spec says to always write `0` first.\n@@ -116,14 +116,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap)?;\n-                this.write_scalar(res, dest)?;\n+                this.write_pointer(res, dest)?;\n             }\n             \"HeapFree\" => {\n                 let &[ref handle, ref flags, ref ptr] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n@@ -132,10 +132,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n-                this.write_scalar(res, dest)?;\n+                this.write_pointer(res, dest)?;\n             }\n \n             // errno\n@@ -189,8 +189,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n-                let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n-                this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n+                let new_data = this.read_scalar(new_ptr)?.check_init()?;\n+                this.machine.tls.store_tls(key, active_thread, new_data, &*this.tcx)?;\n \n                 // Return success (`1`).\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n@@ -199,8 +199,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n                 let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.write_scalar(\n-                    this.machine.cmd_line.expect(\"machine must be initialized\"),\n+                this.write_pointer(\n+                    this.machine.cmd_line.expect(\"machine must be initialized\").ptr,\n                     dest,\n                 )?;\n             }\n@@ -267,10 +267,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref hModule, ref lpProcName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n-                let name = this.read_c_str(this.read_scalar(lpProcName)?.check_init()?)?;\n+                let name = this.read_c_str(this.read_pointer(lpProcName)?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n                     let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n-                    this.write_scalar(Scalar::from(ptr), dest)?;\n+                    this.write_pointer(ptr, dest)?;\n                 } else {\n                     this.write_null(dest)?;\n                 }\n@@ -281,7 +281,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This is really 'RtlGenRandom'.\n                 let &[ref ptr, ref len] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n@@ -290,7 +290,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let &[ref algorithm, ref ptr, ref len, ref flags] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n-                let ptr = this.read_scalar(ptr)?.check_init()?;\n+                let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n                 if flags != 2 {"}, {"sha": "ddfbfd426680aaafa45be9eb5b5b6dc0858a3531", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 132, "deletions": 85, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n use rustc_middle::mir::RetagKind;\n use rustc_middle::ty;\n-use rustc_target::abi::{Align, LayoutOf, Size};\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n@@ -20,16 +20,16 @@ pub type AllocExtra = Stacks;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub enum Tag {\n+pub enum SbTag {\n     Tagged(PtrId),\n     Untagged,\n }\n \n-impl fmt::Debug for Tag {\n+impl fmt::Debug for SbTag {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Tag::Tagged(id) => write!(f, \"<{}>\", id),\n-            Tag::Untagged => write!(f, \"<untagged>\"),\n+            SbTag::Tagged(id) => write!(f, \"<{}>\", id),\n+            SbTag::Untagged => write!(f, \"<untagged>\"),\n         }\n     }\n }\n@@ -54,7 +54,7 @@ pub struct Item {\n     /// The permission this item grants.\n     perm: Permission,\n     /// The pointers the permission is granted to.\n-    tag: Tag,\n+    tag: SbTag,\n     /// An optional protector, ensuring the item cannot get popped until `CallId` is over.\n     protector: Option<CallId>,\n }\n@@ -95,7 +95,7 @@ pub struct GlobalState {\n     /// Table storing the \"base\" tag for each allocation.\n     /// The base tag is the one used for the initial pointer.\n     /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_ids: FxHashMap<AllocId, Tag>,\n+    base_ptr_ids: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n@@ -197,14 +197,22 @@ impl GlobalState {\n         self.active_calls.contains(&id)\n     }\n \n-    pub fn global_base_ptr(&mut self, id: AllocId) -> Tag {\n+    pub fn base_tag(&mut self, id: AllocId) -> SbTag {\n         self.base_ptr_ids.get(&id).copied().unwrap_or_else(|| {\n-            let tag = Tag::Tagged(self.new_ptr());\n+            let tag = SbTag::Tagged(self.new_ptr());\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n             self.base_ptr_ids.try_insert(id, tag).unwrap();\n             tag\n         })\n     }\n+\n+    pub fn base_tag_untagged(&mut self, id: AllocId) -> SbTag {\n+        trace!(\"New allocation {:?} has no base tag (untagged)\", id);\n+        let tag = SbTag::Untagged;\n+        // This must only be done on new allocations.\n+        self.base_ptr_ids.try_insert(id, tag).unwrap();\n+        tag\n+    }\n }\n \n /// Error reporting\n@@ -247,7 +255,7 @@ impl Permission {\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n     /// it is on the stack.\n-    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n+    fn find_granting(&self, access: AccessKind, tag: SbTag) -> Option<usize> {\n         self.borrows\n             .iter()\n             .enumerate() // we also need to know *where* in the stack\n@@ -288,8 +296,12 @@ impl<'tcx> Stack {\n     }\n \n     /// Check if the given item is protected.\n-    fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n-        if let Tag::Tagged(id) = item.tag {\n+    fn check_protector(\n+        item: &Item,\n+        tag: Option<SbTag>,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        if let SbTag::Tagged(id) = item.tag {\n             if Some(id) == global.tracked_pointer_tag {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(item.clone()));\n             }\n@@ -314,18 +326,17 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         access: AccessKind,\n-        ptr: Pointer<Tag>,\n+        tag: SbTag,\n+        dbg_ptr: Pointer<AllocId>, // just for debug printing amd error messages\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, ptr.tag).ok_or_else(|| {\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting {} to tag {:?} at {} found in borrow stack.\",\n-                access,\n-                ptr.tag,\n-                ptr.erase_tag(),\n+                \"no item granting {} to tag {:?} at {:?} found in borrow stack.\",\n+                access, tag, dbg_ptr,\n             ))\n         })?;\n \n@@ -337,7 +348,7 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some(ptr.tag), global)?;\n+                Stack::check_protector(&item, Some(tag), global)?;\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -352,7 +363,7 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some(ptr.tag), global)?;\n+                    Stack::check_protector(item, Some(tag), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n             }\n@@ -364,12 +375,17 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    fn dealloc(&mut self, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn dealloc(\n+        &mut self,\n+        tag: SbTag,\n+        dbg_ptr: Pointer<AllocId>, // just for debug printing amd error messages\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, ptr.tag).ok_or_else(|| {\n+        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting write access for deallocation to tag {:?} at {} found in borrow stack\",\n-                ptr.tag, ptr.erase_tag(),\n+                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n+                tag, dbg_ptr,\n             ))\n         })?;\n \n@@ -387,19 +403,20 @@ impl<'tcx> Stack {\n     /// from instead of all the way at the top of the stack.\n     fn grant(\n         &mut self,\n-        derived_from: Pointer<Tag>,\n+        derived_from: SbTag,\n         new: Item,\n+        dbg_ptr: Pointer<AllocId>,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from.tag)\n+        let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| err_sb_ub(format!(\n-                \"trying to reborrow for {:?} at {}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n-                new.perm, derived_from.erase_tag(), derived_from.tag,\n+                \"trying to reborrow for {:?} at {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n+                new.perm, dbg_ptr, derived_from,\n             )))?;\n \n         // Compute where to put the new item.\n@@ -419,7 +436,7 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, global)?;\n+            self.access(access, derived_from, dbg_ptr, global)?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -445,7 +462,7 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: Tag) -> Self {\n+    fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack { borrows: vec![item] };\n \n@@ -455,31 +472,25 @@ impl<'tcx> Stacks {\n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n+        range: AllocRange,\n+        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n-        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n-            let mut cur_ptr = ptr;\n-            cur_ptr.offset = offset;\n-            f(cur_ptr, stack)?;\n+        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n+            f(offset, stack)?;\n         }\n         Ok(())\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each_mut(\n         &mut self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n+        range: AllocRange,\n+        f: impl Fn(Size, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n-        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n-            let mut cur_ptr = ptr;\n-            cur_ptr.offset = offset;\n-            f(cur_ptr, stack)?;\n+        for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n+            f(offset, stack)?;\n         }\n         Ok(())\n     }\n@@ -492,15 +503,15 @@ impl Stacks {\n         size: Size,\n         extra: &MemoryExtra,\n         kind: MemoryKind<MiriMemoryKind>,\n-    ) -> (Self, Tag) {\n+    ) -> Self {\n         let mut extra = extra.borrow_mut();\n-        let (tag, perm) = match kind {\n+        let (base_tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (Tag::Tagged(extra.new_ptr()), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_tag(id), Permission::Unique),\n             // `Global` memory can be referenced by global pointers from `tcx`.\n             // Thus we call `global_base_ptr` such that the global pointers get the same tag\n             // as what we use here.\n@@ -515,53 +526,72 @@ impl Stacks {\n                 | MiriMemoryKind::Tls\n                 | MiriMemoryKind::Env\n                 | MiriMemoryKind::Machine,\n-            ) => (extra.global_base_ptr(id), Permission::SharedReadWrite),\n+            ) => (extra.base_tag(id), Permission::SharedReadWrite),\n             // Heap allocations we only track precisely when raw pointers are tagged, for now.\n             MemoryKind::Machine(\n                 MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n             ) => {\n                 let tag =\n-                    if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n+                    if extra.track_raw { extra.base_tag(id) } else { extra.base_tag_untagged(id) };\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        (Stacks::new(size, perm, tag), tag)\n+        Stacks::new(size, perm, base_tag)\n     }\n \n     #[inline(always)]\n     pub fn memory_read<'tcx>(\n         &self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        alloc_id: AllocId,\n+        tag: SbTag,\n+        range: AllocRange,\n         extra: &MemoryExtra,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        trace!(\n+            \"read access with tag {:?}: {:?}, size {}\",\n+            tag,\n+            Pointer::new(alloc_id, range.start),\n+            range.size.bytes()\n+        );\n         let global = &*extra.borrow();\n-        self.for_each(ptr, size, move |ptr, stack| stack.access(AccessKind::Read, ptr, global))\n+        self.for_each(range, move |offset, stack| {\n+            stack.access(AccessKind::Read, tag, Pointer::new(alloc_id, offset), global)\n+        })\n     }\n \n     #[inline(always)]\n     pub fn memory_written<'tcx>(\n         &mut self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        alloc_id: AllocId,\n+        tag: SbTag,\n+        range: AllocRange,\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        trace!(\n+            \"write access with tag {:?}: {:?}, size {}\",\n+            tag,\n+            Pointer::new(alloc_id, range.start),\n+            range.size.bytes()\n+        );\n         let global = extra.get_mut();\n-        self.for_each_mut(ptr, size, move |ptr, stack| stack.access(AccessKind::Write, ptr, global))\n+        self.for_each_mut(range, move |offset, stack| {\n+            stack.access(AccessKind::Write, tag, Pointer::new(alloc_id, offset), global)\n+        })\n     }\n \n     #[inline(always)]\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        alloc_id: AllocId,\n+        tag: SbTag,\n+        range: AllocRange,\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n+        trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let global = extra.get_mut();\n-        self.for_each_mut(ptr, size, move |ptr, stack| stack.dealloc(ptr, global))\n+        self.for_each_mut(range, move |offset, stack| {\n+            stack.dealloc(tag, Pointer::new(alloc_id, offset), global)\n+        })\n     }\n }\n \n@@ -574,11 +604,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n         kind: RefKind,\n-        new_tag: Tag,\n+        new_tag: SbTag,\n         protect: bool,\n     ) -> InterpResult<'tcx> {\n-        // Nothing to do for ZSTs.\n+        let this = self.eval_context_mut();\n         if size == Size::ZERO {\n+            // Nothing to do for zero-sized accesses.\n             trace!(\n                 \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n                 kind,\n@@ -588,17 +619,30 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             );\n             return Ok(());\n         }\n+        let (alloc_id, base_offset, ptr) = this.memory.ptr_get_alloc(place.ptr)?;\n+        let orig_tag = ptr.provenance.sb;\n+\n+        // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n+        let (allocation_size, _) =\n+            this.memory.get_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+        if base_offset + size > allocation_size {\n+            throw_ub!(PointerOutOfBounds {\n+                alloc_id,\n+                offset: base_offset,\n+                size,\n+                allocation_size,\n+                msg: CheckInAllocMsg::InboundsTest\n+            });\n+        }\n \n-        let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n-        let ptr = place.ptr.assert_ptr();\n         trace!(\n             \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind,\n             new_tag,\n-            ptr.tag,\n+            orig_tag,\n             place.layout.ty,\n-            ptr.erase_tag(),\n+            Pointer::new(alloc_id, base_offset),\n             size.bytes()\n         );\n \n@@ -615,33 +659,39 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n-                let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n+                let extra = this.memory.get_alloc_extra(alloc_id)?;\n                 let stacked_borrows =\n                     extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n                 let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n-                return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n+                    // Adjust range.\n+                    range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen {\n                         Permission::SharedReadOnly\n                     } else {\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack| {\n-                        stack.grant(cur_ptr, item, &*global)\n+                    stacked_borrows.for_each(range, |offset, stack| {\n+                        stack.grant(orig_tag, item, Pointer::new(alloc_id, offset), &*global)\n                     })\n-                });\n+                })?;\n+                return Ok(());\n             }\n         };\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let (alloc_extra, memory_extra) = this.memory.get_alloc_extra_mut(ptr.alloc_id)?;\n+        let (alloc_extra, memory_extra) = this.memory.get_alloc_extra_mut(alloc_id)?;\n         let stacked_borrows =\n             alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n         let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each_mut(ptr, size, |ptr, stack| stack.grant(ptr, item, global))\n+        stacked_borrows.for_each_mut(alloc_range(base_offset, size), |offset, stack| {\n+            stack.grant(orig_tag, item, Pointer::new(alloc_id, offset), global)\n+        })?;\n+        Ok(())\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -663,29 +713,26 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(size) => size,\n             None => return Ok(*val),\n         };\n-        // `reborrow` relies on getting a `Pointer` and everything being in-bounds,\n-        // so let's ensure that. However, we do not care about alignment.\n-        // We can see dangling ptrs in here e.g. after a Box's `Unique` was\n-        // updated using \"self.0 = ...\" (can happen in Box::from_raw) so we cannot ICE; see miri#1050.\n-        let place = this.mplace_access_checked(place, Some(Align::from_bytes(1).unwrap()))?;\n \n         // Compute new borrow.\n         let new_tag = {\n             let mem_extra = this.memory.extra.stacked_borrows.as_mut().unwrap().get_mut();\n             match kind {\n                 // Give up tracking for raw pointers.\n-                RefKind::Raw { .. } if !mem_extra.track_raw => Tag::Untagged,\n+                RefKind::Raw { .. } if !mem_extra.track_raw => SbTag::Untagged,\n                 // All other pointers are properly tracked.\n-                _ => Tag::Tagged(mem_extra.new_ptr()),\n+                _ => SbTag::Tagged(mem_extra.new_ptr()),\n             }\n         };\n \n         // Reborrow.\n         this.reborrow(&place, size, kind, new_tag, protect)?;\n-        let new_place = place.replace_tag(new_tag);\n+\n+        // Adjust pointer.\n+        let new_place = place.map_provenance(|p| p.map(|t| Tag { sb: new_tag, ..t }));\n \n         // Return new pointer.\n-        Ok(ImmTy::from_immediate(new_place.to_ref(), val.layout))\n+        Ok(ImmTy::from_immediate(new_place.to_ref(this), val.layout))\n     }\n }\n \n@@ -752,7 +799,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We have to turn the place into a pointer to use the existing code.\n         // (The pointer type does not matter, so we use a raw pointer.)\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n-        let val = ImmTy::from_immediate(return_place.to_ref(), ptr_layout);\n+        let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it.\n         let val = this.retag_reference(\n             &val,"}, {"sha": "0e4e9695d81d529b7160ff044c1fa2afc7c6a095", "filename": "src/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -152,7 +152,7 @@ pub(super) struct SynchronizationState {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n-    futexes: HashMap<Pointer, Futex>,\n+    futexes: HashMap<u64, Futex>,\n }\n \n // Private extension trait for local helper methods\n@@ -486,18 +486,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n     }\n \n-    fn futex_wait(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+    fn futex_wait(&mut self, addr: u64, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        let futex = &mut this.machine.threads.sync.futexes.entry(addr.erase_tag()).or_default();\n+        let futex = &mut this.machine.threads.sync.futexes.entry(addr).or_default();\n         let waiters = &mut futex.waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n         waiters.push_back(FutexWaiter { thread });\n     }\n \n-    fn futex_wake(&mut self, addr: Pointer<stacked_borrows::Tag>) -> Option<ThreadId> {\n+    fn futex_wake(&mut self, addr: u64) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n-        let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr.erase_tag())?;\n+        let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n         let data_race = &this.memory.extra.data_race;\n \n         // Each futex-wake happens-before the end of the futex wait\n@@ -513,9 +513,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         res\n     }\n \n-    fn futex_remove_waiter(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+    fn futex_remove_waiter(&mut self, addr: u64, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        if let Some(futex) = this.machine.threads.sync.futexes.get_mut(&addr.erase_tag()) {\n+        if let Some(futex) = this.machine.threads.sync.futexes.get_mut(&addr) {\n             futex.waiters.retain(|waiter| waiter.thread != thread);\n         }\n     }"}, {"sha": "de8e41224b20f21694c385004e6f8cfa9dcb00d0", "filename": "src/thread.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -218,7 +218,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n     pub(crate) sync: SynchronizationState,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n-    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), AllocId>>,\n+    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Tag>>>,\n     /// A flag that indicates that we should change the active thread.\n     yield_active_thread: bool,\n     /// Callbacks that are called once the specified time passes.\n@@ -247,18 +247,18 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n-    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<AllocId> {\n+    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Tag>> {\n         self.thread_local_alloc_ids.borrow().get(&(def_id, self.active_thread)).cloned()\n     }\n \n-    /// Set the allocation id as the allocation id of the given thread local\n+    /// Set the pointer for the allocation of the given thread local\n     /// static for the active thread.\n     ///\n     /// Panics if a thread local is initialized twice for the same thread.\n-    fn set_thread_local_alloc_id(&self, def_id: DefId, new_alloc_id: AllocId) {\n+    fn set_thread_local_alloc(&self, def_id: DefId, ptr: Pointer<Tag>) {\n         self.thread_local_alloc_ids\n             .borrow_mut()\n-            .try_insert((def_id, self.active_thread), new_alloc_id)\n+            .try_insert((def_id, self.active_thread), ptr)\n             .unwrap();\n     }\n \n@@ -435,11 +435,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n-    /// The `AllocId` that can now be freed is returned.\n+    /// The `AllocId` that can now be freed are returned.\n     fn thread_terminated(\n         &mut self,\n         mut data_race: Option<&mut data_race::GlobalState>,\n-    ) -> Vec<AllocId> {\n+    ) -> Vec<Pointer<Tag>> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -557,16 +557,16 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n-    fn get_or_create_thread_local_alloc_id(\n+    fn get_or_create_thread_local_alloc(\n         &mut self,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n+    ) -> InterpResult<'tcx, Pointer<Tag>> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n-        if let Some(new_alloc_id) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n+        if let Some(old_alloc) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n             // We already have a thread-specific allocation id for this\n             // thread-local static.\n-            Ok(new_alloc_id)\n+            Ok(old_alloc)\n         } else {\n             // We need to allocate a thread-specific allocation id for this\n             // thread-local static.\n@@ -576,10 +576,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             let allocation = tcx.eval_static_initializer(def_id)?;\n             // Create a fresh allocation with this content.\n-            let new_alloc_id =\n-                this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into()).alloc_id;\n-            this.machine.threads.set_thread_local_alloc_id(def_id, new_alloc_id);\n-            Ok(new_alloc_id)\n+            let new_alloc =\n+                this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into());\n+            this.machine.threads.set_thread_local_alloc(def_id, new_alloc);\n+            Ok(new_alloc)\n         }\n     }\n \n@@ -761,10 +761,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        for alloc_id in this.machine.threads.thread_terminated(this.memory.extra.data_race.as_mut())\n-        {\n-            let ptr = this.memory.global_base_pointer(alloc_id.into())?;\n-            this.memory.deallocate(ptr, None, MiriMemoryKind::Tls.into())?;\n+        for ptr in this.machine.threads.thread_terminated(this.memory.extra.data_race.as_mut()) {\n+            this.memory.deallocate(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n         }\n         Ok(())\n     }"}, {"sha": "b7fcf4559e0ad4f2dbde972808c6166cae789dfb", "filename": "tests/compile-fail/dangling_pointers/deref-partially-dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fderef-partially-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fderef-partially-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fderef-partially-dangling.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     let x = (1, 13);\n     let xptr = &x as *const _ as *const (i32, i32, i32);\n-    let val = unsafe { (*xptr).1 }; //~ ERROR pointer must be in-bounds at offset 12, but is outside bounds of alloc\n+    let val = unsafe { (*xptr).1 }; //~ ERROR pointer to 12 bytes starting at offset 0 is out-of-bounds\n     assert_eq!(val, 13);\n }"}, {"sha": "56de3970f1bb23b2206143a4c09b472492ecacdd", "filename": "tests/compile-fail/dangling_pointers/dyn_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fdyn_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fdyn_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fdyn_size.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     // That should be UB, as the reference is not fully dereferencable.\n     let ptr: *const SliceWithHead = unsafe { std::mem::transmute((&buf, 4usize)) };\n     // Re-borrow that. This should be UB.\n-    let _ptr = unsafe { &*ptr }; //~ ERROR pointer must be in-bounds at offset 5\n+    let _ptr = unsafe { &*ptr }; //~ ERROR pointer to 5 bytes starting at offset 0 is out-of-bounds\n }"}, {"sha": "357eadf91c7f085af2bbde8ee52ed6c084bed878", "filename": "tests/compile-fail/dangling_pointers/maybe_null_pointer_deref_zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_deref_zst.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -4,5 +4,5 @@\n fn main() {\n     // This pointer *could* be NULL so we cannot load from it, not even at ZST\n     let ptr = (&0u8 as *const u8).wrapping_sub(0x800) as *const ();\n-    let _x: () = unsafe { *ptr }; //~ ERROR outside bounds\n+    let _x: () = unsafe { *ptr }; //~ ERROR out-of-bounds\n }"}, {"sha": "7f50b9827d94b5fd224915b14ec32067670ac069", "filename": "tests/compile-fail/dangling_pointers/maybe_null_pointer_write_zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fmaybe_null_pointer_write_zst.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     // Also not assigning directly as that's array initialization, not assignment.\n     let zst_val = [1u8; 0];\n     let ptr = (&0u8 as *const u8).wrapping_sub(0x800) as *mut [u8; 0];\n-    unsafe { *ptr = zst_val; } //~ ERROR outside bounds\n+    unsafe { *ptr = zst_val; } //~ ERROR out-of-bounds\n }"}, {"sha": "ef5cdeec99677c022c084810498fec8aecb0e900", "filename": "tests/compile-fail/dangling_pointers/out_of_bounds_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read1.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR outside bounds of alloc\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR out-of-bounds\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "ef5cdeec99677c022c084810498fec8aecb0e900", "filename": "tests/compile-fail/dangling_pointers/out_of_bounds_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointers%2Fout_of_bounds_read2.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR outside bounds of alloc\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR out-of-bounds\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "d200b3eb0297f6797d2970324d54e8ade44b6e82", "filename": "tests/compile-fail/intrinsics/out_of_bounds_ptr_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_1.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: must be in-bounds at offset 5, but is outside bounds of alloc\n+// error-pattern: pointer to 5 bytes starting at offset 0 is out-of-bounds\n fn main() {\n     let v = [0i8; 4];\n     let x = &v as *const i8;"}, {"sha": "52b385b8e3b48cecd4092c9fbeb408e2168f9756", "filename": "tests/compile-fail/intrinsics/out_of_bounds_ptr_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fout_of_bounds_ptr_2.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -2,6 +2,6 @@\n fn main() {\n     let v = [0i8; 4];\n     let x = &v as *const i8;\n-    let x = unsafe { x.offset(-1) };\n+    let x = unsafe { x.offset(isize::MIN) };\n     panic!(\"this should never print: {:?}\", x);\n }"}, {"sha": "8760345409c8e9dfa1d1bf6ef6e1c556fa298fc7", "filename": "tests/compile-fail/intrinsics/ptr_offset_ptr_plus_0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fptr_offset_ptr_plus_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fintrinsics%2Fptr_offset_ptr_plus_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fptr_offset_ptr_plus_0.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: outside bounds of alloc\n+// error-pattern: pointer at offset 32 is out-of-bounds\n \n fn main() {\n     let x = Box::into_raw(Box::new(0u32));"}, {"sha": "04617c58f3cefd9b71c4a362eb9cea4f5f5f3d44", "filename": "tests/compile-fail/null_pointer_deref_zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fnull_pointer_deref_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fnull_pointer_deref_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref_zst.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -3,6 +3,6 @@\n \n #[allow(deref_nullptr)]\n fn main() {\n-    let x: () = unsafe { *std::ptr::null() }; //~ ERROR memory access failed: 0x0 is not a valid pointer\n+    let x: () = unsafe { *std::ptr::null() }; //~ ERROR dereferencing pointer failed: 0x0 is not a valid pointer\n     panic!(\"this should never print: {:?}\", x);\n }"}, {"sha": "46a8345b1b45a37090fda1644e553b772a0ebd06", "filename": "tests/compile-fail/null_pointer_write_zst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fnull_pointer_write_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fnull_pointer_write_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_write_zst.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,10 +1,11 @@\n // Some optimizations remove ZST accesses, thus masking this UB.\n // compile-flags: -Zmir-opt-level=0\n+// error-pattern: memory access failed: 0x0 is not a valid pointer\n \n #[allow(deref_nullptr)]\n fn main() {\n     // Not using the () type here, as writes of that type do not even have MIR generated.\n     // Also not assigning directly as that's array initialization, not assignment.\n     let zst_val = [1u8; 0];\n-    unsafe { *std::ptr::null_mut() = zst_val }; //~ ERROR memory access failed: 0x0 is not a valid pointer\n+    unsafe { std::ptr::null_mut::<[u8; 0]>().write(zst_val) };\n }"}, {"sha": "852eb69968ed77f3ed2cd8e93fef296f70da9322", "filename": "tests/compile-fail/stacked_borrows/issue-miri-1050-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fstacked_borrows%2Fissue-miri-1050-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fstacked_borrows%2Fissue-miri-1050-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fissue-miri-1050-1.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: pointer must be in-bounds\n+// error-pattern: pointer to 4 bytes starting at offset 0 is out-of-bounds\n \n fn main() { unsafe {\n     let ptr = Box::into_raw(Box::new(0u16));"}, {"sha": "417a03bb0335b55e1eceb9ce3a56ed5b7ded8c52", "filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -3,6 +3,6 @@ static X: usize = 5;\n #[allow(mutable_transmutes)]\n fn main() {\n     let _x = unsafe {\n-        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR writing to alloc0 which is read-only\n+        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR writing to alloc1 which is read-only\n     };\n }"}, {"sha": "d400fba5d0c2477b1241c692c8b097fae5257f4e", "filename": "tests/compile-fail/zst1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fzst1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fzst1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst1.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     // make sure ZST locals cannot be accessed\n     let x = &() as *const () as *const i8;\n-    let _val = unsafe { *x }; //~ ERROR pointer must be in-bounds\n+    let _val = unsafe { *x }; //~ ERROR out-of-bounds\n }"}, {"sha": "7ecb8c7dca9d5931215b7b320c375c1c1591bbf1", "filename": "tests/compile-fail/zst3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1233a721d0832071a2c1b1a95895cc0b924b553/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=a1233a721d0832071a2c1b1a95895cc0b924b553", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     unsafe { *(x as *mut [u8; 0]) = zst_val; }\n     // One byte further is OOB.\n     let x = x.wrapping_offset(1);\n-    unsafe { *(x as *mut [u8; 0]) = zst_val; } //~ ERROR pointer must be in-bounds\n+    unsafe { *(x as *mut [u8; 0]) = zst_val; } //~ ERROR out-of-bounds\n }"}]}