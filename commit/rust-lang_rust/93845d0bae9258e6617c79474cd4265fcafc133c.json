{"sha": "93845d0bae9258e6617c79474cd4265fcafc133c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzODQ1ZDBiYWU5MjU4ZTY2MTdjNzk0NzRjZDQyNjVmY2FmYzEzM2M=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-27T21:40:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-28T20:26:19Z"}, "message": "Fix nested patterns in rustboot\n\nThe code for taking pattern-bound variables was being interspersed\nwith pattern code, so that if a nested pattern failed partway through,\na variable would be taken but never dropped (because the drop code\nis inside the block representing the action for the pattern). For\nexample, in the pattern foo(?i, bar(some[t](_)), _), if the scrutinee\nwas foo(x, bar(none[t]), y), the variable i would be taken but never\ndropped. The patch fixes this bug.", "tree": {"sha": "1e8fa4f15c4d69bb44d693b657aaac2305f88c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e8fa4f15c4d69bb44d693b657aaac2305f88c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93845d0bae9258e6617c79474cd4265fcafc133c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93845d0bae9258e6617c79474cd4265fcafc133c", "html_url": "https://github.com/rust-lang/rust/commit/93845d0bae9258e6617c79474cd4265fcafc133c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93845d0bae9258e6617c79474cd4265fcafc133c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25694582d994add42972b068209aa0b29fe8dcf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/25694582d994add42972b068209aa0b29fe8dcf1", "html_url": "https://github.com/rust-lang/rust/commit/25694582d994add42972b068209aa0b29fe8dcf1"}], "stats": {"total": 50, "additions": 34, "deletions": 16}, "files": [{"sha": "d34d19d8dc63d65be0e1c51a9b6a959aaa43fbec", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/93845d0bae9258e6617c79474cd4265fcafc133c/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/93845d0bae9258e6617c79474cd4265fcafc133c/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=93845d0bae9258e6617c79474cd4265fcafc133c", "patch": "@@ -4793,18 +4793,28 @@ let trans_visitor\n     let trans_arm arm : quad_idx =\n       let (pat, block) = arm.node in\n \n-      (* Translates the pattern and returns the addresses of the branch\n-       * instructions that are taken if the match fails.\n+      (* Translates the pattern and returns a pair where the first\n+          component is a list of the addresses of the branch\n+          instructions that are taken if the match fails,\n+          and the second component is a thunk that, when invoked,\n+          emits initialization code for the variables bound in this pattern.\n+\n+          trans_pat can't just emit the initialization code itself, because\n+          then, pattern-bound variables could be taken without ever being \n+          dropped if a nested pattern fails partway through (because the \n+          drop code is part of the action for the pattern).\n        *)\n       let rec trans_pat\n           (pat:Ast.pat)\n           (src_cell:Il.cell)\n           (src_ty:Ast.ty)\n-          : quad_idx list =\n+          : (quad_idx list *\n+             (unit -> unit)) =\n \n         match pat with\n             Ast.PAT_lit lit ->\n-              trans_compare_simple Il.JNE (trans_lit lit) (Il.Cell src_cell)\n+              (trans_compare_simple Il.JNE (trans_lit lit) (Il.Cell src_cell),\n+               fun _ -> ())\n \n           | Ast.PAT_tag (lval, pats) ->\n               let tag_ident =\n@@ -4815,7 +4825,7 @@ let trans_visitor\n                   | Ast.LVAL_base { node = Ast.BASE_app (id, _); id = _ } ->\n                       id\n                   | _ -> bug cx \"expected lval ending in ident\"\n-              in\n+              in \n               let ttag =\n                 match strip_mutable_or_constrained_ty src_ty with\n                     Ast.TY_tag ttag -> ttag\n@@ -4843,7 +4853,8 @@ let trans_visitor\n \n               let tup_cell:Il.cell = get_variant_ptr union_cell i in\n \n-              let trans_elem_pat i elem_pat : quad_idx list =\n+              let trans_elem_pat i elem_pat :\n+                    (quad_idx list * (unit -> unit)) =\n                 let elem_cell =\n                   get_element_ptr_dyn_in_current_frame tup_cell i\n                 in\n@@ -4852,24 +4863,31 @@ let trans_visitor\n               in\n \n               let elem_jumps =\n-                List.concat (Array.to_list (Array.mapi trans_elem_pat pats))\n+                (Array.to_list (Array.mapi trans_elem_pat pats)) in\n+              let (elem_jump_addrs, ks) = List.split elem_jumps\n               in\n-                next_jumps @ elem_jumps\n+                (next_jumps @ (List.concat elem_jump_addrs),\n+                 (* Compose all the var-initialization thunks together\n+                    to make one thunk that initializes all the vars *)\n+                 List.fold_left (fun g f -> (fun x -> f (g x)))\n+                   (fun _ -> ()) ks)\n \n           | Ast.PAT_slot (dst, _) ->\n               let dst_slot = get_slot cx dst.id in\n               let dst_cell = cell_of_block_slot dst.id in\n-                trans_init_slot_from_cell\n-                  (get_ty_params_of_current_frame())\n-                  CLONE_none dst_cell dst_slot\n-                  src_cell src_ty;\n-                []                 (* irrefutable *)\n-\n-          | Ast.PAT_wild -> []     (* irrefutable *)\n+              (* irrefutable *)\n+                ([], (fun () -> (* init the slot later, inside the block,\n+                                   once we know we had a match *)\n+                                  trans_init_slot_from_cell \n+                                  (get_ty_params_of_current_frame())\n+                                  CLONE_none dst_cell dst_slot\n+                                  src_cell src_ty))\n+          | Ast.PAT_wild -> ([], fun _ -> ())     (* irrefutable *)\n       in\n \n       let (lval_cell, lval_ty) = trans_lval at.Ast.alt_tag_lval in\n-      let next_jumps = trans_pat pat lval_cell lval_ty in\n+      let (next_jumps, prologue) = trans_pat pat lval_cell lval_ty in\n+        prologue (); (* binds any pattern-bound variables *)\n         trans_block block;\n         let last_jump = mark() in\n           emit (Il.jmp Il.JMP Il.CodeNone);"}]}