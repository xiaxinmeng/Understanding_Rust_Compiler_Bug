{"sha": "b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "node_id": "C_kwDOAAsO6NoAKGIyODA3YjJiZjNiZTlmYmVkOWEwYWFkYzk3ODQxYzIwYTFhYjVmNzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-07T14:32:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-07T14:32:11Z"}, "message": "Auto merge of #112383 - Dylan-DPC:rollup-et2z6nt, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #112076 (Fall back to bidirectional normalizes-to if no subst-relate candidate in alias-relate goal)\n - #112122 (Add `-Ztrait-solver=next-coherence`)\n - #112251 (rustdoc: convert `if let Some()` that always matches to variable)\n - #112345 (fix(expand): prevent infinity loop in macro containing only \"///\")\n - #112359 (Respect `RUST_BACKTRACE` for delayed bugs)\n - #112382 (download-rustc: Fix `x test core` on MacOS)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f8861cada9423965104c8fb57a7dbfdf1cd68a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8861cada9423965104c8fb57a7dbfdf1cd68a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "html_url": "https://github.com/rust-lang/rust/commit/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94bda3bf13303671427363d1cd93ac5e089f090", "url": "https://api.github.com/repos/rust-lang/rust/commits/e94bda3bf13303671427363d1cd93ac5e089f090", "html_url": "https://github.com/rust-lang/rust/commit/e94bda3bf13303671427363d1cd93ac5e089f090"}, {"sha": "90c361c8376e8ec9d63cbd78b6d68c9647eb32c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/90c361c8376e8ec9d63cbd78b6d68c9647eb32c1", "html_url": "https://github.com/rust-lang/rust/commit/90c361c8376e8ec9d63cbd78b6d68c9647eb32c1"}], "stats": {"total": 903, "additions": 671, "deletions": 232}, "files": [{"sha": "a561496b02639ae3d2d529bd768fbbacf2271e06", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let infcx = self\n             .tcx\n             .infer_ctxt()\n-            .with_opaque_type_inference(if self.tcx.trait_solver_next() {\n+            .with_opaque_type_inference(if self.next_trait_solver() {\n                 DefiningAnchor::Bind(def_id)\n             } else {\n                 DefiningAnchor::Bubble"}, {"sha": "00fd3762fa773d19dbdf11607aaa1c2fb6082123", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -188,7 +188,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n+    if infcx.next_trait_solver() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n "}, {"sha": "7a297ea0d5f8285c18a54395ade361965c9a4bd7", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -383,7 +383,7 @@ pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n pub use diagnostic_impls::{\n     DiagnosticArgFromDisplay, DiagnosticSymbolList, LabelKind, SingleLabelManySpans,\n };\n-use std::backtrace::Backtrace;\n+use std::backtrace::{Backtrace, BacktraceStatus};\n \n /// A handler deals with errors and other compiler output.\n /// Certain errors (fatal, bug, unimpl) may cause immediate exit,\n@@ -1331,7 +1331,7 @@ impl HandlerInner {\n             // once *any* errors were emitted (and truncate `delayed_span_bugs`\n             // when an error is first emitted, also), but maybe there's a case\n             // in which that's not sound? otherwise this is really inefficient.\n-            let backtrace = std::backtrace::Backtrace::force_capture();\n+            let backtrace = std::backtrace::Backtrace::capture();\n             self.delayed_span_bugs\n                 .push(DelayedDiagnostic::with_backtrace(diagnostic.clone(), backtrace));\n \n@@ -1620,7 +1620,7 @@ impl HandlerInner {\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&mut diagnostic);\n         }\n-        let backtrace = std::backtrace::Backtrace::force_capture();\n+        let backtrace = std::backtrace::Backtrace::capture();\n         self.delayed_good_path_bugs.push(DelayedDiagnostic::with_backtrace(diagnostic, backtrace));\n     }\n \n@@ -1739,7 +1739,17 @@ impl DelayedDiagnostic {\n     }\n \n     fn decorate(mut self) -> Diagnostic {\n-        self.inner.note(format!(\"delayed at {}\\n{}\", self.inner.emitted_at, self.note));\n+        match self.note.status() {\n+            BacktraceStatus::Captured => {\n+                self.inner.note(format!(\"delayed at {}\\n{}\", self.inner.emitted_at, self.note));\n+            }\n+            // Avoid the needless newline when no backtrace has been captured,\n+            // the display impl should just be a single line.\n+            _ => {\n+                self.inner.note(format!(\"delayed at {} - {}\", self.inner.emitted_at, self.note));\n+            }\n+        }\n+\n         self.inner\n     }\n }"}, {"sha": "f0e67cfd50e0818199127fc6c688860bc1214a4b", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -249,6 +249,7 @@ pub(super) fn compute_locs(matcher: &[TokenTree]) -> Vec<MatcherLoc> {\n }\n \n /// A single matcher position, representing the state of matching.\n+#[derive(Debug)]\n struct MatcherPos {\n     /// The index into `TtParser::locs`, which represents the \"dot\".\n     idx: usize,"}, {"sha": "ee9616a0f0a9df94b36dc5d18b23e2657be39c10", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -628,6 +628,40 @@ fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree)\n     // after parsing/expansion. we can report every error in every macro this way.\n }\n \n+fn is_empty_token_tree(sess: &ParseSess, seq: &mbe::SequenceRepetition) -> bool {\n+    if seq.separator.is_some() {\n+        false\n+    } else {\n+        let mut is_empty = true;\n+        let mut iter = seq.tts.iter().peekable();\n+        while let Some(tt) = iter.next() {\n+            match tt {\n+                mbe::TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => {}\n+                mbe::TokenTree::Token(t @ Token { kind: DocComment(..), .. }) => {\n+                    let mut now = t;\n+                    while let Some(&mbe::TokenTree::Token(\n+                        next @ Token { kind: DocComment(..), .. },\n+                    )) = iter.peek()\n+                    {\n+                        now = next;\n+                        iter.next();\n+                    }\n+                    let span = t.span.to(now.span);\n+                    sess.span_diagnostic.span_note_without_error(\n+                        span,\n+                        \"doc comments are ignored in matcher position\",\n+                    );\n+                }\n+                mbe::TokenTree::Sequence(_, sub_seq)\n+                    if (sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n+                        || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne) => {}\n+                _ => is_empty = false,\n+            }\n+        }\n+        is_empty\n+    }\n+}\n+\n /// Checks that the lhs contains no repetition which could match an empty token\n /// tree, because then the matcher would hang indefinitely.\n fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n@@ -644,16 +678,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n                 }\n             }\n             TokenTree::Sequence(span, seq) => {\n-                if seq.separator.is_none()\n-                    && seq.tts.iter().all(|seq_tt| match seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n-                        TokenTree::Sequence(_, sub_seq) => {\n-                            sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n-                                || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n-                        }\n-                        _ => false,\n-                    })\n-                {\n+                if is_empty_token_tree(sess, seq) {\n                     let sp = span.entire();\n                     sess.span_diagnostic.span_err(sp, \"repetition matches empty token tree\");\n                     return false;"}, {"sha": "6eb18aecd653f93d4bbff7c6efa4cfa5e867cb91", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n             // NOTE: we may still need to normalize the built-in deref in case\n             // we have some type like `&<Ty as Trait>::Assoc`, since users of\n             // autoderef expect this type to have been structurally normalized.\n-            if self.infcx.tcx.trait_solver_next()\n+            if self.infcx.next_trait_solver()\n                 && let ty::Alias(ty::Projection, _) = ty.kind()\n             {\n                 let (normalized_ty, obligations) = self.structurally_normalize(ty)?;\n@@ -161,8 +161,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n     ) -> Option<(Ty<'tcx>, Vec<traits::PredicateObligation<'tcx>>)> {\n-        let tcx = self.infcx.tcx;\n-        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n+        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.infcx);\n \n         let cause = traits::ObligationCause::misc(self.span, self.body_id);\n         let normalized_ty = match self"}, {"sha": "17be5fe66cf629e24b20eabb7431901df437af9f", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -1549,7 +1549,7 @@ pub(super) fn check_generator_obligations(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         .with_opaque_type_inference(DefiningAnchor::Bind(def_id))\n         .build();\n \n-    let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+    let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(&infcx);\n     for (predicate, cause) in generator_interior_predicates {\n         let obligation = Obligation::new(tcx, cause.clone(), param_env, *predicate);\n         fulfillment_cx.register_predicate_obligation(&infcx, obligation);"}, {"sha": "81231e8fe068ba5a825c7dddca67eb66d3ba3d8a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -156,7 +156,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // In the new solver, lazy norm may allow us to shallowly equate\n             // more types, but we emit possibly impossible-to-satisfy obligations.\n             // Filter these cases out to make sure our coercion is more accurate.\n-            if self.tcx.trait_solver_next() {\n+            if self.next_trait_solver() {\n                 if let Ok(res) = &res {\n                     for obligation in &res.obligations {\n                         if !self.predicate_may_hold(&obligation) {"}, {"sha": "fb56b7e74cb549bb365d4938ba71d0fedd9f68da", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -1476,7 +1476,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let mut ty = self.resolve_vars_with_obligations(ty);\n \n-        if self.tcx.trait_solver_next()\n+        if self.next_trait_solver()\n             && let ty::Alias(ty::Projection, _) = ty.kind()\n         {\n             match self"}, {"sha": "aa4f90b4ad8a063df2c826ba856cb9888dc7c190", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -86,8 +86,8 @@ impl<'tcx> Inherited<'tcx> {\n \n         Inherited {\n             typeck_results,\n+            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(&infcx)),\n             infcx,\n-            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(tcx)),\n             locals: RefCell::new(Default::default()),\n             deferred_sized_obligations: RefCell::new(Vec::new()),\n             deferred_call_resolutions: RefCell::new(Default::default()),"}, {"sha": "6a3a46c778a7a0d4e5a061312907c3191a9dbc8c", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -591,7 +591,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n-                assert!(!self.tcx().trait_solver_next());\n+                assert!(!self.fcx.next_trait_solver());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash(\n@@ -812,7 +812,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Resolver<'cx, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.fcx.fully_resolve(t) {\n-            Ok(t) if self.fcx.tcx.trait_solver_next() => {\n+            Ok(t) if self.fcx.next_trait_solver() => {\n                 // We must normalize erasing regions here, since later lints\n                 // expect that types that show up in the typeck are fully\n                 // normalized."}, {"sha": "1f0bf4f9887c3bacddab7c32e5e7403e9470dc02", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -82,6 +82,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n+            next_trait_solver: self.next_trait_solver,\n         }\n     }\n }"}, {"sha": "7a80ee98cb3c1ff9cd566a9a899b83c95c46e09d", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -109,11 +109,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             | (\n                 ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n                 ty::Alias(AliasKind::Projection, _),\n-            ) if self.tcx.trait_solver_next() => {\n+            ) if self.next_trait_solver() => {\n                 bug!()\n             }\n \n-            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.tcx.trait_solver_next() => {\n+            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.next_trait_solver() => {\n                 relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }\n@@ -227,9 +227,20 @@ impl<'tcx> InferCtxt<'tcx> {\n                 return self.unify_const_variable(vid, a, relation.param_env());\n             }\n             (ty::ConstKind::Unevaluated(..), _) | (_, ty::ConstKind::Unevaluated(..))\n-                if self.tcx.features().generic_const_exprs || self.tcx.trait_solver_next() =>\n+                if self.tcx.features().generic_const_exprs || self.next_trait_solver() =>\n             {\n-                relation.register_const_equate_obligation(a, b);\n+                let (a, b) = if relation.a_is_expected() { (a, b) } else { (b, a) };\n+\n+                relation.register_predicates([ty::Binder::dummy(if self.next_trait_solver() {\n+                    ty::PredicateKind::AliasRelate(\n+                        a.into(),\n+                        b.into(),\n+                        ty::AliasRelationDirection::Equate,\n+                    )\n+                } else {\n+                    ty::PredicateKind::ConstEquate(a, b)\n+                })]);\n+\n                 return Ok(b);\n             }\n             _ => {}\n@@ -453,19 +464,6 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     /// be used if control over the obligation causes is required.\n     fn register_predicates(&mut self, obligations: impl IntoIterator<Item: ToPredicate<'tcx>>);\n \n-    /// Register an obligation that both constants must be equal to each other.\n-    ///\n-    /// If they aren't equal then the relation doesn't hold.\n-    fn register_const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-\n-        self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n-            ty::PredicateKind::AliasRelate(a.into(), b.into(), ty::AliasRelationDirection::Equate)\n-        } else {\n-            ty::PredicateKind::ConstEquate(a, b)\n-        })]);\n-    }\n-\n     /// Register an obligation that both types must be related to each other according to\n     /// the [`ty::AliasRelationDirection`] given by [`ObligationEmittingRelation::alias_relate_direction`]\n     fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {"}, {"sha": "495c250a77d073dd476166f1d5416cc7be20183e", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n                     && def_id.is_local()\n-                    && !self.tcx().trait_solver_next() =>\n+                    && !self.fields.infcx.next_trait_solver() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "9ef35429fe32c2719878e046ea01d20876b1f743", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -113,7 +113,7 @@ where\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n             if this.define_opaque_types() == DefineOpaqueTypes::Yes\n                 && def_id.is_local()\n-                && !this.tcx().trait_solver_next() =>\n+                && !this.infcx().next_trait_solver() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "9526ed144c349d871b8cf6141bfe37064fc73a1e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -330,6 +330,8 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n+\n+    next_trait_solver: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -545,6 +547,9 @@ pub struct InferCtxtBuilder<'tcx> {\n     skip_leak_check: bool,\n     /// Whether we are in coherence mode.\n     intercrate: bool,\n+    /// Whether we should use the new trait solver in the local inference context,\n+    /// which affects things like which solver is used in `predicate_may_hold`.\n+    next_trait_solver: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -559,6 +564,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             considering_regions: true,\n             skip_leak_check: false,\n             intercrate: false,\n+            next_trait_solver: self.next_trait_solver_globally(),\n         }\n     }\n }\n@@ -575,6 +581,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn with_next_trait_solver(mut self, next_trait_solver: bool) -> Self {\n+        self.next_trait_solver = next_trait_solver;\n+        self\n+    }\n+\n     pub fn intercrate(mut self, intercrate: bool) -> Self {\n         self.intercrate = intercrate;\n         self\n@@ -617,6 +628,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             considering_regions,\n             skip_leak_check,\n             intercrate,\n+            next_trait_solver,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -634,6 +646,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             in_snapshot: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n+            next_trait_solver,\n         }\n     }\n }\n@@ -670,6 +683,10 @@ pub struct CombinedSnapshot<'tcx> {\n }\n \n impl<'tcx> InferCtxt<'tcx> {\n+    pub fn next_trait_solver(&self) -> bool {\n+        self.next_trait_solver\n+    }\n+\n     /// Creates a `TypeErrCtxt` for emitting various inference errors.\n     /// During typeck, use `FnCtxt::err_ctxt` instead.\n     pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "71c07f31bc952a6a868ac7810b08054323296e2e", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -491,12 +491,12 @@ where\n             (\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n-            ) if a_def_id == b_def_id || infcx.tcx.trait_solver_next() => {\n+            ) if a_def_id == b_def_id || infcx.next_trait_solver() => {\n                 infcx.super_combine_tys(self, a, b).or_else(|err| {\n                     // This behavior is only there for the old solver, the new solver\n                     // shouldn't ever fail. Instead, it unconditionally emits an\n                     // alias-relate goal.\n-                    assert!(!self.tcx().trait_solver_next());\n+                    assert!(!self.infcx.next_trait_solver());\n                     self.tcx().sess.delay_span_bug(\n                         self.delegate.span(),\n                         \"failure to relate an opaque to itself should result in an error later on\",\n@@ -506,7 +506,7 @@ where\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if def_id.is_local() && !self.tcx().trait_solver_next() =>\n+                if def_id.is_local() && !self.infcx.next_trait_solver() =>\n             {\n                 self.relate_opaques(a, b)\n             }"}, {"sha": "a9ead429f4c71898540e221b6e0946191a1501bc", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n         // We handle opaque types differently in the new solver.\n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             return InferOk { value, obligations: vec![] };\n         }\n \n@@ -578,7 +578,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n-        assert!(self.tcx.trait_solver_next());\n+        assert!(self.next_trait_solver());\n         let origin = self\n             .opaque_type_origin(opaque_type_key.def_id)\n             .expect(\"should be called for defining usages only\");\n@@ -614,7 +614,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id)\n-                            && !tcx.trait_solver_next() =>\n+                            && !self.next_trait_solver() =>\n                     {\n                         self.infer_projection(\n                             param_env,"}, {"sha": "4f8c9188cf85b8440eb6328f604df88af2d0b8fa", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             // FIXME(-Ztrait-solver=next): Instead of branching here,\n             // completely change the normalization routine with the new solver.\n             //"}, {"sha": "d9f9d2aabdbf7524a3cbf69c5b839bb2ba9f2b18", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n                     && def_id.is_local()\n-                    && !self.tcx().trait_solver_next() =>\n+                    && !self.fields.infcx.next_trait_solver() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "4ee543bbfb6dce09b943f5a739cb768f6ed7c9d2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -2333,10 +2333,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.opt_local_def_id_to_hir_id(local_def_id).unwrap()\n     }\n \n-    pub fn trait_solver_next(self) -> bool {\n+    pub fn next_trait_solver_globally(self) -> bool {\n         self.sess.opts.unstable_opts.trait_solver == rustc_session::config::TraitSolver::Next\n     }\n \n+    pub fn next_trait_solver_in_coherence(self) -> bool {\n+        matches!(\n+            self.sess.opts.unstable_opts.trait_solver,\n+            rustc_session::config::TraitSolver::Next\n+                | rustc_session::config::TraitSolver::NextCoherence\n+        )\n+    }\n+\n     pub fn lower_impl_trait_in_trait_to_assoc_ty(self) -> bool {\n         self.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty\n     }"}, {"sha": "24291301a3293a68903279c162e69dedd98dc6a3", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -610,6 +610,8 @@ pub enum TraitSolver {\n     Chalk,\n     /// Experimental trait solver in `rustc_trait_selection::solve`\n     Next,\n+    /// Use the new trait solver during coherence\n+    NextCoherence,\n }\n \n pub enum Input {"}, {"sha": "201066e3950172e5c2bccf6c9e568e8479ac3562", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -986,6 +986,7 @@ mod parse {\n             Some(\"classic\") => *slot = TraitSolver::Classic,\n             Some(\"chalk\") => *slot = TraitSolver::Chalk,\n             Some(\"next\") => *slot = TraitSolver::Next,\n+            Some(\"next-coherence\") => *slot = TraitSolver::NextCoherence,\n             // default trait solver is subject to change..\n             Some(\"default\") => *slot = TraitSolver::Classic,\n             _ => return false,"}, {"sha": "66a4d36a1e5a7b0628c4e429025ce8c5b84bf594", "filename": "compiler/rustc_trait_selection/src/solve/alias_relate.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,195 @@\n+use super::{EvalCtxt, SolverMode};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::ty;\n+\n+/// We may need to invert the alias relation direction if dealing an alias on the RHS.\n+#[derive(Debug)]\n+enum Invert {\n+    No,\n+    Yes,\n+}\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn compute_alias_relate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let Goal { param_env, predicate: (lhs, rhs, direction) } = goal;\n+        if lhs.is_infer() || rhs.is_infer() {\n+            bug!(\n+                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n+            );\n+        }\n+\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n+            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n+\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_lhs,\n+                rhs,\n+                direction,\n+                Invert::No,\n+            ),\n+\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_rhs,\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            ),\n+\n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"both sides are aliases\");\n+\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_lhs,\n+                    rhs,\n+                    direction,\n+                    Invert::No,\n+                ));\n+                // RHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_rhs,\n+                    lhs,\n+                    direction,\n+                    Invert::Yes,\n+                ));\n+                // Relate via substs\n+                let subst_relate_response = self\n+                    .assemble_subst_relate_candidate(param_env, alias_lhs, alias_rhs, direction);\n+                candidates.extend(subst_relate_response);\n+                debug!(?candidates);\n+\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    // When relating two aliases and we have ambiguity, we prefer\n+                    // relating the generic arguments of the aliases over normalizing\n+                    // them. This is necessary for inference during typeck.\n+                    //\n+                    // As this is incomplete, we must not do so during coherence.\n+                    match self.solver_mode() {\n+                        SolverMode::Normal => {\n+                            if let Ok(subst_relate_response) = subst_relate_response {\n+                                Ok(subst_relate_response)\n+                            } else if let Ok(bidirectional_normalizes_to_response) = self\n+                                .assemble_bidirectional_normalizes_to_candidate(\n+                                    param_env, lhs, rhs, direction,\n+                                )\n+                            {\n+                                Ok(bidirectional_normalizes_to_response)\n+                            } else {\n+                                self.flounder(&candidates)\n+                            }\n+                        }\n+                        SolverMode::Coherence => self.flounder(&candidates),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn assemble_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            ecx.normalizes_to_inner(param_env, alias, other, direction, invert)?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    fn normalizes_to_inner(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> Result<(), NoSolution> {\n+        let other = match direction {\n+            // This is purely an optimization.\n+            ty::AliasRelationDirection::Equate => other,\n+\n+            ty::AliasRelationDirection::Subtype => {\n+                let fresh = self.next_term_infer_of_kind(other);\n+                let (sub, sup) = match invert {\n+                    Invert::No => (fresh, other),\n+                    Invert::Yes => (other, fresh),\n+                };\n+                self.sub(param_env, sub, sup)?;\n+                fresh\n+            }\n+        };\n+        self.add_goal(Goal::new(\n+            self.tcx(),\n+            param_env,\n+            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty: alias, term: other }),\n+        ));\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_subst_relate_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias_lhs: ty::AliasTy<'tcx>,\n+        alias_rhs: ty::AliasTy<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            match direction {\n+                ty::AliasRelationDirection::Equate => {\n+                    ecx.eq(param_env, alias_lhs, alias_rhs)?;\n+                }\n+                ty::AliasRelationDirection::Subtype => {\n+                    ecx.sub(param_env, alias_lhs, alias_rhs)?;\n+                }\n+            }\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    fn assemble_bidirectional_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: ty::Term<'tcx>,\n+        rhs: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                lhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                rhs,\n+                direction,\n+                Invert::No,\n+            )?;\n+            ecx.normalizes_to_inner(\n+                param_env,\n+                rhs.to_alias_ty(ecx.tcx()).unwrap(),\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            )?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+}"}, {"sha": "3001d9f1b1f3f2dd1959abad143bec07519ac2b2", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -187,6 +187,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let (ref infcx, input, var_values) = tcx\n                 .infer_ctxt()\n                 .intercrate(intercrate)\n+                .with_next_trait_solver(true)\n                 .with_opaque_type_inference(canonical_input.value.anchor)\n                 .build_with_canonical(DUMMY_SP, &canonical_input);\n "}, {"sha": "f4c29c837b8841a5ec71ef21079dfc350f94d3a1", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 136, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n+mod alias_relate;\n mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n@@ -154,142 +155,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_alias_relate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n-    ) -> QueryResult<'tcx> {\n-        let tcx = self.tcx();\n-        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n-        #[derive(Debug)]\n-        enum Invert {\n-            No,\n-            Yes,\n-        }\n-        let evaluate_normalizes_to =\n-            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n-                let span = tracing::span!(\n-                    tracing::Level::DEBUG,\n-                    \"compute_alias_relate_goal(evaluate_normalizes_to)\",\n-                    ?alias,\n-                    ?other,\n-                    ?direction,\n-                    ?invert\n-                );\n-                let _enter = span.enter();\n-                let result = ecx.probe(|ecx| {\n-                    let other = match direction {\n-                        // This is purely an optimization.\n-                        ty::AliasRelationDirection::Equate => other,\n-\n-                        ty::AliasRelationDirection::Subtype => {\n-                            let fresh = ecx.next_term_infer_of_kind(other);\n-                            let (sub, sup) = match invert {\n-                                Invert::No => (fresh, other),\n-                                Invert::Yes => (other, fresh),\n-                            };\n-                            ecx.sub(goal.param_env, sub, sup)?;\n-                            fresh\n-                        }\n-                    };\n-                    ecx.add_goal(goal.with(\n-                        tcx,\n-                        ty::Binder::dummy(ty::ProjectionPredicate {\n-                            projection_ty: alias,\n-                            term: other,\n-                        }),\n-                    ));\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                debug!(?result);\n-                result\n-            };\n-\n-        let (lhs, rhs, direction) = goal.predicate;\n-\n-        if lhs.is_infer() || rhs.is_infer() {\n-            bug!(\n-                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n-            );\n-        }\n-\n-        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n-            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n-\n-            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n-            (Some(alias_lhs), None) => {\n-                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n-            }\n-\n-            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n-            (None, Some(alias_rhs)) => {\n-                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n-            }\n-\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"both sides are aliases\");\n-\n-                let mut candidates = Vec::new();\n-                // LHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_lhs,\n-                    rhs,\n-                    direction,\n-                    Invert::No,\n-                ));\n-                // RHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_rhs,\n-                    lhs,\n-                    direction,\n-                    Invert::Yes,\n-                ));\n-                // Relate via substs\n-                let subst_relate_response = self.probe(|ecx| {\n-                    let span = tracing::span!(\n-                        tracing::Level::DEBUG,\n-                        \"compute_alias_relate_goal(relate_via_substs)\",\n-                        ?alias_lhs,\n-                        ?alias_rhs,\n-                        ?direction\n-                    );\n-                    let _enter = span.enter();\n-\n-                    match direction {\n-                        ty::AliasRelationDirection::Equate => {\n-                            ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                        ty::AliasRelationDirection::Subtype => {\n-                            ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                    }\n-\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                candidates.extend(subst_relate_response);\n-                debug!(?candidates);\n-\n-                if let Some(merged) = self.try_merge_responses(&candidates) {\n-                    Ok(merged)\n-                } else {\n-                    // When relating two aliases and we have ambiguity, we prefer\n-                    // relating the generic arguments of the aliases over normalizing\n-                    // them. This is necessary for inference during typeck.\n-                    //\n-                    // As this is incomplete, we must not do so during coherence.\n-                    match (self.solver_mode(), subst_relate_response) {\n-                        (SolverMode::Normal, Ok(response)) => Ok(response),\n-                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n-                            self.flounder(&candidates)\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_const_arg_has_type_goal(\n         &mut self,"}, {"sha": "2c793ea33dc8877cda61c5b5c2f0a6b298f153bd", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -182,6 +182,7 @@ fn overlap<'tcx>(\n         .with_opaque_type_inference(DefiningAnchor::Bubble)\n         .skip_leak_check(skip_leak_check.is_yes())\n         .intercrate(true)\n+        .with_next_trait_solver(tcx.next_trait_solver_in_coherence())\n         .build();\n     let selcx = &mut SelectionContext::new(&infcx);\n     if track_ambiguity_causes.is_yes() {"}, {"sha": "90699c3cadcf523f0e1888c1c132d0aa932f8c8f", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -27,24 +27,42 @@ use rustc_session::config::TraitSolver;\n use rustc_span::Span;\n \n pub trait TraitEngineExt<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n-    fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self>;\n+    fn new(infcx: &InferCtxt<'tcx>) -> Box<Self>;\n+    fn new_in_snapshot(infcx: &InferCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        match tcx.sess.opts.unstable_opts.trait_solver {\n-            TraitSolver::Classic => Box::new(FulfillmentContext::new()),\n-            TraitSolver::Chalk => Box::new(ChalkFulfillmentContext::new()),\n-            TraitSolver::Next => Box::new(NextFulfillmentCtxt::new()),\n+    fn new(infcx: &InferCtxt<'tcx>) -> Box<Self> {\n+        match (infcx.tcx.sess.opts.unstable_opts.trait_solver, infcx.next_trait_solver()) {\n+            (TraitSolver::Classic, false) | (TraitSolver::NextCoherence, false) => {\n+                Box::new(FulfillmentContext::new())\n+            }\n+            (TraitSolver::Next | TraitSolver::NextCoherence, true) => {\n+                Box::new(NextFulfillmentCtxt::new())\n+            }\n+            (TraitSolver::Chalk, false) => Box::new(ChalkFulfillmentContext::new()),\n+            _ => bug!(\n+                \"incompatible combination of -Ztrait-solver flag ({:?}) and InferCtxt::next_trait_solver ({:?})\",\n+                infcx.tcx.sess.opts.unstable_opts.trait_solver,\n+                infcx.next_trait_solver()\n+            ),\n         }\n     }\n \n-    fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        match tcx.sess.opts.unstable_opts.trait_solver {\n-            TraitSolver::Classic => Box::new(FulfillmentContext::new_in_snapshot()),\n-            TraitSolver::Chalk => Box::new(ChalkFulfillmentContext::new_in_snapshot()),\n-            TraitSolver::Next => Box::new(NextFulfillmentCtxt::new()),\n+    fn new_in_snapshot(infcx: &InferCtxt<'tcx>) -> Box<Self> {\n+        match (infcx.tcx.sess.opts.unstable_opts.trait_solver, infcx.next_trait_solver()) {\n+            (TraitSolver::Classic, false) | (TraitSolver::NextCoherence, false) => {\n+                Box::new(FulfillmentContext::new_in_snapshot())\n+            }\n+            (TraitSolver::Next | TraitSolver::NextCoherence, true) => {\n+                Box::new(NextFulfillmentCtxt::new())\n+            }\n+            (TraitSolver::Chalk, false) => Box::new(ChalkFulfillmentContext::new_in_snapshot()),\n+            _ => bug!(\n+                \"incompatible combination of -Ztrait-solver flag ({:?}) and InferCtxt::next_trait_solver ({:?})\",\n+                infcx.tcx.sess.opts.unstable_opts.trait_solver,\n+                infcx.next_trait_solver()\n+            ),\n         }\n     }\n }\n@@ -58,11 +76,11 @@ pub struct ObligationCtxt<'a, 'tcx> {\n \n impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx.tcx)) }\n+        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new(infcx)) }\n     }\n \n     pub fn new_in_snapshot(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new_in_snapshot(infcx.tcx)) }\n+        Self { infcx, engine: RefCell::new(<dyn TraitEngine<'_>>::new_in_snapshot(infcx)) }\n     }\n \n     pub fn register_obligation(&self, obligation: PredicateObligation<'tcx>) {"}, {"sha": "c4481b39e14be6cea8670e13ad66d12ca20ebe45", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -1047,7 +1047,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // (which may fail).\n                                 span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                             }\n-                            TraitSolver::Chalk | TraitSolver::Next => {\n+                            TraitSolver::Chalk | TraitSolver::Next | TraitSolver::NextCoherence => {\n                                 // FIXME: we'll need a better message which takes into account\n                                 // which bounds actually failed to hold.\n                                 self.tcx.sess.struct_span_err("}, {"sha": "f8ceee50054434034adea9688b9c7b0f1f8e0fd0", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             _ => obligation.param_env.without_const(),\n         };\n \n-        if self.tcx.trait_solver_next() {\n+        if self.next_trait_solver() {\n             self.probe(|snapshot| {\n                 let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n                 fulfill_cx.register_predicate_obligation(self, obligation.clone());"}, {"sha": "9d7933e23a8b2de2ccd1a47fdc0897fd5584a15c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -146,7 +146,7 @@ where\n         infcx: &InferCtxt<'tcx>,\n         span: Span,\n     ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n-        if infcx.tcx.trait_solver_next() {\n+        if infcx.next_trait_solver() {\n             return Ok(scrape_region_constraints(\n                 infcx,\n                 |ocx| QueryTypeOp::perform_locally_in_new_solver(ocx, self),"}, {"sha": "25e5b5e17deff675a9f9f880ea13b0c5af7f5b85", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -539,7 +539,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluation_probe(|this| {\n             let goal =\n                 this.infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n-            let mut result = if this.tcx().trait_solver_next() {\n+            let mut result = if this.infcx.next_trait_solver() {\n                 this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])?\n             } else {\n                 this.evaluate_predicate_recursively(\n@@ -593,7 +593,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n-        if self.tcx().trait_solver_next() {\n+        if self.infcx.next_trait_solver() {\n             self.evaluate_predicates_recursively_in_new_solver(predicates)\n         } else {\n             let mut result = EvaluatedToOk;"}, {"sha": "84746eba3ecf838d351c8856082ad80281193429", "filename": "compiler/rustc_trait_selection/src/traits/structural_normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> StructurallyNormalizeExt<'tcx> for At<'_, 'tcx> {\n     ) -> Result<Ty<'tcx>, Vec<FulfillmentError<'tcx>>> {\n         assert!(!ty.is_ty_var(), \"should have resolved vars before calling\");\n \n-        if self.infcx.tcx.trait_solver_next() {\n+        if self.infcx.next_trait_solver() {\n             while let ty::Alias(ty::Projection, projection_ty) = *ty.kind() {\n                 let new_infer_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::NormalizeProjectionType,"}, {"sha": "5f84acc8a0473d6db52aaef93f1120518add46a6", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -55,7 +55,7 @@ pub fn codegen_select_candidate<'tcx>(\n     // Currently, we use a fulfillment context to completely resolve\n     // all nested obligations. This is because they can inform the\n     // inference of the impl's type parameters.\n-    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n+    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(&infcx);\n     let impl_source = selection.map(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });"}, {"sha": "73756caf37272d3a7185b132d044c0e712f969c3", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -16,7 +16,7 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n-    assert!(!tcx.trait_solver_next());\n+    assert!(!tcx.next_trait_solver_globally());\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs"}, {"sha": "a9e15d8924605b88939a3cbeffda675ed144e8b8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -1358,7 +1358,12 @@ impl Step for Sysroot {\n             // newly compiled std, not the downloaded std.\n             add_filtered_files(\"lib\", builder.config.ci_rust_std_contents());\n \n-            let filtered_extensions = [OsStr::new(\"rmeta\"), OsStr::new(\"rlib\"), OsStr::new(\"so\")];\n+            let filtered_extensions = [\n+                OsStr::new(\"rmeta\"),\n+                OsStr::new(\"rlib\"),\n+                // FIXME: this is wrong when compiler.host != build, but we don't support that today\n+                OsStr::new(std::env::consts::DLL_EXTENSION),\n+            ];\n             let ci_rustc_dir = builder.ci_rustc_dir(builder.config.build);\n             builder.cp_filtered(&ci_rustc_dir, &sysroot, &|path| {\n                 if path.extension().map_or(true, |ext| !filtered_extensions.contains(&ext)) {"}, {"sha": "22c8cc092438cdb264f5900f35b995dfc0131ff5", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -14,7 +14,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::{iter, mem};\n+use std::mem;\n \n use crate::clean::{cfg::Cfg, reexport_chain, AttributesExt, NestedAttributesExt};\n use crate::core;\n@@ -291,27 +291,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         if !please_inline {\n             let inherits_hidden = inherits_doc_hidden(tcx, res_did, None);\n             // Only inline if requested or if the item would otherwise be stripped.\n-            //\n-            // If it's a doc hidden module, we need to keep it in case some of its inner items\n-            // are re-exported.\n             if (!is_private && !inherits_hidden) || (\n                 is_hidden &&\n+                // If it's a doc hidden module, we need to keep it in case some of its inner items\n+                // are re-exported.\n                 !matches!(item, Node::Item(&hir::Item { kind: hir::ItemKind::Mod(_), .. }))\n-            ) {\n-                return false;\n-            } else if let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n-                .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n-                .chain(iter::once(res_did)).nth(1) &&\n-                item_def_id != def_id &&\n-                self\n-                    .cx\n-                    .cache\n-                    .effective_visibilities\n-                    .is_directly_public(tcx, item_def_id.to_def_id()) &&\n-                !tcx.is_doc_hidden(item_def_id) &&\n-                !inherits_doc_hidden(tcx, item_def_id, None)\n-            {\n+            ) ||\n                 // The imported item is public and not `doc(hidden)` so no need to inline it.\n+                self.reexport_public_and_not_hidden(def_id, res_did)\n+            {\n                 return false;\n             }\n         }\n@@ -359,6 +347,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n+    /// Returns `true` if the item is visible, meaning it's not `#[doc(hidden)]` or private.\n+    ///\n+    /// This function takes into account the entire re-export `use` chain, so it needs the\n+    /// ID of the \"leaf\" `use` and the ID of the \"root\" item.\n+    fn reexport_public_and_not_hidden(\n+        &self,\n+        import_def_id: LocalDefId,\n+        target_def_id: LocalDefId,\n+    ) -> bool {\n+        let tcx = self.cx.tcx;\n+        let item_def_id = reexport_chain(tcx, import_def_id, target_def_id)\n+            .iter()\n+            .flat_map(|reexport| reexport.id())\n+            .map(|id| id.expect_local())\n+            .nth(1)\n+            .unwrap_or(target_def_id);\n+        item_def_id != import_def_id\n+            && self.cx.cache.effective_visibilities.is_directly_public(tcx, item_def_id.to_def_id())\n+            && !tcx.is_doc_hidden(item_def_id)\n+            && !inherits_doc_hidden(tcx, item_def_id, None)\n+    }\n+\n     #[inline]\n     fn add_to_current_mod(\n         &mut self,"}, {"sha": "96fe720630ccd890e9db2071ac2c01d62829f6db", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -108,6 +108,7 @@ string_enum! {\n         Polonius => \"polonius\",\n         Chalk => \"chalk\",\n         NextSolver => \"next-solver\",\n+        NextSolverCoherence => \"next-solver-coherence\",\n         SplitDwarf => \"split-dwarf\",\n         SplitDwarfSingle => \"split-dwarf-single\",\n     }"}, {"sha": "6582b534488a8c3c99be3613398a3cdeef63629a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -2127,6 +2127,9 @@ impl<'test> TestCx<'test> {\n             Some(CompareMode::NextSolver) => {\n                 rustc.args(&[\"-Ztrait-solver=next\"]);\n             }\n+            Some(CompareMode::NextSolverCoherence) => {\n+                rustc.args(&[\"-Ztrait-solver=next-coherence\"]);\n+            }\n             Some(CompareMode::SplitDwarf) if self.config.target.contains(\"windows\") => {\n                 rustc.args(&[\"-Csplit-debuginfo=unpacked\", \"-Zunstable-options\"]);\n             }"}, {"sha": "bd2abe7f697f4f8d66e56cff3681b75ab73f6d55", "filename": "tests/ui/macros/issue-112342-1.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-112342-1.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,49 @@\n+// same as #95267, ignore doc comment although it's a bug.\n+\n+macro_rules! m1 {\n+    (\n+        $(\n+            ///\n+        )*\n+        //~^^^ERROR repetition matches empty token tree\n+    ) => {};\n+}\n+\n+m1! {}\n+\n+macro_rules! m2 {\n+    (\n+        $(\n+            ///\n+        )+\n+        //~^^^ERROR repetition matches empty token tree\n+    ) => {};\n+}\n+\n+m2! {}\n+\n+macro_rules! m3 {\n+    (\n+        $(\n+            ///\n+        )?\n+        //~^^^ERROR repetition matches empty token tree\n+    ) => {};\n+}\n+\n+m3! {}\n+\n+\n+macro_rules! m4 {\n+    (\n+        $(\n+            ///\n+            ///\n+        )*\n+        //~^^^^ERROR repetition matches empty token tree\n+    ) => {};\n+}\n+\n+m4! {}\n+\n+fn main() {}"}, {"sha": "f2d82bf599e99fdff6eacc658290356e4b310586", "filename": "tests/ui/macros/issue-112342-1.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-112342-1.stderr?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,64 @@\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-1.rs:6:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+error: repetition matches empty token tree\n+  --> $DIR/issue-112342-1.rs:5:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |             ///\n+LL | |         )*\n+   | |_________^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-1.rs:17:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+error: repetition matches empty token tree\n+  --> $DIR/issue-112342-1.rs:16:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |             ///\n+LL | |         )+\n+   | |_________^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-1.rs:28:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+error: repetition matches empty token tree\n+  --> $DIR/issue-112342-1.rs:27:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |             ///\n+LL | |         )?\n+   | |_________^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-1.rs:40:13\n+   |\n+LL | /             ///\n+LL | |             ///\n+   | |_______________^\n+\n+error: repetition matches empty token tree\n+  --> $DIR/issue-112342-1.rs:39:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |             ///\n+LL | |             ///\n+LL | |         )*\n+   | |_________^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e797aff94d2f3e69e7a613ca4c8a2dcc91b9e2e9", "filename": "tests/ui/macros/issue-112342-2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-112342-2.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+// same as #95267, ignore doc comment although it's a bug.\n+\n+macro_rules! m1 {\n+    (\n+        $(\n+            ///\n+            $expr: expr,\n+        )*\n+    ) => {};\n+}\n+\n+m1! {}\n+\n+macro_rules! m2 {\n+    (\n+        $(\n+            ///\n+            $expr: expr,\n+            ///\n+        )*\n+    ) => {};\n+}\n+\n+m2! {}\n+\n+macro_rules! m3 {\n+    (\n+        $(\n+            ///\n+            $tt: tt,\n+        )*\n+    ) => {};\n+}\n+\n+m3! {}\n+\n+fn main() {}"}, {"sha": "8c1b6f9471bcea6b61415b08660fb9cbcb7a1ae7", "filename": "tests/ui/macros/issue-112342-2.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fmacros%2Fissue-112342-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fissue-112342-2.stderr?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,24 @@\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-2.rs:8:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-2.rs:19:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-2.rs:21:13\n+   |\n+LL |             ///\n+   |             ^^^\n+\n+note: doc comments are ignored in matcher position\n+  --> $DIR/issue-112342-2.rs:31:13\n+   |\n+LL |             ///\n+   |             ^^^\n+"}, {"sha": "578db0cc65e8928b8d46e4b2b4f78f99f138972c", "filename": "tests/ui/specialization/specialization-default-items-drop-coherence.coherence.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.coherence.stderr?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Overlap` for type `u32`\n+  --> $DIR/specialization-default-items-drop-coherence.rs:29:1\n+   |\n+LL | impl Overlap for u32 {\n+   | -------------------- first implementation here\n+...\n+LL | impl Overlap for <u32 as Default>::Id {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "578db0cc65e8928b8d46e4b2b4f78f99f138972c", "filename": "tests/ui/specialization/specialization-default-items-drop-coherence.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.next.stderr?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Overlap` for type `u32`\n+  --> $DIR/specialization-default-items-drop-coherence.rs:29:1\n+   |\n+LL | impl Overlap for u32 {\n+   | -------------------- first implementation here\n+...\n+LL | impl Overlap for <u32 as Default>::Id {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "44c598f19cb9bc3c27f4d5b159252c69caef7a5b", "filename": "tests/ui/specialization/specialization-default-items-drop-coherence.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -1,5 +1,8 @@\n-// check-pass\n-// known-bug: #105782\n+// revisions: classic coherence next\n+//[next] compile-flags: -Ztrait-solver=next\n+//[coherence] compile-flags: -Ztrait-solver=next-coherence\n+//[classic] check-pass\n+//[classic] known-bug: #105782\n \n // Should fail. Default items completely drop candidates instead of ambiguity,\n // which is unsound during coherence, since coherence requires completeness.\n@@ -24,6 +27,8 @@ impl Overlap for u32 {\n }\n \n impl Overlap for <u32 as Default>::Id {\n+   //[coherence]~^ ERROR conflicting implementations of trait `Overlap` for type `u32`\n+   //[next]~^^ ERROR conflicting implementations of trait `Overlap` for type `u32`\n    type Assoc = Box<usize>;\n }\n "}, {"sha": "99a3d02bd1aeae101b641c99bc084e0e4b8cabec", "filename": "tests/ui/traits/new-solver/tait-eq-proj-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj-2.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+// Similar to tests/ui/traits/new-solver/tait-eq-proj.rs\n+// but check the alias-sub relation in the other direction.\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn a() {\n+    let x: Tait = mk();\n+    let mut array = mk();\n+    let mut z = IntoIterator::into_iter(array);\n+    z = x;\n+    array = [0i32; 32];\n+}\n+\n+fn main() {}"}, {"sha": "01141b2819a8d5af026f6f248ecc627a9f6a3a6f", "filename": "tests/ui/traits/new-solver/tait-eq-proj.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-proj.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Iterator<Item = impl Sized>;\n+\n+/*\n+\n+Consider the goal - AliasRelate(Tait, <[i32; 32] as IntoIterator>::IntoIter)\n+which is registered on the line above.\n+\n+A. SubstRelate - fails (of course).\n+\n+B. NormalizesToRhs - Tait normalizes-to <[i32; 32] as IntoIterator>::IntoIter\n+    * infer definition - Tait := <[i32; 32] as IntoIterator>::IntoIter\n+\n+C. NormalizesToLhs - <[i32; 32] as IntoIterator>::IntoIter normalizes-to Tait\n+    * Find impl candidate, after substitute - std::array::IntoIter<i32, 32>\n+    * Equate std::array::IntoIter<i32, 32> and Tait\n+        * infer definition - Tait := std::array::IntoIter<i32, 32>\n+\n+B and C are not equal, but they are equivalent modulo normalization.\n+\n+We get around this by evaluating both the NormalizesToRhs and NormalizesToLhs\n+goals together. Essentially:\n+    A alias-relate B if A normalizes-to B and B normalizes-to A.\n+\n+*/\n+\n+fn a() {\n+    let _: Tait = IntoIterator::into_iter([0i32; 32]);\n+}\n+\n+fn main() {}"}, {"sha": "532c4c39bd499f79e75f766523126522d65345fd", "filename": "tests/ui/traits/new-solver/tait-eq-tait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftait-eq-tait.rs?ref=b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Not exactly sure if this is the inference behavior we *want*,\n+// but it is a side-effect of the lazy normalization of TAITs.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Sized;\n+type Tait2 = impl Sized;\n+\n+fn mk<T>() -> T { todo!() }\n+\n+fn main() {\n+    let x: Tait = 1u32;\n+    let y: Tait2 = x;\n+}"}]}