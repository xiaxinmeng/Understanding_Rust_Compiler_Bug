{"sha": "8e73ea52537fe5189fac5cd02380592563fe7f0c", "node_id": "C_kwDOAAsO6NoAKDhlNzNlYTUyNTM3ZmU1MTg5ZmFjNWNkMDIzODA1OTI1NjNmZTdmMGM", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-19T09:32:51Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-19T09:32:51Z"}, "message": "Desugar try blocks", "tree": {"sha": "5af7e8ad90ef80c1803b91a2b69b2f4764d50228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af7e8ad90ef80c1803b91a2b69b2f4764d50228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e73ea52537fe5189fac5cd02380592563fe7f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e73ea52537fe5189fac5cd02380592563fe7f0c", "html_url": "https://github.com/rust-lang/rust/commit/8e73ea52537fe5189fac5cd02380592563fe7f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e73ea52537fe5189fac5cd02380592563fe7f0c/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "453ae2e00e2f3bcd96a2fa78626296e14641dae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/453ae2e00e2f3bcd96a2fa78626296e14641dae8", "html_url": "https://github.com/rust-lang/rust/commit/453ae2e00e2f3bcd96a2fa78626296e14641dae8"}], "stats": {"total": 299, "additions": 215, "deletions": 84}, "files": [{"sha": "a93fcb3b1dc29cbfe88d92da2483d34bb0398622", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -19,7 +19,7 @@ use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName, LiteralKind,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n@@ -100,6 +100,7 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n+        current_try_block: None,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n     }\n@@ -113,6 +114,7 @@ struct ExprCollector<'a> {\n     body: Body,\n     krate: CrateId,\n     source_map: BodySourceMap,\n+    current_try_block: Option<LabelId>,\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n }\n@@ -222,6 +224,10 @@ impl ExprCollector<'_> {\n         self.source_map.label_map.insert(src, id);\n         id\n     }\n+    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n+        self.body.labels.alloc(label)\n+    }\n     fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n         let id = self.body.labels.alloc(label);\n         self.source_map.label_map_back.insert(id, src);\n@@ -259,13 +265,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n-                Some(ast::BlockModifier::Try(_)) => {\n-                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n-                        id,\n-                        statements,\n-                        tail,\n-                    })\n-                }\n+                Some(ast::BlockModifier::Try(_)) => self.collect_try_block(e),\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n                     self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n                         id,\n@@ -606,6 +606,59 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n+    /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n+    /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n+    fn collect_try_block(&mut self, e: BlockExpr) -> ExprId {\n+        let Some(try_from_output) = LangItem::TryTraitFromOutput.path(self.db, self.krate) else {\n+            return self.alloc_expr_desugared(Expr::Missing);\n+        };\n+        let prev_try_block = self.current_try_block.take();\n+        self.current_try_block =\n+            Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n+        let expr_id = self.collect_block(e);\n+        let callee = self.alloc_expr_desugared(Expr::Path(try_from_output));\n+        let Expr::Block { label, tail, .. } = &mut self.body.exprs[expr_id] else {\n+            unreachable!(\"It is the output of collect block\");\n+        };\n+        *label = self.current_try_block;\n+        let next_tail = match *tail {\n+            Some(tail) => self.alloc_expr_desugared(Expr::Call {\n+                callee,\n+                args: Box::new([tail]),\n+                is_assignee_expr: false,\n+            }),\n+            None => {\n+                let unit = self.alloc_expr_desugared(Expr::Tuple {\n+                    exprs: Box::new([]),\n+                    is_assignee_expr: false,\n+                });\n+                self.alloc_expr_desugared(Expr::Call {\n+                    callee,\n+                    args: Box::new([unit]),\n+                    is_assignee_expr: false,\n+                })\n+            }\n+        };\n+        let Expr::Block { tail, .. } = &mut self.body.exprs[expr_id] else {\n+            unreachable!(\"It is the output of collect block\");\n+        };\n+        *tail = Some(next_tail);\n+        self.current_try_block = prev_try_block;\n+        expr_id\n+    }\n+\n+    /// Desugar `ast::TryExpr` from: `<expr>?` into:\n+    /// ```ignore (pseudo-rust)\n+    /// match Try::branch(<expr>) {\n+    ///     ControlFlow::Continue(val) => val,\n+    ///     ControlFlow::Break(residual) =>\n+    ///         // If there is an enclosing `try {...}`:\n+    ///         break 'catch_target Try::from_residual(residual),\n+    ///         // Otherwise:\n+    ///         return Try::from_residual(residual),\n+    /// }\n+    /// ```\n     fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {\n         let (try_branch, cf_continue, cf_break, try_from_residual) = 'if_chain: {\n             if let Some(try_branch) = LangItem::TryTraitBranch.path(self.db, self.krate) {\n@@ -628,7 +681,9 @@ impl ExprCollector<'_> {\n             Expr::Call { callee: try_branch, args: Box::new([operand]), is_assignee_expr: false },\n             syntax_ptr.clone(),\n         );\n-        let continue_binding = self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n+        let continue_name = Name::generate_new_name();\n+        let continue_binding =\n+            self.alloc_binding(continue_name.clone(), BindingAnnotation::Unannotated);\n         let continue_bpat =\n             self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });\n         self.add_definition_to_binding(continue_binding, continue_bpat);\n@@ -639,9 +694,10 @@ impl ExprCollector<'_> {\n                 ellipsis: None,\n             }),\n             guard: None,\n-            expr: self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone()),\n+            expr: self.alloc_expr(Expr::Path(Path::from(continue_name)), syntax_ptr.clone()),\n         };\n-        let break_binding = self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n+        let break_name = Name::generate_new_name();\n+        let break_binding = self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated);\n         let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n         self.add_definition_to_binding(break_binding, break_bpat);\n         let break_arm = MatchArm {\n@@ -652,13 +708,18 @@ impl ExprCollector<'_> {\n             }),\n             guard: None,\n             expr: {\n-                let x = self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone());\n+                let x = self.alloc_expr(Expr::Path(Path::from(break_name)), syntax_ptr.clone());\n                 let callee = self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n                 let result = self.alloc_expr(\n                     Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n                     syntax_ptr.clone(),\n                 );\n-                self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n+                if let Some(label) = self.current_try_block {\n+                    let label = Some(self.body.labels[label].name.clone());\n+                    self.alloc_expr(Expr::Break { expr: Some(result), label }, syntax_ptr.clone())\n+                } else {\n+                    self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n+                }\n             },\n         };\n         let arms = Box::new([continue_arm, break_arm]);"}, {"sha": "8c9d77620e188a018360f1984e1c9c6e9f1ea6ec", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -420,9 +420,6 @@ impl<'a> Printer<'a> {\n             Expr::Unsafe { id: _, statements, tail } => {\n                 self.print_block(Some(\"unsafe \"), statements, tail);\n             }\n-            Expr::TryBlock { id: _, statements, tail } => {\n-                self.print_block(Some(\"try \"), statements, tail);\n-            }\n             Expr::Async { id: _, statements, tail } => {\n                 self.print_block(Some(\"async \"), statements, tail);\n             }"}, {"sha": "8ddb89a4725d5d8af68da94b6e6789494c55078f", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -202,8 +202,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         }\n         Expr::Unsafe { id, statements, tail }\n         | Expr::Async { id, statements, tail }\n-        | Expr::Const { id, statements, tail }\n-        | Expr::TryBlock { id, statements, tail } => {\n+        | Expr::Const { id, statements, tail } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, None);\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions)."}, {"sha": "7ede19cc3c2b48a34008113c7ac57d70aa59f1b8", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -122,11 +122,6 @@ pub enum Expr {\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n-    TryBlock {\n-        id: BlockId,\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Async {\n         id: BlockId,\n         statements: Box<[Statement]>,\n@@ -310,7 +305,6 @@ impl Expr {\n                 f(*expr);\n             }\n             Expr::Block { statements, tail, .. }\n-            | Expr::TryBlock { statements, tail, .. }\n             | Expr::Unsafe { statements, tail, .. }\n             | Expr::Async { statements, tail, .. }\n             | Expr::Const { statements, tail, .. } => {"}, {"sha": "8099c20b027c28e49b7b05a1b394af7dcf90d127", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -78,7 +78,7 @@ impl Name {\n         Self::new_text(lt.text().into())\n     }\n \n-    /// Shortcut to create inline plain text name\n+    /// Shortcut to create inline plain text name. Panics if `text.len() > 22`\n     const fn new_inline(text: &str) -> Name {\n         Name::new_text(SmolStr::new_inline(text))\n     }\n@@ -112,6 +112,18 @@ impl Name {\n         Name::new_inline(\"[missing name]\")\n     }\n \n+    /// Generates a new name which is only equal to itself, by incrementing a counter. Due\n+    /// its implementation, it should not be used in things that salsa considers, like\n+    /// type names or field names, and it should be only used in names of local variables\n+    /// and labels and similar things.\n+    pub fn generate_new_name() -> Name {\n+        use std::sync::atomic::{AtomicUsize, Ordering};\n+        static CNT: AtomicUsize = AtomicUsize::new(0);\n+        let c = CNT.fetch_add(1, Ordering::Relaxed);\n+        // FIXME: Currently a `__RA_generated_name` in user code will break our analysis\n+        Name::new_text(format!(\"__RA_geneated_name_{c}\").into())\n+    }\n+\n     /// Returns the tuple index this name represents if it is a tuple field.\n     pub fn as_tuple_index(&self) -> Option<usize> {\n         match self.0 {"}, {"sha": "2ba0cbd5db4f019fe4b53b6cd265153d3f5f747b", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -522,6 +522,42 @@ fn loops() {\n         \"#,\n         4,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        loop {\n+            x = x + 1;\n+            if x == 5 {\n+                break x + 2;\n+            }\n+        }\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        'a: loop {\n+            let x = 'b: loop {\n+                let x = 'c: loop {\n+                    let x = 'd: loop {\n+                        let x = 'e: loop {\n+                            break 'd 1;\n+                        };\n+                        break 2 + x;\n+                    };\n+                    break 3 + x;\n+                };\n+                break 'a 4 + x;\n+            };\n+            break 5 + x;\n+        }\n+    };\n+        \"#,\n+        8,\n+    );\n }\n \n #[test]\n@@ -1019,6 +1055,24 @@ fn try_operator() {\n     );\n }\n \n+#[test]\n+fn try_block() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        let r = try { x? * y? };\n+        match r {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number("}, {"sha": "38b7dee75fd5bfa09bf53a0a58be52a1782ec095", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -1025,10 +1025,6 @@ impl<'a> InferenceContext<'a> {\n         self.resolve_lang_item(lang)?.as_trait()\n     }\n \n-    fn resolve_ops_try_output(&self) -> Option<TypeAliasId> {\n-        self.resolve_output_on(self.resolve_lang_trait(LangItem::Try)?)\n-    }\n-\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         self.resolve_output_on(self.resolve_lang_trait(LangItem::Neg)?)\n     }"}, {"sha": "6d2aa59ea3598bf25b6b7b16ff4c5dc0f0ca8e38", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -159,26 +159,6 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .1\n             }\n-            Expr::TryBlock { id: _, statements, tail } => {\n-                // The type that is returned from the try block\n-                let try_ty = self.table.new_type_var();\n-                if let Some(ty) = expected.only_has_type(&mut self.table) {\n-                    self.unify(&try_ty, &ty);\n-                }\n-\n-                // The ok-ish type that is expected from the last expression\n-                let ok_ty =\n-                    self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n-\n-                self.infer_block(\n-                    tgt_expr,\n-                    statements,\n-                    *tail,\n-                    None,\n-                    &Expectation::has_type(ok_ty.clone()),\n-                );\n-                try_ty\n-            }\n             Expr::Async { id: _, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);"}, {"sha": "7ed21d230c7f601c3ba7e0fa0bd6ffb485509e6c", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -44,7 +44,6 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Let { pat, expr } => self.infer_mut_expr(*expr, self.pat_bound_mutability(*pat)),\n             Expr::Block { id: _, statements, tail, label: _ }\n-            | Expr::TryBlock { id: _, statements, tail }\n             | Expr::Async { id: _, statements, tail }\n             | Expr::Const { id: _, statements, tail }\n             | Expr::Unsafe { id: _, statements, tail } => {"}, {"sha": "5d9ae320726ffc9695df9fc625b3c3a25ca7e631", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -18,6 +18,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n@@ -32,17 +33,21 @@ mod pattern_matching;\n \n use pattern_matching::AdtPatternShape;\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n     /// `None` for loops that are not terminating\n     end: Option<BasicBlockId>,\n+    place: Place,\n }\n \n struct MirLowerCtx<'a> {\n     result: MirBody,\n     owner: DefWithBodyId,\n     current_loop_blocks: Option<LoopBlocks>,\n+    // FIXME: we should resolve labels in HIR lowering and always work with label id here, not\n+    // with raw names.\n+    labeled_loop_blocks: FxHashMap<Name, LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n     body: &'a Body,\n@@ -72,6 +77,7 @@ pub enum MirLowerError {\n     ImplementationError(&'static str),\n     LangItemNotFound(LangItem),\n     MutatingRvalue,\n+    UnresolvedLabel,\n }\n \n macro_rules! not_supported {\n@@ -375,19 +381,29 @@ impl MirLowerCtx<'_> {\n                 Ok(self.merge_blocks(Some(then_target), else_target))\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n-                self.lower_block_to_place(None, statements, current, *tail, place)\n+                self.lower_block_to_place(statements, current, *tail, place)\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.lower_block_to_place(*label, statements, current, *tail, place)\n+                if let Some(label) = label {\n+                    self.lower_loop(current, place.clone(), Some(*label), |this, begin| {\n+                        if let Some(block) = this.lower_block_to_place(statements, begin, *tail, place)? {\n+                            let end = this.current_loop_end()?;\n+                            this.set_goto(block, end);\n+                        }\n+                        Ok(())\n+                    })\n+                } else {\n+                    self.lower_block_to_place(statements, current, *tail, place)\n+                }\n             }\n-            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n+            Expr::Loop { body, label } => self.lower_loop(current, place, *label, |this, begin| {\n                 if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n                     this.set_goto(block, begin);\n                 }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n-                self.lower_loop(current, *label, |this, begin| {\n+                self.lower_loop(current, place, *label, |this, begin| {\n                     let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n                         return Ok(());\n                     };\n@@ -438,7 +454,7 @@ impl MirLowerCtx<'_> {\n                     return Ok(None);\n                 };\n                 self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n-                self.lower_loop(current, label, |this, begin| {\n+                self.lower_loop(current, place, label, |this, begin| {\n                     let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n                     else {\n                         return Ok(());\n@@ -558,24 +574,28 @@ impl MirLowerCtx<'_> {\n                 Some(_) => not_supported!(\"continue with label\"),\n                 None => {\n                     let loop_data =\n-                        self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n+                        self.current_loop_blocks.as_ref().ok_or(MirLowerError::ContinueWithoutLoop)?;\n                     self.set_goto(current, loop_data.begin);\n                     Ok(None)\n                 }\n             },\n             Expr::Break { expr, label } => {\n-                if expr.is_some() {\n-                    not_supported!(\"break with value\");\n-                }\n-                match label {\n-                    Some(_) => not_supported!(\"break with label\"),\n-                    None => {\n-                        let end =\n-                            self.current_loop_end()?;\n-                        self.set_goto(current, end);\n-                        Ok(None)\n-                    }\n+                if let Some(expr) = expr {\n+                    let loop_data = match label {\n+                        Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n+                        None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::BreakWithoutLoop)?,\n+                    };\n+                    let Some(c) = self.lower_expr_to_place(*expr, loop_data.place.clone(), current)? else {\n+                        return Ok(None);\n+                    };\n+                    current = c;\n                 }\n+                let end = match label {\n+                    Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n+                    None => self.current_loop_end()?,\n+                };\n+                self.set_goto(current, end);\n+                Ok(None)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -668,7 +688,6 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::Await { .. } => not_supported!(\"await\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n-            Expr::TryBlock { .. } => not_supported!(\"try block\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),\n             Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n             Expr::Cast { expr, type_ref: _ } => {\n@@ -1085,19 +1104,34 @@ impl MirLowerCtx<'_> {\n     fn lower_loop(\n         &mut self,\n         prev_block: BasicBlockId,\n+        place: Place,\n         label: Option<LabelId>,\n         f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n     ) -> Result<Option<BasicBlockId>> {\n-        if label.is_some() {\n-            not_supported!(\"loop with label\");\n-        }\n         let begin = self.new_basic_block();\n-        let prev =\n-            mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end: None }));\n+        let prev = mem::replace(\n+            &mut self.current_loop_blocks,\n+            Some(LoopBlocks { begin, end: None, place }),\n+        );\n+        let prev_label = if let Some(label) = label {\n+            // We should generate the end now, to make sure that it wouldn't change later. It is\n+            // bad as we may emit end (unneccessary unreachable block) for unterminating loop, but\n+            // it should not affect correctness.\n+            self.current_loop_end()?;\n+            self.labeled_loop_blocks.insert(\n+                self.body.labels[label].name.clone(),\n+                self.current_loop_blocks.as_ref().unwrap().clone(),\n+            )\n+        } else {\n+            None\n+        };\n         self.set_goto(prev_block, begin);\n         f(self, begin)?;\n         let my = mem::replace(&mut self.current_loop_blocks, prev)\n             .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        if let Some(prev) = prev_label {\n+            self.labeled_loop_blocks.insert(self.body.labels[label.unwrap()].name.clone(), prev);\n+        }\n         Ok(my.end)\n     }\n \n@@ -1185,15 +1219,11 @@ impl MirLowerCtx<'_> {\n \n     fn lower_block_to_place(\n         &mut self,\n-        label: Option<LabelId>,\n         statements: &[hir_def::expr::Statement],\n         mut current: BasicBlockId,\n         tail: Option<ExprId>,\n         place: Place,\n     ) -> Result<Option<Idx<BasicBlock>>> {\n-        if label.is_some() {\n-            not_supported!(\"block with label\");\n-        }\n         for statement in statements.iter() {\n             match statement {\n                 hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n@@ -1355,6 +1385,7 @@ pub fn lower_to_mir(\n         body,\n         owner,\n         current_loop_blocks: None,\n+        labeled_loop_blocks: Default::default(),\n         discr_temp: None,\n     };\n     let mut current = start_block;"}, {"sha": "97ec1bb871d4b44067b64d305701e0e6fcbd2a65", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e73ea52537fe5189fac5cd02380592563fe7f0c/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8e73ea52537fe5189fac5cd02380592563fe7f0c", "patch": "@@ -206,19 +206,27 @@ fn test() {\n fn infer_try_trait() {\n     check_types(\n         r#\"\n-//- minicore: try, result\n+//- minicore: try, result, from\n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v;\n } //^ i32\n-\n-impl<O, E> core::ops::Try for Result<O, E> {\n-    type Output = O;\n-    type Error = Result<core::convert::Infallible, E>;\n+\"#,\n+    );\n }\n \n-impl<T, E, F: From<E>> core::ops::FromResidual<Result<core::convert::Infallible, E>> for Result<T, F> {}\n+#[test]\n+fn infer_try_block() {\n+    // FIXME: We should test more cases, but it currently doesn't work, since\n+    // our labeled block type inference is broken.\n+    check_types(\n+        r#\"\n+//- minicore: try, option\n+fn test() {\n+    let x: Option<_> = try { Some(2)?; };\n+      //^ Option<()>\n+}\n \"#,\n     );\n }"}]}