{"sha": "124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNGUxZTE4Y2M0ZjMyNzczMGE5NzhhN2E4YzFlNzg3NmJiNjNjNmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-11T09:35:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-13T01:25:21Z"}, "message": "Improve comments and address nits.", "tree": {"sha": "495a44143ae26cb847efa8bcbf414bfbc30c76f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495a44143ae26cb847efa8bcbf414bfbc30c76f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "html_url": "https://github.com/rust-lang/rust/commit/124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f43899db46f8211cf634ce9ce195662f3dfb97a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f43899db46f8211cf634ce9ce195662f3dfb97a", "html_url": "https://github.com/rust-lang/rust/commit/5f43899db46f8211cf634ce9ce195662f3dfb97a"}], "stats": {"total": 92, "additions": 54, "deletions": 38}, "files": [{"sha": "412c188f5f4ae04d8862bdc69b009c4880440aca", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "patch": "@@ -250,13 +250,15 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                 self.predicates.retain(|predicate| {\n                     // Hack: Retain does not pass in the index, but we want\n                     // to avoid processing the first `start_count` entries.\n-                    if skip == 0 {\n-                        retain_predicate(selcx, predicate,\n-                                         &mut selections, &mut errors, region_obligations)\n-                    } else {\n-                        skip -= 1;\n-                        true\n-                    }\n+                    let processed =\n+                        if skip == 0 {\n+                            process_predicate(selcx, predicate,\n+                                              &mut selections, &mut errors, region_obligations)\n+                        } else {\n+                            skip -= 1;\n+                            false\n+                        };\n+                    !processed\n                 });\n             }\n \n@@ -286,17 +288,17 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n-fn retain_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                             predicate: &PredicateObligation<'tcx>,\n-                             selections: &mut Vec<Selection<'tcx>>,\n-                             errors: &mut Vec<FulfillmentError<'tcx>>,\n-                             region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n-                             -> bool\n+fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                              predicate: &PredicateObligation<'tcx>,\n+                              selections: &mut Vec<Selection<'tcx>>,\n+                              errors: &mut Vec<FulfillmentError<'tcx>>,\n+                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                              -> bool\n {\n     /*!\n-     * Evaluates a predicate obligation and modifies the appropriate\n-     * output array.  Returns `true` if the predicate must be retained\n-     * because it could not be fully evaluated yet due to insufficient\n+     * Processes a predicate obligation and modifies the appropriate\n+     * output array with the successful/error result.  Returns `false`\n+     * if the predicate could not be processed due to insufficient\n      * type inference.\n      */\n \n@@ -308,11 +310,11 @@ fn retain_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                                 trait_ref: trait_ref.clone() };\n             match selcx.select(&trait_obligation) {\n                 Ok(None) => {\n-                    true\n+                    false\n                 }\n                 Ok(Some(s)) => {\n                     selections.push(s);\n-                    false\n+                    true\n                 }\n                 Err(selection_err) => {\n                     debug!(\"predicate: {} error: {}\",\n@@ -322,7 +324,7 @@ fn retain_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         FulfillmentError::new(\n                             predicate.clone(),\n                             CodeSelectionError(selection_err)));\n-                    false\n+                    true\n                 }\n             }\n         }\n@@ -331,27 +333,27 @@ fn retain_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             let origin = infer::EquatePredicate(predicate.cause.span);\n             match infer::mk_eqty(selcx.infcx(), false, origin, a, b) {\n                 Ok(()) => {\n-                    false\n+                    true\n                 }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n                             predicate.clone(),\n                             CodeSelectionError(Unimplemented)));\n-                    false\n+                    true\n                 }\n             }\n         }\n \n         ty::Predicate::RegionOutlives(r_a, r_b) => {\n             let origin = infer::RelateRegionParamBound(predicate.cause.span);\n             let () = infer::mk_subr(selcx.infcx(), origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            false\n+            true\n         }\n \n         ty::Predicate::TypeOutlives(t_a, r_b) => {\n             register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n-            false\n+            true\n         }\n     }\n }"}, {"sha": "604a0607c0b4ce4ef36949c7523fc4e0236f721f", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "patch": "@@ -61,7 +61,12 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::TraitRef<'tcx>>>;\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n-    // the id of XXX\n+    // The id of the fn body that triggered this obligation. This is\n+    // used for region obligations to determine the precise\n+    // environment in which the region obligation should be evaluated\n+    // (in particular, closures can add new assumptions). See the\n+    // field `region_obligations` of the `FulfillmentContext` for more\n+    // information.\n     pub body_id: ast::NodeId,\n \n     pub code: ObligationCauseCode<'tcx>"}, {"sha": "52154e0be7ad0c3a3382f241bd5c0b620a2d3171", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "patch": "@@ -24,8 +24,16 @@ use super::{Obligation, ObligationCause, PredicateObligation,\n             VtableImpl, VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n-// Elaboration iterator\n+// `Elaboration` iterator\n+///////////////////////////////////////////////////////////////////////////\n \n+/// \"Elaboration\" is the process of identifying all the predicates that\n+/// are implied by a source predicate. Currently this basically means\n+/// walking the \"supertraits\" and other similar assumptions. For\n+/// example, if we know that `T : Ord`, the elaborator would deduce\n+/// that `T : PartialOrd` holds as well. Similarly, if we have `trait\n+/// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n+/// 'static`.\n pub struct Elaborator<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n     stack: Vec<StackEntry<'tcx>>,\n@@ -157,7 +165,10 @@ impl<'cx, 'tcx> Iterator<ty::Predicate<'tcx>> for Elaborator<'cx, 'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n // Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n \n+/// A filter around the `Elaborator` that just yields up supertrait references,\n+/// not other kinds of predicates.\n pub struct Supertraits<'cx, 'tcx:'cx> {\n     elaborator: Elaborator<'cx, 'tcx>,\n }\n@@ -197,6 +208,8 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Other\n ///////////////////////////////////////////////////////////////////////////\n \n // determine the `self` type, using fresh variables for all variables"}, {"sha": "ddbf69685cd91523bfc651ab51fec79a4a3cc557", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "patch": "@@ -1656,14 +1656,16 @@ impl<'tcx> Generics<'tcx> {\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum Predicate<'tcx> {\n-    /// where Foo : Bar\n+    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// the `Self` type of the trait reference and `A`, `B`, and `C`\n+    /// would be the parameters in the `TypeSpace`.\n     Trait(Rc<TraitRef<'tcx>>),\n \n-    /// where Foo == Bar\n-    Equate(Ty<'tcx>, Ty<'tcx>),\n+    /// where `T1 == T2`.\n+    Equate(/* T1 */ Ty<'tcx>, /* T2 */ Ty<'tcx>),\n \n     /// where 'a : 'b\n-    RegionOutlives(Region, Region),\n+    RegionOutlives(/* 'a */ Region, /* 'b */ Region),\n \n     /// where T : 'a\n     TypeOutlives(Ty<'tcx>, Region),\n@@ -1807,7 +1809,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1842,7 +1843,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1869,7 +1869,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n-                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -1880,8 +1879,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, item.span,\n-                                                        &pty.generics, id)\n+                        construct_parameter_environment(cx, &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -5031,8 +5029,8 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given a reference to a trait, returns the bounds declared on the\n-/// trait, with appropriate substitutions applied.\n+/// Given a reference to a trait, returns the \"superbounds\" declared\n+/// on the trait, with appropriate substitutions applied.\n pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n                                       trait_ref: &TraitRef<'tcx>)\n                                       -> Vec<ty::Predicate<'tcx>>\n@@ -5929,7 +5927,6 @@ pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n /// See `ParameterEnvironment` struct def'n for details\n pub fn construct_parameter_environment<'tcx>(\n     tcx: &ctxt<'tcx>,\n-    _span: Span,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment<'tcx>"}, {"sha": "8c82429e1c226cc4282e06bbb1a5ca001f21a7d2", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124e1e18cc4f327730a978a7a8c1e7876bb63c6e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=124e1e18cc4f327730a978a7a8c1e7876bb63c6e", "patch": "@@ -91,7 +91,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n-                                                item.span,\n                                                 &polytype.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);"}]}