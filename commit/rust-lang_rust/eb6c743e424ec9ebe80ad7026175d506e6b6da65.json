{"sha": "eb6c743e424ec9ebe80ad7026175d506e6b6da65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNmM3NDNlNDI0ZWM5ZWJlODBhZDcwMjYxNzVkNTA2ZTZiNmRhNjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-29T02:43:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-29T02:43:05Z"}, "message": "avoid anonymous bool", "tree": {"sha": "3d622d8eb5d780ea23a174daceab9a1bf124012a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d622d8eb5d780ea23a174daceab9a1bf124012a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb6c743e424ec9ebe80ad7026175d506e6b6da65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb6c743e424ec9ebe80ad7026175d506e6b6da65", "html_url": "https://github.com/rust-lang/rust/commit/eb6c743e424ec9ebe80ad7026175d506e6b6da65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb6c743e424ec9ebe80ad7026175d506e6b6da65/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c8e834b99ca3d422828b44ed0b2d4a76335be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c8e834b99ca3d422828b44ed0b2d4a76335be6", "html_url": "https://github.com/rust-lang/rust/commit/14c8e834b99ca3d422828b44ed0b2d4a76335be6"}], "stats": {"total": 119, "additions": 62, "deletions": 57}, "files": [{"sha": "bbaaba08a14ddd4689bd283e8a7402aded1c7f50", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -142,6 +142,12 @@ impl Default for ResourceLimits {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct TyAndPacked<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub packed: bool,\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n         EvalContext {\n@@ -381,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    Value::ByRef(ptr, _aligned) =>\n+                    Value::ByRef { ptr, aligned: _aligned } =>\n                         // Alignment does not matter for this call\n                         self.memory.mark_static_initalized(ptr.to_ptr()?.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n@@ -439,7 +445,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr, _aligned)) = local {\n+        if let Some(Value::ByRef { ptr, aligned: _ }) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -609,7 +615,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let (offset, ty, _packed) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                                let (offset, TyAndPacked { ty, packed: _}) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n                                 // TODO: The packed flag is ignored\n \n                                 // FIXME(solson)\n@@ -745,7 +751,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByRef(..), _) |\n+                                (Value::ByRef{..}, _) |\n                                 (Value::ByValPair(..), true) => {\n                                     self.write_value(src, dest, dest_ty)?;\n                                 },\n@@ -826,7 +832,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         nndiscr: u64,\n         discrfield: &[u32],\n-    ) -> EvalResult<'tcx, (Size, Ty<'tcx>, bool)> {\n+    ) -> EvalResult<'tcx, (Size, TyAndPacked<'tcx>)> {\n         // Skip the constant 0 at the start meant for LLVM GEP and the outer non-null variant\n         let path = discrfield.iter().skip(2).map(|&i| i as usize);\n \n@@ -849,19 +855,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mut offset: Size,\n         mut ty: Ty<'tcx>,\n         path: I,\n-    ) -> EvalResult<'tcx, (Size, Ty<'tcx>, bool)> {\n+    ) -> EvalResult<'tcx, (Size, TyAndPacked<'tcx>)> {\n         // Skip the initial 0 intended for LLVM GEP.\n         let mut packed = false;\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n             trace!(\"field_path_offset_and_ty: {}, {}, {:?}, {:?}\", field_index, ty, field_offset, offset);\n             let field_ty = self.get_field_ty(ty, field_index)?;\n-            ty = field_ty.0;\n-            packed = packed || field_ty.1;\n+            ty = field_ty.ty;\n+            packed = packed || field_ty.packed;\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n \n-        Ok((offset, ty, packed))\n+        Ok((offset, TyAndPacked { ty, packed }))\n     }\n     fn get_fat_field(&self, pointee_ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n         match (field_index, &self.tcx.struct_tail(pointee_ty).sty) {\n@@ -874,18 +880,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// Returns the field type and whether the field is packed\n-    pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, (Ty<'tcx>, bool)> {\n+    pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, TyAndPacked<'tcx>> {\n         match ty.sty {\n             ty::TyAdt(adt_def, _) if adt_def.is_box() =>\n-                Ok((self.get_fat_field(ty.boxed_ty(), field_index)?, false)),\n+                Ok(TyAndPacked { ty: self.get_fat_field(ty.boxed_ty(), field_index)?, packed: false }),\n             ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n                     RawNullablePointer { nndiscr, .. } =>\n-                        Ok((adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs), false)),\n+                        Ok(TyAndPacked { ty: adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs), packed: false }),\n                     StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n                         let ty = adt_def.variants[nndiscr as usize].fields[field_index].ty(self.tcx, substs);\n-                        Ok((ty, nonnull.packed))\n+                        Ok(TyAndPacked { ty, packed: nonnull.packed })\n                     },\n                     _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle enum type: {:?}, {:?}\", ty, ty.sty))),\n                 }\n@@ -895,17 +901,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n                     Univariant { ref variant, .. } =>\n-                        Ok((variant_def.fields[field_index].ty(self.tcx, substs), variant.packed)),\n+                        Ok(TyAndPacked { ty: variant_def.fields[field_index].ty(self.tcx, substs), packed: variant.packed }),\n                     _ => Err(EvalError::Unimplemented(format!(\"get_field_ty can't handle struct type: {:?}, {:?}\", ty, ty.sty))),\n                 }\n             }\n \n-            ty::TyTuple(fields, _) => Ok((fields[field_index], false)),\n+            ty::TyTuple(fields, _) => Ok(TyAndPacked { ty: fields[field_index], packed: false }),\n \n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => Ok((self.get_fat_field(tam.ty, field_index)?, false)),\n+            ty::TyRawPtr(ref tam) => Ok(TyAndPacked { ty: self.get_fat_field(tam.ty, field_index)?, packed: false }),\n \n-            ty::TyArray(ref inner, _) => Ok((inner, false)),\n+            ty::TyArray(ref inner, _) => Ok(TyAndPacked { ty: inner, packed: false }),\n \n             _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n         }\n@@ -1042,7 +1048,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return Err(EvalError::DeadLocal),\n-                    Some(Value::ByRef(ptr, aligned)) => {\n+                    Some(Value::ByRef { ptr, aligned }) => {\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n                     },\n                     Some(val) => {\n@@ -1060,7 +1066,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Global(cid) => {\n                 let global_val = self.globals.get(&cid).expect(\"global not cached\").clone();\n                 match global_val.value {\n-                    Value::ByRef(ptr, aligned) =>\n+                    Value::ByRef { ptr, aligned } =>\n                         Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None },\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n@@ -1086,7 +1092,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(ptr, aligned) => {\n+            Value::ByRef { ptr, aligned } => {\n                 self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n@@ -1095,7 +1101,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n-            Value::ByRef(..) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n+            Value::ByRef{..} => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n             Value::ByVal(primval) => {\n                 self.ensure_valid_value(primval, ty)?;\n@@ -1185,7 +1191,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(dest_ptr, aligned) = old_dest_val {\n+        if let Value::ByRef { ptr: dest_ptr, aligned } = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n@@ -1196,7 +1202,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             self.write_maybe_aligned_mut(aligned,\n                 |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n-        } else if let Value::ByRef(src_ptr, aligned) = src_val {\n+        } else if let Value::ByRef { ptr: src_ptr, aligned } = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1234,7 +1240,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr, aligned) => {\n+            Value::ByRef { ptr, aligned } => {\n                 self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n@@ -1255,19 +1261,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let mut packed = false;\n         while self.get_field_count(ty)? == 1 {\n             let field = self.get_field_ty(ty, 0)?;\n-            ty = field.0;\n-            packed = packed || field.1;\n+            ty = field.ty;\n+            packed = packed || field.packed;\n         }\n         assert_eq!(self.get_field_count(ty)?, 2);\n         let field_0 = self.get_field_offset(ty, 0)?;\n         let field_1 = self.get_field_offset(ty, 1)?;\n         let field_0_ty = self.get_field_ty(ty, 0)?;\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n-        // The .1 components say whether the field is packed\n-        assert_eq!(field_0_ty.1, field_1_ty.1, \"the two fields must agree on being packed\");\n-        packed = packed || field_0_ty.1;\n-        let field_0_size = self.type_size(field_0_ty.0)?.expect(\"pair element type must be sized\");\n-        let field_1_size = self.type_size(field_1_ty.0)?.expect(\"pair element type must be sized\");\n+        assert_eq!(field_0_ty.packed, field_1_ty.packed, \"the two fields must agree on being packed\");\n+        packed = packed || field_0_ty.packed;\n+        let field_0_size = self.type_size(field_0_ty.ty)?.expect(\"pair element type must be sized\");\n+        let field_1_size = self.type_size(field_1_ty.ty)?.expect(\"pair element type must be sized\");\n         let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n         let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n         self.write_maybe_aligned_mut(!packed,\n@@ -1554,8 +1559,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 if self.ty_to_primval_kind(src_ty).is_ok() {\n                     // TODO: We ignore the packed flag here\n-                    let sty = self.get_field_ty(src_ty, 0)?.0;\n-                    let dty = self.get_field_ty(dest_ty, 0)?.0;\n+                    let sty = self.get_field_ty(src_ty, 0)?.ty;\n+                    let dty = self.get_field_ty(dest_ty, 0)?.ty;\n                     return self.unsize_into(src, sty, dest, dty);\n                 }\n                 // unsizing of generic struct with pointer fields\n@@ -1570,7 +1575,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 //let src = adt::MaybeSizedValue::sized(src);\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n-                    Value::ByRef(ptr, true) => ptr,\n+                    Value::ByRef { ptr, aligned: true } => ptr,\n                     // TODO: Is it possible for unaligned pointers to occur here?\n                     _ => bug!(\"expected aligned pointer, got {:?}\", src),\n                 };\n@@ -1617,7 +1622,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(ptr, aligned)) => match ptr.into_inner_primval() {\n+                Ok(Value::ByRef { ptr, aligned }) => match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n                         write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n                         allocs.push(ptr.alloc_id);"}, {"sha": "f1d1ba70b4f55c056f26c8a8a615f14e42865e62", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr, aligned))\n+                Ok(Value::ByRef { ptr, aligned })\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(..) |\n+                Value::ByRef{..} |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n-                Value::ByRef(..) |\n+                Value::ByRef{..} |\n                 Value::ByValPair(..) |\n                 Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n             },"}, {"sha": "1679688625dc6315d2cbb819152654265d7a06f1", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -15,7 +15,7 @@ use syntax::codemap::Span;\n use syntax::ast::Mutability;\n \n use error::{EvalResult, EvalError};\n-use eval_context::{EvalContext, StackPopCleanup};\n+use eval_context::{EvalContext, StackPopCleanup, TyAndPacked};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n use memory::HasMemory;\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                         if variant_index as u64 != nndiscr {\n-                            let (offset, ty, packed) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+                            let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n                             let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(offset.bytes(), &self)?;\n                             trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                             // only the pointer part of a fat pointer is used for this space optimization"}, {"sha": "5c608bc163007ed57fc8cb8a6b0fe0fde5294448", "filename": "src/librustc_mir/interpret/terminator/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n-                    Value::ByRef(..) => bug!(\"just read the value, can't be byref\"),\n+                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n@@ -251,10 +251,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef(ptr, aligned) => {\n+                        Value::ByRef { ptr, aligned } => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Value::ByRef(ptr, aligned)\n+                            Value::ByRef { ptr, aligned }\n                         },\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n@@ -442,9 +442,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n-                        Value::ByRef(ptr, aligned) => {\n+                        Value::ByRef { ptr, aligned } => {\n                             this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(Value::ByRef(ptr, aligned))\n+                            Ok(Value::ByRef { ptr, aligned })\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n                     }"}, {"sha": "288409783db88fa2755c954cdcdcf0c882d51759", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited, self};\n+use eval_context::{EvalContext, IntegerExt, StackPopCleanup, TyAndPacked, is_inhabited, self};\n use lvalue::Lvalue;\n use memory::{MemoryPointer, TlsKey, Kind, HasMemory};\n use value::{PrimVal, Value};\n@@ -313,10 +313,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n-                                    Value::ByRef(ptr, aligned) => {\n+                                    Value::ByRef { ptr, aligned } => {\n                                         assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset, &self)?, true);\n+                                            let arg = Value::ByRef { ptr: ptr.offset(offset, &self)?, aligned: true};\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n-                let ty = self.get_field_ty(ty, 0)?.0; // TODO: packed flag is ignored\n+                let ty = self.get_field_ty(ty, 0)?.ty; // TODO: packed flag is ignored\n                 match arg_operands[0] {\n                     mir::Operand::Consume(ref mut lval) => *lval = lval.clone().field(mir::Field::new(0), ty),\n                     _ => bug!(\"virtual call first arg cannot be a constant\"),\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let (offset, ty, packed) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n+                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n                 let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization"}, {"sha": "87b3d9f383c4e90b208441587fd3f16c2e7a2aa7", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6c743e424ec9ebe80ad7026175d506e6b6da65/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=eb6c743e424ec9ebe80ad7026175d506e6b6da65", "patch": "@@ -32,7 +32,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(Pointer, bool),\n+    ByRef { ptr: Pointer, aligned: bool},\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -162,15 +162,15 @@ pub enum PrimValKind {\n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n     pub(super) fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef(ptr, true)\n+        Value::ByRef { ptr, aligned: true }\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n     pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr, aligned) => {\n+            ByRef { ptr, aligned } => {\n                 mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n             },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n@@ -183,7 +183,7 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr, aligned) => {\n+            ByRef { ptr: ref_ptr, aligned } => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n@@ -200,7 +200,7 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ref_ptr, aligned) => {\n+            ByRef { ptr: ref_ptr, aligned } => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;"}]}