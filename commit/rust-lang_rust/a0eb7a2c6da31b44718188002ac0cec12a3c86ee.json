{"sha": "a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZWI3YTJjNmRhMzFiNDQ3MTgxODgwMDJhYzBjZWMxMmEzYzg2ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T21:34:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T21:34:19Z"}, "message": "Auto merge of #27544 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #27285, #27524, #27533, #27535, #27538, #27539\n- Failed merges:", "tree": {"sha": "079f86260286e535e6c48176ff42941fcf1b4f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/079f86260286e535e6c48176ff42941fcf1b4f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "html_url": "https://github.com/rust-lang/rust/commit/a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "430a9fd4c797c50cea26157141b2408073b2ed91", "url": "https://api.github.com/repos/rust-lang/rust/commits/430a9fd4c797c50cea26157141b2408073b2ed91", "html_url": "https://github.com/rust-lang/rust/commit/430a9fd4c797c50cea26157141b2408073b2ed91"}, {"sha": "428050712f3e4eb70d556926acf6933347067155", "url": "https://api.github.com/repos/rust-lang/rust/commits/428050712f3e4eb70d556926acf6933347067155", "html_url": "https://github.com/rust-lang/rust/commit/428050712f3e4eb70d556926acf6933347067155"}], "stats": {"total": 247, "additions": 228, "deletions": 19}, "files": [{"sha": "161c4ce90b2408614e80601fb45de3be3f7569dd", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -316,6 +316,35 @@ assert_eq!(3, answer);\n Now we take a trait object, a `&Fn`. And we have to make a reference\n to our closure when we pass it to `call_with_one`, so we use `&||`.\n \n+# Function pointers and closures\n+\n+A function pointer is kind of like a closure that has no environment. As such,\n+you can pass a function pointer to any function expecting a closure argument,\n+and it will work:\n+\n+```rust\n+fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n+    some_closure(1)\n+}\n+\n+fn add_one(i: i32) -> i32 {\n+    i + 1\n+}\n+\n+let f = add_one;\n+\n+let answer = call_with_one(&f);\n+\n+assert_eq!(2, answer);\n+```\n+\n+In this example, we don\u2019t strictly need the intermediate variable `f`,\n+the name of the function works just fine too:\n+\n+```ignore\n+let answer = call_with_one(&add_one);\n+```\n+\n # Returning closures\n \n It\u2019s very common for functional-style code to return closures in various"}, {"sha": "5b29965efc60b70cca0f2acec994226c16275b89", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -227,3 +227,34 @@ as any type:\n let x: i32 = diverges();\n let x: String = diverges();\n ```\n+\n+## Function pointers\n+\n+We can also create variable bindings which point to functions:\n+\n+```rust\n+let f: fn(i32) -> i32;\n+```\n+\n+`f` is a variable binding which points to a function that takes an `i32` as\n+an argument and returns an `i32`. For example:\n+\n+```rust\n+fn plus_one(i: i32) -> i32 {\n+    i + 1\n+}\n+\n+// without type inference\n+let f: fn(i32) -> i32 = plus_one;\n+\n+// with type inference\n+let f = plus_one;\n+```\n+\n+We can then use `f` to call the function:\n+\n+```rust\n+# fn plus_one(i: i32) -> i32 { i + 1 }\n+# let f = plus_one;\n+let six = f(5);\n+```"}, {"sha": "59dc8e9ed942e515b274eb8d59bcdd8f67ee8369", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -6,7 +6,7 @@ Generics are called \u2018parametric polymorphism\u2019 in type theory,\n which means that they are types or functions that have multiple forms (\u2018poly\u2019\n is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n \n-Anyway, enough with type theory, let\u2019s check out some generic code. Rust\u2019s\n+Anyway, enough type theory, let\u2019s check out some generic code. Rust\u2019s\n standard library provides a type, `Option<T>`, that\u2019s generic:\n \n ```rust\n@@ -27,7 +27,7 @@ let x: Option<i32> = Some(5);\n \n In the type declaration, we say `Option<i32>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n+the right-hand side of the binding, we make a `Some(T)`, where `T` is `5`.\n Since that\u2019s an `i32`, the two sides match, and Rust is happy. If they didn\u2019t\n match, we\u2019d get an error:\n \n@@ -101,11 +101,6 @@ fn takes_two_things<T, U>(x: T, y: U) {\n }\n ```\n \n-Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover in the\n-[section on traits][traits].\n-\n-[traits]: traits.html\n-\n ## Generic structs\n \n You can store a generic type in a `struct` as well:\n@@ -122,3 +117,28 @@ let float_origin = Point { x: 0.0, y: 0.0 };\n \n Similarly to functions, the `<T>` is where we declare the generic parameters,\n and we then use `x: T` in the type declaration, too.\n+\n+When you want to add an implementation for the generic struct, you just\n+declare the type parameter after the `impl`:\n+\n+```rust\n+# struct Point<T> {\n+#     x: T,\n+#     y: T,\n+# }\n+#\n+impl<T> Point<T> {\n+    fn swap(&mut self) {\n+        std::mem::swap(&mut self.x, &mut self.y);\n+    }\n+}\n+```\n+\n+So far you\u2019ve seen generics that take absolutely any type. These are useful in\n+many cases: you\u2019ve already seen `Option<T>`, and later you\u2019ll meet universal\n+container types like [`Vec<T>`][Vec]. On the other hand, often you want to\n+trade that flexibility for increased expressive power. Read about [trait\n+bounds][traits] to see why and how.\n+\n+[traits]: traits.html\n+[Vec]: ../std/vec/struct.Vec.html"}, {"sha": "4a35022b03c916bd5a23c5a82b4b165bd7f099a7", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -533,7 +533,7 @@ Great! Next up: let\u2019s compare our guess to the secret guess.\n # Comparing guesses\n \n Now that we\u2019ve got user input, let\u2019s compare our guess to the random guess.\n-Here\u2019s our next step, though it doesn\u2019t quite work yet:\n+Here\u2019s our next step, though it doesn\u2019t quite compile yet:\n \n ```rust,ignore\n extern crate rand;\n@@ -617,7 +617,7 @@ match guess.cmp(&secret_number) {\n If it\u2019s `Less`, we print `Too small!`, if it\u2019s `Greater`, `Too big!`, and if\n `Equal`, `You win!`. `match` is really useful, and is used often in Rust.\n \n-I did mention that this won\u2019t quite work yet, though. Let\u2019s try it:\n+I did mention that this won\u2019t quite compile yet, though. Let\u2019s try it:\n \n ```bash\n $ cargo build"}, {"sha": "bdb22fb4a690672b51a6c05d3701a1f16d97ce97", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -77,8 +77,18 @@ Before we get to that, though, let\u2019s break the explicit example down:\n fn bar<'a>(...)\n ```\n \n-This part declares our lifetimes. This says that `bar` has one lifetime, `'a`.\n-If we had two reference parameters, it would look like this:\n+We previously talked a little about [function syntax][functions], but we didn\u2019t\n+discuss the `<>`s after a function\u2019s name. A function can have \u2018generic\n+parameters\u2019 between the `<>`s, of which lifetimes are one kind. We\u2019ll discuss\n+other kinds of generics [later in the book][generics], but for now, let\u2019s\n+just focus on the lifteimes aspect.\n+\n+[functions]: functions.html\n+[generics]: generics.html\n+\n+We use `<>` to declare our lifetimes. This says that `bar` has one lifetime,\n+`'a`. If we had two reference parameters, it would look like this:\n+\n \n ```rust,ignore\n fn bar<'a, 'b>(...)"}, {"sha": "e53664eeb552662e2b0e4a17aafd17dea37c2adb", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -81,3 +81,55 @@ will let you do this:\n let p: Point = // ...\n let x: f64 = p + 2i32;\n ```\n+\n+# Using operator traits in generic structs\n+\n+Now that we know how operator traits are defined, we can define our `HasArea`\n+trait and `Square` struct from the [traits chapter][traits] more generically:\n+\n+[traits]: traits.html\n+\n+```rust\n+use std::ops::Mul;\n+\n+trait HasArea<T> {\n+    fn area(&self) -> T;\n+}\n+\n+struct Square<T> {\n+    x: T,\n+    y: T,\n+    side: T,\n+}\n+\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy {\n+    fn area(&self) -> T {\n+        self.side * self.side\n+    }\n+}\n+\n+fn main() {\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 12.0f64,\n+    };\n+\n+    println!(\"Area of s: {}\", s.area());\n+}\n+```\n+\n+For `HasArea` and `Square`, we just declare a type parameter `T` and replace\n+`f64` with it. The `impl` needs more involved modifications:\n+\n+```ignore\n+impl<T> HasArea<T> for Square<T>\n+        where T: Mul<Output=T> + Copy { ... }\n+```\n+\n+The `area` method requires that we can multiply the sides, so we declare that\n+type `T` must implement `std::ops::Mul`. Like `Add`, mentioned above, `Mul`\n+itself takes an `Output` parameter: since we know that numbers don't change\n+type when multiplied, we also set it to `T`. `T` must also support copying, so\n+Rust doesn't try to move `self.side` into the return value."}, {"sha": "80c45ac4f0ade2f273788671cd6c373a1457d134", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -47,8 +47,11 @@ As you can see, the `trait` block looks very similar to the `impl` block,\n but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n-We can use traits to constrain our generics. Consider this function, which\n-does not compile:\n+## Traits bounds for generic functions\n+\n+Traits are useful because they allow a type to make certain promises about its\n+behavior. Generic functions can exploit this to constrain the types they\n+accept. Consider this function, which does not compile:\n \n ```rust,ignore\n fn print_area<T>(shape: T) {\n@@ -75,7 +78,7 @@ fn print_area<T: HasArea>(shape: T) {\n }\n ```\n \n-The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n+The syntax `<T: HasArea>` means \u201cany type that implements the `HasArea` trait.\u201d\n Because traits define function type signatures, we can be sure that any type\n which implements `HasArea` will have an `.area()` method.\n \n@@ -152,6 +155,63 @@ We get a compile-time error:\n error: the trait `HasArea` is not implemented for the type `_` [E0277]\n ```\n \n+## Traits bounds for generic structs\n+\n+Your generic structs can also benefit from trait constraints. All you need to\n+do is append the constraint when you declare type parameters. Here is a new\n+type `Rectangle<T>` and its operation `is_square()`:\n+\n+```rust\n+struct Rectangle<T> {\n+    x: T,\n+    y: T,\n+    width: T,\n+    height: T,\n+}\n+\n+impl<T: PartialEq> Rectangle<T> {\n+    fn is_square(&self) -> bool {\n+        self.width == self.height\n+    }\n+}\n+\n+fn main() {\n+    let mut r = Rectangle {\n+        x: 0,\n+        y: 0,\n+        width: 47,\n+        height: 47,\n+    };\n+\n+    assert!(r.is_square());\n+\n+    r.height = 42;\n+    assert!(!r.is_square());\n+}\n+```\n+\n+`is_square()` needs to check that the sides are equal, so the sides must be of\n+a type that implements the [`core::cmp::PartialEq`][PartialEq] trait:\n+\n+```ignore\n+impl<T: PartialEq> Rectangle<T> { ... }\n+```\n+\n+Now, a rectangle can be defined in terms of any type that can be compared for\n+equality.\n+\n+[PartialEq]: ../core/cmp/trait.PartialEq.html\n+\n+Here we defined a new struct `Rectangle` that accepts numbers of any\n+precision\u2014really, objects of pretty much any type\u2014as long as they can be\n+compared for equality. Could we do the same for our `HasArea` structs, `Square`\n+and `Circle`? Yes, but they need multiplication, and to work with that we need\n+to know more about [operator traits][operators-and-overloading].\n+\n+[operators-and-overloading]: operators-and-overloading.html\n+\n+# Rules for implementing traits\n+\n So far, we\u2019ve only added trait implementations to structs, but you can\n implement a trait for any type. So technically, we _could_ implement `HasArea`\n for `i32`:\n@@ -175,7 +235,7 @@ impl HasArea for i32 {\n It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n-This may seem like the Wild West, but there are two other restrictions around\n+This may seem like the Wild West, but there are two restrictions around\n implementing traits that prevent this from getting out of hand. The first is\n that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n example: the standard library provides a [`Write`][write] trait which adds\n@@ -340,10 +400,10 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-## Default methods\n+# Default methods\n \n-There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n-easiest just to show an example:\n+If you already know how a typical implementor will define a method, you can\n+let your trait supply a default:\n \n ```rust\n trait Foo {"}, {"sha": "a7b4c17314bcb993e143b69feb0261ef396557e0", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -38,6 +38,9 @@ use self::Cow::*;\n /// type can be borrowed as multiple different types. In particular, `Vec<T>:\n /// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n ///\n+/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n+/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n+///\n /// `Borrow` is very similar to, but different than, `AsRef`. See\n /// [the book][book] for more.\n ///"}, {"sha": "c0956753c988cb789f41b59c55398e60c1212e4a", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0eb7a2c6da31b44718188002ac0cec12a3c86ee/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a0eb7a2c6da31b44718188002ac0cec12a3c86ee", "patch": "@@ -273,7 +273,11 @@ macro_rules! impls{\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n /// of your code.\n ///\n-/// Though they both have scary names, `PhantomData<T>` and \"phantom types\" are unrelated. \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n+/// # A ghastly note \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n+///\n+/// Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not\n+/// identical. Phantom types are a more general concept that don't require `PhantomData<T>` to\n+/// implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.\n ///\n /// # Examples\n ///"}]}