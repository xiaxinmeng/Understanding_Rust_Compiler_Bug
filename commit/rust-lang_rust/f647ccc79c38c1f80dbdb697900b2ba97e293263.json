{"sha": "f647ccc79c38c1f80dbdb697900b2ba97e293263", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NDdjY2M3OWMzOGMxZjgwZGJkYjY5NzkwMGIyYmE5N2UyOTMyNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-09T12:11:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-09T12:11:33Z"}, "message": "auto merge of #9695 : huonw/rust/rand2, r=alexcrichton\n\nA pile of changes to `std::rand`:\r\n\r\n- Add the 64-bit variant of the ISAAC Rng. This also splits the `Rng.next() -> u32` method into `Rng.next_u32() -> u32` and `Rng.next_u64() -> u64` to be able to actually take advantage of the wider numbers. They have default implementations in terms of each other. (This is ~2&times; faster than the 32 bit one for generating anything larger than a `u32` on 64-bit computers.)\r\n- Add `ReaderRng` which just wraps a reader as an RNG, useful for `/dev/urandom`, `/dev/random`, `/dev/hwrng`, etc. This also adds the overrideable `fill_bytes` method to `Rng`, since readers can \"generate\" randomness more than just 8 bytes at a time.\r\n- Add an interface to `/dev/urandom` (and the windows API) that implements `Rng` (`os::OSRng`) so that it is a first-class randomness source. This means that experimenting with things like seeding hashmaps from it will be much easier. It deletes most of the C++ supporting the old form, except for thin wrappers around the Windows API; I don't have access to a windows with Rust other than the try branch. ( **Note:** on unices, this means that `OSRng` requires the runtime, so it's not possible to use it to seed the scheduler RNG; I've replaced it with direct libc calls for reading from `/dev/urandom`.)\r\n- Add the \"blessed\" `StdRng` which means users who just want a random number generator don't need to worry about the implementation details (which will make changing the underlying implementation from Isaac to something else will be easier, if this every happen). This actually changes between the 32 and 64-bit variants of Isaac depending on the platform at the moment.\r\n- Add a `SeedableRng` trait for random number generators that can be explicitly seeded, \r\n- Add the `ReseedingRng` wrapper for reseeding a RNG after a certain amount of randomness is emitted. (The method for reseeding is controlled via the `Reseeder` trait from the same module)\r\n- changes to the task rng: \r\n - uses `StdRng`\r\n - it will reseed itself every 32KB, that is, after outputting 32KB of random data it will read new data from the OS (via `OSRng`)\r\n- Implements `Rand` for `char`, and makes the `f32` and `f64` instances more reasonable (and more similar to most other languages I've looked at).\r\n- Documentation, examples and tests", "tree": {"sha": "c16836c1c963984b2df8cfebcadc18de45314b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c16836c1c963984b2df8cfebcadc18de45314b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f647ccc79c38c1f80dbdb697900b2ba97e293263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f647ccc79c38c1f80dbdb697900b2ba97e293263", "html_url": "https://github.com/rust-lang/rust/commit/f647ccc79c38c1f80dbdb697900b2ba97e293263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f647ccc79c38c1f80dbdb697900b2ba97e293263/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e505d4c3535d6e0af1070b1b50ec8db4c2eca827", "url": "https://api.github.com/repos/rust-lang/rust/commits/e505d4c3535d6e0af1070b1b50ec8db4c2eca827", "html_url": "https://github.com/rust-lang/rust/commit/e505d4c3535d6e0af1070b1b50ec8db4c2eca827"}, {"sha": "e678435cab9cc8ddd668d4cb58ab82194c220382", "url": "https://api.github.com/repos/rust-lang/rust/commits/e678435cab9cc8ddd668d4cb58ab82194c220382", "html_url": "https://github.com/rust-lang/rust/commit/e678435cab9cc8ddd668d4cb58ab82194c220382"}], "stats": {"total": 2279, "additions": 1703, "deletions": 576}, "files": [{"sha": "412e25bed4de2caacb2ef2336a98ceb10e0c8bf6", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -86,7 +86,6 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/sync/lock_and_signal.cpp \\\n               rt/sync/rust_thread.cpp \\\n               rt/rust_builtin.cpp \\\n-              rt/rust_rng.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n               rt/miniz.cpp \\"}, {"sha": "4f8cd4d33088369873cdacad04336c84d61c2126", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -1524,16 +1524,16 @@ mod tests {\n     }\n \n     fn rng() -> rand::IsaacRng {\n-        let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::IsaacRng::new_seeded(seed)\n+        let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n     }\n \n     #[bench]\n     fn bench_uint_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n-            bitv |= (1 << ((r.next() as uint) % uint::bits));\n+            bitv |= (1 << ((r.next_u32() as uint) % uint::bits));\n         }\n     }\n \n@@ -1542,7 +1542,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1551,7 +1551,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1562,7 +1562,7 @@ mod tests {\n         storage.grow(BENCH_BITS / uint::bits, &0u);\n         let mut bitv = BigBitv::new(storage);\n         do b.iter {\n-            bitv.set((r.next() as uint) % BENCH_BITS, true);\n+            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n         }\n     }\n \n@@ -1571,7 +1571,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n-            bitv.set((r.next() as uint) % BENCH_BITS, true);\n+            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n         }\n     }\n \n@@ -1580,7 +1580,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1589,7 +1589,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n-            bitv.insert((r.next() as uint) % uint::bits);\n+            bitv.insert((r.next_u32() as uint) % uint::bits);\n         }\n     }\n \n@@ -1598,7 +1598,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n-            bitv.insert((r.next() as uint) % BENCH_BITS);\n+            bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n         }\n     }\n "}, {"sha": "66e1fd0c2c3dc05e2df9bb604932b095f5feb09f", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -1013,7 +1013,7 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let mut rng = rand::IsaacRng::new_seeded(&[42]);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n \n         do 3.times {\n             do 90.times {"}, {"sha": "0068b60cfa51b12a53148408d8f4774e18321b73", "filename": "src/libstd/rand/isaac.rs", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -0,0 +1,517 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The ISAAC random number generator.\n+\n+use cast;\n+use rand::{Rng, SeedableRng, OSRng};\n+use iter::{Iterator, range, range_step, Repeat};\n+use option::{None, Some};\n+\n+static RAND_SIZE_LEN: u32 = 8;\n+static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n+\n+/// A random number generator that uses the [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n+pub struct IsaacRng {\n+    priv cnt: u32,\n+    priv rsl: [u32, .. RAND_SIZE],\n+    priv mem: [u32, .. RAND_SIZE],\n+    priv a: u32,\n+    priv b: u32,\n+    priv c: u32\n+}\n+static EMPTY: IsaacRng = IsaacRng {\n+    cnt: 0,\n+    rsl: [0, .. RAND_SIZE],\n+    mem: [0, .. RAND_SIZE],\n+    a: 0, b: 0, c: 0\n+};\n+\n+impl IsaacRng {\n+    /// Create an ISAAC random number generator with a random seed.\n+    pub fn new() -> IsaacRng {\n+        let mut rng = EMPTY;\n+\n+        {\n+            let bytes = unsafe {cast::transmute::<&mut [u32], &mut [u8]>(rng.rsl)};\n+            OSRng::new().fill_bytes(bytes);\n+        }\n+\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create an ISAAC random number generator using the default\n+    /// fixed seed.\n+    pub fn new_unseeded() -> IsaacRng {\n+        let mut rng = EMPTY;\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    fn init(&mut self, use_rsl: bool) {\n+        let mut a = 0x9e3779b9;\n+        let mut b = a;\n+        let mut c = a;\n+        let mut d = a;\n+        let mut e = a;\n+        let mut f = a;\n+        let mut g = a;\n+        let mut h = a;\n+\n+        macro_rules! mix(\n+            () => {{\n+                a^=b<<11; d+=a; b+=c;\n+                b^=c>>2;  e+=b; c+=d;\n+                c^=d<<8;  f+=c; d+=e;\n+                d^=e>>16; g+=d; e+=f;\n+                e^=f<<10; h+=e; f+=g;\n+                f^=g>>4;  a+=f; g+=h;\n+                g^=h<<8;  b+=g; h+=a;\n+                h^=a>>9;  c+=h; a+=b;\n+            }}\n+        );\n+\n+        do 4.times { mix!(); }\n+\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for i in range_step(0u32, RAND_SIZE, 8) {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for i in range_step(0u32, RAND_SIZE, 8) {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n+            }\n+        }\n+\n+        self.isaac();\n+    }\n+\n+    /// Refills the output buffer (`self.rsl`)\n+    #[inline]\n+    fn isaac(&mut self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n+\n+        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n+\n+        macro_rules! ind (($x:expr) => {\n+            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n+        });\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = $j;\n+                let mix = if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                };\n+\n+                let x = self.mem[base  + mr_offset];\n+                a = (a ^ mix) + self.mem[base + m2_offset];\n+                let y = ind!(x) + a + b;\n+                self.mem[base + mr_offset] = y;\n+\n+                b = ind!(y >> RAND_SIZE_LEN) + x;\n+                self.rsl[base + mr_offset] = b;\n+            }}\n+        );\n+\n+        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n+        for &(mr_offset, m2_offset) in r.iter() {\n+            for i in range_step(0u, MIDPOINT, 4) {\n+                rngstep!(i + 0, 13);\n+                rngstep!(i + 1, -6);\n+                rngstep!(i + 2, 2);\n+                rngstep!(i + 3, -16);\n+            }\n+        }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE;\n+    }\n+}\n+\n+impl Rng for IsaacRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac();\n+        }\n+        self.cnt -= 1;\n+        self.rsl[self.cnt]\n+    }\n+}\n+\n+impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n+    fn reseed(&mut self, seed: &'self [u32]) {\n+        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n+        // - 1], 0, 0, ...], to fill rng.rsl.\n+        let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u32));\n+\n+        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+            *rsl_elem = seed_elem;\n+        }\n+        self.cnt = 0;\n+        self.a = 0;\n+        self.b = 0;\n+        self.c = 0;\n+\n+        self.init(true);\n+    }\n+\n+    /// Create an ISAAC random number generator with a seed. This can\n+    /// be any length, although the maximum number of elements used is\n+    /// 256 and any more will be silently ignored. A generator\n+    /// constructed with a given seed will generate the same sequence\n+    /// of values as all other generators constructed with that seed.\n+    fn from_seed(seed: &'self [u32]) -> IsaacRng {\n+        let mut rng = EMPTY;\n+        rng.reseed(seed);\n+        rng\n+    }\n+}\n+\n+\n+static RAND_SIZE_64_LEN: uint = 8;\n+static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n+\n+/// A random number generator that uses the 64-bit variant of the\n+/// [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n+pub struct Isaac64Rng {\n+    priv cnt: uint,\n+    priv rsl: [u64, .. RAND_SIZE_64],\n+    priv mem: [u64, .. RAND_SIZE_64],\n+    priv a: u64,\n+    priv b: u64,\n+    priv c: u64,\n+}\n+\n+static EMPTY_64: Isaac64Rng = Isaac64Rng {\n+    cnt: 0,\n+    rsl: [0, .. RAND_SIZE_64],\n+    mem: [0, .. RAND_SIZE_64],\n+    a: 0, b: 0, c: 0,\n+};\n+\n+impl Isaac64Rng {\n+    /// Create a 64-bit ISAAC random number generator with a random\n+    /// seed.\n+    pub fn new() -> Isaac64Rng {\n+        let mut rng = EMPTY_64;\n+        {\n+            let bytes = unsafe {cast::transmute::<&mut [u64], &mut [u8]>(rng.rsl)};\n+            OSRng::new().fill_bytes(bytes);\n+        }\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create a 64-bit ISAAC random number generator using the\n+    /// default fixed seed.\n+    pub fn new_unseeded() -> Isaac64Rng {\n+        let mut rng = EMPTY_64;\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    fn init(&mut self, use_rsl: bool) {\n+        macro_rules! init (\n+            ($var:ident) => (\n+                let mut $var = 0x9e3779b97f4a7c13;\n+            )\n+        );\n+        init!(a); init!(b); init!(c); init!(d);\n+        init!(e); init!(f); init!(g); init!(h);\n+\n+        macro_rules! mix(\n+            () => {{\n+                a-=e; f^=h>>9;  h+=a;\n+                b-=f; g^=a<<9;  a+=b;\n+                c-=g; h^=b>>23; b+=c;\n+                d-=h; a^=c<<15; c+=d;\n+                e-=a; b^=d>>14; d+=e;\n+                f-=b; c^=e<<20; e+=f;\n+                g-=c; d^=f>>17; f+=g;\n+                h-=d; e^=g<<14; g+=h;\n+            }}\n+        );\n+\n+        for _ in range(0, 4) { mix!(); }\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n+            }\n+        }\n+\n+        self.isaac64();\n+    }\n+\n+    /// Refills the output buffer (`self.rsl`)\n+    fn isaac64(&mut self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n+        static MIDPOINT: uint =  RAND_SIZE_64 / 2;\n+        static MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n+        macro_rules! ind (\n+            ($x:expr) => {\n+                self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+            }\n+        );\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = base + $j;\n+                let mix = a ^ (if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                });\n+                let mix = if $j == 0 {!mix} else {mix};\n+\n+                unsafe {\n+                    let x = self.mem.unsafe_get(base + mr_offset);\n+                    a = mix + self.mem.unsafe_get(base + m2_offset);\n+                    let y = ind!(x) + a + b;\n+                    self.mem.unsafe_set(base + mr_offset, y);\n+\n+                    b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                    self.rsl.unsafe_set(base + mr_offset, b);\n+                }\n+            }}\n+        );\n+\n+        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n+            for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n+                rngstep!(0, 21);\n+                rngstep!(1, -5);\n+                rngstep!(2, 12);\n+                rngstep!(3, -33);\n+            }\n+        }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE_64;\n+    }\n+}\n+\n+impl Rng for Isaac64Rng {\n+    // FIXME #7771: having next_u32 like this should be unnecessary\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        self.next_u64() as u32\n+    }\n+\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac64();\n+        }\n+        self.cnt -= 1;\n+        unsafe { self.rsl.unsafe_get(self.cnt) }\n+    }\n+}\n+\n+impl<'self> SeedableRng<&'self [u64]> for Isaac64Rng {\n+    fn reseed(&mut self, seed: &'self [u64]) {\n+        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n+        // - 1], 0, 0, ...], to fill rng.rsl.\n+        let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u64));\n+\n+        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+            *rsl_elem = seed_elem;\n+        }\n+        self.cnt = 0;\n+        self.a = 0;\n+        self.b = 0;\n+        self.c = 0;\n+\n+        self.init(true);\n+    }\n+\n+    /// Create an ISAAC random number generator with a seed. This can\n+    /// be any length, although the maximum number of elements used is\n+    /// 256 and any more will be silently ignored. A generator\n+    /// constructed with a given seed will generate the same sequence\n+    /// of values as all other generators constructed with that seed.\n+    fn from_seed(seed: &'self [u64]) -> Isaac64Rng {\n+        let mut rng = EMPTY_64;\n+        rng.reseed(seed);\n+        rng\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rand::{Rng, SeedableRng, OSRng};\n+    use option::Some;\n+    use iter::range;\n+    use vec;\n+\n+    #[test]\n+    fn test_rng_32_rand_seeded() {\n+        let s = OSRng::new().gen_vec::<u32>(256);\n+        let mut ra: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+    #[test]\n+    fn test_rng_64_rand_seeded() {\n+        let s = OSRng::new().gen_vec::<u64>(256);\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_rng_32_seeded() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n+        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+    #[test]\n+    fn test_rng_64_seeded() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_rng_32_reseed() {\n+        let s = OSRng::new().gen_vec::<u32>(256);\n+        let mut r: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        let string1 = r.gen_ascii_str(100);\n+\n+        r.reseed(s);\n+\n+        let string2 = r.gen_ascii_str(100);\n+        assert_eq!(string1, string2);\n+    }\n+    #[test]\n+    fn test_rng_64_reseed() {\n+        let s = OSRng::new().gen_vec::<u64>(256);\n+        let mut r: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        let string1 = r.gen_ascii_str(100);\n+\n+        r.reseed(s);\n+\n+        let string2 = r.gen_ascii_str(100);\n+        assert_eq!(string1, string2);\n+    }\n+\n+    #[test]\n+    fn test_rng_32_true_values() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n+        // Regression test that isaac is actually using the above vector\n+        let v = vec::from_fn(10, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   ~[447462228, 2081944040, 3163797308, 2379916134, 2377489184,\n+                     1132373754, 536342443, 2995223415, 1265094839, 345325140]);\n+\n+        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n+        // skip forward to the 10000th number\n+        for _ in range(0, 10000) { rb.next_u32(); }\n+\n+        let v = vec::from_fn(10, |_| rb.next_u32());\n+        assert_eq!(v,\n+                   ~[612373032, 292987903, 1819311337, 3141271980, 422447569,\n+                     310096395, 1083172510, 867909094, 2478664230, 2073577855]);\n+    }\n+    #[test]\n+    fn test_rng_64_true_values() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n+        // Regression test that isaac is actually using the above vector\n+        let v = vec::from_fn(10, |_| ra.next_u64());\n+        assert_eq!(v,\n+                   ~[15015576812873463115, 12461067598045625862, 14818626436142668771,\n+                     5562406406765984441, 11813289907965514161, 13443797187798420053,\n+                     6935026941854944442, 7750800609318664042, 14428747036317928637,\n+                     14028894460301215947]);\n+\n+        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n+        // skip forward to the 10000th number\n+        for _ in range(0, 10000) { rb.next_u64(); }\n+\n+        let v = vec::from_fn(10, |_| rb.next_u64());\n+        assert_eq!(v,\n+                   ~[13557216323596688637, 17060829581390442094, 4927582063811333743,\n+                     2699639759356482270, 4819341314392384881, 6047100822963614452,\n+                     11086255989965979163, 11901890363215659856, 5370800226050011580,\n+                     16496463556025356451]);\n+    }\n+}"}, {"sha": "9b757092266bf3e58c9d037d9c5c7f4595303246", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 324, "deletions": 434, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,6 +19,15 @@ suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n See the `distributions` submodule for sampling random numbers from\n distributions like normal and exponential.\n \n+# Task-local RNG\n+\n+There is built-in support for a RNG associated with each task stored\n+in task-local storage. This RNG can be accessed via `task_rng`, or\n+used implicitly via `random`. This RNG is normally randomly seeded\n+from an operating-system source of randomness, e.g. `/dev/urandom` on\n+Unix systems, and will automatically reseed itself from this source\n+after generating 32 KiB of random data.\n+\n # Examples\n \n ```rust\n@@ -44,21 +53,23 @@ fn main () {\n */\n \n use cast;\n-use cmp;\n use container::Container;\n-use int;\n-use iter::{Iterator, range, range_step};\n+use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use sys;\n-use u32;\n use u64;\n-use uint;\n use vec;\n-use libc::size_t;\n+\n+pub use self::isaac::{IsaacRng, Isaac64Rng};\n+pub use self::os::OSRng;\n \n pub mod distributions;\n+pub mod isaac;\n+pub mod os;\n+pub mod reader;\n+pub mod reseeding;\n+mod rand_impls;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n@@ -67,178 +78,6 @@ pub trait Rand {\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n-impl Rand for int {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> int {\n-        if int::bits == 32 {\n-            rng.next() as int\n-        } else {\n-            rng.gen::<i64>() as int\n-        }\n-    }\n-}\n-\n-impl Rand for i8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i8 {\n-        rng.next() as i8\n-    }\n-}\n-\n-impl Rand for i16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i16 {\n-        rng.next() as i16\n-    }\n-}\n-\n-impl Rand for i32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i32 {\n-        rng.next() as i32\n-    }\n-}\n-\n-impl Rand for i64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i64 {\n-        (rng.next() as i64 << 32) | rng.next() as i64\n-    }\n-}\n-\n-impl Rand for uint {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> uint {\n-        if uint::bits == 32 {\n-            rng.next() as uint\n-        } else {\n-            rng.gen::<u64>() as uint\n-        }\n-    }\n-}\n-\n-impl Rand for u8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u8 {\n-        rng.next() as u8\n-    }\n-}\n-\n-impl Rand for u16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u16 {\n-        rng.next() as u16\n-    }\n-}\n-\n-impl Rand for u32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u32 {\n-        rng.next()\n-    }\n-}\n-\n-impl Rand for u64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u64 {\n-        (rng.next() as u64 << 32) | rng.next() as u64\n-    }\n-}\n-\n-impl Rand for f32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f32 {\n-        rng.gen::<f64>() as f32\n-    }\n-}\n-\n-static SCALE : f64 = (u32::max_value as f64) + 1.0f64;\n-impl Rand for f64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> f64 {\n-        let u1 = rng.next() as f64;\n-        let u2 = rng.next() as f64;\n-        let u3 = rng.next() as f64;\n-\n-        ((u1 / SCALE + u2) / SCALE + u3) / SCALE\n-    }\n-}\n-\n-impl Rand for bool {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> bool {\n-        rng.next() & 1u32 == 1u32\n-    }\n-}\n-\n-macro_rules! tuple_impl {\n-    // use variables to indicate the arity of the tuple\n-    ($($tyvar:ident),* ) => {\n-        // the trailing commas are for the 1 tuple\n-        impl<\n-            $( $tyvar : Rand ),*\n-            > Rand for ( $( $tyvar ),* , ) {\n-\n-            #[inline]\n-            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n-                (\n-                    // use the $tyvar's to get the appropriate number of\n-                    // repeats (they're not actually needed)\n-                    $(\n-                        _rng.gen::<$tyvar>()\n-                    ),*\n-                    ,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl Rand for () {\n-    #[inline]\n-    fn rand<R: Rng>(_: &mut R) -> () { () }\n-}\n-tuple_impl!{A}\n-tuple_impl!{A, B}\n-tuple_impl!{A, B, C}\n-tuple_impl!{A, B, C, D}\n-tuple_impl!{A, B, C, D, E}\n-tuple_impl!{A, B, C, D, E, F}\n-tuple_impl!{A, B, C, D, E, F, G}\n-tuple_impl!{A, B, C, D, E, F, G, H}\n-tuple_impl!{A, B, C, D, E, F, G, H, I}\n-tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n-\n-impl<T:Rand> Rand for Option<T> {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n-        if rng.gen() {\n-            Some(rng.gen())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<T: Rand> Rand for ~T {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n-}\n-\n-impl<T: Rand + 'static> Rand for @T {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n-}\n-\n-#[abi = \"cdecl\"]\n-pub mod rustrt {\n-    use libc::size_t;\n-\n-    extern {\n-        pub fn rand_gen_seed(buf: *mut u8, sz: size_t);\n-    }\n-}\n-\n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n@@ -249,9 +88,92 @@ pub struct Weighted<T> {\n \n /// A random number generator\n pub trait Rng {\n-    /// Return the next random integer\n-    fn next(&mut self) -> u32;\n+    /// Return the next random u32. This rarely needs to be called\n+    /// directly, prefer `r.gen()` to `r.next_u32()`.\n+    ///\n+    // FIXME #7771: Should be implemented in terms of next_u64\n+    fn next_u32(&mut self) -> u32;\n \n+    /// Return the next random u64. This rarely needs to be called\n+    /// directly, prefer `r.gen()` to `r.next_u64()`.\n+    ///\n+    /// By default this is implemented in terms of `next_u32`. An\n+    /// implementation of this trait must provide at least one of\n+    /// these two methods.\n+    fn next_u64(&mut self) -> u64 {\n+        (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n+    }\n+\n+    /// Fill `dest` with random data.\n+    ///\n+    /// This has a default implementation in terms of `next_u64` and\n+    /// `next_u32`, but should be overriden by implementations that\n+    /// offer a more efficient solution than just calling those\n+    /// methods repeatedly.\n+    ///\n+    /// This method does *not* have a requirement to bear any fixed\n+    /// relationship to the other methods, for example, it does *not*\n+    /// have to result in the same output as progressively filling\n+    /// `dest` with `self.gen::<u8>()`, and any such behaviour should\n+    /// not be relied upon.\n+    ///\n+    /// This method should guarantee that `dest` is entirely filled\n+    /// with new data, and may fail if this is impossible\n+    /// (e.g. reading past the end of a file that is being used as the\n+    /// source of randomness).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::rand::{task_rng, Rng};\n+    ///\n+    /// fn main() {\n+    ///    let mut v = [0u8, .. 13579];\n+    ///    task_rng().fill_bytes(v);\n+    ///    println!(\"{:?}\", v);\n+    /// }\n+    /// ```\n+    fn fill_bytes(&mut self, mut dest: &mut [u8]) {\n+        // this relies on the lengths being transferred correctly when\n+        // transmuting between vectors like this.\n+        let as_u64: &mut &mut [u64] = unsafe { cast::transmute(&mut dest) };\n+        for dest in as_u64.mut_iter() {\n+            *dest = self.next_u64();\n+        }\n+\n+        // the above will have filled up the vector as much as\n+        // possible in multiples of 8 bytes.\n+        let mut remaining = dest.len() % 8;\n+\n+        // space for a u32\n+        if remaining >= 4 {\n+            let as_u32: &mut &mut [u32] = unsafe { cast::transmute(&mut dest) };\n+            as_u32[as_u32.len() - 1] = self.next_u32();\n+            remaining -= 4;\n+        }\n+        // exactly filled\n+        if remaining == 0 { return }\n+\n+        // now we know we've either got 1, 2 or 3 spots to go,\n+        // i.e. exactly one u32 is enough.\n+        let rand = self.next_u32();\n+        let remaining_index = dest.len() - remaining;\n+        match dest.mut_slice_from(remaining_index) {\n+            [ref mut a] => {\n+                *a = rand as u8;\n+            }\n+            [ref mut a, ref mut b] => {\n+                *a = rand as u8;\n+                *b = (rand >> 8) as u8;\n+            }\n+            [ref mut a, ref mut b, ref mut c] => {\n+                *a = rand as u8;\n+                *b = (rand >> 8) as u8;\n+                *c = (rand >> 16) as u8;\n+            }\n+            _ => fail2!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+        }\n+    }\n \n     /// Return a random value of a Rand type.\n     ///\n@@ -556,202 +478,118 @@ pub trait Rng {\n     }\n }\n \n+/// A random number generator that can be explicitly seeded to produce\n+/// the same stream of randomness multiple times.\n+pub trait SeedableRng<Seed>: Rng {\n+    /// Reseed an RNG with the given seed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng: rand::StdRng = rand::SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    ///     rng.reseed([5, 6, 7, 8]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    /// }\n+    /// ```\n+    fn reseed(&mut self, Seed);\n+\n+    /// Create a new RNG with the given seed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng: rand::StdRng = rand::SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    /// }\n+    /// ```\n+    fn from_seed(seed: Seed) -> Self;\n+}\n+\n /// Create a random number generator with a default algorithm and seed.\n ///\n /// It returns the cryptographically-safest `Rng` algorithm currently\n /// available in Rust. If you require a specifically seeded `Rng` for\n /// consistency over time you should pick one algorithm and create the\n /// `Rng` yourself.\n-pub fn rng() -> IsaacRng {\n-    IsaacRng::new()\n-}\n-\n-/// Create a weak random number generator with a default algorithm and seed.\n ///\n-/// It returns the fastest `Rng` algorithm currently available in Rust without\n-/// consideration for cryptography or security. If you require a specifically\n-/// seeded `Rng` for consistency over time you should pick one algorithm and\n-/// create the `Rng` yourself.\n-pub fn weak_rng() -> XorShiftRng {\n-    XorShiftRng::new()\n+/// This is a very expensive operation as it has to read randomness\n+/// from the operating system and use this in an expensive seeding\n+/// operation. If one does not require high performance generation of\n+/// random numbers, `task_rng` and/or `random` may be more\n+/// appropriate.\n+pub fn rng() -> StdRng {\n+    StdRng::new()\n }\n \n-static RAND_SIZE_LEN: u32 = 8;\n-static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n+/// The standard RNG. This is designed to be efficient on the current\n+/// platform.\n+#[cfg(not(target_word_size=\"64\"))]\n+pub struct StdRng { priv rng: IsaacRng }\n \n-/// A random number generator that uses the [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n-///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n-pub struct IsaacRng {\n-    priv cnt: u32,\n-    priv rsl: [u32, .. RAND_SIZE],\n-    priv mem: [u32, .. RAND_SIZE],\n-    priv a: u32,\n-    priv b: u32,\n-    priv c: u32\n-}\n+/// The standard RNG. This is designed to be efficient on the current\n+/// platform.\n+#[cfg(target_word_size=\"64\")]\n+pub struct StdRng { priv rng: Isaac64Rng }\n \n-impl IsaacRng {\n-    /// Create an ISAAC random number generator with a random seed.\n-    pub fn new() -> IsaacRng {\n-        IsaacRng::new_seeded(seed())\n+impl StdRng {\n+    /// Create a randomly seeded instance of `StdRng`. This reads\n+    /// randomness from the OS to seed the PRNG.\n+    #[cfg(not(target_word_size=\"64\"))]\n+    pub fn new() -> StdRng {\n+        StdRng { rng: IsaacRng::new() }\n     }\n-\n-    /// Create an ISAAC random number generator with a seed. This can be any\n-    /// length, although the maximum number of bytes used is 1024 and any more\n-    /// will be silently ignored. A generator constructed with a given seed\n-    /// will generate the same sequence of values as all other generators\n-    /// constructed with the same seed.\n-    pub fn new_seeded(seed: &[u8]) -> IsaacRng {\n-        let mut rng = IsaacRng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE],\n-            mem: [0, .. RAND_SIZE],\n-            a: 0, b: 0, c: 0\n-        };\n-\n-        let array_size = sys::size_of_val(&rng.rsl);\n-        let copy_length = cmp::min(array_size, seed.len());\n-\n-        // manually create a &mut [u8] slice of randrsl to copy into.\n-        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n-        vec::bytes::copy_memory(dest, seed, copy_length);\n-        rng.init(true);\n-        rng\n+    /// Create a randomly seeded instance of `StdRng`. This reads\n+    /// randomness from the OS to seed the PRNG.\n+    #[cfg(target_word_size=\"64\")]\n+    pub fn new() -> StdRng {\n+        StdRng { rng: Isaac64Rng::new() }\n     }\n+}\n \n-    /// Create an ISAAC random number generator using the default\n-    /// fixed seed.\n-    pub fn new_unseeded() -> IsaacRng {\n-        let mut rng = IsaacRng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE],\n-            mem: [0, .. RAND_SIZE],\n-            a: 0, b: 0, c: 0\n-        };\n-        rng.init(false);\n-        rng\n+impl Rng for StdRng {\n+    #[inline]\n+    fn next_u32(&mut self) -> u32 {\n+        self.rng.next_u32()\n     }\n \n-    /// Initialises `self`. If `use_rsl` is true, then use the current value\n-    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n-    /// randomly).\n-    fn init(&mut self, use_rsl: bool) {\n-        let mut a = 0x9e3779b9;\n-        let mut b = a;\n-        let mut c = a;\n-        let mut d = a;\n-        let mut e = a;\n-        let mut f = a;\n-        let mut g = a;\n-        let mut h = a;\n-\n-        macro_rules! mix(\n-            () => {{\n-                a^=b<<11; d+=a; b+=c;\n-                b^=c>>2;  e+=b; c+=d;\n-                c^=d<<8;  f+=c; d+=e;\n-                d^=e>>16; g+=d; e+=f;\n-                e^=f<<10; h+=e; f+=g;\n-                f^=g>>4;  a+=f; g+=h;\n-                g^=h<<8;  b+=g; h+=a;\n-                h^=a>>9;  c+=h; a+=b;\n-            }}\n-        );\n-\n-        do 4.times { mix!(); }\n-\n-        if use_rsl {\n-            macro_rules! memloop (\n-                ($arr:expr) => {{\n-                    for i in range_step(0u32, RAND_SIZE, 8) {\n-                        a+=$arr[i  ]; b+=$arr[i+1];\n-                        c+=$arr[i+2]; d+=$arr[i+3];\n-                        e+=$arr[i+4]; f+=$arr[i+5];\n-                        g+=$arr[i+6]; h+=$arr[i+7];\n-                        mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n-                    }\n-                }}\n-            );\n-\n-            memloop!(self.rsl);\n-            memloop!(self.mem);\n-        } else {\n-            for i in range_step(0u32, RAND_SIZE, 8) {\n-                mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n-            }\n-        }\n-\n-        self.isaac();\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        self.rng.next_u64()\n     }\n+}\n \n-    /// Refills the output buffer (`self.rsl`)\n-    #[inline]\n-    fn isaac(&mut self) {\n-        self.c += 1;\n-        // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n-\n-        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n-\n-        macro_rules! ind (($x:expr) => {\n-            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n-        });\n-        macro_rules! rngstep(\n-            ($j:expr, $shift:expr) => {{\n-                let base = $j;\n-                let mix = if $shift < 0 {\n-                    a >> -$shift as uint\n-                } else {\n-                    a << $shift as uint\n-                };\n-\n-                let x = self.mem[base  + mr_offset];\n-                a = (a ^ mix) + self.mem[base + m2_offset];\n-                let y = ind!(x) + a + b;\n-                self.mem[base + mr_offset] = y;\n-\n-                b = ind!(y >> RAND_SIZE_LEN) + x;\n-                self.rsl[base + mr_offset] = b;\n-            }}\n-        );\n-\n-        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in r.iter() {\n-            for i in range_step(0u, MIDPOINT, 4) {\n-                rngstep!(i + 0, 13);\n-                rngstep!(i + 1, -6);\n-                rngstep!(i + 2, 2);\n-                rngstep!(i + 3, -16);\n-            }\n-        }\n+impl<'self> SeedableRng<&'self [uint]> for StdRng {\n+    fn reseed(&mut self, seed: &'self [uint]) {\n+        // the internal RNG can just be seeded from the above\n+        // randomness.\n+        self.rng.reseed(unsafe {cast::transmute(seed)})\n+    }\n \n-        self.a = a;\n-        self.b = b;\n-        self.cnt = RAND_SIZE;\n+    fn from_seed(seed: &'self [uint]) -> StdRng {\n+        StdRng { rng: SeedableRng::from_seed(unsafe {cast::transmute(seed)}) }\n     }\n }\n \n-impl Rng for IsaacRng {\n-    #[inline]\n-    fn next(&mut self) -> u32 {\n-        if self.cnt == 0 {\n-            // make some more numbers\n-            self.isaac();\n-        }\n-        self.cnt -= 1;\n-        self.rsl[self.cnt]\n-    }\n+/// Create a weak random number generator with a default algorithm and seed.\n+///\n+/// It returns the fastest `Rng` algorithm currently available in Rust without\n+/// consideration for cryptography or security. If you require a specifically\n+/// seeded `Rng` for consistency over time you should pick one algorithm and\n+/// create the `Rng` yourself.\n+///\n+/// This will read randomness from the operating system to seed the\n+/// generator.\n+pub fn weak_rng() -> XorShiftRng {\n+    XorShiftRng::new()\n }\n \n /// An [Xorshift random number\n@@ -769,7 +607,7 @@ pub struct XorShiftRng {\n \n impl Rng for XorShiftRng {\n     #[inline]\n-    fn next(&mut self) -> u32 {\n+    fn next_u32(&mut self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -781,89 +619,123 @@ impl Rng for XorShiftRng {\n     }\n }\n \n+impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n+    /// Reseed an XorShiftRng. This will fail if `seed` is entirely 0.\n+    fn reseed(&mut self, seed: [u32, .. 4]) {\n+        assert!(!seed.iter().all(|&x| x == 0),\n+                \"XorShiftRng.reseed called with an all zero seed.\");\n+\n+        self.x = seed[0];\n+        self.y = seed[1];\n+        self.z = seed[2];\n+        self.w = seed[3];\n+    }\n+\n+    /// Create a new XorShiftRng. This will fail if `seed` is entirely 0.\n+    fn from_seed(seed: [u32, .. 4]) -> XorShiftRng {\n+        assert!(!seed.iter().all(|&x| x == 0),\n+                \"XorShiftRng::from_seed called with an all zero seed.\");\n+\n+        XorShiftRng {\n+            x: seed[0],\n+            y: seed[1],\n+            z: seed[2],\n+            w: seed[3]\n+        }\n+    }\n+}\n+\n impl XorShiftRng {\n     /// Create an xor shift random number generator with a random seed.\n     pub fn new() -> XorShiftRng {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        // generate seeds the same way as seed(), except we have a spceific size\n         let mut s = [0u8, ..16];\n         loop {\n-            do s.as_mut_buf |p, sz| {\n-                unsafe {\n-                    rustrt::rand_gen_seed(p, sz as size_t);\n-                }\n-            }\n+            let mut r = OSRng::new();\n+            r.fill_bytes(s);\n+\n             if !s.iter().all(|x| *x == 0) {\n                 break;\n             }\n         }\n-        let s: &[u32, ..4] = unsafe { cast::transmute(&s) };\n-        XorShiftRng::new_seeded(s[0], s[1], s[2], s[3])\n-    }\n-\n-    /**\n-     * Create a random number generator using the specified seed. A generator\n-     * constructed with a given seed will generate the same sequence of values\n-     * as all other generators constructed with the same seed.\n-     */\n-    pub fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n-        XorShiftRng {\n-            x: x,\n-            y: y,\n-            z: z,\n-            w: w,\n-        }\n+        let s: [u32, ..4] = unsafe { cast::transmute(s) };\n+        SeedableRng::from_seed(s)\n     }\n }\n \n-/// Create a new random seed.\n-pub fn seed() -> ~[u8] {\n-    #[fixed_stack_segment]; #[inline(never)];\n+/// Controls how the task-local RNG is reseeded.\n+struct TaskRngReseeder;\n \n-    unsafe {\n-        let n = RAND_SIZE * 4;\n-        let mut s = vec::from_elem(n as uint, 0_u8);\n-        do s.as_mut_buf |p, sz| {\n-            rustrt::rand_gen_seed(p, sz as size_t)\n-        }\n-        s\n+impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n+    fn reseed(&mut self, rng: &mut StdRng) {\n+        *rng = StdRng::new();\n     }\n }\n+static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n+/// The task-local RNG.\n+pub type TaskRng = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n \n // used to make space in TLS for a random number generator\n-local_data_key!(tls_rng_state: @@mut IsaacRng)\n+local_data_key!(TASK_RNG_KEY: @mut TaskRng)\n \n-/**\n- * Gives back a lazily initialized task-local random number generator,\n- * seeded by the system. Intended to be used in method chaining style, ie\n- * `task_rng().gen::<int>()`.\n- */\n-#[inline]\n-pub fn task_rng() -> @mut IsaacRng {\n-    let r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n+/// Retrieve the lazily-initialized task-local random number\n+/// generator, seeded by the system. Intended to be used in method\n+/// chaining style, e.g. `task_rng().gen::<int>()`.\n+///\n+/// The RNG provided will reseed itself from the operating system\n+/// after generating a certain amount of randomness.\n+///\n+/// The internal RNG used is platform and architecture dependent, even\n+/// if the operating system random number generator is rigged to give\n+/// the same sequence always. If absolute consistency is required,\n+/// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n+pub fn task_rng() -> @mut TaskRng {\n+    let r = local_data::get(TASK_RNG_KEY, |k| k.map(|&k| *k));\n     match r {\n         None => {\n-            let rng = @@mut IsaacRng::new_seeded(seed());\n-            local_data::set(tls_rng_state, rng);\n-            *rng\n+            let rng = @mut reseeding::ReseedingRng::new(StdRng::new(),\n+                                                        TASK_RNG_RESEED_THRESHOLD,\n+                                                        TaskRngReseeder);\n+            local_data::set(TASK_RNG_KEY, rng);\n+            rng\n         }\n-        Some(rng) => *rng\n+        Some(rng) => rng\n     }\n }\n \n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @mut R {\n     #[inline]\n-    fn next(&mut self) -> u32 {\n-        (**self).next()\n+    fn next_u32(&mut self) -> u32 {\n+        (**self).next_u32()\n+    }\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        (**self).next_u64()\n+    }\n+\n+    #[inline]\n+    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n+        (**self).fill_bytes(bytes);\n     }\n }\n \n-/**\n- * Returns a random value of a Rand type, using the task's random number\n- * generator.\n- */\n+/// Generate a random value using the task-local random number\n+/// generator.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand::random;\n+///\n+/// fn main() {\n+///     if random() {\n+///         let x = random();\n+///         println!(\"{}\", 2u * x);\n+///     } else {\n+///         println!(\"{}\", random::<float>());\n+///     }\n+/// }\n+/// ```\n #[inline]\n pub fn random<T: Rand>() -> T {\n     task_rng().gen()\n@@ -876,31 +748,11 @@ mod test {\n     use super::*;\n \n     #[test]\n-    fn test_rng_seeded() {\n-        let seed = seed();\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded_custom_seed() {\n-        // much shorter than generated seeds which are 1024 bytes\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n-    }\n+    fn test_fill_bytes_default() {\n+        let mut r = weak_rng();\n \n-    #[test]\n-    fn test_rng_seeded_custom_seed2() {\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        // Regression test that isaac is actually using the above vector\n-        let r = ra.next();\n-        debug2!(\"{:?}\", r);\n-        assert!(r == 890007737u32 // on x86_64\n-                     || r == 2935188040u32); // on x86\n+        let mut v = [0u8, .. 100];\n+        r.fill_bytes(v);\n     }\n \n     #[test]\n@@ -1070,6 +922,26 @@ mod test {\n             **e >= MIN_VAL && **e <= MAX_VAL\n         }));\n     }\n+\n+    #[test]\n+    fn test_std_rng_seeded() {\n+        let s = OSRng::new().gen_vec::<uint>(256);\n+        let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_std_rng_reseed() {\n+        let s = OSRng::new().gen_vec::<uint>(256);\n+        let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n+        let string1 = r.gen_ascii_str(100);\n+\n+        r.reseed(s);\n+\n+        let string2 = r.gen_ascii_str(100);\n+        assert_eq!(string1, string2);\n+    }\n }\n \n #[cfg(test)]\n@@ -1096,6 +968,24 @@ mod bench {\n         bh.bytes = size_of::<uint>() as u64;\n     }\n \n+    #[bench]\n+    fn rand_isaac64(bh: &mut BenchHarness) {\n+        let mut rng = Isaac64Rng::new();\n+        do bh.iter {\n+            rng.gen::<uint>();\n+        }\n+        bh.bytes = size_of::<uint>() as u64;\n+    }\n+\n+    #[bench]\n+    fn rand_std(bh: &mut BenchHarness) {\n+        let mut rng = StdRng::new();\n+        do bh.iter {\n+            rng.gen::<uint>();\n+        }\n+        bh.bytes = size_of::<uint>() as u64;\n+    }\n+\n     #[bench]\n     fn rand_shuffle_100(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();"}, {"sha": "4c8cf06c55e87052f089d93f35439795aa87caa5", "filename": "src/libstd/rand/os.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Interfaces to the operating system provided random number\n+//! generators.\n+\n+use rand::Rng;\n+use ops::Drop;\n+\n+#[cfg(unix)]\n+use rand::reader::ReaderRng;\n+#[cfg(unix)]\n+use rt::io::{file, Open, Read};\n+\n+#[cfg(windows)]\n+use cast;\n+#[cfg(windows)]\n+use libc::{c_long, DWORD, BYTE};\n+#[cfg(windows)]\n+type HCRYPTPROV = c_long;\n+// the extern functions imported from the runtime on Windows are\n+// implemented so that they either succeed or abort(), so we can just\n+// assume they work when we call them.\n+\n+/// A random number generator that retrieves randomness straight from\n+/// the operating system. On Unix-like systems this reads from\n+/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+///\n+/// This does not block.\n+#[cfg(unix)]\n+pub struct OSRng {\n+    priv inner: ReaderRng<file::FileStream>\n+}\n+/// A random number generator that retrieves randomness straight from\n+/// the operating system. On Unix-like systems this reads from\n+/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+///\n+/// This does not block.\n+#[cfg(windows)]\n+pub struct OSRng {\n+    priv hcryptprov: HCRYPTPROV\n+}\n+\n+impl OSRng {\n+    /// Create a new `OSRng`.\n+    #[cfg(unix)]\n+    pub fn new() -> OSRng {\n+        let reader = file::open(& &\"/dev/urandom\", Open, Read).expect(\"Error opening /dev/urandom\");\n+        let reader_rng = ReaderRng::new(reader);\n+\n+        OSRng { inner: reader_rng }\n+    }\n+\n+    /// Create a new `OSRng`.\n+    #[cfg(windows)]\n+    pub fn new() -> OSRng {\n+        externfn!(fn rust_win32_rand_acquire(phProv: *mut HCRYPTPROV))\n+\n+        let mut hcp = 0;\n+        unsafe {rust_win32_rand_acquire(&mut hcp)};\n+\n+        OSRng { hcryptprov: hcp }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl Rng for OSRng {\n+    fn next_u32(&mut self) -> u32 {\n+        self.inner.next_u32()\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        self.inner.next_u64()\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        self.inner.fill_bytes(v)\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl Rng for OSRng {\n+    fn next_u32(&mut self) -> u32 {\n+        let mut v = [0u8, .. 4];\n+        self.fill_bytes(v);\n+        unsafe { cast::transmute(v) }\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        let mut v = [0u8, .. 8];\n+        self.fill_bytes(v);\n+        unsafe { cast::transmute(v) }\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        externfn!(fn rust_win32_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD, pbBuffer: *mut BYTE))\n+\n+        do v.as_mut_buf |ptr, len| {\n+            unsafe {rust_win32_rand_gen(self.hcryptprov, len as DWORD, ptr)}\n+        }\n+    }\n+}\n+\n+impl Drop for OSRng {\n+    #[cfg(unix)]\n+    fn drop(&mut self) {\n+        // ensure that OSRng is not implicitly copyable on all\n+        // platforms, for consistency.\n+    }\n+\n+    #[cfg(windows)]\n+    fn drop(&mut self) {\n+        externfn!(fn rust_win32_rand_release(hProv: HCRYPTPROV))\n+\n+        unsafe {rust_win32_rand_release(self.hcryptprov)}\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rand::Rng;\n+\n+    #[test]\n+    fn test_os_rng() {\n+        let mut r = OSRng::new();\n+\n+        r.next_u32();\n+        r.next_u64();\n+\n+        let mut v = [0u8, .. 1000];\n+        r.fill_bytes(v);\n+    }\n+\n+    #[test]\n+    fn test_os_rng_tasks() {\n+        use task;\n+        use comm;\n+        use comm::{GenericChan, GenericPort};\n+        use option::{None, Some};\n+        use iter::{Iterator, range};\n+        use vec::{ImmutableVector, OwnedVector};\n+\n+        let mut chans = ~[];\n+        for _ in range(0, 20) {\n+            let (p, c) = comm::stream();\n+            chans.push(c);\n+            do task::spawn_with(p) |p| {\n+                // wait until all the tasks are ready to go.\n+                p.recv();\n+\n+                // deschedule to attempt to interleave things as much\n+                // as possible (XXX: is this a good test?)\n+                let mut r = OSRng::new();\n+                task::deschedule();\n+                let mut v = [0u8, .. 1000];\n+\n+                for _ in range(0, 100) {\n+                    r.next_u32();\n+                    task::deschedule();\n+                    r.next_u64();\n+                    task::deschedule();\n+                    r.fill_bytes(v);\n+                    task::deschedule();\n+                }\n+            }\n+        }\n+\n+        // start all the tasks\n+        for c in chans.iter() {\n+            c.send(())\n+        }\n+    }\n+}"}, {"sha": "aad0d4e861c58c6f5f06e72e5bf8407ed3c88015", "filename": "src/libstd/rand/rand_impls.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frand_impls.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -0,0 +1,224 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The implementations of `Rand` for the built-in types.\n+\n+use char;\n+use int;\n+use option::{Option, Some, None};\n+use rand::{Rand,Rng};\n+use uint;\n+\n+impl Rand for int {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> int {\n+        if int::bits == 32 {\n+            rng.gen::<i32>() as int\n+        } else {\n+            rng.gen::<i64>() as int\n+        }\n+    }\n+}\n+\n+impl Rand for i8 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i8 {\n+        rng.next_u32() as i8\n+    }\n+}\n+\n+impl Rand for i16 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i16 {\n+        rng.next_u32() as i16\n+    }\n+}\n+\n+impl Rand for i32 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i32 {\n+        rng.next_u32() as i32\n+    }\n+}\n+\n+impl Rand for i64 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> i64 {\n+        rng.next_u64() as i64\n+    }\n+}\n+\n+impl Rand for uint {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> uint {\n+        if uint::bits == 32 {\n+            rng.gen::<u32>() as uint\n+        } else {\n+            rng.gen::<u64>() as uint\n+        }\n+    }\n+}\n+\n+impl Rand for u8 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u8 {\n+        rng.next_u32() as u8\n+    }\n+}\n+\n+impl Rand for u16 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u16 {\n+        rng.next_u32() as u16\n+    }\n+}\n+\n+impl Rand for u32 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u32 {\n+        rng.next_u32()\n+    }\n+}\n+\n+impl Rand for u64 {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> u64 {\n+        rng.next_u64()\n+    }\n+}\n+\n+impl Rand for f32 {\n+    /// A random `f32` in the range `[0, 1)`, using 24 bits of\n+    /// precision.\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> f32 {\n+        // using any more than 24 bits will cause (e.g.) 0xffff_ffff\n+        // to correspond to 1 exactly, so we need to drop 8 to\n+        // guarantee the open end.\n+\n+        static SCALE: f32 = (1u32 << 24) as f32;\n+        (rng.next_u32() >> 8) as f32 / SCALE\n+    }\n+}\n+\n+impl Rand for f64 {\n+    /// A random `f64` in the range `[0, 1)`, using 53 bits of\n+    /// precision.\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> f64 {\n+        // as for f32, but using more bits.\n+\n+        static SCALE: f64 = (1u64 << 53) as f64;\n+        (rng.next_u64() >> 11) as f64 / SCALE\n+    }\n+}\n+\n+\n+impl Rand for char {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> char {\n+        // a char is 21 bits\n+        static CHAR_MASK: u32 = 0x001f_ffff;\n+        loop {\n+            // Rejection sampling. About 0.2% of numbers with at most\n+            // 21-bits are invalid codepoints (surrogates), so this\n+            // will succeed first go almost every time.\n+            match char::from_u32(rng.next_u32() & CHAR_MASK) {\n+                Some(c) => return c,\n+                None => {}\n+            }\n+        }\n+    }\n+}\n+\n+impl Rand for bool {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> bool {\n+        rng.gen::<u8>() & 1 == 1\n+    }\n+}\n+\n+macro_rules! tuple_impl {\n+    // use variables to indicate the arity of the tuple\n+    ($($tyvar:ident),* ) => {\n+        // the trailing commas are for the 1 tuple\n+        impl<\n+            $( $tyvar : Rand ),*\n+            > Rand for ( $( $tyvar ),* , ) {\n+\n+            #[inline]\n+            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n+                (\n+                    // use the $tyvar's to get the appropriate number of\n+                    // repeats (they're not actually needed)\n+                    $(\n+                        _rng.gen::<$tyvar>()\n+                    ),*\n+                    ,\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+impl Rand for () {\n+    #[inline]\n+    fn rand<R: Rng>(_: &mut R) -> () { () }\n+}\n+tuple_impl!{A}\n+tuple_impl!{A, B}\n+tuple_impl!{A, B, C}\n+tuple_impl!{A, B, C, D}\n+tuple_impl!{A, B, C, D, E}\n+tuple_impl!{A, B, C, D, E, F}\n+tuple_impl!{A, B, C, D, E, F, G}\n+tuple_impl!{A, B, C, D, E, F, G, H}\n+tuple_impl!{A, B, C, D, E, F, G, H, I}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n+\n+impl<T:Rand> Rand for Option<T> {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n+        if rng.gen() {\n+            Some(rng.gen())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<T: Rand> Rand for ~T {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n+}\n+\n+impl<T: Rand + 'static> Rand for @T {\n+    #[inline]\n+    fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rand::Rng;\n+    struct ConstantRng(u64);\n+    impl Rng for ConstantRng {\n+        fn next_u32(&mut self) -> u32 {\n+            (**self) as u32\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            **self\n+        }\n+    }\n+    fn floating_point_edge_cases() {\n+        // the test for exact equality is correct here.\n+        assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0)\n+        assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0)\n+    }\n+}"}, {"sha": "961a5b2cd2869cdf49c652d7ff86118fcc772efa", "filename": "src/libstd/rand/reader.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A wrapper around any Reader to treat it as an RNG.\n+\n+use option::{Some, None};\n+use rt::io::Reader;\n+use rt::io::ReaderByteConversions;\n+\n+use rand::Rng;\n+\n+/// An RNG that reads random bytes straight from a `Reader`. This will\n+/// work best with an infinite reader, but this is not required.\n+///\n+/// It will fail if it there is insufficient data to fulfill a request.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand::{reader, Rng};\n+/// use std::rt::io::mem;\n+///\n+/// fn main() {\n+///     let mut rng = reader::ReaderRng::new(mem::MemReader::new(~[1,2,3,4,5,6,7,8]));\n+///     println!(\"{:x}\", rng.gen::<uint>());\n+/// }\n+/// ```\n+pub struct ReaderRng<R> {\n+    priv reader: R\n+}\n+\n+impl<R: Reader> ReaderRng<R> {\n+    /// Create a new `ReaderRng` from a `Reader`.\n+    pub fn new(r: R) -> ReaderRng<R> {\n+        ReaderRng {\n+            reader: r\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Rng for ReaderRng<R> {\n+    fn next_u32(&mut self) -> u32 {\n+        // This is designed for speed: reading a LE integer on a LE\n+        // platform just involves blitting the bytes into the memory\n+        // of the u32, similarly for BE on BE; avoiding byteswapping.\n+        if cfg!(target_endian=\"little\") {\n+            self.reader.read_le_u32_()\n+        } else {\n+            self.reader.read_be_u32_()\n+        }\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        // see above for explanation.\n+        if cfg!(target_endian=\"little\") {\n+            self.reader.read_le_u64_()\n+        } else {\n+            self.reader.read_be_u64_()\n+        }\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        if v.len() == 0 { return }\n+        match self.reader.read(v) {\n+            Some(n) if n == v.len() => return,\n+            Some(n) => fail2!(\"ReaderRng.fill_bytes could not fill buffer: \\\n+                              read {} out of {} bytes.\", n, v.len()),\n+            None => fail2!(\"ReaderRng.fill_bytes reached eof.\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::io::mem::MemReader;\n+    use cast;\n+\n+    #[test]\n+    fn test_reader_rng_u64() {\n+        // transmute from the target to avoid endianness concerns.\n+        let v = ~[1u64, 2u64, 3u64];\n+        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+\n+        assert_eq!(rng.next_u64(), 1);\n+        assert_eq!(rng.next_u64(), 2);\n+        assert_eq!(rng.next_u64(), 3);\n+    }\n+    #[test]\n+    fn test_reader_rng_u32() {\n+        // transmute from the target to avoid endianness concerns.\n+        let v = ~[1u32, 2u32, 3u32];\n+        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+\n+        assert_eq!(rng.next_u32(), 1);\n+        assert_eq!(rng.next_u32(), 2);\n+        assert_eq!(rng.next_u32(), 3);\n+    }\n+    #[test]\n+    fn test_reader_rng_fill_bytes() {\n+        let v = [1u8, 2, 3, 4, 5, 6, 7, 8];\n+        let mut w = [0u8, .. 8];\n+\n+        let mut rng = ReaderRng::new(MemReader::new(v.to_owned()));\n+        rng.fill_bytes(w);\n+\n+        assert_eq!(v, w);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_reader_rng_insufficient_bytes() {\n+        let mut rng = ReaderRng::new(MemReader::new(~[]));\n+        let mut v = [0u8, .. 3];\n+        rng.fill_bytes(v);\n+    }\n+}"}, {"sha": "3b4919392fc2995bab8f010a5f244b1acf4385fb", "filename": "src/libstd/rand/reseeding.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freseeding.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -0,0 +1,204 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A wrapper around another RNG that reseeds it after it\n+//! generates a certain number of random bytes.\n+\n+use rand::{Rng, SeedableRng};\n+use default::Default;\n+\n+/// How many bytes of entropy the underling RNG is allowed to generate\n+/// before it is reseeded.\n+static DEFAULT_GENERATION_THRESHOLD: uint = 32 * 1024;\n+\n+/// A wrapper around any RNG which reseeds the underlying RNG after it\n+/// has generated a certain number of random bytes.\n+pub struct ReseedingRng<R, Rsdr> {\n+    priv rng: R,\n+    priv generation_threshold: uint,\n+    priv bytes_generated: uint,\n+    /// Controls the behaviour when reseeding the RNG.\n+    reseeder: Rsdr\n+}\n+\n+impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n+    /// Create a new `ReseedingRng` with the given parameters.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `rng`: the random number generator to use.\n+    /// * `generation_threshold`: the number of bytes of entropy at which to reseed the RNG.\n+    /// * `reseeder`: the reseeding object to use.\n+    pub fn new(rng: R, generation_threshold: uint, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n+        ReseedingRng {\n+            rng: rng,\n+            generation_threshold: generation_threshold,\n+            bytes_generated: 0,\n+            reseeder: reseeder\n+        }\n+    }\n+\n+    /// Reseed the internal RNG if the number of bytes that have been\n+    /// generated exceed the threshold.\n+    pub fn reseed_if_necessary(&mut self) {\n+        if self.bytes_generated >= self.generation_threshold {\n+            self.reseeder.reseed(&mut self.rng);\n+            self.bytes_generated = 0;\n+        }\n+    }\n+}\n+\n+\n+impl<R: Rng, Rsdr: Reseeder<R>> Rng for ReseedingRng<R, Rsdr> {\n+    fn next_u32(&mut self) -> u32 {\n+        self.reseed_if_necessary();\n+        self.bytes_generated += 4;\n+        self.rng.next_u32()\n+    }\n+\n+    fn next_u64(&mut self) -> u64 {\n+        self.reseed_if_necessary();\n+        self.bytes_generated += 8;\n+        self.rng.next_u64()\n+    }\n+\n+    fn fill_bytes(&mut self, dest: &mut [u8]) {\n+        self.reseed_if_necessary();\n+        self.bytes_generated += dest.len();\n+        self.fill_bytes(dest)\n+    }\n+}\n+\n+impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R>>\n+     SeedableRng<(Rsdr, S)> for ReseedingRng<R, Rsdr> {\n+    fn reseed(&mut self, (rsdr, seed): (Rsdr, S)) {\n+        self.rng.reseed(seed);\n+        self.reseeder = rsdr;\n+        self.bytes_generated = 0;\n+    }\n+    /// Create a new `ReseedingRng` from the given reseeder and\n+    /// seed. This uses a default value for `generation_threshold`.\n+    fn from_seed((rsdr, seed): (Rsdr, S)) -> ReseedingRng<R, Rsdr> {\n+        ReseedingRng {\n+            rng: SeedableRng::from_seed(seed),\n+            generation_threshold: DEFAULT_GENERATION_THRESHOLD,\n+            bytes_generated: 0,\n+            reseeder: rsdr\n+        }\n+    }\n+}\n+\n+/// Something that can be used to reseed an RNG via `ReseedingRng`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::{Rng, SeedableRng};\n+/// use std::rand::reseeding::{Reseeder, ReseedingRng};\n+///\n+/// struct TickTockReseeder { tick: bool }\n+/// impl Reseeder<rand::StdRng> for TickTockReseeder {\n+///     fn reseed(&mut self, rng: &mut rand::StdRng) {\n+///         let val = if self.tick {0} else {1};\n+///         rng.reseed(&[val]);\n+///         self.tick = !self.tick;\n+///     }\n+/// }\n+/// fn main() {\n+///     let rsdr = TickTockReseeder { tick: true };\n+///     let mut rng = ReseedingRng::new(rand::StdRng::new(), 10, rsdr);\n+///\n+///     // this will repeat, because it gets reseeded very regularly.\n+///     println(rng.gen_ascii_str(100));\n+/// }\n+///\n+/// ```\n+pub trait Reseeder<R> {\n+    /// Reseed the given RNG.\n+    fn reseed(&mut self, rng: &mut R);\n+}\n+\n+/// Reseed an RNG using a `Default` instance. This reseeds by\n+/// replacing the RNG with the result of a `Default::default` call.\n+pub struct ReseedWithDefault;\n+\n+impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n+    fn reseed(&mut self, rng: &mut R) {\n+        *rng = Default::default();\n+    }\n+}\n+impl Default for ReseedWithDefault {\n+    fn default() -> ReseedWithDefault { ReseedWithDefault }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rand::{SeedableRng, Rng};\n+    use default::Default;\n+    use iter::range;\n+    use option::{None, Some};\n+\n+    struct Counter {\n+        i: u32\n+    }\n+\n+    impl Rng for Counter {\n+        fn next_u32(&mut self) -> u32 {\n+            self.i += 1;\n+            // very random\n+            self.i - 1\n+        }\n+    }\n+    impl Default for Counter {\n+        fn default() -> Counter {\n+            Counter { i: 0 }\n+        }\n+    }\n+    impl SeedableRng<u32> for Counter {\n+        fn reseed(&mut self, seed: u32) {\n+            self.i = seed;\n+        }\n+        fn from_seed(seed: u32) -> Counter {\n+            Counter { i: seed }\n+        }\n+    }\n+    type MyRng = ReseedingRng<Counter, ReseedWithDefault>;\n+\n+    #[test]\n+    fn test_reseeding() {\n+        let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n+\n+        let mut i = 0;\n+        for _ in range(0, 1000) {\n+            assert_eq!(rs.next_u32(), i % 100);\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rng_seeded() {\n+        let mut ra: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n+        let mut rb: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_rng_reseed() {\n+        let mut r: MyRng = SeedableRng::from_seed((ReseedWithDefault, 3));\n+        let string1 = r.gen_ascii_str(100);\n+\n+        r.reseed((ReseedWithDefault, 3));\n+\n+        let string2 = r.gen_ascii_str(100);\n+        assert_eq!(string1, string2);\n+    }\n+}"}, {"sha": "ee43ced44ab255e82ed6424946b8d92a6ba26f05", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -140,7 +140,7 @@ impl Scheduler {\n             cleanup_job: None,\n             run_anything: run_anything,\n             friend_handle: friend,\n-            rng: XorShiftRng::new(),\n+            rng: new_sched_rng(),\n             idle_callback: None,\n             yield_check_count: 0,\n             steal_for_yield: false\n@@ -844,6 +844,54 @@ impl ClosureConverter for UnsafeTaskReceiver {\n     fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n }\n \n+// On unix, we read randomness straight from /dev/urandom, but the\n+// default constructor of an XorShiftRng does this via io::file, which\n+// relies on the scheduler existing, so we have to manually load\n+// randomness. Windows has its own C API for this, so we don't need to\n+// worry there.\n+#[cfg(windows)]\n+fn new_sched_rng() -> XorShiftRng {\n+    XorShiftRng::new()\n+}\n+#[cfg(unix)]\n+#[fixed_stack_segment] #[inline(never)]\n+fn new_sched_rng() -> XorShiftRng {\n+    use libc;\n+    use sys;\n+    use c_str::ToCStr;\n+    use vec::MutableVector;\n+    use iter::Iterator;\n+    use rand::SeedableRng;\n+\n+    let fd = do \"/dev/urandom\".with_c_str |name| {\n+        unsafe { libc::open(name, libc::O_RDONLY, 0) }\n+    };\n+    if fd == -1 {\n+        rtabort!(\"could not open /dev/urandom for reading.\")\n+    }\n+\n+    let mut seeds = [0u32, .. 4];\n+    let size = sys::size_of_val(&seeds);\n+    loop {\n+        let nbytes = do seeds.as_mut_buf |buf, _| {\n+            unsafe {\n+                libc::read(fd,\n+                           buf as *mut libc::c_void,\n+                           size as libc::size_t)\n+            }\n+        };\n+        rtassert!(nbytes as uint == size);\n+\n+        if !seeds.iter().all(|x| *x == 0) {\n+            break;\n+        }\n+    }\n+\n+    unsafe {libc::close(fd);}\n+\n+    SeedableRng::from_seed(seeds)\n+}\n+\n #[cfg(test)]\n mod test {\n     extern mod extra;"}, {"sha": "48b894f51e095a6842ad38ce974fe7547623ccb0", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -509,7 +509,7 @@ mod test {\n         do run_in_newsched_task() {\n             use rand::{rng, Rng};\n             let mut r = rng();\n-            let _ = r.next();\n+            let _ = r.next_u32();\n         }\n     }\n "}, {"sha": "d1d4286a7c62959228ee5b5ffe5afbaf82813f82", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -15,7 +15,6 @@\n #include \"sync/lock_and_signal.h\"\n #include \"memory_region.h\"\n #include \"boxed_region.h\"\n-#include \"rust_rng.h\"\n #include \"vg/valgrind.h\"\n #include \"sp.h\"\n \n@@ -69,11 +68,6 @@ rust_env_pairs() {\n }\n #endif\n \n-extern \"C\" CDECL void\n-rand_gen_seed(uint8_t* dest, size_t size) {\n-    rng_gen_seed(dest, size);\n-}\n-\n extern \"C\" CDECL char*\n #if defined(__WIN32__)\n rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n@@ -654,6 +648,62 @@ rust_unset_sigprocmask() {\n \n #endif\n \n+#if defined(__WIN32__)\n+void\n+win32_require(LPCTSTR fn, BOOL ok) {\n+    if (!ok) {\n+        LPTSTR buf;\n+        DWORD err = GetLastError();\n+        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+                      FORMAT_MESSAGE_FROM_SYSTEM |\n+                      FORMAT_MESSAGE_IGNORE_INSERTS,\n+                      NULL, err,\n+                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+                      (LPTSTR) &buf, 0, NULL );\n+        fprintf(stderr, \"%s failed with error %ld: %s\", fn, err, buf);\n+        LocalFree((HLOCAL)buf);\n+        abort();\n+    }\n+}\n+\n+extern \"C\" CDECL void\n+rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n+    win32_require\n+        (_T(\"CryptAcquireContext\"),\n+         CryptAcquireContext(phProv, NULL, NULL, PROV_RSA_FULL,\n+                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n+\n+}\n+extern \"C\" CDECL void\n+rust_win32_rand_gen(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer) {\n+    win32_require\n+        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, dwLen, pbBuffer));\n+}\n+extern \"C\" CDECL void\n+rust_win32_rand_release(HCRYPTPROV hProv) {\n+    win32_require\n+        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n+}\n+\n+#else\n+\n+// these symbols are listed in rustrt.def.in, so they need to exist; but they\n+// should never be called.\n+\n+extern \"C\" CDECL void\n+rust_win32_rand_acquire() {\n+    abort();\n+}\n+extern \"C\" CDECL void\n+rust_win32_rand_gen() {\n+    abort();\n+}\n+extern \"C\" CDECL void\n+rust_win32_rand_release() {\n+    abort();\n+}\n+\n+#endif\n //\n // Local Variables:\n // mode: C++"}, {"sha": "89754f94b7096842e1076a92229b044762e34c19", "filename": "src/rt/rust_rng.cpp", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e505d4c3535d6e0af1070b1b50ec8db4c2eca827/src%2Frt%2Frust_rng.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e505d4c3535d6e0af1070b1b50ec8db4c2eca827/src%2Frt%2Frust_rng.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.cpp?ref=e505d4c3535d6e0af1070b1b50ec8db4c2eca827", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"rust_globals.h\"\n-#include \"rust_rng.h\"\n-#include \"rust_util.h\"\n-\n-\n-#ifdef __WIN32__\n-void\n-win32_require(LPCTSTR fn, BOOL ok) {\n-    if (!ok) {\n-        LPTSTR buf;\n-        DWORD err = GetLastError();\n-        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-                      FORMAT_MESSAGE_FROM_SYSTEM |\n-                      FORMAT_MESSAGE_IGNORE_INSERTS,\n-                      NULL, err,\n-                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-                      (LPTSTR) &buf, 0, NULL );\n-        fprintf(stderr, \"%s failed with error %ld: %s\", fn, err, buf);\n-        LocalFree((HLOCAL)buf);\n-        abort();\n-    }\n-}\n-#endif\n-\n-void\n-rng_gen_seed(uint8_t* dest, size_t size) {\n-#ifdef __WIN32__\n-    HCRYPTPROV hProv;\n-    win32_require\n-        (_T(\"CryptAcquireContext\"),\n-         CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n-                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-    win32_require\n-        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, size, (BYTE*) dest));\n-    win32_require\n-        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n-#else\n-    int fd = open(\"/dev/urandom\", O_RDONLY);\n-    if (fd == -1) {\n-        fprintf(stderr, \"error opening /dev/urandom: %s\", strerror(errno));\n-        abort();\n-    }\n-    size_t amount = 0;\n-    do {\n-        ssize_t ret = read(fd, dest+amount, size-amount);\n-        if (ret < 0) {\n-            fprintf(stderr, \"error reading /dev/urandom: %s\", strerror(errno));\n-            abort();\n-        }\n-        else if (ret == 0) {\n-            fprintf(stderr, \"somehow hit eof reading from /dev/urandom\");\n-            abort();\n-        }\n-        amount += (size_t)ret;\n-    } while (amount < size);\n-    int ret = close(fd);\n-    if (ret != 0) {\n-        fprintf(stderr, \"error closing /dev/urandom: %s\", strerror(errno));\n-        // FIXME #3697: Why does this fail sometimes?\n-        // abort();\n-    }\n-#endif\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "08335a6f73f79ab777bd6bd1ba71c66e710cfb36", "filename": "src/rt/rust_rng.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e505d4c3535d6e0af1070b1b50ec8db4c2eca827/src%2Frt%2Frust_rng.h", "raw_url": "https://github.com/rust-lang/rust/raw/e505d4c3535d6e0af1070b1b50ec8db4c2eca827/src%2Frt%2Frust_rng.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.h?ref=e505d4c3535d6e0af1070b1b50ec8db4c2eca827", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_RNG_H\n-#define RUST_RNG_H\n-\n-void rng_gen_seed(uint8_t* dest, size_t size);\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-\n-#endif"}, {"sha": "30f60c662e991c797fc436178fa605a47f2390d9", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -9,7 +9,6 @@ rust_localtime\n rust_timegm\n rust_mktime\n precise_time_ns\n-rand_gen_seed\n rust_path_is_dir\n rust_path_exists\n rust_get_stdin\n@@ -23,6 +22,9 @@ rust_log_console_off\n rust_should_log_console\n rust_unset_sigprocmask\n rust_env_pairs\n+rust_win32_rand_acquire\n+rust_win32_rand_gen\n+rust_win32_rand_release\n upcall_rust_personality\n upcall_call_shim_on_c_stack\n upcall_call_shim_on_rust_stack"}, {"sha": "2d209e40e424942a0c7cd4d20ee0ae383219b2ec", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -15,7 +15,7 @@ use extra::treemap::TreeMap;\n use std::hashmap::{HashMap, HashSet};\n use std::io;\n use std::os;\n-use std::rand::Rng;\n+use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::trie::TrieMap;\n use std::uint;\n use std::vec;\n@@ -106,10 +106,10 @@ fn main() {\n     let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let mut rng = std::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n+        let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n-            let next = rng.next() as uint;\n+            let next = rng.gen();\n             if set.insert(next) {\n                 rand.push(next);\n             }"}, {"sha": "b9a8e74668fa9683dadb99efe31b2ae5e1610d91", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -60,7 +60,7 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n                 for _ in range(0, num_keys) {\n-                    set.insert((rng.next() as uint) % rand_cap);\n+                    set.insert(rng.gen::<uint>() % rand_cap);\n                 }\n             }\n         }\n@@ -102,7 +102,7 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n                 for _ in range(0, num_keys) {\n-                    let s = (rng.next() as uint).to_str();\n+                    let s = rng.gen::<uint>().to_str();\n                     set.insert(s);\n                 }\n             }\n@@ -163,11 +163,11 @@ fn main() {\n         }\n     };\n \n-    let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let max = 200000;\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n             let s: HashSet<uint> = HashSet::new();\n@@ -181,7 +181,7 @@ fn main() {\n     }\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n             let s: TreeSet<uint> = TreeSet::new();\n@@ -195,7 +195,7 @@ fn main() {\n     }\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || BitvSet::new());\n         write_results(\"extra::bitv::BitvSet\", &results);"}, {"sha": "53da752fdc4faa0bcedd48df40d0bfdefc22bee4", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -76,7 +76,7 @@ fn make_random_fasta(wr: @io::Writer,\n     wr.write_line(~\">\" + id + \" \" + desc);\n     let mut rng = rand::rng();\n     let rng = @mut MyRandom {\n-        last: rng.next()\n+        last: rng.gen()\n     };\n     let mut op: ~str = ~\"\";\n     for _ in range(0u, n as uint) {"}, {"sha": "a5a67ede98c0de1658f7ba475ae1d97243d05a67", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f647ccc79c38c1f80dbdb697900b2ba97e293263/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=f647ccc79c38c1f80dbdb697900b2ba97e293263", "patch": "@@ -69,8 +69,8 @@ pub fn main() {\n     let mut rng = rand::rng();\n     for f in fns.iter() {\n         let f = *f;\n-        let sz = rng.next() % 256u32 + 256u32;\n-        let frame_backoff = rng.next() % 10u32 + 1u32;\n+        let sz = rng.gen::<u32>() % 256u32 + 256u32;\n+        let frame_backoff = rng.gen::<u32>() % 10u32 + 1u32;\n         task::try(|| runtest(f, frame_backoff) );\n     }\n }"}]}