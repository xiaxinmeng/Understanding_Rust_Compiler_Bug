{"sha": "734bdc656a6fae7a2c1f5722de4c1f9611bc28b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNGJkYzY1NmE2ZmFlN2EyYzFmNTcyMmRlNGMxZjk2MTFiYzI4YjU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T14:22:44Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T15:24:30Z"}, "message": "copyedits: functions", "tree": {"sha": "495a953a048fe9f1296415566602c3674b69b140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495a953a048fe9f1296415566602c3674b69b140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5", "html_url": "https://github.com/rust-lang/rust/commit/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f9ddb878992a9a4edd2667423c29b129ce4301", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f9ddb878992a9a4edd2667423c29b129ce4301", "html_url": "https://github.com/rust-lang/rust/commit/e4f9ddb878992a9a4edd2667423c29b129ce4301"}], "stats": {"total": 136, "additions": 85, "deletions": 51}, "files": [{"sha": "67ee91b479e5153e777c74648b4db7f65983c48c", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 85, "deletions": 51, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/734bdc656a6fae7a2c1f5722de4c1f9611bc28b5/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=734bdc656a6fae7a2c1f5722de4c1f9611bc28b5", "patch": "@@ -1,31 +1,31 @@\n % Functions\n \n-You've already seen one function so far, the `main` function:\n+Every Rust program has at least one function, the `main` function:\n \n ```rust\n fn main() {\n }\n ```\n \n This is the simplest possible function declaration. As we mentioned before,\n-`fn` says \"this is a function,\" followed by the name, some parentheses because\n+`fn` says \u2018this is a function\u2019, followed by the name, some parentheses because\n this function takes no arguments, and then some curly braces to indicate the\n-body. Here's a function named `foo`:\n+body. Here\u2019s a function named `foo`:\n \n ```rust\n fn foo() {\n }\n ```\n \n-So, what about taking arguments? Here's a function that prints a number:\n+So, what about taking arguments? Here\u2019s a function that prints a number:\n \n ```rust\n fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n \n-Here's a complete program that uses `print_number`:\n+Here\u2019s a complete program that uses `print_number`:\n \n ```rust\n fn main() {\n@@ -40,7 +40,7 @@ fn print_number(x: i32) {\n As you can see, function arguments work very similar to `let` declarations:\n you add a type to the argument name, after a colon.\n \n-Here's a complete program that adds two numbers together and prints them:\n+Here\u2019s a complete program that adds two numbers together and prints them:\n \n ```rust\n fn main() {\n@@ -58,7 +58,7 @@ as when you declare it.\n Unlike `let`, you _must_ declare the types of function arguments. This does\n not work:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_sum(x, y) {\n     println!(\"sum is: {}\", x + y);\n }\n@@ -67,8 +67,8 @@ fn print_sum(x, y) {\n You get this error:\n \n ```text\n-hello.rs:5:18: 5:19 expected one of `!`, `:`, or `@`, found `)`\n-hello.rs:5 fn print_number(x, y) {\n+expected one of `!`, `:`, or `@`, found `)`\n+fn print_number(x, y) {\n ```\n \n This is a deliberate design decision. While full-program inference is possible,\n@@ -77,7 +77,7 @@ types explicitly is a best-practice. We agree that forcing functions to declare\n types while allowing for inference inside of function bodies is a wonderful\n sweet spot between full inference and no inference.\n \n-What about returning a value? Here's a function that adds one to an integer:\n+What about returning a value? Here\u2019s a function that adds one to an integer:\n \n ```rust\n fn add_one(x: i32) -> i32 {\n@@ -86,11 +86,11 @@ fn add_one(x: i32) -> i32 {\n ```\n \n Rust functions return exactly one value, and you declare the type after an\n-\"arrow,\" which is a dash (`-`) followed by a greater-than sign (`>`).\n+\u2018arrow\u2019, which is a dash (`-`) followed by a greater-than sign (`>`). The last\n+line of a function determines what it returns. You\u2019ll note the lack of a\n+semicolon here. If we added it in:\n \n-You'll note the lack of a semicolon here. If we added it in:\n-\n-```{rust,ignore}\n+```rust,ignore\n fn add_one(x: i32) -> i32 {\n     x + 1;\n }\n@@ -109,60 +109,99 @@ help: consider removing this semicolon:\n           ^\n ```\n \n-Remember our earlier discussions about semicolons and `()`? Our function claims\n-to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n-realizes this probably isn't what we want, and suggests removing the semicolon.\n+This reveals two interesting things about Rust: it is an expression-based\n+language, and semicolons are different from semicolons in other \u2018curly brace\n+and semicolon\u2019-based languages. These two things are related.\n \n-This is very much like our `if` statement before: the result of the block\n-(`{}`) is the value of the expression. Other expression-oriented languages,\n-such as Ruby, work like this, but it's a bit unusual in the systems programming\n-world. When people first learn about this, they usually assume that it\n-introduces bugs. But because Rust's type system is so strong, and because unit\n-is its own unique type, we have never seen an issue where adding or removing a\n-semicolon in a return position would cause a bug.\n+## Expressions vs. Statements\n \n-But what about early returns? Rust does have a keyword for that, `return`:\n+Rust is primarily an expression-based language. There are only two kinds of\n+statements, and everything else is an expression.\n \n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+So what's the difference? Expressions return a value, and statements do not.\n+That\u2019s why we end up with \u2018not all control paths return a value\u2019 here: the\n+statement `x + 1;` doesn\u2019t return a value. There are two kinds of statements in\n+Rust: \u2018declaration statements\u2019 and \u2018expression statements\u2019. Everything else is\n+an expression. Let\u2019s talk about expression statements first.\n+\n+In some languages, variable bindings can be written as expressions, not just\n+statements. Like Ruby:\n+\n+```ruby\n+x = y = 5\n+```\n+\n+In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n+following will produce a compile-time error:\n+\n+```ignore\n+let x = (let y = 5); // expected identifier, found keyword `let`\n+```\n+\n+The compiler is telling us here that it was expecting to see the beginning of\n+an expression, and a `let` can only begin a statement, not an expression.\n+\n+Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n+expression, although its value is not particularly useful. Unlike other\n+languages where an assignment evaluates to the assigned value (e.g. `5` in the\n+previous example), in Rust the value of an assignment is an empty tuple `()`:\n+\n+```\n+let mut y = 5;\n+\n+let x = (y = 6);  // x has the value `()`, not `6`\n+```\n+\n+The second kind of statement in Rust is the *expression statement*. Its\n+purpose is to turn any expression into a statement. In practical terms, Rust's\n+grammar expects statements to follow other statements. This means that you use\n+semicolons to separate expressions from each other. This means that Rust\n+looks a lot like most other languages that require you to use semicolons\n+at the end of every line, and you will see semicolons at the end of almost\n+every line of Rust code you see.\n \n+What is this exception that makes us say \"almost\"? You saw it already, in this\n+code:\n+\n+```rust\n+fn add_one(x: i32) -> i32 {\n     x + 1\n }\n ```\n \n-Using a `return` as the last line of a function works, but is considered poor\n-style:\n+Our function claims to return an `i32`, but with a semicolon, it would return\n+`()` instead. Rust realizes this probably isn\u2019t what we want, and suggests\n+removing the semicolon in the error we saw before.\n+\n+## Early returns\n+\n+But what about early returns? Rust does have a keyword for that, `return`:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+    return x;\n \n-    return x + 1;\n+    // we never run this code!\n+    x + 1\n }\n ```\n \n-The previous definition without `return` may look a bit strange if you haven't\n-worked in an expression-based language before, but it becomes intuitive over\n-time. If this were production code, we wouldn't write it in that way anyway,\n-we'd write this:\n+Using a `return` as the last line of a function works, but is considered poor\n+style:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 {\n-        x\n-    } else {\n-        x + 1\n-    }\n+    return x + 1;\n }\n ```\n \n-Because `if` is an expression, and it's the only expression in this function,\n-the value will be the result of the `if`.\n+The previous definition without `return` may look a bit strange if you haven\u2019t\n+worked in an expression-based language before, but it becomes intuitive over\n+time.\n \n ## Diverging functions\n \n-Rust has some special syntax for 'diverging functions', which are functions that\n+Rust has some special syntax for \u2018diverging functions\u2019, which are functions that\n do not return:\n \n ```\n@@ -171,23 +210,18 @@ fn diverges() -> ! {\n }\n ```\n \n-`panic!` is a macro, similar to `println!()` that we've already seen. Unlike\n+`panic!` is a macro, similar to `println!()` that we\u2019ve already seen. Unlike\n `println!()`, `panic!()` causes the current thread of execution to crash with\n the given message.\n \n Because this function will cause a crash, it will never return, and so it has\n-the type '`!`', which is read \"diverges.\" A diverging function can be used\n+the type \u2018`!`\u2019, which is read \u2018diverges\u2019. A diverging function can be used\n as any type:\n \n ```should_panic\n # fn diverges() -> ! {\n #    panic!(\"This function never returns!\");\n # }\n-\n let x: i32 = diverges();\n let x: String = diverges();\n ```\n-\n-We don't have a good use for diverging functions yet, because they're used in\n-conjunction with other Rust features. But when you see `-> !` later, you'll\n-know what it's called."}]}