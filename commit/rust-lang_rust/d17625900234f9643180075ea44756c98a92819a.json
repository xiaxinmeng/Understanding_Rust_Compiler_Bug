{"sha": "d17625900234f9643180075ea44756c98a92819a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNzYyNTkwMDIzNGY5NjQzMTgwMDc1ZWE0NDc1NmM5OGE5MjgxOWE=", "commit": {"author": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2019-12-25T21:09:54Z"}, "committer": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2019-12-25T23:17:20Z"}, "message": "deduplicate shared code between stat and statx", "tree": {"sha": "695e4e6262abedb9786f3d7e31a0b943508caba1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/695e4e6262abedb9786f3d7e31a0b943508caba1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d17625900234f9643180075ea44756c98a92819a", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niI4EABYIADYWIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCXgPuARgcZ2l0QGNocmlz\ndGlhbnBvdmVkYS54eXoACgkQJ1Je9edCClC1hgEAv39RWtOwuyUFPt5rXCR4jw5i\ny0xBPDOaBunL+k8YzRUA/ivARMQIe0Qa0ynrGSCBGIiPyJ+HBh1gK3qMU2Gzo+MK\n=/wfQ\n-----END PGP SIGNATURE-----", "payload": "tree 695e4e6262abedb9786f3d7e31a0b943508caba1\nparent 515c11935969f6bffc42ab2e4cece862f109bb31\nauthor Christian Poveda <git@christianpoveda.xyz> 1577308194 -0500\ncommitter Christian Poveda <git@christianpoveda.xyz> 1577315840 -0500\n\ndeduplicate shared code between stat and statx\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d17625900234f9643180075ea44756c98a92819a", "html_url": "https://github.com/rust-lang/rust/commit/d17625900234f9643180075ea44756c98a92819a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d17625900234f9643180075ea44756c98a92819a/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "515c11935969f6bffc42ab2e4cece862f109bb31", "url": "https://api.github.com/repos/rust-lang/rust/commits/515c11935969f6bffc42ab2e4cece862f109bb31", "html_url": "https://github.com/rust-lang/rust/commit/515c11935969f6bffc42ab2e4cece862f109bb31"}], "stats": {"total": 173, "additions": 92, "deletions": 81}, "files": [{"sha": "a5bac27cc449d5ce2bd94b391066489e4e2f138b", "filename": "src/shims/fs.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d17625900234f9643180075ea44756c98a92819a/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d17625900234f9643180075ea44756c98a92819a/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=d17625900234f9643180075ea44756c98a92819a", "patch": "@@ -269,40 +269,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         if this.tcx.sess.target.target.target_os.to_lowercase() != \"macos\" {\n-            throw_unsup_format!(\"The `stat` shim is only only available in the `macos` platform.\")\n+            throw_unsup_format!(\"The `stat` shim is only only available for `macos` targets.\")\n         }\n \n         let path_scalar = this.read_scalar(path_op)?.not_undef()?;\n-        let path = this.read_os_str_from_c_str(path_scalar)?;\n+        let path: PathBuf = this.read_os_str_from_c_str(path_scalar)?.into();\n \n         let buf = this.deref_operand(buf_op)?;\n \n-        let metadata = match std::fs::metadata(path) {\n-            Ok(metadata) => metadata,\n-            Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n-                return Ok(-1);\n-            }\n-        };\n-\n-        let file_type = metadata.file_type();\n-\n-        let mode_name = if file_type.is_file() {\n-            \"S_IFREG\"\n-        } else if file_type.is_dir() {\n-            \"S_IFDIR\"\n-        } else {\n-            \"S_IFLNK\"\n+        let stats = match FileStatus::new(this, path, false)? {\n+            Some(stats) => stats,\n+            None => return Ok(-1),\n         };\n \n         // FIXME: use Scalar::to_u16\n-        let mode = this.eval_libc(mode_name)?.to_bits(Size::from_bits(16))? as u16;\n-\n-        let size = metadata.len();\n+        let mode: u16 = stats.mode.to_bits(Size::from_bits(16))? as u16;\n \n-        let (access_sec, access_nsec) = extract_sec_and_nsec(metadata.accessed(), &mut 0, 0)?;\n-        let (created_sec, created_nsec) = extract_sec_and_nsec(metadata.created(), &mut 0, 0)?;\n-        let (modified_sec, modified_nsec) = extract_sec_and_nsec(metadata.modified(), &mut 0, 0)?;\n+        let (access_sec, access_nsec) = stats.accessed.unwrap_or((0, 0));\n+        let (created_sec, created_nsec) = stats.created.unwrap_or((0, 0));\n+        let (modified_sec, modified_nsec) = stats.modified.unwrap_or((0, 0));\n \n         let dev_t_layout = this.libc_ty_layout(\"dev_t\")?;\n         let mode_t_layout = this.libc_ty_layout(\"mode_t\")?;\n@@ -341,7 +326,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_uint_checked(0u128, long_layout)?, // st_ctime_nsec\n             immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n             immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n-            immty_from_uint_checked(size, off_t_layout)?, // st_size\n+            immty_from_uint_checked(stats.size, off_t_layout)?, // st_size\n             immty_from_uint_checked(0u128, blkcnt_t_layout)?, // st_blocks\n             immty_from_uint_checked(0u128, blksize_t_layout)?, // st_blksize\n             immty_from_uint_checked(0u128, uint32_t_layout)?, // st_flags\n@@ -365,6 +350,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"statx\")?;\n \n+        if this.tcx.sess.target.target.target_os.to_lowercase() != \"linux\" {\n+            throw_unsup_format!(\"The `statx` shim is only only available for `linux` targets.\")\n+        }\n+\n         let statxbuf_scalar = this.read_scalar(statxbuf_op)?.not_undef()?;\n         let pathname_scalar = this.read_scalar(pathname_op)?.not_undef()?;\n \n@@ -422,68 +411,50 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n         // symbolic links.\n-        let metadata = if flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? != 0 {\n-            // FIXME: metadata for symlinks need testing.\n-            std::fs::symlink_metadata(path)\n-        } else {\n-            std::fs::metadata(path)\n-        };\n-\n-        let metadata = match metadata {\n-            Ok(metadata) => metadata,\n-            Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n-                return Ok(-1);\n-            }\n-        };\n-\n-        let file_type = metadata.file_type();\n+        let is_symlink = flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? != 0;\n \n-        let mode_name = if file_type.is_file() {\n-            \"S_IFREG\"\n-        } else if file_type.is_dir() {\n-            \"S_IFDIR\"\n-        } else {\n-            \"S_IFLNK\"\n+        let stats = match FileStatus::new(this, path, is_symlink)? {\n+            Some(stats) => stats,\n+            None => return Ok(-1),\n         };\n \n         // The `mode` field specifies the type of the file and the permissions over the file for\n         // the owner, its group and other users. Given that we can only provide the file type\n         // without using platform specific methods, we only set the bits corresponding to the file\n         // type. This should be an `__u16` but `libc` provides its values as `u32`.\n-        let mode: u16 = this\n-            .eval_libc(mode_name)?\n+        let mode: u16 = stats\n+            .mode\n             .to_u32()?\n             .try_into()\n-            .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n-\n-        let size = metadata.len();\n+            .unwrap_or_else(|_| bug!(\"libc contains bad value for constant\"));\n \n-        let (access_sec, access_nsec) = extract_sec_and_nsec(\n-            metadata.accessed(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_ATIME\")?.to_u32()?,\n-        )?;\n+        let (access_sec, access_nsec) = if let Some(tup) = stats.accessed {\n+            tup\n+        } else {\n+            mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n+            (0, 0)\n+        };\n \n-        let (created_sec, created_nsec) = extract_sec_and_nsec(\n-            metadata.created(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_BTIME\")?.to_u32()?,\n-        )?;\n+        let (created_sec, created_nsec) = if let Some(tup) = stats.created {\n+            tup\n+        } else {\n+            mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n+            (0, 0)\n+        };\n \n-        let (modified_sec, modified_nsec) = extract_sec_and_nsec(\n-            metadata.modified(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_MTIME\")?.to_u32()?,\n-        )?;\n+        let (modified_sec, modified_nsec) = if let Some(tup) = stats.modified {\n+            tup\n+        } else {\n+            mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n+            (0, 0)\n+        };\n \n         let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n         let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n         let __u16_layout = this.libc_ty_layout(\"__u16\")?;\n \n         // Now we transform all this fields into `ImmTy`s and write them to `statxbuf`. We write a\n         // zero for the unavailable fields.\n-        // FIXME: Provide more fields using platform specific methods.\n         let imms = [\n             immty_from_uint_checked(mask, __u32_layout)?, // stx_mask\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n@@ -494,7 +465,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_uint_checked(mode, __u16_layout)?, // stx_mode\n             immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n-            immty_from_uint_checked(size, __u64_layout)?, // stx_size\n+            immty_from_uint_checked(stats.size, __u64_layout)?, // stx_size\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n             immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n@@ -532,19 +503,59 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch, and\n-// then sets the `mask` bits determined by `flag` when `time` is Ok. If `time` is an error, it\n-// returns `(0, 0)` without setting any bits.\n-fn extract_sec_and_nsec<'tcx>(\n-    time: std::io::Result<SystemTime>,\n-    mask: &mut u32,\n-    flag: u32,\n-) -> InterpResult<'tcx, (u64, u32)> {\n-    if let Ok(time) = time {\n+// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch when\n+// `time` is Ok. If `time` is an error, it returns `None`.\n+fn extract_sec_and_nsec<'tcx>(time: std::io::Result<SystemTime>) -> InterpResult<'tcx, Option<(u64, u32)>> {\n+    time.ok().map(|time| {\n         let duration = system_time_to_duration(&time)?;\n-        *mask |= flag;\n         Ok((duration.as_secs(), duration.subsec_nanos()))\n-    } else {\n-        Ok((0, 0))\n+    }).transpose()\n+}\n+\n+struct FileStatus {\n+    mode: Scalar<Tag>,\n+    size: u64,\n+    created: Option<(u64, u32)>,\n+    accessed: Option<(u64, u32)>,\n+    modified: Option<(u64, u32)>,\n+}\n+\n+impl FileStatus {\n+    fn new<'tcx, 'mir>(ecx: &mut MiriEvalContext<'mir, 'tcx>, path: PathBuf, is_symlink: bool) -> InterpResult<'tcx, Option<FileStatus>> {\n+        let metadata = if is_symlink {\n+            // FIXME: metadata for symlinks need testing.\n+            std::fs::symlink_metadata(path)\n+        } else {\n+            std::fs::metadata(path)\n+        };\n+\n+        let metadata = match metadata {\n+            Ok(metadata) => metadata,\n+            Err(e) => {\n+                ecx.set_last_error_from_io_error(e)?;\n+                return Ok(None);\n+            }\n+        };\n+\n+        let file_type = metadata.file_type();\n+\n+        let mode_name = if file_type.is_file() {\n+            \"S_IFREG\"\n+        } else if file_type.is_dir() {\n+            \"S_IFDIR\"\n+        } else {\n+            \"S_IFLNK\"\n+        };\n+\n+        let mode = ecx.eval_libc(mode_name)?;\n+\n+        let size = metadata.len();\n+\n+        let created = extract_sec_and_nsec(metadata.created())?;\n+        let accessed = extract_sec_and_nsec(metadata.accessed())?;\n+        let modified = extract_sec_and_nsec(metadata.modified())?;\n+\n+        // FIXME: Provide more fields using platform specific methods.\n+        Ok(Some(FileStatus { mode, size, created, accessed, modified }))\n     }\n }"}]}