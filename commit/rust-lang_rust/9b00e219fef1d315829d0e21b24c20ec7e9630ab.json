{"sha": "9b00e219fef1d315829d0e21b24c20ec7e9630ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMDBlMjE5ZmVmMWQzMTU4MjlkMGUyMWIyNGMyMGVjN2U5NjMwYWI=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-26T01:02:50Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-26T01:20:57Z"}, "message": "Remove unused DepTrackingMap", "tree": {"sha": "0454ae8e4832eae0a2c705f4e0a27edcdb5a22aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0454ae8e4832eae0a2c705f4e0a27edcdb5a22aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b00e219fef1d315829d0e21b24c20ec7e9630ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b00e219fef1d315829d0e21b24c20ec7e9630ab", "html_url": "https://github.com/rust-lang/rust/commit/9b00e219fef1d315829d0e21b24c20ec7e9630ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b00e219fef1d315829d0e21b24c20ec7e9630ab/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c2c29c43206d6e2f1091fa278d2792ea10e3659", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2c29c43206d6e2f1091fa278d2792ea10e3659", "html_url": "https://github.com/rust-lang/rust/commit/6c2c29c43206d6e2f1091fa278d2792ea10e3659"}], "stats": {"total": 159, "additions": 3, "deletions": 156}, "files": [{"sha": "ee22d0b755a097565df5b53cc4db22c2e5da4922", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1,87 +0,0 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::marker::PhantomData;\n-use crate::util::common::MemoizationMap;\n-\n-use super::{DepKind, DepNodeIndex, DepGraph};\n-\n-/// A DepTrackingMap offers a subset of the `Map` API and ensures that\n-/// we make calls to `read` and `write` as appropriate. We key the\n-/// maps with a unique type for brevity.\n-pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n-    phantom: PhantomData<M>,\n-    graph: DepGraph,\n-    map: FxHashMap<M::Key, (M::Value, DepNodeIndex)>,\n-}\n-\n-pub trait DepTrackingMapConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value: Clone;\n-    fn to_dep_kind() -> DepKind;\n-}\n-\n-impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n-    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n-        DepTrackingMap {\n-            phantom: PhantomData,\n-            graph,\n-            map: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n-    type Key = M::Key;\n-    type Value = M::Value;\n-\n-    /// Memoizes an entry in the dep-tracking-map. If the entry is not\n-    /// already present, then `op` will be executed to compute its value.\n-    /// The resulting dependency graph looks like this:\n-    ///\n-    ///     [op] -> Map(key) -> CurrentTask\n-    ///\n-    /// Here, `[op]` represents whatever nodes `op` reads in the\n-    /// course of execution; `Map(key)` represents the node for this\n-    /// map, and `CurrentTask` represents the current task when\n-    /// `memoize` is invoked.\n-    ///\n-    /// **Important:** when `op` is invoked, the current task will be\n-    /// switched to `Map(key)`. Therefore, if `op` makes use of any\n-    /// HIR nodes or shared state accessed through its closure\n-    /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_of_item` in `collect`,\n-    /// which looks something like this:\n-    ///\n-    /// ```\n-    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.hir_id);\n-    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n-    ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_of_item(ccx, item)\n-    ///     });\n-    /// }\n-    /// ```\n-    ///\n-    /// The key is the line marked `(*)`: the closure implicitly\n-    /// accesses the body of the item `item`, so we register a read\n-    /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n-        where OP: FnOnce() -> M::Value\n-    {\n-        let graph;\n-        {\n-            let this = self.borrow();\n-            if let Some(&(ref result, dep_node)) = this.map.get(&key) {\n-                this.graph.read_index(dep_node);\n-                return result.clone();\n-            }\n-            graph = this.graph.clone();\n-        }\n-\n-        let (result, dep_node) = graph.with_anon_task(M::to_dep_kind(), op);\n-        self.borrow_mut().map.insert(key, (result.clone(), dep_node));\n-        graph.read_index(dep_node);\n-        result\n-    }\n-}"}, {"sha": "43f3d7e89cd5c7236589ed72a8ca9ebea47ddcd0", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=9b00e219fef1d315829d0e21b24c20ec7e9630ab", "patch": "@@ -1,14 +1,12 @@\n pub mod debug;\n mod dep_node;\n-mod dep_tracking_map;\n mod graph;\n mod prev;\n mod query;\n mod safe;\n mod serialized;\n pub mod cgu_reuse_tracker;\n \n-pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, RecoverKey, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;"}, {"sha": "9dff699deb8af6982f26e5e2a062783dca38b519", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=9b00e219fef1d315829d0e21b24c20ec7e9630ab", "patch": "@@ -3,12 +3,10 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::dep_graph::{DepKind, DepTrackingMapConfig};\n-use std::marker::PhantomData;\n use crate::infer::InferCtxt;\n use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::fold::TypeFoldable;\n \n@@ -100,33 +98,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>);\n-    type Value = Vtable<'tcx, ()>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n // # Global Cache\n \n-pub struct ProjectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for ProjectionCache<'tcx> {\n-    type Key = Ty<'tcx>;\n-    type Value = Ty<'tcx>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Finishes processes any obligations that remain in the\n     /// fulfillment context, and then returns the result with all type"}, {"sha": "0f472126695e0720cacd8138162c6d79e3707a56", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b00e219fef1d315829d0e21b24c20ec7e9630ab/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=9b00e219fef1d315829d0e21b24c20ec7e9630ab", "patch": "@@ -1,10 +1,9 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n+use rustc_data_structures::sync::Lock;\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::Cell;\n use std::fmt::Debug;\n-use std::hash::Hash;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n@@ -279,39 +278,3 @@ pub fn indenter() -> Indenter {\n     debug!(\">>\");\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n-\n-pub trait MemoizationMap {\n-    type Key: Clone;\n-    type Value: Clone;\n-\n-    /// If `key` is present in the map, return the value,\n-    /// otherwise invoke `op` and store the value in the map.\n-    ///\n-    /// N.B., if the receiver is a `DepTrackingMap`, special care is\n-    /// needed in the `op` to ensure that the correct edges are\n-    /// added into the dep graph. See the `DepTrackingMap` impl for\n-    /// more details!\n-    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n-        where OP: FnOnce() -> Self::Value;\n-}\n-\n-impl<K, V> MemoizationMap for RefCell<FxHashMap<K,V>>\n-    where K: Hash+Eq+Clone, V: Clone\n-{\n-    type Key = K;\n-    type Value = V;\n-\n-    fn memoize<OP>(&self, key: K, op: OP) -> V\n-        where OP: FnOnce() -> V\n-    {\n-        let result = self.borrow().get(&key).cloned();\n-        match result {\n-            Some(result) => result,\n-            None => {\n-                let result = op();\n-                self.borrow_mut().insert(key, result.clone());\n-                result\n-            }\n-        }\n-    }\n-}"}]}