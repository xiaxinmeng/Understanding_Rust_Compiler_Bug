{"sha": "6203bf445f1c7abd958ea1f79feb311381ace502", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMDNiZjQ0NWYxYzdhYmQ5NThlYTFmNzlmZWIzMTEzODFhY2U1MDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-18T09:59:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-18T09:59:28Z"}, "message": "update for rustc memory changes; fix (un)init intrinsic for ZST", "tree": {"sha": "c554cb82e11d0688a98cc821fe0e528b4fe1cfc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c554cb82e11d0688a98cc821fe0e528b4fe1cfc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6203bf445f1c7abd958ea1f79feb311381ace502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6203bf445f1c7abd958ea1f79feb311381ace502", "html_url": "https://github.com/rust-lang/rust/commit/6203bf445f1c7abd958ea1f79feb311381ace502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6203bf445f1c7abd958ea1f79feb311381ace502/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea27e46a3859d20b8740738ee3efea16e0a87e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea27e46a3859d20b8740738ee3efea16e0a87e2e", "html_url": "https://github.com/rust-lang/rust/commit/ea27e46a3859d20b8740738ee3efea16e0a87e2e"}], "stats": {"total": 65, "additions": 34, "deletions": 31}, "files": [{"sha": "605b63a10ea4713fbf7407e1c63248debdccb42f", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6203bf445f1c7abd958ea1f79feb311381ace502/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6203bf445f1c7abd958ea1f79feb311381ace502/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=6203bf445f1c7abd958ea1f79feb311381ace502", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let key_ptr = self.read_scalar(args[0])?.to_ptr()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n@@ -525,7 +525,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,\n-                    key_layout.align,\n                 )?;\n \n                 // Return success (0)"}, {"sha": "47399c390796b6ebba1482e3aceab8b15ba90f3c", "filename": "src/intrinsic.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6203bf445f1c7abd958ea1f79feb311381ace502/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6203bf445f1c7abd958ea1f79feb311381ace502/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=6203bf445f1c7abd958ea1f79feb311381ace502", "patch": "@@ -295,21 +295,23 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"init\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n-                match dest.layout.abi {\n-                    layout::Abi::Scalar(ref s) => {\n-                        let x = Scalar::null(s.value.size(&self));\n-                        self.write_value(Value::Scalar(x.into()), dest)?;\n-                    }\n-                    layout::Abi::ScalarPair(ref s1, ref s2) => {\n-                        let x = Scalar::null(s1.value.size(&self));\n-                        let y = Scalar::null(s2.value.size(&self));\n-                        self.write_value(Value::ScalarPair(x.into(), y.into()), dest)?;\n-                    }\n-                    _ => {\n-                        // Do it in memory\n-                        let mplace = self.force_allocation(dest)?;\n-                        assert_eq!(mplace.extra, PlaceExtra::None);\n-                        self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                if !dest.layout.is_zst() { // notzhing to do for ZST\n+                    match dest.layout.abi {\n+                        layout::Abi::Scalar(ref s) => {\n+                            let x = Scalar::null(s.value.size(&self));\n+                            self.write_value(Value::Scalar(x.into()), dest)?;\n+                        }\n+                        layout::Abi::ScalarPair(ref s1, ref s2) => {\n+                            let x = Scalar::null(s1.value.size(&self));\n+                            let y = Scalar::null(s2.value.size(&self));\n+                            self.write_value(Value::ScalarPair(x.into(), y.into()), dest)?;\n+                        }\n+                        _ => {\n+                            // Do it in memory\n+                            let mplace = self.force_allocation(dest)?;\n+                            assert_eq!(mplace.extra, PlaceExtra::None);\n+                            self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                        }\n                     }\n                 }\n             }\n@@ -571,20 +573,22 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"uninit\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,\n                 // but we also do not want to create a new allocation with 0s and then copy that over.\n-                match dest.layout.abi {\n-                    layout::Abi::Scalar(..) => {\n-                        let x = ScalarMaybeUndef::Undef;\n-                        self.write_value(Value::Scalar(x), dest)?;\n-                    }\n-                    layout::Abi::ScalarPair(..) => {\n-                        let x = ScalarMaybeUndef::Undef;\n-                        self.write_value(Value::ScalarPair(x, x), dest)?;\n-                    }\n-                    _ => {\n-                        // Do it in memory\n-                        let mplace = self.force_allocation(dest)?;\n-                        assert_eq!(mplace.extra, PlaceExtra::None);\n-                        self.memory.mark_definedness(mplace.ptr, dest.layout.size, false)?;\n+                if !dest.layout.is_zst() { // nothing to do for ZST\n+                    match dest.layout.abi {\n+                        layout::Abi::Scalar(..) => {\n+                            let x = ScalarMaybeUndef::Undef;\n+                            self.write_value(Value::Scalar(x), dest)?;\n+                        }\n+                        layout::Abi::ScalarPair(..) => {\n+                            let x = ScalarMaybeUndef::Undef;\n+                            self.write_value(Value::ScalarPair(x, x), dest)?;\n+                        }\n+                        _ => {\n+                            // Do it in memory\n+                            let mplace = self.force_allocation(dest)?;\n+                            assert_eq!(mplace.extra, PlaceExtra::None);\n+                            self.memory.mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n+                        }\n                     }\n                 }\n             }"}]}