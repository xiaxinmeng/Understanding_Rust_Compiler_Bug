{"sha": "6087c014608108e2b971608e214a74759743e95e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwODdjMDE0NjA4MTA4ZTJiOTcxNjA4ZTIxNGE3NDc1OTc0M2U5NWU=", "commit": {"author": {"name": "Steffen Lyngbaek", "email": "steffenlyngbaek@gmail.com", "date": "2020-03-17T06:30:25Z"}, "committer": {"name": "Steffen Lyngbaek", "email": "steffenlyngbaek@gmail.com", "date": "2020-03-19T18:47:33Z"}, "message": "'Fill match arms' should work with existing match arms\n\nAddresses #3039\n\nThis essentially adds missing match arms. The algorithm for this\ncan get complicated rather quickly so bail in certain conditions\nand rely on a PlaceholderPat.\n\nThe algorighm works as such:\n- Iterate through the Enum Def Variants\n- Attempt to see if the variant already exists as a match arm\n- If yes, skip the enum variant. If no, include it.\n- If it becomes complicated, rather than exhaustively deal with every\n  branch, mark it as a \"partial match\" and simply include the\n  placeholder.\n\n  Conditions for \"complication\":\n  - The match arm contains a match guard\n  - Any kind of nested destrucuring\n\nOrder the resulting merged match branches as such:\n1. Provided match arms\n2. Missing enum variant branch arms\n3. End with Placeholder if required\n\n- Add extra tests", "tree": {"sha": "e85c417d692b496fe1e0f50309e05afc72773915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85c417d692b496fe1e0f50309e05afc72773915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6087c014608108e2b971608e214a74759743e95e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6087c014608108e2b971608e214a74759743e95e", "html_url": "https://github.com/rust-lang/rust/commit/6087c014608108e2b971608e214a74759743e95e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6087c014608108e2b971608e214a74759743e95e/comments", "author": {"login": "slyngbaek", "id": 1216902, "node_id": "MDQ6VXNlcjEyMTY5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1216902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/slyngbaek", "html_url": "https://github.com/slyngbaek", "followers_url": "https://api.github.com/users/slyngbaek/followers", "following_url": "https://api.github.com/users/slyngbaek/following{/other_user}", "gists_url": "https://api.github.com/users/slyngbaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/slyngbaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/slyngbaek/subscriptions", "organizations_url": "https://api.github.com/users/slyngbaek/orgs", "repos_url": "https://api.github.com/users/slyngbaek/repos", "events_url": "https://api.github.com/users/slyngbaek/events{/privacy}", "received_events_url": "https://api.github.com/users/slyngbaek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "slyngbaek", "id": 1216902, "node_id": "MDQ6VXNlcjEyMTY5MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1216902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/slyngbaek", "html_url": "https://github.com/slyngbaek", "followers_url": "https://api.github.com/users/slyngbaek/followers", "following_url": "https://api.github.com/users/slyngbaek/following{/other_user}", "gists_url": "https://api.github.com/users/slyngbaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/slyngbaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/slyngbaek/subscriptions", "organizations_url": "https://api.github.com/users/slyngbaek/orgs", "repos_url": "https://api.github.com/users/slyngbaek/repos", "events_url": "https://api.github.com/users/slyngbaek/events{/privacy}", "received_events_url": "https://api.github.com/users/slyngbaek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba03c6995015b3143a417ed07437f0c9028a97d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba03c6995015b3143a417ed07437f0c9028a97d", "html_url": "https://github.com/rust-lang/rust/commit/1ba03c6995015b3143a417ed07437f0c9028a97d"}], "stats": {"total": 306, "additions": 281, "deletions": 25}, "files": [{"sha": "6e6c2d5ccf3724de66640c80b44731fb8c33240e", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 281, "deletions": 25, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/6087c014608108e2b971608e214a74759743e95e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6087c014608108e2b971608e214a74759743e95e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=6087c014608108e2b971608e214a74759743e95e", "patch": "@@ -1,12 +1,17 @@\n //! FIXME: write short doc here\n \n-use std::iter;\n+use std::{collections::LinkedList, iter};\n \n use hir::{Adt, HasSource, Semantics};\n use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n \n use crate::{Assist, AssistCtx, AssistId};\n+use ra_syntax::{\n+    ast::{self, edit::IndentLevel, make, AstNode, NameOwner},\n+    SyntaxKind, SyntaxNode,\n+};\n+\n+use ast::{MatchArm, MatchGuard, Pat};\n \n // Assist: fill_match_arms\n //\n@@ -36,16 +41,6 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n-    // We already have some match arms, so we don't provide any assists.\n-    // Unless if there is only one trivial match arm possibly created\n-    // by match postfix complete. Trivial match arm is the catch all arm.\n-    let mut existing_arms = match_arm_list.arms();\n-    if let Some(arm) = existing_arms.next() {\n-        if !is_trivial(&arm) || existing_arms.next().is_some() {\n-            return None;\n-        }\n-    };\n-\n     let expr = match_expr.expr()?;\n     let enum_def = resolve_enum_def(&ctx.sema, &expr)?;\n     let module = ctx.sema.scope(expr.syntax()).module()?;\n@@ -56,29 +51,113 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let db = ctx.db;\n-\n     ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n-        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n+        let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n+        if arms.len() == 1 {\n+            if let Some(Pat::PlaceholderPat(..)) = arms[0].pat() {\n+                arms.clear();\n+            }\n+        }\n \n-        let new_arm_list = {\n-            let arms = variants\n-                .into_iter()\n-                .filter_map(|variant| build_pat(db, module, variant))\n-                .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()));\n-            indent_level.increase_indent(make::match_arm_list(arms))\n-        };\n+        let mut has_partial_match = false;\n+        let variants: Vec<MatchArm> = variants\n+            .into_iter()\n+            .filter_map(|variant| build_pat(db, module, variant))\n+            .filter(|variant_pat| {\n+                !arms.iter().filter_map(|arm| arm.pat().map(|_| arm)).any(|arm| {\n+                    let pat = arm.pat().unwrap();\n+\n+                    // Special casee OrPat as separate top-level pats\n+                    let pats: Vec<Pat> = match Pat::from(pat.clone()) {\n+                        Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n+                        _ => vec![pat],\n+                    };\n+\n+                    pats.iter().any(|pat| {\n+                        match does_arm_pat_match_variant(pat, arm.guard(), variant_pat) {\n+                            ArmMatch::Yes => true,\n+                            ArmMatch::No => false,\n+                            ArmMatch::Partial => {\n+                                has_partial_match = true;\n+                                true\n+                            }\n+                        }\n+                    })\n+                })\n+            })\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+            .collect();\n+\n+        arms.extend(variants);\n+        if has_partial_match {\n+            arms.push(make::match_arm(\n+                iter::once(make::placeholder_pat().into()),\n+                make::expr_unit(),\n+            ));\n+        }\n+\n+        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n+        let new_arm_list = indent_level.increase_indent(make::match_arm_list(arms));\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);\n     })\n }\n \n-fn is_trivial(arm: &ast::MatchArm) -> bool {\n-    match arm.pat() {\n-        Some(ast::Pat::PlaceholderPat(..)) => true,\n-        _ => false,\n+enum ArmMatch {\n+    Yes,\n+    No,\n+    Partial,\n+}\n+\n+fn does_arm_pat_match_variant(arm: &Pat, arm_guard: Option<MatchGuard>, var: &Pat) -> ArmMatch {\n+    let arm = flatten_pats(arm.clone());\n+    let var = flatten_pats(var.clone());\n+    let mut arm = arm.iter();\n+    let mut var = var.iter();\n+\n+    // If the first part of the Pat don't match, there's no match\n+    match (arm.next(), var.next()) {\n+        (Some(arm), Some(var)) if arm.text() == var.text() => {}\n+        _ => return ArmMatch::No,\n+    }\n+\n+    // If we have a guard we automatically know we have a partial match\n+    if arm_guard.is_some() {\n+        return ArmMatch::Partial;\n+    }\n+\n+    if arm.clone().count() != var.clone().count() {\n+        return ArmMatch::Partial;\n+    }\n+\n+    let direct_match = arm.zip(var).all(|(arm, var)| {\n+        if arm.text() == var.text() {\n+            return true;\n+        }\n+        match (arm.kind(), var.kind()) {\n+            (SyntaxKind::PLACEHOLDER_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n+            (SyntaxKind::DOT_DOT_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n+            (SyntaxKind::BIND_PAT, SyntaxKind::PLACEHOLDER_PAT) => true,\n+            _ => false,\n+        }\n+    });\n+\n+    match direct_match {\n+        true => ArmMatch::Yes,\n+        false => ArmMatch::Partial,\n+    }\n+}\n+\n+fn flatten_pats(pat: Pat) -> Vec<SyntaxNode> {\n+    let mut pats: LinkedList<SyntaxNode> = pat.syntax().children().collect();\n+    let mut out: Vec<SyntaxNode> = vec![];\n+    while let Some(p) = pats.pop_front() {\n+        pats.extend(p.children());\n+        out.push(p);\n     }\n+    out\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n@@ -114,6 +193,183 @@ mod tests {\n \n     use super::fill_match_arms;\n \n+    #[test]\n+    fn partial_fill_multi() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs(i32, Option<i32>)\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Bs(_, Some(_)) => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs(i32, Option<i32>)\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Bs(_, Some(_)) => (),\n+                    A::As => (),\n+                    _ => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill_record() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs{x:i32, y:Option<i32>},\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Bs{x,y:Some(_)} => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs{x:i32, y:Option<i32>},\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Bs{x,y:Some(_)} => (),\n+                    A::As => (),\n+                    _ => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill_or_pat() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Cs(_) | A::Bs => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Cs(_) | A::Bs => (),\n+                    A::As => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill_or_pat2() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Cs(Some(_)) | A::Bs => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Cs(Some(_)) | A::Bs => (),\n+                    A::As => (),\n+                    _ => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs,\n+                Ds(String),\n+                Es(B),\n+            }\n+            enum B {\n+                Xs,\n+                Ys,\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Bs if 0 < 1 => (),\n+                    A::Ds(_value) => (),\n+                    A::Es(B::Xs) => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs,\n+                Ds(String),\n+                Es(B),\n+            }\n+            enum B {\n+                Xs,\n+                Ys,\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Bs if 0 < 1 => (),\n+                    A::Ds(_value) => (),\n+                    A::Es(B::Xs) => (),\n+                    A::As => (),\n+                    A::Cs => (),\n+                    _ => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn fill_match_arms_empty_body() {\n         check_assist("}]}