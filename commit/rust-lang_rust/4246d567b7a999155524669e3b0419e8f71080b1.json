{"sha": "4246d567b7a999155524669e3b0419e8f71080b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNDZkNTY3YjdhOTk5MTU1NTI0NjY5ZTNiMDQxOWU4ZjcxMDgwYjE=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-07-28T23:46:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-29T03:30:29Z"}, "message": "Move ports out into their own file, add data_message and make communication system use it (and proxies) instead of existing token scheme.", "tree": {"sha": "38ab4d3aa04b25e37db9e663890235edf2f3a8a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38ab4d3aa04b25e37db9e663890235edf2f3a8a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4246d567b7a999155524669e3b0419e8f71080b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4246d567b7a999155524669e3b0419e8f71080b1", "html_url": "https://github.com/rust-lang/rust/commit/4246d567b7a999155524669e3b0419e8f71080b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4246d567b7a999155524669e3b0419e8f71080b1/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff8e15128f90d4e9e57897c48280c6f82bb8343", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff8e15128f90d4e9e57897c48280c6f82bb8343", "html_url": "https://github.com/rust-lang/rust/commit/4ff8e15128f90d4e9e57897c48280c6f82bb8343"}], "stats": {"total": 434, "additions": 256, "deletions": 178}, "files": [{"sha": "35327624314c28b1ee2b91de6e8911b75ea1f7b4", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -257,6 +257,7 @@ RUNTIME_CS := rt/sync/spin_lock.cpp \\\n               rt/rust_dom.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_chan.cpp \\\n+              rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_message.cpp \\\n@@ -270,6 +271,7 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/rust_internal.h \\\n                rt/rust_util.h \\\n                rt/rust_chan.h \\\n+               rt/rust_port.h \\\n                rt/rust_dom.h \\\n                rt/rust_task.h \\\n                rt/rust_proxy.h \\"}, {"sha": "f107d2871dd5580c72f205cd6fbffbbeb4812163", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -1,12 +1,14 @@\n #include \"rust_internal.h\"\n #include \"rust_chan.h\"\n \n-rust_chan::rust_chan(rust_task *task, rust_port *port) :\n-    task(task), port(port), buffer(task->dom, port->unit_sz), token(this) {\n+/**\n+ * Create a new rust channel and associate it with the specified port.\n+ */\n+rust_chan::rust_chan(rust_task *task, maybe_proxy<rust_port> *port) :\n+    task(task), port(port), buffer(task->dom, port->delegate()->unit_sz) {\n \n     if (port) {\n-        port->chans.push(this);\n-        ref();\n+        associate(port);\n     }\n \n     task->log(rust_log::MEM | rust_log::COMM,\n@@ -16,49 +18,68 @@ rust_chan::rust_chan(rust_task *task, rust_port *port) :\n }\n \n rust_chan::~rust_chan() {\n-    if (port) {\n-        if (token.pending())\n-            token.withdraw();\n-        port->chans.swap_delete(this);\n+    if (port && !port->is_proxy()) {\n+        port->delegate()->chans.swap_delete(this);\n     }\n }\n \n-void rust_chan::disassociate() {\n-    I(task->dom, port);\n+/**\n+ * Link this channel with the specified port.\n+ */\n+void rust_chan::associate(maybe_proxy<rust_port> *port) {\n+    this->port = port;\n+    if (!port->is_proxy()) {\n+        this->port->delegate()->chans.push(this);\n+    }\n+}\n \n-    if (token.pending())\n-        token.withdraw();\n+bool rust_chan::is_associated() {\n+    return port != NULL;\n+}\n \n-    // Delete reference to the port/\n-    port = NULL;\n+/**\n+ * Unlink this channel from its associated port.\n+ */\n+void rust_chan::disassociate() {\n+    A(task->dom, is_associated(), \"Channel must be associated with a port.\");\n \n-    deref();\n+    // Delete reference to the port.\n+    port = NULL;\n }\n \n /**\n  * Attempt to transmit channel data to the associated port.\n  */\n-int rust_chan::transmit() {\n+void rust_chan::transmit() {\n     rust_dom *dom = task->dom;\n-\n-    // TODO: Figure out how and why the port would become null.\n-    if (port == NULL) {\n-        dom->log(rust_log::COMM, \"invalid port, transmission incomplete\");\n-        return ERROR;\n+    if (!is_associated()) {\n+        W(dom, is_associated(),\n+          \"rust_chan::transmit with no associated port.\");\n+        return;\n     }\n \n-    if (buffer.is_empty()) {\n-        dom->log(rust_log::COMM, \"buffer is empty, transmission incomplete\");\n-        return ERROR;\n-    }\n+    A(dom, !buffer.is_empty(),\n+      \"rust_chan::transmit with nothing to send.\");\n \n-    if(port->task->blocked_on(port)) {\n-        buffer.dequeue(port->task->rendezvous_ptr);\n-        port->task->wakeup(port);\n+    if (port->is_proxy()) {\n+        // TODO: Cache port task locally.\n+        rust_proxy<rust_task> *port_task =\n+            dom->get_task_proxy(port->delegate()->task);\n+        data_message::send(buffer.peek(), buffer.unit_sz,\n+            \"send data\", task, port_task, port->as_proxy());\n+        buffer.dequeue(NULL);\n+    } else {\n+        rust_port *target_port = port->delegate();\n+        if (target_port->task->blocked_on(target_port)) {\n+            dom->log(rust_log::COMM, \"dequeued in rendezvous_ptr\");\n+            buffer.dequeue(target_port->task->rendezvous_ptr);\n+            target_port->task->rendezvous_ptr = 0;\n+            target_port->task->wakeup(target_port);\n+            return;\n+        }\n     }\n \n-    return 0;\n-\n+    return;\n }\n \n //"}, {"sha": "055e359ae71a26ef3377d8f77162c29fb636d305", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -1,24 +1,23 @@\n-\n #ifndef RUST_CHAN_H\n #define RUST_CHAN_H\n \n-class rust_chan : public rc_base<rust_chan>, public task_owned<rust_chan> {\n+class rust_chan : public rc_base<rust_chan>,\n+                  public task_owned<rust_chan>,\n+                  public rust_cond {\n public:\n-    rust_chan(rust_task *task, rust_port *port);\n+    rust_chan(rust_task *task, maybe_proxy<rust_port> *port);\n     ~rust_chan();\n \n     rust_task *task;\n-    rust_port *port;\n+    maybe_proxy<rust_port> *port;\n+    size_t idx;\n     circular_buffer buffer;\n-    size_t idx;           // Index into port->chans.\n-\n-    // Token belonging to this chan, it will be placed into a port's\n-    // writers vector if we have something to send to the port.\n-    rust_token token;\n \n+    void associate(maybe_proxy<rust_port> *port);\n     void disassociate();\n+    bool is_associated();\n \n-    int transmit();\n+    void transmit();\n };\n \n //"}, {"sha": "3fbaaa047707bfe96f732e23352935b9751eb7e8", "filename": "src/rt/rust_comm.cpp", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_comm.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_comm.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_comm.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -1,87 +1,13 @@\n \n #include \"rust_internal.h\"\n \n-template class ptr_vec<rust_token>;\n template class ptr_vec<rust_alarm>;\n-template class ptr_vec<rust_chan>;\n \n rust_alarm::rust_alarm(rust_task *receiver) :\n     receiver(receiver)\n {\n }\n \n-// Ports.\n-\n-rust_port::rust_port(rust_task *task, size_t unit_sz) :\n-    task(task),\n-    unit_sz(unit_sz),\n-    writers(task->dom),\n-    chans(task->dom)\n-{\n-    task->log(rust_log::MEM|rust_log::COMM,\n-              \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n-              PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n-}\n-\n-rust_port::~rust_port()\n-{\n-    task->log(rust_log::COMM|rust_log::MEM,\n-              \"~rust_port 0x%\" PRIxPTR,\n-              (uintptr_t)this);\n-    while (chans.length() > 0)\n-        chans.pop()->disassociate();\n-}\n-\n-\n-// Tokens.\n-\n-rust_token::rust_token(rust_chan *chan) :\n-    chan(chan),\n-    idx(0),\n-    submitted(false)\n-{\n-}\n-\n-rust_token::~rust_token()\n-{\n-}\n-\n-bool\n-rust_token::pending() const\n-{\n-    return submitted;\n-}\n-\n-void\n-rust_token::submit()\n-{\n-    rust_port *port = chan->port;\n-    rust_dom *dom = chan->task->dom;\n-\n-    I(dom, port);\n-    I(dom, !submitted);\n-\n-    port->writers.push(this);\n-    submitted = true;\n-}\n-\n-void\n-rust_token::withdraw()\n-{\n-    rust_task *task = chan->task;\n-    rust_port *port = chan->port;\n-    rust_dom *dom = task->dom;\n-\n-    I(dom, port);\n-    I(dom, submitted);\n-\n-    if (task->blocked())\n-        task->wakeup(this); // must be blocked on us (or dead)\n-    port->writers.swap_delete(this);\n-    submitted = false;\n-}\n-\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "0c175e7889c4d0e0a0e5a537b2f7e2a4ec967384", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -46,6 +46,14 @@ rust_dom::delete_proxies() {\n                             \" in dom %\" PRIxPTR, task_proxy, task_proxy->dom);\n         delete task_proxy;\n     }\n+\n+    rust_port *port;\n+    rust_proxy<rust_port> *port_proxy;\n+    while (_port_proxies.pop(&port, &port_proxy)) {\n+        log(rust_log::TASK, \"deleting proxy %\" PRIxPTR\n+                            \" in dom %\" PRIxPTR, port_proxy, port_proxy->dom);\n+        delete port_proxy;\n+    }\n }\n \n rust_dom::~rust_dom() {\n@@ -217,7 +225,6 @@ rust_dom::reap_dead_tasks() {\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n         rust_task *task = dead_tasks[i];\n         if (task->ref_count == 0) {\n-            I(this, !task->waiting_tasks.length());\n             I(this, task->tasks_waiting_to_join.is_empty());\n \n             dead_tasks.swap_delete(task);\n@@ -270,6 +277,28 @@ rust_dom::get_task_proxy(rust_task *task) {\n     _task_proxies.put(task, proxy);\n     return proxy;\n }\n+\n+/**\n+ * Gets a proxy for this port.\n+ *\n+ * TODO: This method needs to be synchronized since it's usually called\n+ * during upcall_clone_chan in a different thread. However, for now\n+ * since this usually happens before the thread actually starts,\n+ * we may get lucky without synchronizing.\n+ *\n+ */\n+rust_proxy<rust_port> *\n+rust_dom::get_port_proxy_synchronized(rust_port *port) {\n+    rust_proxy<rust_port> *proxy = NULL;\n+    if (_port_proxies.get(port, &proxy)) {\n+        return proxy;\n+    }\n+    log(rust_log::COMM, \"no proxy for 0x%\" PRIxPTR, port);\n+    proxy = new (this) rust_proxy<rust_port> (this, port, false);\n+    _port_proxies.put(port, proxy);\n+    return proxy;\n+}\n+\n /**\n  * Schedules a running task for execution. Only running tasks can be\n  * activated.  Blocked tasks have to be unblocked before they can be"}, {"sha": "528790d56cc467706696dc340a2762168d1f1270", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -37,6 +37,7 @@ struct rust_dom\n     condition_variable _progress;\n \n     hash_map<rust_task *, rust_proxy<rust_task> *> _task_proxies;\n+    hash_map<rust_port *, rust_proxy<rust_port> *> _port_proxies;\n \n     // Incoming messages from other domains.\n     condition_variable _incoming_message_pending;\n@@ -66,6 +67,7 @@ struct rust_dom\n     void drain_incoming_message_queue();\n     rust_proxy<rust_task> *get_task_proxy(rust_task *task);\n     void delete_proxies();\n+    rust_proxy<rust_port> *get_port_proxy_synchronized(rust_port *port);\n \n #ifdef __WIN32__\n     void win32_require(LPCTSTR fn, BOOL ok);"}, {"sha": "a89144d70669bd86b0464653fff9bf02fa0dabaf", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -580,37 +580,11 @@ struct gc_alloc {\n     }\n };\n \n+#include \"circular_buffer.h\"\n #include \"rust_proxy.h\"\n #include \"rust_task.h\"\n-\n-struct rust_port : public rc_base<rust_port>,\n-                   public task_owned<rust_port>,\n-                   public rust_cond {\n-    rust_task *task;\n-    size_t unit_sz;\n-    ptr_vec<rust_token> writers;\n-    ptr_vec<rust_chan> chans;\n-\n-    rust_port(rust_task *task, size_t unit_sz);\n-    ~rust_port();\n-};\n-\n-struct rust_token : public rust_cond {\n-    rust_chan *chan;      // Link back to the channel this token belongs to\n-    size_t idx;           // Index into port->writers.\n-    bool submitted;       // Whether token is in a port->writers.\n-\n-    rust_token(rust_chan *chan);\n-    ~rust_token();\n-\n-    bool pending() const;\n-    void submit();\n-    void withdraw();\n-};\n-\n-#include \"circular_buffer.h\"\n-\n #include \"rust_chan.h\"\n+#include \"rust_port.h\"\n \n //\n // Local Variables:"}, {"sha": "8b396b4dc0f8d6a64d68eacbbdbbed692bf32fc2", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -27,6 +27,19 @@ notify_message(notification_type type, const char* label,\n                rust_message(label, source, target), type(type) {\n }\n \n+data_message::\n+data_message(uint8_t *buffer, size_t buffer_sz, const char* label,\n+             rust_task *source, rust_task *target, rust_port *port) :\n+             rust_message(label, source, target),\n+             _buffer_sz(buffer_sz), _port(port) {\n+    _buffer = (uint8_t *)malloc(buffer_sz);\n+    memcpy(_buffer, buffer, buffer_sz);\n+}\n+\n+data_message::~data_message() {\n+    free (_buffer);\n+}\n+\n /**\n  * Sends a message to the target task via a proxy. The message is allocated\n  * in the target task domain along with a proxy which points back to the\n@@ -63,6 +76,25 @@ void notify_message::process() {\n     }\n }\n \n+void data_message::\n+send(uint8_t *buffer, size_t buffer_sz, const char* label, rust_task *source,\n+     rust_proxy<rust_task> *target, rust_proxy<rust_port> *port) {\n+\n+    rust_task *target_task = target->delegate();\n+    rust_port *target_port = port->delegate();\n+    rust_dom *target_domain = target_task->dom;\n+    data_message *message = new (target_domain)\n+        data_message(buffer, buffer_sz, label, source,\n+                     target_task, target_port);\n+    target_domain->send_message(message);\n+}\n+\n+void data_message::process() {\n+    _port->remote_channel->buffer.enqueue(_buffer);\n+    _port->remote_channel->transmit();\n+    _target->log(rust_log::COMM, \"<=== received data via message ===\");\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "b7b8568a6289d4a52646b6ce0f1cfa28c4eec609", "filename": "src/rt/rust_message.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -58,6 +58,30 @@ class notify_message : public rust_message {\n          rust_proxy<rust_task> *target);\n };\n \n+/**\n+ * Data messages carry a buffer.\n+ */\n+class data_message : public rust_message {\n+private:\n+    uint8_t *_buffer;\n+    size_t _buffer_sz;\n+    rust_port *_port;\n+public:\n+\n+    data_message(uint8_t *buffer, size_t buffer_sz, const char* label,\n+                 rust_task *source, rust_task *target, rust_port *port);\n+    ~data_message();\n+    void process();\n+\n+    /**\n+     * This code executes in the sending domain's thread.\n+     */\n+    static void\n+    send(uint8_t *buffer, size_t buffer_sz, const char* label,\n+         rust_task *source, rust_proxy<rust_task> *target,\n+         rust_proxy<rust_port> *port);\n+};\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "0a5b7ee75e7c385c0c7ba14f2c4c1deba8cd073a", "filename": "src/rt/rust_port.cpp", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -0,0 +1,39 @@\n+#include \"rust_internal.h\"\n+#include \"rust_port.h\"\n+\n+rust_port::rust_port(rust_task *task, size_t unit_sz) :\n+    maybe_proxy<rust_port>(this), task(task), unit_sz(unit_sz),\n+    writers(task->dom), chans(task->dom) {\n+\n+    task->log(rust_log::MEM | rust_log::COMM,\n+              \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n+              PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n+\n+    // Allocate a remote channel, for remote channel data.\n+    remote_channel = new (task->dom) rust_chan(task, this);\n+}\n+\n+rust_port::~rust_port() {\n+    task->log(rust_log::COMM | rust_log::MEM,\n+              \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n+\n+    // Disassociate channels from this port.\n+    while (chans.is_empty() == false) {\n+        chans.pop()->disassociate();\n+    }\n+\n+    // We're the only ones holding a reference to the remote channel, so\n+    // clean it up.\n+    delete remote_channel;\n+}\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "49a8943760021b6482f505a506f33eef4b4be5ee", "filename": "src/rt/rust_port.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -0,0 +1,31 @@\n+#ifndef RUST_PORT_H\n+#define RUST_PORT_H\n+\n+class rust_port : public maybe_proxy<rust_port>,\n+                  public task_owned<rust_port> {\n+\n+public:\n+    rust_task *task;\n+    size_t unit_sz;\n+    ptr_vec<rust_token> writers;\n+    ptr_vec<rust_chan> chans;\n+\n+    // Data sent to this port from remote tasks is buffered in this channel.\n+    rust_chan *remote_channel;\n+\n+    rust_port(rust_task *task, size_t unit_sz);\n+    ~rust_port();\n+};\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+\n+#endif /* RUST_PORT_H */"}, {"sha": "7140692cb445b73c97c21960fce0995208526be4", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -64,7 +64,6 @@ rust_task::rust_task(rust_dom *dom, rust_task *spawner) :\n     cond(NULL),\n     supervisor(spawner),\n     idx(0),\n-    waiting_tasks(dom),\n     rendezvous_ptr(0),\n     alarm(this)\n {\n@@ -372,19 +371,6 @@ rust_task::unsupervise()\n     supervisor = NULL;\n }\n \n-void\n-rust_task::notify_waiting_tasks()\n-{\n-    while (waiting_tasks.length() > 0) {\n-        log(rust_log::ALL, \"notify_waiting_tasks: %d\",\n-            waiting_tasks.length());\n-        rust_task *waiting_task = waiting_tasks.pop()->receiver;\n-        if (!waiting_task->dead()) {\n-            waiting_task->wakeup(this);\n-        }\n-    }\n-}\n-\n void\n rust_task::notify_tasks_waiting_to_join() {\n     while (tasks_waiting_to_join.is_empty() == false) {"}, {"sha": "b657592a5ef27e28565174cf92c94f7ff2b411ae", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -28,9 +28,6 @@ rust_task : public maybe_proxy<rust_task>,\n     size_t gc_alloc_thresh;\n     size_t gc_alloc_accum;\n \n-    // Wait queue for tasks waiting for this task.\n-    rust_wait_queue waiting_tasks;\n-\n     // Rendezvous pointer for receiving data when blocked on a port. If we're\n     // trying to read data and no data is available on any incoming channel,\n     // we block on the port, and yield control to the scheduler. Since, we\n@@ -101,7 +98,6 @@ rust_task : public maybe_proxy<rust_task>,\n     void unsupervise();\n \n     // Notify tasks waiting for us that we are about to die.\n-    void notify_waiting_tasks();\n     void notify_tasks_waiting_to_join();\n \n     uintptr_t get_fp();"}, {"sha": "574cb703a1f4079c94973a8b68a365965c3b202e", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4246d567b7a999155524669e3b0419e8f71080b1/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=4246d567b7a999155524669e3b0419e8f71080b1", "patch": "@@ -21,11 +21,6 @@\n \n extern \"C\" CDECL char const *str_buf(rust_task *task, rust_str *s);\n \n-inline bool\n-requires_message_passing(rust_task *sender, rust_task *receiver) {\n-    return sender->dom != receiver->dom;\n-}\n-\n extern \"C\" void upcall_grow_task(rust_task *task, size_t n_frame_bytes) {\n     LOG_UPCALL_ENTRY(task);\n     task->grow(n_frame_bytes);\n@@ -96,6 +91,18 @@ extern \"C\" CDECL void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n     I(dom, !chan->ref_count);\n+\n+    if (!chan->buffer.is_empty() && chan->is_associated()) {\n+        A(dom, !chan->port->is_proxy(),\n+          \"Channels to remote ports should be flushed automatically.\");\n+        // A target port may still be reading from this channel.\n+        // Block on this channel until it has been completely drained\n+        // by the port.\n+        task->block(chan);\n+        task->yield(2);\n+        return;\n+    }\n+\n     delete chan;\n }\n \n@@ -105,14 +112,19 @@ extern \"C\" CDECL void upcall_del_chan(rust_task *task, rust_chan *chan) {\n  */\n extern \"C\" CDECL rust_chan *\n upcall_clone_chan(rust_task *task,\n-                  maybe_proxy<rust_task> *spawnee_proxy,\n+                  maybe_proxy<rust_task> *target,\n                   rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_task *spawnee = spawnee_proxy->delegate();\n-    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n-              \"spawnee: 0x%\" PRIxPTR \", chan: 0x%\" PRIxPTR,\n-              (uintptr_t) spawnee, (uintptr_t) chan);\n-    return new (spawnee->dom) rust_chan(spawnee, chan->port);\n+    task->log(rust_log::UPCALL | rust_log::COMM,\n+              \"target: 0x%\" PRIxPTR \", chan: 0x%\" PRIxPTR,\n+              target, chan);\n+    rust_task *target_task = target->delegate();\n+    maybe_proxy<rust_port> *port = chan->port;\n+    if (target->is_proxy()) {\n+        port = target_task->dom->get_port_proxy_synchronized(\n+                chan->port->as_delegate());\n+    }\n+    return new (target_task->dom) rust_chan(target_task, port);\n }\n \n extern \"C\" CDECL void upcall_yield(rust_task *task) {\n@@ -145,20 +157,20 @@ upcall_join(rust_task *task, maybe_proxy<rust_task> *target) {\n }\n \n /**\n- * Sends an chunk of data along the specified channel.\n+ * Buffers a chunk of data in the specified channel.\n  *\n- * sptr: pointer to a chunk of data to send\n+ * sptr: pointer to a chunk of data to buffer\n  */\n extern \"C\" CDECL void\n upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n     task->log(rust_log::UPCALL | rust_log::COMM,\n               \"chan: 0x%\" PRIxPTR \", sptr: 0x%\" PRIxPTR \", size: %d\",\n-              (uintptr_t) chan, (uintptr_t) sptr, chan->port->unit_sz);\n-\n+              (uintptr_t) chan, (uintptr_t) sptr,\n+              chan->port->delegate()->unit_sz);\n     chan->buffer.enqueue(sptr);\n     chan->transmit();\n-    task->log(rust_log::COMM, \"=== WROTE DATA ===>\");\n+    task->log(rust_log::COMM, \"=== sent data ===>\");\n }\n \n extern \"C\" CDECL void\n@@ -174,7 +186,11 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n         rust_chan *chan = port->chans[i];\n         if (chan->buffer.is_empty() == false) {\n             chan->buffer.dequeue(dptr);\n-            task->log(rust_log::COMM, \"<=== READ DATA ===\");\n+            if (chan->buffer.is_empty() && chan->task->blocked()) {\n+                chan->task->wakeup(chan);\n+                delete chan;\n+            }\n+            task->log(rust_log::COMM, \"<=== read data ===\");\n             return;\n         }\n     }\n@@ -183,6 +199,7 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     // on the port. Remember the rendezvous location so that any sender\n     // task can write to it before waking up this task.\n \n+    task->log(rust_log::COMM, \"<=== waiting for rendezvous data ===\");\n     task->rendezvous_ptr = dptr;\n     task->block(port);\n     task->yield(3);"}]}