{"sha": "f0daff20ca0d7878d5d18599cad47825178cd29c", "node_id": "C_kwDOAAsO6NoAKGYwZGFmZjIwY2EwZDc4NzhkNWQxODU5OWNhZDQ3ODI1MTc4Y2QyOWM", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-09-28T04:07:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-28T04:07:18Z"}, "message": "Rollup merge of #102347 - nnethercote:unescaping-cleanups, r=matklad\n\nUnescaping cleanups\n\nSome minor improvements.\n\nr? `@matklad`", "tree": {"sha": "7613c4ade0b402018dfd634f5c8ca635a1374e0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7613c4ade0b402018dfd634f5c8ca635a1374e0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0daff20ca0d7878d5d18599cad47825178cd29c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjM8h2CRBK7hj4Ov3rIwAAwc0IAEKOy7eduwrC72opXTsYPPm8\nm9CWqe8p58foZtJzYwotljAQXHSAfGLlSgXEdvkJd5isbUt5ZNSj0uges8xKR7qM\noPomIxLcwQ59qnOc6Y0FeHAcybr4rZ7g7l2+Nk/Vcc5umEbweTuogGv2n/oQOX5G\nG+8h3wT3Pn4ApRa6a2HtLMREWTYLZORjvBKyfDVHRtCMy+aVdLA6DIsUj8Dy+HID\nylgRi+txp/60BRG34TNI2wqboXQ751HtgIT+yqqdcA/g73U+AgoP25WXLv5K7Kbo\nUwh8Qy+qwtq6bhwaZ65VB8cuGJBpahfPEtkjdiJBdLw2Y7HlWklfpPVR+Lh34KY=\n=qfA/\n-----END PGP SIGNATURE-----\n", "payload": "tree 7613c4ade0b402018dfd634f5c8ca635a1374e0f\nparent b263b7e64c842ad10d7a0a32efd13ad1fbf9b035\nparent 94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3\nauthor Yuki Okushi <jtitor@2k36.org> 1664338038 +0900\ncommitter GitHub <noreply@github.com> 1664338038 +0900\n\nRollup merge of #102347 - nnethercote:unescaping-cleanups, r=matklad\n\nUnescaping cleanups\n\nSome minor improvements.\n\nr? `@matklad`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0daff20ca0d7878d5d18599cad47825178cd29c", "html_url": "https://github.com/rust-lang/rust/commit/f0daff20ca0d7878d5d18599cad47825178cd29c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0daff20ca0d7878d5d18599cad47825178cd29c/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b263b7e64c842ad10d7a0a32efd13ad1fbf9b035", "url": "https://api.github.com/repos/rust-lang/rust/commits/b263b7e64c842ad10d7a0a32efd13ad1fbf9b035", "html_url": "https://github.com/rust-lang/rust/commit/b263b7e64c842ad10d7a0a32efd13ad1fbf9b035"}, {"sha": "94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3", "html_url": "https://github.com/rust-lang/rust/commit/94cb5e86ea50ec878b1a5de9b0b64bb35e8027e3"}], "stats": {"total": 27, "additions": 12, "deletions": 15}, "files": [{"sha": "8f64b5f5158e4222ec74ec5acddc0095cf045b99", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f0daff20ca0d7878d5d18599cad47825178cd29c/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0daff20ca0d7878d5d18599cad47825178cd29c/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=f0daff20ca0d7878d5d18599cad47825178cd29c", "patch": "@@ -93,7 +93,7 @@ where\n         // NOTE: Raw strings do not perform any explicit character escaping, here we\n         // only translate CRLF to LF and produce errors on bare CR.\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n         }\n     }\n }\n@@ -105,7 +105,7 @@ pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F\n where\n     F: FnMut(Range<usize>, Result<u8, EscapeError>),\n {\n-    assert!(mode.is_bytes());\n+    debug_assert!(mode.is_bytes());\n     unescape_literal(literal_text, mode, &mut |range, result| {\n         callback(range, result.map(byte_from_char));\n     })\n@@ -129,7 +129,7 @@ pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n }\n \n /// What kind of literal do we parse.\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n pub enum Mode {\n     Char,\n     Str,\n@@ -140,17 +140,13 @@ pub enum Mode {\n }\n \n impl Mode {\n-    pub fn in_single_quotes(self) -> bool {\n+    pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Char | Mode::Byte => true,\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => false,\n+            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn in_double_quotes(self) -> bool {\n-        !self.in_single_quotes()\n-    }\n-\n     pub fn is_bytes(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n@@ -184,7 +180,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n             let value = hi * 16 + lo;\n \n-            // For a byte literal verify that it is within ASCII range.\n+            // For a non-byte literal verify that it is within ASCII range.\n             if !mode.is_bytes() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n@@ -263,6 +259,7 @@ fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n }\n \n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match first_char {\n         '\\\\' => scan_escape(chars, mode),\n@@ -282,7 +279,7 @@ fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n     let initial_len = src.len();\n     let mut chars = src.chars();\n     while let Some(first_char) = chars.next() {\n@@ -344,11 +341,11 @@ where\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n /// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    assert!(mode.in_double_quotes());\n+    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n     let initial_len = literal_text.len();\n \n     let mut chars = literal_text.chars();\n@@ -368,7 +365,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n+    debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}]}