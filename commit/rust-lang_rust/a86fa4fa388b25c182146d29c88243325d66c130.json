{"sha": "a86fa4fa388b25c182146d29c88243325d66c130", "node_id": "C_kwDOAAsO6NoAKGE4NmZhNGZhMzg4YjI1YzE4MjE0NmQyOWM4ODI0MzMyNWQ2NmMxMzA", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-06-22T19:59:48Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-07-07T19:25:56Z"}, "message": "Avoid misleading message/label in `match-cfg-fake-edges.rs` test", "tree": {"sha": "917e07bd29c01251bf8b82aa0f99b289684f9db6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/917e07bd29c01251bf8b82aa0f99b289684f9db6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a86fa4fa388b25c182146d29c88243325d66c130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a86fa4fa388b25c182146d29c88243325d66c130", "html_url": "https://github.com/rust-lang/rust/commit/a86fa4fa388b25c182146d29c88243325d66c130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a86fa4fa388b25c182146d29c88243325d66c130/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ab1cd9fdcce6b189e37d481a9cc5a4f67c5ca72", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab1cd9fdcce6b189e37d481a9cc5a4f67c5ca72", "html_url": "https://github.com/rust-lang/rust/commit/8ab1cd9fdcce6b189e37d481a9cc5a4f67c5ca72"}], "stats": {"total": 71, "additions": 46, "deletions": 25}, "files": [{"sha": "f3d9d8597010d46550d9eeeecf5affacddd3e5f6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a86fa4fa388b25c182146d29c88243325d66c130/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86fa4fa388b25c182146d29c88243325d66c130/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=a86fa4fa388b25c182146d29c88243325d66c130", "patch": "@@ -339,23 +339,48 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 Some(name) => (format!(\"`{name}`\"), format!(\"`{name}`\"), format!(\"`{name}` \")),\n                 None => (\"value\".to_string(), \"the variable\".to_string(), String::new()),\n             };\n+\n+        // We use the statements were the binding was initialized, and inspect the HIR to look\n+        // for the branching codepaths that aren't covered, to point at them.\n+        let hir_id = self.mir_hir_id();\n+        let map = self.infcx.tcx.hir();\n+        let body_id = map.body_owned_by(hir_id);\n+        let body = map.body(body_id);\n+\n+        let mut visitor = ConditionVisitor { spans: &spans, name: &name, errors: vec![] };\n+        visitor.visit_body(&body);\n+\n         let isnt_initialized =\n             if let InitializationRequiringAction::PartialAssignment = desired_action {\n                 // The same error is emitted for bindings that are *sometimes* initialized and the ones\n                 // that are *partially* initialized by assigning to a field of an uninitialized\n                 // binding. We differentiate between them for more accurate wording here.\n                 \"isn't fully initialized\"\n-            } else if spans.iter().filter(|i| !i.contains(span)).count() == 0 {\n-                // We filter above to avoid misleading wording in cases like the following, where `x`\n-                // has an `init`, but it is in the same place we're looking at:\n-                // ```\n-                // let x;\n-                // x += 1;\n-                // ```\n+            } else if spans\n+                .iter()\n+                .filter(|i| {\n+                    // We filter these to avoid misleading wording in cases like the following,\n+                    // where `x` has an `init`, but it is in the same place we're looking at:\n+                    // ```\n+                    // let x;\n+                    // x += 1;\n+                    // ```\n+                    !i.contains(span)\n+                    // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n+                        && !visitor\n+                            .errors\n+                            .iter()\n+                            .map(|(sp, _)| *sp)\n+                            .any(|sp| span < sp && !sp.contains(span))\n+                })\n+                .count()\n+                == 0\n+            {\n                 \"isn't initialized\"\n             } else {\n                 \"is possibly-uninitialized\"\n             };\n+\n         let used = desired_action.as_general_verb_in_past_tense();\n         let mut err =\n             struct_span_err!(self, span, E0381, \"{used} binding {desc}{isnt_initialized}\");\n@@ -372,22 +397,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n         err.span_label(span, format!(\"{binding} {used} here but it {isnt_initialized}\"));\n \n-        // We use the statements were the binding was initialized, and inspect the HIR to look\n-        // for the branching codepaths that aren't covered, to point at them.\n-        let hir_id = self.mir_hir_id();\n-        let map = self.infcx.tcx.hir();\n-        let body_id = map.body_owned_by(hir_id);\n-        let body = map.body(body_id);\n-\n-        let mut visitor = ConditionVisitor { spans: &spans, name: &name, errors: vec![] };\n-        visitor.visit_body(&body);\n-        if visitor.errors.is_empty() {\n-            for sp in &spans {\n-                if *sp < span && !sp.overlaps(span) {\n-                    err.span_label(*sp, \"binding initialized here in some conditions\");\n-                }\n-            }\n-        }\n+        let mut shown = false;\n         for (sp, label) in visitor.errors {\n             if sp < span && !sp.overlaps(span) {\n                 // When we have a case like `match-cfg-fake-edges.rs`, we don't want to mention\n@@ -404,6 +414,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // };\n                 // ```\n                 err.span_label(sp, &label);\n+                shown = true;\n+            }\n+        }\n+        if !shown {\n+            for sp in &spans {\n+                if *sp < span && !sp.overlaps(span) {\n+                    err.span_label(*sp, \"binding initialized here in some conditions\");\n+                }\n             }\n         }\n         err.span_label(decl_span, \"binding declared here but left uninitialized\");"}, {"sha": "250aa482e5c675012bb30ce48b460a7e6275181f", "filename": "src/test/ui/nll/match-cfg-fake-edges.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a86fa4fa388b25c182146d29c88243325d66c130/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a86fa4fa388b25c182146d29c88243325d66c130/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-cfg-fake-edges.stderr?ref=a86fa4fa388b25c182146d29c88243325d66c130", "patch": "@@ -1,11 +1,14 @@\n-error[E0381]: used binding `x` is possibly-uninitialized\n+error[E0381]: used binding `x` isn't initialized\n   --> $DIR/match-cfg-fake-edges.rs:21:13\n    |\n LL |     let x;\n    |         - binding declared here but left uninitialized\n ...\n+LL |         _ if { x = 2; true } => 1,\n+   |                ----- binding initialized here in some conditions\n+LL |         _ if {\n LL |             x;\n-   |             ^ `x` used here but it is possibly-uninitialized\n+   |             ^ `x` used here but it isn't initialized\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/match-cfg-fake-edges.rs:35:13"}]}