{"sha": "778e6e8ba850668360319d5627fa4cfbca6a4fcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OGU2ZThiYTg1MDY2ODM2MDMxOWQ1NjI3ZmE0Y2ZiY2E2YTRmY2Y=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-31T12:04:34Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-31T12:04:34Z"}, "message": "add_explicit_type is applicable for closure parameters", "tree": {"sha": "f89f77536dd8a5c15e711c039f1cc8952539af30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f89f77536dd8a5c15e711c039f1cc8952539af30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/778e6e8ba850668360319d5627fa4cfbca6a4fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/778e6e8ba850668360319d5627fa4cfbca6a4fcf", "html_url": "https://github.com/rust-lang/rust/commit/778e6e8ba850668360319d5627fa4cfbca6a4fcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/778e6e8ba850668360319d5627fa4cfbca6a4fcf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f817833e7fbf29d8305b0b938b516d96e555ace", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f817833e7fbf29d8305b0b938b516d96e555ace", "html_url": "https://github.com/rust-lang/rust/commit/1f817833e7fbf29d8305b0b938b516d96e555ace"}], "stats": {"total": 209, "additions": 128, "deletions": 81}, "files": [{"sha": "5375095df66c822a668ec0089692a79c0afcb698", "filename": "crates/ide_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 93, "deletions": 77, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=778e6e8ba850668360319d5627fa4cfbca6a4fcf", "patch": "@@ -1,8 +1,5 @@\n use hir::HirDisplay;\n-use syntax::{\n-    ast::{self, AstNode, LetStmt},\n-    TextRange,\n-};\n+use syntax::ast::{self, AstNode, LetStmt, Param};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -22,40 +19,46 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n // ```\n pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let let_stmt = ctx.find_node_at_offset::<LetStmt>()?;\n-    let module = ctx.sema.scope(let_stmt.syntax()).module()?;\n-    let expr = let_stmt.initializer()?;\n-    // Must be a binding\n-    let pat = match let_stmt.pat()? {\n-        ast::Pat::IdentPat(bind_pat) => bind_pat,\n-        _ => return None,\n-    };\n-    let pat_range = pat.syntax().text_range();\n+    let (ascribed_ty, expr, pat) = if let Some(let_stmt) = ctx.find_node_at_offset::<LetStmt>() {\n+        let cursor_in_range = {\n+            let eq_range = let_stmt.eq_token()?.text_range();\n+            ctx.offset() < eq_range.start()\n+        };\n+        if !cursor_in_range {\n+            cov_mark::hit!(add_explicit_type_not_applicable_if_cursor_after_equals);\n+            return None;\n+        }\n \n-    // Assist should only be applicable if cursor is between 'let' and '='\n-    let cursor_in_range = {\n-        let stmt_range = let_stmt.syntax().text_range();\n-        let eq_range = let_stmt.eq_token()?.text_range();\n-        let let_range = TextRange::new(stmt_range.start(), eq_range.start());\n-        let_range.contains_range(ctx.frange.range)\n-    };\n-    if !cursor_in_range {\n-        cov_mark::hit!(add_explicit_type_not_applicable_if_cursor_after_equals);\n+        (let_stmt.ty(), let_stmt.initializer(), let_stmt.pat()?)\n+    } else if let Some(param) = ctx.find_node_at_offset::<Param>() {\n+        if param.syntax().ancestors().nth(2).and_then(ast::ClosureExpr::cast).is_none() {\n+            cov_mark::hit!(add_explicit_type_not_applicable_in_fn_param);\n+            return None;\n+        }\n+        (param.ty(), None, param.pat()?)\n+    } else {\n         return None;\n-    }\n+    };\n+\n+    let module = ctx.sema.scope(pat.syntax()).module()?;\n+    let pat_range = pat.syntax().text_range();\n \n-    // Assist not applicable if the type has already been specified\n-    // and it has no placeholders\n-    let ascribed_ty = let_stmt.ty();\n+    // Don't enable the assist if there is a type ascription without any placeholders\n     if let Some(ty) = &ascribed_ty {\n-        if ty.syntax().descendants().find_map(ast::InferType::cast).is_none() {\n+        let mut contains_infer_ty = false;\n+        ty.walk(&mut |ty| contains_infer_ty |= matches!(ty, ast::Type::InferType(_)));\n+        if !contains_infer_ty {\n             cov_mark::hit!(add_explicit_type_not_applicable_if_ty_already_specified);\n             return None;\n         }\n     }\n \n-    // Infer type\n-    let (ty, _) = ctx.sema.type_of_expr_with_coercion(&expr)?;\n+    let ty = match (pat, expr) {\n+        (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr_with_coercion(&expr)?.0,\n+        (pat, _) => ctx.sema.type_of_pat(&pat)?,\n+    };\n+\n+    // Unresolved or unnameable types can't be annotated\n     if ty.contains_unknown() || ty.is_closure() {\n         cov_mark::hit!(add_explicit_type_not_applicable_if_ty_not_inferred);\n         return None;\n@@ -89,7 +92,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn add_explicit_type_works_for_simple_expr() {\n+    fn add_explicit_type_simple() {\n         check_assist(\n             add_explicit_type,\n             r#\"fn f() { let a$0 = 1; }\"#,\n@@ -98,7 +101,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn add_explicit_type_works_for_underscore() {\n+    fn add_explicit_type_simple_on_infer_ty() {\n         check_assist(\n             add_explicit_type,\n             r#\"fn f() { let a$0: _ = 1; }\"#,\n@@ -107,19 +110,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn add_explicit_type_works_for_nested_underscore() {\n+    fn add_explicit_type_simple_nested_infer_ty() {\n         check_assist(\n             add_explicit_type,\n             r#\"\n-enum Option<T> { Some(T), None }\n-\n+//- minicore: option\n fn f() {\n     let a$0: Option<_> = Option::Some(1);\n }\n \"#,\n             r#\"\n-enum Option<T> { Some(T), None }\n-\n fn f() {\n     let a: Option<i32> = Option::Some(1);\n }\n@@ -128,7 +128,7 @@ fn f() {\n     }\n \n     #[test]\n-    fn add_explicit_type_works_for_macro_call() {\n+    fn add_explicit_type_macro_call_expr() {\n         check_assist(\n             add_explicit_type,\n             r\"macro_rules! v { () => {0u64} } fn f() { let a$0 = v!(); }\",\n@@ -137,64 +137,31 @@ fn f() {\n     }\n \n     #[test]\n-    fn add_explicit_type_works_for_macro_call_recursive() {\n-        check_assist(\n-            add_explicit_type,\n-            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a$0 = v!(); }\"#,\n-            r#\"macro_rules! u { () => {0u64} } macro_rules! v { () => {u!()} } fn f() { let a: u64 = v!(); }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn add_explicit_type_not_applicable_if_ty_not_inferred() {\n+    fn add_explicit_type_not_applicable_unresolved() {\n         cov_mark::check!(add_explicit_type_not_applicable_if_ty_not_inferred);\n         check_assist_not_applicable(add_explicit_type, r#\"fn f() { let a$0 = None; }\"#);\n     }\n \n     #[test]\n-    fn add_explicit_type_not_applicable_if_ty_already_specified() {\n-        cov_mark::check!(add_explicit_type_not_applicable_if_ty_already_specified);\n-        check_assist_not_applicable(add_explicit_type, r#\"fn f() { let a$0: i32 = 1; }\"#);\n+    fn add_explicit_type_not_applicable_closure_expr() {\n+        check_assist_not_applicable(add_explicit_type, r#\"fn f() { let a$0 = || {}; }\"#);\n     }\n \n     #[test]\n-    fn add_explicit_type_not_applicable_if_specified_ty_is_tuple() {\n-        check_assist_not_applicable(\n-            add_explicit_type,\n-            r#\"fn f() { let a$0: (i32, i32) = (3, 4); }\"#,\n-        );\n+    fn add_explicit_type_not_applicable_ty_already_specified() {\n+        cov_mark::check!(add_explicit_type_not_applicable_if_ty_already_specified);\n+        check_assist_not_applicable(add_explicit_type, r#\"fn f() { let a$0: i32 = 1; }\"#);\n     }\n \n     #[test]\n-    fn add_explicit_type_not_applicable_if_cursor_after_equals() {\n+    fn add_explicit_type_not_applicable_cursor_after_equals_of_let() {\n         cov_mark::check!(add_explicit_type_not_applicable_if_cursor_after_equals);\n         check_assist_not_applicable(\n             add_explicit_type,\n             r#\"fn f() {let a =$0 match 1 {2 => 3, 3 => 5};}\"#,\n         )\n     }\n \n-    #[test]\n-    fn add_explicit_type_not_applicable_if_cursor_before_let() {\n-        check_assist_not_applicable(\n-            add_explicit_type,\n-            r#\"fn f() $0{let a = match 1 {2 => 3, 3 => 5};}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn closure_parameters_are_not_added() {\n-        check_assist_not_applicable(\n-            add_explicit_type,\n-            r#\"\n-fn main() {\n-    let multiply_by_two$0 = |i| i * 3;\n-    let six = multiply_by_two(2);\n-}\n-\"#,\n-        )\n-    }\n-\n     /// https://github.com/rust-analyzer/rust-analyzer/issues/2922\n     #[test]\n     fn regression_issue_2922() {\n@@ -276,6 +243,55 @@ fn f() {\n fn f() {\n     let x: *const [i32] = &[3];\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_explicit_type_not_applicable_fn_param() {\n+        cov_mark::check!(add_explicit_type_not_applicable_in_fn_param);\n+        check_assist_not_applicable(add_explicit_type, r#\"fn f(x$0: ()) {}\"#);\n+    }\n+\n+    #[test]\n+    fn add_explicit_type_ascribes_closure_param() {\n+        check_assist(\n+            add_explicit_type,\n+            r#\"\n+fn f() {\n+    |y$0| {\n+        let x: i32 = y;\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    |y: i32| {\n+        let x: i32 = y;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_explicit_type_ascribes_closure_param_already_ascribed() {\n+        check_assist(\n+            add_explicit_type,\n+            r#\"\n+//- minicore: option\n+fn f() {\n+    |mut y$0: Option<_>| {\n+        y = Some(3);\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    |mut y: Option<i32>| {\n+        y = Some(3);\n+    };\n+}\n \"#,\n         );\n     }"}, {"sha": "968f2057b47b5c4f3eca5e314816a8e39961dabe", "filename": "crates/ide_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=778e6e8ba850668360319d5627fa4cfbca6a4fcf", "patch": "@@ -26,7 +26,6 @@ use crate::{\n //     if y { B } else { A }\n // }\n // ```\n-\n pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_syntax_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent()?)?;"}, {"sha": "0a540d9cfb3098a191e704d5d17e74523af341a5", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/778e6e8ba850668360319d5627fa4cfbca6a4fcf/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=778e6e8ba850668360319d5627fa4cfbca6a4fcf", "patch": "@@ -64,13 +64,45 @@ impl ast::Pat {\n                 WalkEvent::Enter(node) => node,\n                 WalkEvent::Leave(_) => continue,\n             };\n-            match ast::Pat::cast(node.clone()) {\n-                Some(ast::Pat::ConstBlockPat(_)) => preorder.skip_subtree(),\n+            let kind = node.kind();\n+            match ast::Pat::cast(node) {\n+                Some(pat @ ast::Pat::ConstBlockPat(_)) => {\n+                    preorder.skip_subtree();\n+                    cb(pat);\n+                }\n                 Some(pat) => {\n                     cb(pat);\n                 }\n                 // skip const args\n-                None if ast::GenericArg::can_cast(node.kind()) => {\n+                None if ast::GenericArg::can_cast(kind) => {\n+                    preorder.skip_subtree();\n+                }\n+                None => (),\n+            }\n+        }\n+    }\n+}\n+\n+impl ast::Type {\n+    /// Preorder walk all the type's sub types.\n+    pub fn walk(&self, cb: &mut dyn FnMut(ast::Type)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            let kind = node.kind();\n+            match ast::Type::cast(node) {\n+                Some(ty @ ast::Type::MacroType(_)) => {\n+                    preorder.skip_subtree();\n+                    cb(ty)\n+                }\n+                Some(ty) => {\n+                    cb(ty);\n+                }\n+                // skip const args\n+                None if ast::ConstArg::can_cast(kind) => {\n                     preorder.skip_subtree();\n                 }\n                 None => (),"}]}