{"sha": "33375a31e884043961b374ab7c654e4cd9e98527", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMzc1YTMxZTg4NDA0Mzk2MWIzNzRhYjdjNjU0ZTRjZDllOTg1Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-24T04:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-24T04:01:42Z"}, "message": "auto merge of #10514 : sfackler/rust/mut, r=cmr\n\nThis is based off of @blake2-ppc's work on #9429. That PR bitrotted and I haven't been able to contact the original author so I decided to take up the cause.\r\n\r\nOverview\r\n======\r\n`Mut` encapsulates a mutable, non-nullable slot. The `Cell` type is currently used to do this, but `Cell` is much more commonly used as a workaround for the inability to move values into non-once functions. `Mut` provides a more robust API.\r\n\r\n`Mut` duplicates the semantics of borrowed pointers with enforcement at runtime instead of compile time.\r\n```rust\r\nlet x = Mut::new(0);\r\n\r\n{\r\n    // make some immutable borrows\r\n    let p = x.borrow();\r\n    let y = *p.get() + 10;\r\n\r\n    // multiple immutable borrows are allowed simultaneously\r\n    let p2 = x.borrow();\r\n\r\n    // this would throw a runtime failure\r\n    // let p_mut = x.borrow_mut();\r\n}\r\n\r\n// now we can mutably borrow\r\nlet p = x.borrow_mut();\r\n*p.get() = 10;\r\n```\r\n`borrow` returns a `Ref` type and `borrow_mut` returns a `RefMut` type, both of which are simple smart pointer types with a single method, `get`, which returns a reference to the wrapped data.\r\n\r\nThis also allows `RcMut<T>` to be deleted, as it can be replaced with `Rc<Mut<T>>`.\r\n\r\nChanges\r\n======\r\nI've done things a little bit differently than the original proposal.\r\n\r\n* I've added `try_borrow` and `try_borrow_mut` methods that return `Option<Ref<T>>` and `Option<RefMut<T>>` respectively instead of failing on a borrow check failure. I'm not totally sure when that'd be useful, but I don't see any reason to not put them in and @cmr requested them.\r\n* `ReadPtr` and `WritePtr` have been renamed to `Ref` and `RefMut` respectively, as `Ref` is to `ref foo` and `RefMut` is to `ref mut foo` as `Mut` is to `mut foo`.\r\n* `get` on `MutRef` now takes `&self` instead of `&mut self` for consistency with `&mut`. As @alexcrichton pointed, out this violates soundness by allowing aliasing `&mut` references.\r\n* `Cell` is being left as is. It solves a different problem than `Mut` is designed to solve.\r\n* There are no longer methods implemented for `Mut<Option<T>>`. Since `Cell` isn't going away, there's less of a need for these, and I didn't feel like they provided a huge benefit, especially as that kind of `impl` is very uncommon in the standard library.\r\n\r\nOpen Questions\r\n============\r\n* `Cell` should now be used exclusively for movement into closures. Should this be enforced by reducing its API to `new` and `take`? It seems like this use case will be completely going away once the transition to `proc` and co. finishes.\r\n* Should there be `try_map` and `try_map_mut` methods along with `map` and `map_mut`?", "tree": {"sha": "ac4dec3fe4a5319193a099c11235e96ee7b59b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac4dec3fe4a5319193a099c11235e96ee7b59b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33375a31e884043961b374ab7c654e4cd9e98527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33375a31e884043961b374ab7c654e4cd9e98527", "html_url": "https://github.com/rust-lang/rust/commit/33375a31e884043961b374ab7c654e4cd9e98527", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33375a31e884043961b374ab7c654e4cd9e98527/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cbc57cadbf8dfb2053893c917fb89ccbca0f253", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cbc57cadbf8dfb2053893c917fb89ccbca0f253", "html_url": "https://github.com/rust-lang/rust/commit/6cbc57cadbf8dfb2053893c917fb89ccbca0f253"}, {"sha": "bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "html_url": "https://github.com/rust-lang/rust/commit/bdfaf04bd507bf99cff392c0a0c2df65ede96f69"}], "stats": {"total": 797, "additions": 437, "deletions": 360}, "files": [{"sha": "8af370792aee158f121c280ee56d4c64216e95da", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -24,7 +24,6 @@ use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n-use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n@@ -106,16 +105,15 @@ pub struct RegionVarBindings {\n     undo_log: ~[UndoLogEntry],\n \n     // This contains the results of inference.  It begins as an empty\n-    // cell and only acquires a value after inference is complete.\n-    // We use a cell vs a mutable option to circumvent borrowck errors.\n-    values: Cell<~[VarValue]>,\n+    // option and only acquires a value after inference is complete.\n+    values: Option<~[VarValue]>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n         var_origins: ~[],\n-        values: Cell::new_empty(),\n+        values: None,\n         constraints: HashMap::new(),\n         lubs: HashMap::new(),\n         glbs: HashMap::new(),\n@@ -226,7 +224,7 @@ impl RegionVarBindings {\n                           constraint: Constraint,\n                           origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n@@ -242,7 +240,7 @@ impl RegionVarBindings {\n                           sub: Region,\n                           sup: Region) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n@@ -277,7 +275,7 @@ impl RegionVarBindings {\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -300,7 +298,7 @@ impl RegionVarBindings {\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -319,14 +317,14 @@ impl RegionVarBindings {\n     }\n \n     pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        if self.values.is_empty() {\n-            self.tcx.sess.span_bug(\n+        let v = match self.values {\n+            None => self.tcx.sess.span_bug(\n                 self.var_origins[rid.to_uint()].span(),\n                 format!(\"Attempt to resolve region variable before values have \\\n-                      been computed!\"));\n-        }\n+                      been computed!\")),\n+            Some(ref values) => values[rid.to_uint()]\n+        };\n \n-        let v = self.values.with_ref(|values| values[rid.to_uint()]);\n         debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n                rid, rid.to_uint(), v);\n         match v {\n@@ -482,7 +480,7 @@ impl RegionVarBindings {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n-        self.values.put_back(v);\n+        self.values = Some(v);\n         errors\n     }\n }"}, {"sha": "019cd53be55bccc960c8d4cc62a8cb2e23bf851a", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 294, "deletions": 56, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A mutable, nullable memory location\n+//! Types dealing with dynamic mutability\n \n #[missing_doc];\n \n-use cast::transmute_mut;\n-use unstable::finally::Finally;\n use prelude::*;\n+use cast;\n+use util::NonCopyable;\n+\n \n /*\n A dynamic, mutable location.\n@@ -35,14 +36,9 @@ impl<T> Cell<T> {\n         Cell { value: Some(value) }\n     }\n \n-    /// Creates a new empty cell with no value inside.\n-    pub fn new_empty() -> Cell<T> {\n-        Cell { value: None }\n-    }\n-\n     /// Yields the value, failing if the cell is empty.\n     pub fn take(&self) -> T {\n-        let this = unsafe { transmute_mut(self) };\n+        let this = unsafe { cast::transmute_mut(self) };\n         if this.is_empty() {\n             fail!(\"attempt to take an empty cell\");\n         }\n@@ -52,38 +48,14 @@ impl<T> Cell<T> {\n \n     /// Yields the value if the cell is full, or `None` if it is empty.\n     pub fn take_opt(&self) -> Option<T> {\n-        let this = unsafe { transmute_mut(self) };\n+        let this = unsafe { cast::transmute_mut(self) };\n         this.value.take()\n     }\n \n-    /// Returns the value, failing if the cell is full.\n-    pub fn put_back(&self, value: T) {\n-        let this = unsafe { transmute_mut(self) };\n-        if !this.is_empty() {\n-            fail!(\"attempt to put a value back into a full cell\");\n-        }\n-        this.value = Some(value);\n-    }\n-\n     /// Returns true if the cell is empty and false if the cell is full.\n     pub fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n-\n-    /// Calls a closure with a reference to the value.\n-    pub fn with_ref<R>(&self, op: |v: &T| -> R) -> R {\n-        do self.with_mut_ref |ptr| { op(ptr) }\n-    }\n-\n-    /// Calls a closure with a mutable reference to the value.\n-    pub fn with_mut_ref<R>(&self, op: |v: &mut T| -> R) -> R {\n-        let mut v = Some(self.take());\n-        do (|| {\n-            op(v.get_mut_ref())\n-        }).finally {\n-            self.put_back(v.take_unwrap());\n-        }\n-    }\n }\n \n #[test]\n@@ -93,38 +65,304 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert!(value == ~10);\n     assert!(value_cell.is_empty());\n-    value_cell.put_back(value);\n-    assert!(!value_cell.is_empty());\n }\n \n #[test]\n #[should_fail]\n fn test_take_empty() {\n-    let value_cell: Cell<~int> = Cell::new_empty();\n+    let value_cell: Cell<~int> = Cell::new(~0);\n+    value_cell.take();\n     value_cell.take();\n }\n \n-#[test]\n-#[should_fail]\n-fn test_put_back_non_empty() {\n-    let value_cell = Cell::new(~10);\n-    value_cell.put_back(~20);\n+\n+/// A mutable memory location with dynamically checked borrow rules\n+#[no_freeze]\n+pub struct RefCell<T> {\n+    priv value: T,\n+    priv borrow: BorrowFlag,\n+    priv nc: NonCopyable\n }\n \n-#[test]\n-fn test_with_ref() {\n-    let good = 6;\n-    let c = Cell::new(~[1, 2, 3, 4, 5, 6]);\n-    let l = do c.with_ref() |v| { v.len() };\n-    assert_eq!(l, good);\n+// Values [1, MAX-1] represent the number of `Ref` active\n+// (will not outgrow its range since `uint` is the size of the address space)\n+type BorrowFlag = uint;\n+static UNUSED: BorrowFlag = 0;\n+static WRITING: BorrowFlag = -1;\n+\n+impl<T> RefCell<T> {\n+    /// Create a new `RefCell` containing `value`\n+    pub fn new(value: T) -> RefCell<T> {\n+        RefCell {\n+            value: value,\n+            borrow: UNUSED,\n+            nc: NonCopyable\n+        }\n+    }\n+\n+    /// Consumes the `RefCell`, returning the wrapped value.\n+    pub fn unwrap(self) -> T {\n+        assert!(self.borrow == UNUSED);\n+        self.value\n+    }\n+\n+    unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {\n+        cast::transmute_mut(self)\n+    }\n+\n+    /// Attempts to immutably borrow the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// Returns `None` if the value is currently mutably borrowed.\n+    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n+        match self.borrow {\n+            WRITING => None,\n+            _ => {\n+                unsafe { self.as_mut().borrow += 1; }\n+                Some(Ref { parent: self })\n+            }\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n+        match self.try_borrow() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"RefCell<T> already mutably borrowed\")\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// Returns `None` if the value is currently borrowed.\n+    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n+        match self.borrow {\n+            UNUSED => unsafe {\n+                let mut_self = self.as_mut();\n+                mut_self.borrow = WRITING;\n+                Some(RefMut { parent: mut_self })\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n+        match self.try_borrow_mut() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"RefCell<T> already borrowed\")\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    #[inline]\n+    pub fn with<U>(&self, blk: |&T| -> U) -> U {\n+        let ptr = self.borrow();\n+        blk(ptr.get())\n+    }\n+\n+    /// Mutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    #[inline]\n+    pub fn with_mut<U>(&self, blk: |&mut T| -> U) -> U {\n+        let mut ptr = self.borrow_mut();\n+        blk(ptr.get())\n+    }\n }\n \n-#[test]\n-fn test_with_mut_ref() {\n-    let good = ~[1, 2, 3];\n-    let v = ~[1, 2];\n-    let c = Cell::new(v);\n-    do c.with_mut_ref() |v| { v.push(3); }\n-    let v = c.take();\n-    assert_eq!(v, good);\n+impl<T: Clone> Clone for RefCell<T> {\n+    fn clone(&self) -> RefCell<T> {\n+        let x = self.borrow();\n+        RefCell::new(x.get().clone())\n+    }\n+}\n+\n+impl<T: DeepClone> DeepClone for RefCell<T> {\n+    fn deep_clone(&self) -> RefCell<T> {\n+        let x = self.borrow();\n+        RefCell::new(x.get().deep_clone())\n+    }\n+}\n+\n+impl<T: Eq> Eq for RefCell<T> {\n+    fn eq(&self, other: &RefCell<T>) -> bool {\n+        let a = self.borrow();\n+        let b = other.borrow();\n+        a.get() == b.get()\n+    }\n+}\n+\n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n+pub struct Ref<'box, T> {\n+    priv parent: &'box RefCell<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for Ref<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n+        unsafe { self.parent.as_mut().borrow -= 1; }\n+    }\n+}\n+\n+impl<'box, T> Ref<'box, T> {\n+    /// Retrieve an immutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a T {\n+        &self.parent.value\n+    }\n+}\n+\n+/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+pub struct RefMut<'box, T> {\n+    priv parent: &'box mut RefCell<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for RefMut<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow == WRITING);\n+        self.parent.borrow = UNUSED;\n+    }\n+}\n+\n+impl<'box, T> RefMut<'box, T> {\n+    /// Retrieve a mutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.parent.value\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn double_imm_borrow() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn no_mut_then_imm_borrow() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow().is_none());\n+    }\n+\n+    #[test]\n+    fn no_imm_then_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn no_double_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn imm_release_borrow_mut() {\n+        let x = RefCell::new(0);\n+        {\n+            let _b1 = x.borrow();\n+        }\n+        x.borrow_mut();\n+    }\n+\n+    #[test]\n+    fn mut_release_borrow_mut() {\n+        let x = RefCell::new(0);\n+        {\n+            let _b1 = x.borrow_mut();\n+        }\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn double_borrow_single_release_no_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        {\n+            let _b2 = x.borrow();\n+        }\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn with_ok() {\n+        let x = RefCell::new(0);\n+        assert_eq!(1, x.with(|x| *x+1));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn mut_borrow_with() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        x.with(|x| *x+1);\n+    }\n+\n+    #[test]\n+    fn borrow_with() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        assert_eq!(1, x.with(|x| *x+1));\n+    }\n+\n+    #[test]\n+    fn with_mut_ok() {\n+        let x = RefCell::new(0);\n+        x.with_mut(|x| *x += 1);\n+        let b = x.borrow();\n+        assert_eq!(1, *b.get());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn borrow_with_mut() {\n+        let x = RefCell::new(0);\n+        let _b = x.borrow();\n+        x.with_mut(|x| *x += 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn discard_doesnt_unborrow() {\n+        let x = RefCell::new(0);\n+        let _b = x.borrow();\n+        let _ = _b;\n+        let _b = x.borrow_mut();\n+    }\n }"}, {"sha": "5fe11d310d4675f8b1130f7c2b4a15ca8d4d3803", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -55,26 +55,26 @@ impl<T: DeepClone + Send + 'static> DeepClone for Gc<T> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use cell::Cell;\n+    use cell::RefCell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Gc::new(Cell::new(5));\n+        let x = Gc::new(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 20);\n+        assert_eq!(y.borrow().with(|x| *x), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Gc::new(Cell::new(5));\n+        let x = Gc::new(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 5);\n+        assert_eq!(y.borrow().with(|x| *x), 5);\n     }\n \n     #[test]"}, {"sha": "242533773d7cec59cddae60049a8797078c11dd9", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 21, "deletions": 241, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -14,17 +14,14 @@ The `Rc` type provides shared ownership of an immutable value. Destruction is de\n will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n overhead of atomic reference counting.\n \n-The `RcMut` type provides shared ownership of a mutable value. Since multiple owners prevent\n-inherited mutability, a dynamic freezing check is used to maintain the invariant that an `&mut`\n-reference is a unique handle and the type is marked as non-`Freeze`.\n-\n */\n \n use ptr::RawPtr;\n use unstable::intrinsics::transmute;\n use ops::Drop;\n use kinds::{Freeze, Send};\n use clone::{Clone, DeepClone};\n+use cell::RefCell;\n \n struct RcBox<T> {\n     value: T,\n@@ -58,6 +55,16 @@ impl<T: Send> Rc<T> {\n     }\n }\n \n+impl<T: Freeze> Rc<RefCell<T>> {\n+    /// Construct a new reference-counted box from a `RefCell`-wrapped `Freeze` value\n+    #[inline]\n+    pub fn from_mut(value: RefCell<T>) -> Rc<RefCell<T>> {\n+        unsafe {\n+            Rc::new_unchecked(value)\n+        }\n+    }\n+}\n+\n impl<T> Rc<T> {\n     /// Unsafety construct a new reference-counted box from any value.\n     ///\n@@ -109,26 +116,26 @@ impl<T> Drop for Rc<T> {\n #[cfg(test)]\n mod test_rc {\n     use super::*;\n-    use cell::Cell;\n+    use cell::RefCell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::from_send(Cell::new(5));\n+        let x = Rc::from_send(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 20);\n+        assert_eq!(y.borrow().with(|v| *v), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::from_send(Cell::new(5));\n+        let x = Rc::from_send(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 5);\n+        assert_eq!(y.borrow().with(|v| *v), 5);\n     }\n \n     #[test]\n@@ -150,237 +157,10 @@ mod test_rc {\n         let x = Rc::from_send(~5);\n         assert_eq!(**x.borrow(), 5);\n     }\n-}\n-\n-#[deriving(Eq)]\n-enum Borrow {\n-    Mutable,\n-    Immutable,\n-    Nothing\n-}\n-\n-struct RcMutBox<T> {\n-    value: T,\n-    count: uint,\n-    borrow: Borrow\n-}\n-\n-/// Mutable reference counted pointer type\n-#[no_send]\n-#[no_freeze]\n-#[unsafe_no_drop_flag]\n-pub struct RcMut<T> {\n-    priv ptr: *mut RcMutBox<T>,\n-}\n-\n-impl<T: Freeze> RcMut<T> {\n-    /// Construct a new mutable reference-counted box from a `Freeze` value\n-    #[inline]\n-    pub fn new(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new_unchecked(value) }\n-    }\n-}\n-\n-impl<T: Send> RcMut<T> {\n-    /// Construct a new mutable reference-counted box from a `Send` value\n-    #[inline]\n-    pub fn from_send(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new_unchecked(value) }\n-    }\n-}\n-\n-impl<T> RcMut<T> {\n-    /// Unsafety construct a new mutable reference-counted box from any value.\n-    ///\n-    /// It is possible to create cycles, which will leak, and may interact\n-    /// poorly with managed pointers.\n-    #[inline]\n-    pub unsafe fn new_unchecked(value: T) -> RcMut<T> {\n-        RcMut{ptr: transmute(~RcMutBox{value: value, count: 1, borrow: Nothing})}\n-    }\n-}\n-\n-impl<T> RcMut<T> {\n-    /// Fails if there is already a mutable borrow of the box\n-    #[inline]\n-    pub fn with_borrow<U>(&self, f: |&T| -> U) -> U {\n-        unsafe {\n-            assert!((*self.ptr).borrow != Mutable);\n-            let previous = (*self.ptr).borrow;\n-            (*self.ptr).borrow = Immutable;\n-            let res = f(&(*self.ptr).value);\n-            (*self.ptr).borrow = previous;\n-            res\n-        }\n-    }\n-\n-    /// Fails if there is already a mutable or immutable borrow of the box\n-    #[inline]\n-    pub fn with_mut_borrow<U>(&self, f: |&mut T| -> U) -> U {\n-        unsafe {\n-            assert_eq!((*self.ptr).borrow, Nothing);\n-            (*self.ptr).borrow = Mutable;\n-            let res = f(&mut (*self.ptr).value);\n-            (*self.ptr).borrow = Nothing;\n-            res\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for RcMut<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.ptr.is_not_null() {\n-                (*self.ptr).count -= 1;\n-                if (*self.ptr).count == 0 {\n-                    let _: ~RcMutBox<T> = transmute(self.ptr);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for RcMut<T> {\n-    /// Return a shallow copy of the reference counted pointer.\n-    #[inline]\n-    fn clone(&self) -> RcMut<T> {\n-        unsafe {\n-            (*self.ptr).count += 1;\n-            RcMut{ptr: self.ptr}\n-        }\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for RcMut<T> {\n-    /// Return a deep copy of the reference counted pointer.\n-    #[inline]\n-    fn deep_clone(&self) -> RcMut<T> {\n-        do self.with_borrow |x| {\n-            // FIXME: #6497: should avoid freeze (slow)\n-            unsafe { RcMut::new_unchecked(x.deep_clone()) }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_rc_mut {\n-    use super::*;\n \n     #[test]\n-    fn test_clone() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-        do x.with_mut_borrow |value| {\n-            *value = 20;\n-        }\n-        do y.with_borrow |value| {\n-            assert_eq!(*value, 20);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_deep_clone() {\n-        let x = RcMut::new(5);\n-        let y = x.deep_clone();\n-        do x.with_mut_borrow |value| {\n-            *value = 20;\n-        }\n-        do y.with_borrow |value| {\n-            assert_eq!(*value, 5);\n-        }\n-    }\n-\n-    #[test]\n-    fn borrow_many() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |a| {\n-            assert_eq!(*a, 5);\n-            do y.with_borrow |b| {\n-                assert_eq!(*b, 5);\n-                do x.with_borrow |c| {\n-                    assert_eq!(*c, 5);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn modify() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do y.with_mut_borrow |a| {\n-            assert_eq!(*a, 5);\n-            *a = 6;\n-        }\n-\n-        do x.with_borrow |a| {\n-            assert_eq!(*a, 6);\n-        }\n-    }\n-\n-    #[test]\n-    fn release_immutable() {\n-        let x = RcMut::from_send(5);\n-        do x.with_borrow |_| {}\n-        do x.with_mut_borrow |_| {}\n-    }\n-\n-    #[test]\n-    fn release_mutable() {\n-        let x = RcMut::new(5);\n-        do x.with_mut_borrow |_| {}\n-        do x.with_borrow |_| {}\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn frozen() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |_| {\n-            do y.with_mut_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mutable_dupe() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do x.with_mut_borrow |_| {\n-            do y.with_mut_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mutable_freeze() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_mut_borrow |_| {\n-            do y.with_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn restore_freeze() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |_| {\n-            do x.with_borrow |_| {}\n-            do y.with_mut_borrow |_| {}\n-        }\n+    fn test_from_mut() {\n+        let a = 10;\n+        let _x = Rc::from_mut(RefCell::new(&a));\n     }\n }"}, {"sha": "8635f9372c472c9b2d21bf6692d5b32b80d79e79", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -22,9 +22,10 @@ use rt::select::{SelectInner, SelectPortInner};\n use select::{Select, SelectPort};\n use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n use unstable::sync::UnsafeArc;\n+use util;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::Cell;\n+use cell::{Cell, RefCell};\n use clone::Clone;\n use tuple::ImmutableTuple;\n \n@@ -431,28 +432,28 @@ type StreamPortOne<T> = PortOne<StreamPayload<T>>;\n \n /// A channel with unbounded size.\n pub struct Chan<T> {\n-    // FIXME #5372. Using Cell because we don't take &mut self\n-    next: Cell<StreamChanOne<T>>\n+    // FIXME #5372. Using RefCell because we don't take &mut self\n+    next: RefCell<StreamChanOne<T>>\n }\n \n /// An port with unbounded size.\n pub struct Port<T> {\n-    // FIXME #5372. Using Cell because we don't take &mut self\n-    next: Cell<StreamPortOne<T>>\n+    // FIXME #5372. Using RefCell because we don't take &mut self\n+    next: RefCell<Option<StreamPortOne<T>>>\n }\n \n pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n     let (pone, cone) = oneshot();\n-    let port = Port { next: Cell::new(pone) };\n-    let chan = Chan { next: Cell::new(cone) };\n+    let port = Port { next: RefCell::new(Some(pone)) };\n+    let chan = Chan { next: RefCell::new(cone) };\n     return (port, chan);\n }\n \n impl<T: Send> Chan<T> {\n     fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n-        let (next_pone, next_cone) = oneshot();\n-        let cone = self.next.take();\n-        self.next.put_back(next_cone);\n+        let (next_pone, mut cone) = oneshot();\n+        let mut b = self.next.borrow_mut();\n+        util::swap(&mut cone, b.get());\n         cone.try_send_inner(StreamPayload { val: val, next: next_pone }, do_resched)\n     }\n }\n@@ -489,10 +490,11 @@ impl<T: Send> GenericPort<T> for Port<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        do self.next.take_opt().map_default(None) |pone| {\n+        let mut b = self.next.borrow_mut();\n+        do b.get().take().map_default(None) |pone| {\n             match pone.try_recv() {\n                 Some(StreamPayload { val, next }) => {\n-                    self.next.put_back(next);\n+                    *b.get() = Some(next);\n                     Some(val)\n                 }\n                 None => None\n@@ -503,7 +505,7 @@ impl<T: Send> GenericPort<T> for Port<T> {\n \n impl<T: Send> Peekable<T> for Port<T> {\n     fn peek(&self) -> bool {\n-        self.next.with_mut_ref(|p| p.peek())\n+        self.next.with_mut(|p| p.get_mut_ref().peek())\n     }\n }\n \n@@ -514,18 +516,18 @@ impl<T: Send> Peekable<T> for Port<T> {\n impl<'self, T: Send> SelectInner for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n-        do self.next.with_mut_ref |pone| { pone.optimistic_check() }\n+        do self.next.with_mut |pone| { pone.get_mut_ref().optimistic_check() }\n     }\n \n     #[inline]\n     fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        let task = Cell::new(task);\n-        do self.next.with_mut_ref |pone| { pone.block_on(sched, task.take()) }\n+        let mut b = self.next.borrow_mut();\n+        b.get().get_mut_ref().block_on(sched, task)\n     }\n \n     #[inline]\n     fn unblock_from(&mut self) -> bool {\n-        do self.next.with_mut_ref |pone| { pone.unblock_from() }\n+        do self.next.with_mut |pone| { pone.get_mut_ref().unblock_from() }\n     }\n }\n \n@@ -552,9 +554,10 @@ impl<T: Send> Select for Port<T> { }\n \n impl<'self, T: Send> SelectPortInner<T> for &'self Port<T> {\n     fn recv_ready(self) -> Option<T> {\n-        match self.next.take().recv_ready() {\n+        let mut b = self.next.borrow_mut();\n+        match b.get().take_unwrap().recv_ready() {\n             Some(StreamPayload { val, next }) => {\n-                self.next.put_back(next);\n+                *b.get() = Some(next);\n                 Some(val)\n             }\n             None => None\n@@ -571,7 +574,7 @@ pub struct SharedChan<T> {\n \n impl<T: Send> SharedChan<T> {\n     pub fn new(chan: Chan<T>) -> SharedChan<T> {\n-        let next = chan.next.take();\n+        let next = chan.next.unwrap();\n         let next = AtomicOption::new(~next);\n         SharedChan { next: UnsafeArc::new(next) }\n     }\n@@ -625,7 +628,7 @@ pub struct SharedPort<T> {\n impl<T: Send> SharedPort<T> {\n     pub fn new(port: Port<T>) -> SharedPort<T> {\n         // Put the data port into a new link pipe\n-        let next_data_port = port.next.take();\n+        let next_data_port = port.next.unwrap().unwrap();\n         let (next_link_port, next_link_chan) = oneshot();\n         next_link_chan.send(next_data_port);\n         let next_link = AtomicOption::new(~next_link_port);"}, {"sha": "f3b78ecd30c676423317d46182a516008171a78a", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -81,8 +81,7 @@ fn main() {\n     let num_tasks = from_str::<uint>(args[1]).unwrap();\n     let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n-    let (num_chan, num_port) = init();\n-    let num_chan = Cell::new(num_chan);\n+    let (mut num_chan, num_port) = init();\n \n     let start = time::precise_time_s();\n \n@@ -92,19 +91,19 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan.take());\n+        let num_chan2 = Cell::new(num_chan);\n         let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn() {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan.put_back(new_chan);\n+        num_chan = new_chan;\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n+    thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n     for f in futures.mut_iter() {"}, {"sha": "47b1e5903280ee22324fb32e38ddf57bf5acc396", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -77,8 +77,7 @@ fn main() {\n     let num_tasks = from_str::<uint>(args[1]).unwrap();\n     let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n-    let (num_chan, num_port) = init();\n-    let num_chan = Cell::new(num_chan);\n+    let (mut num_chan, num_port) = init();\n \n     let start = time::precise_time_s();\n \n@@ -88,19 +87,19 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan.take());\n+        let num_chan2 = Cell::new(num_chan);\n         let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan.put_back(new_chan);\n+        num_chan = new_chan;\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n+    thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n     for f in futures.mut_iter() {"}, {"sha": "9276a2f0d41941e5f0ac0cb5ca95c3228c67420a", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -8,21 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::RcMut;\n+use std::rc::Rc;\n+use std::cell::RefCell;\n \n trait Foo\n {\n-    fn set(&mut self, v: RcMut<A>);\n+    fn set(&mut self, v: Rc<RefCell<A>>);\n }\n \n struct B\n {\n-    v: Option<RcMut<A>>\n+    v: Option<Rc<RefCell<A>>>\n }\n \n impl Foo for B\n {\n-    fn set(&mut self, v: RcMut<A>)\n+    fn set(&mut self, v: Rc<RefCell<A>>)\n     {\n         self.v = Some(v);\n     }\n@@ -36,7 +37,9 @@ struct A\n fn main()\n {\n     let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n-    let v = RcMut::new(a); //~ ERROR instantiating a type parameter with an incompatible type\n+    let v = Rc::from_send(RefCell::new(a));\n     let w = v.clone();\n-    v.with_mut_borrow(|p| {p.v.set(w.clone());})\n+    let b = v.borrow();\n+    let mut b = b.borrow_mut();\n+    b.get().v.set(w.clone());\n }"}, {"sha": "f031467328f0b712b8fc0d4dc37b4860c38627b3", "filename": "src/test/compile-fail/mut-cant-alias.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let m = RefCell::new(0);\n+    let mut b = m.borrow_mut();\n+    let b1 = b.get();\n+    let b2 = b.get(); //~ ERROR cannot borrow `b` as mutable more than once at a time\n+}"}, {"sha": "97fe49ca087f544e52f89607f3bcd6b72833f169", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+fn f<T: Freeze>(_: T) {}\n+\n+fn main() {\n+    let x = RefCell::new(0);\n+    f(x); //~ ERROR: which does not fulfill `Freeze`\n+}"}, {"sha": "ca276700e8b61d1a26f5ca7d1ec4b4f8f20cae44", "filename": "src/test/compile-fail/mut-ptr-cant-outlive-ref.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let m = RefCell::new(0);\n+    let p;\n+    {\n+        let b = m.borrow();\n+        p = b.get(); //~ ERROR borrowed value does not live long enough\n+    }\n+}"}, {"sha": "7e0c8319356e47f8ca7110978bfac4ea91d1258d", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33375a31e884043961b374ab7c654e4cd9e98527/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=33375a31e884043961b374ab7c654e4cd9e98527", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::RcMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n \n fn o<T: Send>(_: &T) {}\n fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n-    let x = RcMut::from_send(0);\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Send`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Freeze`\n+    let x = Rc::from_send(RefCell::new(0));\n+    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Send`\n+    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n }"}]}