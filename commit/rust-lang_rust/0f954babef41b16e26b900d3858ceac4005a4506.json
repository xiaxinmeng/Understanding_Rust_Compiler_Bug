{"sha": "0f954babef41b16e26b900d3858ceac4005a4506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTU0YmFiZWY0MWIxNmUyNmI5MDBkMzg1OGNlYWM0MDA1YTQ1MDY=", "commit": {"author": {"name": "unknown", "email": "abramlujan@gmail.com", "date": "2020-11-29T04:47:32Z"}, "committer": {"name": "unknown", "email": "abramlujan@gmail.com", "date": "2020-12-03T23:54:28Z"}, "message": "Make the unsafe_sizeof_count_copies lint find copy_{from,to} method calls", "tree": {"sha": "2a7bd8b5617751452764fe4f0abc8024960c4e92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7bd8b5617751452764fe4f0abc8024960c4e92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f954babef41b16e26b900d3858ceac4005a4506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f954babef41b16e26b900d3858ceac4005a4506", "html_url": "https://github.com/rust-lang/rust/commit/0f954babef41b16e26b900d3858ceac4005a4506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f954babef41b16e26b900d3858ceac4005a4506/comments", "author": {"login": "nico-abram", "id": 24706838, "node_id": "MDQ6VXNlcjI0NzA2ODM4", "avatar_url": "https://avatars.githubusercontent.com/u/24706838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nico-abram", "html_url": "https://github.com/nico-abram", "followers_url": "https://api.github.com/users/nico-abram/followers", "following_url": "https://api.github.com/users/nico-abram/following{/other_user}", "gists_url": "https://api.github.com/users/nico-abram/gists{/gist_id}", "starred_url": "https://api.github.com/users/nico-abram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nico-abram/subscriptions", "organizations_url": "https://api.github.com/users/nico-abram/orgs", "repos_url": "https://api.github.com/users/nico-abram/repos", "events_url": "https://api.github.com/users/nico-abram/events{/privacy}", "received_events_url": "https://api.github.com/users/nico-abram/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nico-abram", "id": 24706838, "node_id": "MDQ6VXNlcjI0NzA2ODM4", "avatar_url": "https://avatars.githubusercontent.com/u/24706838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nico-abram", "html_url": "https://github.com/nico-abram", "followers_url": "https://api.github.com/users/nico-abram/followers", "following_url": "https://api.github.com/users/nico-abram/following{/other_user}", "gists_url": "https://api.github.com/users/nico-abram/gists{/gist_id}", "starred_url": "https://api.github.com/users/nico-abram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nico-abram/subscriptions", "organizations_url": "https://api.github.com/users/nico-abram/orgs", "repos_url": "https://api.github.com/users/nico-abram/repos", "events_url": "https://api.github.com/users/nico-abram/events{/privacy}", "received_events_url": "https://api.github.com/users/nico-abram/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6113066429bc3108f62b920ccbfc79accfef2dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6113066429bc3108f62b920ccbfc79accfef2dd", "html_url": "https://github.com/rust-lang/rust/commit/b6113066429bc3108f62b920ccbfc79accfef2dd"}], "stats": {"total": 131, "additions": 99, "deletions": 32}, "files": [{"sha": "5df7d72564ee1ef95d09f1831b8b3b72f1eb15b1", "filename": "clippy_lints/src/unsafe_sizeof_count_copies.rs", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0f954babef41b16e26b900d3858ceac4005a4506/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f954babef41b16e26b900d3858ceac4005a4506/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs?ref=0f954babef41b16e26b900d3858ceac4005a4506", "patch": "@@ -6,7 +6,7 @@ use if_chain::if_chain;\n use rustc_hir::BinOpKind;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Ty as TyM, TyS};\n+use rustc_middle::ty::{self, Ty, TyS, TypeAndMut};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -40,7 +40,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UnsafeSizeofCountCopies => [UNSAFE_SIZEOF_COUNT_COPIES]);\n \n-fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<TyM<'tcx>> {\n+fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Ty<'tcx>> {\n     match &expr.kind {\n         ExprKind::Call(ref count_func, _func_args) => {\n             if_chain! {\n@@ -62,35 +62,65 @@ fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<TyM<'t\n     }\n }\n \n+fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+        // Find calls to ptr::copy and copy_nonoverlapping\n+        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let [_src, _dest, count] = &**args;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if match_def_path(cx, def_id, &paths::COPY_NONOVERLAPPING)\n+            || match_def_path(cx, def_id, &paths::COPY);\n+\n+        // Get the pointee type\n+        if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    if_chain! {\n+        // Find calls to copy_{from,to}{,_nonoverlapping}\n+        if let ExprKind::MethodCall(ref method_path, _, ref args, _) = expr.kind;\n+        if let [ptr_self, _, count] = &**args;\n+        let method_ident = method_path.ident.as_str();\n+        if method_ident== \"copy_to\" || method_ident == \"copy_from\"\n+            || method_ident == \"copy_to_nonoverlapping\" || method_ident == \"copy_from_nonoverlapping\";\n+\n+        // Get the pointee type\n+        if let ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl:_mutability }) =\n+            cx.typeck_results().expr_ty(ptr_self).kind();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    None\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for UnsafeSizeofCountCopies {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // Find calls to ptr::copy and copy_nonoverlapping\n-            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n-            if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::COPY_NONOVERLAPPING)\n-                || match_def_path(cx, def_id, &paths::COPY);\n+        const HELP_MSG: &str = \"use a count of elements instead of a count of bytes \\\n+            for the count parameter, it already gets multiplied by the size of the pointed to type\";\n+\n+        const LINT_MSG: &str = \"unsafe memory copying using a byte count \\\n+            (Multiplied by size_of::<T>) instead of a count of T\";\n \n-            // Get the pointee type\n-            let _substs = cx.typeck_results().node_substs(func.hir_id);\n-            if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n+        if_chain! {\n+            // Find calls to unsafe copy functions and get\n+            // the pointee type and count parameter expression\n+            if let Some((pointee_ty, count_expr)) = get_pointee_ty_and_count_expr(cx, expr);\n \n             // Find a size_of call in the count parameter expression and\n             // check that it's the same type\n-            if let [_src, _dest, count] = &**func_args;\n-            if let Some(ty_used_for_size_of) = get_size_of_ty(cx, count);\n+            if let Some(ty_used_for_size_of) = get_size_of_ty(cx, count_expr);\n             if TyS::same_type(pointee_ty, ty_used_for_size_of);\n             then {\n                 span_lint_and_help(\n                     cx,\n                     UNSAFE_SIZEOF_COUNT_COPIES,\n                     expr.span,\n-                    \"unsafe memory copying using a byte count (Multiplied by size_of::<T>) \\\n-                    instead of a count of T\",\n+                    LINT_MSG,\n                     None,\n-                    \"use a count of elements instead of a count of bytes for the count parameter, \\\n-                    it already gets multiplied by the size of the pointed to type\"\n+                    HELP_MSG\n                 );\n             }\n         };"}, {"sha": "0bb22314cc0005df74546412779fc037a0631b2b", "filename": "tests/ui/unsafe_sizeof_count_copies.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f954babef41b16e26b900d3858ceac4005a4506/tests%2Fui%2Funsafe_sizeof_count_copies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f954babef41b16e26b900d3858ceac4005a4506/tests%2Fui%2Funsafe_sizeof_count_copies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsafe_sizeof_count_copies.rs?ref=0f954babef41b16e26b900d3858ceac4005a4506", "patch": "@@ -14,6 +14,11 @@ fn main() {\n     unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n \n+    unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+\n     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n "}, {"sha": "14ca04617c288ba65674f72007f328aeac178751", "filename": "tests/ui/unsafe_sizeof_count_copies.stderr", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f954babef41b16e26b900d3858ceac4005a4506/tests%2Fui%2Funsafe_sizeof_count_copies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f954babef41b16e26b900d3858ceac4005a4506/tests%2Fui%2Funsafe_sizeof_count_copies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsafe_sizeof_count_copies.stderr?ref=0f954babef41b16e26b900d3858ceac4005a4506", "patch": "@@ -18,114 +18,146 @@ LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x\n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n   --> $DIR/unsafe_sizeof_count_copies.rs:17:14\n    |\n+LL |     unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:18:14\n+   |\n+LL |     unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:19:14\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:20:14\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:22:14\n+   |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:18:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:23:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:21:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:26:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:22:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:27:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:24:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:29:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:25:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:30:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:28:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:33:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * HALF_SIZE * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:29:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:34:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:31:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:36:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE * HALF_SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:32:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:37:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * HALF_SIZE * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:35:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:40:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * DOUBLE_SIZE / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:36:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:41:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE / 2 * size_of_val(&x[0])) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:38:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:43:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:39:14\n+  --> $DIR/unsafe_sizeof_count_copies.rs:44:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * DOUBLE_SIZE / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 20 previous errors\n "}]}