{"sha": "009c4a7efe034cf08fc9fcaf249e1ec951246c19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOWM0YTdlZmUwMzRjZjA4ZmM5ZmNhZjI0OWUxZWM5NTEyNDZjMTk=", "commit": {"author": {"name": "Valentin Tolmer", "email": "valentin.tolmer@gmail.com", "date": "2019-02-27T16:10:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-15T14:56:43Z"}, "message": "Add debug assertions to write_bytes and copy*", "tree": {"sha": "91dc6b22a47fc7d51b37325ebce87512fe0a1b77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91dc6b22a47fc7d51b37325ebce87512fe0a1b77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/009c4a7efe034cf08fc9fcaf249e1ec951246c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/009c4a7efe034cf08fc9fcaf249e1ec951246c19", "html_url": "https://github.com/rust-lang/rust/commit/009c4a7efe034cf08fc9fcaf249e1ec951246c19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/009c4a7efe034cf08fc9fcaf249e1ec951246c19/comments", "author": {"login": "nitnelave", "id": 796633, "node_id": "MDQ6VXNlcjc5NjYzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/796633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nitnelave", "html_url": "https://github.com/nitnelave", "followers_url": "https://api.github.com/users/nitnelave/followers", "following_url": "https://api.github.com/users/nitnelave/following{/other_user}", "gists_url": "https://api.github.com/users/nitnelave/gists{/gist_id}", "starred_url": "https://api.github.com/users/nitnelave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nitnelave/subscriptions", "organizations_url": "https://api.github.com/users/nitnelave/orgs", "repos_url": "https://api.github.com/users/nitnelave/repos", "events_url": "https://api.github.com/users/nitnelave/events{/privacy}", "received_events_url": "https://api.github.com/users/nitnelave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5480b47d7f9e708300d3ba319869f21cd1ffd487", "url": "https://api.github.com/repos/rust-lang/rust/commits/5480b47d7f9e708300d3ba319869f21cd1ffd487", "html_url": "https://github.com/rust-lang/rust/commit/5480b47d7f9e708300d3ba319869f21cd1ffd487"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "56e45c3695f61830594cbaaba62ea3076b27381f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/009c4a7efe034cf08fc9fcaf249e1ec951246c19/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c4a7efe034cf08fc9fcaf249e1ec951246c19/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=009c4a7efe034cf08fc9fcaf249e1ec951246c19", "patch": "@@ -36,6 +36,8 @@\n             issue = \"0\")]\n #![allow(missing_docs)]\n \n+use crate::mem;\n+\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[rustc_deprecated(reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n                    since = \"1.18.0\")]\n@@ -1323,6 +1325,26 @@ extern \"rust-intrinsic\" {\n // (`transmute` also falls into this category, but it cannot be wrapped due to the\n // check that `T` and `U` have the same size.)\n \n+/// Checks whether `ptr` is properly aligned with respect to\n+/// `align_of::<T>()`.\n+pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n+    !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n+}\n+\n+/// Checks whether the regions of memory starting at `src` and `dst` of size\n+/// `count * size_of::<T>()` overlap.\n+fn overlaps<T>(src: *const T, dst: *const T, count: usize) -> bool {\n+    let src_usize = src as usize;\n+    let dst_usize = dst as usize;\n+    let size = mem::size_of::<T>().checked_mul(count).unwrap();\n+    let diff = if src_usize > dst_usize {\n+        src_usize - dst_usize\n+    } else {\n+        dst_usize - src_usize\n+    };\n+    size > diff\n+}\n+\n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n /// and destination must *not* overlap.\n ///\n@@ -1412,7 +1434,11 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n-    copy_nonoverlapping(src, dst, count);\n+\n+    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n+    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n+    debug_assert!(!overlaps(src, dst, count), \"attempt to copy to overlapping memory\");\n+    copy_nonoverlapping(src, dst, count)\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -1472,6 +1498,9 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n+\n+    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n+    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n     copy(src, dst, count)\n }\n \n@@ -1553,5 +1582,7 @@ pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n+\n+    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n     write_bytes(dst, val, count)\n }"}, {"sha": "1397a52fbbefc4e64f0782c14d4f8e6b21bf5800", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009c4a7efe034cf08fc9fcaf249e1ec951246c19/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009c4a7efe034cf08fc9fcaf249e1ec951246c19/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=009c4a7efe034cf08fc9fcaf249e1ec951246c19", "patch": "@@ -25,7 +25,7 @@\n use crate::cmp::Ordering::{self, Less, Equal, Greater};\n use crate::cmp;\n use crate::fmt;\n-use crate::intrinsics::{assume, exact_div, unchecked_sub};\n+use crate::intrinsics::{assume, exact_div, unchecked_sub, is_aligned_and_not_null};\n use crate::isize;\n use crate::iter::*;\n use crate::ops::{FnMut, Try, self};\n@@ -5228,7 +5228,7 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n-    debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n+    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n                   \"attempt to create slice covering half the address space\");\n     &*ptr::slice_from_raw_parts(data, len)\n@@ -5249,7 +5249,7 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n-    debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n+    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n                   \"attempt to create slice covering half the address space\");\n     &mut *ptr::slice_from_raw_parts_mut(data, len)"}]}