{"sha": "d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDliOTI2ODM2YjFmMWMyYjhiM2ZlNGFiMzVkYzYzYmVjN2ZmY2Q=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-06T02:49:32Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T05:18:30Z"}, "message": "path2: Adjust the API to remove all the _str mutation methods\n\nAdd a new trait BytesContainer that is implemented for both byte vectors\nand strings.\n\nConvert Path::from_vec and ::from_str to one function, Path::new().\n\nRemove all the _str-suffixed mutation methods (push, join, with_*,\nset_*) and modify the non-suffixed versions to use BytesContainer.", "tree": {"sha": "e197783b86700e71d94c9bc6d0254eb25b16cc0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e197783b86700e71d94c9bc6d0254eb25b16cc0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "html_url": "https://github.com/rust-lang/rust/commit/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed539e14712539473c3e89604cb69e2307110772", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed539e14712539473c3e89604cb69e2307110772", "html_url": "https://github.com/rust-lang/rust/commit/ed539e14712539473c3e89604cb69e2307110772"}], "stats": {"total": 2869, "additions": 1384, "deletions": 1485}, "files": [{"sha": "362d2ba749d1c29bcf0ae1e93520bf9760e775b4", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -102,15 +102,15 @@ pub fn parse_config(args: ~[~str]) -> config {\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n-        Path::from_str(m.opt_str(nm).unwrap())\n+        Path::new(m.opt_str(nm).unwrap())\n     }\n \n     config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::from_str(s)),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::from_str(s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n@@ -123,10 +123,10 @@ pub fn parse_config(args: ~[~str]) -> config {\n             } else {\n                 None\n             },\n-        logfile: matches.opt_str(\"logfile\").map(|s| Path::from_str(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::from_str(s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n+        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map(|s| Path::from_str(s)),\n+            matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n         runtool: matches.opt_str(\"runtool\"),"}, {"sha": "9cd3d3683cdedff5ccffebe92f793b6072a32fe2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -161,7 +161,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n-      Some(s) => Some(Path::from_str(s)),\n+      Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n             testfile.file_path()"}, {"sha": "b5b81f7b8102c735fa62b40bd97a17f6239b6e3b", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -62,7 +62,7 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(\"\\n\\n\");\n     }\n-    let testfile = Path::from_str(testfile);\n+    let testfile = Path::new(testfile);\n     debug2!(\"running {}\", testfile.display());\n     let props = load_props(&testfile);\n     debug2!(\"loaded props\");\n@@ -594,7 +594,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n \n     for rel_ab in props.aux_builds.iter() {\n-        let abs_ab = config.aux_base.join_str(*rel_ab);\n+        let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);\n@@ -662,7 +662,7 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    f.add_extension_str(os::EXE_EXTENSION);\n+    f.add_extension(os::EXE_EXTENSION);\n     f\n }\n \n@@ -742,23 +742,23 @@ fn dump_output_file(config: &config, testfile: &Path,\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n-    output_base_name(config, testfile).with_extension_str(extension)\n+    output_base_name(config, testfile).with_extension(extension)\n }\n \n fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    f.add_extension_str(\"libaux\");\n+    f.add_extension(\"libaux\");\n     f\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path::from_vec(testfile.filestem().unwrap())\n+    Path::new(testfile.filestem().unwrap())\n }\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {\n     config.build_base\n         .join_path(&output_testname(testfile))\n-        .with_extension_str(config.stage_id)\n+        .with_extension(config.stage_id.as_slice())\n }\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n@@ -916,7 +916,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n // codegen tests (vs. clang)\n \n fn make_o_name(config: &config, testfile: &Path) -> Path {\n-    output_base_name(config, testfile).with_extension_str(\"o\")\n+    output_base_name(config, testfile).with_extension(\"o\")\n }\n \n fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n@@ -942,9 +942,9 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n \n fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n                                           testfile: &Path) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, \"clang\");\n-    let testcc = testfile.with_extension_str(\"cc\");\n+    let testcc = testfile.with_extension(\"cc\");\n     let ProcArgs = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n@@ -959,10 +959,10 @@ fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n                                  fname: &str, testfile: &Path,\n                                  suffix: &str) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n-    let prog = config.llvm_bin_path.get_ref().join_str(\"llvm-extract\");\n+    let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n     let ProcArgs = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n@@ -975,11 +975,11 @@ fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n \n fn disassemble_extract(config: &config, _props: &TestProps,\n                        testfile: &Path, suffix: &str) -> ProcRes {\n-    let bitcodefile = output_base_name(config, testfile).with_extension_str(\"bc\");\n+    let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n-    let extracted_ll = extracted_bc.with_extension_str(\"ll\");\n-    let prog = config.llvm_bin_path.get_ref().join_str(\"llvm-dis\");\n+    let extracted_ll = extracted_bc.with_extension(\"ll\");\n+    let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n     let ProcArgs = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n@@ -991,7 +991,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_extension_str(\"ll\")).unwrap();\n+    let x = io::read_whole_file_str(&p.with_extension(\"ll\")).unwrap();\n     x.line_iter().len()\n }\n "}, {"sha": "8f176d5ccea131849600e02a411afb84abd1f949", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -358,11 +358,11 @@ instance. `stdin_hyphen` controls whether `-` represents `stdin` or\n a literal `-`.\n */\n pub fn make_path_option_vec(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec.iter().map(|str| {\n-        if stdin_hyphen && \"-\" == *str {\n+    vec.iter().map(|s| {\n+        if stdin_hyphen && \"-\" == *s {\n             None\n         } else {\n-            Some(Path::from_str(*str))\n+            Some(Path::new(s.as_slice()))\n         }\n     }).collect()\n }\n@@ -435,14 +435,14 @@ mod test {\n     fn test_make_path_option_vec() {\n         let strs = [~\"some/path\",\n                     ~\"some/other/path\"];\n-        let paths = ~[Some(Path::from_str(\"some/path\")),\n-                      Some(Path::from_str(\"some/other/path\"))];\n+        let paths = ~[Some(Path::new(\"some/path\")),\n+                      Some(Path::new(\"some/other/path\"))];\n \n         assert_eq!(make_path_option_vec(strs, true), paths.clone());\n         assert_eq!(make_path_option_vec(strs, false), paths);\n \n         assert_eq!(make_path_option_vec([~\"-\"], true), ~[None]);\n-        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path::from_str(\"-\"))]);\n+        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path::new(\"-\"))]);\n     }\n \n     #[test]\n@@ -567,9 +567,9 @@ mod test {\n     #[test]\n     fn test_no_trailing_newline() {\n         let f1 =\n-            Some(Path::from_str(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n+            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n         let f2 =\n-            Some(Path::from_str(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n+            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n \n         {\n             let mut wr = file::open(f1.get_ref(), io::CreateOrTruncate,"}, {"sha": "1a6c8e08e3b8473b228cecee72dd04b68106b29f", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -91,7 +91,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n \n     // calculate root this way to handle volume-relative Windows paths correctly\n     let mut root = os::getcwd();\n-    let pat_root = Path::from_str(pattern).root_path();\n+    let pat_root = Path::new(pattern).root_path();\n     if pat_root.is_some() {\n         if check_windows_verbatim(pat_root.get_ref()) {\n             // XXX: How do we want to handle verbatim paths? I'm inclined to return nothing,\n@@ -548,7 +548,7 @@ mod test {\n         assert!(glob(\"//\").next().is_none());\n \n         // check windows absolute paths with host/device components\n-        let root_with_device = os::getcwd().root_path().unwrap().join_str(\"*\");\n+        let root_with_device = os::getcwd().root_path().unwrap().join(\"*\");\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         assert!(glob(root_with_device.as_str().unwrap()).next().is_some());\n     }\n@@ -772,9 +772,9 @@ mod test {\n \n     #[test]\n     fn test_matches_path() {\n-        // on windows, (Path::from_str(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n+        // on windows, (Path::new(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n         // tests that / and \\ are considered equivalent on windows\n-        assert!(Pattern::new(\"a/b\").matches_path(&Path::from_str(\"a/b\")));\n+        assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n     }\n }\n "}, {"sha": "d8fa130916a46a437d4c3f613583bb790569afed", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -35,7 +35,7 @@ impl TempDir {\n \n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n-            let p = tmpdir.join_str(r.gen_ascii_str(16) + suffix);\n+            let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n             if os::make_dir(&p, 0x1c0) { // 700\n                 return Some(TempDir { path: Some(p) });\n             }"}, {"sha": "ea7d20e096df4b1c126ee6b9c1c7ac30d9d3538e", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -28,26 +28,26 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n \n     // Find search directory\n     match getenv(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(Path::from_str(dir)),\n+        Some(dir) => dirs_to_search.push(Path::new(dir)),\n         None => {\n             if homedir.is_some() {\n                 // ncurses compatability;\n-                dirs_to_search.push(homedir.unwrap().join_str(\".terminfo\"))\n+                dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n                 Some(dirs) => for i in dirs.split_iter(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(Path::from_str(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(Path::from_str(i.to_owned()));\n+                        dirs_to_search.push(Path::new(i.to_owned()));\n                     }\n                 },\n                 // Found nothing, use the default paths\n                 // /usr/share/terminfo is the de facto location, but it seems\n                 // Ubuntu puts it in /lib/terminfo\n                 None => {\n-                    dirs_to_search.push(Path::from_str(\"/usr/share/terminfo\"));\n-                    dirs_to_search.push(Path::from_str(\"/lib/terminfo\"));\n+                    dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(Path::new(\"/lib/terminfo\"));\n                 }\n             }\n         }\n@@ -57,13 +57,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n     for p in dirs_to_search.iter() {\n         if os::path_exists(p) {\n             let f = str::from_char(first_char);\n-            let newp = p.join_many_str([f.as_slice(), term]);\n+            let newp = p.join_many([f.as_slice(), term]);\n             if os::path_exists(&newp) {\n                 return Some(~newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many_str([f.as_slice(), term]);\n+            let newp = p.join_many([f.as_slice(), term]);\n             if os::path_exists(&newp) {\n                 return Some(~newp);\n             }"}, {"sha": "21fa9ed7574421a8ac0486c7c61dcd725681c932", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -271,20 +271,20 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| Path::from_str(s));\n+    let logfile = logfile.map(|s| Path::new(s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n         matches.opt_present(\"test\");\n \n     let ratchet_metrics = matches.opt_str(\"ratchet-metrics\");\n-    let ratchet_metrics = ratchet_metrics.map(|s| Path::from_str(s));\n+    let ratchet_metrics = ratchet_metrics.map(|s| Path::new(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n     let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n-    let save_metrics = save_metrics.map(|s| Path::from_str(s));\n+    let save_metrics = save_metrics.map(|s| Path::new(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n     let test_shard = opt_shard(test_shard);\n@@ -1440,7 +1440,7 @@ mod tests {\n     pub fn ratchet_test() {\n \n         let dpth = TempDir::new(\"test-ratchet\").expect(\"missing test for ratchet\");\n-        let pth = dpth.path().join_str(\"ratchet.json\");\n+        let pth = dpth.path().join(\"ratchet.json\");\n \n         let mut m1 = MetricMap::new();\n         m1.insert_metric(\"runtime\", 1000.0, 2.0);"}, {"sha": "26309cf3b37edc3472cacfc1bc5283afb7cc8b8e", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -498,7 +498,7 @@ fn test() {\n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n-        let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename_str(filename);\n+        let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if os::path_exists(&pth) {\n             os::remove_file(&pth);\n         }"}, {"sha": "404efa25ff3320f0cc3d735fb564d0e84c3ec3ff", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -249,7 +249,7 @@ pub mod write {\n             llvm::LLVMInitializeMipsAsmParser();\n \n             if sess.opts.save_temps {\n-                do output.with_extension_str(\"no-opt.bc\").with_c_str |buf| {\n+                do output.with_extension(\"no-opt.bc\").with_c_str |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }\n@@ -317,7 +317,7 @@ pub mod write {\n             llvm::LLVMDisposePassManager(mpm);\n \n             if sess.opts.save_temps {\n-                do output.with_extension_str(\"bc\").with_c_str |buf| {\n+                do output.with_extension(\"bc\").with_c_str |buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }\n@@ -921,7 +921,7 @@ pub fn link_binary(sess: Session,\n         let out_dirname = out_filename.dir_path();\n         debug2!(\"dirname(out_filename): {}\", out_dirname.display());\n \n-        out_filename.with_filename_str(long_libname)\n+        out_filename.with_filename(long_libname)\n     } else {\n         out_filename.clone()\n     };\n@@ -977,7 +977,7 @@ pub fn link_args(sess: Session,\n \n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        out_filename.with_filename_str(long_libname)\n+        out_filename.with_filename(long_libname)\n     } else {\n         out_filename.clone()\n     };"}, {"sha": "b7ae9c1ecb58eae1fc41ac74631458224f8ffc5e", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -46,7 +46,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n     let mut p = sess.filesearch.sysroot().join_path(&r);\n-    p.push_str(os::dll_filename(\"rustrt\"));\n+    p.push(os::dll_filename(\"rustrt\"));\n     p\n }\n \n@@ -147,7 +147,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     let tlib = filesearch::relative_target_lib_path(target_triple);\n-    let mut path = Path::from_str(install_prefix);\n+    let mut path = Path::new(install_prefix);\n     path.push_path(&tlib);\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -186,8 +186,8 @@ mod test {\n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        let mut d = Path::from_str(env!(\"CFG_PREFIX\"));\n-        d.push_str(\"lib/rustc/triple/lib\");\n+        let mut d = Path::new(env!(\"CFG_PREFIX\"));\n+        d.push(\"lib/rustc/triple/lib\");\n         debug2!(\"test_prefix_path: {} vs. {}\",\n                res.to_str(),\n                d.display());\n@@ -200,7 +200,7 @@ mod test {\n     #[test]\n     fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        assert!(Path::from_str(res).is_absolute());\n+        assert!(Path::new(res).is_absolute());\n     }\n \n     #[test]\n@@ -224,7 +224,7 @@ mod test {\n     fn test_rpath_relative() {\n       let o = session::OsLinux;\n       let res = get_rpath_relative_to_output(o,\n-            &Path::from_str(\"bin/rustc\"), &Path::from_str(\"lib/libstd.so\"));\n+            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n       assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n@@ -233,7 +233,7 @@ mod test {\n     fn test_rpath_relative() {\n         let o = session::OsFreebsd;\n         let res = get_rpath_relative_to_output(o,\n-            &Path::from_str(\"bin/rustc\"), &Path::from_str(\"lib/libstd.so\"));\n+            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n@@ -242,15 +242,15 @@ mod test {\n     fn test_rpath_relative() {\n         let o = session::OsMacos;\n         let res = get_rpath_relative_to_output(o,\n-                                               &Path::from_str(\"bin/rustc\"),\n-                                               &Path::from_str(\"lib/libstd.so\"));\n+                                               &Path::new(\"bin/rustc\"),\n+                                               &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@executable_path/../lib\");\n     }\n \n     #[test]\n     fn test_get_absolute_rpath() {\n-        let res = get_absolute_rpath(&Path::from_str(\"lib/libstd.so\"));\n-        let lib = os::make_absolute(&Path::from_str(\"lib\"));\n+        let res = get_absolute_rpath(&Path::new(\"lib/libstd.so\"));\n+        let lib = os::make_absolute(&Path::new(\"lib\"));\n         debug2!(\"test_get_absolute_rpath: {} vs. {}\",\n                res.to_str(), lib.display());\n "}, {"sha": "f85b0dbcdc3e3b8768fe606250ecdc18b69a6f40", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -353,7 +353,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n         (sess.opts.output_type == link::output_type_object ||\n          sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;\n-        let asm_filename = outputs.obj_filename.with_extension_str(\"s\");\n+        let asm_filename = outputs.obj_filename.with_extension(\"s\");\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n@@ -722,7 +722,7 @@ pub fn build_session_options(binary: @str,\n         } else if matches.opt_present(\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::from_str(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::new(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let target_cpu = matches.opt_str(\"target-cpu\").unwrap_or(~\"generic\");\n     let target_feature = matches.opt_str(\"target-feature\").unwrap_or(~\"\");\n@@ -755,7 +755,7 @@ pub fn build_session_options(binary: @str,\n \n     let statik = debugging_opts & session::statik != 0;\n \n-    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path::from_str(*s));\n+    let addl_lib_search_paths = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n     let linker = matches.opt_str(\"linker\");\n     let linker_args = matches.opt_strs(\"link-args\").flat_map( |a| {\n         a.split_iter(' ').map(|arg| arg.to_owned()).collect()\n@@ -1005,15 +1005,15 @@ pub fn build_output_filenames(input: &input,\n           }\n \n           if *sess.building_library {\n-              out_path = dirpath.join_str(os::dll_filename(stem));\n+              out_path = dirpath.join(os::dll_filename(stem));\n               obj_path = {\n-                  let mut p = dirpath.join_str(stem);\n-                  p.set_extension_str(obj_suffix);\n+                  let mut p = dirpath.join(stem);\n+                  p.set_extension(obj_suffix);\n                   p\n               };\n           } else {\n-              out_path = dirpath.join_str(stem);\n-              obj_path = out_path.with_extension_str(obj_suffix);\n+              out_path = dirpath.join(stem);\n+              obj_path = out_path.with_extension(obj_suffix);\n           }\n       }\n \n@@ -1022,7 +1022,7 @@ pub fn build_output_filenames(input: &input,\n         obj_path = if stop_after_codegen {\n             out_file.clone()\n         } else {\n-            out_file.with_extension_str(obj_suffix)\n+            out_file.with_extension(obj_suffix)\n         };\n \n         if *sess.building_library {"}, {"sha": "9700f68383ad7b26987dea9c00d7d1911b45f39c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -143,7 +143,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n           let meta_items = match path_opt {\n               None => meta_items.clone(),\n               Some((p, _path_str_style)) => {\n-                  let p_path = Path::from_str(p);\n+                  let p_path = Path::new(p);\n                   match p_path.filestem_str() {\n                       None|Some(\"\") =>\n                           e.diag.span_bug(i.span, \"Bad package path in `extern mod` item\"),\n@@ -275,7 +275,7 @@ fn resolve_crate(e: @mut Env,\n         };\n         let (lident, ldata) = loader::load_library_crate(&load_ctxt);\n \n-        let cfilename = Path::from_str(lident);\n+        let cfilename = Path::new(lident);\n         let cdata = ldata;\n \n         let attrs = decoder::get_crate_attributes(cdata);"}, {"sha": "6335df47d73889ac677d762a0d4c11884ec51a7b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -138,11 +138,11 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {\n     let dir = libdir();\n-    let mut p = Path::from_str(dir);\n+    let mut p = Path::new(dir.as_slice());\n     assert!(p.is_relative());\n-    p.push_str(\"rustc\");\n-    p.push_str(target_triple);\n-    p.push_str(dir);\n+    p.push(\"rustc\");\n+    p.push(target_triple);\n+    p.push(dir);\n     p\n }\n \n@@ -153,8 +153,8 @@ fn make_target_lib_path(sysroot: &Path,\n \n fn make_rustpkg_target_lib_path(dir: &Path,\n                         target_triple: &str) -> Path {\n-    let mut p = dir.join_str(libdir());\n-    p.push_str(target_triple);\n+    let mut p = dir.join(libdir());\n+    p.push(target_triple);\n     p\n }\n \n@@ -192,28 +192,28 @@ pub fn rust_path() -> ~[Path] {\n         Some(env_path) => {\n             let env_path_components: ~[&str] =\n                 env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path::from_str(s))\n+            env_path_components.map(|&s| Path::new(s))\n         }\n         None => ~[]\n     };\n     let cwd = os::getcwd();\n     // now add in default entries\n-    let cwd_dot_rust = cwd.join_str(\".rust\");\n+    let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n         env_rust_path.push(cwd_dot_rust);\n     }\n     if !env_rust_path.contains(&cwd) {\n         env_rust_path.push(cwd.clone());\n     }\n     do cwd.each_parent() |p| {\n-        if !env_rust_path.contains(&p.join_str(\".rust\")) {\n+        if !env_rust_path.contains(&p.join(\".rust\")) {\n             push_if_exists(&mut env_rust_path, p);\n         }\n         true\n     };\n     let h = os::homedir();\n     for h in h.iter() {\n-        if !env_rust_path.contains(&h.join_str(\".rust\")) {\n+        if !env_rust_path.contains(&h.join(\".rust\")) {\n             push_if_exists(&mut env_rust_path, h);\n         }\n     }\n@@ -223,7 +223,7 @@ pub fn rust_path() -> ~[Path] {\n \n /// Adds p/.rust into vec, only if it exists\n fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n-    let maybe_dir = p.join_str(\".rust\");\n+    let maybe_dir = p.join(\".rust\");\n     if os::path_exists(&maybe_dir) {\n         vec.push(maybe_dir);\n     }"}, {"sha": "1d9f37a2e877ea118079796a5b200ed6b9bbea56", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -250,16 +250,16 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n             let src = str::from_utf8(io::stdin().read_whole_stream());\n             str_input(src.to_managed())\n         } else {\n-            file_input(Path::from_str(ifile))\n+            file_input(Path::new(ifile))\n         }\n       }\n       _ => early_error(demitter, \"multiple input filenames provided\")\n     };\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path::from_str(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path::from_str(o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let cfg = build_configuration(sess);\n     let pretty = do matches.opt_default(\"pretty\", \"normal\").map |a| {\n         parse_pretty(sess, a)"}, {"sha": "7ed424136be2270cfc880d218702a640c0f1133d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -255,16 +255,16 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     crate = cache.fold_crate(crate);\n \n     // Add all the static files\n-    let mut dst = cx.dst.join_str(crate.name);\n+    let mut dst = cx.dst.join(crate.name.as_slice());\n     mkdir(&dst);\n-    write(dst.join_str(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n-    write(dst.join_str(\"main.js\"), include_str!(\"static/main.js\"));\n-    write(dst.join_str(\"main.css\"), include_str!(\"static/main.css\"));\n-    write(dst.join_str(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n+    write(dst.join(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n+    write(dst.join(\"main.js\"), include_str!(\"static/main.js\"));\n+    write(dst.join(\"main.css\"), include_str!(\"static/main.css\"));\n+    write(dst.join(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n \n     // Publish the search index\n     {\n-        dst.push_str(\"search-index.js\");\n+        dst.push(\"search-index.js\");\n         let mut w = BufferedWriter::new(dst.open_writer(io::CreateOrTruncate));\n         let w = &mut w as &mut io::Writer;\n         write!(w, \"var searchIndex = [\");\n@@ -292,9 +292,9 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     // Render all source files (this may turn into a giant no-op)\n     {\n         info2!(\"emitting source files\");\n-        let dst = cx.dst.join_str(\"src\");\n+        let dst = cx.dst.join(\"src\");\n         mkdir(&dst);\n-        let dst = dst.join_str(crate.name);\n+        let dst = dst.join(crate.name.as_slice());\n         mkdir(&dst);\n         let mut folder = SourceCollector {\n             dst: dst,\n@@ -338,7 +338,7 @@ fn mkdir(path: &Path) {\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n fn clean_srcpath(src: &[u8], f: &fn(&str)) {\n-    let p = Path::from_vec(src);\n+    let p = Path::new(src);\n     if p.as_vec() != bytes!(\".\") {\n         for c in p.str_component_iter().map(|x|x.unwrap()) {\n             if \"..\" == c {\n@@ -354,7 +354,7 @@ fn clean_srcpath(src: &[u8], f: &fn(&str)) {\n /// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // See if there's documentation generated into the local directory\n-    let local_location = dst.join_str(e.name);\n+    let local_location = dst.join(e.name.as_slice());\n     if local_location.is_dir() {\n         return Local;\n     }\n@@ -413,7 +413,7 @@ impl<'self> DocFolder for SourceCollector<'self> {\n impl<'self> SourceCollector<'self> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> bool {\n-        let p = Path::from_str(filename);\n+        let p = Path::new(filename);\n \n         // Read the contents of the file\n         let mut contents = ~[];\n@@ -445,7 +445,7 @@ impl<'self> SourceCollector<'self> {\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n         do clean_srcpath(p.dirname()) |component| {\n-            cur.push_str(component);\n+            cur.push(component);\n             mkdir(&cur);\n             root_path.push_str(\"../\");\n         }\n@@ -661,7 +661,7 @@ impl Context {\n             fail2!(\"what {:?}\", self);\n         }\n         let prev = self.dst.clone();\n-        self.dst.push_str(s);\n+        self.dst.push(s.as_slice());\n         self.root_path.push_str(\"../\");\n         self.current.push(s);\n \n@@ -808,7 +808,7 @@ impl Context {\n                 let item = Cell::new(item);\n                 do self.recurse(name) |this| {\n                     let item = item.take();\n-                    let dst = this.dst.join_str(\"index.html\");\n+                    let dst = this.dst.join(\"index.html\");\n                     let writer = dst.open_writer(io::CreateOrTruncate);\n                     render(writer.unwrap(), this, &item, false);\n \n@@ -826,7 +826,7 @@ impl Context {\n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n-                let dst = self.dst.join_str(item_path(&item));\n+                let dst = self.dst.join(item_path(&item));\n                 let writer = dst.open_writer(io::CreateOrTruncate);\n                 render(writer.unwrap(), self, &item, true);\n             }"}, {"sha": "4efc68a265512e53d80a9c974db7e701aed0bd4d", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -41,7 +41,7 @@ impl PluginManager {\n     /// platform. On windows, it turns into name.dll, on OS X, name.dylib, and\n     /// elsewhere, libname.so.\n     pub fn load_plugin(&mut self, name: ~str) {\n-        let x = self.prefix.join_str(libname(name));\n+        let x = self.prefix.join(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n         let plugin = unsafe { lib.symbol(\"rustdoc_plugin_entrypoint\") }.unwrap();"}, {"sha": "6684410b5877822692f7df137f18186fa7fbd29d", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -134,13 +134,13 @@ pub fn main_args(args: &[~str]) -> int {\n \n     info2!(\"going to format\");\n     let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path::from_str(s));\n+    let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            html::render::run(crate, output.unwrap_or(Path::from_str(\"doc\")))\n+            html::render::run(crate, output.unwrap_or(Path::new(\"doc\")))\n         }\n         Some(~\"json\") => {\n-            json_output(crate, res, output.unwrap_or(Path::from_str(\"doc.json\")))\n+            json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\")))\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -188,8 +188,8 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::from_str(*s)));\n-    let cr = Cell::new(Path::from_str(cratefile));\n+    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n+    let cr = Cell::new(Path::new(cratefile));\n     info2!(\"starting to run rustc\");\n     let crate = do std::task::try {\n         let cr = cr.take();\n@@ -230,7 +230,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n \n     // Load all plugins/passes into a PluginManager\n     let path = matches.opt_str(\"plugin-path\").unwrap_or(~\"/tmp/rustdoc_ng/plugins\");\n-    let mut pm = plugins::PluginManager::new(Path::from_str(path));\n+    let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n             Some(i) => PASSES[i].n1(),\n@@ -254,7 +254,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match ::std::io::file_reader(&Path::from_str(input)) {\n+    let input = match ::std::io::file_reader(&Path::new(input)) {\n         Ok(i) => i,\n         Err(s) => return Err(s),\n     };"}, {"sha": "c025d9b10dd0421fb5d6bd675baba28539bb2a7d", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -142,7 +142,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n         binary: binary,\n-        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path::from_str(*p)),\n+        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path::new(p.as_slice())),\n         jit: true,\n         .. (*session::basic_options()).clone()\n     };\n@@ -328,7 +328,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         }\n     }\n     match do task::try {\n-        let src_path = Path::from_str(src_filename);\n+        let src_path = Path::new(src_filename.as_slice());\n         let binary = binary.to_managed();\n         let options = @session::options {\n             binary: binary,\n@@ -441,7 +441,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 }\n             }\n             for crate in loaded_crates.iter() {\n-                let crate_path = Path::from_str(*crate);\n+                let crate_path = Path::new(crate.as_slice());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let crate_dir = crate_path.dirname_str().unwrap();\n                 repl.program.record_extern(format!(\"extern mod {};\", *crate));"}, {"sha": "02a96402229090a58e89ffdc555892c57514b62d", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -43,17 +43,17 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n }\n \n fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::from_str(path);\n+    let path = Path::new(path);\n     os::path_exists(&path) && in_hash == digest_file_with_date(&path)\n }\n \n fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::from_str(path);\n+    let path = Path::new(path);\n     os::path_exists(&path) && in_hash == digest_only_date(&path)\n }\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n-    let db_file = p.join_str(\"rustpkg_db.json\"); // ??? probably wrong\n+    let db_file = p.join(\"rustpkg_db.json\"); // ??? probably wrong\n     debug2!(\"Workcache database file: {}\", db_file.display());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n@@ -73,7 +73,7 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n-        start_dir: root.join_many_str([\"src\", name.as_slice()]),\n+        start_dir: root.join_many([\"src\", name.as_slice()]),\n         id: PkgId{ version: version, ..PkgId::new(name)},\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n@@ -91,7 +91,7 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n-        start_dir: root.join_many_str([\"src\", name.as_slice()]),\n+        start_dir: root.join_many([\"src\", name.as_slice()]),\n         id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[],\n         // n.b. This assumes the package only has one crate"}, {"sha": "554019133b2d79157db376a86acda806026e3694", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -156,7 +156,7 @@ impl Context {\n pub fn in_target(sysroot: &Path) -> bool {\n     debug2!(\"Checking whether {} is in target\", sysroot.display());\n     let mut p = sysroot.dir_path();\n-    p.set_filename_str(\"rustc\");\n+    p.set_filename(\"rustc\");\n     os::path_is_dir(&p)\n }\n "}, {"sha": "485cbfef2f602e2d6a7bea6f9b58777f4e4d63f4", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -17,7 +17,7 @@ use std::os;\n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = os::list_dir(&p.join_str(\"bin\"));\n+        let binfiles = os::list_dir(&p.join(\"bin\"));\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -29,17 +29,17 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = os::list_dir(&p.join_str(\"lib\"));\n+        let libfiles = os::list_dir(&p.join(\"lib\"));\n         for lib in libfiles.iter() {\n             debug2!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n                 Some(basename) => {\n-                    let parent = p.join_str(\"lib\");\n+                    let parent = p.join(\"lib\");\n                     debug2!(\"parent = {}, child = {}\",\n                             parent.display(), lib.display());\n                     let rel_p = lib.path_relative_from(&parent).unwrap();\n                     debug2!(\"Rel: {}\", rel_p.display());\n-                    let rel_path = rel_p.join_str(basename);\n+                    let rel_path = rel_p.join(basename);\n                     do rel_path.with_display_str |s| {\n                         debug2!(\"Rel name: {}\", s);\n                         f(&PkgId::new(s));"}, {"sha": "38b922ec05d6459a4cbf0dfe737567cd0b10dbfa", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -59,7 +59,7 @@ impl PkgId {\n             }\n         };\n \n-        let path = Path::from_str(s);\n+        let path = Path::new(s);\n         if !path.is_relative() {\n             return cond.raise((path, ~\"absolute pkgid\"));\n         }\n@@ -137,8 +137,8 @@ impl Iterator<(Path, Path)> for Prefixes {\n             let last = self.components.pop();\n             self.remaining.unshift(last);\n             // converting to str and then back is a little unfortunate\n-            Some((Path::from_str(self.components.connect(\"/\")),\n-                  Path::from_str(self.remaining.connect(\"/\"))))\n+            Some((Path::new(self.components.connect(\"/\")),\n+                  Path::new(self.remaining.connect(\"/\"))))\n         }\n     }\n }"}, {"sha": "4e0db8cac4f69555ce1db27b60e9878419e7e78b", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -94,20 +94,20 @@ impl PkgSrc {\n         } else {\n             // We search for sources under both src/ and build/ , because build/ is where\n             // automatically-checked-out sources go.\n-            let mut result = source_workspace.join_str(\"src\");\n+            let mut result = source_workspace.join(\"src\");\n             result.push_path(&id.path.dir_path());\n-            result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result);\n-            let mut result = source_workspace.join_str(\"src\");\n+            let mut result = source_workspace.join(\"src\");\n             result.push_path(&id.path);\n             to_try.push(result);\n \n-            let mut result = build_dir.join_str(\"src\");\n+            let mut result = build_dir.join(\"src\");\n             result.push_path(&id.path.dir_path());\n             result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result.clone());\n             output_names.push(result);\n-            let mut other_result = build_dir.join_str(\"src\");\n+            let mut other_result = build_dir.join(\"src\");\n             other_result.push_path(&id.path);\n             to_try.push(other_result.clone());\n             output_names.push(other_result);\n@@ -129,7 +129,7 @@ impl PkgSrc {\n                 // That is, is this a package ID that points into the middle of a workspace?\n                 for (prefix, suffix) in id.prefixes_iter() {\n                     let package_id = PkgId::new(prefix.as_str().unwrap());\n-                    let path = build_dir.join_path(&package_id.path);\n+                    let path = build_dir.join(&package_id.path);\n                     debug2!(\"in loop: checking if {} is a directory\", path.display());\n                     if os::path_is_dir(&path) {\n                         let ps = PkgSrc::new(source_workspace,\n@@ -260,6 +260,7 @@ impl PkgSrc {\n                     return None;\n                 }\n \n+                // FIXME (#9639): This needs to handle non-utf8 paths\n                 let url = format!(\"https://{}\", pkgid.path.as_str().unwrap());\n                 debug2!(\"Fetching package: git clone {} {} [version={}]\",\n                         url, clone_target.display(), pkgid.version.to_str());\n@@ -289,7 +290,7 @@ impl PkgSrc {\n     // If a file named \"pkg.rs\" in the start directory exists,\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n-        let maybe_path = self.start_dir.join_str(\"pkg.rs\");\n+        let maybe_path = self.start_dir.join(\"pkg.rs\");\n         debug2!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n@@ -309,7 +310,7 @@ impl PkgSrc {\n             it.nth(prefix-1); // skip elements\n         }\n         assert!(it.peek().is_some());\n-        let mut sub = Path::from_str(\".\");\n+        let mut sub = Path::new(\".\");\n         for c in it {\n             sub.push(c);\n         }"}, {"sha": "0f5f1470b6fe670f35a8d6d655b63992718cc288", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -53,7 +53,7 @@ pub fn make_dir_rwx_recursive(p: &Path) -> bool { os::mkdir_recursive(p, U_RWX)\n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    workspace_contains_package_id_(pkgid, workspace, |p| p.join_str(\"src\")).is_some()\n+    workspace_contains_package_id_(pkgid, workspace, |p| p.join(\"src\")).is_some()\n }\n \n pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n@@ -98,24 +98,24 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n /// Return the target-specific build subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n pub fn target_build_dir(workspace: &Path) -> Path {\n-    let mut dir = workspace.join_str(\"build\");\n-    dir.push_str(host_triple());\n+    let mut dir = workspace.join(\"build\");\n+    dir.push(host_triple());\n     dir\n }\n \n /// Return the target-specific lib subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n fn target_lib_dir(workspace: &Path) -> Path {\n-    let mut dir = workspace.join_str(\"lib\");\n-    dir.push_str(host_triple());\n+    let mut dir = workspace.join(\"lib\");\n+    dir.push(host_triple());\n     dir\n }\n \n /// Return the bin subdirectory, pushed onto `base`;\n /// doesn't check that it exists or create it\n /// note: this isn't target-specific\n fn target_bin_dir(workspace: &Path) -> Path {\n-    workspace.join_str(\"bin\")\n+    workspace.join(\"bin\")\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n@@ -205,7 +205,7 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n \n // rustc doesn't use target-specific subdirectories\n pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n-    library_in(lib_name, &NoVersion, &sysroot.join_str(\"lib\"))\n+    library_in(lib_name, &NoVersion, &sysroot.join(\"lib\"))\n }\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n@@ -377,9 +377,9 @@ pub fn mk_output_path(what: OutputType, where: Target,\n            dir.display());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n-        Lib => dir.join_str(os::dll_filename(short_name_with_version)),\n+        Lib => dir.join(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.join_str(format!(\"{}{}{}\", pkg_id.short_name,\n+        _ => dir.join(format!(\"{}{}{}\", pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -416,7 +416,7 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n \n fn dir_has_file(dir: &Path, file: &str) -> bool {\n     assert!(dir.is_absolute());\n-    os::path_exists(&dir.join_str(file))\n+    os::path_exists(&dir.join(file))\n }\n \n pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {"}, {"sha": "5ef8948c37772d57b31d76a9481786c94ea65aa6", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -146,7 +146,7 @@ impl<'self> PkgScript<'self> {\n         let crate = util::ready_crate(sess, self.crate.take_unwrap());\n         debug2!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n-        let exe = self.build_dir.join_str(\"pkg\" + util::exe_suffix());\n+        let exe = self.build_dir.join(\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n                                        exec,\n                                        Nothing,\n@@ -422,7 +422,7 @@ impl CtxMethods for BuildContext {\n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n         if !in_rust_path(&workspace) && is_git_dir(&workspace.join_path(&pkgid.path)) {\n-            let mut out_dir = default_workspace().join_str(\"src\");\n+            let mut out_dir = default_workspace().join(\"src\");\n             out_dir.push_path(&pkgid.path);\n             let git_result = source_control::safe_git_clone(&workspace.join_path(&pkgid.path),\n                                                             &pkgid.version,\n@@ -488,7 +488,7 @@ impl CtxMethods for BuildContext {\n                 // Find crates inside the workspace\n                 &Everything => pkg_src.find_crates(),\n                 // Find only tests\n-                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::from_str(s)) }),\n+                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n@@ -562,7 +562,7 @@ impl CtxMethods for BuildContext {\n \n         let result = self.install_no_build(pkg_src.build_workspace(),\n                                            &pkg_src.destination_workspace,\n-                                           &id).map(|s| Path::from_str(*s));\n+                                           &id).map(|s| Path::new(*s));\n         debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.map(|p| p.to_display_str()));\n         installed_files = installed_files + result;\n@@ -669,10 +669,10 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn init(&self) {\n-        os::mkdir_recursive(&Path::from_str(\"src\"),   U_RWX);\n-        os::mkdir_recursive(&Path::from_str(\"lib\"),   U_RWX);\n-        os::mkdir_recursive(&Path::from_str(\"bin\"),   U_RWX);\n-        os::mkdir_recursive(&Path::from_str(\"build\"), U_RWX);\n+        os::mkdir_recursive(&Path::new(\"src\"),   U_RWX);\n+        os::mkdir_recursive(&Path::new(\"lib\"),   U_RWX);\n+        os::mkdir_recursive(&Path::new(\"bin\"),   U_RWX);\n+        os::mkdir_recursive(&Path::new(\"build\"), U_RWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n@@ -852,7 +852,7 @@ pub fn main_args(args: &[~str]) -> int {\n     let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n     remaining_args.shift();\n     let sroot = match supplied_sysroot {\n-        Some(getopts::Val(s)) => Path::from_str(s),\n+        Some(getopts::Val(s)) => Path::new(s),\n         _ => filesearch::get_or_default_sysroot()\n     };\n "}, {"sha": "2fc925a8a6a93f80fd98abae27dd6ab4bd2cb7a0", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -43,7 +43,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                 else {\n                 match v {\n                     &ExactRevision(ref s) => {\n-                        let git_dir = target.join_str(\".git\");\n+                        let git_dir = target.join(\".git\");\n                         debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                                 *s, target.display(), git_dir.display());\n                         // FIXME (#9639: This needs to handle non-utf8 paths\n@@ -64,7 +64,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             // Check that no version was specified. There's no reason to not handle the\n             // case where a version was requested, but I haven't implemented it.\n             assert!(*v == NoVersion);\n-            let git_dir = target.join_str(\".git\");\n+            let git_dir = target.join(\".git\");\n             debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                     target.display(), git_dir.display(), source.display());\n             // FIXME (#9639: This needs to handle non-utf8 paths\n@@ -80,7 +80,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n \n         let scratch_dir = TempDir::new(\"rustpkg\");\n         let clone_target = match scratch_dir {\n-            Some(d) => d.unwrap().join_str(\"rustpkg_temp\"),\n+            Some(d) => d.unwrap().join(\"rustpkg_temp\"),\n             None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n         };\n \n@@ -136,5 +136,5 @@ fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput\n }\n \n pub fn is_git_dir(p: &Path) -> bool {\n-    os::path_is_dir(&p.join_str(\".git\"))\n+    os::path_is_dir(&p.join(\".git\"))\n }"}, {"sha": "b21641a5e53e31f6567d8f9e27313520aebd1d58", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -56,7 +56,7 @@ fn file_is(p: &Path, stem: &str) -> bool {\n }\n \n pub fn lib_name_of(p: &Path) -> Path {\n-    p.join_str(\"lib.rs\")\n+    p.join(\"lib.rs\")\n }\n \n pub static lib_crate_filename: &'static str = \"lib.rs\";"}, {"sha": "cb40c3c00906a0f0e7aa83f7b9d3f5f7c6a8a887", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 185, "deletions": 189, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -41,7 +41,7 @@ use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     let context = workcache::Context::new(\n-        RWArc::new(Database::new(workspace.join_str(\"rustpkg_db.json\"))),\n+        RWArc::new(Database::new(workspace.join(\"rustpkg_db.json\"))),\n         RWArc::new(Logger::new()),\n         Arc::new(TreeMap::new()));\n     BuildContext {\n@@ -59,23 +59,23 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n     PkgId {\n-        path: Path::from_str(sn),\n+        path: Path::new(sn.as_slice()),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg() -> PkgId {\n     PkgId {\n-        path: Path::from_str(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n     PkgId {\n-        path: Path::from_str(\"mockgithub.com/catamorphism/test-pkg\"),\n+        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n     }\n@@ -102,18 +102,18 @@ fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> TempDi\n fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace.join_many_str([~\"src\", format!(\"{}-{}\",\n-                                                short_name.as_str().unwrap(), version.to_str())]);\n+    let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n+                                           short_name.as_str().unwrap(), version.to_str())]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n     let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n-    let package_dir = workspace_dir.path().join_many_str([~\"src\",\n-                                                          format!(\"{}-{}\",\n-                                                                  short_name.to_str(),\n-                                                                  version.to_str())]);\n+    let package_dir = workspace_dir.path().join_many([~\"src\",\n+                                                      format!(\"{}-{}\",\n+                                                              short_name.to_str(),\n+                                                              version.to_str())]);\n \n     debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n@@ -124,13 +124,13 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n-    writeFile(&package_dir.join_str(\"main.rs\"),\n+    writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"lib.rs\"),\n+    writeFile(&package_dir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"test.rs\"),\n+    writeFile(&package_dir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join_str(\"bench.rs\"),\n+    writeFile(&package_dir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     (workspace_dir, package_dir)\n }\n@@ -163,7 +163,7 @@ fn init_git_repo(p: &Path) -> TempDir {\n     run_git([~\"init\"], None, &work_dir_for_opts,\n         format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n     // Add stuff to the dir so that git tag succeeds\n-    writeFile(&work_dir.join_str(\"README\"), \"\");\n+    writeFile(&work_dir.join(\"README\"), \"\");\n     run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\",\n                                                                 work_dir.display()));\n     git_commit(&work_dir_for_opts, ~\"whatever\");\n@@ -232,13 +232,13 @@ fn test_sysroot() -> Path {\n // Returns the path to rustpkg\n fn rustpkg_exec() -> Path {\n     // Ugh\n-    let first_try = test_sysroot().join_many_str(\n+    let first_try = test_sysroot().join_many(\n         [~\"lib\", ~\"rustc\", host_triple(), ~\"bin\", ~\"rustpkg\"]);\n     if is_executable(&first_try) {\n         first_try\n     }\n     else {\n-        let second_try = test_sysroot().join_many_str([\"bin\", \"rustpkg\"]);\n+        let second_try = test_sysroot().join_many([\"bin\", \"rustpkg\"]);\n         if is_executable(&second_try) {\n             second_try\n         }\n@@ -328,21 +328,21 @@ fn create_local_package(pkgid: &PkgId) -> TempDir {\n \n fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.join_many_str([~\"src\", pkgid.to_str()]);\n+    let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n \n     // Create main, lib, test, and bench files\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n-    writeFile(&package_dir.join_str(\"main.rs\"),\n+    writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"lib.rs\"),\n+    writeFile(&package_dir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"test.rs\"),\n+    writeFile(&package_dir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join_str(\"bench.rs\"),\n+    writeFile(&package_dir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     package_dir\n }\n@@ -356,11 +356,11 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir\n     let package_dir = create_local_package(pkgid);\n     create_local_package_in(subord_pkgid, package_dir.path());\n     // Write a main.rs file into pkgid that references subord_pkgid\n-    writeFile(&package_dir.path().join_many_str([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n                    subord_pkgid.short_name));\n     // Write a lib.rs file into subord_pkgid that has something in it\n-    writeFile(&package_dir.path().join_many_str([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n@@ -452,7 +452,7 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n }\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    os::path_exists(&target_build_dir(repo).join_many_str([short_name.to_owned(),\n+    os::path_exists(&target_build_dir(repo).join_many([short_name.to_owned(),\n                                      format!(\"{}.{}\", short_name, extension)]))\n }\n \n@@ -497,7 +497,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug2!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n-    library_in_workspace(&Path::from_str(short_name),\n+    library_in_workspace(&Path::new(short_name),\n                          short_name,\n                          Build,\n                          workspace,\n@@ -506,13 +506,13 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).join_str(short_name).join_str(format!(\"{}{}\", short_name,\n-                                                                      os::EXE_SUFFIX))\n+    target_build_dir(workspace).join(short_name.as_slice()).join(format!(\"{}{}\", short_name,\n+                                                                         os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many_str([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n     let contents = os::list_dir_path(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -528,9 +528,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n /// Add a comment at the end\n fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many_str([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n     let mut maybe_p = None;\n-    let maybe_file = pkg_src_dir.join_str(filename);\n+    let maybe_file = pkg_src_dir.join(filename);\n     debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n     if os::path_exists(&maybe_file) {\n         maybe_p = Some(maybe_file);\n@@ -552,7 +552,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n #[test]\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n-    let dir = temp.join_str(\"quux\");\n+    let dir = temp.join(\"quux\");\n     assert!(!os::path_exists(&dir) ||\n             os::remove_dir_recursive(&dir));\n     debug2!(\"Trying to make {}\", dir.display());\n@@ -630,16 +630,16 @@ fn test_install_git() {\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n     debug2!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.display());\n \n-    writeFile(&repo_subdir.join_str(\"main.rs\"),\n+    writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"test.rs\"),\n+    writeFile(&repo_subdir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n+    writeFile(&repo_subdir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n@@ -648,7 +648,7 @@ fn test_install_git() {\n     // should have test, bench, lib, and main\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n-    let ws = repo.join_str(\".rust\");\n+    let ws = repo.join(\".rust\");\n     // Check that all files exist\n     debug2!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n@@ -705,12 +705,12 @@ fn test_package_ids_must_be_relative_path_like() {\n     }\n \n     do cond.trap(|(p, e)| {\n-        let abs = os::make_absolute(&Path::from_str(\"foo/bar/quux\"));\n+        let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let zp = os::make_absolute(&Path::from_str(\"foo/bar/quux\"));\n+        let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let z = PkgId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n@@ -721,17 +721,17 @@ fn test_package_ids_must_be_relative_path_like() {\n #[test]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::from_str(local_path));\n+    let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug2!(\"Writing files in: {}\", repo_subdir.display());\n-    writeFile(&repo_subdir.join_str(\"main.rs\"),\n+    writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"test.rs\"),\n+    writeFile(&repo_subdir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n+    writeFile(&repo_subdir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n@@ -740,7 +740,7 @@ fn test_package_version() {\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       repo);\n-    let ws = repo.join_str(\".rust\");\n+    let ws = repo.join(\".rust\");\n     // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n                                              &ws) {\n@@ -751,36 +751,36 @@ fn test_package_version() {\n         None    => false\n     });\n     assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n-            == Some(target_build_dir(&ws).join_many_str([\"mockgithub.com\",\n-                                                         \"catamorphism\",\n-                                                         \"test_pkg_version\",\n-                                                         \"test_pkg_version\"])));\n+            == Some(target_build_dir(&ws).join_many([\"mockgithub.com\",\n+                                                     \"catamorphism\",\n+                                                     \"test_pkg_version\",\n+                                                     \"test_pkg_version\"])));\n }\n \n #[test]\n fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::from_str(local_path));\n+    let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug2!(\"Writing files in: {}\", repo_subdir.display());\n-    writeFile(&repo_subdir.join_str(\"main.rs\"),\n+    writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"test.rs\"),\n+    writeFile(&repo_subdir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join_str(\"bench.rs\"),\n+    writeFile(&repo_subdir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join_str(\"version-0.3-file.txt\"), \"hi\");\n+    writeFile(&repo_subdir.join(\"version-0.3-file.txt\"), \"hi\");\n     add_git_tag(&repo_subdir, ~\"0.3\");\n-    writeFile(&repo_subdir.join_str(\"version-0.4-file.txt\"), \"hello\");\n+    writeFile(&repo_subdir.join(\"version-0.4-file.txt\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&Path::from_str(\"test_pkg_version\"),\n-                                                 &repo.join_str(\".rust\")) {\n+    assert!(match installed_library_in_workspace(&Path::new(\"test_pkg_version\"),\n+                                                 &repo.join(\".rust\")) {\n         Some(p) => {\n             debug2!(\"installed: {}\", p.display());\n             let suffix = format!(\"0.3{}\", os::consts::DLL_SUFFIX);\n@@ -789,15 +789,15 @@ fn test_package_request_version() {\n         None    => false\n     });\n     let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n-    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join_str(\".rust\"))\n-            == repo.join_many_str([\".rust\", \"bin\", \"test_pkg_version\"]));\n+    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n+            == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n-    let mut dir = target_build_dir(&repo.join_str(\".rust\"));\n-    dir.push_path(&Path::from_str(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n+    let mut dir = target_build_dir(&repo.join(\".rust\"));\n+    dir.push_path(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n     debug2!(\"dir = {}\", dir.display());\n     assert!(os::path_is_dir(&dir));\n-    assert!(os::path_exists(&dir.join_str(\"version-0.3-file.txt\")));\n-    assert!(!os::path_exists(&dir.join_str(\"version-0.4-file.txt\")));\n+    assert!(os::path_exists(&dir.join(\"version-0.3-file.txt\")));\n+    assert!(!os::path_exists(&dir.join(\"version-0.4-file.txt\")));\n }\n \n #[test]\n@@ -810,23 +810,23 @@ fn rustpkg_install_url_2() {\n \n #[test]\n fn rustpkg_library_target() {\n-    let foo_repo = init_git_repo(&Path::from_str(\"foo\"));\n+    let foo_repo = init_git_repo(&Path::new(\"foo\"));\n     let foo_repo = foo_repo.path();\n-    let package_dir = foo_repo.join_str(\"foo\");\n+    let package_dir = foo_repo.join(\"foo\");\n \n     debug2!(\"Writing files in: {}\", package_dir.display());\n-    writeFile(&package_dir.join_str(\"main.rs\"),\n+    writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"lib.rs\"),\n+    writeFile(&package_dir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join_str(\"test.rs\"),\n+    writeFile(&package_dir.join(\"test.rs\"),\n               \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join_str(\"bench.rs\"),\n+    writeFile(&package_dir.join(\"bench.rs\"),\n               \"#[bench] pub fn f() { (); }\");\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join_str(\".rust\"), &Path::from_str(\"foo\"), ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &Path::new(\"foo\"), ExactRevision(~\"1.0\"));\n }\n \n #[test]\n@@ -844,26 +844,25 @@ fn package_script_with_default_build() {\n     debug2!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n     source.pop(); source.pop();\n-    source.push_many_str(\n-        [\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n+    source.push_many([\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n     debug2!(\"package_script_with_default_build: {}\", source.display());\n     if !os::copy_file(&source,\n-                      &dir.join_many_str([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n+                      &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n         fail2!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &Path::from_str(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).join_many_str([\"fancy-lib\", \"generated.rs\"])));\n+    assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n+    assert!(os::path_exists(&target_build_dir(dir).join_many([\"fancy-lib\", \"generated.rs\"])));\n }\n \n #[test]\n fn rustpkg_build_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n-    let tmp = tmp.path().join_str(\".rust\");\n-    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n+    let tmp = tmp.path().join(\".rust\");\n+    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n-    writeFile(&package_dir.join_str(\"main.rs\"),\n+    writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug2!(\"build_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n@@ -873,24 +872,24 @@ fn rustpkg_build_no_arg() {\n #[test]\n fn rustpkg_install_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n-    let tmp = tmp.path().join_str(\".rust\");\n-    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n+    let tmp = tmp.path().join(\".rust\");\n+    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    writeFile(&package_dir.join_str(\"lib.rs\"),\n+    writeFile(&package_dir.join(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug2!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &Path::from_str(\"foo\"), NoVersion);\n+    assert_lib_exists(&tmp, &Path::new(\"foo\"), NoVersion);\n }\n \n #[test]\n fn rustpkg_clean_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n-    let tmp = tmp.path().join_str(\".rust\");\n-    let package_dir = tmp.join_many_str([\"src\", \"foo\"]);\n+    let tmp = tmp.path().join(\".rust\");\n+    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n \n-    writeFile(&package_dir.join_str(\"main.rs\"),\n+    writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug2!(\"clean_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n@@ -903,9 +902,9 @@ fn rustpkg_clean_no_arg() {\n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &Path::from_str(\"foo\"), &NoVersion);\n+    let dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n     debug2!(\"dir = {}\", dir.display());\n-    writeFile(&dir.join_str(\"main.rs\"), \"fn main() { let _x = (); }\");\n+    writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n     debug2!(\"cwd = {}\", cwd.display());\n@@ -921,16 +920,16 @@ fn rust_path_test() {\n #[ignore] // FIXME(#9184) tests can't change the cwd (other tests are sad then)\n fn rust_path_contents() {\n     let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n-    let abc = &dir.path().join_many_str([\"A\", \"B\", \"C\"]);\n-    assert!(os::mkdir_recursive(&abc.join_str(\".rust\"), U_RWX));\n+    let abc = &dir.path().join_many([\"A\", \"B\", \"C\"]);\n+    assert!(os::mkdir_recursive(&abc.join(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.with_filename(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), U_RWX));\n     assert!(os::change_dir(abc));\n \n     let p = rust_path();\n-    let cwd = os::getcwd().join_str(\".rust\");\n-    let parent = cwd.dir_path().with_filename_str(\".rust\");\n-    let grandparent = cwd.dir_path().dir_path().with_filename_str(\".rust\");\n+    let cwd = os::getcwd().join(\".rust\");\n+    let parent = cwd.dir_path().with_filename(\".rust\");\n+    let grandparent = cwd.dir_path().dir_path().with_filename(\".rust\");\n     assert!(p.contains(&cwd));\n     assert!(p.contains(&parent));\n     assert!(p.contains(&grandparent));\n@@ -943,9 +942,9 @@ fn rust_path_contents() {\n fn rust_path_parse() {\n     os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n     let paths = rust_path();\n-    assert!(paths.contains(&Path::from_str(\"/g/h/i\")));\n-    assert!(paths.contains(&Path::from_str(\"/d/e/f\")));\n-    assert!(paths.contains(&Path::from_str(\"/a/b/c\")));\n+    assert!(paths.contains(&Path::new(\"/g/h/i\")));\n+    assert!(paths.contains(&Path::new(\"/d/e/f\")));\n+    assert!(paths.contains(&Path::new(\"/a/b/c\")));\n     os::unsetenv(\"RUST_PATH\");\n }\n \n@@ -1144,23 +1143,21 @@ fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    writeFile(&repo_subdir.join_str(\"foo\"), \"foo\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    writeFile(&repo_subdir.join(\"foo\"), \"foo\");\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"testbranch\");\n-    writeFile(&repo_subdir.join_str(\"testbranch_only\"), \"hello\");\n+    writeFile(&repo_subdir.join(\"testbranch_only\"), \"hello\");\n     add_git_tag(&repo_subdir, ~\"another_tag\");\n-    writeFile(&repo_subdir.join_str(\"not_on_testbranch_only\"), \"bye bye\");\n+    writeFile(&repo_subdir.join(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", format!(\"{}\\\\#testbranch\",\n                                            temp_pkg_id.path.as_str().unwrap())], repo);\n-    let file1 = repo.join_many_str([\"mockgithub.com\", \"catamorphism\",\n-                                    \"test-pkg\", \"testbranch_only\"]);\n-    let file2 = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n-                                    \"master_only\"]);\n+    let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n+    let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n     assert!(os::path_exists(&file1));\n     assert!(!os::path_exists(&file2));\n }\n@@ -1169,13 +1166,12 @@ fn test_non_numeric_tag() {\n fn test_extern_mod() {\n     let dir = TempDir::new(\"test_extern_mod\").expect(\"test_extern_mod\");\n     let dir = dir.path();\n-    let main_file = dir.join_str(\"main.rs\");\n+    let main_file = dir.join(\"main.rs\");\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n     let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.join_many_str([\"src\", \"mockgithub.com\", \"catamorphism\",\n-                                                \"test_pkg\"]);\n+    let aux_dir = lib_depend_dir.join_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n-    let aux_pkg_file = aux_dir.join_str(\"lib.rs\");\n+    let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n     assert!(os::path_exists(&aux_pkg_file));\n@@ -1186,12 +1182,12 @@ fn test_extern_mod() {\n \n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], lib_depend_dir);\n \n-    let exec_file = dir.join_str(\"out\");\n+    let exec_file = dir.join(\"out\");\n     // Be sure to extend the existing environment\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename_str(\"rustc\");\n+    let rustc = rustpkg_exec.with_filename(\"rustc\");\n \n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1219,12 +1215,12 @@ fn test_extern_mod() {\n fn test_extern_mod_simpler() {\n     let dir = TempDir::new(\"test_extern_mod_simpler\").expect(\"test_extern_mod_simpler\");\n     let dir = dir.path();\n-    let main_file = dir.join_str(\"main.rs\");\n+    let main_file = dir.join(\"main.rs\");\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n     let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.join_many_str([\"src\", \"rust-awesomeness\"]);\n+    let aux_dir = lib_depend_dir.join_many([\"src\", \"rust-awesomeness\"]);\n     assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n-    let aux_pkg_file = aux_dir.join_str(\"lib.rs\");\n+    let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n     assert!(os::path_exists(&aux_pkg_file));\n@@ -1235,12 +1231,12 @@ fn test_extern_mod_simpler() {\n \n     command_line_test([~\"install\", ~\"rust-awesomeness\"], lib_depend_dir);\n \n-    let exec_file = dir.join_str(\"out\");\n+    let exec_file = dir.join(\"out\");\n     // Be sure to extend the existing environment\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n     let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename_str(\"rustc\");\n+    let rustc = rustpkg_exec.with_filename(\"rustc\");\n     let test_sys = test_sysroot();\n     debug2!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n                      lib_depend_dir.display(),\n@@ -1275,11 +1271,11 @@ fn test_import_rustpkg() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug2!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join_str(\"foo\").join_str(format!(\"pkg{}\",\n+    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1288,11 +1284,11 @@ fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug2!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join_str(\"foo\").join_str(format!(\"pkg{}\",\n+    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1302,8 +1298,8 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::from_str(\"foo\"), &NoVersion);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::from_str(\"foo\"), &NoVersion);\n+    let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n+    let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n     debug2!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n@@ -1328,19 +1324,19 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let p_id = PkgId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    let rust_path = Some(~[(~\"RUST_PATH\",\n        format!(\"{}:{}\",\n                dest_workspace.as_str().unwrap(),\n                foo_path.as_str().unwrap()))]);\n    command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n                                ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_executable_exists(dest_workspace, \"foo\");\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion));\n+   assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n    assert!(!executable_exists(workspace, \"foo\"));\n    assert!(!built_library_exists(workspace, \"foo\"));\n    assert!(!built_executable_exists(workspace, \"foo\"));\n@@ -1369,40 +1365,40 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n-   let cwd = cwd.path().join_str(\"foo\");\n+   let cwd = cwd.path().join(\"foo\");\n    assert!(os::mkdir_recursive(&cwd, U_RWX));\n-   writeFile(&cwd.join_str(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n    debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &Path::from_str(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&cwd, &Path::new(\"foo\"), NoVersion));\n    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n-   let subdir = cwd.path().join_many_str([\"foo\", \"bar\", \"quux\"]);\n+   let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n    assert!(os::mkdir_recursive(&subdir, U_RWX));\n-   writeFile(&subdir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n-   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n    debug2!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::from_str(\"quux\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"quux\"), NoVersion);\n    assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &Path::from_str(\"quux\"), NoVersion));\n+   assert!(!lib_exists(&subdir, &Path::new(\"quux\"), NoVersion));\n    assert!(!built_library_exists(&subdir, name));\n }\n \n@@ -1411,31 +1407,31 @@ fn rust_path_hack_install_no_arg() {\n    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n    let cwd = cwd.path();\n-   let source_dir = cwd.join_str(\"foo\");\n+   let source_dir = cwd.join(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n    debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &Path::from_str(\"foo\"), NoVersion);\n+   assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &Path::from_str(\"foo\"), NoVersion));\n+   assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), NoVersion));\n    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_no_arg() {\n    // Same as rust_path_hack_install_no_arg, but building instead of installing\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-   let source_dir = cwd.path().join_str(\"foo\");\n+   let source_dir = cwd.path().join(\"foo\");\n    assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join_str(\"lib.rs\"), \"pub fn f() { }\");\n+   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n \n-   let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+   let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n@@ -1449,9 +1445,9 @@ fn rust_path_hack_build_no_arg() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let mut dir = mk_workspace(dir_for_path.path(), &Path::from_str(\"foo\"), &NoVersion);\n+    let mut dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n     debug2!(\"dir = {}\", dir.display());\n-    writeFile(&dir.join_str(\"main.rs\"), \"fn main() { let _x = (); }\");\n+    writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n     let dir_to_install_to = dir_to_install_to.path();\n@@ -1561,7 +1557,7 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion));\n+        assert!(!lib_exists(workspace, &Path::new(\"foo\"), NoVersion));\n     }\n }\n \n@@ -1605,7 +1601,7 @@ fn test_cfg_build() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n-    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1623,7 +1619,7 @@ fn test_cfg_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1780,23 +1776,23 @@ fn pkgid_pointing_to_subdir() {\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n     let workspace = workspace.path();\n-    assert!(os::mkdir_recursive(&workspace.join_many_str([\"src\", \"mockgithub.com\",\n-                                                          \"mozilla\", \"some_repo\"]), U_RWX));\n+    assert!(os::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n+                                                      \"mozilla\", \"some_repo\"]), U_RWX));\n \n-    let foo_dir = workspace.join_many_str([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n-                                           \"extras\", \"foo\"]);\n-    let bar_dir = workspace.join_many_str([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n-                                           \"extras\", \"bar\"]);\n+    let foo_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n+                                       \"extras\", \"foo\"]);\n+    let bar_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n+                                       \"extras\", \"bar\"]);\n     assert!(os::mkdir_recursive(&foo_dir, U_RWX));\n     assert!(os::mkdir_recursive(&bar_dir, U_RWX));\n-    writeFile(&foo_dir.join_str(\"lib.rs\"), \"pub fn f() {}\");\n-    writeFile(&bar_dir.join_str(\"lib.rs\"), \"pub fn g() {}\");\n+    writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n+    writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n \n     debug2!(\"Creating a file in {}\", workspace.display());\n-    let testpkg_dir = workspace.join_many_str([\"src\", \"testpkg-0.1\"]);\n+    let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n     assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n \n-    writeFile(&testpkg_dir.join_str(\"main.rs\"),\n+    writeFile(&testpkg_dir.join(\"main.rs\"),\n               \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n                extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar\\\";\\n\n                use foo::f; use bar::g; \\n\n@@ -1813,31 +1809,31 @@ fn test_recursive_deps() {\n     let c_id = PkgId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n-    writeFile(&b_workspace.join_many_str([\"src\", \"c-0.1\", \"lib.rs\"])),\n+    writeFile(&b_workspace.join_many([\"src\", \"c-0.1\", \"lib.rs\"])),\n                \"pub fn g() {}\");\n     let a_workspace = create_local_package(&a_id);\n     let a_workspace = a_workspace.path();\n-    writeFile(&a_workspace.join_many_str([\"src\", \"a-0.1\", \"main.rs\"]),\n+    writeFile(&a_workspace.join_many([\"src\", \"a-0.1\", \"main.rs\"]),\n                \"extern mod b; use b::f; fn main() { f(); }\");\n-    writeFile(&b_workspace.join_many_str([\"src\", \"b-0.1\", \"lib.rs\"]),\n+    writeFile(&b_workspace.join_many([\"src\", \"b-0.1\", \"lib.rs\"]),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.as_str().unwrap().to_owned())]);\n     debug2!(\"RUST_PATH={}\", b_workspace.display());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &Path::from_str(\"a\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::from_str(\"b\"), NoVersion);\n-    assert_lib_exists(b_workspace, &Path::from_str(\"c\"), NoVersion);\n+    assert_lib_exists(a_workspace, &Path::new(\"a\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::new(\"b\"), NoVersion);\n+    assert_lib_exists(b_workspace, &Path::new(\"c\"), NoVersion);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n     let p_id = PkgId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&Path::from_str(\"p\"), &NoVersion, \"dest\");\n+    let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n     let first_workspace = first_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1869,7 +1865,7 @@ fn test_target_specific_build_dir() {\n                       workspace);\n     assert!(os::path_is_dir(&target_build_dir(workspace)));\n     assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(os::list_dir(&workspace.join_str(\"build\")).len() == 1);\n+    assert!(os::list_dir(&workspace.join(\"build\")).len() == 1);\n }\n \n #[test]\n@@ -1883,10 +1879,10 @@ fn test_target_specific_install_dir() {\n                        ~\"install\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&workspace.join_many_str([\"lib\", host_triple()])));\n-    assert_lib_exists(workspace, &Path::from_str(\"foo\"), NoVersion);\n-    assert!(os::list_dir(&workspace.join_str(\"lib\")).len() == 1);\n-    assert!(os::path_is_dir(&workspace.join_str(\"bin\")));\n+    assert!(os::path_is_dir(&workspace.join_many([\"lib\", host_triple()])));\n+    assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n+    assert!(os::list_dir(&workspace.join(\"lib\")).len() == 1);\n+    assert!(os::path_is_dir(&workspace.join(\"bin\")));\n     assert_executable_exists(workspace, \"foo\");\n }\n \n@@ -1896,10 +1892,10 @@ fn test_dependencies_terminate() {\n     let b_id = PkgId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n-    let b_dir = workspace.join_many_str([\"src\", \"b-0.1\"]);\n-    let b_subdir = b_dir.join_str(\"test\");\n+    let b_dir = workspace.join_many([\"src\", \"b-0.1\"]);\n+    let b_subdir = b_dir.join(\"test\");\n     assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n-    writeFile(&b_subdir.join_str(\"test.rs\"),\n+    writeFile(&b_subdir.join(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n     command_line_test([~\"install\", ~\"b\"], workspace);\n }\n@@ -1960,13 +1956,13 @@ fn correct_package_name_with_rust_path_hack() {\n     let bar_id = PkgId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&Path::from_str(\"bar\"), &NoVersion, \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n-    writeFile(&dest_workspace.join_many_str([\"src\", \"bar-0.1\", \"main.rs\"]),\n+    writeFile(&dest_workspace.join_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n \n-    let foo_path = foo_workspace.join_many_str([\"src\", \"foo-0.1\"]);\n+    let foo_path = foo_workspace.join_many([\"src\", \"foo-0.1\"]);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n                                                   foo_path.as_str().unwrap()))]);\n@@ -1989,7 +1985,7 @@ fn test_rustpkg_test_creates_exec() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]),\n+    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n               \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2013,7 +2009,7 @@ fn test_rebuild_when_needed() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2033,7 +2029,7 @@ fn test_no_rebuilding() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2058,16 +2054,16 @@ fn test_installed_read_only() {\n     let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.display());\n \n-    writeFile(&repo_subdir.join_str(\"main.rs\"),\n+    writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n \n-    let ws = repo.join_str(\".rust\");\n+    let ws = repo.join(\".rust\");\n     // Check that all files exist\n     debug2!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n@@ -2099,9 +2095,9 @@ fn test_installed_local_changes() {\n     debug2!(\"repo_subdir = {}\", repo_subdir.display());\n     assert!(os::mkdir_recursive(&repo.join_many_str([\".rust\", \"src\"]), U_RWX));\n \n-    writeFile(&repo_subdir.join_str(\"main.rs\"),\n+    writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join_str(\"lib.rs\"),\n+    writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n@@ -2127,13 +2123,13 @@ fn test_installed_local_changes() {\n     };\n \n     // Make a local change to it\n-    writeFile(&target_dir.join_str(\"lib.rs\"),\n+    writeFile(&target_dir.join(\"lib.rs\"),\n               \"pub fn g() { let _x = (); }\");\n \n     // Finally, make *another* package that uses it\n     let importer_pkg_id = fake_pkg();\n     let main_subdir = create_local_package_in(&importer_pkg_id, hacking_workspace);\n-    writeFile(&main_subdir.join_str(\"main.rs\"),\n+    writeFile(&main_subdir.join(\"main.rs\"),\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test-pkg\\\"; \\\n               use test::g;\n               fn main() { g(); }\");"}, {"sha": "c5e81e6dc4a2cb9267fca97f28d4a6d7dc5eaf3b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -467,8 +467,7 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                   self.context.context.use_rust_path_hack,\n                                                   pkg_id);\n                         let (outputs_disc, inputs_disc) =\n-                            self.context.install(pkg_src,\n-                                                 &JustOne(Path::from_str(lib_crate_filename)));\n+                            self.context.install(pkg_src, &JustOne(Path::new(lib_crate_filename)));\n                         debug2!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n@@ -492,12 +491,13 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_file_with_date(\n-                                                             &Path::from_str(*dep)));\n+                                                             &Path::new(dep.as_slice())));\n                             }\n                                 else if *what == ~\"binary\" {\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n-                                                         digest_only_date(&Path::from_str(*dep)));\n+                                                         digest_only_date(\n+                                                             &Path::new(dep.as_slice())));\n                             }\n                                 else {\n                                 fail2!(\"Bad kind: {}\", *what);"}, {"sha": "21abeeb03e3a26f30623e881ca70c37656ceb5d1", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -99,7 +99,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     let rustpath = rust_path();\n     for rp in rustpath.iter() {\n         let local_path = rp.join_path(local_path);\n-        let git_dir = local_path.join_str(\".git\");\n+        let git_dir = local_path.join(\".git\");\n         if !os::path_is_dir(&git_dir) {\n             continue;\n         }\n@@ -148,7 +148,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));\n             let mut output = None;\n-            let git_dir = tmp_dir.join_str(\".git\");\n+            let git_dir = tmp_dir.join(\".git\");\n             debug2!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n                    git_dir.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "b4c2a66c1aafd3de23430df8711a0ca950e98d35", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -52,15 +52,15 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n }\n \n pub fn is_workspace(p: &Path) -> bool {\n-    os::path_is_dir(&p.join_str(\"src\"))\n+    os::path_is_dir(&p.join(\"src\"))\n }\n \n /// Construct a workspace and package-ID name based on the current directory.\n /// This gets used when rustpkg gets invoked without a package-ID argument.\n pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n     let cwd = os::getcwd();\n     for path in rust_path().move_iter() {\n-        let srcpath = path.join_str(\"src\");\n+        let srcpath = path.join(\"src\");\n         if srcpath.is_ancestor_of(&cwd) {\n             let rel = cwd.path_relative_from(&srcpath);\n             let rel_s = rel.and_then_ref(|p|p.as_str());"}, {"sha": "c03fc6d7ffb61ca41e1e8c38520dce4a5a69ae97", "filename": "src/libstd/io.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -1893,7 +1893,7 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let tmpfile = &Path::from_str(\"tmp/lib-io-test-simple.tmp\");\n+        let tmpfile = &Path::new(\"tmp/lib-io-test-simple.tmp\");\n         debug2!(\"{}\", tmpfile.display());\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n@@ -1911,7 +1911,7 @@ mod tests {\n     #[test]\n     fn test_each_byte_each_char_file() {\n         // Issue #5056 -- shouldn't include trailing EOF.\n-        let path = Path::from_str(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n \n         {\n             // create empty, enough to reproduce a problem\n@@ -2011,7 +2011,7 @@ mod tests {\n \n     #[test]\n     fn file_reader_not_exist() {\n-        match io::file_reader(&Path::from_str(\"not a file\")) {\n+        match io::file_reader(&Path::new(\"not a file\")) {\n           Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n@@ -2022,7 +2022,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_read_buffer_too_small() {\n-        let path = &Path::from_str(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n+        let path = &Path::new(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n         // ensure the file exists\n         io::file_writer(path, [io::Create]).unwrap();\n \n@@ -2033,7 +2033,7 @@ mod tests {\n \n     #[test]\n     fn test_read_buffer_big_enough() {\n-        let path = &Path::from_str(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n+        let path = &Path::new(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n         // ensure the file exists\n         io::file_writer(path, [io::Create]).unwrap();\n \n@@ -2044,14 +2044,14 @@ mod tests {\n \n     #[test]\n     fn test_write_empty() {\n-        let file = io::file_writer(&Path::from_str(\"tmp/lib-io-test-write-empty.tmp\"),\n+        let file = io::file_writer(&Path::new(\"tmp/lib-io-test-write-empty.tmp\"),\n                                    [io::Create]).unwrap();\n         file.write([]);\n     }\n \n     #[test]\n     fn file_writer_bad_name() {\n-        match io::file_writer(&Path(\"?/?\"), []) {\n+        match io::file_writer(&Path::new(\"?/?\"), []) {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n@@ -2076,7 +2076,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_le() {\n-        let path = Path::from_str(\"tmp/lib-io-test-read-write-le.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-read-write-le.tmp\");\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n \n         // write the ints to the file\n@@ -2098,7 +2098,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_be() {\n-        let path = Path::from_str(\"tmp/lib-io-test-read-write-be.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-read-write-be.tmp\");\n         let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n \n         // write the ints to the file\n@@ -2120,7 +2120,7 @@ mod tests {\n \n     #[test]\n     fn test_read_be_int_n() {\n-        let path = Path::from_str(\"tmp/lib-io-test-read-be-int-n.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-read-be-int-n.tmp\");\n         let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n \n         // write the ints to the file\n@@ -2144,7 +2144,7 @@ mod tests {\n \n     #[test]\n     fn test_read_f32() {\n-        let path = Path::from_str(\"tmp/lib-io-test-read-f32.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-read-f32.tmp\");\n         //big-endian floating-point 8.1250\n         let buf = ~[0x41, 0x02, 0x00, 0x00];\n \n@@ -2162,7 +2162,7 @@ mod tests {\n \n     #[test]\n     fn test_read_write_f32() {\n-        let path = Path::from_str(\"tmp/lib-io-test-read-write-f32.tmp\");\n+        let path = Path::new(\"tmp/lib-io-test-read-write-f32.tmp\");\n         let f:f32 = 8.1250;\n \n         {"}, {"sha": "449888b4e2a4595908da3f4509da52923b7f5f57", "filename": "src/libstd/os.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -513,7 +513,7 @@ pub fn self_exe_path() -> Option<Path> {\n         }\n     }\n \n-    load_self().and_then(|path| Path::from_vec_opt(path).map(|p| p.dir_path()))\n+    load_self().and_then(|path| Path::new_opt(path).map(|p| { p.pop(); p }))\n }\n \n \n@@ -538,7 +538,7 @@ pub fn self_exe_path() -> Option<Path> {\n pub fn homedir() -> Option<Path> {\n     // FIXME (#7188): getenv needs a ~[u8] variant\n     return match getenv(\"HOME\") {\n-        Some(ref p) if !p.is_empty() => Path::from_str_opt(*p),\n+        Some(ref p) if !p.is_empty() => Path::new_opt(p.as_slice()),\n         _ => secondary()\n     };\n \n@@ -551,7 +551,7 @@ pub fn homedir() -> Option<Path> {\n     fn secondary() -> Option<Path> {\n         do getenv(\"USERPROFILE\").and_then |p| {\n             if !p.is_empty() {\n-                Path::from_str_opt(p)\n+                Path::new_opt(p)\n             } else {\n                 None\n             }\n@@ -580,7 +580,7 @@ pub fn tmpdir() -> Path {\n                 if x.is_empty() {\n                     None\n                 } else {\n-                    Path::from_str_opt(x)\n+                    Path::new_opt(x)\n                 },\n             _ => None\n         }\n@@ -589,9 +589,9 @@ pub fn tmpdir() -> Path {\n     #[cfg(unix)]\n     fn lookup() -> Path {\n         if cfg!(target_os = \"android\") {\n-            Path::from_str(\"/data/tmp\")\n+            Path::new(\"/data/tmp\")\n         } else {\n-            getenv_nonempty(\"TMPDIR\").unwrap_or(Path::from_str(\"/tmp\"))\n+            getenv_nonempty(\"TMPDIR\").unwrap_or(Path::new(\"/tmp\"))\n         }\n     }\n \n@@ -600,7 +600,7 @@ pub fn tmpdir() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::from_str(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::new(\"C:\\\\Windows\"))\n     }\n }\n \n@@ -762,7 +762,7 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                 fn rust_list_dir_wfd_size() -> libc::size_t;\n                 fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n             }\n-            let star = p.join_str(\"*\");\n+            let star = p.join(\"*\");\n             do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n                 let mut paths = ~[];\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n@@ -778,7 +778,7 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                             let fp_vec = vec::from_buf(\n                                 fp_buf, wcslen(fp_buf) as uint);\n                             let fp_str = str::from_utf16(fp_vec);\n-                            paths.push(Path::from_str(fp_str));\n+                            paths.push(Path::new(fp_str));\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n@@ -1830,13 +1830,13 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        assert!((!Path::from_str(\"test-path\").is_absolute()));\n+        assert!((!Path::new(\"test-path\").is_absolute()));\n \n         let cwd = getcwd();\n         debug2!(\"Current working directory: {}\", cwd.display());\n \n-        debug2!(\"{:?}\", make_absolute(&Path::from_str(\"test-path\")));\n-        debug2!(\"{:?}\", make_absolute(&Path::from_str(\"/usr/bin\")));\n+        debug2!(\"{:?}\", make_absolute(&Path::new(\"test-path\")));\n+        debug2!(\"{:?}\", make_absolute(&Path::new(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -1845,7 +1845,7 @@ mod tests {\n         let oldhome = getenv(\"HOME\");\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n@@ -1866,16 +1866,16 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n \n         setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"/home/MountainView\");\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert_eq!(os::homedir(), Some(Path::from_str(\"/home/MountainView\")));\n+        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n \n         for s in oldhome.iter() { setenv(\"HOME\", *s) }\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n@@ -1891,12 +1891,12 @@ mod tests {\n     // Issue #712\n     #[test]\n     fn test_list_dir_no_invalid_memory_access() {\n-        os::list_dir(&Path::from_str(\".\"));\n+        os::list_dir(&Path::new(\".\"));\n     }\n \n     #[test]\n     fn list_dir() {\n-        let dirs = os::list_dir(&Path::from_str(\".\"));\n+        let dirs = os::list_dir(&Path::new(\".\"));\n         // Just assuming that we've got some contents in the current directory\n         assert!(dirs.len() > 0u);\n \n@@ -1908,35 +1908,35 @@ mod tests {\n     #[test]\n     #[cfg(not(windows))]\n     fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::from_str(\"/\"));\n+        let dirs = os::list_dir(&Path::new(\"/\"));\n         assert!(dirs.len() > 1);\n     }\n     #[test]\n     #[cfg(windows)]\n     fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::from_str(\"C:\\\\\"));\n+        let dirs = os::list_dir(&Path::new(\"C:\\\\\"));\n         assert!(dirs.len() > 1);\n     }\n \n \n     #[test]\n     fn path_is_dir() {\n-        assert!((os::path_is_dir(&Path::from_str(\".\"))));\n-        assert!((!os::path_is_dir(&Path::from_str(\"test/stdtest/fs.rs\"))));\n+        assert!((os::path_is_dir(&Path::new(\".\"))));\n+        assert!((!os::path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert!((os::path_exists(&Path::from_str(\".\"))));\n-        assert!((!os::path_exists(&Path::from_str(\n+        assert!((os::path_exists(&Path::new(\".\"))));\n+        assert!((!os::path_exists(&Path::new(\n                      \"test/nonexistent-bogus-path\"))));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert!(!os::copy_file(&Path::from_str(\"test/nonexistent-bogus-path\"),\n-                            &Path::from_str(\"test/other-bogus-path\")));\n-      assert!(!os::path_exists(&Path::from_str(\"test/other-bogus-path\")));\n+      assert!(!os::copy_file(&Path::new(\"test/nonexistent-bogus-path\"),\n+                            &Path::new(\"test/other-bogus-path\")));\n+      assert!(!os::path_exists(&Path::new(\"test/other-bogus-path\")));\n     }\n \n     #[test]\n@@ -1946,8 +1946,8 @@ mod tests {\n         unsafe {\n             let tempdir = getcwd(); // would like to use $TMPDIR,\n                                     // doesn't seem to work on Linux\n-            let input = tempdir.join_str(\"in.txt\");\n-            let out = tempdir.join_str(\"out.txt\");\n+            let input = tempdir.join(\"in.txt\");\n+            let out = tempdir.join(\"out.txt\");\n \n             /* Write the temp input file */\n             let ostream = do input.with_c_str |fromp| {\n@@ -1983,7 +1983,7 @@ mod tests {\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        let path = Path::from_str(\"/\");\n+        let path = Path::new(\"/\");\n         assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n \n@@ -2032,7 +2032,7 @@ mod tests {\n         }\n \n         let mut path = tmpdir();\n-        path.push_str(\"mmap_file.tmp\");\n+        path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n         remove_file(&path);\n "}, {"sha": "561155f22584f00688aa96b2bb06df6e741e9309", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 222, "deletions": 247, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -20,8 +20,7 @@ appropriate platform-specific path variant.\n Both `PosixPath` and `WindowsPath` implement a trait `GenericPath`, which\n contains the set of methods that behave the same for both paths. They each also\n implement some methods that could not be expressed in `GenericPath`, yet behave\n-identically for both path flavors, such as `::from_str()` or\n-`.component_iter()`.\n+identically for both path flavors, such as `.component_iter()`.\n \n The three main design goals of this module are 1) to avoid unnecessary\n allocation, 2) to behave the same regardless of which flavor of path is being\n@@ -35,19 +34,19 @@ code, `Path` should be used to refer to the platform-native path, and methods\n used should be restricted to those defined in `GenericPath`, and those methods\n that are declared identically on both `PosixPath` and `WindowsPath`.\n \n-Creation of a path is typically done with either `Path::from_str(some_str)` or\n-`Path::from_vec(some_vec)`. This path can be modified with `.push()` and\n+Creation of a path is typically done with either `Path::new(some_str)` or\n+`Path::new(some_vec)`. This path can be modified with `.push()` and\n `.pop()` (and other setters). The resulting Path can either be passed to another\n API that expects a path, or can be turned into a &[u8] with `.as_vec()` or a\n Option<&str> with `.as_str()`. Similarly, attributes of the path can be queried\n with methods such as `.filename()`. There are also methods that return a new\n path instead of modifying the receiver, such as `.join()` or `.dir_path()`.\n \n Paths are always kept in normalized form. This means that creating the path\n-`Path::from_str(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt\n+`Path::new(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt\n to mutate the path will always leave it in normalized form.\n \n-When rendering a path to some form of display, there is a method `.display()`\n+When rendering a path to some form of output, there is a method `.display()`\n which is compatible with the `format!()` parameter `{}`. This will render the\n path as a string, replacing all non-utf8 sequences with the Replacement\n Character (U+FFFD). As such it is not suitable for passing to any API that\n@@ -56,10 +55,10 @@ actually operates on the path; it is only intended for display.\n ## Example\n \n ```rust\n-let mut path = Path::from_str(\"/tmp/path\");\n+let mut path = Path::new(\"/tmp/path\");\n debug2!(\"path: {}\", path.display());\n-path.set_filename_str(\"foo\");\n-path.push_str(\"bar\");\n+path.set_filename(\"foo\");\n+path.push(\"bar\");\n debug2!(\"new path: {}\", path.display());\n let b = std::os::path_exists(&path);\n debug2!(\"path exists: {}\", b);\n@@ -70,6 +69,7 @@ debug2!(\"path exists: {}\", b);\n use container::Container;\n use c_str::CString;\n use clone::Clone;\n+use either::{Left, Right};\n use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n@@ -131,7 +131,7 @@ condition! {\n \n /// A trait that represents the generic operations available on paths\n pub trait GenericPath: Clone + GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector.\n+    /// Creates a new Path from a byte vector or string.\n     /// The resulting Path will always be normalized.\n     ///\n     /// # Failure\n@@ -140,52 +140,24 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// See individual Path impls for additional restrictions.\n     #[inline]\n-    fn from_vec(path: &[u8]) -> Self {\n-        if contains_nul(path) {\n-            let path = self::null_byte::cond.raise(path.to_owned());\n+    fn new<T: BytesContainer>(path: T) -> Self {\n+        if contains_nul(path.container_as_bytes()) {\n+            let path = self::null_byte::cond.raise(path.container_into_owned_bytes());\n             assert!(!contains_nul(path));\n-            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+            unsafe { GenericPathUnsafe::new_unchecked(path) }\n         } else {\n-            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+            unsafe { GenericPathUnsafe::new_unchecked(path) }\n         }\n     }\n \n-    /// Creates a new Path from a byte vector, if possible.\n+    /// Creates a new Path from a byte vector or string, if possible.\n     /// The resulting Path will always be normalized.\n     #[inline]\n-    fn from_vec_opt(path: &[u8]) -> Option<Self> {\n-        if contains_nul(path) {\n+    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n+        if contains_nul(path.container_as_bytes()) {\n             None\n         } else {\n-            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(path) })\n-        }\n-    }\n-\n-    /// Creates a new Path from a string.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n-    #[inline]\n-    fn from_str(path: &str) -> Self {\n-        let v = path.as_bytes();\n-        if contains_nul(v) {\n-            GenericPath::from_vec(path.as_bytes()) // let from_vec handle the condition\n-        } else {\n-            unsafe { GenericPathUnsafe::from_str_unchecked(path) }\n-        }\n-    }\n-\n-    /// Creates a new Path from a string, if possible.\n-    /// The resulting Path will always be normalized.\n-    #[inline]\n-    fn from_str_opt(path: &str) -> Option<Self> {\n-        let v = path.as_bytes();\n-        if contains_nul(v) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::from_str_unchecked(path) })\n+            Some(unsafe { GenericPathUnsafe::new_unchecked(path) })\n         }\n     }\n \n@@ -199,7 +171,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         let v = path.as_bytes();\n         // v is NUL-terminated. Strip it off\n         let v = v.slice_to(v.len()-1);\n-        unsafe { GenericPathUnsafe::from_vec_unchecked(v) }\n+        unsafe { GenericPathUnsafe::new_unchecked(v) }\n     }\n \n     /// Returns the path as a string, if possible.\n@@ -209,9 +181,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         str::from_utf8_slice_opt(self.as_vec())\n     }\n \n+    /// Converts the Path into an owned string, if possible\n+    fn into_str(self) -> Option<~str>;\n+\n     /// Returns the path as a byte vector\n     fn as_vec<'a>(&'a self) -> &'a [u8];\n \n+    /// Converts the Path into an owned byte vector\n+    fn into_vec(self) -> ~[u8];\n+\n     /// Provides the path as a string\n     ///\n     /// If the path is not UTF-8, invalid sequences will be replaced with the unicode\n@@ -345,115 +323,91 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         self.extension().and_then(str::from_utf8_slice_opt)\n     }\n \n-    /// Replaces the directory portion of the path with the given byte vector.\n+    /// Replaces the directory portion of the path with the given byte vector or string.\n     /// If `self` represents the root of the filesystem hierarchy, the last path component\n-    /// of the given byte vector becomes the filename.\n+    /// of the argument becomes the filename.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the dirname contains a NUL.\n     #[inline]\n-    fn set_dirname(&mut self, dirname: &[u8]) {\n-        if contains_nul(dirname) {\n-            let dirname = self::null_byte::cond.raise(dirname.to_owned());\n+    fn set_dirname<T: BytesContainer>(&mut self, dirname: T) {\n+        if contains_nul(dirname.container_as_bytes()) {\n+            let dirname = self::null_byte::cond.raise(dirname.container_into_owned_bytes());\n             assert!(!contains_nul(dirname));\n             unsafe { self.set_dirname_unchecked(dirname) }\n         } else {\n             unsafe { self.set_dirname_unchecked(dirname) }\n         }\n     }\n-    /// Replaces the directory portion of the path with the given string.\n-    /// See `set_dirname` for details.\n-    #[inline]\n-    fn set_dirname_str(&mut self, dirname: &str) {\n-        if contains_nul(dirname.as_bytes()) {\n-            self.set_dirname(dirname.as_bytes()) // triggers null_byte condition\n-        } else {\n-            unsafe { self.set_dirname_str_unchecked(dirname) }\n-        }\n-    }\n-    /// Replaces the filename portion of the path with the given byte vector.\n+    /// Replaces the filename portion of the path with the given byte vector or string.\n     /// If the replacement name is [], this is equivalent to popping the path.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the filename contains a NUL.\n     #[inline]\n-    fn set_filename(&mut self, filename: &[u8]) {\n-        if contains_nul(filename) {\n-            let filename = self::null_byte::cond.raise(filename.to_owned());\n+    fn set_filename<T: BytesContainer>(&mut self, filename: T) {\n+        if contains_nul(filename.container_as_bytes()) {\n+            let filename = self::null_byte::cond.raise(filename.container_into_owned_bytes());\n             assert!(!contains_nul(filename));\n             unsafe { self.set_filename_unchecked(filename) }\n         } else {\n             unsafe { self.set_filename_unchecked(filename) }\n         }\n     }\n-    /// Replaces the filename portion of the path with the given string.\n-    /// See `set_filename` for details.\n-    #[inline]\n-    fn set_filename_str(&mut self, filename: &str) {\n-        if contains_nul(filename.as_bytes()) {\n-            self.set_filename(filename.as_bytes()) // triggers null_byte condition\n-        } else {\n-            unsafe { self.set_filename_str_unchecked(filename) }\n-        }\n-    }\n-    /// Replaces the filestem with the given byte vector.\n+    /// Replaces the filestem with the given byte vector or string.\n     /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n-    /// to `set_filename`. Otherwise, if the given byte vector is [], the extension (including\n+    /// to `set_filename`. Otherwise, if the argument is [] or \"\", the extension (including\n     /// the preceding '.') becomes the new filename.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the filestem contains a NUL.\n-    fn set_filestem(&mut self, filestem: &[u8]) {\n+    fn set_filestem<T: BytesContainer>(&mut self, filestem: T) {\n         // borrowck is being a pain here\n         let val = {\n             match self.filename() {\n-                None => None,\n+                None => Left(filestem),\n                 Some(name) => {\n                     let dot = '.' as u8;\n                     match name.rposition_elem(&dot) {\n-                        None | Some(0) => None,\n+                        None | Some(0) => Left(filestem),\n                         Some(idx) => {\n                             let mut v;\n-                            if contains_nul(filestem) {\n-                                let filestem = self::null_byte::cond.raise(filestem.to_owned());\n+                            if contains_nul(filestem.container_as_bytes()) {\n+                                let filestem = filestem.container_into_owned_bytes();\n+                                let filestem = self::null_byte::cond.raise(filestem);\n                                 assert!(!contains_nul(filestem));\n                                 v = filestem;\n                                 let n = v.len();\n                                 v.reserve(n + name.len() - idx);\n                             } else {\n+                                let filestem = filestem.container_as_bytes();\n                                 v = vec::with_capacity(filestem.len() + name.len() - idx);\n                                 v.push_all(filestem);\n                             }\n                             v.push_all(name.slice_from(idx));\n-                            Some(v)\n+                            Right(v)\n                         }\n                     }\n                 }\n             }\n         };\n         match val {\n-            None => self.set_filename(filestem),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n+            Left(v)  => self.set_filename(v),\n+            Right(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n-    /// Replaces the filestem with the given string.\n-    /// See `set_filestem` for details.\n-    #[inline]\n-    fn set_filestem_str(&mut self, filestem: &str) {\n-        self.set_filestem(filestem.as_bytes())\n-    }\n-    /// Replaces the extension with the given byte vector.\n+    /// Replaces the extension with the given byte vector or string.\n     /// If there is no extension in `self`, this adds one.\n-    /// If the given byte vector is [], this removes the extension.\n+    /// If the argument is [] or \"\", this removes the extension.\n     /// If `self` has no filename, this is a no-op.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the extension contains a NUL.\n-    fn set_extension(&mut self, extension: &[u8]) {\n+    fn set_extension<T: BytesContainer>(&mut self, extension: T) {\n         // borrowck causes problems here too\n         let val = {\n             match self.filename() {\n@@ -462,19 +416,20 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                     let dot = '.' as u8;\n                     match name.rposition_elem(&dot) {\n                         None | Some(0) => {\n-                            if extension.is_empty() {\n+                            if extension.container_as_bytes().is_empty() {\n                                 None\n                             } else {\n                                 let mut v;\n-                                if contains_nul(extension) {\n-                                    let ext = extension.to_owned();\n+                                if contains_nul(extension.container_as_bytes()) {\n+                                    let ext = extension.container_into_owned_bytes();\n                                     let extension = self::null_byte::cond.raise(ext);\n                                     assert!(!contains_nul(extension));\n                                     v = vec::with_capacity(name.len() + extension.len() + 1);\n                                     v.push_all(name);\n                                     v.push(dot);\n                                     v.push_all(extension);\n                                 } else {\n+                                    let extension = extension.container_as_bytes();\n                                     v = vec::with_capacity(name.len() + extension.len() + 1);\n                                     v.push_all(name);\n                                     v.push(dot);\n@@ -484,18 +439,19 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                             }\n                         }\n                         Some(idx) => {\n-                            if extension.is_empty() {\n+                            if extension.container_as_bytes().is_empty() {\n                                 Some(name.slice_to(idx).to_owned())\n                             } else {\n                                 let mut v;\n-                                if contains_nul(extension) {\n-                                    let ext = extension.to_owned();\n+                                if contains_nul(extension.container_as_bytes()) {\n+                                    let ext = extension.container_into_owned_bytes();\n                                     let extension = self::null_byte::cond.raise(ext);\n                                     assert!(!contains_nul(extension));\n                                     v = vec::with_capacity(idx + extension.len() + 1);\n                                     v.push_all(name.slice_to(idx+1));\n                                     v.push_all(extension);\n                                 } else {\n+                                    let extension = extension.container_as_bytes();\n                                     v = vec::with_capacity(idx + extension.len() + 1);\n                                     v.push_all(name.slice_to(idx+1));\n                                     v.push_all(extension);\n@@ -512,38 +468,33 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             Some(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n-    /// Replaces the extension with the given string.\n-    /// See `set_extension` for details.\n-    #[inline]\n-    fn set_extension_str(&mut self, extension: &str) {\n-        self.set_extension(extension.as_bytes())\n-    }\n-    /// Adds the given extension (as a byte vector) to the file.\n+    /// Adds the given extension (as a byte vector or string) to the file.\n     /// This does not remove any existing extension.\n     /// `foo.bar`.add_extension(`baz`) becomes `foo.bar.baz`.\n     /// If `self` has no filename, this is a no-op.\n-    /// If the given byte vector is [], this is a no-op.\n+    /// If the argument is [] or \"\", this is a no-op.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the extension contains a NUL.\n-    fn add_extension(&mut self, extension: &[u8]) {\n-        if extension.is_empty() { return; }\n+    fn add_extension<T: BytesContainer>(&mut self, extension: T) {\n+        if extension.container_as_bytes().is_empty() { return; }\n         // appease borrowck\n         let val = {\n             match self.filename() {\n                 None => None,\n                 Some(name) => {\n                     let mut v;\n-                    if contains_nul(extension) {\n-                        let ext = extension.to_owned();\n+                    if contains_nul(extension.container_as_bytes()) {\n+                        let ext = extension.container_into_owned_bytes();\n                         let extension = self::null_byte::cond.raise(ext);\n                         assert!(!contains_nul(extension));\n                         v = vec::with_capacity(name.len() + 1 + extension.len());\n                         v.push_all(name);\n                         v.push('.' as u8);\n                         v.push_all(extension);\n                     } else {\n+                        let extension = extension.container_as_bytes();\n                         v = vec::with_capacity(name.len() + 1 + extension.len());\n                         v.push_all(name);\n                         v.push('.' as u8);\n@@ -558,157 +509,113 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             Some(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n-    /// Adds the given extension (as a string) to the file.\n-    /// See `add_extension` for details.\n-    #[inline]\n-    fn add_extension_str(&mut self, extension: &str) {\n-        self.add_extension(extension.as_bytes())\n-    }\n \n-    /// Returns a new Path constructed by replacing the dirname with the given byte vector.\n+    /// Returns a new Path constructed by replacing the dirname with the given\n+    /// byte vector or string.\n     /// See `set_dirname` for details.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the dirname contains a NUL.\n     #[inline]\n-    fn with_dirname(&self, dirname: &[u8]) -> Self {\n+    fn with_dirname<T: BytesContainer>(&self, dirname: T) -> Self {\n         let mut p = self.clone();\n         p.set_dirname(dirname);\n         p\n     }\n-    /// Returns a new Path constructed by replacing the dirname with the given string.\n-    /// See `set_dirname` for details.\n-    #[inline]\n-    fn with_dirname_str(&self, dirname: &str) -> Self {\n-        let mut p = self.clone();\n-        p.set_dirname_str(dirname);\n-        p\n-    }\n-    /// Returns a new Path constructed by replacing the filename with the given byte vector.\n+    /// Returns a new Path constructed by replacing the filename with the given\n+    /// byte vector or string.\n     /// See `set_filename` for details.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the filename contains a NUL.\n     #[inline]\n-    fn with_filename(&self, filename: &[u8]) -> Self {\n+    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {\n         let mut p = self.clone();\n         p.set_filename(filename);\n         p\n     }\n-    /// Returns a new Path constructed by replacing the filename with the given string.\n-    /// See `set_filename` for details.\n-    #[inline]\n-    fn with_filename_str(&self, filename: &str) -> Self {\n-        let mut p = self.clone();\n-        p.set_filename_str(filename);\n-        p\n-    }\n-    /// Returns a new Path constructed by setting the filestem to the given byte vector.\n+    /// Returns a new Path constructed by setting the filestem to the given\n+    /// byte vector or string.\n     /// See `set_filestem` for details.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the filestem contains a NUL.\n     #[inline]\n-    fn with_filestem(&self, filestem: &[u8]) -> Self {\n+    fn with_filestem<T: BytesContainer>(&self, filestem: T) -> Self {\n         let mut p = self.clone();\n         p.set_filestem(filestem);\n         p\n     }\n-    /// Returns a new Path constructed by setting the filestem to the given string.\n-    /// See `set_filestem` for details.\n-    #[inline]\n-    fn with_filestem_str(&self, filestem: &str) -> Self {\n-        let mut p = self.clone();\n-        p.set_filestem_str(filestem);\n-        p\n-    }\n-    /// Returns a new Path constructed by setting the extension to the given byte vector.\n+    /// Returns a new Path constructed by setting the extension to the given\n+    /// byte vector or string.\n     /// See `set_extension` for details.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the extension contains a NUL.\n     #[inline]\n-    fn with_extension(&self, extension: &[u8]) -> Self {\n+    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {\n         let mut p = self.clone();\n         p.set_extension(extension);\n         p\n     }\n-    /// Returns a new Path constructed by setting the extension to the given string.\n-    /// See `set_extension` for details.\n-    #[inline]\n-    fn with_extension_str(&self, extension: &str) -> Self {\n-        let mut p = self.clone();\n-        p.set_extension_str(extension);\n-        p\n-    }\n \n     /// Returns the directory component of `self`, as a Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n     fn dir_path(&self) -> Self {\n         // self.dirname() returns a NUL-free vector\n-        unsafe { GenericPathUnsafe::from_vec_unchecked(self.dirname()) }\n+        unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n     }\n     /// Returns the file component of `self`, as a relative Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns None.\n     fn file_path(&self) -> Option<Self> {\n         // self.filename() returns a NUL-free vector\n-        self.filename().map_move(|v| unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n+        self.filename().map_move(|v| unsafe { GenericPathUnsafe::new_unchecked(v) })\n     }\n \n     /// Returns a Path that represents the filesystem root that `self` is rooted in.\n     ///\n     /// If `self` is not absolute, or vol-relative in the case of Windows, this returns None.\n     fn root_path(&self) -> Option<Self>;\n \n-    /// Pushes a path (as a byte vector) onto `self`.\n+    /// Pushes a path (as a byte vector or string) onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the path contains a NUL.\n     #[inline]\n-    fn push(&mut self, path: &[u8]) {\n-        if contains_nul(path) {\n-            let path = self::null_byte::cond.raise(path.to_owned());\n+    fn push<T: BytesContainer>(&mut self, path: T) {\n+        if contains_nul(path.container_as_bytes()) {\n+            let path = self::null_byte::cond.raise(path.container_into_owned_bytes());\n             assert!(!contains_nul(path));\n             unsafe { self.push_unchecked(path) }\n         } else {\n             unsafe { self.push_unchecked(path) }\n         }\n     }\n-    /// Pushes a path (as a string) onto `self.\n-    /// See `push` for details.\n-    #[inline]\n-    fn push_str(&mut self, path: &str) {\n-        if contains_nul(path.as_bytes()) {\n-            self.push(path.as_bytes()) // triggers null_byte condition\n-        } else {\n-            unsafe { self.push_str_unchecked(path) }\n-        }\n-    }\n     /// Pushes a Path onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n     #[inline]\n     fn push_path(&mut self, path: &Self) {\n         self.push(path.as_vec())\n     }\n-    /// Pushes multiple paths (as byte vectors) onto `self`.\n+    /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n     /// See `push` for details.\n     #[inline]\n-    fn push_many<V: Vector<u8>>(&mut self, paths: &[V]) {\n-        for p in paths.iter() {\n-            self.push(p.as_slice());\n-        }\n-    }\n-    /// Pushes multiple paths (as strings) onto `self`.\n-    #[inline]\n-    fn push_many_str<S: Str>(&mut self, paths: &[S]) {\n-        for p in paths.iter() {\n-            self.push_str(p.as_slice());\n+    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n+        let t: Option<T> = None;\n+        if BytesContainer::is_str(t) {\n+            for p in paths.iter() {\n+                self.push(p.container_as_str())\n+            }\n+        } else {\n+            for p in paths.iter() {\n+                self.push(p.container_as_bytes())\n+            }\n         }\n     }\n     /// Pops the last path component off of `self` and returns it.\n@@ -722,26 +629,19 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         self.pop().and_then(|v| str::from_utf8_owned_opt(v))\n     }\n \n-    /// Returns a new Path constructed by joining `self` with the given path (as a byte vector).\n+    /// Returns a new Path constructed by joining `self` with the given path\n+    /// (as a byte vector or string).\n     /// If the given path is absolute, the new Path will represent just that.\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the path contains a NUL.\n     #[inline]\n-    fn join(&self, path: &[u8]) -> Self {\n+    fn join<T: BytesContainer>(&self, path: T) -> Self {\n         let mut p = self.clone();\n         p.push(path);\n         p\n     }\n-    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n-    /// See `join` for details.\n-    #[inline]\n-    fn join_str(&self, path: &str) -> Self {\n-        let mut p = self.clone();\n-        p.push_str(path);\n-        p\n-    }\n     /// Returns a new Path constructed by joining `self` with the given path.\n     /// If the given path is absolute, the new Path will represent just that.\n     #[inline]\n@@ -750,22 +650,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.push_path(path);\n         p\n     }\n-    /// Returns a new Path constructed by joining `self` with the given paths (as byte vectors).\n+    /// Returns a new Path constructed by joining `self` with the given paths\n+    /// (as byte vectors or strings).\n     /// See `join` for details.\n     #[inline]\n-    fn join_many<V: Vector<u8>>(&self, paths: &[V]) -> Self {\n+    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {\n         let mut p = self.clone();\n         p.push_many(paths);\n         p\n     }\n-    /// Returns a new Path constructed by joining `self` with the given paths (as strings).\n-    /// See `join` for details.\n-    #[inline]\n-    fn join_many_str<S: Str>(&self, paths: &[S]) -> Self {\n-        let mut p = self.clone();\n-        p.push_many_str(paths);\n-        p\n-    }\n \n     /// Returns whether `self` represents an absolute path.\n     /// An absolute path is defined as one that, when joined to another path, will\n@@ -805,57 +698,59 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         }\n         true\n     }\n+\n+    /// Returns whether the relative path `child` is a suffix of `self`.\n+    fn ends_with_path(&self, child: &Self) -> bool;\n+}\n+\n+/// A trait that represents something bytes-like (e.g. a &[u8] or a &str)\n+pub trait BytesContainer {\n+    /// Returns a &[u8] representing the receiver\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n+    /// Consumes the receiver and converts it into ~[u8]\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self.container_as_bytes().to_owned()\n+    }\n+    /// Returns the receiver interpreted as a utf-8 string\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises `str::null_byte` if not utf-8\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        str::from_utf8_slice(self.container_as_bytes())\n+    }\n+    /// Returns the receiver interpreted as a utf-8 string, if possible\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        str::from_utf8_slice_opt(self.container_as_bytes())\n+    }\n+    /// Returns whether the concrete receiver is a string type\n+    // FIXME (#8888): Remove unused arg once ::<for T> works\n+    #[inline]\n+    fn is_str(_: Option<Self>) -> bool { false }\n }\n \n /// A trait that represents the unsafe operations on GenericPaths\n pub trait GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector without checking for null bytes.\n+    /// Creates a new Path without checking for null bytes.\n     /// The resulting Path will always be normalized.\n-    unsafe fn from_vec_unchecked(path: &[u8]) -> Self;\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;\n \n-    /// Creates a new Path from a str without checking for null bytes.\n-    /// The resulting Path will always be normalized.\n-    #[inline]\n-    unsafe fn from_str_unchecked(path: &str) -> Self {\n-        GenericPathUnsafe::from_vec_unchecked(path.as_bytes())\n-    }\n-\n-    /// Replaces the directory portion of the path with the given byte vector without\n-    /// checking for null bytes.\n+    /// Replaces the directory portion of the path without checking for null\n+    /// bytes.\n     /// See `set_dirname` for details.\n-    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]);\n-\n-    /// Replaces the directory portion of the path with the given str without\n-    /// checking for null bytes.\n-    /// See `set_dirname_str` for details.\n-    #[inline]\n-    unsafe fn set_dirname_str_unchecked(&mut self, dirname: &str) {\n-        self.set_dirname_unchecked(dirname.as_bytes())\n-    }\n+    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T);\n \n-    /// Replaces the filename portion of the path with the given byte vector without\n-    /// checking for null bytes.\n+    /// Replaces the filename portion of the path without checking for null\n+    /// bytes.\n     /// See `set_filename` for details.\n-    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]);\n-\n-    /// Replaces the filename portion of the path with the given str without\n-    /// checking for null bytes.\n-    /// See `set_filename_str` for details.\n-    #[inline]\n-    unsafe fn set_filename_str_unchecked(&mut self, filename: &str) {\n-        self.set_filename_unchecked(filename.as_bytes())\n-    }\n+    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);\n \n-    /// Pushes a byte vector onto `self` without checking for null bytes.\n+    /// Pushes a path onto `self` without checking for null bytes.\n     /// See `push` for details.\n-    unsafe fn push_unchecked(&mut self, path: &[u8]);\n-\n-    /// Pushes a str onto `self` without checking for null bytes.\n-    /// See `push_str` for details.\n-    #[inline]\n-    unsafe fn push_str_unchecked(&mut self, path: &str) {\n-        self.push_unchecked(path.as_bytes())\n-    }\n+    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);\n }\n \n /// Helper struct for printing paths with format!()\n@@ -883,6 +778,86 @@ impl<'self, P: GenericPath> fmt::Default for FilenameDisplay<'self, P> {\n     }\n }\n \n+impl<'self> BytesContainer for &'self str {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_bytes()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        *self\n+    }\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        Some(*self)\n+    }\n+    #[inline]\n+    fn is_str(_: Option<&'self str>) -> bool { true }\n+}\n+\n+impl BytesContainer for ~str {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_bytes()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self.into_bytes()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        self.as_slice()\n+    }\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        Some(self.as_slice())\n+    }\n+    #[inline]\n+    fn is_str(_: Option<~str>) -> bool { true }\n+}\n+\n+impl BytesContainer for @str {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_bytes()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        self.as_slice()\n+    }\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        Some(self.as_slice())\n+    }\n+    #[inline]\n+    fn is_str(_: Option<@str>) -> bool { true }\n+}\n+\n+impl<'self> BytesContainer for &'self [u8] {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        *self\n+    }\n+}\n+\n+impl BytesContainer for ~[u8] {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_slice()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self\n+    }\n+}\n+\n+impl BytesContainer for @[u8] {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_slice()\n+    }\n+}\n+\n #[inline(always)]\n fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)"}, {"sha": "3400b673c301266caf44b1ed9eeeff1482e6bd32", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 300, "deletions": 318, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -23,7 +23,7 @@ use to_bytes::IterBytes;\n use util;\n use vec;\n use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n-use super::{GenericPath, GenericPathUnsafe};\n+use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n #[cfg(not(target_os = \"win32\"))]\n use libc;\n@@ -65,12 +65,7 @@ impl Eq for Path {\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        let v = s.as_bytes();\n-        if contains_nul(v) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n-        }\n+        Path::new_opt(s)\n     }\n }\n \n@@ -95,14 +90,15 @@ impl IterBytes for Path {\n }\n \n impl GenericPathUnsafe for Path {\n-    unsafe fn from_vec_unchecked(path: &[u8]) -> Path {\n-        let path = Path::normalize(path);\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n+        let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n         let idx = path.rposition_elem(&sep);\n         Path{ repr: path, sepidx: idx }\n     }\n \n-    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n+    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T) {\n+        let dirname = dirname.container_as_bytes();\n         match self.sepidx {\n             None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => {\n                 self.repr = Path::normalize(dirname);\n@@ -134,7 +130,8 @@ impl GenericPathUnsafe for Path {\n         self.sepidx = self.repr.rposition_elem(&sep);\n     }\n \n-    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n+    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n+        let filename = filename.container_as_bytes();\n         match self.sepidx {\n             None if bytes!(\"..\") == self.repr => {\n                 let mut v = vec::with_capacity(3 + filename.len());\n@@ -163,7 +160,8 @@ impl GenericPathUnsafe for Path {\n         self.sepidx = self.repr.rposition_elem(&sep);\n     }\n \n-    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n+    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n+        let path = path.container_as_bytes();\n         if !path.is_empty() {\n             if path[0] == sep {\n                 self.repr = Path::normalize(path);\n@@ -185,6 +183,14 @@ impl GenericPath for Path {\n         self.repr.as_slice()\n     }\n \n+    fn into_vec(self) -> ~[u8] {\n+        self.repr\n+    }\n+\n+    fn into_str(self) -> Option<~str> {\n+        str::from_utf8_owned_opt(self.repr)\n+    }\n+\n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n             None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n@@ -230,7 +236,7 @@ impl GenericPath for Path {\n \n     fn root_path(&self) -> Option<Path> {\n         if self.is_absolute() {\n-            Some(Path::from_str(\"/\"))\n+            Some(Path::new(\"/\"))\n         } else {\n             None\n         }\n@@ -299,52 +305,41 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::from_vec(comps.connect_vec(&sep)))\n+            Some(Path::new(comps.connect_vec(&sep)))\n+        }\n+    }\n+\n+    fn ends_with_path(&self, child: &Path) -> bool {\n+        if !child.is_relative() { return false; }\n+        let mut selfit = self.rev_component_iter();\n+        let mut childit = child.rev_component_iter();\n+        loop {\n+            match (selfit.next(), childit.next()) {\n+                (Some(a), Some(b)) => if a != b { return false; },\n+                (Some(_), None) => break,\n+                (None, Some(_)) => return false,\n+                (None, None) => break\n+            }\n         }\n+        true\n     }\n }\n \n impl Path {\n-    /// Returns a new Path from a byte vector\n+    /// Returns a new Path from a byte vector or string\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     #[inline]\n-    pub fn from_vec(v: &[u8]) -> Path {\n-        GenericPath::from_vec(v)\n-    }\n-\n-    /// Returns a new Path from a byte vector, if possible\n-    #[inline]\n-    pub fn from_vec_opt(v: &[u8]) -> Option<Path> {\n-        GenericPath::from_vec_opt(v)\n-    }\n-\n-    /// Returns a new Path from a string\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the str contains a NUL.\n-    #[inline]\n-    pub fn from_str(s: &str) -> Path {\n-        GenericPath::from_str(s)\n+    pub fn new<T: BytesContainer>(path: T) -> Path {\n+        GenericPath::new(path)\n     }\n \n-    /// Returns a new Path from a string, if possible\n+    /// Returns a new Path from a byte vector or string, if possible\n     #[inline]\n-    pub fn from_str_opt(s: &str) -> Option<Path> {\n-        GenericPath::from_str_opt(s)\n-    }\n-\n-    /// Converts the Path into an owned byte vector\n-    pub fn into_vec(self) -> ~[u8] {\n-        self.repr\n-    }\n-\n-    /// Converts the Path into an owned string, if possible\n-    pub fn into_str(self) -> Option<~str> {\n-        str::from_utf8_owned_opt(self.repr)\n+    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+        GenericPath::new_opt(path)\n     }\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n@@ -427,22 +422,6 @@ impl Path {\n     pub fn rev_str_component_iter<'a>(&'a self) -> RevStrComponentIter<'a> {\n         self.rev_component_iter().map(str::from_utf8_slice_opt)\n     }\n-\n-    /// Returns whether the relative path `child` is a suffix of `self`.\n-    pub fn ends_with_path(&self, child: &Path) -> bool {\n-        if !child.is_relative() { return false; }\n-        let mut selfit = self.rev_component_iter();\n-        let mut childit = child.rev_component_iter();\n-        loop {\n-            match (selfit.next(), childit.next()) {\n-                (Some(a), Some(b)) => if a != b { return false; },\n-                (Some(_), None) => break,\n-                (None, Some(_)) => return false,\n-                (None, None) => break\n-            }\n-        }\n-        true\n-    }\n }\n \n // None result means the byte vector didn't need normalizing\n@@ -611,54 +590,55 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        t!(v: Path::from_vec([]), b!(\".\"));\n-        t!(v: Path::from_vec(b!(\"/\")), b!(\"/\"));\n-        t!(v: Path::from_vec(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: Path::from_vec(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: Path::from_vec(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = Path::from_vec(b!(\"a/b/c\", 0xff));\n+        let empty: &[u8] = [];\n+        t!(v: Path::new(empty), b!(\".\"));\n+        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n+        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n+        let p = Path::new(b!(\"a/b/c\", 0xff));\n         assert_eq!(p.as_str(), None);\n \n-        t!(s: Path::from_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"/\"), \"/\");\n-        t!(s: Path::from_str(\"hi\"), \"hi\");\n-        t!(s: Path::from_str(\"hi/\"), \"hi\");\n-        t!(s: Path::from_str(\"/lib\"), \"/lib\");\n-        t!(s: Path::from_str(\"/lib/\"), \"/lib\");\n-        t!(s: Path::from_str(\"hi/there\"), \"hi/there\");\n-        t!(s: Path::from_str(\"hi/there.txt\"), \"hi/there.txt\");\n-\n-        t!(s: Path::from_str(\"hi/there/\"), \"hi/there\");\n-        t!(s: Path::from_str(\"hi/../there\"), \"there\");\n-        t!(s: Path::from_str(\"../hi/there\"), \"../hi/there\");\n-        t!(s: Path::from_str(\"/../hi/there\"), \"/hi/there\");\n-        t!(s: Path::from_str(\"foo/..\"), \".\");\n-        t!(s: Path::from_str(\"/foo/..\"), \"/\");\n-        t!(s: Path::from_str(\"/foo/../..\"), \"/\");\n-        t!(s: Path::from_str(\"/foo/../../bar\"), \"/bar\");\n-        t!(s: Path::from_str(\"/./hi/./there/.\"), \"/hi/there\");\n-        t!(s: Path::from_str(\"/./hi/./there/./..\"), \"/hi\");\n-        t!(s: Path::from_str(\"foo/../..\"), \"..\");\n-        t!(s: Path::from_str(\"foo/../../..\"), \"../..\");\n-        t!(s: Path::from_str(\"foo/../../bar\"), \"../bar\");\n-\n-        assert_eq!(Path::from_vec(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n-        assert_eq!(Path::from_vec(b!(\"/foo/../../bar\")).into_vec(),\n+        t!(s: Path::new(\"\"), \".\");\n+        t!(s: Path::new(\"/\"), \"/\");\n+        t!(s: Path::new(\"hi\"), \"hi\");\n+        t!(s: Path::new(\"hi/\"), \"hi\");\n+        t!(s: Path::new(\"/lib\"), \"/lib\");\n+        t!(s: Path::new(\"/lib/\"), \"/lib\");\n+        t!(s: Path::new(\"hi/there\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/there.txt\"), \"hi/there.txt\");\n+\n+        t!(s: Path::new(\"hi/there/\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/../there\"), \"there\");\n+        t!(s: Path::new(\"../hi/there\"), \"../hi/there\");\n+        t!(s: Path::new(\"/../hi/there\"), \"/hi/there\");\n+        t!(s: Path::new(\"foo/..\"), \".\");\n+        t!(s: Path::new(\"/foo/..\"), \"/\");\n+        t!(s: Path::new(\"/foo/../..\"), \"/\");\n+        t!(s: Path::new(\"/foo/../../bar\"), \"/bar\");\n+        t!(s: Path::new(\"/./hi/./there/.\"), \"/hi/there\");\n+        t!(s: Path::new(\"/./hi/./there/./..\"), \"/hi\");\n+        t!(s: Path::new(\"foo/../..\"), \"..\");\n+        t!(s: Path::new(\"foo/../../..\"), \"../..\");\n+        t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec(),\n                    b!(\"/bar\").to_owned());\n-        assert_eq!(Path::from_str(\"foo/bar\").into_str(), Some(~\"foo/bar\"));\n-        assert_eq!(Path::from_str(\"/foo/../../bar\").into_str(), Some(~\"/bar\"));\n+        assert_eq!(Path::new(\"foo/bar\").into_str(), Some(~\"foo/bar\"));\n+        assert_eq!(Path::new(\"/foo/../../bar\").into_str(), Some(~\"/bar\"));\n \n-        let p = Path::from_vec(b!(\"foo/bar\", 0x80));\n+        let p = Path::new(b!(\"foo/bar\", 0x80));\n         assert_eq!(p.as_str(), None);\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n+        assert_eq!(Path::new(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::from_vec_opt(b!(\"foo/bar\", 0)), None);\n-        t!(v: Path::from_vec_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n-        assert_eq!(Path::from_str_opt(\"foo/bar\\0\"), None);\n-        t!(s: Path::from_str_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n+        assert_eq!(Path::new_opt(b!(\"foo/bar\", 0)), None);\n+        t!(v: Path::new_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n+        assert_eq!(Path::new_opt(\"foo/bar\\0\"), None);\n+        t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n \n     #[test]\n@@ -671,7 +651,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n             (b!(\"/bar\").to_owned())\n         }).inside {\n-            Path::from_vec(b!(\"foo/bar\", 0))\n+            Path::new(b!(\"foo/bar\", 0))\n         };\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/bar\"));\n@@ -727,16 +707,16 @@ mod tests {\n             )\n         )\n \n-        t!(~\"from_vec() w/nul\" => {\n+        t!(~\"new() w/nul\" => {\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n-                Path::from_vec(b!(\"foo/bar\", 0))\n+                Path::new(b!(\"foo/bar\", 0))\n             };\n         })\n \n         t!(~\"set_filename w/nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo/bar\"));\n+            let mut p = Path::new(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -745,7 +725,7 @@ mod tests {\n         })\n \n         t!(~\"set_dirname w/nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo/bar\"));\n+            let mut p = Path::new(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -754,7 +734,7 @@ mod tests {\n         })\n \n         t!(~\"push w/nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo/bar\"));\n+            let mut p = Path::new(b!(\"foo/bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -765,46 +745,46 @@ mod tests {\n \n     #[test]\n     fn test_display_str() {\n-        assert_eq!(Path::from_str(\"foo\").to_display_str(), ~\"foo\");\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0x80)).to_display_str(), ~\"foo\\uFFFD\");\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"bar\")).to_display_str(), ~\"foo\\uFFFDbar\");\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).to_filename_display_str(), Some(~\"bar\"));\n-        assert_eq!(Path::from_vec(b!(\"foo/\", 0xff, \"bar\")).to_filename_display_str(),\n+        assert_eq!(Path::new(\"foo\").to_display_str(), ~\"foo\");\n+        assert_eq!(Path::new(b!(\"foo\", 0x80)).to_display_str(), ~\"foo\\uFFFD\");\n+        assert_eq!(Path::new(b!(\"foo\", 0xff, \"bar\")).to_display_str(), ~\"foo\\uFFFDbar\");\n+        assert_eq!(Path::new(b!(\"foo\", 0xff, \"/bar\")).to_filename_display_str(), Some(~\"bar\"));\n+        assert_eq!(Path::new(b!(\"foo/\", 0xff, \"bar\")).to_filename_display_str(),\n                    Some(~\"\\uFFFDbar\"));\n-        assert_eq!(Path::from_vec(b!(\"/\")).to_filename_display_str(), None);\n+        assert_eq!(Path::new(b!(\"/\")).to_filename_display_str(), None);\n \n         let mut called = false;\n-        do Path::from_str(\"foo\").with_display_str |s| {\n+        do Path::new(\"foo\").with_display_str |s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo\", 0x80)).with_display_str |s| {\n+        do Path::new(b!(\"foo\", 0x80)).with_display_str |s| {\n             assert_eq!(s, \"foo\\uFFFD\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo\", 0xff, \"bar\")).with_display_str |s| {\n+        do Path::new(b!(\"foo\", 0xff, \"bar\")).with_display_str |s| {\n             assert_eq!(s, \"foo\\uFFFDbar\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo\", 0xff, \"/bar\")).with_filename_display_str |s| {\n+        do Path::new(b!(\"foo\", 0xff, \"/bar\")).with_filename_display_str |s| {\n             assert_eq!(s, Some(\"bar\"));\n             called = true;\n         }\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"foo/\", 0xff, \"bar\")).with_filename_display_str |s| {\n+        do Path::new(b!(\"foo/\", 0xff, \"bar\")).with_filename_display_str |s| {\n             assert_eq!(s, Some(\"\\uFFFDbar\"));\n             called = true;\n         }\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"/\")).with_filename_display_str |s| {\n+        do Path::new(b!(\"/\")).with_filename_display_str |s| {\n             assert!(s.is_none());\n             called = true;\n         }\n@@ -816,7 +796,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n                     assert_eq!(f.as_slice(), $exp);\n                     let f = format!(\"{}\", path.filename_display());\n@@ -839,20 +819,20 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), ($exp).as_bytes());\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let left = path.$op().map(|&x| str::from_utf8_slice(x));\n                     assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             );\n@@ -924,10 +904,10 @@ mod tests {\n                 {\n                     let path = ($path);\n                     let join = ($join);\n-                    let mut p1 = Path::from_str(path);\n+                    let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n-                    p1.push_str(join);\n-                    assert_eq!(p1, p2.join_str(join));\n+                    p1.push(join);\n+                    assert_eq!(p1, p2.join(join));\n                 }\n             )\n         )\n@@ -943,8 +923,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_str($path);\n-                    let push = Path::from_str($push);\n+                    let mut p = Path::new($path);\n+                    let push = Path::new($push);\n                     p.push_path(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n@@ -966,14 +946,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_str($path);\n-                    p.push_many_str($push);\n+                    let mut p = Path::new($path);\n+                    p.push_many($push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_vec($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n@@ -997,23 +977,23 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::from_str($path);\n+                    let mut p = Path::new($path);\n                     let file = p.pop_str();\n                     assert_eq!(p.as_str(), Some($left));\n                     assert_eq!(file.map(|s| s.as_slice()), $right);\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n-                    let mut p = Path::from_vec(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n-                    let mut p = Path::from_vec(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n@@ -1036,36 +1016,36 @@ mod tests {\n         t!(s: \"/a\", \"/\", Some(\"a\"));\n         t!(s: \"/\", \"/\", None);\n \n-        assert_eq!(Path::from_vec(b!(\"foo/bar\", 0x80)).pop_str(), None);\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0x80, \"/bar\")).pop_str(), Some(~\"bar\"));\n+        assert_eq!(Path::new(b!(\"foo/bar\", 0x80)).pop_str(), None);\n+        assert_eq!(Path::new(b!(\"foo\", 0x80, \"/bar\")).pop_str(), Some(~\"bar\"));\n     }\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::from_vec(b!(\"a/b/c\")).root_path(), None);\n-        assert_eq!(Path::from_vec(b!(\"/a/b/c\")).root_path(), Some(Path::from_str(\"/\")));\n+        assert_eq!(Path::new(b!(\"a/b/c\")).root_path(), None);\n+        assert_eq!(Path::new(b!(\"/a/b/c\")).root_path(), Some(Path::new(\"/\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::from_vec(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: Path::from_vec(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: Path::from_vec(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n-        t!(s: Path::from_str(\"a/b/c\").join_str(\"..\"), \"a/b\");\n-        t!(s: Path::from_str(\"/a/b/c\").join_str(\"d\"), \"/a/b/c/d\");\n-        t!(s: Path::from_str(\"a/b\").join_str(\"c/d\"), \"a/b/c/d\");\n-        t!(s: Path::from_str(\"a/b\").join_str(\"/c/d\"), \"/c/d\");\n-        t!(s: Path::from_str(\".\").join_str(\"a/b\"), \"a/b\");\n-        t!(s: Path::from_str(\"/\").join_str(\"a/b\"), \"/a/b\");\n+        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n+        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n+        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n+        t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n+        t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n+        t!(s: Path::new(\"a/b\").join(\"/c/d\"), \"/c/d\");\n+        t!(s: Path::new(\".\").join(\"a/b\"), \"a/b\");\n+        t!(s: Path::new(\"/\").join(\"a/b\"), \"/a/b\");\n     }\n \n     #[test]\n     fn test_join_path() {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let join = Path::from_str($join);\n+                    let path = Path::new($path);\n+                    let join = Path::new($join);\n                     let res = path.join_path(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n@@ -1087,14 +1067,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let res = path.join_many_str($join);\n+                    let path = Path::new($path);\n+                    let res = path.join_many($join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n@@ -1114,100 +1094,102 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        t!(v: Path::from_vec(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n-        t!(v: Path::from_vec(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n-        t!(v: Path::from_vec(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n-        t!(v: Path::from_vec(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n+        let empty: &[u8] = [];\n+\n+        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n+        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n+        t!(v: Path::new(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n+        t!(v: Path::new(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n               b!(\"/\", 0xcd, \"/\", 0x80));\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d\"), \"d/c\");\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d/e\"), \"d/e/c\");\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"\"), \"c\");\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"/\"), \"/c\");\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\".\"), \"c\");\n-        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"..\"), \"../c\");\n-        t!(s: Path::from_str(\"/\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: Path::from_str(\"/\").with_dirname_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"/foo\").with_dirname_str(\"bar\"), \"bar/foo\");\n-        t!(s: Path::from_str(\"..\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: Path::from_str(\"../..\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: Path::from_str(\"..\").with_dirname_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"../..\").with_dirname_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"foo\").with_dirname_str(\"..\"), \"../foo\");\n-        t!(s: Path::from_str(\"foo\").with_dirname_str(\"../..\"), \"../../foo\");\n-\n-        t!(v: Path::from_vec(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: Path::from_vec(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: Path::from_vec(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\"d\"), \"d/c\");\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\"d/e\"), \"d/e/c\");\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\"\"), \"c\");\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\"/\"), \"/c\");\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\".\"), \"c\");\n+        t!(s: Path::new(\"a/b/c\").with_dirname(\"..\"), \"../c\");\n+        t!(s: Path::new(\"/\").with_dirname(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"/\").with_dirname(\"\"), \".\");\n+        t!(s: Path::new(\"/foo\").with_dirname(\"bar\"), \"bar/foo\");\n+        t!(s: Path::new(\"..\").with_dirname(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"../..\").with_dirname(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"..\").with_dirname(\"\"), \".\");\n+        t!(s: Path::new(\"../..\").with_dirname(\"\"), \".\");\n+        t!(s: Path::new(\"foo\").with_dirname(\"..\"), \"../foo\");\n+        t!(s: Path::new(\"foo\").with_dirname(\"../..\"), \"../../foo\");\n+\n+        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n+        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n               b!(\"/\", 0xff, \"/\", 0xcd));\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"d\"), \"a/b/d\");\n-        t!(s: Path::from_str(\".\").with_filename_str(\"foo\"), \"foo\");\n-        t!(s: Path::from_str(\"/a/b/c\").with_filename_str(\"d\"), \"/a/b/d\");\n-        t!(s: Path::from_str(\"/\").with_filename_str(\"foo\"), \"/foo\");\n-        t!(s: Path::from_str(\"/a\").with_filename_str(\"foo\"), \"/foo\");\n-        t!(s: Path::from_str(\"foo\").with_filename_str(\"bar\"), \"bar\");\n-        t!(s: Path::from_str(\"/\").with_filename_str(\"foo/\"), \"/foo\");\n-        t!(s: Path::from_str(\"/a\").with_filename_str(\"foo/\"), \"/foo\");\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"\"), \"a/b\");\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\".\"), \"a/b\");\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"..\"), \"a\");\n-        t!(s: Path::from_str(\"/a\").with_filename_str(\"\"), \"/\");\n-        t!(s: Path::from_str(\"foo\").with_filename_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"d/e\"), \"a/b/d/e\");\n-        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"/d\"), \"a/b/d\");\n-        t!(s: Path::from_str(\"..\").with_filename_str(\"foo\"), \"../foo\");\n-        t!(s: Path::from_str(\"../..\").with_filename_str(\"foo\"), \"../../foo\");\n-        t!(s: Path::from_str(\"..\").with_filename_str(\"\"), \"..\");\n-        t!(s: Path::from_str(\"../..\").with_filename_str(\"\"), \"../..\");\n-\n-        t!(v: Path::from_vec(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n+        t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n+        t!(s: Path::new(\"/\").with_filename(\"foo\"), \"/foo\");\n+        t!(s: Path::new(\"/a\").with_filename(\"foo\"), \"/foo\");\n+        t!(s: Path::new(\"foo\").with_filename(\"bar\"), \"bar\");\n+        t!(s: Path::new(\"/\").with_filename(\"foo/\"), \"/foo\");\n+        t!(s: Path::new(\"/a\").with_filename(\"foo/\"), \"/foo\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"\"), \"a/b\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\".\"), \"a/b\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"..\"), \"a\");\n+        t!(s: Path::new(\"/a\").with_filename(\"\"), \"/\");\n+        t!(s: Path::new(\"foo\").with_filename(\"\"), \".\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"d/e\"), \"a/b/d/e\");\n+        t!(s: Path::new(\"a/b/c\").with_filename(\"/d\"), \"a/b/d\");\n+        t!(s: Path::new(\"..\").with_filename(\"foo\"), \"../foo\");\n+        t!(s: Path::new(\"../..\").with_filename(\"foo\"), \"../../foo\");\n+        t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n+        t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n               b!(\"hi/\", 0xff, \".txt\"));\n-        t!(v: Path::from_vec(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n+        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n               b!(\"hi/\", 0xff, \".txt\", 0x80));\n-        t!(v: Path::from_vec(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n-        t!(v: Path::from_vec(b!(\"hi\", 0x80, \"/there\")).with_filestem([]), b!(\"hi\", 0x80));\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"\"), \"hi/.txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\".\"), \"hi/..txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"..\"), \"hi/...txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"/\"), \"hi/.txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"foo/bar\"), \"hi/foo/bar.txt\");\n-        t!(s: Path::from_str(\"hi/there.foo.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n-        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"here\"), \"hi/here\");\n-        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"\"), \"hi\");\n-        t!(s: Path::from_str(\"hi\").with_filestem_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"/hi\").with_filestem_str(\"\"), \"/\");\n-        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"..\"), \".\");\n-        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\".\"), \"hi\");\n-        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"foo\"), \"hi/foo.\");\n-        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"\"), \"hi\");\n-        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\".\"), \".\");\n-        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"..\"), \"hi/...\");\n-        t!(s: Path::from_str(\"/\").with_filestem_str(\"foo\"), \"/foo\");\n-        t!(s: Path::from_str(\".\").with_filestem_str(\"foo\"), \"foo\");\n-        t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"here\"), \"hi/here.\");\n-        t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"\"), \"hi\");\n-\n-        t!(v: Path::from_vec(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n+        t!(v: Path::new(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n+        t!(v: Path::new(b!(\"hi\", 0x80, \"/there\")).with_filestem(empty), b!(\"hi\", 0x80));\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"\"), \"hi/.txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\".\"), \"hi/..txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"..\"), \"hi/...txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"/\"), \"hi/.txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_filestem(\"foo/bar\"), \"hi/foo/bar.txt\");\n+        t!(s: Path::new(\"hi/there.foo.txt\").with_filestem(\"here\"), \"hi/here.txt\");\n+        t!(s: Path::new(\"hi/there\").with_filestem(\"here\"), \"hi/here\");\n+        t!(s: Path::new(\"hi/there\").with_filestem(\"\"), \"hi\");\n+        t!(s: Path::new(\"hi\").with_filestem(\"\"), \".\");\n+        t!(s: Path::new(\"/hi\").with_filestem(\"\"), \"/\");\n+        t!(s: Path::new(\"hi/there\").with_filestem(\"..\"), \".\");\n+        t!(s: Path::new(\"hi/there\").with_filestem(\".\"), \"hi\");\n+        t!(s: Path::new(\"hi/there.\").with_filestem(\"foo\"), \"hi/foo.\");\n+        t!(s: Path::new(\"hi/there.\").with_filestem(\"\"), \"hi\");\n+        t!(s: Path::new(\"hi/there.\").with_filestem(\".\"), \".\");\n+        t!(s: Path::new(\"hi/there.\").with_filestem(\"..\"), \"hi/...\");\n+        t!(s: Path::new(\"/\").with_filestem(\"foo\"), \"/foo\");\n+        t!(s: Path::new(\".\").with_filestem(\"foo\"), \"foo\");\n+        t!(s: Path::new(\"hi/there..\").with_filestem(\"here\"), \"hi/here.\");\n+        t!(s: Path::new(\"hi/there..\").with_filestem(\"\"), \"hi\");\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n               b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: Path::from_vec(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there.\", 0xff));\n-        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n               b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)).with_extension([]), b!(\"hi/there\"));\n-        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"exe\"), \"hi/there.exe\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"\"), \"hi/there\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\".\"), \"hi/there..\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"..\"), \"hi/there...\");\n-        t!(s: Path::from_str(\"hi/there\").with_extension_str(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::from_str(\"hi/there\").with_extension_str(\".\"), \"hi/there..\");\n-        t!(s: Path::from_str(\"hi/there\").with_extension_str(\"..\"), \"hi/there...\");\n-        t!(s: Path::from_str(\"hi/there.\").with_extension_str(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::from_str(\"hi/.foo\").with_extension_str(\"txt\"), \"hi/.foo.txt\");\n-        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\".foo\"), \"hi/there..foo\");\n-        t!(s: Path::from_str(\"/\").with_extension_str(\"txt\"), \"/\");\n-        t!(s: Path::from_str(\"/\").with_extension_str(\".\"), \"/\");\n-        t!(s: Path::from_str(\"/\").with_extension_str(\"..\"), \"/\");\n-        t!(s: Path::from_str(\".\").with_extension_str(\"txt\"), \".\");\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension(empty), b!(\"hi/there\"));\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\"..\"), \"hi/there...\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\".\"), \"hi/there..\");\n+        t!(s: Path::new(\"hi/there\").with_extension(\"..\"), \"hi/there...\");\n+        t!(s: Path::new(\"hi/there.\").with_extension(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::new(\"hi/.foo\").with_extension(\"txt\"), \"hi/.foo.txt\");\n+        t!(s: Path::new(\"hi/there.txt\").with_extension(\".foo\"), \"hi/there..foo\");\n+        t!(s: Path::new(\"/\").with_extension(\"txt\"), \"/\");\n+        t!(s: Path::new(\"/\").with_extension(\".\"), \"/\");\n+        t!(s: Path::new(\"/\").with_extension(\"..\"), \"/\");\n+        t!(s: Path::new(\".\").with_extension(\"txt\"), \".\");\n     }\n \n     #[test]\n@@ -1217,19 +1199,19 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::from_str(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::from_str(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::from_vec(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::from_vec(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n@@ -1238,54 +1220,54 @@ mod tests {\n         t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d\"));\n         t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d/e\"));\n         t!(v: b!(\"a/\", 0x80, \"/c\"), set_dirname, with_dirname, b!(0xff));\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d\");\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d/e\");\n-        t!(s: \"/\", set_dirname_str, with_dirname_str, \"foo\");\n-        t!(s: \"/foo\", set_dirname_str, with_dirname_str, \"bar\");\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"\");\n-        t!(s: \"../..\", set_dirname_str, with_dirname_str, \"x\");\n-        t!(s: \"foo\", set_dirname_str, with_dirname_str, \"../..\");\n+        t!(s: \"a/b/c\", set_dirname, with_dirname, \"d\");\n+        t!(s: \"a/b/c\", set_dirname, with_dirname, \"d/e\");\n+        t!(s: \"/\", set_dirname, with_dirname, \"foo\");\n+        t!(s: \"/foo\", set_dirname, with_dirname, \"bar\");\n+        t!(s: \"a/b/c\", set_dirname, with_dirname, \"\");\n+        t!(s: \"../..\", set_dirname, with_dirname, \"x\");\n+        t!(s: \"foo\", set_dirname, with_dirname, \"../..\");\n \n         t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n         t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n         t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n-        t!(s: \"a/b/c\", set_filename_str, with_filename_str, \"d\");\n-        t!(s: \"/\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \".\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \"a/b\", set_filename_str, with_filename_str, \"\");\n-        t!(s: \"a\", set_filename_str, with_filename_str, \"\");\n+        t!(s: \"a/b/c\", set_filename, with_filename, \"d\");\n+        t!(s: \"/\", set_filename, with_filename, \"foo\");\n+        t!(s: \".\", set_filename, with_filename, \"foo\");\n+        t!(s: \"a/b\", set_filename, with_filename, \"\");\n+        t!(s: \"a\", set_filename, with_filename, \"\");\n \n         t!(v: b!(\"hi/there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n         t!(v: b!(\"hi/there\", 0x80, \".txt\"), set_filestem, with_filestem, b!(\"here\", 0xff));\n-        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there.\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"\");\n-        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"\");\n+        t!(s: \"hi/there.txt\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi/there.\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi/there\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi/there.txt\", set_filestem, with_filestem, \"\");\n+        t!(s: \"hi/there\", set_filestem, with_filestem, \"\");\n \n         t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n         t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n-        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"exe\");\n-        t!(s: \"hi/there.\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n+        t!(s: \"hi/there.\", set_extension, with_extension, \"txt\");\n+        t!(s: \"hi/there\", set_extension, with_extension, \"txt\");\n+        t!(s: \"hi/there.txt\", set_extension, with_extension, \"\");\n+        t!(s: \"hi/there\", set_extension, with_extension, \"\");\n+        t!(s: \".\", set_extension, with_extension, \"txt\");\n     }\n \n     #[test]\n     fn test_add_extension() {\n         macro_rules! t(\n             (s: $path:expr, $ext:expr, $exp:expr) => (\n                 {\n-                    let mut path = Path::from_str($path);\n-                    path.add_extension_str($ext);\n+                    let mut path = Path::new($path);\n+                    path.add_extension($ext);\n                     assert_eq!(path.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $ext:expr, $exp:expr) => (\n                 {\n-                    let mut path = Path::from_vec($path);\n+                    let mut path = Path::new($path);\n                     path.add_extension($ext);\n                     assert_eq!(path.as_vec(), $exp);\n                 }\n@@ -1338,39 +1320,39 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::from_vec(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n-        t!(v: Path::from_vec(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n-        t!(v: Path::from_vec(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n+        t!(v: Path::new(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n+        t!(v: Path::new(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n               Some(b!(\"there\")), Some(b!(0xff)));\n-        t!(s: Path::from_str(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::from_str(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::from_str(\"/\"), None, Some(\"/\"), None, None);\n-        t!(s: Path::from_str(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::from_str(\"../..\"), None, Some(\"../..\"), None, None);\n-        t!(s: Path::from_str(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n+        t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::from_str(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::from_str(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::from_str(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::from_str(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::from_vec(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::from_vec(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::from_vec(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::from_vec(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_file_path() {\n-        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: Path::from_vec(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n-        t!(s: Path::from_str(\"hi/there\").dir_path(), \"hi\");\n-        t!(s: Path::from_str(\"hi\").dir_path(), \".\");\n-        t!(s: Path::from_str(\"/hi\").dir_path(), \"/\");\n-        t!(s: Path::from_str(\"/\").dir_path(), \"/\");\n-        t!(s: Path::from_str(\"..\").dir_path(), \"..\");\n-        t!(s: Path::from_str(\"../..\").dir_path(), \"../..\");\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n+        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n+        t!(s: Path::new(\"hi\").dir_path(), \".\");\n+        t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n+        t!(s: Path::new(\"/\").dir_path(), \"/\");\n+        t!(s: Path::new(\"..\").dir_path(), \"..\");\n+        t!(s: Path::new(\"../..\").dir_path(), \"../..\");\n \n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n@@ -1389,22 +1371,22 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::from_vec(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n-        t!(v: Path::from_vec(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n-        t!(s: Path::from_str(\"hi/there\").file_path(), Some(\"there\"));\n-        t!(s: Path::from_str(\"hi\").file_path(), Some(\"hi\"));\n-        t!(s: Path::from_str(\".\").file_path(), None);\n-        t!(s: Path::from_str(\"/\").file_path(), None);\n-        t!(s: Path::from_str(\"..\").file_path(), None);\n-        t!(s: Path::from_str(\"../..\").file_path(), None);\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n+        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n+        t!(s: Path::new(\"hi/there\").file_path(), Some(\"there\"));\n+        t!(s: Path::new(\"hi\").file_path(), Some(\"hi\"));\n+        t!(s: Path::new(\".\").file_path(), None);\n+        t!(s: Path::new(\"/\").file_path(), None);\n+        t!(s: Path::new(\"..\").file_path(), None);\n+        t!(s: Path::new(\"../..\").file_path(), None);\n     }\n \n     #[test]\n     fn test_is_absolute() {\n         macro_rules! t(\n             (s: $path:expr, $abs:expr, $rel:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.is_absolute(), $abs);\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n@@ -1425,8 +1407,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let dest = Path::from_str($dest);\n+                    let path = Path::new($path);\n+                    let dest = Path::new($dest);\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n@@ -1459,15 +1441,15 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let child = Path::from_str($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n             (v: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n-                    let child = Path::from_vec($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n@@ -1498,8 +1480,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let other = Path::from_str($other);\n+                    let path = Path::new($path);\n+                    let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n                     assert_eq!(res.and_then_ref(|x| x.as_str()), $exp);\n                 }\n@@ -1543,7 +1525,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n@@ -1557,7 +1539,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n-                    let path = Path::from_vec(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n                     assert!(comps.as_slice() == exp, \"component_iter: Expected {:?}, found {:?}\",\n@@ -1592,7 +1574,7 @@ mod tests {\n         macro_rules! t(\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n-                    let path = Path::from_vec(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.str_component_iter().to_owned_vec();\n                     let exp: &[Option<&str>] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -1616,13 +1598,13 @@ mod tests {\n \n     #[test]\n     fn test_each_parent() {\n-        assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));\n-        assert!(!Path::from_str(\"/foo/bar\").each_parent(|_| false));\n+        assert!(Path::new(\"/foo/bar\").each_parent(|_| true));\n+        assert!(!Path::new(\"/foo/bar\").each_parent(|_| false));\n \n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let exp: &[&str] = $exp;\n                     let mut comps = exp.iter().map(|&x|x);\n                     do path.each_parent |p| {\n@@ -1638,7 +1620,7 @@ mod tests {\n             );\n             (v: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     let exp: &[&[u8]] = $exp;\n                     let mut comps = exp.iter().map(|&x|x);\n                     do path.each_parent |p| {"}, {"sha": "cc04261ec6695140b98744b21fa1cc7e07e2a32d", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 396, "deletions": 452, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -22,7 +22,7 @@ use str::{CharSplitIterator, OwnedStr, Str, StrVector};\n use to_bytes::IterBytes;\n use util;\n use vec::Vector;\n-use super::{GenericPath, GenericPathUnsafe};\n+use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n #[cfg(target_os = \"win32\")]\n use libc;\n@@ -97,11 +97,7 @@ impl Eq for Path {\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        if contains_nul(s.as_bytes()) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n-        }\n+        Path::new_opt(s)\n     }\n }\n \n@@ -132,18 +128,8 @@ impl GenericPathUnsafe for Path {\n     ///\n     /// Raises the `str::not_utf8` condition if not valid UTF-8.\n     #[inline]\n-    unsafe fn from_vec_unchecked(path: &[u8]) -> Path {\n-        if !str::is_utf8(path) {\n-            let path = str::from_utf8(path); // triggers not_utf8 condition\n-            GenericPathUnsafe::from_str_unchecked(path)\n-        } else {\n-            GenericPathUnsafe::from_str_unchecked(cast::transmute(path))\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn from_str_unchecked(path: &str) -> Path {\n-        let (prefix, path) = Path::normalize_(path);\n+    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n+        let (prefix, path) = Path::normalize_(path.container_as_str());\n         assert!(!path.is_empty());\n         let mut ret = Path{ repr: path, prefix: prefix, sepidx: None };\n         ret.update_sepidx();\n@@ -155,17 +141,8 @@ impl GenericPathUnsafe for Path {\n     /// # Failure\n     ///\n     /// Raises the `str::not_utf8` condition if not valid UTF-8.\n-    #[inline]\n-    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n-        if !str::is_utf8(dirname) {\n-            let dirname = str::from_utf8(dirname); // triggers not_utf8 condition\n-            self.set_dirname_str_unchecked(dirname);\n-        } else {\n-            self.set_dirname_str_unchecked(cast::transmute(dirname))\n-        }\n-    }\n-\n-    unsafe fn set_dirname_str_unchecked(&mut self, dirname: &str) {\n+    unsafe fn set_dirname_unchecked<T: BytesContainer>(&mut self, dirname: T) {\n+        let dirname = dirname.container_as_str();\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == self.repr || \"..\" == self.repr => {\n                 self.update_normalized(dirname);\n@@ -207,17 +184,8 @@ impl GenericPathUnsafe for Path {\n     /// # Failure\n     ///\n     /// Raises the `str::not_utf8` condition if not valid UTF-8.\n-    #[inline]\n-    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n-        if !str::is_utf8(filename) {\n-            let filename = str::from_utf8(filename); // triggers not_utf8 condition\n-            self.set_filename_str_unchecked(filename)\n-        } else {\n-            self.set_filename_str_unchecked(cast::transmute(filename))\n-        }\n-    }\n-\n-    unsafe fn set_filename_str_unchecked(&mut self, filename: &str) {\n+    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n+        let filename = filename.container_as_str();\n         match self.sepidx_or_prefix_len() {\n             None if \"..\" == self.repr => {\n                 let mut s = str::with_capacity(3 + filename.len());\n@@ -254,20 +222,6 @@ impl GenericPathUnsafe for Path {\n \n     /// See `GenericPathUnsafe::push_unchecked`.\n     ///\n-    /// # Failure\n-    ///\n-    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n-    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n-        if !str::is_utf8(path) {\n-            let path = str::from_utf8(path); // triggers not_utf8 condition\n-            self.push_str_unchecked(path);\n-        } else {\n-            self.push_str_unchecked(cast::transmute(path));\n-        }\n-    }\n-\n-    /// See `GenericPathUnsafe::push_str_unchecked`.\n-    ///\n     /// Concatenating two Windows Paths is rather complicated.\n     /// For the most part, it will behave as expected, except in the case of\n     /// pushing a volume-relative path, e.g. `C:foo.txt`. Because we have no\n@@ -276,7 +230,8 @@ impl GenericPathUnsafe for Path {\n     /// the same volume as the new path, it will be treated as the cwd that\n     /// the new path is relative to. Otherwise, the new path will be treated\n     /// as if it were absolute and will replace the receiver outright.\n-    unsafe fn push_str_unchecked(&mut self, path: &str) {\n+    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n+        let path = path.container_as_str();\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n             let rest = path.slice_from(prefix_len(prefix));\n@@ -357,11 +312,17 @@ impl GenericPathUnsafe for Path {\n \n impl GenericPath for Path {\n     #[inline]\n-    fn from_vec_opt(v: &[u8]) -> Option<Path> {\n-        if contains_nul(v) || !str::is_utf8(v) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n+    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+        let s = path.container_as_str_opt();\n+        match s {\n+            None => None,\n+            Some(s) => {\n+                if contains_nul(s.as_bytes()) {\n+                    None\n+                } else {\n+                    Some(unsafe { GenericPathUnsafe::new_unchecked(s) })\n+                }\n+            }\n         }\n     }\n \n@@ -372,11 +333,23 @@ impl GenericPath for Path {\n         Some(self.repr.as_slice())\n     }\n \n+    /// See `GenericPath::into_str` for info.\n+    /// Always returns a `Some` value.\n+    #[inline]\n+    fn into_str(self) -> Option<~str> {\n+        Some(self.repr)\n+    }\n+\n     #[inline]\n     fn as_vec<'a>(&'a self) -> &'a [u8] {\n         self.repr.as_bytes()\n     }\n \n+    #[inline]\n+    fn into_vec(self) -> ~[u8] {\n+        self.repr.into_bytes()\n+    }\n+\n     #[inline]\n     fn with_display_str<T>(&self, f: &fn(&str) -> T) -> T {\n         f(self.repr.as_slice())\n@@ -448,16 +421,16 @@ impl GenericPath for Path {\n     }\n \n     fn dir_path(&self) -> Path {\n-        unsafe { GenericPathUnsafe::from_str_unchecked(self.dirname_str().unwrap()) }\n+        unsafe { GenericPathUnsafe::new_unchecked(self.dirname_str().unwrap()) }\n     }\n \n     fn file_path(&self) -> Option<Path> {\n-        self.filename_str().map_move(|s| unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n+        self.filename_str().map_move(|s| unsafe { GenericPathUnsafe::new_unchecked(s) })\n     }\n \n     #[inline]\n     fn push_path(&mut self, path: &Path) {\n-        self.push_str(path.as_str().unwrap())\n+        self.push(path.as_str().unwrap())\n     }\n \n     #[inline]\n@@ -494,14 +467,14 @@ impl GenericPath for Path {\n \n     fn root_path(&self) -> Option<Path> {\n         if self.is_absolute() {\n-            Some(Path::from_str(match self.prefix {\n+            Some(Path::new(match self.prefix {\n                 Some(VerbatimDiskPrefix)|Some(DiskPrefix) => {\n                     self.repr.slice_to(self.prefix_len()+1)\n                 }\n                 _ => self.repr.slice_to(self.prefix_len())\n             }))\n         } else if self.is_vol_relative() {\n-            Some(Path::from_str(self.repr.slice_to(1)))\n+            Some(Path::new(self.repr.slice_to(1)))\n         } else {\n             None\n         }\n@@ -631,11 +604,10 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::from_str(comps.connect(\"\\\\\")))\n+            Some(Path::new(comps.connect(\"\\\\\")))\n         }\n     }\n \n-    /// Executes a callback with the receiver and every parent\n     fn each_parent(&self, f: &fn(&Path) -> bool) -> bool {\n         let mut p = self.clone();\n         loop {\n@@ -649,52 +621,39 @@ impl GenericPath for Path {\n         }\n         true\n     }\n+\n+    fn ends_with_path(&self, child: &Path) -> bool {\n+        if !child.is_relative() { return false; }\n+        let mut selfit = self.str_component_iter().invert();\n+        let mut childit = child.str_component_iter().invert();\n+        loop {\n+            match (selfit.next(), childit.next()) {\n+                (Some(a), Some(b)) => if a != b { return false; },\n+                (Some(_), None) => break,\n+                (None, Some(_)) => return false,\n+                (None, None) => break\n+            }\n+        }\n+        true\n+    }\n }\n \n impl Path {\n-    /// Returns a new Path from a byte vector\n+    /// Returns a new Path from a byte vector or string\n     ///\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the vector contains a NUL.\n     /// Raises the `str::not_utf8` condition if invalid UTF-8.\n     #[inline]\n-    pub fn from_vec(v: &[u8]) -> Path {\n-        GenericPath::from_vec(v)\n-    }\n-\n-    /// Returns a new Path from a byte vector, if possible\n-    #[inline]\n-    pub fn from_vec_opt(v: &[u8]) -> Option<Path> {\n-        GenericPath::from_vec_opt(v)\n+    pub fn new<T: BytesContainer>(path: T) -> Path {\n+        GenericPath::new(path)\n     }\n \n-    /// Returns a new Path from a string\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    /// Returns a new Path from a byte vector or string, if possible\n     #[inline]\n-    pub fn from_str(s: &str) -> Path {\n-        GenericPath::from_str(s)\n-    }\n-\n-    /// Returns a new Path from a string, if possible\n-    #[inline]\n-    pub fn from_str_opt(s: &str) -> Option<Path> {\n-        GenericPath::from_str_opt(s)\n-    }\n-\n-    /// Converts the Path into an owned byte vector\n-    pub fn into_vec(self) -> ~[u8] {\n-        self.repr.into_bytes()\n-    }\n-\n-    /// Converts the Path into an owned string\n-    /// Returns an Option for compatibility with posix::Path, but the\n-    /// return value will always be Some.\n-    pub fn into_str(self) -> Option<~str> {\n-        Some(self.repr)\n+    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n+        GenericPath::new_opt(path)\n     }\n \n     /// Returns an iterator that yields each component of the path in turn as a Option<&str>.\n@@ -745,22 +704,6 @@ impl Path {\n         self.rev_str_component_iter().map(convert)\n     }\n \n-    /// Returns whether the relative path `child` is a suffix of `self`.\n-    pub fn ends_with_path(&self, child: &Path) -> bool {\n-        if !child.is_relative() { return false; }\n-        let mut selfit = self.str_component_iter().invert();\n-        let mut childit = child.str_component_iter().invert();\n-        loop {\n-            match (selfit.next(), childit.next()) {\n-                (Some(a), Some(b)) => if a != b { return false; },\n-                (Some(_), None) => break,\n-                (None, Some(_)) => return false,\n-                (None, None) => break\n-            }\n-        }\n-        true\n-    }\n-\n     /// Returns whether the path is considered \"volume-relative\", which means a path\n     /// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n     /// but absolute within that volume.\n@@ -1310,102 +1253,103 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        t!(v: Path::from_vec([]), b!(\".\"));\n-        t!(v: Path::from_vec(b!(\"\\\\\")), b!(\"\\\\\"));\n-        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n-\n-        t!(s: Path::from_str(\"\"), \".\");\n-        t!(s: Path::from_str(\"\\\\\"), \"\\\\\");\n-        t!(s: Path::from_str(\"hi\"), \"hi\");\n-        t!(s: Path::from_str(\"hi\\\\\"), \"hi\");\n-        t!(s: Path::from_str(\"\\\\lib\"), \"\\\\lib\");\n-        t!(s: Path::from_str(\"\\\\lib\\\\\"), \"\\\\lib\");\n-        t!(s: Path::from_str(\"hi\\\\there\"), \"hi\\\\there\");\n-        t!(s: Path::from_str(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n-        t!(s: Path::from_str(\"/\"), \"\\\\\");\n-        t!(s: Path::from_str(\"hi/\"), \"hi\");\n-        t!(s: Path::from_str(\"/lib\"), \"\\\\lib\");\n-        t!(s: Path::from_str(\"/lib/\"), \"\\\\lib\");\n-        t!(s: Path::from_str(\"hi/there\"), \"hi\\\\there\");\n-\n-        t!(s: Path::from_str(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n-        t!(s: Path::from_str(\"hi\\\\..\\\\there\"), \"there\");\n-        t!(s: Path::from_str(\"hi/../there\"), \"there\");\n-        t!(s: Path::from_str(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n-        t!(s: Path::from_str(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::from_str(\"/../hi/there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::from_str(\"foo\\\\..\"), \".\");\n-        t!(s: Path::from_str(\"\\\\foo\\\\..\"), \"\\\\\");\n-        t!(s: Path::from_str(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n-        t!(s: Path::from_str(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n-        t!(s: Path::from_str(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::from_str(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n-        t!(s: Path::from_str(\"foo\\\\..\\\\..\"), \"..\");\n-        t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n-        t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n-\n-        assert_eq!(Path::from_vec(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n-        assert_eq!(Path::from_vec(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n+        let empty: &[u8] = [];\n+        t!(v: Path::new(empty), b!(\".\"));\n+        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+\n+        t!(s: Path::new(\"\"), \".\");\n+        t!(s: Path::new(\"\\\\\"), \"\\\\\");\n+        t!(s: Path::new(\"hi\"), \"hi\");\n+        t!(s: Path::new(\"hi\\\\\"), \"hi\");\n+        t!(s: Path::new(\"\\\\lib\"), \"\\\\lib\");\n+        t!(s: Path::new(\"\\\\lib\\\\\"), \"\\\\lib\");\n+        t!(s: Path::new(\"hi\\\\there\"), \"hi\\\\there\");\n+        t!(s: Path::new(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n+        t!(s: Path::new(\"/\"), \"\\\\\");\n+        t!(s: Path::new(\"hi/\"), \"hi\");\n+        t!(s: Path::new(\"/lib\"), \"\\\\lib\");\n+        t!(s: Path::new(\"/lib/\"), \"\\\\lib\");\n+        t!(s: Path::new(\"hi/there\"), \"hi\\\\there\");\n+\n+        t!(s: Path::new(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n+        t!(s: Path::new(\"hi\\\\..\\\\there\"), \"there\");\n+        t!(s: Path::new(\"hi/../there\"), \"there\");\n+        t!(s: Path::new(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n+        t!(s: Path::new(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"/../hi/there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"foo\\\\..\"), \".\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\"), \"\\\\\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n+        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n+        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\"), \"..\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n+        t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n                    b!(\"\\\\bar\").to_owned());\n-        assert_eq!(Path::from_str(\"foo\\\\bar\").into_str(), Some(~\"foo\\\\bar\"));\n-        assert_eq!(Path::from_str(\"\\\\foo\\\\..\\\\..\\\\bar\").into_str(), Some(~\"\\\\bar\"));\n-\n-        t!(s: Path::from_str(\"\\\\\\\\a\"), \"\\\\a\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n-        t!(s: Path::from_str(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::from_str(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::from_str(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::from_str(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::from_str(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::from_str(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::from_str(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n-        t!(s: Path::from_str(\"C:\\\\\"), \"C:\\\\\");\n-        t!(s: Path::from_str(\"C:\"), \"C:\");\n-        t!(s: Path::from_str(\"q:\"), \"Q:\");\n-        t!(s: Path::from_str(\"C:/\"), \"C:\\\\\");\n-        t!(s: Path::from_str(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n-        t!(s: Path::from_str(\"C:foo\\\\..\"), \"C:\");\n-        t!(s: Path::from_str(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n-        t!(s: Path::from_str(\"C:\\\\a/\"), \"C:\\\\a\");\n-        t!(s: Path::from_str(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::from_str(\"C:a\\\\\"), \"C:a\");\n-        t!(s: Path::from_str(\"C:a/\"), \"C:a\");\n-        t!(s: Path::from_str(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n-        t!(s: Path::from_str(\"C:a\\\\b/\"), \"C:a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n-        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n-        t!(s: Path::from_str(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n-        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n+        assert_eq!(Path::new(\"foo\\\\bar\").into_str(), Some(~\"foo\\\\bar\"));\n+        assert_eq!(Path::new(\"\\\\foo\\\\..\\\\..\\\\bar\").into_str(), Some(~\"\\\\bar\"));\n+\n+        t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n+        t!(s: Path::new(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::new(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::new(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::new(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::new(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"C:\\\\\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:\"), \"C:\");\n+        t!(s: Path::new(\"q:\"), \"Q:\");\n+        t!(s: Path::new(\"C:/\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n+        t!(s: Path::new(\"C:foo\\\\..\"), \"C:\");\n+        t!(s: Path::new(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n+        t!(s: Path::new(\"C:\\\\a/\"), \"C:\\\\a\");\n+        t!(s: Path::new(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::new(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::new(\"C:a\\\\\"), \"C:a\");\n+        t!(s: Path::new(\"C:a/\"), \"C:a\");\n+        t!(s: Path::new(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n+        t!(s: Path::new(\"C:a\\\\b/\"), \"C:a\\\\b\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n+        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n \n         // I'm not sure whether \\\\.\\foo/bar should normalize to \\\\.\\foo\\bar\n         // as information is sparse and this isn't really googleable.\n         // I'm going to err on the side of not normalizing it, as this skips the filesystem\n-        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n-        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n+        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::from_vec_opt(b!(\"foo\\\\bar\", 0)), None);\n-        assert_eq!(Path::from_vec_opt(b!(\"foo\\\\bar\", 0x80)), None);\n-        t!(v: Path::from_vec_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n-        assert_eq!(Path::from_str_opt(\"foo\\\\bar\\0\"), None);\n-        t!(s: Path::from_str_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n+        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0)), None);\n+        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)), None);\n+        t!(v: Path::new_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n+        assert_eq!(Path::new_opt(\"foo\\\\bar\\0\"), None);\n+        t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n \n     #[test]\n@@ -1418,7 +1362,7 @@ mod tests {\n             assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n             (b!(\"\\\\bar\").to_owned())\n         }).inside {\n-            Path::from_vec(b!(\"foo\\\\bar\", 0))\n+            Path::new(b!(\"foo\\\\bar\", 0))\n         };\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n@@ -1478,12 +1422,12 @@ mod tests {\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n-                Path::from_vec(b!(\"foo\\\\bar\", 0))\n+                Path::new(b!(\"foo\\\\bar\", 0))\n             };\n         })\n \n         t!(~\"set_filename w\\\\nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1492,7 +1436,7 @@ mod tests {\n         })\n \n         t!(~\"set_dirname w\\\\nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1501,7 +1445,7 @@ mod tests {\n         })\n \n         t!(~\"push w\\\\nul\" => {\n-            let mut p = Path::from_vec(b!(\"foo\\\\bar\"));\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n             do cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n             }).inside {\n@@ -1513,22 +1457,22 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_not_utf8_fail() {\n-        Path::from_vec(b!(\"hello\", 0x80, \".txt\"));\n+        Path::new(b!(\"hello\", 0x80, \".txt\"));\n     }\n \n     #[test]\n     fn test_display_str() {\n-        assert_eq!(Path::from_str(\"foo\").to_display_str(), ~\"foo\");\n-        assert_eq!(Path::from_vec(b!(\"\\\\\")).to_filename_display_str(), None);\n+        assert_eq!(Path::new(\"foo\").to_display_str(), ~\"foo\");\n+        assert_eq!(Path::new(b!(\"\\\\\")).to_filename_display_str(), None);\n \n         let mut called = false;\n-        do Path::from_str(\"foo\").with_display_str |s| {\n+        do Path::new(\"foo\").with_display_str |s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n         };\n         assert!(called);\n         called = false;\n-        do Path::from_vec(b!(\"\\\\\")).with_filename_display_str |s| {\n+        do Path::new(b!(\"\\\\\")).with_filename_display_str |s| {\n             assert!(s.is_none());\n             called = true;\n         }\n@@ -1540,7 +1484,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n                     assert_eq!(f.as_slice(), $exp);\n                     let f = format!(\"{}\", path.filename_display());\n@@ -1559,20 +1503,20 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let left = path.$op();\n                     assert_eq!(left, $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     assert_eq!(path.$op(), $exp);\n                 }\n             )\n@@ -1681,10 +1625,10 @@ mod tests {\n                 {\n                     let path = ($path);\n                     let join = ($join);\n-                    let mut p1 = Path::from_str(path);\n+                    let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n-                    p1.push_str(join);\n-                    assert_eq!(p1, p2.join_str(join));\n+                    p1.push(join);\n+                    assert_eq!(p1, p2.join(join));\n                 }\n             )\n         )\n@@ -1693,19 +1637,19 @@ mod tests {\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n         t!(s: \"a\\\\b\", \"c\\\\d\");\n         t!(s: \"a\\\\b\", \"\\\\c\\\\d\");\n-        // this is just a sanity-check test. push_str and join_str share an implementation,\n+        // this is just a sanity-check test. push and join share an implementation,\n         // so there's no need for the full set of prefix tests\n \n         // we do want to check one odd case though to ensure the prefix is re-parsed\n-        let mut p = Path::from_str(\"\\\\\\\\?\\\\C:\");\n+        let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n         assert_eq!(p.prefix(), Some(VerbatimPrefix(2)));\n-        p.push_str(\"foo\");\n+        p.push(\"foo\");\n         assert_eq!(p.prefix(), Some(VerbatimDiskPrefix));\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n \n         // and another with verbatim non-normalized paths\n-        let mut p = Path::from_str(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n-        p.push_str(\"foo\");\n+        let mut p = Path::new(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n+        p.push(\"foo\");\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\a\\\\foo\"));\n     }\n \n@@ -1714,8 +1658,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_str($path);\n-                    let push = Path::from_str($push);\n+                    let mut p = Path::new($path);\n+                    let push = Path::new($push);\n                     p.push_path(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n@@ -1766,14 +1710,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_str($path);\n-                    p.push_many_str($push);\n+                    let mut p = Path::new($path);\n+                    p.push_many($push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n-                    let mut p = Path::from_vec($path);\n+                    let mut p = Path::new($path);\n                     p.push_many($push);\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n@@ -1798,7 +1742,7 @@ mod tests {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let pstr = $path;\n-                    let mut p = Path::from_str(pstr);\n+                    let mut p = Path::new(pstr);\n                     let file = p.pop_str();\n                     let left = $left;\n                     assert!(p.as_str() == Some(left),\n@@ -1812,15 +1756,15 @@ mod tests {\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n-                    let mut p = Path::from_vec(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n-                    let mut p = Path::from_vec(b!($($path),+));\n+                    let mut p = Path::new(b!($($path),+));\n                     let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n@@ -1866,28 +1810,28 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::from_str(\"a\\\\b\\\\c\").root_path(), None);\n-        assert_eq!(Path::from_str(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::from_str(\"\\\\\")));\n-        assert_eq!(Path::from_str(\"C:a\").root_path(), None);\n-        assert_eq!(Path::from_str(\"C:\\\\a\").root_path(), Some(Path::from_str(\"C:\\\\\")));\n-        assert_eq!(Path::from_str(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::from_str(\"\\\\\\\\a\\\\b\")));\n-        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::from_str(\"\\\\\\\\?\\\\a\")));\n-        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::from_str(\"\\\\\\\\?\\\\C:\\\\\")));\n-        assert_eq!(Path::from_str(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n-                   Some(Path::from_str(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n-        assert_eq!(Path::from_str(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::from_str(\"\\\\\\\\.\\\\a\")));\n+        assert_eq!(Path::new(\"a\\\\b\\\\c\").root_path(), None);\n+        assert_eq!(Path::new(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\")));\n+        assert_eq!(Path::new(\"C:a\").root_path(), None);\n+        assert_eq!(Path::new(\"C:\\\\a\").root_path(), Some(Path::new(\"C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\\\\a\\\\b\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\a\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n+        assert_eq!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n+                   Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n+        assert_eq!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\.\\\\a\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(s: Path::from_str(\"a\\\\b\\\\c\").join_str(\"..\"), \"a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\a\\\\b\\\\c\").join_str(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::from_str(\"a\\\\b\").join_str(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::from_str(\"a\\\\b\").join_str(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n-        t!(s: Path::from_str(\".\").join_str(\"a\\\\b\"), \"a\\\\b\");\n-        t!(s: Path::from_str(\"\\\\\").join_str(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n-        t!(v: Path::from_vec(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        t!(s: Path::new(\"a\\\\b\\\\c\").join(\"..\"), \"a\\\\b\");\n+        t!(s: Path::new(\"\\\\a\\\\b\\\\c\").join(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::new(\"a\\\\b\").join(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n+        t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n+        t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n+        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1897,8 +1841,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let join = Path::from_str($join);\n+                    let path = Path::new($path);\n+                    let join = Path::new($join);\n                     let res = path.join_path(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n@@ -1922,14 +1866,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let res = path.join_many_str($join);\n+                    let path = Path::new($path);\n+                    let res = path.join_many($join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_vec($path);\n+                    let path = Path::new($path);\n                     let res = path.join_many($join);\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n@@ -1953,7 +1897,7 @@ mod tests {\n             (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n                 {\n                     let pstr = $path;\n-                    let path = Path::from_str(pstr);\n+                    let path = Path::new(pstr);\n                     let arg = $arg;\n                     let res = path.$op(arg);\n                     let exp = $res;\n@@ -1963,137 +1907,137 @@ mod tests {\n                 }\n             )\n         )\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"d\", \"d\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"d\\\\e\", \"d\\\\e\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"\", \"c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"\\\\\", \"\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"/\", \"\\\\c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \".\", \"c\");\n-        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"..\", \"..\\\\c\");\n-        t!(s: \"\\\\\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \"\\\\\", with_dirname_str, \"\", \".\");\n-        t!(s: \"\\\\foo\", with_dirname_str, \"bar\", \"bar\\\\foo\");\n-        t!(s: \"..\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \"..\\\\..\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \"..\", with_dirname_str, \"\", \".\");\n-        t!(s: \"..\\\\..\", with_dirname_str, \"\", \".\");\n-        t!(s: \".\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \"foo\", with_dirname_str, \"..\", \"..\\\\foo\");\n-        t!(s: \"foo\", with_dirname_str, \"..\\\\..\", \"..\\\\..\\\\foo\");\n-        t!(s: \"C:\\\\a\\\\b\", with_dirname_str, \"foo\", \"foo\\\\b\");\n-        t!(s: \"foo\", with_dirname_str, \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\foo\");\n-        t!(s: \"C:a\\\\b\", with_dirname_str, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\b\");\n-        t!(s: \"a\", with_dirname_str, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\a\");\n-        t!(s: \"a\\\\b\", with_dirname_str, \"\\\\\\\\?\\\\\", \"\\\\\\\\?\\\\b\");\n-        t!(s: \"a\\\\b\", with_dirname_str, \"C:\", \"C:b\");\n-        t!(s: \"a\\\\b\", with_dirname_str, \"C:\\\\\", \"C:\\\\b\");\n-        t!(s: \"a\\\\b\", with_dirname_str, \"C:/\", \"C:\\\\b\");\n-        t!(s: \"C:\\\\\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \"C:\", with_dirname_str, \"foo\", \"foo\");\n-        t!(s: \".\", with_dirname_str, \"C:\\\\\", \"C:\\\\\");\n-        t!(s: \".\", with_dirname_str, \"C:/\", \"C:\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_dirname_str, \"C:\\\\\", \"C:\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_dirname_str, \"bar\", \"bar\");\n-        t!(s: \"foo\\\\bar\", with_dirname_str, \"\\\\\\\\?\\\\C:\\\\baz\", \"\\\\\\\\?\\\\C:\\\\baz\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\foo\", with_dirname_str, \"C:\\\\bar\", \"C:\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\a\\\\foo\", with_dirname_str, \"C:\\\\bar\", \"C:\\\\bar\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\a\\\\foo/bar\", with_dirname_str, \"C:\\\\baz\", \"C:\\\\baz\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\", with_dirname_str, \"a\", \"a\\\\baz\");\n-        t!(s: \"foo\\\\bar\", with_dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\",\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"d\", \"d\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"d\\\\e\", \"d\\\\e\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"\", \"c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"\\\\\", \"\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"/\", \"\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \".\", \"c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname, \"..\", \"..\\\\c\");\n+        t!(s: \"\\\\\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \"\\\\\", with_dirname, \"\", \".\");\n+        t!(s: \"\\\\foo\", with_dirname, \"bar\", \"bar\\\\foo\");\n+        t!(s: \"..\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \"..\\\\..\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \"..\", with_dirname, \"\", \".\");\n+        t!(s: \"..\\\\..\", with_dirname, \"\", \".\");\n+        t!(s: \".\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \"foo\", with_dirname, \"..\", \"..\\\\foo\");\n+        t!(s: \"foo\", with_dirname, \"..\\\\..\", \"..\\\\..\\\\foo\");\n+        t!(s: \"C:\\\\a\\\\b\", with_dirname, \"foo\", \"foo\\\\b\");\n+        t!(s: \"foo\", with_dirname, \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\foo\");\n+        t!(s: \"C:a\\\\b\", with_dirname, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\b\");\n+        t!(s: \"a\", with_dirname, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\a\");\n+        t!(s: \"a\\\\b\", with_dirname, \"\\\\\\\\?\\\\\", \"\\\\\\\\?\\\\b\");\n+        t!(s: \"a\\\\b\", with_dirname, \"C:\", \"C:b\");\n+        t!(s: \"a\\\\b\", with_dirname, \"C:\\\\\", \"C:\\\\b\");\n+        t!(s: \"a\\\\b\", with_dirname, \"C:/\", \"C:\\\\b\");\n+        t!(s: \"C:\\\\\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \"C:\", with_dirname, \"foo\", \"foo\");\n+        t!(s: \".\", with_dirname, \"C:\\\\\", \"C:\\\\\");\n+        t!(s: \".\", with_dirname, \"C:/\", \"C:\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_dirname, \"C:\\\\\", \"C:\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_dirname, \"bar\", \"bar\");\n+        t!(s: \"foo\\\\bar\", with_dirname, \"\\\\\\\\?\\\\C:\\\\baz\", \"\\\\\\\\?\\\\C:\\\\baz\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\foo\", with_dirname, \"C:\\\\bar\", \"C:\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\foo\", with_dirname, \"C:\\\\bar\", \"C:\\\\bar\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\foo/bar\", with_dirname, \"C:\\\\baz\", \"C:\\\\baz\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\", with_dirname, \"a\", \"a\\\\baz\");\n+        t!(s: \"foo\\\\bar\", with_dirname, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\",\n               \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", with_dirname_str, \"bar\", \"bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz\", \"baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz\\\\\", \"baz\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz/\", \"baz\\\\bar\");\n-\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"d\", \"a\\\\b\\\\d\");\n-        t!(s: \".\", with_filename_str, \"foo\", \"foo\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", with_filename_str, \"d\", \"\\\\a\\\\b\\\\d\");\n-        t!(s: \"\\\\\", with_filename_str, \"foo\", \"\\\\foo\");\n-        t!(s: \"\\\\a\", with_filename_str, \"foo\", \"\\\\foo\");\n-        t!(s: \"foo\", with_filename_str, \"bar\", \"bar\");\n-        t!(s: \"\\\\\", with_filename_str, \"foo\\\\\", \"\\\\foo\");\n-        t!(s: \"\\\\a\", with_filename_str, \"foo\\\\\", \"\\\\foo\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"\", \"a\\\\b\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \".\", \"a\\\\b\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"..\", \"a\");\n-        t!(s: \"\\\\a\", with_filename_str, \"\", \"\\\\\");\n-        t!(s: \"foo\", with_filename_str, \"\", \".\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"d\\\\e\", \"a\\\\b\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"\\\\d\", \"a\\\\b\\\\d\");\n-        t!(s: \"..\", with_filename_str, \"foo\", \"..\\\\foo\");\n-        t!(s: \"..\\\\..\", with_filename_str, \"foo\", \"..\\\\..\\\\foo\");\n-        t!(s: \"..\", with_filename_str, \"\", \"..\");\n-        t!(s: \"..\\\\..\", with_filename_str, \"\", \"..\\\\..\");\n-        t!(s: \"C:\\\\foo\\\\bar\", with_filename_str, \"baz\", \"C:\\\\foo\\\\baz\");\n-        t!(s: \"C:\\\\foo\", with_filename_str, \"bar\", \"C:\\\\bar\");\n-        t!(s: \"C:\\\\\", with_filename_str, \"foo\", \"C:\\\\foo\");\n-        t!(s: \"C:foo\\\\bar\", with_filename_str, \"baz\", \"C:foo\\\\baz\");\n-        t!(s: \"C:foo\", with_filename_str, \"bar\", \"C:bar\");\n-        t!(s: \"C:\", with_filename_str, \"foo\", \"C:foo\");\n-        t!(s: \"C:\\\\foo\", with_filename_str, \"\", \"C:\\\\\");\n-        t!(s: \"C:foo\", with_filename_str, \"\", \"C:\");\n-        t!(s: \"C:\\\\foo\\\\bar\", with_filename_str, \"..\", \"C:\\\\\");\n-        t!(s: \"C:\\\\foo\", with_filename_str, \"..\", \"C:\\\\\");\n-        t!(s: \"C:\\\\\", with_filename_str, \"..\", \"C:\\\\\");\n-        t!(s: \"C:foo\\\\bar\", with_filename_str, \"..\", \"C:\");\n-        t!(s: \"C:foo\", with_filename_str, \"..\", \"C:..\");\n-        t!(s: \"C:\", with_filename_str, \"..\", \"C:..\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"foo\", \"\\\\\\\\server\\\\share\\\\foo\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"..\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"..\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\?\\\\C:\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_filename_str, \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename_str, \"..\", \"\\\\\\\\?\\\\C:\\\\..\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\?\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\?\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\?\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\\", with_filename_str, \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename_str, \"..\", \"\\\\\\\\?\\\\foo\\\\..\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\.\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\.\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename_str, \"..\", \"\\\\\\\\.\\\\foo\\\\..\");\n-\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"here\", \"hi\\\\here.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"\", \"hi\\\\.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \".\", \"hi\\\\..txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"..\", \"hi\\\\...txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"\\\\\", \"hi\\\\.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"foo\\\\bar\", \"hi\\\\foo\\\\bar.txt\");\n-        t!(s: \"hi\\\\there.foo.txt\", with_filestem_str, \"here\", \"hi\\\\here.txt\");\n-        t!(s: \"hi\\\\there\", with_filestem_str, \"here\", \"hi\\\\here\");\n-        t!(s: \"hi\\\\there\", with_filestem_str, \"\", \"hi\");\n-        t!(s: \"hi\", with_filestem_str, \"\", \".\");\n-        t!(s: \"\\\\hi\", with_filestem_str, \"\", \"\\\\\");\n-        t!(s: \"hi\\\\there\", with_filestem_str, \"..\", \".\");\n-        t!(s: \"hi\\\\there\", with_filestem_str, \".\", \"hi\");\n-        t!(s: \"hi\\\\there.\", with_filestem_str, \"foo\", \"hi\\\\foo.\");\n-        t!(s: \"hi\\\\there.\", with_filestem_str, \"\", \"hi\");\n-        t!(s: \"hi\\\\there.\", with_filestem_str, \".\", \".\");\n-        t!(s: \"hi\\\\there.\", with_filestem_str, \"..\", \"hi\\\\...\");\n-        t!(s: \"\\\\\", with_filestem_str, \"foo\", \"\\\\foo\");\n-        t!(s: \".\", with_filestem_str, \"foo\", \"foo\");\n-        t!(s: \"hi\\\\there..\", with_filestem_str, \"here\", \"hi\\\\here.\");\n-        t!(s: \"hi\\\\there..\", with_filestem_str, \"\", \"hi\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", with_dirname, \"bar\", \"bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz\", \"baz\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz\\\\\", \"baz\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname, \"baz/\", \"baz\\\\bar\");\n+\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n+        t!(s: \".\", with_filename, \"foo\", \"foo\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", with_filename, \"d\", \"\\\\a\\\\b\\\\d\");\n+        t!(s: \"\\\\\", with_filename, \"foo\", \"\\\\foo\");\n+        t!(s: \"\\\\a\", with_filename, \"foo\", \"\\\\foo\");\n+        t!(s: \"foo\", with_filename, \"bar\", \"bar\");\n+        t!(s: \"\\\\\", with_filename, \"foo\\\\\", \"\\\\foo\");\n+        t!(s: \"\\\\a\", with_filename, \"foo\\\\\", \"\\\\foo\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \"\", \"a\\\\b\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \".\", \"a\\\\b\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \"..\", \"a\");\n+        t!(s: \"\\\\a\", with_filename, \"\", \"\\\\\");\n+        t!(s: \"foo\", with_filename, \"\", \".\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \"d\\\\e\", \"a\\\\b\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename, \"\\\\d\", \"a\\\\b\\\\d\");\n+        t!(s: \"..\", with_filename, \"foo\", \"..\\\\foo\");\n+        t!(s: \"..\\\\..\", with_filename, \"foo\", \"..\\\\..\\\\foo\");\n+        t!(s: \"..\", with_filename, \"\", \"..\");\n+        t!(s: \"..\\\\..\", with_filename, \"\", \"..\\\\..\");\n+        t!(s: \"C:\\\\foo\\\\bar\", with_filename, \"baz\", \"C:\\\\foo\\\\baz\");\n+        t!(s: \"C:\\\\foo\", with_filename, \"bar\", \"C:\\\\bar\");\n+        t!(s: \"C:\\\\\", with_filename, \"foo\", \"C:\\\\foo\");\n+        t!(s: \"C:foo\\\\bar\", with_filename, \"baz\", \"C:foo\\\\baz\");\n+        t!(s: \"C:foo\", with_filename, \"bar\", \"C:bar\");\n+        t!(s: \"C:\", with_filename, \"foo\", \"C:foo\");\n+        t!(s: \"C:\\\\foo\", with_filename, \"\", \"C:\\\\\");\n+        t!(s: \"C:foo\", with_filename, \"\", \"C:\");\n+        t!(s: \"C:\\\\foo\\\\bar\", with_filename, \"..\", \"C:\\\\\");\n+        t!(s: \"C:\\\\foo\", with_filename, \"..\", \"C:\\\\\");\n+        t!(s: \"C:\\\\\", with_filename, \"..\", \"C:\\\\\");\n+        t!(s: \"C:foo\\\\bar\", with_filename, \"..\", \"C:\");\n+        t!(s: \"C:foo\", with_filename, \"..\", \"C:..\");\n+        t!(s: \"C:\", with_filename, \"..\", \"C:..\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"foo\", \"\\\\\\\\server\\\\share\\\\foo\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"..\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"..\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename, \"bar\", \"\\\\\\\\?\\\\C:\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_filename, \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename, \"..\", \"\\\\\\\\?\\\\C:\\\\..\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\?\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\?\\\\foo\", with_filename, \"bar\", \"\\\\\\\\?\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\\", with_filename, \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename, \"..\", \"\\\\\\\\?\\\\foo\\\\..\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\.\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", with_filename, \"bar\", \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename, \"..\", \"\\\\\\\\.\\\\foo\\\\..\");\n+\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \"here\", \"hi\\\\here.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \"\", \"hi\\\\.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \".\", \"hi\\\\..txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \"..\", \"hi\\\\...txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \"\\\\\", \"hi\\\\.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem, \"foo\\\\bar\", \"hi\\\\foo\\\\bar.txt\");\n+        t!(s: \"hi\\\\there.foo.txt\", with_filestem, \"here\", \"hi\\\\here.txt\");\n+        t!(s: \"hi\\\\there\", with_filestem, \"here\", \"hi\\\\here\");\n+        t!(s: \"hi\\\\there\", with_filestem, \"\", \"hi\");\n+        t!(s: \"hi\", with_filestem, \"\", \".\");\n+        t!(s: \"\\\\hi\", with_filestem, \"\", \"\\\\\");\n+        t!(s: \"hi\\\\there\", with_filestem, \"..\", \".\");\n+        t!(s: \"hi\\\\there\", with_filestem, \".\", \"hi\");\n+        t!(s: \"hi\\\\there.\", with_filestem, \"foo\", \"hi\\\\foo.\");\n+        t!(s: \"hi\\\\there.\", with_filestem, \"\", \"hi\");\n+        t!(s: \"hi\\\\there.\", with_filestem, \".\", \".\");\n+        t!(s: \"hi\\\\there.\", with_filestem, \"..\", \"hi\\\\...\");\n+        t!(s: \"\\\\\", with_filestem, \"foo\", \"\\\\foo\");\n+        t!(s: \".\", with_filestem, \"foo\", \"foo\");\n+        t!(s: \"hi\\\\there..\", with_filestem, \"here\", \"hi\\\\here.\");\n+        t!(s: \"hi\\\\there..\", with_filestem, \"\", \"hi\");\n         // filestem setter calls filename setter internally, no need for extended tests\n \n-        t!(s: \"hi\\\\there.txt\", with_extension_str, \"exe\", \"hi\\\\there.exe\");\n-        t!(s: \"hi\\\\there.txt\", with_extension_str, \"\", \"hi\\\\there\");\n-        t!(s: \"hi\\\\there.txt\", with_extension_str, \".\", \"hi\\\\there..\");\n-        t!(s: \"hi\\\\there.txt\", with_extension_str, \"..\", \"hi\\\\there...\");\n-        t!(s: \"hi\\\\there\", with_extension_str, \"txt\", \"hi\\\\there.txt\");\n-        t!(s: \"hi\\\\there\", with_extension_str, \".\", \"hi\\\\there..\");\n-        t!(s: \"hi\\\\there\", with_extension_str, \"..\", \"hi\\\\there...\");\n-        t!(s: \"hi\\\\there.\", with_extension_str, \"txt\", \"hi\\\\there.txt\");\n-        t!(s: \"hi\\\\.foo\", with_extension_str, \"txt\", \"hi\\\\.foo.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_extension_str, \".foo\", \"hi\\\\there..foo\");\n-        t!(s: \"\\\\\", with_extension_str, \"txt\", \"\\\\\");\n-        t!(s: \"\\\\\", with_extension_str, \".\", \"\\\\\");\n-        t!(s: \"\\\\\", with_extension_str, \"..\", \"\\\\\");\n-        t!(s: \".\", with_extension_str, \"txt\", \".\");\n+        t!(s: \"hi\\\\there.txt\", with_extension, \"exe\", \"hi\\\\there.exe\");\n+        t!(s: \"hi\\\\there.txt\", with_extension, \"\", \"hi\\\\there\");\n+        t!(s: \"hi\\\\there.txt\", with_extension, \".\", \"hi\\\\there..\");\n+        t!(s: \"hi\\\\there.txt\", with_extension, \"..\", \"hi\\\\there...\");\n+        t!(s: \"hi\\\\there\", with_extension, \"txt\", \"hi\\\\there.txt\");\n+        t!(s: \"hi\\\\there\", with_extension, \".\", \"hi\\\\there..\");\n+        t!(s: \"hi\\\\there\", with_extension, \"..\", \"hi\\\\there...\");\n+        t!(s: \"hi\\\\there.\", with_extension, \"txt\", \"hi\\\\there.txt\");\n+        t!(s: \"hi\\\\.foo\", with_extension, \"txt\", \"hi\\\\.foo.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_extension, \".foo\", \"hi\\\\there..foo\");\n+        t!(s: \"\\\\\", with_extension, \"txt\", \"\\\\\");\n+        t!(s: \"\\\\\", with_extension, \".\", \"\\\\\");\n+        t!(s: \"\\\\\", with_extension, \"..\", \"\\\\\");\n+        t!(s: \".\", with_extension, \"txt\", \".\");\n         // extension setter calls filename setter internally, no need for extended tests\n     }\n \n@@ -2104,56 +2048,56 @@ mod tests {\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::from_str(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::from_str(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n                     let arg = $arg;\n-                    let mut p1 = Path::from_vec(path);\n+                    let mut p1 = Path::new(path);\n                     p1.$set(arg);\n-                    let p2 = Path::from_vec(path);\n+                    let p2 = Path::new(path);\n                     assert_eq!(p1, p2.$with(arg));\n                 }\n             )\n         )\n \n         t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\\\\e\"));\n-        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"d\");\n-        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"d\\\\e\");\n-        t!(s: \"\\\\\", set_dirname_str, with_dirname_str, \"foo\");\n-        t!(s: \"\\\\foo\", set_dirname_str, with_dirname_str, \"bar\");\n-        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"\");\n-        t!(s: \"..\\\\..\", set_dirname_str, with_dirname_str, \"x\");\n-        t!(s: \"foo\", set_dirname_str, with_dirname_str, \"..\\\\..\");\n+        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"d\");\n+        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"d\\\\e\");\n+        t!(s: \"\\\\\", set_dirname, with_dirname, \"foo\");\n+        t!(s: \"\\\\foo\", set_dirname, with_dirname, \"bar\");\n+        t!(s: \"a\\\\b\\\\c\", set_dirname, with_dirname, \"\");\n+        t!(s: \"..\\\\..\", set_dirname, with_dirname, \"x\");\n+        t!(s: \"foo\", set_dirname, with_dirname, \"..\\\\..\");\n \n         t!(v: b!(\"a\\\\b\\\\c\"), set_filename, with_filename, b!(\"d\"));\n         t!(v: b!(\"\\\\\"), set_filename, with_filename, b!(\"foo\"));\n-        t!(s: \"a\\\\b\\\\c\", set_filename_str, with_filename_str, \"d\");\n-        t!(s: \"\\\\\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \".\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \"a\\\\b\", set_filename_str, with_filename_str, \"\");\n-        t!(s: \"a\", set_filename_str, with_filename_str, \"\");\n+        t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n+        t!(s: \"\\\\\", set_filename, with_filename, \"foo\");\n+        t!(s: \".\", set_filename, with_filename, \"foo\");\n+        t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n+        t!(s: \"a\", set_filename, with_filename, \"\");\n \n         t!(v: b!(\"hi\\\\there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n-        t!(s: \"hi\\\\there.txt\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi\\\\there.\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi\\\\there\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi\\\\there.txt\", set_filestem_str, with_filestem_str, \"\");\n-        t!(s: \"hi\\\\there\", set_filestem_str, with_filestem_str, \"\");\n+        t!(s: \"hi\\\\there.txt\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi\\\\there.\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi\\\\there\", set_filestem, with_filestem, \"here\");\n+        t!(s: \"hi\\\\there.txt\", set_filestem, with_filestem, \"\");\n+        t!(s: \"hi\\\\there\", set_filestem, with_filestem, \"\");\n \n         t!(v: b!(\"hi\\\\there.txt\"), set_extension, with_extension, b!(\"exe\"));\n-        t!(s: \"hi\\\\there.txt\", set_extension_str, with_extension_str, \"exe\");\n-        t!(s: \"hi\\\\there.\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi\\\\there\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi\\\\there.txt\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \"hi\\\\there\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n+        t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n+        t!(s: \"hi\\\\there\", set_extension, with_extension, \"txt\");\n+        t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"\");\n+        t!(s: \"hi\\\\there\", set_extension, with_extension, \"\");\n+        t!(s: \".\", set_extension, with_extension, \"txt\");\n \n         // with_ helpers use the setter internally, so the tests for the with_ helpers\n         // will suffice. No need for the full set of prefix tests.\n@@ -2164,14 +2108,14 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $ext:expr, $exp:expr) => (\n                 {\n-                    let mut path = Path::from_str($path);\n-                    path.add_extension_str($ext);\n+                    let mut path = Path::new($path);\n+                    path.add_extension($ext);\n                     assert_eq!(path.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $ext:expr, $exp:expr) => (\n                 {\n-                    let mut path = Path::from_vec($path);\n+                    let mut path = Path::new($path);\n                     path.add_extension($ext);\n                     assert_eq!(path.as_vec(), $exp);\n                 }\n@@ -2221,32 +2165,32 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::from_vec(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n-        t!(s: Path::from_str(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::from_str(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::from_str(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n-        t!(s: Path::from_str(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::from_str(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n-        t!(s: Path::from_str(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n+        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n+        t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::from_str(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::from_str(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::from_str(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::from_str(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n+        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n \n         // these are already tested in test_components, so no need for extended tests\n     }\n \n     #[test]\n     fn test_dir_file_path() {\n-        t!(s: Path::from_str(\"hi\\\\there\").dir_path(), \"hi\");\n-        t!(s: Path::from_str(\"hi\").dir_path(), \".\");\n-        t!(s: Path::from_str(\"\\\\hi\").dir_path(), \"\\\\\");\n-        t!(s: Path::from_str(\"\\\\\").dir_path(), \"\\\\\");\n-        t!(s: Path::from_str(\"..\").dir_path(), \"..\");\n-        t!(s: Path::from_str(\"..\\\\..\").dir_path(), \"..\\\\..\");\n+        t!(s: Path::new(\"hi\\\\there\").dir_path(), \"hi\");\n+        t!(s: Path::new(\"hi\").dir_path(), \".\");\n+        t!(s: Path::new(\"\\\\hi\").dir_path(), \"\\\\\");\n+        t!(s: Path::new(\"\\\\\").dir_path(), \"\\\\\");\n+        t!(s: Path::new(\"..\").dir_path(), \"..\");\n+        t!(s: Path::new(\"..\\\\..\").dir_path(), \"..\\\\..\");\n \n         macro_rules! t(\n             ($path:expr, $exp:expr) => (\n@@ -2258,12 +2202,12 @@ mod tests {\n             );\n         )\n \n-        t!(Path::from_str(\"hi\\\\there\").file_path(), Some(\"there\"));\n-        t!(Path::from_str(\"hi\").file_path(), Some(\"hi\"));\n-        t!(Path::from_str(\".\").file_path(), None);\n-        t!(Path::from_str(\"\\\\\").file_path(), None);\n-        t!(Path::from_str(\"..\").file_path(), None);\n-        t!(Path::from_str(\"..\\\\..\").file_path(), None);\n+        t!(Path::new(\"hi\\\\there\").file_path(), Some(\"there\"));\n+        t!(Path::new(\"hi\").file_path(), Some(\"hi\"));\n+        t!(Path::new(\".\").file_path(), None);\n+        t!(Path::new(\"\\\\\").file_path(), None);\n+        t!(Path::new(\"..\").file_path(), None);\n+        t!(Path::new(\"..\\\\..\").file_path(), None);\n \n         // dir_path and file_path are just dirname and filename interpreted as paths.\n         // No need for extended tests\n@@ -2274,7 +2218,7 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n                     let b = path.is_absolute();\n                     assert!(b == abs, \"Path '{}'.is_absolute(): expected {:?}, found {:?}\",\n@@ -2314,8 +2258,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let dest = Path::from_str($dest);\n+                    let path = Path::new($path);\n+                    let dest = Path::new($dest);\n                     let exp = $exp;\n                     let res = path.is_ancestor_of(&dest);\n                     assert!(res == exp,\n@@ -2417,8 +2361,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let child = Path::from_str($child);\n+                    let path = Path::new($path);\n+                    let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n@@ -2449,8 +2393,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n-                    let other = Path::from_str($other);\n+                    let path = Path::new($path);\n+                    let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n                     let exp = $exp;\n                     assert!(res.and_then_ref(|x| x.as_str()) == exp,\n@@ -2583,7 +2527,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -2598,7 +2542,7 @@ mod tests {\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n-                    let path = Path::from_vec(b!($($arg),+));\n+                    let path = Path::new(b!($($arg),+));\n                     let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n@@ -2658,7 +2602,7 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let comps = path.component_iter().to_owned_vec();\n                     let exp: &[&[u8]] = $exp;\n                     assert!(comps.as_slice() == exp, \"component_iter: Expected {:?}, found {:?}\",\n@@ -2679,13 +2623,13 @@ mod tests {\n \n     #[test]\n     fn test_each_parent() {\n-        assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));\n-        assert!(!Path::from_str(\"/foo/bar\").each_parent(|_| false));\n+        assert!(Path::new(\"/foo/bar\").each_parent(|_| true));\n+        assert!(!Path::new(\"/foo/bar\").each_parent(|_| false));\n \n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n-                    let path = Path::from_str($path);\n+                    let path = Path::new($path);\n                     let exp: &[&str] = $exp;\n                     let mut comps = exp.iter().map(|&x|x);\n                     do path.each_parent |p| {"}, {"sha": "39c3c5692f8a2ca67bbc30ab74cc19dec43ce702", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -703,7 +703,7 @@ mod test {\n     fn file_test_io_smoke_test() {\n         do run_in_mt_newsched_task {\n             let message = \"it's alright. have a good time\";\n-            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test.txt\");\n+            let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n             {\n                 let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n                 write_stream.write(message.as_bytes());\n@@ -725,7 +725,7 @@ mod test {\n     #[test]\n     fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path::from_str(\"./tmp/file_that_does_not_exist.txt\");\n+            let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n             let mut called = false;\n             do io_error::cond.trap(|_| {\n                 called = true;\n@@ -740,7 +740,7 @@ mod test {\n     #[test]\n     fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path::from_str(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+            let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n             let mut called = false;\n             do io_error::cond.trap(|_| {\n                 called = true;\n@@ -757,7 +757,7 @@ mod test {\n             use str;\n             let message = \"ten-four\";\n             let mut read_mem = [0, .. 8];\n-            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_positional.txt\");\n+            let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(message.as_bytes());\n@@ -788,7 +788,7 @@ mod test {\n             let set_cursor = 4 as u64;\n             let mut tell_pos_pre_read;\n             let mut tell_pos_post_read;\n-            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(message.as_bytes());\n@@ -817,7 +817,7 @@ mod test {\n             let final_msg =     \"foo-the-bar!!\";\n             let seek_idx = 3;\n             let mut read_mem = [0, .. 13];\n-            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(initial_msg.as_bytes());\n@@ -843,7 +843,7 @@ mod test {\n             let chunk_two = \"asdf\";\n             let chunk_three = \"zxcv\";\n             let mut read_mem = [0, .. 4];\n-            let filename = &Path::from_str(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n             {\n                 let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n                 rw_stream.write(initial_msg.as_bytes());\n@@ -873,7 +873,7 @@ mod test {\n     #[test]\n     fn file_test_stat_is_correct_on_is_file() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path::from_str(\"./tmp/file_stat_correct_on_is_file.txt\");\n+            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n             {\n                 let mut fs = open(filename, Create, ReadWrite).unwrap();\n                 let msg = \"hw\";\n@@ -891,7 +891,7 @@ mod test {\n     #[test]\n     fn file_test_stat_is_correct_on_is_dir() {\n         do run_in_mt_newsched_task {\n-            let filename = &Path::from_str(\"./tmp/file_stat_correct_on_is_dir\");\n+            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n             mkdir(filename);\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n@@ -905,7 +905,7 @@ mod test {\n     #[test]\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         do run_in_mt_newsched_task {\n-            let dir = &Path::from_str(\"./tmp/fileinfo_false_on_dir\");\n+            let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n             mkdir(dir);\n             assert!(dir.is_file() == false);\n             rmdir(dir);\n@@ -915,7 +915,7 @@ mod test {\n     #[test]\n     fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         do run_in_mt_newsched_task {\n-            let file = &Path::from_str(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+            let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n             {\n                 let msg = \"foo\".as_bytes();\n                 let mut w = file.open_writer(Create);\n@@ -930,7 +930,7 @@ mod test {\n     #[test]\n     fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         do run_in_mt_newsched_task {\n-            let dir = &Path::from_str(\"./tmp/before_and_after_dir\");\n+            let dir = &Path::new(\"./tmp/before_and_after_dir\");\n             assert!(!dir.exists());\n             dir.mkdir();\n             assert!(dir.exists());\n@@ -944,11 +944,11 @@ mod test {\n     fn file_test_directoryinfo_readdir() {\n         use str;\n         do run_in_mt_newsched_task {\n-            let dir = &Path::from_str(\"./tmp/di_readdir\");\n+            let dir = &Path::new(\"./tmp/di_readdir\");\n             dir.mkdir();\n             let prefix = \"foo\";\n             for n in range(0,3) {\n-                let f = dir.join_str(format!(\"{}.txt\", n));\n+                let f = dir.join(format!(\"{}.txt\", n));\n                 let mut w = f.open_writer(Create);\n                 let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n                 let msg = msg_str.as_bytes();"}, {"sha": "31040bc51a135ec47a7d3e2a32e557e7c55bf40d", "filename": "src/libstd/rt/io/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsupport.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -35,7 +35,7 @@ mod test {\n     #[test]\n     fn path_like_smoke_test() {\n         let expected = if cfg!(unix) { \"/home\" } else { \"C:\\\\\" };\n-        let path = Path::from_str(expected);\n+        let path = Path::new(expected);\n         path.path_as_str(|p| assert!(p == expected));\n         path.path_as_str(|p| assert!(p == expected));\n     }"}, {"sha": "cb5054626d4c494f0a3424d7bfa174c1f1a38326", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -391,7 +391,7 @@ mod test {\n             let read_mem = vec::from_elem(read_buf_len, 0u8);\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n-            let p = Path::from_str(path_str);\n+            let p = Path::new(path_str);\n             let open_req = FsRequest::new();\n             do open_req.open(&loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n@@ -405,7 +405,7 @@ mod test {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &Path::from_str(path_str), read_flags as int,0)\n+                        do open_req.open(&loop_, &Path::new(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n@@ -431,7 +431,7 @@ mod test {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n                                         let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_, &Path::from_str(path_str))\n+                                        do unlink_req.unlink(loop_, &Path::new(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -465,7 +465,7 @@ mod test {\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::from_str(path_str),\n+            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let fd = result.unwrap();\n@@ -479,7 +479,7 @@ mod test {\n             assert!(result.is_ok());\n             // re-open\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::from_str(path_str),\n+            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n@@ -503,7 +503,7 @@ mod test {\n                 assert!(result.is_ok());\n                 // unlink\n                 let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &Path::from_str(path_str));\n+                let result = unlink_req.unlink_sync(&loop_, &Path::new(path_str));\n                 assert!(result.is_ok());\n             } else { fail2!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();"}, {"sha": "d5893d6d014145d1663b201248d139d991cd4b44", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -18,6 +18,7 @@ use ops::Drop;\n use option::*;\n use ptr;\n use str;\n+use str::Str;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -631,7 +632,7 @@ impl IoFactory for UvIoFactory {\n                         None => {\n                             let stat = req.get_stat();\n                             Ok(FileStat {\n-                                path: Path::from_str(path_str),\n+                                path: Path::new(path_str.as_slice()),\n                                 is_file: stat.is_file(),\n                                 is_dir: stat.is_dir(),\n                                 size: stat.st_size,\n@@ -720,8 +721,8 @@ impl IoFactory for UvIoFactory {\n                             let rel_paths = req.get_paths();\n                             let mut paths = ~[];\n                             for r in rel_paths.iter() {\n-                                let mut p = Path::from_str(path_str);\n-                                p.push_str(*r);\n+                                let mut p = Path::new(path_str.as_slice());\n+                                p.push(r.as_slice());\n                                 paths.push(p);\n                             }\n                             Ok(paths)\n@@ -2179,20 +2180,20 @@ fn file_test_uvio_full_simple_impl() {\n         {\n             let create_fm = Create;\n             let create_fa = ReadWrite;\n-            let mut fd = (*io).fs_open(&Path::from_str(path), create_fm, create_fa).unwrap();\n+            let mut fd = (*io).fs_open(&Path::new(path), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n             let ro_fm = Open;\n             let ro_fa = Read;\n-            let mut fd = (*io).fs_open(&Path::from_str(path), ro_fm, ro_fa).unwrap();\n+            let mut fd = (*io).fs_open(&Path::new(path), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(&Path::from_str(path));\n+        (*io).fs_unlink(&Path::new(path));\n     }\n }\n "}, {"sha": "0d32efbba883de67179e66ca3899a4eff2943038", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -579,7 +579,7 @@ mod tests {\n \n         let output = str::from_utf8(prog.finish_with_output().output);\n         let parent_dir = os::getcwd();\n-        let child_dir = Path::from_str(output.trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -596,7 +596,7 @@ mod tests {\n         let mut prog = run_pwd(Some(&parent_dir));\n \n         let output = str::from_utf8(prog.finish_with_output().output);\n-        let child_dir = Path::from_str(output.trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();"}, {"sha": "58ff51fe102bdc0c1988a807103378cfcf71d5f2", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -121,7 +121,7 @@ mod test {\n     fn test_errors_do_not_crash() {\n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n-        let path = GenericPath::from_str(\"/dev/null\");\n+        let path = GenericPath::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n             Ok(_) => fail2!(\"Successfully opened the empty library.\")"}, {"sha": "c7ac3e1da9efe9ade33e3adaedeb553e927547f7", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -81,15 +81,15 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n-        &res_rel_file(cx, sp, &Path::from_str(file)), sp);\n+        &res_rel_file(cx, sp, &Path::new(file)), sp);\n     base::MRExpr(p.parse_expr())\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n-    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path::from_str(file)));\n+    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path::new(file)));\n     match res {\n       result::Ok(res) => {\n           base::MRExpr(cx.expr_str(sp, res.to_managed()))\n@@ -103,7 +103,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n-    match io::read_whole_file(&res_rel_file(cx, sp, &Path::from_str(file))) {\n+    match io::read_whole_file(&res_rel_file(cx, sp, &Path::new(file))) {\n       result::Ok(src) => {\n         let u8_exprs: ~[@ast::Expr] = src.iter().map(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n@@ -145,7 +145,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let mut cu = Path::from_str(cx.codemap().span_to_filename(sp));\n+        let mut cu = Path::new(cx.codemap().span_to_filename(sp));\n         cu.pop();\n         cu.push_path(arg);\n         cu"}, {"sha": "32cd45c86cb2ade6ddd8d5deb5fbbeeeeef1440f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -3992,20 +3992,20 @@ impl Parser {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {\n-        let mut prefix = Path::from_str(self.sess.cm.span_to_filename(*self.span));\n+        let mut prefix = Path::new(self.sess.cm.span_to_filename(*self.span));\n         prefix.pop();\n         let mod_path_stack = &*self.mod_path_stack;\n-        let mod_path = Path::from_str(\".\").join_many_str(*mod_path_stack);\n+        let mod_path = Path::new(\".\").join_many(*mod_path_stack);\n         let dir_path = prefix.join_path(&mod_path);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n-            Some(d) => dir_path.join_str(d),\n+            Some(d) => dir_path.join(d),\n             None => {\n                 let mod_name = token::interner_get(id.name).to_owned();\n                 let default_path_str = mod_name + \".rs\";\n                 let secondary_path_str = mod_name + \"/mod.rs\";\n-                let default_path = dir_path.join_str(default_path_str);\n-                let secondary_path = dir_path.join_str(secondary_path_str);\n+                let default_path = dir_path.join(default_path_str.as_slice());\n+                let secondary_path = dir_path.join(secondary_path_str.as_slice());\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n                 match (default_exists, secondary_exists) {"}, {"sha": "6ce289620fb79846d02fedf1f9c9bc14e0f3e4cf", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -73,8 +73,8 @@ fn read_line() {\n     use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n \n-    let path = Path::from_str(env!(\"CFG_SRC_DIR\"))\n-        .join_str(\"src/test/bench/shootout-k-nucleotide.data\");\n+    let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n+    path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {\n         let mut reader = BufferedReader::new(path.open_reader(Open).unwrap());"}, {"sha": "77c3a0e39835f1f66068fd46d9b3a03ce68938bd", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -122,7 +122,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        io::file_writer(&Path::from_str(\"./shootout-fasta.data\"),\n+        io::file_writer(&Path::new(\"./shootout-fasta.data\"),\n                         [io::Truncate, io::Create]).unwrap()\n     } else {\n         io::stdout()"}, {"sha": "c0464dcc676c88799ac2152e18e06d65aa4c93ca", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -164,8 +164,8 @@ fn main() {\n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         // FIXME: Using this compile-time env variable is a crummy way to\n         // get to this massive data set, but include_bin! chokes on it (#2598)\n-        let path = Path::from_str(env!(\"CFG_SRC_DIR\"))\n-            .join_str(\"src/test/bench/shootout-k-nucleotide.data\");\n+        let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n+        path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n         ~path.open_reader(Open).unwrap() as ~Reader\n     } else {\n         ~stdio::stdin() as ~Reader"}, {"sha": "c86a438344adc66e60bca35f8670a24f3a4f385a", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -20,14 +20,14 @@ use std::{io, os, unstable};\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            os::make_dir(&Path::from_str(path), 0xFFFF);\n+            os::make_dir(&Path::new(path), 0xFFFF);\n         } else {\n-            io::mk_file_writer(&Path::from_str(path), [io::Create]);\n+            io::mk_file_writer(&Path::new(path), [io::Create]);\n         }\n     }\n \n     fn abs_path(path: &str) -> Path {\n-        os::getcwd().join_path(&Path::from_str(path))\n+        os::getcwd().join_path(&Path::new(path))\n     }\n \n     fn glob_vec(pattern: &str) -> ~[Path] {"}, {"sha": "f860426ffd270a44bfa44805a8493abf3e3bea45", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -23,7 +23,7 @@ fn tester()\n {\n     let loader: rsrc_loader = |_path| {result::Ok(~\"more blah\")};\n \n-    let path = path::Path::from_str(\"blah\");\n+    let path = path::Path::new(\"blah\");\n     assert!(loader(&path).is_ok());\n }\n "}, {"sha": "76a1d32705b2da1d1e1f25dcf40a3105c5acda1e", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -25,9 +25,9 @@ fn rename_directory() {\n \n         let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n-        let old_path = tmpdir.join_many_str([\"foo\", \"bar\", \"baz\"]);\n+        let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n         assert!(os::mkdir_recursive(&old_path, U_RWX));\n-        let test_file = &old_path.join_str(\"temp.txt\");\n+        let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n         let ostream = do test_file.with_c_str |fromp| {\n@@ -46,11 +46,11 @@ fn rename_directory() {\n         }\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n-        let new_path = tmpdir.join_many_str([\"quux\", \"blat\"]);\n+        let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n         assert!(os::mkdir_recursive(&new_path, U_RWX));\n-        assert!(os::rename_file(&old_path, &new_path.join_str(\"newdir\")));\n-        assert!(os::path_is_dir(&new_path.join_str(\"newdir\")));\n-        assert!(os::path_exists(&new_path.join_many_str([\"newdir\", \"temp.txt\"])));\n+        assert!(os::rename_file(&old_path, &new_path.join(\"newdir\")));\n+        assert!(os::path_is_dir(&new_path.join(\"newdir\")));\n+        assert!(os::path_exists(&new_path.join_many([\"newdir\", \"temp.txt\"])));\n     }\n }\n "}, {"sha": "aa0661d49a2193f592f8c7f6877653687bc15f9c", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -18,8 +18,8 @@ use std::io;\n use std::os;\n \n pub fn main() {\n-    let dir = tempfile::TempDir::new_in(&Path::from_str(\".\"), \"\").unwrap();\n-    let path = dir.path().join_str(\"file\");\n+    let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n+    let path = dir.path().join(\"file\");\n \n     {\n         match io::file_writer(&path, [io::Create, io::Truncate]) {"}, {"sha": "837194fcf9f07d68846c1808261155c0c60579e7", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=d6d9b926836b1f1c2b8b3fe4ab35dc63bec7ffcd", "patch": "@@ -28,7 +28,7 @@ use std::cell::Cell;\n \n fn test_tempdir() {\n     let path = {\n-        let p = TempDir::new_in(&Path::from_str(\".\"), \"foobar\").unwrap();\n+        let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n         assert!(ends_with(p.as_vec(), bytes!(\"foobar\")));\n         p.clone()\n@@ -84,7 +84,7 @@ fn test_rm_tempdir() {\n // Ideally these would be in std::os but then core would need\n // to depend on std\n fn recursive_mkdir_rel() {\n-    let path = Path::from_str(\"frob\");\n+    let path = Path::new(\"frob\");\n     let cwd = os::getcwd();\n     debug2!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), os::path_exists(&path));\n@@ -95,21 +95,21 @@ fn recursive_mkdir_rel() {\n }\n \n fn recursive_mkdir_dot() {\n-    let dot = Path::from_str(\".\");\n+    let dot = Path::new(\".\");\n     assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    let dotdot = Path::from_str(\"..\");\n+    let dotdot = Path::new(\"..\");\n     assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n }\n \n fn recursive_mkdir_rel_2() {\n-    let path = Path::from_str(\"./frob/baz\");\n+    let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), os::path_exists(&path));\n     assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n         assert!(os::path_is_dir(&path));\n     assert!(os::path_is_dir(&path.dir_path()));\n-    let path2 = Path::from_str(\"quux/blat\");\n+    let path2 = Path::new(\"quux/blat\");\n     debug2!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n     assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n@@ -124,17 +124,17 @@ pub fn test_rmdir_recursive_ok() {\n     let tmpdir = TempDir::new(\"test\").expect(\"test_rmdir_recursive_ok: \\\n                                               couldn't create temp dir\");\n     let tmpdir = tmpdir.path();\n-    let root = tmpdir.join_str(\"foo\");\n+    let root = tmpdir.join(\"foo\");\n \n     debug2!(\"making {}\", root.display());\n     assert!(os::make_dir(&root, rwx));\n-    assert!(os::make_dir(&root.join_str(\"foo\"), rwx));\n-    assert!(os::make_dir(&root.join_str(\"foo\").join_str(\"bar\"), rwx));\n-    assert!(os::make_dir(&root.join_str(\"foo\").join_str(\"bar\").join_str(\"blat\"), rwx));\n+    assert!(os::make_dir(&root.join(\"foo\"), rwx));\n+    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\"), rwx));\n+    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx));\n     assert!(os::remove_dir_recursive(&root));\n     assert!(!os::path_exists(&root));\n-    assert!(!os::path_exists(&root.join_str(\"bar\")));\n-    assert!(!os::path_exists(&root.join_str(\"bar\").join_str(\"blat\")));\n+    assert!(!os::path_exists(&root.join(\"bar\")));\n+    assert!(!os::path_exists(&root.join(\"bar\").join(\"blat\")));\n }\n \n fn in_tmpdir(f: &fn()) {"}]}