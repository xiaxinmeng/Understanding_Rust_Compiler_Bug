{"sha": "9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMzJhZDBkZDUxZjg0NTFhYTZlMzlkN2U5ZWE4OTQ4M2NiOGZjZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-16T14:41:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-16T14:41:13Z"}, "message": "Auto merge of #63470 - Mark-Simulacrum:rustc-depdep, r=alexcrichton\n\nUtilize -Zbinary-dep-depinfo in rustbuild\n\nWe no longer utilize stamp-file mtimes at all inside rustbuild, and a future PR may be able to entirely eliminate them by eagerly copying to the appropriate sysroot. The only mtime-based dependency tracking left is for documentation because we lie to Cargo about the rustdoc binary, so Cargo does not track changes to the real binary, and codegen-backends because binary-dep-depinfo does not emit that information into the depfiles.\n\nBoth of these are fixable in the longer term but this existing patch gives us the following benefits:\n * We no longer delete Cargo target directories manually within a stage. Cross-stage, changes to codegen backends will still clear out target directories. This means that incremental state persists across individual steps (e.g., rebuilding libstd does not clear out librustc incremental state). Fixes #54712.\n * Dependency tracking across steps within a given stage is now fully precise. We will not clear out all codegen backend dependencies due to changes in librustc_driver, for example, only deleting the final librustc_codegen_llvm crate. Fixes #54008, fixes #50481.\n * We properly track codegen backends as a dependency (equivalent to rustc) across changes. Fixes #53284, and fixes #52719.\n * Cross-stage dependency tracking of crates is also much more accurate and reliable. Most likely fixes #49979 (but no reproduction steps in that issue). Fixes #59105.\n\ncc #63012", "tree": {"sha": "136e58fdab1fc37eed681cd2a8ccf1566701a7e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/136e58fdab1fc37eed681cd2a8ccf1566701a7e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "html_url": "https://github.com/rust-lang/rust/commit/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dd5c191993aab6c2f1538eb8ab69afdc4b6e67a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd5c191993aab6c2f1538eb8ab69afdc4b6e67a", "html_url": "https://github.com/rust-lang/rust/commit/9dd5c191993aab6c2f1538eb8ab69afdc4b6e67a"}, {"sha": "417f9ea90cf9bcccd8a1fa569a11a4fc071e3b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/417f9ea90cf9bcccd8a1fa569a11a4fc071e3b8c", "html_url": "https://github.com/rust-lang/rust/commit/417f9ea90cf9bcccd8a1fa569a11a4fc071e3b8c"}], "stats": {"total": 123, "additions": 23, "deletions": 100}, "files": [{"sha": "f0054c36c0c886da0ea0f22d27c03c57cd56cccd", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 22, "deletions": 65, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "patch": "@@ -754,76 +754,20 @@ impl<'a> Builder<'a> {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n \n-        // command specific path, we call clear_if_dirty with this\n-        let mut my_out = match cmd {\n-            \"build\" => self.cargo_out(compiler, mode, target),\n-\n-            // This is the intended out directory for crate documentation.\n-            \"doc\" | \"rustdoc\" =>  self.crate_doc_out(target),\n-\n-            _ => self.stage_out(compiler, mode),\n-        };\n-\n-        // This is for the original compiler, but if we're forced to use stage 1, then\n-        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n-        // we copy the libs forward.\n-        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n-\n-        let libstd_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n-        };\n-\n-        let libtest_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::libtest_stamp(self, cmp, target),\n-            _ => compile::libtest_stamp(self, cmp, target),\n-        };\n-\n-        let librustc_stamp = match cmd {\n-            \"check\" | \"clippy\" | \"fix\" => check::librustc_stamp(self, cmp, target),\n-            _ => compile::librustc_stamp(self, cmp, target),\n-        };\n+        // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n+        // so we need to explicitly clear out if they've been updated.\n+        for backend in self.codegen_backends(compiler) {\n+            self.clear_if_dirty(&out_dir, &backend);\n+        }\n \n         if cmd == \"doc\" || cmd == \"rustdoc\" {\n-            if mode == Mode::Rustc || mode == Mode::ToolRustc || mode == Mode::Codegen {\n+            let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n-                my_out = self.compiler_doc_out(target);\n-            }\n+                Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n+                _ => self.crate_doc_out(target),\n+            };\n             let rustdoc = self.rustdoc(compiler);\n             self.clear_if_dirty(&my_out, &rustdoc);\n-        } else if cmd != \"test\" {\n-            match mode {\n-                Mode::Std => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    for backend in self.codegen_backends(compiler) {\n-                        self.clear_if_dirty(&my_out, &backend);\n-                    }\n-                },\n-                Mode::Test => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::Rustc => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::Codegen => {\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-                Mode::ToolBootstrap => { },\n-                Mode::ToolStd => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::ToolTest => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::ToolRustc => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-            }\n         }\n \n         cargo\n@@ -861,6 +805,19 @@ impl<'a> Builder<'a> {\n             },\n         }\n \n+        // This tells Cargo (and in turn, rustc) to output more complete\n+        // dependency information.  Most importantly for rustbuild, this\n+        // includes sysroot artifacts, like libstd, which means that we don't\n+        // need to track those in rustbuild (an error prone process!). This\n+        // feature is currently unstable as there may be some bugs and such, but\n+        // it represents a big improvement in rustbuild's reliability on\n+        // rebuilds, so we're using it here.\n+        //\n+        // For some additional context, see #63470 (the PR originally adding\n+        // this), as well as #63012 which is the tracking issue for this\n+        // feature on the rustc side.\n+        cargo.arg(\"-Zbinary-dep-depinfo\");\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");"}, {"sha": "6e6fea6b831a7507f3835fa21c3032d6f9459b71", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "patch": "@@ -245,7 +245,6 @@ impl Step for Rustdoc {\n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n         add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-        builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n "}, {"sha": "12eb2c882ad1affb281e56d979947b5f0cfbe9fc", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9a32ad0dd51f8451aa6e39d7e9ea89483cb8fcfa", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, t, up_to_date};\n+use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n use serde_json;\n@@ -274,8 +274,6 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n-\n-        builder.cargo(target_compiler, Mode::ToolStd, target, \"clean\");\n     }\n }\n \n@@ -480,8 +478,6 @@ impl Step for TestLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &libtest_stamp(builder, compiler, target)\n         );\n-\n-        builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n }\n \n@@ -639,7 +635,6 @@ impl Step for RustcLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &librustc_stamp(builder, compiler, target)\n         );\n-        builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n \n@@ -1202,41 +1197,13 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n-    // Now we want to update the contents of the stamp file, if necessary. First\n-    // we read off the previous contents along with its mtime. If our new\n-    // contents (the list of files to copy) is different or if any dep's mtime\n-    // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let stamp_contents = fs::read(stamp);\n-    let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n-    let mut max = None;\n-    let mut max_path = None;\n     for (dep, proc_macro) in deps.iter() {\n-        let mtime = mtime(dep);\n-        if Some(mtime) > max {\n-            max = Some(mtime);\n-            max_path = Some(dep.clone());\n-        }\n         new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n-    let max = max.unwrap();\n-    let max_path = max_path.unwrap();\n-    let contents_equal = stamp_contents\n-        .map(|contents| contents == new_contents)\n-        .unwrap_or_default();\n-    if contents_equal && max <= stamp_mtime {\n-        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n-                stamp, max, stamp_mtime));\n-        return deps.into_iter().map(|(d, _)| d).collect()\n-    }\n-    if max > stamp_mtime {\n-        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n-    } else {\n-        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n-    }\n     t!(fs::write(&stamp, &new_contents));\n     deps.into_iter().map(|(d, _)| d).collect()\n }"}]}