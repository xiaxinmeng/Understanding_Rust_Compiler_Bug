{"sha": "fe9babbaede1643ddc10cd34140a58d0107db1ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOWJhYmJhZWRlMTY0M2RkYzEwY2QzNDE0MGE1OGQwMTA3ZGIxZWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-22T23:34:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-22T23:34:36Z"}, "message": "Rollup merge of #73783 - estebank:impl-dyn-trait-static-lifetime, r=nikomatsakis\n\nDetect when `'static` obligation might come from an `impl`\n\nPartly address #71341.", "tree": {"sha": "6f7d2211c6282f29b02c132e30a59dee472a5382", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f7d2211c6282f29b02c132e30a59dee472a5382"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe9babbaede1643ddc10cd34140a58d0107db1ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGM0MCRBK7hj4Ov3rIwAAdHIIAKJ/ovzOlvCYqLTO8QAOzW/c\ncBXHG0i8vhsBazEamkXYYxjESN6Hmmg2a8JYRLSczgHFkbTNfufWp/cOakZ9bzkl\nbC5pbjclsDhbF7yCmCqCVFWohtjhnbHwxFnJH/I3lFpksJhNuAsLb6EVswHQ9m1+\njmZ2b27BCKvrNlSPWxbsSL5kN65Ngr4J/BzbaOaN9UEDOzRkFF1TUw3RPclHOv7R\nz9oT+asZCbmMpfNwUuUyhx3Pw8WfK2ov3xlmgxOaceny1SojN4lPXbkPSBAuq1xP\nL6wSKSl4u6T/2u7eXjOMjtWWSAVunWz+ayJPkHHu2ujisSIbPjcpTe/aaJE/u7k=\n=psAb\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f7d2211c6282f29b02c132e30a59dee472a5382\nparent bbebe7351fcd29af1eb9a35e315369b15887ea09\nparent 889a4d9a0baf06497106eb705143e379c180bd70\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595460876 -0700\ncommitter GitHub <noreply@github.com> 1595460876 -0700\n\nRollup merge of #73783 - estebank:impl-dyn-trait-static-lifetime, r=nikomatsakis\n\nDetect when `'static` obligation might come from an `impl`\n\nPartly address #71341.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9babbaede1643ddc10cd34140a58d0107db1ec", "html_url": "https://github.com/rust-lang/rust/commit/fe9babbaede1643ddc10cd34140a58d0107db1ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe9babbaede1643ddc10cd34140a58d0107db1ec/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbebe7351fcd29af1eb9a35e315369b15887ea09", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbebe7351fcd29af1eb9a35e315369b15887ea09", "html_url": "https://github.com/rust-lang/rust/commit/bbebe7351fcd29af1eb9a35e315369b15887ea09"}, {"sha": "889a4d9a0baf06497106eb705143e379c180bd70", "url": "https://api.github.com/repos/rust-lang/rust/commits/889a4d9a0baf06497106eb705143e379c180bd70", "html_url": "https://github.com/rust-lang/rust/commit/889a4d9a0baf06497106eb705143e379c180bd70"}], "stats": {"total": 1740, "additions": 1301, "deletions": 439}, "files": [{"sha": "72302962d8603a240718f9ae4dea124d34a5eab0", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -633,4 +633,5 @@ E0771: include_str!(\"./error_codes/E0771.md\"),\n     E0755, // `#[ffi_pure]` is only allowed on foreign functions\n     E0756, // `#[ffi_const]` is only allowed on foreign functions\n     E0757, // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n+    E0772, // `'static' obligation coming from `impl dyn Trait {}` or `impl Foo for dyn Bar {}`.\n }"}, {"sha": "6474dc318d329f73854c2c0526b8f075589c7f0b", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -2198,7 +2198,17 @@ pub enum IsAsync {\n     NotAsync,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    PartialEq,\n+    RustcEncodable,\n+    RustcDecodable,\n+    Debug,\n+    HashStable_Generic,\n+    Eq,\n+    Hash\n+)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,"}, {"sha": "c63464e5baec9e3b1a71409ad0402cc1a710684e", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -36,12 +36,13 @@ use crate::traits::{Obligation, PredicateObligations};\n \n use rustc_ast::ast;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'tcx> {\n@@ -367,10 +368,11 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         };\n \n         debug!(\"generalize: for_universe = {:?}\", for_universe);\n+        debug!(\"generalize: trace = {:?}\", self.trace);\n \n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n-            span: self.trace.cause.span,\n+            cause: &self.trace.cause,\n             for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n@@ -414,7 +416,7 @@ struct Generalizer<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n     /// The span, used when creating new type variables and things.\n-    span: Span,\n+    cause: &'cx ObligationCause<'tcx>,\n \n     /// The vid of the type variable that is in the process of being\n     /// instantiated; if we find this within the type we are folding,\n@@ -639,7 +641,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         // FIXME: This is non-ideal because we don't give a\n         // very descriptive origin for this region variable.\n-        Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.span), self.for_universe))\n+        Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.cause.span), self.for_universe))\n     }\n \n     fn consts("}, {"sha": "ff905faa95a9fe627e85e4b433c303218f5ef493", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -2010,7 +2010,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::MiscVariable(_) => String::new(),\n             infer::PatternRegion(_) => \" for pattern\".to_string(),\n             infer::AddrOfRegion(_) => \" for borrow expression\".to_string(),\n-            infer::Autoref(_) => \" for autoref\".to_string(),\n+            infer::Autoref(_, _) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n                 format!(\" for lifetime parameter {}in function call\", br_string(br))"}, {"sha": "4fa6d9d2394242cb56b69ad0ad19f5b3e4b4e745", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 474, "deletions": 197, "changes": 671, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -2,227 +2,504 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n-use rustc_hir::{GenericBound, ItemKind, Lifetime, LifetimeName, TyKind};\n-use rustc_middle::ty::RegionKind;\n+use crate::infer::{SubregionOrigin, TypeTrace};\n+use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{\n+    self as hir, GenericBound, ImplItem, Item, ItemKind, Lifetime, LifetimeName, Node, TraitItem,\n+    TyKind,\n+};\n+use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{MultiSpan, Span};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// Print the error message for lifetime errors when the return type is a static impl Trait.\n+    /// Print the error message for lifetime errors when the return type is a static `impl Trait`,\n+    /// `dyn Trait` or if a method call on a trait object introduces a static requirement.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n-        if let Some(RegionResolutionError::SubSupConflict(\n-            _,\n-            var_origin,\n-            ref sub_origin,\n-            sub_r,\n-            ref sup_origin,\n-            sup_r,\n-        )) = self.error\n-        {\n-            debug!(\n-                \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n-                var_origin, sub_origin, sub_r, sup_origin, sup_r\n-            );\n-            let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-            debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-            let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n-            if fn_returns.is_empty() {\n+        let tcx = self.tcx();\n+        let (var_origin, sub_origin, sub_r, sup_origin, sup_r) = match self.error.as_ref()? {\n+            RegionResolutionError::SubSupConflict(\n+                _,\n+                var_origin,\n+                sub_origin,\n+                sub_r,\n+                sup_origin,\n+                sup_r,\n+            ) if **sub_r == RegionKind::ReStatic => {\n+                (var_origin, sub_origin, sub_r, sup_origin, sup_r)\n+            }\n+            RegionResolutionError::ConcreteFailure(\n+                SubregionOrigin::Subtype(box TypeTrace { cause, .. }),\n+                sub_r,\n+                sup_r,\n+            ) if **sub_r == RegionKind::ReStatic => {\n+                // This is for an implicit `'static` requirement coming from `impl dyn Trait {}`.\n+                if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+                    let param = self.find_param_with_region(sup_r, sub_r)?;\n+                    let lifetime = if sup_r.has_name() {\n+                        format!(\"lifetime `{}`\", sup_r)\n+                    } else {\n+                        \"an anonymous lifetime `'_`\".to_string()\n+                    };\n+                    let mut err = struct_span_err!(\n+                        tcx.sess,\n+                        cause.span,\n+                        E0772,\n+                        \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n+                         requirement\",\n+                        param\n+                            .param\n+                            .pat\n+                            .simple_ident()\n+                            .map(|s| format!(\"`{}`\", s))\n+                            .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n+                        lifetime,\n+                        ctxt.assoc_item.ident,\n+                    );\n+                    err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n+                    err.span_label(\n+                        cause.span,\n+                        &format!(\n+                            \"...is captured and required to live as long as `'static` here \\\n+                             because of an implicit lifetime bound on the {}\",\n+                            match ctxt.assoc_item.container {\n+                                AssocItemContainer::TraitContainer(id) =>\n+                                    format!(\"`impl` of `{}`\", tcx.def_path_str(id)),\n+                                AssocItemContainer::ImplContainer(_) =>\n+                                    \"inherent `impl`\".to_string(),\n+                            },\n+                        ),\n+                    );\n+                    if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n+                        err.emit();\n+                        return Some(ErrorReported);\n+                    } else {\n+                        err.cancel();\n+                    }\n+                }\n                 return None;\n             }\n-            debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-            if *sub_r == RegionKind::ReStatic {\n-                let sp = var_origin.span();\n-                let return_sp = sub_origin.span();\n-                let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                let (lifetime_name, lifetime) = if sup_r.has_name() {\n-                    (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-                } else {\n-                    (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-                };\n-                let mut err = struct_span_err!(\n-                    self.tcx().sess,\n-                    sp,\n-                    E0759,\n-                    \"cannot infer an appropriate lifetime\"\n-                );\n+            _ => return None,\n+        };\n+        debug!(\n+            \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+            var_origin, sub_origin, sub_r, sup_origin, sup_r\n+        );\n+        let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n+        debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+        let sp = var_origin.span();\n+        let return_sp = sub_origin.span();\n+        let param = self.find_param_with_region(sup_r, sub_r)?;\n+        let (lifetime_name, lifetime) = if sup_r.has_name() {\n+            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+        } else {\n+            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+        };\n+        let param_name = param\n+            .param\n+            .pat\n+            .simple_ident()\n+            .map(|s| format!(\"`{}`\", s))\n+            .unwrap_or_else(|| \"`fn` parameter\".to_string());\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            sp,\n+            E0759,\n+            \"{} has {} but it needs to satisfy a `'static` lifetime requirement\",\n+            param_name,\n+            lifetime,\n+        );\n+        err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n+        debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n+\n+        // We try to make the output have fewer overlapping spans if possible.\n+        if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+            && sup_origin.span() != return_sp\n+        {\n+            // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+            // Customize the spans and labels depending on their relative order so\n+            // that split sentences flow correctly.\n+            if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                // Avoid the following:\n+                //\n+                // error: cannot infer an appropriate lifetime\n+                //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                //    |\n+                // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                //    |           ----                      ---------^-\n+                //\n+                // and instead show:\n+                //\n+                // error: cannot infer an appropriate lifetime\n+                //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                //    |\n+                // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                //    |           ----                               ^\n                 err.span_label(\n-                    param_info.param_ty_span,\n-                    &format!(\"this data with {}...\", lifetime),\n+                    sup_origin.span(),\n+                    \"...is captured here, requiring it to live as long as `'static`\",\n                 );\n-                debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+            } else {\n+                err.span_label(sup_origin.span(), \"...is captured here...\");\n+                if return_sp < sup_origin.span() {\n+                    err.span_note(\n+                        return_sp,\n+                        \"...and is required to live as long as `'static` here\",\n+                    );\n+                } else {\n+                    err.span_label(\n+                        return_sp,\n+                        \"...and is required to live as long as `'static` here\",\n+                    );\n+                }\n+            }\n+        } else {\n+            err.span_label(\n+                return_sp,\n+                \"...is captured and required to live as long as `'static` here\",\n+            );\n+        }\n+\n+        let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n-                // We try to make the output have fewer overlapping spans if possible.\n-                if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n-                    && sup_origin.span() != return_sp\n+        let mut override_error_code = None;\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin {\n+            if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+                // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n+                // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n+                if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n+                    override_error_code = Some(ctxt.assoc_item.ident);\n+                }\n+            }\n+        }\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin {\n+            if let ObligationCauseCode::ItemObligation(item_def_id) = cause.code {\n+                // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n+                // lifetime as above, but called using a fully-qualified path to the method:\n+                // `Foo::qux(bar)`.\n+                let mut v = TraitObjectVisitor(vec![]);\n+                v.visit_ty(param.param_ty);\n+                if let Some((ident, self_ty)) =\n+                    self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0[..])\n                 {\n-                    // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n-\n-                    // Customize the spans and labels depending on their relative order so\n-                    // that split sentences flow correctly.\n-                    if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n-                        // Avoid the following:\n-                        //\n-                        // error: cannot infer an appropriate lifetime\n-                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                        //    |\n-                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                        //    |           ----                      ---------^-\n-                        //\n-                        // and instead show:\n-                        //\n-                        // error: cannot infer an appropriate lifetime\n-                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                        //    |\n-                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                        //    |           ----                               ^\n-                        err.span_label(\n-                            sup_origin.span(),\n-                            \"...is captured here, requiring it to live as long as `'static`\",\n+                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0[..], ident, self_ty)\n+                    {\n+                        override_error_code = Some(ident);\n+                    }\n+                }\n+            }\n+        }\n+        if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n+            // Provide a more targetted error code and description.\n+            err.code(rustc_errors::error_code!(E0772));\n+            err.set_primary_message(&format!(\n+                \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n+                requirement\",\n+                param_name, lifetime, ident,\n+            ));\n+        }\n+\n+        debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+        let consider = \"consider changing the\";\n+        let declare = \"to declare that the\";\n+        let arg = match param.param.pat.simple_ident() {\n+            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+            None => \"the argument\".to_string(),\n+        };\n+        let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+        let explicit_static = format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+        let captures = format!(\"captures data from {}\", arg);\n+        let add_static_bound = \"alternatively, add an explicit `'static` bound to this reference\";\n+        let plus_lt = format!(\" + {}\", lifetime_name);\n+        for fn_return in fn_returns {\n+            if fn_return.span.desugaring_kind().is_some() {\n+                // Skip `async` desugaring `impl Future`.\n+                continue;\n+            }\n+            match fn_return.kind {\n+                TyKind::OpaqueDef(item_id, _) => {\n+                    let item = tcx.hir().item(item_id.id);\n+                    let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                        opaque\n+                    } else {\n+                        err.emit();\n+                        return Some(ErrorReported);\n+                    };\n+\n+                    if let Some(span) = opaque\n+                        .bounds\n+                        .iter()\n+                        .filter_map(|arg| match arg {\n+                            GenericBound::Outlives(Lifetime {\n+                                name: LifetimeName::Static,\n+                                span,\n+                                ..\n+                            }) => Some(*span),\n+                            _ => None,\n+                        })\n+                        .next()\n+                    {\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                            lifetime_name.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            param.param_ty_span,\n+                            add_static_bound,\n+                            param.param_ty.to_string(),\n+                            Applicability::MaybeIncorrect,\n                         );\n+                    } else if let Some(_) = opaque\n+                        .bounds\n+                        .iter()\n+                        .filter_map(|arg| match arg {\n+                            GenericBound::Outlives(Lifetime { name, span, .. })\n+                                if name.ident().to_string() == lifetime_name =>\n+                            {\n+                                Some(*span)\n+                            }\n+                            _ => None,\n+                        })\n+                        .next()\n+                    {\n                     } else {\n-                        err.span_label(sup_origin.span(), \"...is captured here...\");\n-                        if return_sp < sup_origin.span() {\n-                            err.span_note(\n-                                return_sp,\n-                                \"...and is required to live as long as `'static` here\",\n-                            );\n-                        } else {\n-                            err.span_label(\n-                                return_sp,\n-                                \"...and is required to live as long as `'static` here\",\n-                            );\n-                        }\n+                        err.span_suggestion_verbose(\n+                            fn_return.span.shrink_to_hi(),\n+                            &format!(\n+                                \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                declare = declare,\n+                                captures = captures,\n+                                explicit = explicit,\n+                            ),\n+                            plus_lt.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n-                } else {\n-                    err.span_label(\n-                        return_sp,\n-                        \"...is captured and required to live as long as `'static` here\",\n-                    );\n                 }\n+                TyKind::TraitObject(_, lt) => match lt.name {\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        err.span_suggestion_verbose(\n+                            fn_return.span.shrink_to_hi(),\n+                            &format!(\n+                                \"{declare} trait object {captures}, {explicit}\",\n+                                declare = declare,\n+                                captures = captures,\n+                                explicit = explicit,\n+                            ),\n+                            plus_lt.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    name if name.ident().to_string() != lifetime_name => {\n+                        // With this check we avoid suggesting redundant bounds. This\n+                        // would happen if there are nested impl/dyn traits and only\n+                        // one of them has the bound we'd suggest already there, like\n+                        // in `impl Foo<X = dyn Bar> + '_`.\n+                        err.span_suggestion_verbose(\n+                            lt.span,\n+                            &format!(\"{} trait object's {}\", consider, explicit_static),\n+                            lifetime_name.clone(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            param.param_ty_span,\n+                            add_static_bound,\n+                            param.param_ty.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                },\n+                _ => {}\n+            }\n+        }\n+        err.emit();\n+        Some(ErrorReported)\n+    }\n \n-                // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                let consider = \"consider changing the\";\n-                let declare = \"to declare that the\";\n-                let arg = match param_info.param.pat.simple_ident() {\n-                    Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                    None => \"the argument\".to_string(),\n-                };\n-                let explicit =\n-                    format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                let explicit_static =\n-                    format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                let captures = format!(\"captures data from {}\", arg);\n-                let add_static_bound =\n-                    \"alternatively, add an explicit `'static` bound to this reference\";\n-                let plus_lt = format!(\" + {}\", lifetime_name);\n-                for fn_return in fn_returns {\n-                    if fn_return.span.desugaring_kind().is_some() {\n-                        // Skip `async` desugaring `impl Future`.\n-                        continue;\n+    fn get_impl_ident_and_self_ty_from_trait(\n+        &self,\n+        def_id: DefId,\n+        trait_objects: &[DefId],\n+    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n+        let tcx = self.tcx();\n+        match tcx.hir().get_if_local(def_id) {\n+            Some(Node::ImplItem(ImplItem { ident, hir_id, .. })) => {\n+                match tcx.hir().find(tcx.hir().get_parent_item(*hir_id)) {\n+                    Some(Node::Item(Item { kind: ItemKind::Impl { self_ty, .. }, .. })) => {\n+                        Some((*ident, self_ty))\n                     }\n-                    match fn_return.kind {\n-                        TyKind::OpaqueDef(item_id, _) => {\n-                            let item = self.tcx().hir().item(item_id.id);\n-                            let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                                opaque\n-                            } else {\n-                                err.emit();\n-                                return Some(ErrorReported);\n-                            };\n-\n-                            if let Some(span) = opaque\n-                                .bounds\n-                                .iter()\n-                                .filter_map(|arg| match arg {\n-                                    GenericBound::Outlives(Lifetime {\n-                                        name: LifetimeName::Static,\n-                                        span,\n+                    _ => None,\n+                }\n+            }\n+            Some(Node::TraitItem(TraitItem { ident, hir_id, .. })) => {\n+                let parent_id = tcx.hir().get_parent_item(*hir_id);\n+                match tcx.hir().find(parent_id) {\n+                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n+                        // The method being called is defined in the `trait`, but the `'static`\n+                        // obligation comes from the `impl`. Find that `impl` so that we can point\n+                        // at it in the suggestion.\n+                        let trait_did = tcx.hir().local_def_id(parent_id).to_def_id();\n+                        match tcx\n+                            .hir()\n+                            .trait_impls(trait_did)\n+                            .iter()\n+                            .filter_map(|impl_node| {\n+                                let impl_did = tcx.hir().local_def_id(*impl_node);\n+                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                    Some(Node::Item(Item {\n+                                        kind: ItemKind::Impl { self_ty, .. },\n                                         ..\n-                                    }) => Some(*span),\n-                                    _ => None,\n-                                })\n-                                .next()\n-                            {\n-                                err.span_suggestion_verbose(\n-                                    span,\n-                                    &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                    lifetime_name.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                err.span_suggestion_verbose(\n-                                    param_info.param_ty_span,\n-                                    add_static_bound,\n-                                    param_info.param_ty.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else if let Some(_) = opaque\n-                                .bounds\n-                                .iter()\n-                                .filter_map(|arg| match arg {\n-                                    GenericBound::Outlives(Lifetime { name, span, .. })\n-                                        if name.ident().to_string() == lifetime_name =>\n+                                    })) if trait_objects.iter().all(|did| {\n+                                        // FIXME: we should check `self_ty` against the receiver\n+                                        // type in the `UnifyReceiver` context, but for now, use\n+                                        // this imperfect proxy. This will fail if there are\n+                                        // multiple `impl`s for the same trait like\n+                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                                        // In that case, only the first one will get suggestions.\n+                                        let mut hir_v = HirTraitObjectVisitor(vec![], *did);\n+                                        hir_v.visit_ty(self_ty);\n+                                        !hir_v.0.is_empty()\n+                                    }) =>\n                                     {\n-                                        Some(*span)\n+                                        Some(self_ty)\n                                     }\n                                     _ => None,\n-                                })\n-                                .next()\n-                            {\n-                            } else {\n-                                err.span_suggestion_verbose(\n-                                    fn_return.span.shrink_to_hi(),\n-                                    &format!(\n-                                        \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                        declare = declare,\n-                                        captures = captures,\n-                                        explicit = explicit,\n-                                    ),\n-                                    plus_lt.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                                }\n+                            })\n+                            .next()\n+                        {\n+                            Some(self_ty) => Some((*ident, self_ty)),\n+                            _ => None,\n                         }\n-                        TyKind::TraitObject(_, lt) => match lt.name {\n-                            LifetimeName::ImplicitObjectLifetimeDefault => {\n-                                err.span_suggestion_verbose(\n-                                    fn_return.span.shrink_to_hi(),\n-                                    &format!(\n-                                        \"{declare} trait object {captures}, {explicit}\",\n-                                        declare = declare,\n-                                        captures = captures,\n-                                        explicit = explicit,\n-                                    ),\n-                                    plus_lt.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            name if name.ident().to_string() != lifetime_name => {\n-                                // With this check we avoid suggesting redundant bounds. This\n-                                // would happen if there are nested impl/dyn traits and only\n-                                // one of them has the bound we'd suggest already there, like\n-                                // in `impl Foo<X = dyn Bar> + '_`.\n-                                err.span_suggestion_verbose(\n-                                    lt.span,\n-                                    &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                    lifetime_name.clone(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                err.span_suggestion_verbose(\n-                                    param_info.param_ty_span,\n-                                    add_static_bound,\n-                                    param_info.param_ty.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            _ => {}\n-                        },\n-                        _ => {}\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// When we call a method coming from an `impl Foo for dyn Bar`, `dyn Bar` introduces a default\n+    /// `'static` obligation. Suggest relaxing that implicit bound.\n+    fn find_impl_on_dyn_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        ty: Ty<'_>,\n+        ctxt: &UnifyReceiverContext<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx();\n+\n+        // Find the method being called.\n+        let instance = match ty::Instance::resolve(\n+            tcx,\n+            ctxt.param_env,\n+            ctxt.assoc_item.def_id,\n+            self.infcx.resolve_vars_if_possible(&ctxt.substs),\n+        ) {\n+            Ok(Some(instance)) => instance,\n+            _ => return false,\n+        };\n+\n+        let mut v = TraitObjectVisitor(vec![]);\n+        v.visit_ty(ty);\n+\n+        // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n+        // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n+        let (ident, self_ty) =\n+            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0[..]) {\n+                Some((ident, self_ty)) => (ident, self_ty),\n+                None => return false,\n+            };\n+\n+        // Find the trait object types in the argument, so we point at *only* the trait object.\n+        self.suggest_constrain_dyn_trait_in_impl(err, &v.0[..], ident, self_ty)\n+    }\n+\n+    fn suggest_constrain_dyn_trait_in_impl(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        found_dids: &[DefId],\n+        ident: Ident,\n+        self_ty: &hir::Ty<'_>,\n+    ) -> bool {\n+        let mut suggested = false;\n+        for found_did in found_dids {\n+            let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n+            hir_v.visit_ty(&self_ty);\n+            for span in &hir_v.0 {\n+                let mut multi_span: MultiSpan = vec![*span].into();\n+                multi_span.push_span_label(\n+                    *span,\n+                    \"this has an implicit `'static` lifetime requirement\".to_string(),\n+                );\n+                multi_span.push_span_label(\n+                    ident.span,\n+                    \"calling this method introduces the `impl`'s 'static` requirement\".to_string(),\n+                );\n+                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        suggested\n+    }\n+}\n+\n+/// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n+struct TraitObjectVisitor(Vec<DefId>);\n+\n+impl TypeVisitor<'_> for TraitObjectVisitor {\n+    fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n+        match t.kind {\n+            ty::Dynamic(preds, RegionKind::ReStatic) => {\n+                if let Some(def_id) = preds.principal_def_id() {\n+                    self.0.push(def_id);\n+                }\n+                false\n+            }\n+            _ => t.super_visit_with(self),\n+        }\n+    }\n+}\n+\n+/// Collect all `hir::Ty<'_>` `Span`s for trait objects with an implicit lifetime.\n+struct HirTraitObjectVisitor(Vec<Span>, DefId);\n+\n+impl<'tcx> Visitor<'tcx> for HirTraitObjectVisitor {\n+    type Map = ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n+        match t.kind {\n+            TyKind::TraitObject(\n+                poly_trait_refs,\n+                Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+            ) => {\n+                for ptr in poly_trait_refs {\n+                    if Some(self.1) == ptr.trait_ref.trait_def_id() {\n+                        self.0.push(ptr.span);\n                     }\n                 }\n-                err.emit();\n-                return Some(ErrorReported);\n             }\n+            _ => {}\n         }\n-        None\n+        walk_ty(self, t);\n     }\n }"}, {"sha": "28e9dd90cfd674531eafece5122db6f3410fa2f5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -7,20 +7,18 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n use rustc_span::Span;\n \n-// The struct contains the information about the anonymous region\n-// we are searching for.\n+/// Information about the anonymous region we are searching for.\n #[derive(Debug)]\n pub(super) struct AnonymousParamInfo<'tcx> {\n-    // the parameter corresponding to the anonymous region\n+    /// The parameter corresponding to the anonymous region.\n     pub param: &'tcx hir::Param<'tcx>,\n-    // the type corresponding to the anonymopus region parameter\n+    /// The type corresponding to the anonymous region parameter.\n     pub param_ty: Ty<'tcx>,\n-    // the ty::BoundRegion corresponding to the anonymous region\n+    /// The ty::BoundRegion corresponding to the anonymous region.\n     pub bound_region: ty::BoundRegion,\n-    // param_ty_span contains span of parameter type\n+    /// The `Span` of the parameter type.\n     pub param_ty_span: Span,\n-    // corresponds to id the argument is the first parameter\n-    // in the declaration\n+    /// Signals that the argument is the first parameter in the declaration.\n     pub is_first: bool,\n }\n "}, {"sha": "3744ad5d0324a59ebd145ae16ca0537210feb11d", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -463,7 +463,7 @@ pub enum RegionVariableOrigin {\n     AddrOfRegion(Span),\n \n     /// Regions created as part of an autoref of a method receiver\n-    Autoref(Span),\n+    Autoref(Span, ty::AssocItem),\n \n     /// Regions created as part of an automatic coercion\n     Coercion(Span),\n@@ -1800,15 +1800,15 @@ impl<'tcx> SubregionOrigin<'tcx> {\n impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n-            MiscVariable(a) => a,\n-            PatternRegion(a) => a,\n-            AddrOfRegion(a) => a,\n-            Autoref(a) => a,\n-            Coercion(a) => a,\n-            EarlyBoundRegion(a, ..) => a,\n-            LateBoundRegion(a, ..) => a,\n+            MiscVariable(a)\n+            | PatternRegion(a)\n+            | AddrOfRegion(a)\n+            | Autoref(a, _)\n+            | Coercion(a)\n+            | EarlyBoundRegion(a, ..)\n+            | LateBoundRegion(a, ..)\n+            | UpvarRegion(_, a) => a,\n             BoundRegionInCoherence(_) => rustc_span::DUMMY_SP,\n-            UpvarRegion(_, a) => a,\n             NLL(..) => bug!(\"NLL variable used with `span`\"),\n         }\n     }"}, {"sha": "bacb7fa153e43b1a0cca8d8f5272ec5c71d749f5", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -13,6 +13,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "d2747e5fc659b9efcef4b621e1d6fea8eb33f347", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -169,6 +169,13 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct UnifyReceiverContext<'tcx> {\n+    pub assoc_item: ty::AssocItem,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n@@ -300,6 +307,8 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Method receiver\n     MethodReceiver,\n \n+    UnifyReceiver(Box<UnifyReceiverContext<'tcx>>),\n+\n     /// `return` with no expression\n     ReturnNoExpression,\n "}, {"sha": "18b4371053a89c77b3340161b2eaab7cefaa92c2", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -213,12 +213,26 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::StartFunctionType => Some(super::StartFunctionType),\n             super::IntrinsicType => Some(super::IntrinsicType),\n             super::MethodReceiver => Some(super::MethodReceiver),\n+            super::UnifyReceiver(ref ctxt) => tcx.lift(ctxt).map(|ctxt| super::UnifyReceiver(ctxt)),\n             super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n             super::TrivialBound => Some(super::TrivialBound),\n         }\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for traits::UnifyReceiverContext<'a> {\n+    type Lifted = traits::UnifyReceiverContext<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.param_env).and_then(|param_env| {\n+            tcx.lift(&self.substs).map(|substs| traits::UnifyReceiverContext {\n+                assoc_item: self.assoc_item,\n+                param_env,\n+                substs,\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {"}, {"sha": "9007bd99d7e4b6e8df08b1dbc00477781a0a4d79", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -136,7 +136,7 @@ pub struct ResolverOutputs {\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Hash)]\n pub enum AssocItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n@@ -184,7 +184,7 @@ pub enum ImplPolarity {\n     Reservation,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n pub struct AssocItem {\n     pub def_id: DefId,\n     #[stable_hasher(project(name))]\n@@ -199,7 +199,7 @@ pub struct AssocItem {\n     pub fn_has_self_parameter: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable, Eq, Hash)]\n pub enum AssocKind {\n     Const,\n     Fn,\n@@ -316,7 +316,7 @@ impl<'tcx> AssociatedItems<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable, Hash)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,"}, {"sha": "dd7ea55cc1043693be0a1e0e96399a602c21c32e", "filename": "src/librustc_trait_selection/traits/codegen/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -6,6 +6,7 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::{\n     FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine,\n+    Unimplemented,\n };\n use rustc_errors::ErrorReported;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -58,6 +59,18 @@ pub fn codegen_fulfill_obligation<'tcx>(\n                 );\n                 return Err(ErrorReported);\n             }\n+            Err(Unimplemented) => {\n+                // This can trigger when we probe for the source of a `'static` lifetime requirement\n+                // on a trait object: `impl Foo for dyn Trait {}` has an implicit `'static` bound.\n+                infcx.tcx.sess.delay_span_bug(\n+                    rustc_span::DUMMY_SP,\n+                    &format!(\n+                        \"Encountered error `Unimplemented` selecting `{:?}` during codegen\",\n+                        trait_ref\n+                    ),\n+                );\n+                return Err(ErrorReported);\n+            }\n             Err(e) => {\n                 bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n             }"}, {"sha": "0632ce2319aeef1d462898e2537243cbcd7f0d42", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1706,6 +1706,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::IntrinsicType\n             | ObligationCauseCode::MethodReceiver\n             | ObligationCauseCode::ReturnNoExpression\n+            | ObligationCauseCode::UnifyReceiver(..)\n             | ObligationCauseCode::MiscObligation => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");"}, {"sha": "ed84095ae6b0cbc4a5a6d7094edb3eea07cd9509", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -6,6 +6,7 @@ use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n+use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -91,7 +92,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // signature (which is also done during probing).\n         let method_sig_rcvr =\n             self.normalize_associated_types_in(self.span, &method_sig.inputs()[0]);\n-        self.unify_receivers(self_ty, method_sig_rcvr);\n+        debug!(\n+            \"confirm: self_ty={:?} method_sig_rcvr={:?} method_sig={:?} method_predicates={:?}\",\n+            self_ty, method_sig_rcvr, method_sig, method_predicates\n+        );\n+        self.unify_receivers(self_ty, method_sig_rcvr, &pick, all_substs);\n \n         let (method_sig, method_predicates) =\n             self.normalize_associated_types_in(self.span, &(method_sig, method_predicates));\n@@ -150,7 +155,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n         if let Some(mutbl) = pick.autoref {\n-            let region = self.next_region_var(infer::Autoref(self.span));\n+            let region = self.next_region_var(infer::Autoref(self.span, pick.item));\n             target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n             let mutbl = match mutbl {\n                 hir::Mutability::Not => AutoBorrowMutability::Not,\n@@ -334,8 +339,26 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         )\n     }\n \n-    fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.at(&self.misc(self.span), self.param_env).sup(method_self_ty, self_ty) {\n+    fn unify_receivers(\n+        &mut self,\n+        self_ty: Ty<'tcx>,\n+        method_self_ty: Ty<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n+        debug!(\n+            \"unify_receivers: self_ty={:?} method_self_ty={:?} span={:?} pick={:?}\",\n+            self_ty, method_self_ty, self.span, pick\n+        );\n+        let cause = self.cause(\n+            self.span,\n+            ObligationCauseCode::UnifyReceiver(Box::new(UnifyReceiverContext {\n+                assoc_item: pick.item,\n+                param_env: self.param_env,\n+                substs,\n+            })),\n+        );\n+        match self.at(&cause, self.param_env).sup(method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "1eeb01ccc846e9d82691725254e58eac7f0830e4", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -35,7 +35,7 @@ fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n \n #[cfg(transmute)] // one instantiations: BAD\n fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-   bar(foo, x) //[transmute]~ ERROR E0495\n+   bar(foo, x) //[transmute]~ ERROR E0759\n }\n \n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD"}, {"sha": "0be9b37263a48bbea3847ef93b55c4fa4b636950", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.transmute.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,26 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/project-fn-ret-contravariant.rs:38:8\n    |\n-LL |    bar(foo, x)\n-   |        ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 37:8...\n-  --> $DIR/project-fn-ret-contravariant.rs:37:8\n-   |\n LL | fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-   |        ^^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/project-fn-ret-contravariant.rs:38:13\n-   |\n-LL |    bar(foo, x)\n-   |             ^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/project-fn-ret-contravariant.rs:38:4\n-   |\n+   |                  ------- this data with lifetime `'a`...\n LL |    bar(foo, x)\n-   |    ^^^^^^^^^^^\n+   |    ----^^^---- ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "08d864f7836d20467ad4292d937f2809f154b089", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -46,7 +46,7 @@ fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n     // Cannot instantiate `foo` with any lifetime other than `'a`,\n     // since it is provided as input.\n \n-    bar(foo, x) //[transmute]~ ERROR E0495\n+    bar(foo, x) //[transmute]~ ERROR E0759\n }\n \n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD"}, {"sha": "0a44864b249551b3a03d6f5f792e7f49c00c13ab", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,30 +1,12 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/project-fn-ret-invariant.rs:49:9\n    |\n-LL |     bar(foo, x)\n-   |         ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 45:8...\n-  --> $DIR/project-fn-ret-invariant.rs:45:8\n-   |\n LL | fn baz<'a, 'b>(x: Type<'a>) -> Type<'static> {\n-   |        ^^\n-note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:49:14\n-   |\n-LL |     bar(foo, x)\n-   |              ^\n-   = note: expected `Type<'_>`\n-              found `Type<'a>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/project-fn-ret-invariant.rs:49:5\n-   |\n+   |                   -------- this data with lifetime `'a`...\n+...\n LL |     bar(foo, x)\n-   |     ^^^^^^^^^^^\n-   = note: expected `Type<'static>`\n-              found `Type<'_>`\n+   |     ----^^^---- ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "66ebbd83ffa9e4546a0fcfd06b437a658b245dc1", "filename": "src/test/ui/async-await/issues/issue-62097.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -9,7 +9,7 @@ where\n struct Struct;\n \n impl Struct {\n-    pub async fn run_dummy_fn(&self) { //~ ERROR cannot infer\n+    pub async fn run_dummy_fn(&self) { //~ ERROR E0759\n         foo(|| self.bar()).await;\n     }\n "}, {"sha": "56a28d904b91d57f29f79c8f6dba321a250422a5", "filename": "src/test/ui/async-await/issues/issue-62097.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/issue-62097.rs:12:31\n    |\n LL |     pub async fn run_dummy_fn(&self) {"}, {"sha": "89210fdf137e0d169203d61f79f1b6ff982686e0", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -17,7 +17,7 @@ fn static_val<T: StaticTrait>(_: T) {\n }\n \n fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n-    static_val(x); //~ ERROR cannot infer\n+    static_val(x); //~ ERROR E0759\n }\n \n fn not_static_val<T: NotStaticTrait>(_: T) {"}, {"sha": "b3bef677d19c1c84999b011663277607a8f44ec4", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,30 +1,17 @@\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/dyn-trait.rs:20:16\n    |\n-LL |     static_val(x);\n-   |                ^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 19:26...\n-  --> $DIR/dyn-trait.rs:19:26\n-   |\n LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n-   |                          ^^\n-note: ...so that the expression is assignable\n-  --> $DIR/dyn-trait.rs:20:16\n-   |\n+   |                                 ------------------- this data with lifetime `'a`...\n LL |     static_val(x);\n-   |                ^\n-   = note: expected `std::boxed::Box<dyn std::fmt::Debug>`\n-              found `std::boxed::Box<(dyn std::fmt::Debug + 'a)>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the types are compatible\n+   |                ^ ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n   --> $DIR/dyn-trait.rs:20:5\n    |\n LL |     static_val(x);\n    |     ^^^^^^^^^^\n-   = note: expected `StaticTrait`\n-              found `StaticTrait`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "4372de245078fc930be3cb4a27dd1f30e337be7d", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -12,7 +12,7 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                       ^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:5:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |             --                 ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n@@ -26,7 +26,7 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+  --> $DIR/must_outlive_least_region_or_bound.rs:7:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               -                              ^ returning this value requires that `'1` must outlive `'static`\n@@ -36,7 +36,7 @@ LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    = help: consider replacing `'1` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n@@ -45,23 +45,23 @@ LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:15:41\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:41\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               ----                      ^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:30:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:22:24\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               -        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n    |               |\n    |               let's call the lifetime of this reference `'1`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:28:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -70,7 +70,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:32:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -80,7 +80,7 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^"}, {"sha": "51f488e45a6f3d14ce6cea95d318c3f06e126ef0", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,41 +1,31 @@\n use std::fmt::Debug;\n \n-fn elided(x: &i32) -> impl Copy { x }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn elided(x: &i32) -> impl Copy { x } //~ ERROR E0759\n \n-fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn explicit<'a>(x: &'a i32) -> impl Copy { x } //~ ERROR E0759\n \n-fn elided2(x: &i32) -> impl Copy + 'static { x }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn elided2(x: &i32) -> impl Copy + 'static { x } //~ ERROR E0759\n \n-fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x } //~ ERROR E0759\n \n fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n //~^ ERROR explicit lifetime required in the type of `x`\n \n-fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) } //~ ERROR E0759\n \n-fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) } //~ ERROR E0759\n \n-fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) } //~ ERROR E0759\n \n-fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) } //~ ERROR E0759\n \n-fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n-//~^ ERROR cannot infer an appropriate lifetime\n-//~| ERROR cannot infer an appropriate lifetime\n+fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) } //~ ERROR E0759\n+//~^ ERROR E0759\n \n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n \n-fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-//~^ ERROR cannot infer an appropriate lifetime\n+fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERROR E0759\n \n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected."}, {"sha": "b040889217e47032e23cfcffbd0b301ce63f31fa", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n@@ -16,16 +16,16 @@ help: to declare that the `impl Trait` captures data from argument `x`, you can\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:5:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |                    -------                 ^ ...is captured here...\n    |                    |\n    |                    this data with lifetime `'a`...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:5:32\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |                                ^^^^^^^^^\n@@ -34,16 +34,16 @@ help: to declare that the `impl Trait` captures data from argument `x`, you can\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:7:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               ----                           ^ ...is captured here...\n    |               |\n    |               this data with an anonymous lifetime `'_`...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:7:24\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |                        ^^^^^^^^^^^^^^^^^^^\n@@ -56,16 +56,16 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n    |               ^^^^^^^^^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |                     -------                           ^ ...is captured here...\n    |                     |\n    |                     this data with lifetime `'a`...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:33\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:33\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |                                 ^^^^^^^^^^^^^^^^^^^\n@@ -79,15 +79,15 @@ LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n    |                     ^^^^^^^^^^^^\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:15:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:11:24\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:30:65\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:22:65\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               ---- this data with an anonymous lifetime `'_`... ^ ...is captured here, requiring it to live as long as `'static`\n@@ -101,14 +101,14 @@ help: to declare that the `impl Trait` captures data from argument `x`, you can\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n    |                                                    ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:30:69\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:22:69\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               ---- this data with an anonymous lifetime `'_`...     ^ ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:30:41\n+  --> $DIR/must_outlive_least_region_or_bound.rs:22:41\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |                                         ^^^^^^^^^^\n@@ -121,14 +121,14 @@ help: to declare that the `impl Trait` captures data from argument `x`, you can\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n    |                                                    ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:28:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:37:34\n+  --> $DIR/must_outlive_least_region_or_bound.rs:28:34\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -142,7 +142,7 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ^^^^^^^^^^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:32:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -151,15 +151,15 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:14:50\n    |\n LL | fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n    |               ----                               ^ ...is captured here, requiring it to live as long as `'static`\n@@ -171,8 +171,8 @@ help: to declare that the trait object captures data from argument `x`, you can\n LL | fn elided3(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n    |                                      ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:21:59\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:16:59\n    |\n LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n    |                     -------                               ^ ...is captured here, requiring it to live as long as `'static`\n@@ -184,8 +184,8 @@ help: to declare that the trait object captures data from argument `x`, you can\n LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n    |                                               ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:24:60\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:18:60\n    |\n LL | fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |               ----                                         ^ ...is captured here, requiring it to live as long as `'static`\n@@ -201,8 +201,8 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn elided4(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |               ^^^^^^^^^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:27:69\n+error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/must_outlive_least_region_or_bound.rs:20:69\n    |\n LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ------- this data with lifetime `'a`...         ^ ...is captured here, requiring it to live as long as `'static`"}, {"sha": "65178cc9d24c262f3b186f99310df4a36a8c5330", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -12,7 +12,7 @@ LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/static-return-lifetime-infered.rs:10:37\n+  --> $DIR/static-return-lifetime-infered.rs:9:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                    --               ^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`"}, {"sha": "518c52f5de4d7bfb3b26ce59a59d6668a7259ced", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -4,13 +4,11 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0)\n+        self.x.iter().map(|a| a.0) //~ ERROR E0759\n     }\n-    //~^^ ERROR cannot infer an appropriate lifetime\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-        self.x.iter().map(|a| a.0)\n+        self.x.iter().map(|a| a.0) //~ ERROR E0759\n     }\n-    //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "7c289b388223a4b6ebff083f9f32210745ee7d6c", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/static-return-lifetime-infered.rs:7:16\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n@@ -18,8 +18,8 @@ help: to declare that the `impl Trait` captures data from argument `self`, you c\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/static-return-lifetime-infered.rs:11:16\n+error[E0759]: `self` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/static-return-lifetime-infered.rs:10:16\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                        -------- this data with lifetime `'a`...\n@@ -29,7 +29,7 @@ LL |         self.x.iter().map(|a| a.0)\n    |         ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/static-return-lifetime-infered.rs:10:37\n+  --> $DIR/static-return-lifetime-infered.rs:9:37\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f048ccd2427cb052cc465de1b9a3302236334e6e", "filename": "src/test/ui/issues/issue-16922.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,8 +1,7 @@\n use std::any::Any;\n \n fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n-    Box::new(value) as Box<dyn Any>\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    Box::new(value) as Box<dyn Any> //~ ERROR E0759\n }\n \n fn main() {"}, {"sha": "6decc751321f9abfd3a434d39873dd34af7b6b87", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `value` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/issue-16922.rs:4:14\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {"}, {"sha": "1931934a2112a7ded99b5e6ff3dfc08a4f15732d", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.stderr", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,28 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error[E0759]: `fn` parameter has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/constant-in-expr-inherent-1.rs:8:5\n    |\n-LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 7:8...\n-  --> $DIR/constant-in-expr-inherent-1.rs:7:8\n-   |\n LL | fn foo<'a>(_: &'a u32) -> &'static u32 {\n-   |        ^^\n-note: ...so that the types are compatible\n-  --> $DIR/constant-in-expr-inherent-1.rs:8:5\n-   |\n-LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n-   = note: expected `Foo<'_>`\n-              found `Foo<'a>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/constant-in-expr-inherent-1.rs:8:5\n-   |\n+   |               ------- this data with lifetime `'a`...\n LL |     <Foo<'a>>::C\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "4a2665d8e1694f2d68d04396c83127fe58b875b9", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -15,7 +15,7 @@ fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR cannot infer an appropriate lifetime\n+    ss.r //~ ERROR E0759\n }\n \n fn store(ss: &mut SomeStruct, b: Box<dyn SomeTrait>) {"}, {"sha": "70b99ef7869ca8cfab83e016c7463e4eb2ef17d9", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `ss` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {"}, {"sha": "9d3f485e314385148fd081174954b3faaf1cedb7", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -5,18 +5,18 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    let x: Box<dyn Foo + 'static> = Box::new(v); //~ ERROR cannot infer an appropriate lifetime\n+    let x: Box<dyn Foo + 'static> = Box::new(v); //~ ERROR E0759\n     x\n }\n \n fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n+    Box::new(v) //~ ERROR E0759\n }\n \n fn c(v: &[u8]) -> Box<dyn Foo> {\n     // same as previous case due to RFC 599\n \n-    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n+    Box::new(v) //~ ERROR E0759\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {"}, {"sha": "63fea1f41626d10e22dda55f34b9a949d772d92d", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `v` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/region-object-lifetime-in-coercion.rs:8:46\n    |\n LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n@@ -15,7 +15,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn a(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n    |         ^^^^^^^^^^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `v` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/region-object-lifetime-in-coercion.rs:13:14\n    |\n LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n@@ -32,7 +32,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn b(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n    |         ^^^^^^^^^^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `v` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/region-object-lifetime-in-coercion.rs:19:14\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {"}, {"sha": "4eb1b275f163ec77af5f50bb86c28b486e72644f", "filename": "src/test/ui/regions/regions-addr-of-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -4,7 +4,7 @@ struct Dog {\n \n impl Dog {\n     pub fn chase_cat(&mut self) {\n-        let p: &'static mut usize = &mut self.cats_chased; //~ ERROR cannot infer\n+        let p: &'static mut usize = &mut self.cats_chased; //~ ERROR E0759\n         *p += 1;\n     }\n "}, {"sha": "738691fd695eb4fe2aa8e05f40fbbe675e108a1b", "filename": "src/test/ui/regions/regions-addr-of-self.stderr", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,29 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/regions-addr-of-self.rs:7:37\n    |\n+LL |     pub fn chase_cat(&mut self) {\n+   |                      --------- this data with an anonymous lifetime `'_`...\n LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 6:5...\n-  --> $DIR/regions-addr-of-self.rs:6:5\n-   |\n-LL | /     pub fn chase_cat(&mut self) {\n-LL | |         let p: &'static mut usize = &mut self.cats_chased;\n-LL | |         *p += 1;\n-LL | |     }\n-   | |_____^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/regions-addr-of-self.rs:7:37\n-   |\n-LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/regions-addr-of-self.rs:7:37\n-   |\n-LL |         let p: &'static mut usize = &mut self.cats_chased;\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^ ...is captured and required to live as long as `'static` here\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "7144ab5a24c51443ec36b8dffda63669e12317a0", "filename": "src/test/ui/regions/regions-close-object-into-object-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -7,7 +7,7 @@ trait X { }\n impl<'a, T> X for B<'a, T> {}\n \n fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n-    box B(&*v) as Box<dyn X> //~ ERROR cannot infer\n+    box B(&*v) as Box<dyn X> //~ ERROR E0759\n }\n \n fn main() { }"}, {"sha": "aab7ce993aa3c3861a55018bbfb1b46912c75056", "filename": "src/test/ui/regions/regions-close-object-into-object-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `v` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/regions-close-object-into-object-2.rs:10:11\n    |\n LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {"}, {"sha": "4c087f264f92b964010c16521d98fd6a97f92889", "filename": "src/test/ui/regions/regions-close-object-into-object-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -7,7 +7,7 @@ trait X { }\n impl<'a, T> X for B<'a, T> {}\n \n fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-    box B(&*v) as Box<dyn X> //~ ERROR cannot infer\n+    box B(&*v) as Box<dyn X> //~ ERROR E0759\n }\n \n fn main() {}"}, {"sha": "90f807a41c5629f07d04aeb0d00a47b1491fa879", "filename": "src/test/ui/regions/regions-close-object-into-object-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `v` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/regions-close-object-into-object-4.rs:10:11\n    |\n LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {"}, {"sha": "55d964ac5340569b287a993d650fe88ba70b2f94", "filename": "src/test/ui/regions/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -6,7 +6,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<dyn FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move || { *x }) //~ ERROR cannot infer an appropriate lifetime\n+    Box::new(move || { *x }) //~ ERROR E0759\n }\n \n fn main() { }"}, {"sha": "e76073f4f6b13f5b6be54d1179799ef19cd2c63c", "filename": "src/test/ui/regions/regions-proc-bound-capture.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/regions-proc-bound-capture.rs:9:14\n    |\n LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {"}, {"sha": "43998ca8c5784478dfca0e18aea561c2aab3ef40", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -6,7 +6,7 @@ struct Foo;\n \n impl Foo {\n     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    //~^ ERROR E0759\n }\n \n fn main() {"}, {"sha": "9cd0fd328ffa007a37fda588dbed69e79ce2aca9", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }"}, {"sha": "04935fc52ab9e31253bb8dce181cacfafdd589ac", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -3,7 +3,7 @@ use std::pin::Pin;\n struct Foo;\n \n impl Foo {\n-    fn f(self: Pin<&Self>) -> impl Clone { self } //~ ERROR cannot infer an appropriate lifetime\n+    fn f(self: Pin<&Self>) -> impl Clone { self } //~ ERROR E0759\n }\n \n fn main() {"}, {"sha": "cb9d5b56dbc5cbd585691e8647bf4a224f660776", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }"}, {"sha": "acf0c0ece402010799a0af429648e19f0d4f98a4", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.nll.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,37 @@\n+error[E0597]: `val` does not live long enough\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:21:9\n+   |\n+LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n+   |               -- lifetime `'a` defined here                  ------------------- opaque type requires that `val` is borrowed for `'a`\n+LL |         val.use_self()\n+   |         ^^^ borrowed value does not live long enough\n+LL |     }\n+   |     - `val` dropped here while still borrowed\n+   |\n+help: you can add a bound to the opaque type to make it last less than `'static` and match `'a`\n+   |\n+LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> + 'a {\n+   |                                                                                  ^^^^\n+\n+error[E0515]: cannot return value referencing function parameter `val`\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:43:9\n+   |\n+LL |         val.use_self()\n+   |         ---^^^^^^^^^^^\n+   |         |\n+   |         returns a value referencing data owned by the current function\n+   |         `val` is borrowed here\n+\n+error[E0515]: cannot return value referencing function parameter `val`\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:109:9\n+   |\n+LL |         val.use_self()\n+   |         ---^^^^^^^^^^^\n+   |         |\n+   |         returns a value referencing data owned by the current function\n+   |         `val` is borrowed here\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0515, E0597.\n+For more information about an error, try `rustc --explain E0515`."}, {"sha": "b2dc16a27e310006490f28118a9781421bc3b9d4", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,113 @@\n+// FIXME: the following cases need to suggest more things to make users reach a working end state.\n+\n+mod bav {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {\n+        type Assoc: Bar;\n+    }\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Bar {}\n+\n+    impl MyTrait for Box<dyn ObjectTrait<Assoc = i32>> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Bar for i32 {}\n+\n+    fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n+        val.use_self() //~ ERROR E0597\n+    }\n+}\n+\n+mod bap {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {\n+        type Assoc: Bar;\n+    }\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Bar {}\n+\n+    impl MyTrait for Box<dyn ObjectTrait<Assoc = i32>> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Bar for i32 {}\n+\n+    fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR E0515\n+    }\n+}\n+\n+// This case in particular requires the user to write all of the bounds we have in `mod bax`.\n+mod bay {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {\n+        type Assoc: Bar;\n+    }\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Bar {}\n+\n+    impl MyTrait for Box<dyn ObjectTrait<Assoc = i32>> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Bar for i32 {}\n+\n+    fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32> + 'a>) -> &'a () {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod bax {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {\n+        type Assoc: Bar;\n+    }\n+    trait MyTrait<'a> {\n+        fn use_self(&'a self) -> &'a () { panic!() }\n+    }\n+    trait Bar {}\n+\n+    impl<'a> MyTrait<'a> for Box<dyn ObjectTrait<Assoc = i32> + 'a> {\n+        fn use_self(&'a self) -> &'a () { panic!() }\n+    }\n+    impl Bar for i32 {}\n+\n+    fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32> + 'a>) -> &'a () {\n+        val.use_self()\n+    }\n+}\n+\n+mod baw {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {\n+        type Assoc: Bar;\n+    }\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Bar {}\n+\n+    impl<'a> MyTrait for Box<dyn ObjectTrait<Assoc = Box<dyn Bar>>> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = Box<dyn Bar>>>) -> impl OtherTrait<'a> + 'a{\n+        val.use_self() //~ ERROR E0515\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "00971b41c7ce652e5b2bffc185aab7278d7324df", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,57 @@\n+error[E0597]: `val` does not live long enough\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:21:9\n+   |\n+LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> {\n+   |               -- lifetime `'a` defined here                  ------------------- opaque type requires that `val` is borrowed for `'a`\n+LL |         val.use_self()\n+   |         ^^^ borrowed value does not live long enough\n+LL |     }\n+   |     - `val` dropped here while still borrowed\n+   |\n+help: you can add a bound to the opaque type to make it last less than `'static` and match `'a`\n+   |\n+LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32>>) -> impl OtherTrait<'a> + 'a {\n+   |                                                                                  ^^^^\n+\n+error[E0515]: cannot return value referencing function parameter `val`\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:43:9\n+   |\n+LL |         val.use_self()\n+   |         ---^^^^^^^^^^^\n+   |         |\n+   |         returns a value referencing data owned by the current function\n+   |         `val` is borrowed here\n+\n+error[E0515]: cannot return value referencing function parameter `val`\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:109:9\n+   |\n+LL |         val.use_self()\n+   |         ---^^^^^^^^^^^\n+   |         |\n+   |         returns a value referencing data owned by the current function\n+   |         `val` is borrowed here\n+\n+error[E0772]: `val` has lifetime `'a` but calling `use_self` introduces an implicit `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:66:13\n+   |\n+LL |     fn use_it<'a>(val: Box<dyn ObjectTrait<Assoc = i32> + 'a>) -> &'a () {\n+   |                        -------------------------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound-needing-more-suggestions.rs:60:30\n+   |\n+LL |     impl MyTrait for Box<dyn ObjectTrait<Assoc = i32>> {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for Box<dyn ObjectTrait<Assoc = i32> + '_> {\n+   |                                                       ^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0515, E0597.\n+For more information about an error, try `rustc --explain E0515`."}, {"sha": "3c10f85d9423a8997ad77f5b4e10006113d118ae", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.fixed", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.fixed?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,112 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+mod foo {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait<T> {}\n+    trait MyTrait<T> {\n+        fn use_self<K>(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n+        fn use_self<K>(&self) -> &() { panic!() }\n+    }\n+    impl<T> Irrelevant for dyn ObjectTrait<T> {}\n+\n+    fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+        val.use_self::<T>() //~ ERROR E0759\n+    }\n+}\n+\n+mod bar {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl MyTrait for dyn ObjectTrait + '_ {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Irrelevant for dyn ObjectTrait {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod baz {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl MyTrait for Box<dyn ObjectTrait + '_> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Irrelevant for Box<dyn ObjectTrait> {}\n+\n+    fn use_it<'a>(val: &'a Box<dyn ObjectTrait + 'a>) -> &'a () {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod bat {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+\n+    impl dyn ObjectTrait + '_ {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod ban {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Irrelevant {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait + '_ {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR E0759\n+    }\n+}\n+\n+mod bal {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Irrelevant {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait + '_ {}\n+    impl Irrelevant for dyn ObjectTrait {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        MyTrait::use_self(val) //~ ERROR E0759\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "697467dc3a6301d9da79db48f09eb9bc531314f9", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.nll.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,42 @@\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:20:9\n+   |\n+LL |     fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+   |                      --- `val` is a reference that is only valid in the function body\n+LL |         val.use_self::<T>()\n+   |         ^^^^^^^^^^^^^^^^^^^ `val` escapes the function body here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:69:9\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                   --- `val` is a reference that is only valid in the function body\n+LL |         val.use_self()\n+   |         ^^^^^^^^^^^^^^ `val` escapes the function body here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:88:9\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n+   |                   --- `val` is a reference that is only valid in the function body\n+LL |         val.use_self()\n+   |         ^^^^^^^^^^^^^^ `val` escapes the function body here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:108:9\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                   --- `val` is a reference that is only valid in the function body\n+LL |         MyTrait::use_self(val)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^ `val` escapes the function body here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "88ab03dfc1ef1837d584cc9ffadbb40b4bf584a9", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,112 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+mod foo {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait<T> {}\n+    trait MyTrait<T> {\n+        fn use_self<K>(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n+        fn use_self<K>(&self) -> &() { panic!() }\n+    }\n+    impl<T> Irrelevant for dyn ObjectTrait<T> {}\n+\n+    fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+        val.use_self::<T>() //~ ERROR E0759\n+    }\n+}\n+\n+mod bar {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl MyTrait for dyn ObjectTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Irrelevant for dyn ObjectTrait {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod baz {\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &();\n+    }\n+    trait Irrelevant {}\n+\n+    impl MyTrait for Box<dyn ObjectTrait> {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    impl Irrelevant for Box<dyn ObjectTrait> {}\n+\n+    fn use_it<'a>(val: &'a Box<dyn ObjectTrait + 'a>) -> &'a () {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod bat {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+\n+    impl dyn ObjectTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        val.use_self() //~ ERROR E0772\n+    }\n+}\n+\n+mod ban {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Irrelevant {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n+        val.use_self() //~ ERROR E0759\n+    }\n+}\n+\n+mod bal {\n+    trait OtherTrait<'a> {}\n+    impl<'a> OtherTrait<'a> for &'a () {}\n+\n+    trait ObjectTrait {}\n+    trait MyTrait {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+    trait Irrelevant {\n+        fn use_self(&self) -> &() { panic!() }\n+    }\n+\n+    impl MyTrait for dyn ObjectTrait {}\n+    impl Irrelevant for dyn ObjectTrait {}\n+\n+    fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+        MyTrait::use_self(val) //~ ERROR E0759\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2fb6c25fd17028a417650e3419660658a11fa900", "filename": "src/test/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.stderr", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -0,0 +1,134 @@\n+error[E0759]: `val` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:20:13\n+   |\n+LL |     fn use_it<'a, T>(val: &'a dyn ObjectTrait<T>) -> impl OtherTrait<'a> + 'a {\n+   |                           ---------------------- this data with lifetime `'a`...\n+LL |         val.use_self::<T>()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:14:32\n+   |\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n+   |                                ^^^^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self<K>(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n+   |                                               ^^^^\n+\n+error[E0772]: `val` has lifetime `'a` but calling `use_self` introduces an implicit `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:69:13\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here because of an implicit lifetime bound on the inherent `impl`\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:64:14\n+   |\n+LL |     impl dyn ObjectTrait {\n+   |              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl dyn ObjectTrait + '_ {\n+   |                          ^^^^\n+\n+error[E0759]: `val` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:88:13\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:85:26\n+   |\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+...\n+LL |     impl MyTrait for dyn ObjectTrait {}\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {}\n+   |                                      ^^^^\n+help: to declare that the `impl Trait` captures data from argument `val`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                                                                    ^^^^\n+\n+error[E0759]: `val` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:108:27\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> impl OtherTrait<'a> + 'a {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         MyTrait::use_self(val)\n+   |                           ^^^ ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:108:9\n+   |\n+LL |         MyTrait::use_self(val)\n+   |         ^^^^^^^^^^^^^^^^^\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:104:26\n+   |\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+...\n+LL |     impl MyTrait for dyn ObjectTrait {}\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {}\n+   |                                      ^^^^\n+\n+error[E0772]: `val` has lifetime `'a` but calling `use_self` introduces an implicit `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:37:13\n+   |\n+LL |     fn use_it<'a>(val: &'a dyn ObjectTrait) -> &'a () {\n+   |                        ------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:31:26\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait {\n+   |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for dyn ObjectTrait + '_ {\n+   |                                      ^^^^\n+\n+error[E0772]: `val` has lifetime `'a` but calling `use_self` introduces an implicit `'static` lifetime requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:54:13\n+   |\n+LL |     fn use_it<'a>(val: &'a Box<dyn ObjectTrait + 'a>) -> &'a () {\n+   |                        ----------------------------- this data with lifetime `'a`...\n+LL |         val.use_self()\n+   |             ^^^^^^^^ ...is captured and required to live as long as `'static` here\n+   |\n+note: the used `impl` has a `'static` requirement\n+  --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:48:30\n+   |\n+LL |     impl MyTrait for Box<dyn ObjectTrait> {\n+   |                              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n+LL |         fn use_self(&self) -> &() { panic!() }\n+   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL |     impl MyTrait for Box<dyn ObjectTrait + '_> {\n+   |                                          ^^^^\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "94dd826a15cae71be3d0881f4bbeba350e2c2c38", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -16,7 +16,7 @@ fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n where\n     G: Get<T>\n {\n-    move || { //~ ERROR cannot infer an appropriate lifetime\n+    move || { //~ ERROR `dest`\n         *dest = g.get();\n     }\n }"}, {"sha": "d7051515f11029c04401888c11f9407e529b5a60", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -6,7 +6,7 @@ LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `dest` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/missing-lifetimes-in-signature.rs:19:5\n    |\n LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()"}, {"sha": "d8446e58dbb63eb9e7b593d69e6ae660492a232e", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -27,7 +27,7 @@ impl Bar {\n     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n         Iter {\n             current: None,\n-            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+            remaining: self.0.iter(), //~ ERROR E0759\n         }\n     }\n }\n@@ -38,7 +38,7 @@ impl Baz {\n     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n         Iter {\n             current: None,\n-            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+            remaining: self.0.iter(), //~ ERROR E0759\n         }\n     }\n }\n@@ -49,7 +49,7 @@ impl Bat {\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n         Iter {\n             current: None,\n-            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+            remaining: self.0.iter(), //~ ERROR E0759\n         }\n     }\n }\n@@ -60,7 +60,7 @@ impl Ban {\n     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n         Iter {\n             current: None,\n-            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+            remaining: self.0.iter(), //~ ERROR E0759\n         }\n     }\n }"}, {"sha": "9f30787f07cc6d9d9114805811f52a0b0323191a", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/trait-object-nested-in-impl-trait.rs:30:31\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n@@ -23,7 +23,7 @@ help: to declare that the trait object captures data from argument `self`, you c\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> {\n    |                                                        ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/trait-object-nested-in-impl-trait.rs:41:31\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n@@ -44,7 +44,7 @@ help: to declare that the trait object captures data from argument `self`, you c\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n    |                                                        ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/trait-object-nested-in-impl-trait.rs:52:31\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n@@ -65,7 +65,7 @@ help: to declare that the trait object captures data from argument `self`, you c\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n    |                                                               ^^^^\n \n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `self` has lifetime `'a` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/trait-object-nested-in-impl-trait.rs:63:31\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {"}, {"sha": "e951adf030f5c2e9e958b2b45b31839832ec43e1", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -5,7 +5,7 @@\n \n fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n-    Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+    Box::new(items.iter()) //~ ERROR E0759\n }\n \n fn b<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {"}, {"sha": "dd804864dab4f59e0eb96f063b2223e50aa21978", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9babbaede1643ddc10cd34140a58d0107db1ec/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=fe9babbaede1643ddc10cd34140a58d0107db1ec", "patch": "@@ -1,4 +1,4 @@\n-error[E0759]: cannot infer an appropriate lifetime\n+error[E0759]: `items` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/dyn-trait-underscore.rs:8:20\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {"}]}