{"sha": "3afadaad4f087c86b1a8509109f544214ecad45f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZmFkYWFkNGYwODdjODZiMWE4NTA5MTA5ZjU0NDIxNGVjYWQ0NWY=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-20T15:31:55Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-21T20:37:30Z"}, "message": "Fix accordingly to review", "tree": {"sha": "499feb0d3b3c330835980becd57451f3edcdfbd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/499feb0d3b3c330835980becd57451f3edcdfbd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3afadaad4f087c86b1a8509109f544214ecad45f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3afadaad4f087c86b1a8509109f544214ecad45f", "html_url": "https://github.com/rust-lang/rust/commit/3afadaad4f087c86b1a8509109f544214ecad45f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3afadaad4f087c86b1a8509109f544214ecad45f/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d29954b2f2c3e079372bbaaee2ed64c1674046b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d29954b2f2c3e079372bbaaee2ed64c1674046b", "html_url": "https://github.com/rust-lang/rust/commit/5d29954b2f2c3e079372bbaaee2ed64c1674046b"}], "stats": {"total": 42, "additions": 20, "deletions": 22}, "files": [{"sha": "cc9cad2162b1b761a666e1b238dbc1192fbd46c9", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3afadaad4f087c86b1a8509109f544214ecad45f/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3afadaad4f087c86b1a8509109f544214ecad45f/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=3afadaad4f087c86b1a8509109f544214ecad45f", "patch": "@@ -288,13 +288,15 @@ mod lazy {\n         }\n \n         pub unsafe fn get(&self) -> Option<&'static T> {\n-            // SAFETY: No reference is ever handed out to the inner cell nor\n-            // mutable reference to the Option<T> inside said cell. This make it\n-            // safe to hand a reference, though the lifetime of 'static\n-            // is itself unsafe, making the get method unsafe.\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n             unsafe { (*self.inner.get()).as_ref() }\n         }\n \n+        /// The caller must ensure that no reference is active: this method\n+        /// needs unique access.\n         pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n             // Execute the initialization up front, *then* move it into our slot,\n             // just in case initialization fails.\n@@ -316,20 +318,13 @@ mod lazy {\n             // destructor\" flag we just use `mem::replace` which should sequence the\n             // operations a little differently and make this safe to call.\n             //\n-            // `ptr` can be dereferenced safely since it was obtained from\n-            // `UnsafeCell::get`, which should not return a non-aligned or NUL pointer.\n-            // What's more a `LazyKeyInner` can only be created with `new`, which ensures\n-            // `inner` is correctly initialized and all calls to methods on `LazyKeyInner`\n-            // will leave `inner` initialized too.\n+            // The precondition also ensures that we are the only one accessing\n+            // `self` at the moment so replacing is fine.\n             unsafe {\n                 let _ = mem::replace(&mut *ptr, Some(value));\n             }\n \n-            // SAFETY: the `*ptr` operation is made safe by the `mem::replace`\n-            // call above combined with `ptr` being correct from the beginning\n-            // (see previous SAFETY: comment above).\n-            //\n-            // Plus, with the call to `mem::replace` it is guaranteed there is\n+            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n             // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n             // will never be reached.\n             unsafe {\n@@ -345,11 +340,12 @@ mod lazy {\n             }\n         }\n \n+        /// The other methods hand out references while taking &self.\n+        /// As such, callers of this method must ensure no `&` and `&mut` are\n+        /// available and used at the same time.\n         #[allow(unused)]\n         pub unsafe fn take(&mut self) -> Option<T> {\n-            // SAFETY: The other methods hand out references while taking &self.\n-            // As such, callers of this method must ensure no `&` and `&mut` are\n-            // available and used at the same time.\n+            // SAFETY: See doc comment for this method.\n             unsafe { (*self.inner.get()).take() }\n         }\n     }\n@@ -442,9 +438,10 @@ pub mod fast {\n             // SAFETY: See the definitions of `LazyKeyInner::get` and\n             // `try_initialize` for more informations.\n             //\n-            // The call to `get` is made safe because no mutable references are\n-            // ever handed out and the `try_initialize` is dependant on the\n-            // passed `init` function.\n+            // The caller must ensure no mutable references are ever active to\n+            // the inner cell or the inner T when this is called.\n+            // The `try_initialize` is dependant on the passed `init` function\n+            // for this.\n             unsafe {\n                 match self.inner.get() {\n                     Some(val) => Some(val),\n@@ -549,9 +546,10 @@ pub mod os {\n             Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n         }\n \n+        /// It is a requirement for the caller to ensure that no mutable\n+        /// reference is active when this method is called.\n         pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n-            // SAFETY: No mutable references are ever handed out meaning getting\n-            // the value is ok.\n+            // SAFETY: See the documentation for this method.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n             if ptr as usize > 1 {\n                 // SAFETY: the check ensured the pointer is safe (its destructor"}]}