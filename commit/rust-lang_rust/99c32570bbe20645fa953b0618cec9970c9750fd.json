{"sha": "99c32570bbe20645fa953b0618cec9970c9750fd", "node_id": "C_kwDOAAsO6NoAKDk5YzMyNTcwYmJlMjA2NDVmYTk1M2IwNjE4Y2VjOTk3MGM5NzUwZmQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T00:03:02Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T07:39:28Z"}, "message": "Do if-expression obligation stuff less eagerly", "tree": {"sha": "4fa9cd5b080097bbd520dde617928c8d27a95351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fa9cd5b080097bbd520dde617928c8d27a95351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c32570bbe20645fa953b0618cec9970c9750fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c32570bbe20645fa953b0618cec9970c9750fd", "html_url": "https://github.com/rust-lang/rust/commit/99c32570bbe20645fa953b0618cec9970c9750fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c32570bbe20645fa953b0618cec9970c9750fd/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d9dd681f520d1d59f38aed0056cf9474894cc74", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9dd681f520d1d59f38aed0056cf9474894cc74", "html_url": "https://github.com/rust-lang/rust/commit/3d9dd681f520d1d59f38aed0056cf9474894cc74"}], "stats": {"total": 761, "additions": 411, "deletions": 350}, "files": [{"sha": "d6e183dd5a3bbd6f89613e9d2dc6b49d24df2e57", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -954,6 +954,16 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n+impl<'hir> Block<'hir> {\n+    pub fn peel_blocks(&self) -> &Block<'hir> {\n+        let mut block = self;\n+        while let Some(Expr { kind: ExprKind::Block(inner_block, _), .. }) = block.expr {\n+            block = inner_block;\n+        }\n+        block\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]"}, {"sha": "a8fc306b28677997b8454f5835320ea889b9ea5e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 297, "deletions": 38, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -721,25 +721,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             },\n             ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then,\n-                else_sp,\n-                outer,\n-                semicolon,\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             }) => {\n-                err.span_label(then, \"expected because of this\");\n-                if let Some(sp) = outer {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(then_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n+                let semicolon = if let hir::Node::Block(blk) = self.tcx.hir().get(then_id)\n+                    && let Some(remove_semicolon) = self.could_remove_semicolon(blk, else_ty)\n+                {\n+                    Some(remove_semicolon)\n+                } else if let hir::Node::Block(blk) = self.tcx.hir().get(else_id)\n+                    && let Some(remove_semicolon) = self.could_remove_semicolon(blk, then_ty)\n+                {\n+                    Some(remove_semicolon)\n+                } else {\n+                    None\n+                };\n                 if let Some((sp, boxed)) = semicolon {\n                     if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n                         err.multipart_suggestion(\n                             \"consider removing this semicolon and boxing the expression\",\n                             vec![\n-                                (then.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (then.shrink_to_hi(), \")\".to_string()),\n-                                (else_sp.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (else_sp.shrink_to_hi(), \")\".to_string()),\n+                                (then_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (then_span.shrink_to_hi(), \")\".to_string()),\n+                                (else_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (else_span.shrink_to_hi(), \")\".to_string()),\n                                 (sp, String::new()),\n                             ],\n                             Applicability::MachineApplicable,\n@@ -752,12 +766,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n+                } else {\n+                    let suggested = if let hir::Node::Block(blk) = self.tcx.hir().get(then_id) {\n+                        self.consider_returning_binding(blk, else_ty, err)\n+                    } else {\n+                        false\n+                    };\n+                    if !suggested && let hir::Node::Block(blk) = self.tcx.hir().get(else_id) {\n+                        self.consider_returning_binding(blk, then_ty, err);\n+                    }\n                 }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,\n                         ret_sp,\n-                        [then, else_sp].into_iter(),\n+                        [then_span, else_span].into_iter(),\n                     );\n                 }\n             }\n@@ -1870,40 +1893,41 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n             self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n-            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => {\n-                match cause.code() {\n-                    ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n                         diag.multipart_suggestion(\n                             \"consider `await`ing on both `Future`s\",\n                             vec![\n-                                (then.shrink_to_hi(), \".await\".to_string()),\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n                                 (exp_span.shrink_to_hi(), \".await\".to_string()),\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                    }\n-                    ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                        prior_arms,\n-                        ..\n-                    }) => {\n-                        if let [.., arm_span] = &prior_arms[..] {\n-                            diag.multipart_suggestion(\n-                                \"consider `await`ing on both `Future`s\",\n-                                vec![\n-                                    (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                    (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            diag.help(\"consider `await`ing on both `Future`s\");\n-                        }\n-                    }\n-                    _ => {\n+                    } else {\n                         diag.help(\"consider `await`ing on both `Future`s\");\n                     }\n                 }\n-            }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n             (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n                 diag.span_suggestion_verbose(\n                     exp_span.shrink_to_hi(),\n@@ -1914,10 +1938,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n             {\n-                ObligationCauseCode::Pattern { span: Some(span), .. }\n-                | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n                     diag.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n+                        then_span.shrink_to_hi(),\n                         \"consider `await`ing on the `Future`\",\n                         \".await\",\n                         Applicability::MaybeIncorrect,\n@@ -2808,3 +2840,230 @@ impl TyCategory {\n         }\n     }\n }\n+\n+impl<'tcx> InferCtxt<'_, 'tcx> {\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.peel_blocks();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen...\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.peel_blocks();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        // Be helpful when the user wrote `{... expr;}` and\n+        // taking the `;` off is enough to fix the error.\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.in_progress_typeck_results?.borrow().expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.peel_blocks();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxHashSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .in_progress_typeck_results\n+                    .and_then(|typeck_results| typeck_results.borrow().node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "7a38c800ccf5fe7a171b73ef7a98e61c9c0af07d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -351,7 +351,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ConstPatternStructural,\n \n     /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n+    IfExpression(Box<IfExpressionCause<'tcx>>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -498,12 +498,14 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub else_sp: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<(Span, StatementAsExpression)>,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Lift, TypeFoldable, TypeVisitable)]\n+pub struct IfExpressionCause<'tcx> {\n+    pub then_id: hir::HirId,\n+    pub else_id: hir::HirId,\n+    pub then_ty: Ty<'tcx>,\n+    pub else_ty: Ty<'tcx>,\n+    pub outer_span: Option<Span>,\n     pub opt_suggest_box_span: Option<Span>,\n }\n "}, {"sha": "7fbd57ac7354aa2691dfec008de1a25618e355ea", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -130,7 +130,6 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n // Lift implementations\n \n TrivialTypeTraversalAndLiftImpls! {\n-    super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n     super::ImplSourcePointeeData,\n }"}, {"sha": "00547a6d8278fb054aaf71c6b904d8297ac160c9", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -216,13 +216,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Span, Option<(Span, StatementAsExpression)>) {\n         let arm = &arms[i];\n         let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-            self.find_block_span(blk, prior_arm_ty)\n+            (\n+                self.find_block_span(blk),\n+                prior_arm_ty\n+                    .and_then(|prior_arm_ty| self.could_remove_semicolon(blk, prior_arm_ty)),\n+            )\n         } else {\n             (arm.body.span, None)\n         };\n         if semi_span.is_none() && i > 0 {\n             if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n-                let (_, semi_span_prev) = self.find_block_span(blk, Some(arm_ty));\n+                let semi_span_prev = self.could_remove_semicolon(blk, arm_ty);\n                 semi_span = semi_span_prev;\n             }\n         }\n@@ -313,7 +317,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_ty: Ty<'tcx>,\n         opt_suggest_box_span: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n-        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n+        let mut outer_span = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n             // clear it is an if/else expression:\n             // ```\n@@ -339,69 +343,67 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        let mut remove_semicolon = None;\n-        let error_sp = if let ExprKind::Block(block, _) = &else_expr.kind {\n-            let (error_sp, semi_sp) = self.find_block_span(block, Some(then_ty));\n-            remove_semicolon = semi_sp;\n-            if block.expr.is_none() && block.stmts.is_empty() {\n-                // Avoid overlapping spans that aren't as readable:\n-                // ```\n-                // 2 |        let x = if true {\n-                //   |   _____________-\n-                // 3 |  |         3\n-                //   |  |         - expected because of this\n-                // 4 |  |     } else {\n-                //   |  |____________^\n-                // 5 | ||\n-                // 6 | ||     };\n-                //   | ||     ^\n-                //   | ||_____|\n-                //   | |______if and else have incompatible types\n-                //   |        expected integer, found `()`\n-                // ```\n-                // by not pointing at the entire expression:\n-                // ```\n-                // 2 |       let x = if true {\n-                //   |               ------- `if` and `else` have incompatible types\n-                // 3 |           3\n-                //   |           - expected because of this\n-                // 4 |       } else {\n-                //   |  ____________^\n-                // 5 | |\n-                // 6 | |     };\n-                //   | |_____^ expected integer, found `()`\n-                // ```\n-                if outer_sp.is_some() {\n-                    outer_sp = Some(self.tcx.sess.source_map().guess_head_span(span));\n-                }\n+        let (error_sp, else_id) = if let ExprKind::Block(block, _) = &else_expr.kind {\n+            let block = block.peel_blocks();\n+\n+            // Avoid overlapping spans that aren't as readable:\n+            // ```\n+            // 2 |        let x = if true {\n+            //   |   _____________-\n+            // 3 |  |         3\n+            //   |  |         - expected because of this\n+            // 4 |  |     } else {\n+            //   |  |____________^\n+            // 5 | ||\n+            // 6 | ||     };\n+            //   | ||     ^\n+            //   | ||_____|\n+            //   | |______if and else have incompatible types\n+            //   |        expected integer, found `()`\n+            // ```\n+            // by not pointing at the entire expression:\n+            // ```\n+            // 2 |       let x = if true {\n+            //   |               ------- `if` and `else` have incompatible types\n+            // 3 |           3\n+            //   |           - expected because of this\n+            // 4 |       } else {\n+            //   |  ____________^\n+            // 5 | |\n+            // 6 | |     };\n+            //   | |_____^ expected integer, found `()`\n+            // ```\n+            if block.expr.is_none() && block.stmts.is_empty()\n+                && let Some(outer_span) = &mut outer_span\n+            {\n+                *outer_span = self.tcx.sess.source_map().guess_head_span(*outer_span);\n             }\n-            error_sp\n+\n+            (self.find_block_span(block), block.hir_id)\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            else_expr.span\n+            (else_expr.span, else_expr.hir_id)\n         };\n \n-        // Compute `Span` of `then` part of `if`-expression.\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.kind {\n-            let (then_sp, semi_sp) = self.find_block_span(block, Some(else_ty));\n-            remove_semicolon = remove_semicolon.or(semi_sp);\n+        let then_id = if let ExprKind::Block(block, _) = &then_expr.kind {\n+            let block = block.peel_blocks();\n+            // Exclude overlapping spans\n             if block.expr.is_none() && block.stmts.is_empty() {\n-                outer_sp = None; // same as in `error_sp`; cleanup output\n+                outer_span = None;\n             }\n-            then_sp\n+            block.hir_id\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            then_expr.span\n+            then_expr.hir_id\n         };\n \n         // Finally construct the cause:\n         self.cause(\n             error_sp,\n             ObligationCauseCode::IfExpression(Box::new(IfExpressionCause {\n-                then: then_sp,\n-                else_sp: error_sp,\n-                outer: outer_sp,\n-                semicolon: remove_semicolon,\n+                else_id,\n+                then_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             })),\n         )\n@@ -482,22 +484,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_block_span(\n-        &self,\n-        block: &'tcx hir::Block<'tcx>,\n-        expected_ty: Option<Ty<'tcx>>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        if let Some(expr) = &block.expr {\n-            (expr.span, None)\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            (stmt.span, expected_ty.and_then(|ty| self.could_remove_semicolon(block, ty)))\n-        } else {\n-            // empty block; point at its entirety\n-            (block.span, None)\n-        }\n-    }\n-\n     // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n     // we check if the different arms would work with boxed trait objects instead and\n     // provide a structured suggestion in that case."}, {"sha": "21b3c9063a78a85331e4caf8ed7a5c252efce94f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -30,17 +30,15 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n };\n \n use std::collections::hash_map::Entry;\n-use std::iter;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1059,84 +1057,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ));\n     }\n \n-    pub(in super::super) fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        // Be helpful when the user wrote `{... expr;}` and\n-        // taking the `;` off is enough to fix the error.\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => StatementAsExpression::CorrectType,\n-        };\n-        if (matches!(last_expr_ty.kind(), ty::Error(_))\n-            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err())\n-            && matches!(needs_box, StatementAsExpression::CorrectType)\n-        {\n-            return None;\n-        }\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     #[instrument(skip(self, span), level = \"debug\")]"}, {"sha": "3e6ff72204f4c49b6c02349d8588058d0ccd4566", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 115, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -14,7 +13,7 @@ use rustc_hir::{\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -904,117 +903,4 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             false\n         }\n     }\n-\n-    pub(crate) fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) {\n-        let mut shadowed = FxHashSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self.typeck_results.borrow().node_type_opt(*hir_id)\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.can_coerce(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-            }\n-            _ => {}\n-        }\n-    }\n }"}, {"sha": "e5887689690e76fd5066d2193ae5613782cfe0b2", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -18,14 +18,6 @@ LL | |             break 0u8;\n LL | |         };\n    | |_________- enclosing `async` block\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n-   |\n-LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected `()`, found `u8`\n-   |\n-   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n-\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:21:58\n    |\n@@ -40,7 +32,7 @@ LL | | }\n    | |_^ expected `u8`, found `()`\n \n error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n@@ -55,6 +47,14 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n+error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+   |\n+LL |     let _: &dyn Future<Output = ()> = &block;\n+   |                                       ^^^^^^ expected `()`, found `u8`\n+   |\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n+\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:47:44\n    |"}, {"sha": "4fabc411abcbe8c8b4e16935d4853079194a6018", "filename": "src/test/ui/suggestions/return-bindings.fixed", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d9dd681f520d1d59f38aed0056cf9474894cc74/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3d9dd681f520d1d59f38aed0056cf9474894cc74/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed?ref=3d9dd681f520d1d59f38aed0056cf9474894cc74", "patch": "@@ -1,23 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused)]\n-\n-fn a(i: i32) -> i32 { i }\n-//~^ ERROR mismatched types\n-\n-fn b(opt_str: Option<String>) {\n-    let s: String = if let Some(s) = opt_str {\n-        s\n-    //~^ ERROR mismatched types\n-    } else {\n-        String::new()\n-    };\n-}\n-\n-fn c() -> Option<i32> {\n-    //~^ ERROR mismatched types\n-    let x = Some(1);\n-    x\n-}\n-\n-fn main() {}"}, {"sha": "80c83a70d50c136e85e231913df4597856c0178e", "filename": "src/test/ui/suggestions/return-bindings.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -1,5 +1,3 @@\n-// run-rustfix\n-\n #![allow(unused)]\n \n fn a(i: i32) -> i32 {}\n@@ -18,4 +16,12 @@ fn c() -> Option<i32> {\n     let x = Some(1);\n }\n \n+fn d(opt_str: Option<String>) {\n+    let s: String = if let Some(s) = opt_str {\n+        //~^ ERROR mismatched types\n+    } else {\n+        String::new()\n+    };\n+}\n+\n fn main() {}"}, {"sha": "53ef7106fa80861dacebd3dc70c10f4ce78de5ef", "filename": "src/test/ui/suggestions/return-bindings.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99c32570bbe20645fa953b0618cec9970c9750fd/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr?ref=99c32570bbe20645fa953b0618cec9970c9750fd", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:5:17\n+  --> $DIR/return-bindings.rs:3:17\n    |\n LL | fn a(i: i32) -> i32 {}\n    |    -            ^^^ expected `i32`, found `()`\n@@ -12,7 +12,7 @@ LL | fn a(i: i32) -> i32 { i }\n    |                       +\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:9:46\n+  --> $DIR/return-bindings.rs:7:46\n    |\n LL |       let s: String = if let Some(s) = opt_str {\n    |  ______________________________________________^\n@@ -28,7 +28,7 @@ LL ~\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:16:11\n+  --> $DIR/return-bindings.rs:14:11\n    |\n LL | fn c() -> Option<i32> {\n    |    -      ^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -43,6 +43,22 @@ LL ~     let x = Some(1);\n LL +     x\n    |\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:20:46\n+   |\n+LL |       let s: String = if let Some(s) = opt_str {\n+   |  ______________________________________________^\n+LL | |\n+LL | |     } else {\n+   | |_____^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s: String = if let Some(s) = opt_str {\n+LL +         s\n+LL ~\n+   |\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}