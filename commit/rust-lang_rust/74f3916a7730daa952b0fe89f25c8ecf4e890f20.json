{"sha": "74f3916a7730daa952b0fe89f25c8ecf4e890f20", "node_id": "C_kwDOAAsO6NoAKDc0ZjM5MTZhNzczMGRhYTk1MmIwZmU4OWYyNWM4ZWNmNGU4OTBmMjA", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-06-09T13:18:41Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-06-09T13:18:41Z"}, "message": "Sync from rust be16c6166f08f9b26d854783bbd4ce8d006c8f6f", "tree": {"sha": "53dc6f06e99db20e943845de024151f1e59904d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53dc6f06e99db20e943845de024151f1e59904d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f3916a7730daa952b0fe89f25c8ecf4e890f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f3916a7730daa952b0fe89f25c8ecf4e890f20", "html_url": "https://github.com/rust-lang/rust/commit/74f3916a7730daa952b0fe89f25c8ecf4e890f20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f3916a7730daa952b0fe89f25c8ecf4e890f20/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d628444e480c0c62350a34cf8b26370f92238b6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d628444e480c0c62350a34cf8b26370f92238b6a", "html_url": "https://github.com/rust-lang/rust/commit/d628444e480c0c62350a34cf8b26370f92238b6a"}, {"sha": "b867d41ed42c8ef5cd13a78d299577c3d4ab589b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b867d41ed42c8ef5cd13a78d299577c3d4ab589b", "html_url": "https://github.com/rust-lang/rust/commit/b867d41ed42c8ef5cd13a78d299577c3d4ab589b"}], "stats": {"total": 194, "additions": 99, "deletions": 95}, "files": [{"sha": "ffa5d747b1160c01bdfbf6f0b73f002dacacd12a", "filename": "src/abi/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -23,6 +23,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n ) -> Signature {\n     let call_conv = match fn_abi.conv {\n         Conv::Rust | Conv::C => default_call_conv,\n+        Conv::RustCold => CallConv::Cold,\n         Conv::X86_64SysV => CallConv::SystemV,\n         Conv::X86_64Win64 => CallConv::WindowsFastcall,\n         Conv::ArmAapcs\n@@ -312,13 +313,14 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     source_info: mir::SourceInfo,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n-    mir_dest: Option<(Place<'tcx>, BasicBlock)>,\n+    destination: Place<'tcx>,\n+    target: Option<BasicBlock>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n     let fn_sig =\n         fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n-    let destination = mir_dest.map(|(place, bb)| (codegen_place(fx, place), bb));\n+    let ret_place = codegen_place(fx, destination);\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -333,7 +335,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 &fx.tcx.symbol_name(instance).name,\n                 substs,\n                 args,\n-                destination,\n+                ret_place,\n+                target,\n             );\n             return;\n         }\n@@ -344,14 +347,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     fx,\n                     instance,\n                     args,\n-                    destination,\n+                    ret_place,\n+                    target,\n                     source_info,\n                 );\n                 return;\n             }\n             InstanceDef::DropGlue(_, None) => {\n                 // empty drop glue - a nop.\n-                let (_, dest) = destination.expect(\"Non terminating drop_in_place_real???\");\n+                let dest = target.expect(\"Non terminating drop_in_place_real???\");\n                 let ret_block = fx.get_block(dest);\n                 fx.bcx.ins().jump(ret_block, &[]);\n                 return;\n@@ -377,7 +381,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         .unwrap_or(false);\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n-        if let Some((_place, destination_block)) = destination {\n+        if let Some(destination_block) = target {\n             fx.bcx.set_cold_block(fx.get_block(destination_block));\n         }\n     }\n@@ -459,7 +463,6 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n     };\n \n-    let ret_place = destination.map(|(place, _)| place);\n     self::returning::codegen_with_call_return_arg(fx, &fn_abi.ret, ret_place, |fx, return_ptr| {\n         let call_args = return_ptr\n             .into_iter()\n@@ -511,7 +514,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         call_inst\n     });\n \n-    if let Some((_, dest)) = destination {\n+    if let Some(dest) = target {\n         let ret_block = fx.get_block(dest);\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else {"}, {"sha": "ff3bb2dfd000f679f1a4d9779685443e7c7745b1", "filename": "src/abi/returning.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -56,23 +56,22 @@ pub(super) fn codegen_return_param<'tcx>(\n pub(super) fn codegen_with_call_return_arg<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n-    ret_place: Option<CPlace<'tcx>>,\n+    ret_place: CPlace<'tcx>,\n     f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> Inst,\n ) {\n     let (ret_temp_place, return_ptr) = match ret_arg_abi.mode {\n         PassMode::Ignore => (None, None),\n-        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n-            Some(ret_place) if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+            if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) {\n                 // This is an optimization to prevent unnecessary copies of the return value when\n                 // the return place is already a memory place as opposed to a register.\n                 // This match arm can be safely removed.\n                 (None, Some(ret_place.to_ptr().get_addr(fx)))\n-            }\n-            _ => {\n+            } else {\n                 let place = CPlace::new_stack_slot(fx, ret_arg_abi.layout);\n                 (Some(place), Some(place.to_ptr().get_addr(fx)))\n             }\n-        },\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n@@ -84,39 +83,25 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n     match ret_arg_abi.mode {\n         PassMode::Ignore => {}\n         PassMode::Direct(_) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n-            }\n+            let ret_val = fx.bcx.inst_results(call_inst)[0];\n+            ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n         }\n         PassMode::Pair(_, _) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n-                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(\n-                    fx,\n-                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n-                );\n-            }\n+            let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+            let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+            ret_place\n+                .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n         PassMode::Cast(cast) => {\n-            if let Some(ret_place) = ret_place {\n-                let results = fx\n-                    .bcx\n-                    .inst_results(call_inst)\n-                    .iter()\n-                    .copied()\n-                    .collect::<SmallVec<[Value; 2]>>();\n-                let result =\n-                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n-                ret_place.write_cvalue(fx, result);\n-            }\n+            let results =\n+                fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n+            let result =\n+                super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+            ret_place.write_cvalue(fx, result);\n         }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n-            if let (Some(ret_place), Some(ret_temp_place)) = (ret_place, ret_temp_place) {\n-                // Both ret_place and ret_temp_place must be Some. If ret_place is None, this is\n-                // a non-returning call. If ret_temp_place is None, it is not necessary to copy the\n-                // return value.\n+            if let Some(ret_temp_place) = ret_temp_place {\n+                // If ret_temp_place is None, it is not necessary to copy the return value.\n                 let ret_temp_value = ret_temp_place.to_cvalue(fx);\n                 ret_place.write_cvalue(fx, ret_temp_value);\n             }"}, {"sha": "07136e1b76a9f0895780db655019cc6326fce889", "filename": "src/base.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -393,6 +393,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 func,\n                 args,\n                 destination,\n+                target,\n                 fn_span,\n                 cleanup: _,\n                 from_hir_call: _,\n@@ -404,6 +405,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                         func,\n                         args,\n                         *destination,\n+                        *target,\n                     )\n                 });\n             }\n@@ -605,7 +607,13 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     lval.write_cvalue(fx, operand.cast_pointer_to(to_layout));\n                 }\n-                Rvalue::Cast(CastKind::Misc, ref operand, to_ty) => {\n+                Rvalue::Cast(\n+                    CastKind::Misc\n+                    | CastKind::PointerExposeAddress\n+                    | CastKind::PointerFromExposedAddress,\n+                    ref operand,\n+                    to_ty,\n+                ) => {\n                     let operand = codegen_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);"}, {"sha": "c7b05239eb77b8ae835a79166f7ba307581db313", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -542,8 +542,8 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     | TerminatorKind::FalseEdge { .. }\n                     | TerminatorKind::FalseUnwind { .. } => unreachable!(),\n                     TerminatorKind::InlineAsm { .. } => return None,\n-                    TerminatorKind::Call { destination: Some((call_place, _)), .. }\n-                        if call_place == place =>\n+                    TerminatorKind::Call { destination, target: Some(_), .. }\n+                        if destination == place =>\n                     {\n                         return None;\n                     }"}, {"sha": "05457ce15e9a7d8bfce0d6747bd888373e25f033", "filename": "src/driver/aot.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -66,11 +66,7 @@ fn emit_module(\n     let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &Some(tmp_file.clone()),\n-        )\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(tcx.sess, &name, &tmp_file)\n     };\n \n     ModuleCodegenResult(\n@@ -84,29 +80,24 @@ fn reuse_workproduct_for_cgu(\n     cgu: &CodegenUnit<'_>,\n     work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n ) -> CompiledModule {\n-    let mut object = None;\n-    let work_product = cgu.work_product(tcx);\n-    if let Some(saved_file) = &work_product.saved_file {\n-        let obj_out =\n-            tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-        object = Some(obj_out.clone());\n-        let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &saved_file);\n-        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-            tcx.sess.err(&format!(\n-                \"unable to copy {} to {}: {}\",\n-                source_file.display(),\n-                obj_out.display(),\n-                err\n-            ));\n-        }\n+    let work_product = cgu.previous_work_product(tcx);\n+    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &work_product.saved_file);\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+        tcx.sess.err(&format!(\n+            \"unable to copy {} to {}: {}\",\n+            source_file.display(),\n+            obj_out.display(),\n+            err\n+        ));\n     }\n \n     work_products.insert(cgu.work_product_id(), work_product);\n \n     CompiledModule {\n         name: cgu.name().to_string(),\n         kind: ModuleKind::Regular,\n-        object,\n+        object: Some(obj_out),\n         dwarf_object: None,\n         bytecode: None,\n     }"}, {"sha": "77ac46540a9ba88f8c65b47eb18d8e225f1b2555", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -10,10 +10,9 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     intrinsic: &str,\n     _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n ) {\n-    let ret = destination.unwrap().0;\n-\n     intrinsic_match! {\n         fx, intrinsic, args,\n         _ => {\n@@ -126,7 +125,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n     }\n \n-    let dest = destination.expect(\"all llvm intrinsics used by stdlib should return\").1;\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n     let ret_block = fx.get_block(dest);\n     fx.bcx.ins().jump(ret_block, &[]);\n }"}, {"sha": "6937e658ed5ee8a8abe7e5909637fe6611251905", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f3916a7730daa952b0fe89f25c8ecf4e890f20/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=74f3916a7730daa952b0fe89f25c8ecf4e890f20", "patch": "@@ -58,6 +58,7 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_target::abi::InitKind;\n \n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n@@ -217,35 +218,42 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+    destination: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n     source_info: mir::SourceInfo,\n ) {\n     let intrinsic = fx.tcx.item_name(instance.def_id());\n     let substs = instance.substs;\n \n-    let ret = match destination {\n-        Some((place, _)) => place,\n-        None => {\n-            // Insert non returning intrinsics here\n-            match intrinsic {\n-                sym::abort => {\n-                    fx.bcx.ins().trap(TrapCode::User(0));\n-                }\n-                sym::transmute => {\n-                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n-                }\n-                _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n+    let target = if let Some(target) = target {\n+        target\n+    } else {\n+        // Insert non returning intrinsics here\n+        match intrinsic {\n+            sym::abort => {\n+                fx.bcx.ins().trap(TrapCode::User(0));\n+            }\n+            sym::transmute => {\n+                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n             }\n-            return;\n+            _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n         }\n+        return;\n     };\n \n     if intrinsic.as_str().starts_with(\"simd_\") {\n-        self::simd::codegen_simd_intrinsic_call(fx, intrinsic, substs, args, ret, source_info.span);\n-        let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n+        self::simd::codegen_simd_intrinsic_call(\n+            fx,\n+            intrinsic,\n+            substs,\n+            args,\n+            destination,\n+            source_info.span,\n+        );\n+        let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n-    } else if codegen_float_intrinsic_call(fx, intrinsic, args, ret) {\n-        let ret_block = fx.get_block(destination.expect(\"Float intrinsics don't diverge\").1);\n+    } else if codegen_float_intrinsic_call(fx, intrinsic, args, destination) {\n+        let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else {\n         codegen_regular_intrinsic_call(\n@@ -254,9 +262,9 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             intrinsic,\n             substs,\n             args,\n-            ret,\n-            source_info,\n             destination,\n+            Some(target),\n+            source_info,\n         );\n     }\n }\n@@ -339,8 +347,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n+    destination: Option<BasicBlock>,\n     source_info: mir::SourceInfo,\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n@@ -664,7 +672,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n+            if intrinsic == sym::assert_zero_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Zero,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n@@ -675,7 +688,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n+            if intrinsic == sym::assert_uninit_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Uninit,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n@@ -761,7 +779,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap().1);\n+                        let ret_block = fx.get_block(destination.unwrap());\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n@@ -789,7 +807,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap().1);\n+                        let ret_block = fx.get_block(destination.unwrap());\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n@@ -1130,6 +1148,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n     }\n \n-    let ret_block = fx.get_block(destination.unwrap().1);\n+    let ret_block = fx.get_block(destination.unwrap());\n     fx.bcx.ins().jump(ret_block, &[]);\n }"}]}