{"sha": "0e61c0e231ccd1db200917c1adff35a0128dffe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjFjMGUyMzFjY2QxZGIyMDA5MTdjMWFkZmYzNWEwMTI4ZGZmZTg=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-11-20T19:04:17Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-14T17:28:20Z"}, "message": "Incorporate a bunch of review comments.", "tree": {"sha": "8d6b69cfa90f00f659c4b9284243697ee342c5b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d6b69cfa90f00f659c4b9284243697ee342c5b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e61c0e231ccd1db200917c1adff35a0128dffe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e61c0e231ccd1db200917c1adff35a0128dffe8", "html_url": "https://github.com/rust-lang/rust/commit/0e61c0e231ccd1db200917c1adff35a0128dffe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e61c0e231ccd1db200917c1adff35a0128dffe8/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7ec0dfcb68eee8a3313e47dd00dbb1709bdbcdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ec0dfcb68eee8a3313e47dd00dbb1709bdbcdd", "html_url": "https://github.com/rust-lang/rust/commit/c7ec0dfcb68eee8a3313e47dd00dbb1709bdbcdd"}], "stats": {"total": 107, "additions": 47, "deletions": 60}, "files": [{"sha": "3d73af28dc99cd8fd8826595ba7998257d04dd10", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0e61c0e231ccd1db200917c1adff35a0128dffe8", "patch": "@@ -512,14 +512,14 @@ pub struct Struct {\n     /// If true, the size is exact, otherwise it's only a lower bound.\n     pub sized: bool,\n \n-    /// Offsets for the first byte of each field, ordered to match the tys.\n+    /// Offsets for the first byte of each field, ordered to match the source definition order.\n     /// This vector does not go in increasing order.\n     /// FIXME(eddyb) use small vector optimization for the common case.\n     pub offsets: Vec<Size>,\n \n-    /// Maps field indices to GEP indices, depending how fields were permuted.\n+    /// Maps source order field indices to memory order indices, depending how fields were permuted.\n     /// FIXME (camlorn) also consider small vector  optimization here.\n-    pub gep_index: Vec<u32>,\n+    pub memory_index: Vec<u32>,\n \n     pub min_size: Size,\n }\n@@ -535,91 +535,78 @@ impl<'a, 'gcx, 'tcx> Struct {\n             packed: packed,\n             sized: true,\n             offsets: vec![],\n-            gep_index: vec![],\n+            memory_index: vec![],\n             min_size: Size::from_bytes(0),\n         };\n-        ret.fill_in_fields(dl, fields, scapegoat, repr, is_enum_variant)?;\n-        Ok(ret)\n-    }\n \n-    fn fill_in_fields<I>(&mut self, dl: &TargetDataLayout,\n-                     fields: I,\n-                     scapegoat: Ty<'gcx>,\n-                     repr: attr::ReprAttr,\n-                     is_enum_variant: bool)\n-                     -> Result<(), LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         let fields = fields.collect::<Result<Vec<_>, LayoutError<'gcx>>>()?;\n         if is_enum_variant { assert!(fields.len() >= 1, \"Enum variants must have at least a discriminant field.\") }\n-        if fields.len() == 0 {return Ok(())};\n+        if fields.len() == 0 {return Ok(ret)};\n \n-        self.offsets = vec![Size::from_bytes(0); fields.len()];\n-        let mut inverse_gep_index: Vec<u32> = Vec::with_capacity(fields.len());\n-        inverse_gep_index.extend(0..fields.len() as u32);\n+        ret.offsets = vec![Size::from_bytes(0); fields.len()];\n+        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n         if repr == attr::ReprAny {\n-            let start: usize = if is_enum_variant {1} else {0};\n+            let start = if is_enum_variant {1} else {0};\n             // FIXME(camlorn): we can't reorder the last field because it is possible for structs to be coerced to unsized.\n             // Example: struct Foo<T: ?Sized> { x: i32, y: T }\n             // We can coerce &Foo<u8> to &Foo<Trait>.\n-            let end = inverse_gep_index.len()-1;\n+            let end = inverse_memory_index.len()-1;\n             if end > start {\n-                let optimizing  = &mut inverse_gep_index[start..end];\n+                let optimizing  = &mut inverse_memory_index[start..end];\n                 optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n             }\n-        if is_enum_variant { assert_eq!(inverse_gep_index[0], 0, \"Enums must have field 0 as the field with lowest offset.\") }\n+            if is_enum_variant { assert_eq!(inverse_memory_index[0], 0, \"Enums must have field 0 as the field with lowest offset.\") }\n         }\n         \n-        // At this point, inverse_gep_index holds field indices by increasing offset.\n-        // That is, if field 5 has offset 0, the first element of inverse_gep_index is 5.\n+        // At this point, inverse_memory_index holds field indices by increasing offset.\n+        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n         // We now write field offsets to the corresponding offset slot; field 5 with offset 0 puts 0 in offsets[5].\n-        // At the bottom of this function, we use inverse_gep_index to produce gep_index.\n+        // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n         let mut offset = Size::from_bytes(0);\n \n-        for i in inverse_gep_index.iter() {\n+        for i in inverse_memory_index.iter() {\n             let field = fields[*i as usize];\n-            if !self.sized {\n-                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n-                     self.offsets.len(), scapegoat);\n+            if !ret.sized {\n+                bug!(\"Struct::new: field #{} of `{}` comes after unsized field\",\n+                     ret.offsets.len(), scapegoat);\n             }\n \n             if field.is_unsized() {\n-                self.sized = false;\n+                ret.sized = false;\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            if !self.packed {\n+            if !ret.packed {\n                 let align = field.align(dl);\n-                self.align = self.align.max(align);\n+                ret.align = ret.align.max(align);\n                 offset = offset.abi_align(align);\n             }\n \n-\n-            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n-            self.offsets[*i as usize] = offset;\n-\n+            debug!(\"Struct::new offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+            ret.offsets[*i as usize] = offset;\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n-        debug!(\"Struct::extend min_size: {:?}\", offset);\n \n-        self.min_size = offset;\n+        debug!(\"Struct::new min_size: {:?}\", offset);\n+        ret.min_size = offset;\n \n-        // As stated above, inverse_gep_index holds field indices by increasing offset.\n+        // As stated above, inverse_memory_index holds field indices by increasing offset.\n         // This makes it an already-sorted view of the offsets vec.\n         // To invert it, consider:\n-        // If field 5 has offset 0, offsets[0] is 5, and gep_index[5] should be 0.\n-        // Field 5 would be the first element, so gep_index is i:\n-        self.gep_index = vec![0; inverse_gep_index.len()];\n+        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+        // Field 5 would be the first element, so memory_index is i:\n+        ret.memory_index = vec![0; inverse_memory_index.len()];\n \n-        for i in 0..inverse_gep_index.len() {\n-            self.gep_index[inverse_gep_index[i] as usize]  = i as u32;\n+        for i in 0..inverse_memory_index.len() {\n+            ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n         }\n \n-        Ok(())\n+        Ok(ret)\n     }\n \n     /// Get the size with trailing alignment padding.\n@@ -645,21 +632,21 @@ impl<'a, 'gcx, 'tcx> Struct {\n     pub fn field_index_by_increasing_offset<'b>(&'b self) -> impl iter::Iterator<Item=usize>+'b {\n         let mut inverse_small = [0u8; 64];\n         let mut inverse_big = vec![];\n-        let use_small = self.gep_index.len() <= inverse_small.len();\n+        let use_small = self.memory_index.len() <= inverse_small.len();\n \n         // We have to write this logic twice in order to keep the array small.\n         if use_small {\n-            for i in 0..self.gep_index.len() {\n-                inverse_small[self.gep_index[i] as usize] = i as u8;\n+            for i in 0..self.memory_index.len() {\n+                inverse_small[self.memory_index[i] as usize] = i as u8;\n             }\n         } else {\n-            inverse_big = vec![0; self.gep_index.len()];\n-            for i in 0..self.gep_index.len() {\n-                inverse_big[self.gep_index[i] as usize] = i as u32;\n+            inverse_big = vec![0; self.memory_index.len()];\n+            for i in 0..self.memory_index.len() {\n+                inverse_big[self.memory_index[i] as usize] = i as u32;\n             }\n         }\n \n-        (0..self.gep_index.len()).map(move |i| {\n+        (0..self.memory_index.len()).map(move |i| {\n             if use_small { inverse_small[i] as usize }\n             else { inverse_big[i] as usize }\n         })\n@@ -703,19 +690,19 @@ impl<'a, 'gcx, 'tcx> Struct {\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n                 }),\n-                Some(&variant.gep_index[..]))\n+                Some(&variant.memory_index[..]))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n                 Struct::non_zero_field_path(infcx, upvar_tys,\n-                    Some(&variant.gep_index[..]))\n+                    Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys)) => {\n                 Struct::non_zero_field_path(infcx, tys.iter().cloned(),\n-                    Some(&variant.gep_index[..]))\n+                    Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n@@ -1193,7 +1180,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                         // We have to fix the last element of path here as only we know the right value.\n                         let mut i = *path.last().unwrap();\n-                        i = st.gep_index[i as usize];\n+                        i = st.memory_index[i as usize];\n                         *path.last_mut().unwrap() = i;\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();"}, {"sha": "9c82e2507737116939a63bdab2ae85ea534349c9", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=0e61c0e231ccd1db200917c1adff35a0128dffe8", "patch": "@@ -588,14 +588,14 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n     if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed || type_is_sized(bcx.tcx(), fty) {\n-        return bcx.struct_gep(ptr_val, st.gep_index[ix] as usize);\n+        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n     }\n \n     // If the type of the last field is [T] or str, then we don't need to do\n     // any adjusments\n     match fty.sty {\n         ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, st.gep_index[ix] as usize);\n+            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n         }\n         _ => ()\n     }\n@@ -814,7 +814,7 @@ pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     match *l {\n         layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n         layout::Univariant { ref variant, .. } => {\n-            const_struct_field(val, variant.gep_index[ix] as usize)\n+            const_struct_field(val, variant.memory_index[ix] as usize)\n         }\n         layout::Vector { .. } => const_struct_field(val, ix),\n         layout::UntaggedUnion { .. } => const_struct_field(val, 0),"}, {"sha": "2ee49db477864d02abeea9964b67e53ba10b30bd", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e61c0e231ccd1db200917c1adff35a0128dffe8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=0e61c0e231ccd1db200917c1adff35a0128dffe8", "patch": "@@ -136,7 +136,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n                         let layout = bcx.ccx().layout_of(dest.ty.to_ty(bcx.tcx()));\n                         let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n-                            Some(&variant.gep_index)\n+                            Some(&variant.memory_index)\n                         } else {\n                             None\n                         };"}]}