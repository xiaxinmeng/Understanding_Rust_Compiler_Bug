{"sha": "616b7afb724a32df41eebfaf95402d008c60b411", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNmI3YWZiNzI0YTMyZGY0MWVlYmZhZjk1NDAyZDAwOGM2MGI0MTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-09T02:13:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-09T02:13:49Z"}, "message": "Tidy up the sync dir, remove dead or mis-designed code in favour of OS primitives, switch rust_kernel to use a lock/signal pair and wait rather than spin.", "tree": {"sha": "03e13578e8b43b9001cef983d1117800a6f93e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03e13578e8b43b9001cef983d1117800a6f93e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616b7afb724a32df41eebfaf95402d008c60b411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616b7afb724a32df41eebfaf95402d008c60b411", "html_url": "https://github.com/rust-lang/rust/commit/616b7afb724a32df41eebfaf95402d008c60b411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616b7afb724a32df41eebfaf95402d008c60b411/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13d6f874316c9f69ab3a29f120ce410da2290a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/13d6f874316c9f69ab3a29f120ce410da2290a64", "html_url": "https://github.com/rust-lang/rust/commit/13d6f874316c9f69ab3a29f120ce410da2290a64"}], "stats": {"total": 529, "additions": 182, "deletions": 347}, "files": [{"sha": "d44dba97d163cce248fcad15c6a5bc762adda899", "filename": "src/Makefile", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -248,8 +248,7 @@ BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n \n RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/sync/sync.cpp \\\n-              rt/sync/spin_lock.cpp \\\n-              rt/sync/condition_variable.cpp \\\n+              rt/sync/lock_and_signal.cpp \\\n               rt/rust.cpp \\\n               rt/rust_builtin.cpp \\\n               rt/rust_crate.cpp \\\n@@ -383,6 +382,9 @@ self: $(CFG_COMPILER)\n TASK_XFAILS := test/run-pass/task-comm-8.rs \\\n                test/run-pass/task-comm-10.rs \\\n                test/run-pass/task-comm-15.rs \\\n+               test/run-pass/task-comm-12.rs \\\n+               test/run-pass/task-comm-2.rs \\\n+               test/run-pass/task-comm-9.rs \\\n                test/run-pass/task-life-0.rs \\\n                test/run-pass/alt-type-simple.rs \\\n                test/run-pass/many.rs\n@@ -936,3 +938,11 @@ clean:\n \t$(CFG_QUIET)rm -Rf $(PKG_NAME)-*.tar.gz dist\n \t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma o a d exe,\\\n                         $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n+\n+\n+# Local Variables:\n+# mode: makefile-gmake\n+# fill-column: 78;\n+# buffer-file-coding-system: utf-8-unix\n+# compile-command: \"make -k 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+# End:"}, {"sha": "b62f0f516116d6196ed3fcf95dac9072a722f92c", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -9,7 +9,7 @@\n #ifndef MEMORY_REGION_H\n #define MEMORY_REGION_H\n \n-#include \"sync/spin_lock.h\"\n+#include \"sync/lock_and_signal.h\"\n \n class rust_srv;\n \n@@ -20,7 +20,7 @@ class memory_region {\n     size_t _live_allocations;\n     array_list<void *> _allocation_list;\n     const bool _synchronized;\n-    spin_lock _lock;\n+    lock_and_signal _lock;\n public:\n     enum memory_region_type {\n         LOCAL = 0x1, SYNCHRONIZED = 0x2\n@@ -42,4 +42,15 @@ inline void *operator new(size_t size, memory_region *region) {\n     return region->malloc(size);\n }\n \n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+\n #endif /* MEMORY_REGION_H */"}, {"sha": "0913f9673a8ea938631a4dbf7233e2e1f1e158b8", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -42,7 +42,7 @@ extern \"C\" {\n #include \"util/hash_map.h\"\n #include \"sync/sync.h\"\n #include \"sync/timer.h\"\n-#include \"sync/condition_variable.h\"\n+#include \"sync/lock_and_signal.h\"\n #include \"sync/lock_free_queue.h\"\n \n class rust_dom;"}, {"sha": "b94c6c1aca0e7e89f284ce2ff9d5f73b3fd8e72b", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -12,7 +12,7 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n \n rust_handle<rust_dom> *\n rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n-    LOCK(_kernel_lock);\n+    _kernel_lock.lock();\n     rust_message_queue *message_queue =\n         new (this) rust_message_queue(_srv, this);\n     rust_srv *srv = _srv->clone();\n@@ -22,21 +22,23 @@ rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n     message_queue->associate(handle);\n     domains.append(dom);\n     message_queues.append(message_queue);\n-    UNLOCK(_kernel_lock);\n+    _kernel_lock.unlock();\n+    _kernel_lock.signal();\n     return handle;\n }\n \n void\n rust_kernel::destroy_domain(rust_dom *dom) {\n-    LOCK(_kernel_lock);\n+    _kernel_lock.lock();\n     log(rust_log::KERN, \"deleting domain: \" PTR \", index: %d, domains %d\",\n         dom, dom->list_index, domains.length());\n     domains.remove(dom);\n     dom->message_queue->disassociate();\n     rust_srv *srv = dom->srv;\n     delete dom;\n     delete srv;\n-    UNLOCK(_kernel_lock);\n+    _kernel_lock.unlock();\n+    _kernel_lock.signal();\n }\n \n rust_handle<rust_dom> *\n@@ -52,29 +54,29 @@ rust_kernel::internal_get_dom_handle(rust_dom *dom) {\n \n rust_handle<rust_dom> *\n rust_kernel::get_dom_handle(rust_dom *dom) {\n-    LOCK(_kernel_lock);\n+    _kernel_lock.lock();\n     rust_handle<rust_dom> *handle = internal_get_dom_handle(dom);\n-    UNLOCK(_kernel_lock);\n+    _kernel_lock.unlock();\n     return handle;\n }\n \n rust_handle<rust_task> *\n rust_kernel::get_task_handle(rust_task *task) {\n-    LOCK(_kernel_lock);\n+    _kernel_lock.lock();\n     rust_handle<rust_task> *handle = NULL;\n     if (_task_handles.get(task, &handle) == false) {\n         handle =\n             new (this) rust_handle<rust_task>(this, task->dom->message_queue,\n                                               task);\n         _task_handles.put(task, handle);\n     }\n-    UNLOCK(_kernel_lock);\n+    _kernel_lock.unlock();\n     return handle;\n }\n \n rust_handle<rust_port> *\n rust_kernel::get_port_handle(rust_port *port) {\n-    PLOCK(_kernel_lock);\n+    _kernel_lock.lock();\n     rust_handle<rust_port> *handle = NULL;\n     if (_port_handles.get(port, &handle) == false) {\n         handle =\n@@ -83,7 +85,7 @@ rust_kernel::get_port_handle(rust_port *port) {\n                                               port);\n         _port_handles.put(port, handle);\n     }\n-    PUNLOCK(_kernel_lock);\n+    _kernel_lock.unlock();\n     return handle;\n }\n \n@@ -126,7 +128,6 @@ rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n \n void\n rust_kernel::pump_message_queues() {\n-    LOCK(_kernel_lock);\n     for (size_t i = 0; i < message_queues.length(); i++) {\n         rust_message_queue *queue = message_queues[i];\n         if (queue->is_associated() == false) {\n@@ -137,27 +138,16 @@ rust_kernel::pump_message_queues() {\n             }\n         }\n     }\n-    UNLOCK(_kernel_lock);\n }\n \n void\n rust_kernel::start_kernel_loop() {\n+    _kernel_lock.lock();\n     while (_interrupt_kernel_loop == false) {\n+        _kernel_lock.wait();\n         pump_message_queues();\n-\n-        // FIXME: this is a complete hack to make the testsuite finish in a\n-        // sane time when executing under valgrind. The whole message-loop\n-        // system here needs replacement with an OS-level event-queue such\n-        // that actually wait on inter-thread notices, rather than\n-        // busy-waiting.\n-\n-        size_t ms = TIME_SLICE_IN_MS;\n-#if defined(__WIN32__)\n-        Sleep(ms);\n-#else\n-        usleep(ms * 1000);\n-#endif\n     }\n+    _kernel_lock.unlock();\n }\n \n void\n@@ -171,6 +161,7 @@ void\n rust_kernel::terminate_kernel_loop() {\n     log(rust_log::KERN, \"terminating kernel loop\");\n     _interrupt_kernel_loop = true;\n+    _kernel_lock.signal();\n     join();\n }\n "}, {"sha": "6607bdbc3a353bd0c9177618c60b7704d61a7a4a", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -32,12 +32,6 @@ rust_handle :\n     }\n };\n \n-#define LOCK(x) x.lock();\n-#define UNLOCK(x) x.unlock();\n-\n-#define PLOCK(x) printf(\"LOCKING @ %d\\n\", __LINE__); x.lock();\n-#define PUNLOCK(x) x.unlock(); printf(\"UNLOCKED @ %d\\n\", __LINE__);\n-\n /**\n  * A global object shared by all thread domains. Most of the data structures\n  * in this class are synchronized since they are accessed from multiple\n@@ -59,9 +53,9 @@ class rust_kernel : public rust_thread {\n \n     void run();\n     void start_kernel_loop();\n-    bool volatile _interrupt_kernel_loop;\n+    bool _interrupt_kernel_loop;\n \n-    spin_lock _kernel_lock;\n+    lock_and_signal _kernel_lock;\n \n     void terminate_kernel_loop();\n     void pump_message_queues();"}, {"sha": "a57f7cb49c95d260f7a9164df3c3c3e2a405b222", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -4,7 +4,6 @@\n  */\n \n #include \"rust_internal.h\"\n-#include \"sync/spin_lock.h\"\n #include \"util/array_list.h\"\n #include <stdarg.h>\n \n@@ -64,7 +63,7 @@ static const char * _foreground_colors[] = { \"[37m\",\n /**\n  * Synchronizes access to the underlying logging mechanism.\n  */\n-static spin_lock _log_lock;\n+static lock_and_signal _log_lock;\n static uint32_t _last_thread_id;\n \n rust_log::rust_log(rust_srv *srv, rust_dom *dom) :"}, {"sha": "c34ab7f42aacc8793c4c6874153da3f88c754827", "filename": "src/rt/sync/condition_variable.cpp", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fcondition_variable.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fcondition_variable.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fcondition_variable.cpp?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,84 +0,0 @@\n-#include \"../globals.h\"\n-\n-/*\n- * Conditional variable. Implemented using pthreads condition variables, and\n- * using events on windows.\n- */\n-\n-#include \"condition_variable.h\"\n-\n-// #define TRACE\n-\n-#if defined(__WIN32__)\n-condition_variable::condition_variable() {\n-    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n-}\n-#else\n-condition_variable::condition_variable() {\n-    pthread_cond_init(&_cond, NULL);\n-    pthread_mutex_init(&_mutex, NULL);\n-}\n-#endif\n-\n-condition_variable::~condition_variable() {\n-#if defined(__WIN32__)\n-    CloseHandle(_event);\n-#else\n-    pthread_cond_destroy(&_cond);\n-    pthread_mutex_destroy(&_mutex);\n-#endif\n-}\n-\n-/**\n- * Wait indefinitely until condition is signaled.\n- */\n-void condition_variable::wait() {\n-    timed_wait(0);\n-}\n-\n-void condition_variable::timed_wait(size_t timeout_in_ns) {\n-#ifdef TRACE\n-    printf(\"waiting on condition_variable: 0x%\" PRIxPTR \" for %d ns. \\n\",\n-           (uintptr_t) this, (int) timeout_in_ns);\n-#endif\n-#if defined(__WIN32__)\n-    WaitForSingleObject(_event, INFINITE);\n-#else\n-    pthread_mutex_lock(&_mutex);\n-    // wait() automatically releases the mutex while it waits, and acquires\n-    // it right before exiting. This allows signal() to acquire the mutex\n-    // when signaling.)\n-    if (timeout_in_ns == 0) {\n-        pthread_cond_wait(&_cond, &_mutex);\n-    } else {\n-        timeval time_val;\n-        gettimeofday(&time_val, NULL);\n-        timespec time_spec;\n-        time_spec.tv_sec = time_val.tv_sec + 0;\n-        time_spec.tv_nsec = time_val.tv_usec * 1000 + timeout_in_ns;\n-        pthread_cond_timedwait(&_cond, &_mutex, &time_spec);\n-    }\n-    pthread_mutex_unlock(&_mutex);\n-#endif\n-#ifdef TRACE\n-    printf(\"resumed on condition_variable: 0x%\" PRIxPTR \"\\n\",\n-           (uintptr_t)this);\n-#endif\n-}\n-\n-/**\n- * Signal condition, and resume the waiting thread.\n- */\n-void condition_variable::signal() {\n-#if defined(__WIN32__)\n-    SetEvent(_event);\n-#else\n-    pthread_mutex_lock(&_mutex);\n-    pthread_cond_signal(&_cond);\n-    pthread_mutex_unlock(&_mutex);\n-#endif\n-#ifdef TRACE\n-    printf(\"signal  condition_variable: 0x%\" PRIxPTR \"\\n\",\n-           (uintptr_t)this);\n-#endif\n-}"}, {"sha": "f336a7f2a6e135938a97136500794045b7a16573", "filename": "src/rt/sync/condition_variable.h", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fcondition_variable.h", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fcondition_variable.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fcondition_variable.h?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,20 +0,0 @@\n-#ifndef CONDITION_VARIABLE_H\n-#define CONDITION_VARIABLE_H\n-\n-class condition_variable {\n-#if defined(__WIN32__)\n-    HANDLE _event;\n-#else\n-    pthread_cond_t _cond;\n-    pthread_mutex_t _mutex;\n-#endif\n-public:\n-    condition_variable();\n-    virtual ~condition_variable();\n-\n-    void wait();\n-    void timed_wait(size_t timeout_in_ns);\n-    void signal();\n-};\n-\n-#endif /* CONDITION_VARIABLE_H */"}, {"sha": "0306ee1df39537a8fe0d3ca488ddbd6e6b7083bb", "filename": "src/rt/sync/fair_ticket_lock.cpp", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,43 +0,0 @@\n-/*\n- * This works well as long as the number of contending threads\n- * is less than the number of processors. This is because of\n- * the fair locking scheme. If the thread that is next in line\n- * for acquiring the lock is not currently running, no other\n- * thread can acquire the lock. This is terrible for performance,\n- * and it seems that all fair locking schemes suffer from this\n- * behavior.\n- */\n-\n-// #define TRACE\n-\n-fair_ticket_lock::fair_ticket_lock() {\n-    next_ticket = now_serving = 0;\n-}\n-\n-fair_ticket_lock::~fair_ticket_lock() {\n-\n-}\n-\n-void fair_ticket_lock::lock() {\n-    unsigned ticket = __sync_fetch_and_add(&next_ticket, 1);\n-    while (now_serving != ticket) {\n-        pause();\n-    }\n-#ifdef TRACE\n-    printf(\"locked   nextTicket: %d nowServing: %d\",\n-            next_ticket, now_serving);\n-#endif\n-}\n-\n-void fair_ticket_lock::unlock() {\n-    now_serving++;\n-#ifdef TRACE\n-    printf(\"unlocked nextTicket: %d nowServing: %d\",\n-            next_ticket, now_serving);\n-#endif\n-}\n-\n-void fair_ticket_lock::pause() {\n-    asm volatile(\"pause\\n\" : : : \"memory\");\n-}\n-"}, {"sha": "c34c9041657c67618a5fff85b29abfa37131a393", "filename": "src/rt/sync/fair_ticket_lock.h", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Ffair_ticket_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Ffair_ticket_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ffair_ticket_lock.h?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,15 +0,0 @@\n-#ifndef FAIR_TICKET_LOCK_H\n-#define FAIR_TICKET_LOCK_H\n-\n-class fair_ticket_lock {\n-    unsigned next_ticket;\n-    unsigned now_serving;\n-    void pause();\n-public:\n-    fair_ticket_lock();\n-    virtual ~fair_ticket_lock();\n-    void lock();\n-    void unlock();\n-};\n-\n-#endif /* FAIR_TICKET_LOCK_H */"}, {"sha": "064b25f17ba2bbfb36a03ef83464eccc50c20449", "filename": "src/rt/sync/interrupt_transparent_queue.cpp", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Finterrupt_transparent_queue.cpp?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,56 +0,0 @@\n-/*\n- * Interrupt transparent queue, Schoen et. al, \"On Interrupt-Transparent\n- * Synchronization in an Embedded Object-Oriented Operating System\", 2000.\n- * enqueue() is allowed to interrupt enqueue() and dequeue(), however,\n- * dequeue() is not allowed to interrupt itself.\n- */\n-\n-#include \"../globals.h\"\n-#include \"interrupt_transparent_queue.h\"\n-\n-interrupt_transparent_queue_node::interrupt_transparent_queue_node() :\n-    next(NULL) {\n-\n-}\n-\n-interrupt_transparent_queue::interrupt_transparent_queue() : _tail(this) {\n-\n-}\n-\n-void\n-interrupt_transparent_queue::enqueue(interrupt_transparent_queue_node *item) {\n-    lock.lock();\n-    item->next = (interrupt_transparent_queue_node *) NULL;\n-    interrupt_transparent_queue_node *last = _tail;\n-    _tail = item;\n-    while (last->next) {\n-        last = last->next;\n-    }\n-    last->next = item;\n-    lock.unlock();\n-}\n-\n-interrupt_transparent_queue_node *\n-interrupt_transparent_queue::dequeue() {\n-    lock.lock();\n-    interrupt_transparent_queue_node *item = next;\n-    if (item && !(next = item->next)) {\n-        _tail = (interrupt_transparent_queue_node *) this;\n-        if (item->next) {\n-            interrupt_transparent_queue_node *lost = item->next;\n-            interrupt_transparent_queue_node *help;\n-            do {\n-                help = lost->next;\n-                enqueue(lost);\n-            } while ((lost = help) !=\n-                     (interrupt_transparent_queue_node *) NULL);\n-        }\n-    }\n-    lock.unlock();\n-    return item;\n-}\n-\n-bool\n-interrupt_transparent_queue::is_empty() {\n-    return next == NULL;\n-}"}, {"sha": "7c02d0c83888e4e7269c0a5db59e24e95bbc2107", "filename": "src/rt/sync/interrupt_transparent_queue.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Finterrupt_transparent_queue.h?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,22 +0,0 @@\n-#ifndef INTERRUPT_TRANSPARENT_QUEUE_H\n-#define INTERRUPT_TRANSPARENT_QUEUE_H\n-\n-#include \"spin_lock.h\"\n-\n-class interrupt_transparent_queue_node {\n-public:\n-    interrupt_transparent_queue_node *next;\n-    interrupt_transparent_queue_node();\n-};\n-\n-class interrupt_transparent_queue : interrupt_transparent_queue_node {\n-    spin_lock lock;\n-    interrupt_transparent_queue_node *_tail;\n-public:\n-    interrupt_transparent_queue();\n-    void enqueue(interrupt_transparent_queue_node *item);\n-    interrupt_transparent_queue_node *dequeue();\n-    bool is_empty();\n-};\n-\n-#endif /* INTERRUPT_TRANSPARENT_QUEUE_H */"}, {"sha": "c010086eb410b521324dd91358bebcac62b18fff", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -0,0 +1,97 @@\n+#include \"../globals.h\"\n+\n+/*\n+ * A \"lock-and-signal\" pair. These are necessarily coupled on pthreads\n+ * systems, and artificially coupled (by this file) on win32. Put\n+ * together here to minimize ifdefs elsewhere; you must use them as\n+ * if you're using a pthreads cvar+mutex pair.\n+ */\n+\n+#include \"lock_and_signal.h\"\n+\n+#if defined(__WIN32__)\n+lock_and_signal::lock_and_signal() {\n+    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n+    InitializeCriticalSection(&_cs);\n+}\n+\n+#else\n+lock_and_signal::lock_and_signal() {\n+    pthread_cond_init(&_cond, NULL);\n+    pthread_mutex_init(&_mutex, NULL);\n+}\n+#endif\n+\n+lock_and_signal::~lock_and_signal() {\n+#if defined(__WIN32__)\n+    CloseHandle(_event);\n+#else\n+    pthread_cond_destroy(&_cond);\n+    pthread_mutex_destroy(&_mutex);\n+#endif\n+}\n+\n+void lock_and_signal::lock() {\n+#if defined(__WIN32__)\n+  EnterCriticalSection(&_cs);\n+#else\n+  pthread_mutex_lock(&_mutex);\n+#endif\n+}\n+\n+void lock_and_signal::unlock() {\n+#if defined(__WIN32__)\n+  LeaveCriticalSection(&_cs);\n+#else\n+  pthread_mutex_unlock(&_mutex);\n+#endif\n+}\n+\n+\n+/**\n+ * Wait indefinitely until condition is signaled.\n+ */\n+void lock_and_signal::wait() {\n+    timed_wait(0);\n+}\n+\n+void lock_and_signal::timed_wait(size_t timeout_in_ns) {\n+#if defined(__WIN32__)\n+  LeaveCriticalSection(&_cs);\n+  WaitForSingleObject(_event, INFINITE);\n+  EnterCriticalSection(&_cs);\n+#else\n+    if (timeout_in_ns == 0) {\n+        pthread_cond_wait(&_cond, &_mutex);\n+    } else {\n+        timeval time_val;\n+        gettimeofday(&time_val, NULL);\n+        timespec time_spec;\n+        time_spec.tv_sec = time_val.tv_sec + 0;\n+        time_spec.tv_nsec = time_val.tv_usec * 1000 + timeout_in_ns;\n+        pthread_cond_timedwait(&_cond, &_mutex, &time_spec);\n+    }\n+#endif\n+}\n+\n+/**\n+ * Signal condition, and resume the waiting thread.\n+ */\n+void lock_and_signal::signal() {\n+#if defined(__WIN32__)\n+    SetEvent(_event);\n+#else\n+    pthread_cond_signal(&_cond);\n+#endif\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "5a852d9d0263c22b8a833f699fb76178df148212", "filename": "src/rt/sync/lock_and_signal.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -0,0 +1,23 @@\n+#ifndef LOCK_AND_SIGNAL_H\n+#define LOCK_AND_SIGNAL_H\n+\n+class lock_and_signal {\n+#if defined(__WIN32__)\n+    HANDLE _event;\n+    CRITICAL_SECTION _cs;\n+#else\n+    pthread_cond_t _cond;\n+    pthread_mutex_t _mutex;\n+#endif\n+public:\n+    lock_and_signal();\n+    virtual ~lock_and_signal();\n+\n+    void lock();\n+    void unlock();\n+    void wait();\n+    void timed_wait(size_t timeout_in_ns);\n+    void signal();\n+};\n+\n+#endif /* LOCK_AND_SIGNAL_H */"}, {"sha": "4a113d1aef97a76a11f9f02fde0073a6b348b51a", "filename": "src/rt/sync/spin_lock.cpp", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fspin_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fspin_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.cpp?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,48 +0,0 @@\n-#include \"../globals.h\"\n-#include \"spin_lock.h\"\n-\n-/*\n- * Your average spin lock.\n- */\n-\n-// #define TRACE\n-\n-spin_lock::spin_lock() {\n-    unlock();\n-}\n-\n-spin_lock::~spin_lock() {\n-}\n-\n-static inline unsigned xchg32(void *ptr, unsigned x) {\n-    __asm__ __volatile__(\"xchgl %0,%1\"\n-                :\"=r\" ((unsigned) x)\n-                :\"m\" (*(volatile unsigned *)ptr), \"0\" (x)\n-                :\"memory\");\n-    return x;\n-}\n-\n-void spin_lock::lock() {\n-    while (true) {\n-        if (!xchg32(&ticket, 1)) {\n-            return;\n-        }\n-        while (ticket) {\n-            pause();\n-        }\n-    }\n-#ifdef TRACE\n-    printf(\"  lock: %d\", ticket);\n-#endif\n-}\n-\n-void spin_lock::unlock() {\n-    ticket = 0;\n-#ifdef TRACE\n-    printf(\"unlock:\");\n-#endif\n-}\n-\n-void spin_lock::pause() {\n-    asm volatile(\"pause\\n\" : : : \"memory\");\n-}"}, {"sha": "f15416a2d4e015de2c719dcc36da09512d5c30ec", "filename": "src/rt/sync/spin_lock.h", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fspin_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/13d6f874316c9f69ab3a29f120ce410da2290a64/src%2Frt%2Fsync%2Fspin_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.h?ref=13d6f874316c9f69ab3a29f120ce410da2290a64", "patch": "@@ -1,14 +0,0 @@\n-#ifndef SPIN_LOCK_H\n-#define SPIN_LOCK_H\n-\n-class spin_lock {\n-    unsigned ticket;\n-    void pause();\n-public:\n-    spin_lock();\n-    virtual ~spin_lock();\n-    void lock();\n-    void unlock();\n-};\n-\n-#endif /* SPIN_LOCK_H */"}, {"sha": "c754392aece971a35a7a220a0d43afc0c3accf9b", "filename": "src/rt/sync/sync.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Fsync.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Fsync%2Fsync.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fsync.cpp?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -11,7 +11,7 @@ void sync::yield() {\n #endif\n }\n \n-rust_thread::rust_thread() : _is_running(false) {\n+rust_thread::rust_thread() : _is_running(false), thread(0) {\n     // Nop.\n }\n \n@@ -25,7 +25,6 @@ static void *\n rust_thread_start(void *ptr) {\n     rust_thread *thread = (rust_thread *) ptr;\n     thread->run();\n-    thread->thread = 0;\n     return 0;\n }\n \n@@ -46,9 +45,11 @@ rust_thread::start() {\n void\n rust_thread::join() {\n #if defined(__WIN32__)\n-   WaitForSingleObject(thread, INFINITE);\n+   if (thread)\n+     WaitForSingleObject(thread, INFINITE);\n #else\n-   pthread_join(thread, NULL);\n+   if (thread)\n+     pthread_join(thread, NULL);\n #endif\n    thread = 0;\n    _is_running = false;"}, {"sha": "6b5611710d7813b900664abfbbffa554e702e5cb", "filename": "src/rt/util/synchronized_indexed_list.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/616b7afb724a32df41eebfaf95402d008c60b411/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fsynchronized_indexed_list.h?ref=616b7afb724a32df41eebfaf95402d008c60b411", "patch": "@@ -5,7 +5,7 @@\n \n template<typename T> class synchronized_indexed_list :\n     public indexed_list<T> {\n-    spin_lock _lock;\n+    lock_and_signal _lock;\n \n public:\n     synchronized_indexed_list(memory_region *region) :\n@@ -61,4 +61,15 @@ template<typename T> class synchronized_indexed_list :\n     }\n };\n \n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//\n+\n #endif /* SYNCHRONIZED_INDEXED_LIST_H */"}]}