{"sha": "17ec4b8258b3f59ded7b2cfae8484be976c658af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ZWM0YjgyNThiM2Y1OWRlZDdiMmNmYWU4NDg0YmU5NzZjNjU4YWY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-12-11T05:33:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-11T05:33:08Z"}, "message": "Rollup merge of #79809 - Eric-Arellano:split-once, r=matklad\n\nDogfood `str_split_once()`\n\nPart of https://github.com/rust-lang/rust/issues/74773.\n\nBeyond increased clarity, this fixes some instances of a common confusion with how `splitn(2)` behaves: the first element will always be `Some()`, regardless of the delimiter, and even if the value is empty.\n\nGiven this code:\n\n```rust\nfn main() {\n    let val = \"...\";\n    let mut iter = val.splitn(2, '=');\n    println!(\"Input: {:?}, first: {:?}, second: {:?}\", val, iter.next(), iter.next());\n}\n```\n\nWe get:\n\n```\nInput: \"no_delimiter\", first: Some(\"no_delimiter\"), second: None\nInput: \"k=v\", first: Some(\"k\"), second: Some(\"v\")\nInput: \"=\", first: Some(\"\"), second: Some(\"\")\n```\n\nUsing `str_split_once()` makes more clear what happens when the delimiter is not found.", "tree": {"sha": "78e69a92950080416cb1097e7b28c1b76a692ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78e69a92950080416cb1097e7b28c1b76a692ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ec4b8258b3f59ded7b2cfae8484be976c658af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf0wSUCRBK7hj4Ov3rIwAAdHIIABa6oftX6N9oENx9zHe+2QHL\n0JEJs2HuteLvhZI3qlWdFY8uE1c71vodolIBVAVheSKYj4dbzd1bSUKC/wv70I6Z\n5cOMVjICWmEwWGhAiVGFg0i5oa4D1Cee7x++Ls1tjxMzTqYP8r8OIk5N3j3buio0\nS+x78oUc6uiMqk9mBWuwkgy/FhKj2pd9FaLbHWIBQ9PlpgUDBGxfhlnwenztcLkO\nDyYjUsQW6+xWBChslKReQ4v1yP01T3pc5fy4ogMRPl3sTafExT7hbdJCCToEta3u\nVjcfNmTPXPRbF6+Gm62Oma0IK0PuMyZ7i5xlUU2GZdIzRmnPP6iaxSOqCufNjyg=\n=KMv/\n-----END PGP SIGNATURE-----\n", "payload": "tree 78e69a92950080416cb1097e7b28c1b76a692ca4\nparent 8b9a59cb905f2f22c7de7713e38756b20289e0b9\nparent 989edf4a5ffb0944e173ec23cb5614c252e8082e\nauthor Tyler Mandry <tmandry@gmail.com> 1607664788 -0800\ncommitter GitHub <noreply@github.com> 1607664788 -0800\n\nRollup merge of #79809 - Eric-Arellano:split-once, r=matklad\n\nDogfood `str_split_once()`\n\nPart of https://github.com/rust-lang/rust/issues/74773.\n\nBeyond increased clarity, this fixes some instances of a common confusion with how `splitn(2)` behaves: the first element will always be `Some()`, regardless of the delimiter, and even if the value is empty.\n\nGiven this code:\n\n```rust\nfn main() {\n    let val = \"...\";\n    let mut iter = val.splitn(2, '=');\n    println!(\"Input: {:?}, first: {:?}, second: {:?}\", val, iter.next(), iter.next());\n}\n```\n\nWe get:\n\n```\nInput: \"no_delimiter\", first: Some(\"no_delimiter\"), second: None\nInput: \"k=v\", first: Some(\"k\"), second: Some(\"v\")\nInput: \"=\", first: Some(\"\"), second: Some(\"\")\n```\n\nUsing `str_split_once()` makes more clear what happens when the delimiter is not found.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ec4b8258b3f59ded7b2cfae8484be976c658af", "html_url": "https://github.com/rust-lang/rust/commit/17ec4b8258b3f59ded7b2cfae8484be976c658af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ec4b8258b3f59ded7b2cfae8484be976c658af/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b9a59cb905f2f22c7de7713e38756b20289e0b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9a59cb905f2f22c7de7713e38756b20289e0b9", "html_url": "https://github.com/rust-lang/rust/commit/8b9a59cb905f2f22c7de7713e38756b20289e0b9"}, {"sha": "989edf4a5ffb0944e173ec23cb5614c252e8082e", "url": "https://api.github.com/repos/rust-lang/rust/commits/989edf4a5ffb0944e173ec23cb5614c252e8082e", "html_url": "https://github.com/rust-lang/rust/commit/989edf4a5ffb0944e173ec23cb5614c252e8082e"}], "stats": {"total": 386, "additions": 196, "deletions": 190}, "files": [{"sha": "e6d822086f52180b0c6d36a93c044c7cdedd3108", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -28,6 +28,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(or_patterns)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n+#![feature(str_split_once)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "af81d9af0e29347f2160024f55f71ea486fc6a6c", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -148,40 +148,46 @@ impl DebugOptions {\n \n         if let Ok(env_debug_options) = std::env::var(RUSTC_COVERAGE_DEBUG_OPTIONS) {\n             for setting_str in env_debug_options.replace(\" \", \"\").replace(\"-\", \"_\").split(',') {\n-                let mut setting = setting_str.splitn(2, '=');\n-                match setting.next() {\n-                    Some(option) if option == \"allow_unused_expressions\" => {\n-                        allow_unused_expressions = bool_option_val(option, setting.next());\n+                let (option, value) = match setting_str.split_once('=') {\n+                    None => (setting_str, None),\n+                    Some((k, v)) => (k, Some(v)),\n+                };\n+                match option {\n+                    \"allow_unused_expressions\" => {\n+                        allow_unused_expressions = bool_option_val(option, value);\n                         debug!(\n                             \"{} env option `allow_unused_expressions` is set to {}\",\n                             RUSTC_COVERAGE_DEBUG_OPTIONS, allow_unused_expressions\n                         );\n                     }\n-                    Some(option) if option == \"counter_format\" => {\n-                        if let Some(strval) = setting.next() {\n-                            counter_format = counter_format_option_val(strval);\n-                            debug!(\n-                                \"{} env option `counter_format` is set to {:?}\",\n-                                RUSTC_COVERAGE_DEBUG_OPTIONS, counter_format\n-                            );\n-                        } else {\n-                            bug!(\n-                                \"`{}` option in environment variable {} requires one or more \\\n-                                plus-separated choices (a non-empty subset of \\\n-                                `id+block+operation`)\",\n-                                option,\n-                                RUSTC_COVERAGE_DEBUG_OPTIONS\n-                            );\n-                        }\n+                    \"counter_format\" => {\n+                        match value {\n+                            None => {\n+                                bug!(\n+                                    \"`{}` option in environment variable {} requires one or more \\\n+                                    plus-separated choices (a non-empty subset of \\\n+                                    `id+block+operation`)\",\n+                                    option,\n+                                    RUSTC_COVERAGE_DEBUG_OPTIONS\n+                                );\n+                            }\n+                            Some(val) => {\n+                                counter_format = counter_format_option_val(val);\n+                                debug!(\n+                                    \"{} env option `counter_format` is set to {:?}\",\n+                                    RUSTC_COVERAGE_DEBUG_OPTIONS, counter_format\n+                                );\n+                            }\n+                        };\n                     }\n-                    Some(\"\") => {}\n-                    Some(invalid) => bug!(\n-                        \"Unsupported setting `{}` in environment variable {}\",\n-                        invalid,\n-                        RUSTC_COVERAGE_DEBUG_OPTIONS\n-                    ),\n-                    None => {}\n-                }\n+                    _ => {\n+                        bug!(\n+                            \"Unsupported setting `{}` in environment variable {}\",\n+                            option,\n+                            RUSTC_COVERAGE_DEBUG_OPTIONS\n+                        )\n+                    }\n+                };\n             }\n         }\n "}, {"sha": "54abb65dc38834d31879ef112fe237745798415b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 50, "deletions": 59, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -1296,8 +1296,10 @@ fn parse_output_types(\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n             for output_type in list.split(',') {\n-                let mut parts = output_type.splitn(2, '=');\n-                let shorthand = parts.next().unwrap();\n+                let (shorthand, path) = match output_type.split_once('=') {\n+                    None => (output_type, None),\n+                    Some((shorthand, path)) => (shorthand, Some(PathBuf::from(path))),\n+                };\n                 let output_type = OutputType::from_shorthand(shorthand).unwrap_or_else(|| {\n                     early_error(\n                         error_format,\n@@ -1308,7 +1310,6 @@ fn parse_output_types(\n                         ),\n                     )\n                 });\n-                let path = parts.next().map(PathBuf::from);\n                 output_types.insert(output_type, path);\n             }\n         }\n@@ -1452,11 +1453,10 @@ fn parse_opt_level(\n     let max_c = matches\n         .opt_strs_pos(\"C\")\n         .into_iter()\n-        .flat_map(\n-            |(i, s)| {\n-                if let Some(\"opt-level\") = s.splitn(2, '=').next() { Some(i) } else { None }\n-            },\n-        )\n+        .flat_map(|(i, s)| {\n+            // NB: This can match a string without `=`.\n+            if let Some(\"opt-level\") = s.splitn(2, '=').next() { Some(i) } else { None }\n+        })\n         .max();\n     if max_o > max_c {\n         OptLevel::Default\n@@ -1491,11 +1491,10 @@ fn select_debuginfo(\n     let max_c = matches\n         .opt_strs_pos(\"C\")\n         .into_iter()\n-        .flat_map(\n-            |(i, s)| {\n-                if let Some(\"debuginfo\") = s.splitn(2, '=').next() { Some(i) } else { None }\n-            },\n-        )\n+        .flat_map(|(i, s)| {\n+            // NB: This can match a string without `=`.\n+            if let Some(\"debuginfo\") = s.splitn(2, '=').next() { Some(i) } else { None }\n+        })\n         .max();\n     if max_g > max_c {\n         DebugInfo::Full\n@@ -1528,23 +1527,26 @@ fn parse_libs(\n         .map(|s| {\n             // Parse string of the form \"[KIND=]lib[:new_name]\",\n             // where KIND is one of \"dylib\", \"framework\", \"static\".\n-            let mut parts = s.splitn(2, '=');\n-            let kind = parts.next().unwrap();\n-            let (name, kind) = match (parts.next(), kind) {\n-                (None, name) => (name, NativeLibKind::Unspecified),\n-                (Some(name), \"dylib\") => (name, NativeLibKind::Dylib),\n-                (Some(name), \"framework\") => (name, NativeLibKind::Framework),\n-                (Some(name), \"static\") => (name, NativeLibKind::StaticBundle),\n-                (Some(name), \"static-nobundle\") => (name, NativeLibKind::StaticNoBundle),\n-                (_, s) => {\n-                    early_error(\n-                        error_format,\n-                        &format!(\n-                            \"unknown library kind `{}`, expected \\\n-                             one of dylib, framework, or static\",\n-                            s\n-                        ),\n-                    );\n+            let (name, kind) = match s.split_once('=') {\n+                None => (s, NativeLibKind::Unspecified),\n+                Some((kind, name)) => {\n+                    let kind = match kind {\n+                        \"dylib\" => NativeLibKind::Dylib,\n+                        \"framework\" => NativeLibKind::Framework,\n+                        \"static\" => NativeLibKind::StaticBundle,\n+                        \"static-nobundle\" => NativeLibKind::StaticNoBundle,\n+                        s => {\n+                            early_error(\n+                                error_format,\n+                                &format!(\n+                                    \"unknown library kind `{}`, expected \\\n+                                     one of dylib, framework, or static\",\n+                                    s\n+                                ),\n+                            );\n+                        }\n+                    };\n+                    (name.to_string(), kind)\n                 }\n             };\n             if kind == NativeLibKind::StaticNoBundle\n@@ -1556,10 +1558,11 @@ fn parse_libs(\n                      accepted on the nightly compiler\",\n                 );\n             }\n-            let mut name_parts = name.splitn(2, ':');\n-            let name = name_parts.next().unwrap();\n-            let new_name = name_parts.next();\n-            (name.to_owned(), new_name.map(|n| n.to_owned()), kind)\n+            let (name, new_name) = match name.split_once(':') {\n+                None => (name, None),\n+                Some((name, new_name)) => (name.to_string(), Some(new_name.to_owned())),\n+            };\n+            (name, new_name, kind)\n         })\n         .collect()\n }\n@@ -1580,20 +1583,13 @@ pub fn parse_externs(\n     let is_unstable_enabled = debugging_opts.unstable_options;\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n     for arg in matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts\n-            .next()\n-            .unwrap_or_else(|| early_error(error_format, \"--extern value must not be empty\"));\n-        let path = parts.next().map(|s| s.to_string());\n-\n-        let mut name_parts = name.splitn(2, ':');\n-        let first_part = name_parts.next();\n-        let second_part = name_parts.next();\n-        let (options, name) = match (first_part, second_part) {\n-            (Some(opts), Some(name)) => (Some(opts), name),\n-            (Some(name), None) => (None, name),\n-            (None, None) => early_error(error_format, \"--extern name must not be empty\"),\n-            _ => unreachable!(),\n+        let (name, path) = match arg.split_once('=') {\n+            None => (arg, None),\n+            Some((name, path)) => (name.to_string(), Some(path.to_string())),\n+        };\n+        let (options, name) = match name.split_once(':') {\n+            None => (None, name),\n+            Some((opts, name)) => (Some(opts), name.to_string()),\n         };\n \n         let entry = externs.entry(name.to_owned());\n@@ -1682,17 +1678,12 @@ fn parse_remap_path_prefix(\n     matches\n         .opt_strs(\"remap-path-prefix\")\n         .into_iter()\n-        .map(|remap| {\n-            let mut parts = remap.rsplitn(2, '='); // reverse iterator\n-            let to = parts.next();\n-            let from = parts.next();\n-            match (from, to) {\n-                (Some(from), Some(to)) => (PathBuf::from(from), PathBuf::from(to)),\n-                _ => early_error(\n-                    error_format,\n-                    \"--remap-path-prefix must contain '=' between FROM and TO\",\n-                ),\n-            }\n+        .map(|remap| match remap.rsplit_once('=') {\n+            None => early_error(\n+                error_format,\n+                \"--remap-path-prefix must contain '=' between FROM and TO\",\n+            ),\n+            Some((from, to)) => (PathBuf::from(from), PathBuf::from(to)),\n         })\n         .collect()\n }"}, {"sha": "36bf8634c6eeceff97229d50152f2ffc33ae53ff", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -1,6 +1,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(once_cell)]\n #![feature(or_patterns)]\n+#![feature(str_split_once)]\n \n #[macro_use]\n extern crate bitflags;"}, {"sha": "74578f2dc179fee60fed90bac8c82c53afb13df3", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -179,9 +179,10 @@ macro_rules! options {\n     {\n         let mut op = $defaultfn();\n         for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(2, '=');\n-            let key = iter.next().unwrap();\n-            let value = iter.next();\n+            let (key, value) = match option.split_once('=') {\n+                None => (option, None),\n+                Some((k, v)) => (k.to_string(), Some(v)),\n+            };\n             let option_to_lookup = key.replace(\"-\", \"_\");\n             let mut found = false;\n             for &(candidate, setter, type_desc, _) in $stat {"}, {"sha": "1ad57582ebafbbce87fb1a5e126b057dc791e260", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -15,6 +15,7 @@\n #![feature(never_type)]\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n+#![feature(str_split_once)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "88422395216437fba0678fcf8dc7d06df5171b8d", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -54,10 +54,7 @@ fn macos_deployment_target() -> (u32, u32) {\n     let deployment_target = env::var(\"MACOSX_DEPLOYMENT_TARGET\").ok();\n     let version = deployment_target\n         .as_ref()\n-        .and_then(|s| {\n-            let mut i = s.splitn(2, '.');\n-            i.next().and_then(|a| i.next().map(|b| (a, b)))\n-        })\n+        .and_then(|s| s.split_once('.'))\n         .and_then(|(a, b)| a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok());\n \n     version.unwrap_or((10, 7))"}, {"sha": "fc48997f1bb2d56b3660fcc05c91968807361203", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -314,6 +314,7 @@\n #![feature(stdsimd)]\n #![feature(stmt_expr_attributes)]\n #![feature(str_internals)]\n+#![feature(str_split_once)]\n #![feature(test)]\n #![feature(thread_local)]\n #![feature(thread_local_internals)]"}, {"sha": "38ba0d2fbdb6b581dee3049738f1126acaf819dd", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -177,11 +177,8 @@ impl TryFrom<&str> for LookupHost {\n         }\n \n         // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = s.rsplitn(2, ':');\n-        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let (host, port_str) = try_opt!(s.rsplit_once(':'), \"invalid socket address\");\n         let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-\n         (host, port).try_into()\n     }\n }"}, {"sha": "656d9669e81d28201b3e206054d89d15c5deaf22", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -30,6 +30,7 @@\n #![feature(termination_trait_lib)]\n #![feature(test)]\n #![feature(total_cmp)]\n+#![feature(str_split_once)]\n \n // Public reexports\n pub use self::bench::{black_box, Bencher};"}, {"sha": "e0b6eadffa119a519a8dbc3c270acd694301756c", "filename": "library/test/src/time.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Ftest%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/library%2Ftest%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftime.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -105,30 +105,24 @@ impl TimeThreshold {\n     /// value.\n     pub fn from_env_var(env_var_name: &str) -> Option<Self> {\n         let durations_str = env::var(env_var_name).ok()?;\n+        let (warn_str, critical_str) = durations_str.split_once(',').unwrap_or_else(|| {\n+            panic!(\n+                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n+                env_var_name, durations_str\n+            )\n+        });\n \n-        // Split string into 2 substrings by comma and try to parse numbers.\n-        let mut durations = durations_str.splitn(2, ',').map(|v| {\n+        let parse_u64 = |v| {\n             u64::from_str(v).unwrap_or_else(|_| {\n                 panic!(\n                     \"Duration value in variable {} is expected to be a number, but got {}\",\n                     env_var_name, v\n                 )\n             })\n-        });\n-\n-        // Callback to be called if the environment variable has unexpected structure.\n-        let panic_on_incorrect_value = || {\n-            panic!(\n-                \"Duration variable {} expected to have 2 numbers separated by comma, but got {}\",\n-                env_var_name, durations_str\n-            );\n         };\n \n-        let (warn, critical) = (\n-            durations.next().unwrap_or_else(panic_on_incorrect_value),\n-            durations.next().unwrap_or_else(panic_on_incorrect_value),\n-        );\n-\n+        let warn = parse_u64(warn_str);\n+        let critical = parse_u64(critical_str);\n         if warn > critical {\n             panic!(\"Test execution warn time should be less or equal to the critical time\");\n         }"}, {"sha": "2d58614b1397e65bffc330236016dc4898c7e2bf", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -397,12 +397,9 @@ impl Options {\n             matches\n                 .opt_strs(\"default-setting\")\n                 .iter()\n-                .map(|s| {\n-                    let mut kv = s.splitn(2, '=');\n-                    // never panics because `splitn` always returns at least one element\n-                    let k = kv.next().unwrap().to_string();\n-                    let v = kv.next().unwrap_or(\"true\").to_string();\n-                    (k, v)\n+                .map(|s| match s.split_once('=') {\n+                    None => (s.clone(), \"true\".to_string()),\n+                    Some((k, v)) => (k.to_string(), v.to_string()),\n                 })\n                 .collect(),\n         ];\n@@ -707,11 +704,9 @@ fn parse_extern_html_roots(\n ) -> Result<BTreeMap<String, String>, &'static str> {\n     let mut externs = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern-html-root-url\") {\n-        let mut parts = arg.splitn(2, '=');\n-        let name = parts.next().ok_or(\"--extern-html-root-url must not be empty\")?;\n-        let url = parts.next().ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n+        let (name, url) =\n+            arg.split_once('=').ok_or(\"--extern-html-root-url must be of the form name=url\")?;\n         externs.insert(name.to_string(), url.to_string());\n     }\n-\n     Ok(externs)\n }"}, {"sha": "efee4c0be06d07ae7a5bde02e335f13da552e5c4", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -167,10 +167,8 @@ impl Context {\n         // `style-suffix.min.css`.  Path::extension would just return `css`\n         // which would result in `style.min-suffix.css` which isn't what we\n         // want.\n-        let mut iter = filename.splitn(2, '.');\n-        let base = iter.next().unwrap();\n-        let ext = iter.next().unwrap();\n-        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext,);\n+        let (base, ext) = filename.split_once('.').unwrap();\n+        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n         self.dst.join(&filename)\n     }\n }"}, {"sha": "f851d1a2372342967a35f663337d1adc263ed352", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -16,6 +16,7 @@\n #![feature(once_cell)]\n #![feature(type_ascription)]\n #![feature(split_inclusive)]\n+#![feature(str_split_once)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5ce64c4cd83cd0eb4f9057b075e0654fbb756d4a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -435,8 +435,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         // Try looking for methods and associated items.\n         let mut split = path_str.rsplitn(2, \"::\");\n-        // this can be an `unwrap()` because we ensure the link is never empty\n-        let (item_str, item_name) = split.next().map(|i| (i, Symbol::intern(i))).unwrap();\n+        // NB: `split`'s first element is always defined, even if the delimiter was not present.\n+        let item_str = split.next().unwrap();\n+        assert!(!item_str.is_empty());\n+        let item_name = Symbol::intern(item_str);\n         let path_root = split\n             .next()\n             .map(|f| f.to_owned())"}, {"sha": "dcfe1bb803fbae13960f68f7b06fd057a8dd36cc", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -14,6 +14,8 @@\n //! A few exceptions are allowed as there's known bugs in rustdoc, but this\n //! should catch the majority of \"broken link\" cases.\n \n+#![feature(str_split_once)]\n+\n use std::collections::hash_map::Entry;\n use std::collections::{HashMap, HashSet};\n use std::env;\n@@ -232,11 +234,12 @@ fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Opti\n         {\n             return;\n         }\n-        let mut parts = url.splitn(2, '#');\n-        let url = parts.next().unwrap();\n-        let fragment = parts.next();\n-        let mut parts = url.splitn(2, '?');\n-        let url = parts.next().unwrap();\n+        let (url, fragment) = match url.split_once('#') {\n+            None => (url, None),\n+            Some((url, fragment)) => (url, Some(fragment)),\n+        };\n+        // NB: the `splitn` always succeeds, even if the delimiter is not present.\n+        let url = url.splitn(2, '?').next().unwrap();\n \n         // Once we've plucked out the URL, parse it using our base url and\n         // then try to extract a file path."}, {"sha": "e06616a59f38c16becbd95cfbfe5759ef9898034", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -59,11 +59,10 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n             break;\n         }\n \n-        let mut parts = line.splitn(2, '=');\n-        let krate = parts.next().unwrap().trim();\n-        if parts.next().is_none() {\n-            continue;\n-        }\n+        let krate = match line.split_once('=') {\n+            None => continue,\n+            Some((krate, _)) => krate.trim(),\n+        };\n \n         // Don't worry about depending on core/std while not writing `extern crate\n         // core/std` -- that's intentional."}, {"sha": "a7199fdfce66bf9f2e8ddddad99aab276784f65b", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -85,47 +85,61 @@ fn extract_error_codes(\n     for line in f.lines() {\n         let s = line.trim();\n         if !reached_no_explanation && s.starts_with('E') && s.contains(\"include_str!(\\\"\") {\n-            if let Some(err_code) = s.splitn(2, ':').next() {\n-                let err_code = err_code.to_owned();\n-                if !error_codes.contains_key(&err_code) {\n-                    error_codes.insert(err_code.clone(), false);\n-                }\n-                // Now we extract the tests from the markdown file!\n-                let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").nth(1));\n-                let md_file_name = some_or_continue!(md.splitn(2, \"\\\")\").next());\n-                let path = some_or_continue!(path.parent())\n-                    .join(md_file_name)\n-                    .canonicalize()\n-                    .expect(\"failed to canonicalize error explanation file path\");\n-                match read_to_string(&path) {\n-                    Ok(content) => {\n-                        if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n-                            && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n-                        {\n-                            errors.push(format!(\n-                                \"`{}` doesn't use its own error code in compile_fail example\",\n-                                path.display(),\n-                            ));\n-                        }\n-                        if check_error_code_explanation(&content, error_codes, err_code) {\n-                            errors.push(format!(\n-                                \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n-                                path.display(),\n-                            ));\n-                        }\n+            let err_code = s\n+                .split_once(':')\n+                .expect(\n+                    format!(\n+                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} without a `:` delimiter\",\n+                        s,\n+                    ).as_str()\n+                )\n+                .0\n+                .to_owned();\n+            if !error_codes.contains_key(&err_code) {\n+                error_codes.insert(err_code.clone(), false);\n+            }\n+            // Now we extract the tests from the markdown file!\n+            let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n+                None => continue,\n+                Some((_, md)) => match md.split_once(\"\\\")\") {\n+                    None => continue,\n+                    Some((file_name, _)) => file_name,\n+                },\n+            };\n+            let path = some_or_continue!(path.parent())\n+                .join(md_file_name)\n+                .canonicalize()\n+                .expect(\"failed to canonicalize error explanation file path\");\n+            match read_to_string(&path) {\n+                Ok(content) => {\n+                    if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n+                        && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n+                    {\n+                        errors.push(format!(\n+                            \"`{}` doesn't use its own error code in compile_fail example\",\n+                            path.display(),\n+                        ));\n                     }\n-                    Err(e) => {\n-                        eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n+                    if check_error_code_explanation(&content, error_codes, err_code) {\n+                        errors.push(format!(\n+                            \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n+                            path.display(),\n+                        ));\n                     }\n                 }\n+                Err(e) => {\n+                    eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n+                }\n             }\n         } else if reached_no_explanation && s.starts_with('E') {\n-            if let Some(err_code) = s.splitn(2, ',').next() {\n-                let err_code = err_code.to_owned();\n-                if !error_codes.contains_key(&err_code) {\n-                    // this check should *never* fail!\n-                    error_codes.insert(err_code, false);\n-                }\n+            let err_code = match s.split_once(',') {\n+                None => s,\n+                Some((err_code, _)) => err_code,\n+            }\n+            .to_string();\n+            if !error_codes.contains_key(&err_code) {\n+                // this check should *never* fail!\n+                error_codes.insert(err_code, false);\n             }\n         } else if s == \";\" {\n             reached_no_explanation = true;\n@@ -137,12 +151,15 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n     for line in f.lines() {\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n-            if let Some(err_code) = s.splitn(2, ']').next() {\n-                if let Some(err_code) = err_code.splitn(2, '[').nth(1) {\n-                    let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n-                    *nb = true;\n-                }\n-            }\n+            let err_code = match s.split_once(']') {\n+                None => continue,\n+                Some((err_code, _)) => match err_code.split_once('[') {\n+                    None => continue,\n+                    Some((_, err_code)) => err_code,\n+                },\n+            };\n+            let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n+            *nb = true;\n         }\n     }\n }"}, {"sha": "93d4d3d8047d82678686876fe0205157288df6a3", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -23,7 +23,7 @@ pub fn check(root: &Path, bad: &mut bool) {\n         }\n \n         // Extract source value.\n-        let source = line.splitn(2, '=').nth(1).unwrap().trim();\n+        let source = line.split_once('=').unwrap().1.trim();\n \n         // Ensure source is allowed.\n         if !ALLOWED_SOURCES.contains(&&*source) {"}, {"sha": "3c2880d0d5e261eaeb3063d4617eaf5502688ccc", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -112,6 +112,7 @@ pub fn check(\n                 let gate_test_str = \"gate-test-\";\n \n                 let feature_name = match line.find(gate_test_str) {\n+                    // NB: the `splitn` always succeeds, even if the delimiter is not present.\n                     Some(i) => line[i + gate_test_str.len()..].splitn(2, ' ').next().unwrap(),\n                     None => continue,\n                 };"}, {"sha": "e11d293210b0a97c566e96745c0ce8b30dfe37d5", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -3,6 +3,8 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n+#![feature(str_split_once)]\n+\n use std::fs::File;\n use std::io::Read;\n use walkdir::{DirEntry, WalkDir};"}, {"sha": "03f4efea983bb2a85bf62838708246f082a006f1", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ec4b8258b3f59ded7b2cfae8484be976c658af/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=17ec4b8258b3f59ded7b2cfae8484be976c658af", "patch": "@@ -19,14 +19,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     //\n                     // For now, just make sure that there is a corresponding\n                     // `$testname.rs` file.\n-                    let testname = file_path\n-                        .file_name()\n-                        .unwrap()\n-                        .to_str()\n-                        .unwrap()\n-                        .splitn(2, '.')\n-                        .next()\n-                        .unwrap();\n+                    //\n+                    // NB: We do not use file_stem() as some file names have multiple `.`s and we\n+                    // must strip all of them.\n+                    let testname =\n+                        file_path.file_name().unwrap().to_str().unwrap().split_once('.').unwrap().0;\n                     if !file_path.with_file_name(testname).with_extension(\"rs\").exists() {\n                         println!(\"Stray file with UI testing output: {:?}\", file_path);\n                         *bad = true;"}]}