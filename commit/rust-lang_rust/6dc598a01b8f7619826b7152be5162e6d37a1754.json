{"sha": "6dc598a01b8f7619826b7152be5162e6d37a1754", "node_id": "C_kwDOAAsO6NoAKDZkYzU5OGEwMWI4Zjc2MTk4MjZiNzE1MmJlNTE2MmU2ZDM3YTE3NTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-09T07:13:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-09T07:13:46Z"}, "message": "Auto merge of #97862 - SparrowLii:superset, r=lcnr\n\noptimize `superset` method of `IntervalSet`\n\nGiven that intervals in the `IntervalSet` are sorted and strictly separated( it means the `end` of the previous interval will not be equal to the `start` of the next interval), we can reduce the complexity of the `superset` method from O(NMlogN) to O(2N) (N is the number of intervals and M is the length of each interval)", "tree": {"sha": "97f84ee4801fd41602accd3360a892ef07560160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f84ee4801fd41602accd3360a892ef07560160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dc598a01b8f7619826b7152be5162e6d37a1754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc598a01b8f7619826b7152be5162e6d37a1754", "html_url": "https://github.com/rust-lang/rust/commit/6dc598a01b8f7619826b7152be5162e6d37a1754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dc598a01b8f7619826b7152be5162e6d37a1754/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14947924dfc5f317b564c771f7b98e73d05565e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/14947924dfc5f317b564c771f7b98e73d05565e1", "html_url": "https://github.com/rust-lang/rust/commit/14947924dfc5f317b564c771f7b98e73d05565e1"}, {"sha": "726b35bd701457bc632ca1c5cdb5070a71d6de03", "url": "https://api.github.com/repos/rust-lang/rust/commits/726b35bd701457bc632ca1c5cdb5070a71d6de03", "html_url": "https://github.com/rust-lang/rust/commit/726b35bd701457bc632ca1c5cdb5070a71d6de03"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "3592fb33077d92ed33e392c75bbc88ec117f419b", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6dc598a01b8f7619826b7152be5162e6d37a1754/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc598a01b8f7619826b7152be5162e6d37a1754/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=6dc598a01b8f7619826b7152be5162e6d37a1754", "patch": "@@ -1,7 +1,7 @@\n use std::iter::Step;\n use std::marker::PhantomData;\n-use std::ops::Bound;\n use std::ops::RangeBounds;\n+use std::ops::{Bound, Range};\n \n use crate::vec::Idx;\n use crate::vec::IndexVec;\n@@ -11,6 +11,10 @@ use smallvec::SmallVec;\n mod tests;\n \n /// Stores a set of intervals on the indices.\n+///\n+/// The elements in `map` are sorted and non-adjacent, which means\n+/// the second value of the previous element is *greater* than the\n+/// first value of the following element.\n #[derive(Debug, Clone)]\n pub struct IntervalSet<I> {\n     // Start, end\n@@ -84,7 +88,7 @@ impl<I: Idx> IntervalSet<I> {\n         // continue to the next range. We're looking here for the first\n         // range which starts *non-adjacently* to our end.\n         let next = self.map.partition_point(|r| r.0 <= end + 1);\n-        if let Some(right) = next.checked_sub(1) {\n+        let result = if let Some(right) = next.checked_sub(1) {\n             let (prev_start, prev_end) = self.map[right];\n             if prev_end + 1 >= start {\n                 // If the start for the inserted range is adjacent to the\n@@ -99,25 +103,25 @@ impl<I: Idx> IntervalSet<I> {\n                     if left != right {\n                         self.map.drain(left..right);\n                     }\n-                    return true;\n+                    true\n                 } else {\n                     // We overlap with the previous range, increase it to\n                     // include us.\n                     //\n                     // Make sure we're actually going to *increase* it though --\n                     // it may be that end is just inside the previously existing\n                     // set.\n-                    return if end > prev_end {\n+                    if end > prev_end {\n                         self.map[right].1 = end;\n                         true\n                     } else {\n                         false\n-                    };\n+                    }\n                 }\n             } else {\n                 // Otherwise, we don't overlap, so just insert\n                 self.map.insert(right + 1, (start, end));\n-                return true;\n+                true\n             }\n         } else {\n             if self.map.is_empty() {\n@@ -127,8 +131,16 @@ impl<I: Idx> IntervalSet<I> {\n             } else {\n                 self.map.insert(next, (start, end));\n             }\n-            return true;\n-        }\n+            true\n+        };\n+        debug_assert!(\n+            self.check_invariants(),\n+            \"wrong intervals after insert {:?}..={:?} to {:?}\",\n+            start,\n+            end,\n+            self\n+        );\n+        result\n     }\n \n     pub fn contains(&self, needle: I) -> bool {\n@@ -145,9 +157,26 @@ impl<I: Idx> IntervalSet<I> {\n     where\n         I: Step,\n     {\n-        // FIXME: Performance here is probably not great. We will be doing a lot\n-        // of pointless tree traversals.\n-        other.iter().all(|elem| self.contains(elem))\n+        let mut sup_iter = self.iter_intervals();\n+        let mut current = None;\n+        let contains = |sup: Range<I>, sub: Range<I>, current: &mut Option<Range<I>>| {\n+            if sup.end < sub.start {\n+                // if `sup.end == sub.start`, the next sup doesn't contain `sub.start`\n+                None // continue to the next sup\n+            } else if sup.end >= sub.end && sup.start <= sub.start {\n+                *current = Some(sup); // save the current sup\n+                Some(true)\n+            } else {\n+                Some(false)\n+            }\n+        };\n+        other.iter_intervals().all(|sub| {\n+            current\n+                .take()\n+                .and_then(|sup| contains(sup, sub.clone(), &mut current))\n+                .or_else(|| sup_iter.find_map(|sup| contains(sup, sub.clone(), &mut current)))\n+                .unwrap_or(false)\n+        })\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -174,7 +203,10 @@ impl<I: Idx> IntervalSet<I> {\n \n     pub fn insert_all(&mut self) {\n         self.clear();\n-        self.map.push((0, self.domain.try_into().unwrap()));\n+        if let Some(end) = self.domain.checked_sub(1) {\n+            self.map.push((0, end.try_into().unwrap()));\n+        }\n+        debug_assert!(self.check_invariants());\n     }\n \n     pub fn union(&mut self, other: &IntervalSet<I>) -> bool\n@@ -186,8 +218,21 @@ impl<I: Idx> IntervalSet<I> {\n         for range in other.iter_intervals() {\n             did_insert |= self.insert_range(range);\n         }\n+        debug_assert!(self.check_invariants());\n         did_insert\n     }\n+\n+    // Check the intervals are valid, sorted and non-adjacent\n+    fn check_invariants(&self) -> bool {\n+        let mut current: Option<u32> = None;\n+        for (start, end) in &self.map {\n+            if start > end || current.map_or(false, |x| x + 1 >= *start) {\n+                return false;\n+            }\n+            current = Some(*end);\n+        }\n+        current.map_or(true, |x| x < self.domain as u32)\n+    }\n }\n \n /// This data structure optimizes for cases where the stored bits in each row"}, {"sha": "375af60f6620758f7d842362057358633a6196c0", "filename": "compiler/rustc_index/src/interval/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dc598a01b8f7619826b7152be5162e6d37a1754/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc598a01b8f7619826b7152be5162e6d37a1754/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs?ref=6dc598a01b8f7619826b7152be5162e6d37a1754", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn insert_collapses() {\n-    let mut set = IntervalSet::<u32>::new(3000);\n+    let mut set = IntervalSet::<u32>::new(10000);\n     set.insert_range(9831..=9837);\n     set.insert_range(43..=9830);\n     assert_eq!(set.iter_intervals().collect::<Vec<_>>(), [43..9838]);"}]}