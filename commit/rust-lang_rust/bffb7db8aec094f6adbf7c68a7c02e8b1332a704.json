{"sha": "bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZmI3ZGI4YWVjMDk0ZjZhZGJmN2M2OGE3YzAyZThiMTMzMmE3MDQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-12T17:17:36Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-12T18:18:31Z"}, "message": "syntax: clarify that trailing separators are never required", "tree": {"sha": "d5762fb0cc2f1a4c296f4b2942df15fc02641ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5762fb0cc2f1a4c296f4b2942df15fc02641ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "html_url": "https://github.com/rust-lang/rust/commit/bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d04ed0c4931f36f15e18f46b233d13572f4c9107", "url": "https://api.github.com/repos/rust-lang/rust/commits/d04ed0c4931f36f15e18f46b233d13572f4c9107", "html_url": "https://github.com/rust-lang/rust/commit/d04ed0c4931f36f15e18f46b233d13572f4c9107"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "cddf8de479bdb56052d482ff488f4f7290954430", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "patch": "@@ -1,6 +1,6 @@\n import either::{either, left, right};\n import ast_util::spanned;\n-import common::{parser_common, seq_sep};\n+import common::{parser_common, seq_sep_trailing_disallowed};\n \n export attr_or_ext;\n export parser_attr;\n@@ -111,7 +111,7 @@ impl parser_attr for parser {\n \n     fn parse_meta_seq() -> [@ast::meta_item] {\n         ret self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n+                           seq_sep_trailing_disallowed(token::COMMA),\n                            {|p| p.parse_meta_item()}).node;\n     }\n "}, {"sha": "0520993de745bfdcb9f7713d9bc1c87d0ecedead", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "patch": "@@ -4,25 +4,23 @@ import parser::parser;\n \n type seq_sep = {\n     sep: option<token::token>,\n-    trailing_opt: bool   // is trailing separator optional?\n+    trailing_sep_allowed: bool\n };\n \n-fn seq_sep(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: false};\n+fn seq_sep_trailing_disallowed(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_sep_allowed: false};\n }\n-fn seq_sep_opt(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: true};\n+fn seq_sep_trailing_allowed(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_sep_allowed: true};\n }\n fn seq_sep_none() -> seq_sep {\n-    ret {sep: option::none, trailing_opt: false};\n+    ret {sep: option::none, trailing_sep_allowed: false};\n }\n \n-\n fn token_to_str(reader: reader, ++token: token::token) -> str {\n     token::to_str(*reader.interner, token)\n }\n \n-\n // This should be done with traits, once traits work\n impl parser_common for parser {\n \n@@ -203,7 +201,7 @@ impl parser_common for parser {\n                         else { self.expect(t); } }\n               _ { }\n             }\n-            if sep.trailing_opt && self.token == ket { break; }\n+            if sep.trailing_sep_allowed && self.token == ket { break; }\n             v += [f(self)];\n         }\n         ret v;"}, {"sha": "33233be3053f7d15f151f43bc4200e6894b59e2d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bffb7db8aec094f6adbf7c68a7c02e8b1332a704/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bffb7db8aec094f6adbf7c68a7c02e8b1332a704", "patch": "@@ -9,7 +9,8 @@ import ast::*;\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n import attr::parser_attr;\n-import common::{seq_sep, seq_sep_opt, seq_sep_none, token_to_str};\n+import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n+                seq_sep_none, token_to_str};\n import common::*;//{parser_common};\n import dvec::{dvec, extensions};\n \n@@ -167,9 +168,9 @@ class parser {\n     }\n \n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n-        let inputs =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA)) { |p|\n+        let inputs = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA)) { |p|\n             let mode = p.parse_arg_mode();\n             let name = if is_plain_ident(p.token)\n                 && p.look_ahead(1u) == token::COLON {\n@@ -260,21 +261,21 @@ class parser {\n     fn parse_ty_constr(fn_args: [arg]) -> @constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA),\n-                                     {|p| p.parse_constr_arg(fn_args)});\n+        let args = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_constr_arg(fn_args)});\n         ret @spanned(lo, self.span.hi,\n                      {path: path, args: args, id: self.get_id()});\n     }\n \n     fn parse_constr_in_type() -> @ty_constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args: [@ty_constr_arg] =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA),\n-                                     {|p| p.parse_type_constr_arg()});\n+        let args: [@ty_constr_arg] = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_type_constr_arg()});\n         let hi = self.span.lo;\n         let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n         ret @spanned(lo, hi, tc);\n@@ -389,9 +390,10 @@ class parser {\n             self.bump();\n             ty_ptr(self.parse_mt())\n         } else if self.token == token::LBRACE {\n-            let elems = self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                                 seq_sep_opt(token::COMMA),\n-                                                 {|p| p.parse_ty_field()});\n+            let elems = self.parse_unspanned_seq(\n+                token::LBRACE, token::RBRACE,\n+                seq_sep_trailing_allowed(token::COMMA),\n+                {|p| p.parse_ty_field()});\n             if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n@@ -802,9 +804,9 @@ class parser {\n         } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            let es =\n-                self.parse_seq_to_end(token::RBRACKET, seq_sep(token::COMMA),\n-                                      {|p| p.parse_expr()});\n+            let es = self.parse_seq_to_end(\n+                token::RBRACKET, seq_sep_trailing_disallowed(token::COMMA),\n+                {|p| p.parse_expr()});\n             hi = self.span.hi;\n             ex = expr_vec(es, mutbl);\n         } else if self.token == token::POUND\n@@ -833,9 +835,10 @@ class parser {\n             ex = ex_ext.node;\n         } else if self.eat_keyword(\"bind\") {\n             let e = self.parse_expr_res(RESTRICT_NO_CALL_EXPRS);\n-            let es = self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                              seq_sep(token::COMMA),\n-                                              {|p| p.parse_expr_or_hole()});\n+            let es = self.parse_unspanned_seq(\n+                token::LPAREN, token::RPAREN,\n+                seq_sep_trailing_disallowed(token::COMMA),\n+                {|p| p.parse_expr_or_hole()});\n             hi = self.span.hi;\n             ex = expr_bind(e, es);\n         } else if self.eat_keyword(\"fail\") {\n@@ -937,7 +940,7 @@ class parser {\n         }\n         let pth = self.parse_path_without_tps();\n         //temporary for a backwards-compatible cycle:\n-        let sep = seq_sep(token::COMMA);\n+        let sep = seq_sep_trailing_disallowed(token::COMMA);\n         let mut e = none;\n         if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n             let lo = self.span.lo;\n@@ -1009,10 +1012,10 @@ class parser {\n             alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n-                let es_opt =\n-                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                             seq_sep(token::COMMA),\n-                                             {|p| p.parse_expr_or_hole()});\n+                let es_opt = self.parse_unspanned_seq(\n+                    token::LPAREN, token::RPAREN,\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_expr_or_hole()});\n                 hi = self.span.hi;\n \n                 let nd =\n@@ -1479,11 +1482,10 @@ class parser {\n                         self.expect(token::RPAREN);\n                       }\n                       _ {\n-                        args =\n-                            self.parse_unspanned_seq(token::LPAREN,\n-                                                     token::RPAREN,\n-                                                     seq_sep(token::COMMA),\n-                                                     {|p| p.parse_pat()});\n+                        args = self.parse_unspanned_seq(\n+                            token::LPAREN, token::RPAREN,\n+                            seq_sep_trailing_disallowed(token::COMMA),\n+                            {|p| p.parse_pat()});\n                         hi = self.span.hi;\n                       }\n                     }\n@@ -1783,8 +1785,9 @@ class parser {\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: [arg_or_capture_item] =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA), parse_arg_fn);\n+            self.parse_unspanned_seq(\n+                token::LPAREN, token::RPAREN,\n+                seq_sep_trailing_disallowed(token::COMMA), parse_arg_fn);\n \n         let inputs = either::lefts(args_or_capture_items);\n         let capture_clause = @either::rights(args_or_capture_items);\n@@ -1810,10 +1813,10 @@ class parser {\n             if self.eat(token::OROR) {\n                 []\n             } else {\n-                self.parse_unspanned_seq(token::BINOP(token::OR),\n-                                         token::BINOP(token::OR),\n-                                         seq_sep(token::COMMA),\n-                                         {|p| p.parse_fn_block_arg()})\n+                self.parse_unspanned_seq(\n+                    token::BINOP(token::OR), token::BINOP(token::OR),\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_fn_block_arg()})\n             }\n         };\n         let output = if self.eat(token::RARROW) {\n@@ -1984,8 +1987,9 @@ class parser {\n     }\n \n     fn parse_iface_ref_list() -> [@iface_ref] {\n-        self.parse_seq_to_before_end(token::LBRACE, seq_sep(token::COMMA),\n-                                     {|p| p.parse_iface_ref()})\n+        self.parse_seq_to_before_end(\n+            token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_iface_ref()})\n     }\n \n     fn parse_item_class() -> item_info {\n@@ -2265,11 +2269,10 @@ class parser {\n             let mut args = [], disr_expr = none;\n             if self.token == token::LPAREN {\n                 all_nullary = false;\n-                let arg_tys =\n-                    self.parse_unspanned_seq(token::LPAREN,\n-                                             token::RPAREN,\n-                                             seq_sep(token::COMMA),\n-                                             {|p| p.parse_ty(false)});\n+                let arg_tys = self.parse_unspanned_seq(\n+                    token::LPAREN, token::RPAREN,\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_ty(false)});\n                 for arg_tys.each {|ty|\n                     args += [{ty: ty, id: self.get_id()}];\n                 }\n@@ -2409,11 +2412,10 @@ class parser {\n \n                   // foo::bar::{a,b,c}\n                   token::LBRACE {\n-                    let idents =\n-                        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                                 seq_sep(token::COMMA),\n-                                                 {|p|\n-                                                  p.parse_path_list_ident()});\n+                    let idents = self.parse_unspanned_seq(\n+                        token::LBRACE, token::RBRACE,\n+                        seq_sep_trailing_disallowed(token::COMMA),\n+                        {|p| p.parse_path_list_ident()});\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: []};"}]}