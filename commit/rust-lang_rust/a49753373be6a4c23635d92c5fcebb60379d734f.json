{"sha": "a49753373be6a4c23635d92c5fcebb60379d734f", "node_id": "C_kwDOAAsO6NoAKGE0OTc1MzM3M2JlNmE0YzIzNjM1ZDkyYzVmY2ViYjYwMzc5ZDczNGY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-05-01T17:52:28Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-05-01T23:56:23Z"}, "message": "Relax implicit `W: Sized` bound on `BufWriter<W>`", "tree": {"sha": "15acc6281f3a1d8f0d1c00238a47ec3f5dd32a22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15acc6281f3a1d8f0d1c00238a47ec3f5dd32a22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49753373be6a4c23635d92c5fcebb60379d734f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49753373be6a4c23635d92c5fcebb60379d734f", "html_url": "https://github.com/rust-lang/rust/commit/a49753373be6a4c23635d92c5fcebb60379d734f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49753373be6a4c23635d92c5fcebb60379d734f/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e77b14e2acc1efbd649990873a8db678cf2086fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e77b14e2acc1efbd649990873a8db678cf2086fa", "html_url": "https://github.com/rust-lang/rust/commit/e77b14e2acc1efbd649990873a8db678cf2086fa"}], "stats": {"total": 142, "additions": 72, "deletions": 70}, "files": [{"sha": "0e2450655e5bf0741158f751bfcf09a9718754bd", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 70, "deletions": 68, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=a49753373be6a4c23635d92c5fcebb60379d734f", "patch": "@@ -67,8 +67,7 @@ use crate::ptr;\n /// [`TcpStream`]: crate::net::TcpStream\n /// [`flush`]: BufWriter::flush\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W: Write> {\n-    inner: W,\n+pub struct BufWriter<W: ?Sized + Write> {\n     // The buffer. Avoid using this like a normal `Vec` in common code paths.\n     // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n     // methods that require bounds checking or the like. This makes an enormous\n@@ -78,6 +77,7 @@ pub struct BufWriter<W: Write> {\n     // write the buffered data a second time in BufWriter's destructor. This\n     // flag tells the Drop impl if it should skip the flush.\n     panicked: bool,\n+    inner: W,\n }\n \n impl<W: Write> BufWriter<W> {\n@@ -115,6 +115,69 @@ impl<W: Write> BufWriter<W> {\n         BufWriter { inner, buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n+    ///\n+    /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError::new(self, e)),\n+            Ok(()) => Ok(self.into_parts().0),\n+        }\n+    }\n+\n+    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n+    /// unwritten data.\n+    ///\n+    /// If the underlying writer panicked, it is not known what portion of the data was written.\n+    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n+    /// contents can still be recovered).\n+    ///\n+    /// `into_parts` makes no attempt to flush data and cannot fail.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::{BufWriter, Write};\n+    ///\n+    /// let mut buffer = [0u8; 10];\n+    /// let mut stream = BufWriter::new(buffer.as_mut());\n+    /// write!(stream, \"too much data\").unwrap();\n+    /// stream.flush().expect_err(\"it doesn't fit\");\n+    /// let (recovered_writer, buffered_data) = stream.into_parts();\n+    /// assert_eq!(recovered_writer.len(), 0);\n+    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n+    /// ```\n+    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n+    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n+        let buf = mem::take(&mut self.buf);\n+        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n+\n+        // SAFETY: forget(self) prevents double dropping inner\n+        let inner = unsafe { ptr::read(&self.inner) };\n+        mem::forget(self);\n+\n+        (inner, buf)\n+    }\n+}\n+\n+impl<W: ?Sized + Write> BufWriter<W> {\n     /// Send data in our local buffer into the inner writer, looping as\n     /// necessary until either it's all been sent or an error occurs.\n     ///\n@@ -284,67 +347,6 @@ impl<W: Write> BufWriter<W> {\n         self.buf.capacity()\n     }\n \n-    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n-    ///\n-    /// The buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // unwrap the TcpStream and flush the buffer\n-    /// let stream = buffer.into_inner().unwrap();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n-        match self.flush_buf() {\n-            Err(e) => Err(IntoInnerError::new(self, e)),\n-            Ok(()) => Ok(self.into_parts().0),\n-        }\n-    }\n-\n-    /// Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n-    /// unwritten data.\n-    ///\n-    /// If the underlying writer panicked, it is not known what portion of the data was written.\n-    /// In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n-    /// contents can still be recovered).\n-    ///\n-    /// `into_parts` makes no attempt to flush data and cannot fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::io::{BufWriter, Write};\n-    ///\n-    /// let mut buffer = [0u8; 10];\n-    /// let mut stream = BufWriter::new(buffer.as_mut());\n-    /// write!(stream, \"too much data\").unwrap();\n-    /// stream.flush().expect_err(\"it doesn't fit\");\n-    /// let (recovered_writer, buffered_data) = stream.into_parts();\n-    /// assert_eq!(recovered_writer.len(), 0);\n-    /// assert_eq!(&buffered_data.unwrap(), b\"ata\");\n-    /// ```\n-    #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n-    pub fn into_parts(mut self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n-        let buf = mem::take(&mut self.buf);\n-        let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n-\n-        // SAFETY: forget(self) prevents double dropping inner\n-        let inner = unsafe { ptr::read(&self.inner) };\n-        mem::forget(self);\n-\n-        (inner, buf)\n-    }\n-\n     // Ensure this function does not get inlined into `write`, so that it\n     // remains inlineable and its common path remains as short as possible.\n     // If this function ends up being called frequently relative to `write`,\n@@ -511,7 +513,7 @@ impl fmt::Debug for WriterPanicked {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for BufWriter<W> {\n+impl<W: ?Sized + Write> Write for BufWriter<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n@@ -640,20 +642,20 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W>\n+impl<W: ?Sized + Write> fmt::Debug for BufWriter<W>\n where\n     W: fmt::Debug,\n {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufWriter\")\n-            .field(\"writer\", &self.inner)\n+            .field(\"writer\", &&self.inner)\n             .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n             .finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write + Seek> Seek for BufWriter<W> {\n+impl<W: ?Sized + Write + Seek> Seek for BufWriter<W> {\n     /// Seek to the offset, in bytes, in the underlying writer.\n     ///\n     /// Seeking always writes out the internal buffer before seeking.\n@@ -664,7 +666,7 @@ impl<W: Write + Seek> Seek for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Drop for BufWriter<W> {\n+impl<W: ?Sized + Write> Drop for BufWriter<W> {\n     fn drop(&mut self) {\n         if !self.panicked {\n             // dtors should not panic, so we ignore a failed flush"}, {"sha": "7c2a772774c15f886b024da02f47920eac97c674", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=a49753373be6a4c23635d92c5fcebb60379d734f", "patch": "@@ -86,7 +86,7 @@ impl<W: Write + ?Sized> BufferedCopySpec for W {\n     }\n }\n \n-impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+impl<I: ?Sized + Write> BufferedCopySpec for BufWriter<I> {\n     fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n         if writer.capacity() < DEFAULT_BUF_SIZE {\n             return stack_buffer_copy(reader, writer);"}, {"sha": "7d49bbdcbe063bde033f156cc9711c6fde8a80b4", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49753373be6a4c23635d92c5fcebb60379d734f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=a49753373be6a4c23635d92c5fcebb60379d734f", "patch": "@@ -495,7 +495,7 @@ impl<T: ?Sized + CopyRead> CopyRead for BufReader<T> {\n     }\n }\n \n-impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+impl<T: ?Sized + CopyWrite> CopyWrite for BufWriter<T> {\n     fn properties(&self) -> CopyParams {\n         self.get_ref().properties()\n     }"}]}