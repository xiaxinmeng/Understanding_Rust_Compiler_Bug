{"sha": "2d1d3fef6205276e0123dea96cc346d1da7df6d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMWQzZmVmNjIwNTI3NmUwMTIzZGVhOTZjYzM0NmQxZGE3ZGY2ZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-09T10:58:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-24T17:27:38Z"}, "message": "support user annotations in fns, methods", "tree": {"sha": "cd4fb8532d974e363a21356aa478674067b5f36f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd4fb8532d974e363a21356aa478674067b5f36f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1d3fef6205276e0123dea96cc346d1da7df6d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1d3fef6205276e0123dea96cc346d1da7df6d0", "html_url": "https://github.com/rust-lang/rust/commit/2d1d3fef6205276e0123dea96cc346d1da7df6d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1d3fef6205276e0123dea96cc346d1da7df6d0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1643d2ea93b02e2cc0a08e74918f37d79ee159", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1643d2ea93b02e2cc0a08e74918f37d79ee159", "html_url": "https://github.com/rust-lang/rust/commit/5f1643d2ea93b02e2cc0a08e74918f37d79ee159"}], "stats": {"total": 365, "additions": 339, "deletions": 26}, "files": [{"sha": "b10f4785f16377d3e08cef3fdd7d12928e845048", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -68,7 +68,7 @@ pub enum Def {\n     Const(DefId),\n     Static(DefId, bool /* is_mutbl */),\n     StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n-    VariantCtor(DefId, CtorKind),\n+    VariantCtor(DefId, CtorKind), // DefId refers to the enum variant\n     Method(DefId),\n     AssociatedConst(DefId),\n "}, {"sha": "8a2332cee2e1c0bbf4df94f6808f96f5b1504341", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -188,6 +188,36 @@ impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n     }\n }\n \n+impl<'gcx, V> Canonical<'gcx, V> {\n+    /// Allows you to map the `value` of a canonical while keeping the\n+    /// same set of bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the\n+    /// name!  In particular, the new value `W` must use all **the\n+    /// same type/region variables** in **precisely the same order**\n+    /// as the original! (The ordering is defined by the\n+    /// `TypeFoldable` implementation of the type in question.)\n+    ///\n+    /// An example of a **correct** use of this:\n+    ///\n+    /// ```rust,ignore\n+    /// let a: Canonical<'_, T> = ...;\n+    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n+    /// ```\n+    ///\n+    /// An example of an **incorrect** use of this:\n+    ///\n+    /// ```rust,ignore\n+    /// let a: Canonical<'tcx, T> = ...;\n+    /// let ty: Ty<'tcx> = ...;\n+    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n+    /// ```\n+    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'gcx, W> {\n+        let Canonical { variables, value } = self;\n+        Canonical { variables, value: map_op(value) }\n+    }\n+}\n+\n pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "9a771e3d451a52f754d5c59930a2ba96241a2e3f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -265,6 +265,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             }\n                         })\n                         .collect();\n+                    // FIXME(#47184) -- user given type annot on ADTs\n                     ExprKind::Adt {\n                         adt_def,\n                         substs,\n@@ -423,6 +424,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n+                            // FIXME(#47184) -- user given type annot on ADTs\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: 0,\n@@ -448,6 +450,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n+                                    // FIXME(#47184) -- user given type annot on ADTs\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n@@ -686,26 +689,78 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                 expr: &hir::Expr,\n-                                 custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n-                                 -> Expr<'tcx> {\n+fn user_annotated_ty_for_def(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    hir_id: hir::HirId,\n+    def: &Def,\n+) -> Option<CanonicalTy<'tcx>> {\n+    let user_substs = cx.tables().user_substs(hir_id)?;\n+    Some(match def {\n+        // A reference to something callable -- e.g., a fn, method, or\n+        // a tuple-struct or tuple-variant. This has the type of a\n+        // `Fn` but with the user-given substitutions.\n+        Def::Fn(_) |\n+        Def::Method(_) |\n+        Def::StructCtor(_, CtorKind::Fn) |\n+        Def::VariantCtor(_, CtorKind::Fn) =>\n+            user_substs.unchecked_map(|user_substs| {\n+                // Here, we just pair a `DefId` with the\n+                // `user_substs`, so no new types etc are introduced.\n+                cx.tcx().mk_fn_def(def.def_id(), user_substs)\n+            }),\n+\n+        Def::Const(_def_id) |\n+        Def::AssociatedConst(_def_id) =>\n+            bug!(\"unimplemented\"),\n+\n+        // A unit struct/variant which is used as a value (e.g.,\n+        // `None`). This has the type of the enum/struct that defines\n+        // this variant -- but with the substitutions given by the\n+        // user.\n+        Def::StructCtor(_def_id, CtorKind::Const) |\n+        Def::VariantCtor(_def_id, CtorKind::Const) =>\n+            match &cx.tables().node_id_to_type(hir_id).sty {\n+                ty::TyAdt(adt_def, _) =>\n+                    user_substs.unchecked_map(|user_substs| {\n+                        // Here, we just pair an `AdtDef` with the\n+                        // `user_substs`, so no new types etc are introduced.\n+                        cx.tcx().mk_adt(adt_def, user_substs)\n+                    }),\n+                sty => bug!(\"unexpected sty: {:?}\", sty),\n+            },\n+\n+        _ =>\n+            bug!(\"user_annotated_ty_for_def: unexpected def {:?} at {:?}\", def, hir_id)\n+    })\n+}\n+\n+fn method_callee<'a, 'gcx, 'tcx>(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    expr: &hir::Expr,\n+    overloaded_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n+) -> Expr<'tcx> {\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        if let Some(def) = cx.tables().type_dependent_defs().get(expr.hir_id) {\n-            (def.def_id(), cx.tables().node_substs(expr.hir_id))\n-        } else {\n-            span_bug!(expr.span, \"no type-dependent def for method callee\")\n+    let (def_id, substs, user_ty) = match overloaded_callee {\n+        Some((def_id, substs)) => (def_id, substs, None),\n+        None => {\n+            let type_dependent_defs = cx.tables().type_dependent_defs();\n+            let def = type_dependent_defs\n+                .get(expr.hir_id)\n+                .unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no type-dependent def for method callee\")\n+                });\n+            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, def);\n+            (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n-    });\n+    };\n     let ty = cx.tcx().mk_fn_def(def_id, substs);\n     Expr {\n         temp_lifetime,\n         ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: ty::Const::zero_sized(cx.tcx(), ty),\n-            user_ty: None, // TODO\n+            user_ty,\n         },\n     }\n }\n@@ -756,12 +811,15 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Fn(_) |\n         Def::Method(_) |\n         Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n-            literal: ty::Const::zero_sized(\n-                cx.tcx,\n-                cx.tables().node_id_to_type(expr.hir_id),\n-            ),\n-            user_ty: None, // TODO\n+        Def::VariantCtor(_, CtorKind::Fn) => {\n+            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, &def);\n+            ExprKind::Literal {\n+                literal: ty::Const::zero_sized(\n+                    cx.tcx,\n+                    cx.tables().node_id_to_type(expr.hir_id),\n+                ),\n+                user_ty,\n+            }\n         },\n \n         Def::Const(def_id) |\n@@ -772,11 +830,12 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 substs,\n                 cx.tables().node_id_to_type(expr.hir_id),\n             ),\n-            user_ty: None, // TODO?\n+            user_ty: None, // FIXME(#47184) -- user given type annot on constants\n         },\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n+            // FIXME(#47184) -- user given type annot on ADTs\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n@@ -963,12 +1022,13 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                     expr: &'tcx hir::Expr,\n-                                     place_ty: Ty<'tcx>,\n-                                     custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n-                                     args: Vec<ExprRef<'tcx>>)\n-                                     -> ExprKind<'tcx> {\n+fn overloaded_place<'a, 'gcx, 'tcx>(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    place_ty: Ty<'tcx>,\n+    overloaded_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n+    args: Vec<ExprRef<'tcx>>,\n+) -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent places):\n@@ -993,7 +1053,7 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, custom_callee);\n+    let fun = method_callee(cx, expr, overloaded_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n         ty: ref_ty,"}, {"sha": "4f26d5422b0a439e26f9590ef0985abe886fc38a", "filename": "src/test/ui/nll/user-annotations/fns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+fn some_fn<T>(arg: T) { }\n+\n+fn no_annot() {\n+    let c = 66;\n+    some_fn(&c); // OK\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    some_fn::<_>(&c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    some_fn::<&u32>(&c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    some_fn::<&'static u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    some_fn::<&'a u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    some_fn::<&'a u32>(c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        some_fn::<&'a u32>(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        some_fn::<&'a u32>(c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "b6ef336567ca0da7b4cfed90140031314b992fe1", "filename": "src/test/ui/nll/user-annotations/fns.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:35:29\n+   |\n+LL |     some_fn::<&'static u32>(&c); //~ ERROR\n+   |                             ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:40:24\n+   |\n+LL |     some_fn::<&'a u32>(&c); //~ ERROR\n+   |                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 38:35...\n+  --> $DIR/fns.rs:38:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:50:28\n+   |\n+LL |         some_fn::<&'a u32>(&c); //~ ERROR\n+   |                            ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 47:46...\n+  --> $DIR/fns.rs:47:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "9a03679bef0a11411411dc2a9c6ce8f90021d35b", "filename": "src/test/ui/nll/user-annotations/method-call.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+trait Bazoom<T> {\n+    fn method<U>(&self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn no_annot() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method(b,  &c); // OK\n+}\n+\n+fn annot_underscore() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<_>(b,  &c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&u32>(b,  &c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&'static u32>(b,  &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&'a u32>(b,  &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    a.method::<&'a u32>(b,  c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        let c = 66;\n+        a.method::<&'a u32>(b,  &c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        a.method::<&'a u32>(b,  c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "f1c7ff1e0fb19e98f1b844134a298da70ea9c591", "filename": "src/test/ui/nll/user-annotations/method-call.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d1d3fef6205276e0123dea96cc346d1da7df6d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr?ref=2d1d3fef6205276e0123dea96cc346d1da7df6d0", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:48:34\n+   |\n+LL |     a.method::<&'static u32>(b,  &c); //~ ERROR\n+   |                                  ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:55:29\n+   |\n+LL |     a.method::<&'a u32>(b,  &c); //~ ERROR\n+   |                             ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 51:35...\n+  --> $DIR/method-call.rs:51:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:69:33\n+   |\n+LL |         a.method::<&'a u32>(b,  &c); //~ ERROR\n+   |                                 ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 64:46...\n+  --> $DIR/method-call.rs:64:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}