{"sha": "51918dcc51360d79cec771ef556ae9181ebaeb2e", "node_id": "C_kwDOAAsO6NoAKDUxOTE4ZGNjNTEzNjBkNzljZWM3NzFlZjU1NmFlOTE4MWViYWViMmU", "commit": {"author": {"name": "Michael Benfield", "email": "mbenfield@google.com", "date": "2022-10-10T17:29:38Z"}, "committer": {"name": "Michael Benfield", "email": "mbenfield@google.com", "date": "2022-11-11T05:54:30Z"}, "message": "rustc_codegen_ssa: Better code generation for niche discriminants.\n\nIn some cases we can avoid arithmetic before checking whether a niche\nrepresents an untagged variant.\n\nThis is relevant to #101872", "tree": {"sha": "1023d9cc603c21b80d2f270f8dc0f50f240e0a54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1023d9cc603c21b80d2f270f8dc0f50f240e0a54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51918dcc51360d79cec771ef556ae9181ebaeb2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51918dcc51360d79cec771ef556ae9181ebaeb2e", "html_url": "https://github.com/rust-lang/rust/commit/51918dcc51360d79cec771ef556ae9181ebaeb2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51918dcc51360d79cec771ef556ae9181ebaeb2e/comments", "author": {"login": "mikebenfield", "id": 543755, "node_id": "MDQ6VXNlcjU0Mzc1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/543755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikebenfield", "html_url": "https://github.com/mikebenfield", "followers_url": "https://api.github.com/users/mikebenfield/followers", "following_url": "https://api.github.com/users/mikebenfield/following{/other_user}", "gists_url": "https://api.github.com/users/mikebenfield/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikebenfield/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikebenfield/subscriptions", "organizations_url": "https://api.github.com/users/mikebenfield/orgs", "repos_url": "https://api.github.com/users/mikebenfield/repos", "events_url": "https://api.github.com/users/mikebenfield/events{/privacy}", "received_events_url": "https://api.github.com/users/mikebenfield/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikebenfield", "id": 543755, "node_id": "MDQ6VXNlcjU0Mzc1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/543755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikebenfield", "html_url": "https://github.com/mikebenfield", "followers_url": "https://api.github.com/users/mikebenfield/followers", "following_url": "https://api.github.com/users/mikebenfield/following{/other_user}", "gists_url": "https://api.github.com/users/mikebenfield/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikebenfield/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikebenfield/subscriptions", "organizations_url": "https://api.github.com/users/mikebenfield/orgs", "repos_url": "https://api.github.com/users/mikebenfield/repos", "events_url": "https://api.github.com/users/mikebenfield/events{/privacy}", "received_events_url": "https://api.github.com/users/mikebenfield/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b82ea74b705799665b5a676b162f30d26f5108c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b82ea74b705799665b5a676b162f30d26f5108c", "html_url": "https://github.com/rust-lang/rust/commit/5b82ea74b705799665b5a676b162f30d26f5108c"}], "stats": {"total": 420, "additions": 371, "deletions": 49}, "files": [{"sha": "8c72d6d1fbe3676a543d0c4d598d37fed313292b", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 145, "deletions": 49, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/51918dcc51360d79cec771ef556ae9181ebaeb2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51918dcc51360d79cec771ef556ae9181ebaeb2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=51918dcc51360d79cec771ef556ae9181ebaeb2e", "patch": "@@ -209,7 +209,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n-        let cast_to = bx.cx().immediate_backend_type(bx.cx().layout_of(cast_to));\n+        let cast_to_layout = bx.cx().layout_of(cast_to);\n+        let cast_to_size = cast_to_layout.layout.size();\n+        let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n@@ -229,7 +231,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Read the tag/niche-encoded discriminant from memory.\n         let tag = self.project_field(bx, tag_field);\n-        let tag = bx.load_operand(tag);\n+        let tag_op = bx.load_operand(tag);\n+        let tag_imm = tag_op.immediate();\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n         match *tag_encoding {\n@@ -242,68 +245,161 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(tag.immediate(), cast_to, signed)\n+                bx.intcast(tag_imm, cast_to, signed)\n             }\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                // Rebase from niche values to discriminants, and check\n-                // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n-                let tag = tag.immediate();\n-\n-                // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-                // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-                // we remap `niche_start..=niche_start + n` (which may wrap around)\n-                // to (non-wrap-around) `0..=n`, to be able to check whether the\n-                // discriminant corresponds to a niche variant with one comparison.\n-                // We also can't go directly to the (variant index) discriminant\n-                // and check that it is in the range `niche_variants`, because\n-                // that might not fit in the same type, on top of needing an extra\n-                // comparison (see also the comment on `let niche_discr`).\n-                let relative_discr = if niche_start == 0 {\n-                    // Avoid subtracting `0`, which wouldn't work for pointers.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    tag\n+                // Cast to an integer so we don't have to treat a pointer as a\n+                // special case.\n+                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n+                    let t = bx.type_isize();\n+                    let tag = bx.ptrtoint(tag_imm, t);\n+                    (tag, t)\n                 } else {\n-                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n                 };\n+\n+                let tag_size = tag_scalar.size(bx.cx());\n+                let max_unsigned = tag_size.unsigned_int_max();\n+                let max_signed = tag_size.signed_int_max() as u128;\n+                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let is_niche = if relative_max == 0 {\n-                    // Avoid calling `const_uint`, which wouldn't work for pointers.\n-                    // Also use canonical == 0 instead of non-canonical u<= 0.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    bx.icmp(IntPredicate::IntEQ, relative_discr, bx.cx().const_null(niche_llty))\n+                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+                let range = tag_scalar.valid_range(bx.cx());\n+\n+                let sle = |lhs: u128, rhs: u128| -> bool {\n+                    // Signed and unsigned comparisons give the same results,\n+                    // except that in signed comparisons an integer with the\n+                    // sign bit set is less than one with the sign bit clear.\n+                    // Toggle the sign bit to do a signed comparison.\n+                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n+                };\n+\n+                // We have a subrange `niche_start..=niche_end` inside `range`.\n+                // If the value of the tag is inside this subrange, it's a\n+                // \"niche value\", an increment of the discriminant. Otherwise it\n+                // indicates the untagged variant.\n+                // A general algorithm to extract the discriminant from the tag\n+                // is:\n+                // relative_tag = tag - niche_start\n+                // is_niche = relative_tag <= (ule) relative_max\n+                // discr = if is_niche {\n+                //     cast(relative_tag) + niche_variants.start()\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // However, we will likely be able to emit simpler code.\n+\n+                // Find the least and greatest values in `range`, considered\n+                // both as signed and unsigned.\n+                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n+                    (range.start, range.end)\n+                } else {\n+                    (0, max_unsigned)\n+                };\n+                let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                    (range.start, range.end)\n                 } else {\n-                    let relative_max = bx.cx().const_uint(niche_llty, relative_max as u64);\n-                    bx.icmp(IntPredicate::IntULE, relative_discr, relative_max)\n+                    (min_signed, max_signed)\n+                };\n+\n+                let niches_ule = niche_start <= niche_end;\n+                let niches_sle = sle(niche_start, niche_end);\n+                let cast_smaller = cast_to_size <= tag_size;\n+\n+                // In the algorithm above, we can change\n+                // cast(relative_tag) + niche_variants.start()\n+                // into\n+                // cast(tag) + (niche_variants.start() - niche_start)\n+                // if either the casted type is no larger than the original\n+                // type, or if the niche values are contiguous (in either the\n+                // signed or unsigned sense).\n+                let can_incr_after_cast = cast_smaller || niches_ule || niches_sle;\n+\n+                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n+                    if !can_incr_after_cast {\n+                        None\n+                    } else if niche_start == low_unsigned {\n+                        Some((IntPredicate::IntULE, niche_end))\n+                    } else if niche_end == high_unsigned {\n+                        Some((IntPredicate::IntUGE, niche_start))\n+                    } else if niche_start == low_signed {\n+                        Some((IntPredicate::IntSLE, niche_end))\n+                    } else if niche_end == high_signed {\n+                        Some((IntPredicate::IntSGE, niche_start))\n+                    } else {\n+                        None\n+                    }\n                 };\n \n-                // NOTE(eddyb) this addition needs to be performed on the final\n-                // type, in case the niche itself can't represent all variant\n-                // indices (e.g. `u8` niche with more than `256` variants,\n-                // but enough uninhabited variants so that the remaining variants\n-                // fit in the niche).\n-                // In other words, `niche_variants.end - niche_variants.start`\n-                // is representable in the niche, but `niche_variants.end`\n-                // might not be, in extreme cases.\n-                let niche_discr = {\n-                    let relative_discr = if relative_max == 0 {\n-                        // HACK(eddyb) since we have only one niche, we know which\n-                        // one it is, and we can avoid having a dynamic value here.\n-                        bx.cx().const_uint(cast_to, 0)\n+                let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                    // Best case scenario: only one tagged variant. This will\n+                    // likely become just a comparison and a jump.\n+                    // The algorithm is:\n+                    // is_niche = tag == niche_start\n+                    // discr = if is_niche {\n+                    //     niche_start\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    let niche_start = bx.cx().const_uint_big(tag_llty, niche_start);\n+                    let is_niche = bx.icmp(IntPredicate::IntEQ, tag, niche_start);\n+                    let tagged_discr =\n+                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n+                    (is_niche, tagged_discr, 0)\n+                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                    // The niche values are either the lowest or the highest in\n+                    // `range`. We can avoid the first subtraction in the\n+                    // algorithm.\n+                    // The algorithm is now this:\n+                    // is_niche = tag <= niche_end\n+                    // discr = if is_niche {\n+                    //     cast(tag) + (niche_variants.start() - niche_start)\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    // (the first line may instead be tag >= niche_start,\n+                    // and may be a signed or unsigned comparison)\n+                    let is_niche =\n+                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n+                    let cast_tag = if cast_smaller {\n+                        bx.intcast(tag, cast_to, false)\n+                    } else if niches_ule {\n+                        bx.zext(tag, cast_to)\n                     } else {\n-                        bx.intcast(relative_discr, cast_to, false)\n+                        bx.sext(tag, cast_to)\n                     };\n-                    bx.add(\n+\n+                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                    (is_niche, cast_tag, delta)\n+                } else {\n+                    // The special cases don't apply, so we'll have to go with\n+                    // the general algorithm.\n+                    let relative_discr = bx.sub(tag, bx.cx().const_uint_big(tag_llty, niche_start));\n+                    let cast_tag = bx.intcast(relative_discr, cast_to, false);\n+                    let is_niche = bx.icmp(\n+                        IntPredicate::IntULE,\n                         relative_discr,\n-                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                    )\n+                        bx.cx().const_uint(tag_llty, relative_max as u64),\n+                    );\n+                    (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n                 };\n \n-                bx.select(\n+                let tagged_discr = if delta == 0 {\n+                    tagged_discr\n+                } else {\n+                    bx.add(tagged_discr, bx.cx().const_uint_big(cast_to, delta))\n+                };\n+\n+                let discr = bx.select(\n                     is_niche,\n-                    niche_discr,\n+                    tagged_discr,\n                     bx.cx().const_uint(cast_to, untagged_variant.as_u32() as u64),\n-                )\n+                );\n+\n+                // In principle we could insert assumes on the possible range of `discr`, but\n+                // currently in LLVM this seems to be a pessimization.\n+\n+                discr\n             }\n         }\n     }"}, {"sha": "efab189fd7b8f9876b46aea2bd050bb21b6dca77", "filename": "src/test/codegen/enum-match.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/51918dcc51360d79cec771ef556ae9181ebaeb2e/src%2Ftest%2Fcodegen%2Fenum-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51918dcc51360d79cec771ef556ae9181ebaeb2e/src%2Ftest%2Fcodegen%2Fenum-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-match.rs?ref=51918dcc51360d79cec771ef556ae9181ebaeb2e", "patch": "@@ -0,0 +1,112 @@\n+// compile-flags: -Copt-level=1\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+\n+// Check each of the 3 cases for `codegen_get_discr`.\n+\n+// Case 0: One tagged variant.\n+pub enum Enum0 {\n+    A(bool),\n+    B,\n+}\n+\n+// CHECK: define i8 @match0{{.*}}\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: %1 = icmp eq i8 %0, 2\n+// CHECK-NEXT: %2 = and i8 %0, 1\n+// CHECK-NEXT: %.0 = select i1 %1, i8 13, i8 %2\n+#[no_mangle]\n+pub fn match0(e: Enum0) -> u8 {\n+    use Enum0::*;\n+    match e {\n+        A(b) => b as u8,\n+        B => 13,\n+    }\n+}\n+\n+// Case 1: Niche values are on a boundary for `range`.\n+pub enum Enum1 {\n+    A(bool),\n+    B,\n+    C,\n+}\n+\n+// CHECK: define i8 @match1{{.*}}\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: %1 = icmp ugt i8 %0, 1\n+// CHECK-NEXT: %2 = zext i8 %0 to i64\n+// CHECK-NEXT: %3 = add nsw i64 %2, -1\n+// CHECK-NEXT: %_2 = select i1 %1, i64 %3, i64 0\n+// CHECK-NEXT: switch i64 %_2, label {{.*}} [\n+#[no_mangle]\n+pub fn match1(e: Enum1) -> u8 {\n+    use Enum1::*;\n+    match e {\n+        A(b) => b as u8,\n+        B => 13,\n+        C => 100,\n+    }\n+}\n+\n+// Case 2: Special cases don't apply.\n+pub enum X {\n+    _2=2, _3, _4, _5, _6, _7, _8, _9, _10, _11,\n+    _12, _13, _14, _15, _16, _17, _18, _19, _20,\n+    _21, _22, _23, _24, _25, _26, _27, _28, _29,\n+    _30, _31, _32, _33, _34, _35, _36, _37, _38,\n+    _39, _40, _41, _42, _43, _44, _45, _46, _47,\n+    _48, _49, _50, _51, _52, _53, _54, _55, _56,\n+    _57, _58, _59, _60, _61, _62, _63, _64, _65,\n+    _66, _67, _68, _69, _70, _71, _72, _73, _74,\n+    _75, _76, _77, _78, _79, _80, _81, _82, _83,\n+    _84, _85, _86, _87, _88, _89, _90, _91, _92,\n+    _93, _94, _95, _96, _97, _98, _99, _100, _101,\n+    _102, _103, _104, _105, _106, _107, _108, _109,\n+    _110, _111, _112, _113, _114, _115, _116, _117,\n+    _118, _119, _120, _121, _122, _123, _124, _125,\n+    _126, _127, _128, _129, _130, _131, _132, _133,\n+    _134, _135, _136, _137, _138, _139, _140, _141,\n+    _142, _143, _144, _145, _146, _147, _148, _149,\n+    _150, _151, _152, _153, _154, _155, _156, _157,\n+    _158, _159, _160, _161, _162, _163, _164, _165,\n+    _166, _167, _168, _169, _170, _171, _172, _173,\n+    _174, _175, _176, _177, _178, _179, _180, _181,\n+    _182, _183, _184, _185, _186, _187, _188, _189,\n+    _190, _191, _192, _193, _194, _195, _196, _197,\n+    _198, _199, _200, _201, _202, _203, _204, _205,\n+    _206, _207, _208, _209, _210, _211, _212, _213,\n+    _214, _215, _216, _217, _218, _219, _220, _221,\n+    _222, _223, _224, _225, _226, _227, _228, _229,\n+    _230, _231, _232, _233, _234, _235, _236, _237,\n+    _238, _239, _240, _241, _242, _243, _244, _245,\n+    _246, _247, _248, _249, _250, _251, _252, _253,\n+}\n+\n+pub enum Enum2 {\n+    A(X),\n+    B,\n+    C,\n+    D,\n+    E,\n+}\n+\n+// CHECK: define i8 @match2{{.*}}\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: %1 = add i8 %0, 2\n+// CHECK-NEXT: %2 = zext i8 %1 to i64\n+// CHECK-NEXT: %3 = icmp ult i8 %1, 4\n+// CHECK-NEXT: %4 = add nuw nsw i64 %2, 1\n+// CHECK-NEXT: %_2 = select i1 %3, i64 %4, i64 0\n+// CHECK-NEXT: switch i64 %_2, label {{.*}} [\n+#[no_mangle]\n+pub fn match2(e: Enum2) -> u8 {\n+    use Enum2::*;\n+    match e {\n+        A(b) => b as u8,\n+        B => 13,\n+        C => 100,\n+        D => 200,\n+        E => 250,\n+    }\n+}"}, {"sha": "71eea4e0f78af5287a267782cde67399bd79c66d", "filename": "src/test/ui/enum-discriminant/get_discr.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/51918dcc51360d79cec771ef556ae9181ebaeb2e/src%2Ftest%2Fui%2Fenum-discriminant%2Fget_discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51918dcc51360d79cec771ef556ae9181ebaeb2e/src%2Ftest%2Fui%2Fenum-discriminant%2Fget_discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fget_discr.rs?ref=51918dcc51360d79cec771ef556ae9181ebaeb2e", "patch": "@@ -0,0 +1,114 @@\n+// run-pass\n+\n+// Now that there are several variations on the code generated in\n+// `codegen_get_discr`, let's make sure the various cases yield the correct\n+// result.\n+\n+// To get the discriminant of an E<X1> value, there are no shortcuts - we must\n+// do the full algorithm.\n+#[repr(u8)]\n+pub enum X1 {\n+    _1 = 1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16,\n+    _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32,\n+    _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48,\n+    _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64,\n+    _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80,\n+    _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96,\n+    _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112,\n+    _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128,\n+    _129, _130, _131, _132, _133, _134, _135, _136, _137, _138, _139, _140, _141, _142, _143, _144,\n+    _145, _146, _147, _148, _149, _150, _151, _152, _153, _154, _155, _156, _157, _158, _159, _160,\n+    _161, _162, _163, _164, _165, _166, _167, _168, _169, _170, _171, _172, _173, _174, _175, _176,\n+    _177, _178, _179, _180, _181, _182, _183, _184, _185, _186, _187, _188, _189, _190, _191, _192,\n+    _193, _194, _195, _196, _197, _198, _199, _200, _201, _202, _203, _204, _205, _206, _207, _208,\n+    _209, _210, _211, _212, _213, _214, _215, _216, _217, _218, _219, _220, _221, _222, _223, _224,\n+    _225, _226, _227, _228, _229, _230, _231, _232, _233, _234, _235, _236, _237, _238, _239, _240,\n+    _241, _242, _243, _244, _245, _246, _247, _248, _249, _250, _251, _252, _253, _254,\n+}\n+\n+#[repr(i8)]\n+pub enum X2 {\n+    _1 = -1, _2 = 0, _3 = 1,\n+}\n+\n+#[repr(i8)]\n+pub enum X3 {\n+    _1 = -128, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16,\n+    _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32,\n+    _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48,\n+    _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64,\n+    _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80,\n+    _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96,\n+    _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112,\n+    _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128,\n+    _129, _130, _131, _132, _133, _134, _135, _136, _137, _138, _139, _140, _141, _142, _143, _144,\n+    _145, _146, _147, _148, _149, _150, _151, _152, _153, _154, _155, _156, _157, _158, _159, _160,\n+    _161, _162, _163, _164, _165, _166, _167, _168, _169, _170, _171, _172, _173, _174, _175, _176,\n+    _177, _178, _179, _180, _181, _182, _183, _184, _185, _186, _187, _188, _189, _190, _191, _192,\n+    _193, _194, _195, _196, _197, _198, _199, _200, _201, _202, _203, _204, _205, _206, _207, _208,\n+    _209, _210, _211, _212, _213, _214, _215, _216, _217, _218, _219, _220, _221, _222, _223, _224,\n+    _225, _226, _227, _228, _229, _230, _231, _232, _233, _234, _235, _236, _237, _238, _239, _240,\n+    _241, _242, _243, _244, _245, _246, _247, _248, _249, _250, _251, _252, _253, _254,\n+}\n+\n+#[repr(i8)]\n+pub enum X4 {\n+    _1 = -126, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16,\n+    _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32,\n+    _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48,\n+    _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64,\n+    _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80,\n+    _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96,\n+    _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112,\n+    _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128,\n+    _129, _130, _131, _132, _133, _134, _135, _136, _137, _138, _139, _140, _141, _142, _143, _144,\n+    _145, _146, _147, _148, _149, _150, _151, _152, _153, _154, _155, _156, _157, _158, _159, _160,\n+    _161, _162, _163, _164, _165, _166, _167, _168, _169, _170, _171, _172, _173, _174, _175, _176,\n+    _177, _178, _179, _180, _181, _182, _183, _184, _185, _186, _187, _188, _189, _190, _191, _192,\n+    _193, _194, _195, _196, _197, _198, _199, _200, _201, _202, _203, _204, _205, _206, _207, _208,\n+    _209, _210, _211, _212, _213, _214, _215, _216, _217, _218, _219, _220, _221, _222, _223, _224,\n+    _225, _226, _227, _228, _229, _230, _231, _232, _233, _234, _235, _236, _237, _238, _239, _240,\n+    _241, _242, _243, _244, _245, _246, _247, _248, _249, _250, _251, _252, _253, _254,\n+}\n+\n+pub enum E<X> {\n+    A(X),\n+    B,\n+    C,\n+}\n+\n+pub fn match_e<X>(e: E<X>) -> u8 {\n+    use E::*;\n+    match e {\n+        A(_) => 0,\n+        B => 1,\n+        C => 2,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match_e(E::A(X1::_1)), 0);\n+    assert_eq!(match_e(E::A(X1::_2)), 0);\n+    assert_eq!(match_e(E::A(X1::_254)), 0);\n+    assert_eq!(match_e(E::<X1>::B), 1);\n+    assert_eq!(match_e(E::<X1>::C), 2);\n+    assert_eq!(match_e(E::A(X2::_1)), 0);\n+    assert_eq!(match_e(E::A(X2::_2)), 0);\n+    assert_eq!(match_e(E::A(X2::_3)), 0);\n+    assert_eq!(match_e(E::<X2>::B), 1);\n+    assert_eq!(match_e(E::<X2>::C), 2);\n+    assert_eq!(match_e(E::A(X3::_1)), 0);\n+    assert_eq!(match_e(E::A(X3::_2)), 0);\n+    assert_eq!(match_e(E::A(X3::_254)), 0);\n+    assert_eq!(match_e(E::<X3>::B), 1);\n+    assert_eq!(match_e(E::<X3>::C), 2);\n+    assert_eq!(match_e(E::A(X4::_1)), 0);\n+    assert_eq!(match_e(E::A(X4::_2)), 0);\n+    assert_eq!(match_e(E::A(X4::_254)), 0);\n+    assert_eq!(match_e(E::<X4>::B), 1);\n+    assert_eq!(match_e(E::<X4>::C), 2);\n+    assert_eq!(match_e(E::A(false)), 0);\n+    assert_eq!(match_e(E::A(true)), 0);\n+    assert_eq!(match_e(E::<bool>::B), 1);\n+    assert_eq!(match_e(E::<bool>::C), 2);\n+}"}]}