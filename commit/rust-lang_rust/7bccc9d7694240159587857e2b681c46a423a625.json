{"sha": "7bccc9d7694240159587857e2b681c46a423a625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiY2NjOWQ3Njk0MjQwMTU5NTg3ODU3ZTJiNjgxYzQ2YTQyM2E2MjU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-26T12:29:21Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-29T00:18:40Z"}, "message": "Clean up formatting.", "tree": {"sha": "0863f0444db1d5a8e7d89582a1d86daeb0c144a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0863f0444db1d5a8e7d89582a1d86daeb0c144a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bccc9d7694240159587857e2b681c46a423a625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bccc9d7694240159587857e2b681c46a423a625", "html_url": "https://github.com/rust-lang/rust/commit/7bccc9d7694240159587857e2b681c46a423a625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bccc9d7694240159587857e2b681c46a423a625/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e178a5810a133d759b418f53a43cab1e716cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e178a5810a133d759b418f53a43cab1e716cab", "html_url": "https://github.com/rust-lang/rust/commit/e9e178a5810a133d759b418f53a43cab1e716cab"}], "stats": {"total": 237, "additions": 103, "deletions": 134}, "files": [{"sha": "222d0b03e67e5555b477022ce6ffca9fbee3faa1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 103, "deletions": 134, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/7bccc9d7694240159587857e2b681c46a423a625/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bccc9d7694240159587857e2b681c46a423a625/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7bccc9d7694240159587857e2b681c46a423a625", "patch": "@@ -1996,77 +1996,52 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_type(&mut self, ty: &Ty) {\n-        match ty.node {\n-            TyKind::Path(ref maybe_qself, ref path) => {\n-                // This is a path in the type namespace. Walk through scopes\n-                // looking for it.\n-                if let Some(def) = self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(),\n-                                                                    path, TypeNS) {\n-                    match def.base_def {\n-                        Def::Mod(..) if def.depth == 0 => {\n-                            self.session.span_err(path.span, \"expected type, found module\");\n-                            self.record_def(ty.id, err_path_resolution());\n-                        }\n-                        _ => {\n-                            // Write the result into the def map.\n-                            debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                                   path_names_to_string(path, 0), ty.id, def);\n-                            self.record_def(ty.id, def);\n-                        }\n+        if let TyKind::Path(ref maybe_qself, ref path) = ty.node {\n+            // This is a path in the type namespace. Walk through scopes looking for it.\n+            if let Some(def) =\n+                    self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(), path, TypeNS) {\n+                match def.base_def {\n+                    Def::Mod(..) if def.depth == 0 => {\n+                        self.session.span_err(path.span, \"expected type, found module\");\n+                        self.record_def(ty.id, err_path_resolution());\n                     }\n-                } else {\n-                    self.record_def(ty.id, err_path_resolution());\n-\n-                    // Keep reporting some errors even if they're ignored above.\n-                    {\n-                        let kind = if maybe_qself.is_some() {\n-                            \"associated type\"\n-                        } else {\n-                            \"type name\"\n-                        };\n-\n-                        let is_invalid_self_type_name = path.segments.len() > 0 &&\n-                                                        maybe_qself.is_none() &&\n-                                                        path.segments[0].identifier.name ==\n-                                                        keywords::SelfType.name();\n-                        if is_invalid_self_type_name {\n-                            resolve_error(self,\n-                                          ty.span,\n-                                          ResolutionError::SelfUsedOutsideImplOrTrait);\n-                        } else {\n-                            let segment = path.segments.last();\n-                            let segment = segment.expect(\"missing name in path\");\n-                            let type_name = segment.identifier.name;\n-\n-                            let candidates =\n-                                self.lookup_candidates(\n-                                    type_name,\n-                                    TypeNS,\n-                                    |def| match def {\n-                                        Def::Trait(_) |\n-                                        Def::Enum(_) |\n-                                        Def::Struct(_) |\n-                                        Def::Union(_) |\n-                                        Def::TyAlias(_) => true,\n-                                        _               => false,\n-                                    },\n-                                );\n-\n-                            // create error object\n-                            let name = &path_names_to_string(path, 0);\n-                            let error =\n-                                ResolutionError::UseOfUndeclared(\n-                                    kind,\n-                                    name,\n-                                    candidates,\n-                                );\n+                    _ => {\n+                        // Write the result into the def map.\n+                        debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                               path_names_to_string(path, 0), ty.id, def);\n+                        self.record_def(ty.id, def);\n+                   }\n+                }\n+            } else {\n+                self.record_def(ty.id, err_path_resolution());\n+                // Keep reporting some errors even if they're ignored above.\n+                let kind = if maybe_qself.is_some() { \"associated type\" } else { \"type name\" };\n+                let is_invalid_self_type_name = {\n+                    path.segments.len() > 0 &&\n+                    maybe_qself.is_none() &&\n+                    path.segments[0].identifier.name == keywords::SelfType.name()\n+                };\n \n-                            resolve_error(self, ty.span, error);\n+                if is_invalid_self_type_name {\n+                    resolve_error(self, ty.span, ResolutionError::SelfUsedOutsideImplOrTrait);\n+                } else {\n+                    let type_name = path.segments.last().unwrap().identifier.name;\n+                    let candidates = self.lookup_candidates(type_name, TypeNS, |def| {\n+                        match def {\n+                            Def::Trait(_) |\n+                            Def::Enum(_) |\n+                            Def::Struct(_) |\n+                            Def::Union(_) |\n+                            Def::TyAlias(_) => true,\n+                            _ => false,\n                         }\n-                    }\n+                    });\n+\n+                    let name = &path_names_to_string(path, 0);\n+                    let error = ResolutionError::UseOfUndeclared(kind, name, candidates);\n+                    resolve_error(self, ty.span, error);\n                 }\n             }\n-            _ => {}\n         }\n         // Resolve embedded types.\n         visit::walk_ty(self, ty);\n@@ -2697,78 +2672,72 @@ impl<'a> Resolver<'a> {\n                         err.emit();\n                     } else {\n                         // Keep reporting some errors even if they're ignored above.\n-                        {\n-                            let mut method_scope = false;\n-                            let mut is_static = false;\n-                            self.ribs[ValueNS].iter().rev().all(|rib| {\n-                                method_scope = match rib.kind {\n-                                    MethodRibKind(is_static_) => {\n-                                        is_static = is_static_;\n-                                        true\n-                                    }\n-                                    ItemRibKind | ConstantItemRibKind => false,\n-                                    _ => return true, // Keep advancing\n-                                };\n-                                false // Stop advancing\n-                            });\n+                        let mut method_scope = false;\n+                        let mut is_static = false;\n+                        self.ribs[ValueNS].iter().rev().all(|rib| {\n+                            method_scope = match rib.kind {\n+                                MethodRibKind(is_static_) => {\n+                                    is_static = is_static_;\n+                                    true\n+                                }\n+                                ItemRibKind | ConstantItemRibKind => false,\n+                                _ => return true, // Keep advancing\n+                            };\n+                            false // Stop advancing\n+                        });\n \n-                            if method_scope && keywords::SelfValue.name() == &*path_name {\n-                                resolve_error(self,\n-                                              expr.span,\n-                                              ResolutionError::SelfNotAvailableInStaticMethod);\n-                            } else {\n-                                let last_name = path.last().unwrap().name;\n-                                let (mut msg, is_field) =\n-                                    match self.find_fallback_in_self_type(last_name) {\n-                                    NoSuggestion => {\n-                                        // limit search to 5 to reduce the number\n-                                        // of stupid suggestions\n-                                        (match self.find_best_match(&path_name) {\n-                                            SuggestionType::Macro(s) => {\n-                                                format!(\"the macro `{}`\", s)\n-                                            }\n-                                            SuggestionType::Function(s) => format!(\"`{}`\", s),\n-                                            SuggestionType::NotFound => \"\".to_string(),\n-                                        }, false)\n-                                    }\n-                                    Field => {\n-                                        (if is_static && method_scope {\n-                                            \"\".to_string()\n-                                        } else {\n-                                            format!(\"`self.{}`\", path_name)\n-                                        }, true)\n-                                    }\n-                                    TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n-                                    TraitMethod(path_str) =>\n-                                        (format!(\"to call `{}::{}`\", path_str, path_name), false),\n-                                };\n-\n-                                let mut context =  UnresolvedNameContext::Other;\n-                                let mut def = Def::Err;\n-                                if !msg.is_empty() {\n-                                    msg = format!(\"did you mean {}?\", msg);\n-                                } else {\n-                                    // we display a help message if this is a module\n-                                    match self.resolve_path(&path, scope, None, None) {\n-                                        PathResult::Module(module) => {\n-                                            def = module.def().unwrap();\n-                                            context = UnresolvedNameContext::PathIsMod(parent);\n-                                        },\n-                                        _ => {},\n-                                    };\n+                        if method_scope && keywords::SelfValue.name() == &*path_name {\n+                            let error = ResolutionError::SelfNotAvailableInStaticMethod;\n+                            resolve_error(self, expr.span, error);\n+                        } else {\n+                            let fallback =\n+                                self.find_fallback_in_self_type(path.last().unwrap().name);\n+                            let (mut msg, is_field) = match fallback {\n+                                NoSuggestion => {\n+                                    // limit search to 5 to reduce the number\n+                                    // of stupid suggestions\n+                                    (match self.find_best_match(&path_name) {\n+                                        SuggestionType::Macro(s) => {\n+                                            format!(\"the macro `{}`\", s)\n+                                        }\n+                                        SuggestionType::Function(s) => format!(\"`{}`\", s),\n+                                        SuggestionType::NotFound => \"\".to_string(),\n+                                    }, false)\n+                                }\n+                                Field => {\n+                                    (if is_static && method_scope {\n+                                        \"\".to_string()\n+                                    } else {\n+                                        format!(\"`self.{}`\", path_name)\n+                                    }, true)\n                                 }\n+                                TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n+                                TraitMethod(path_str) =>\n+                                    (format!(\"to call `{}::{}`\", path_str, path_name), false),\n+                            };\n \n-                                resolve_error(self,\n-                                              expr.span,\n-                                              ResolutionError::UnresolvedName {\n-                                                  path: &path_name,\n-                                                  message: &msg,\n-                                                  context: context,\n-                                                  is_static_method: method_scope && is_static,\n-                                                  is_field: is_field,\n-                                                  def: def,\n-                                              });\n+                            let mut context = UnresolvedNameContext::Other;\n+                            let mut def = Def::Err;\n+                            if !msg.is_empty() {\n+                                msg = format!(\"did you mean {}?\", msg);\n+                            } else {\n+                                // we display a help message if this is a module\n+                                if let PathResult::Module(module) =\n+                                        self.resolve_path(&path, scope, None, None) {\n+                                    def = module.def().unwrap();\n+                                    context = UnresolvedNameContext::PathIsMod(parent);\n+                                }\n                             }\n+\n+                            let error = ResolutionError::UnresolvedName {\n+                                path: &path_name,\n+                                message: &msg,\n+                                context: context,\n+                                is_static_method: method_scope && is_static,\n+                                is_field: is_field,\n+                                def: def,\n+                            };\n+                            resolve_error(self, expr.span, error);\n                         }\n                     }\n                 }"}]}