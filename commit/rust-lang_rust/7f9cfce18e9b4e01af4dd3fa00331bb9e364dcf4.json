{"sha": "7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4", "node_id": "C_kwDOAAsO6NoAKDdmOWNmY2UxOGU5YjRlMDFhZjRkZDNmYTAwMzMxYmI5ZTM2NGRjZjQ", "commit": {"author": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-02-02T14:02:18Z"}, "committer": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-02-02T14:02:18Z"}, "message": "Make timer hierarchical", "tree": {"sha": "d4cb1893ddd2293e892daca857161fc89e718a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4cb1893ddd2293e892daca857161fc89e718a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEzFQynJm4WzBnfhz8kJzQ0mSDUWsFAmPbwmoACgkQkJzQ0mSD\nUWuRwQv+NQQW0VDS9gt+F/NSHITVm1WrQ1UILbtMTsSetHrPk+pltJJyiN+QN07t\nt8MF4Oid3pKaNYbrHlMcygwzyx5bISD1vX/hjVEMCY/YIleYlvU71nkLq0hNLHhB\nk0GkaZSjuA/VffFDp0mhUAxneaWVNUO0fVMQsO69/hPpPz1Jmk/tk3ArwdEKhRCH\nVI/CanGU1KJtNdz57r0BX+fBHFoHggH4AzMEunatib1exgTJISSZ/PG9X5PTZGcv\nlqI1b0MyfyMJW42c6V37Z25MBV3/67T8RhY6iaPhvVyvTijUFH10dOgdPDmjrJ7t\nSDDc46KqiERUVcG2xMIVZ8VACXMcjgd/ShmXV2GEQ3zzLznRosHY5IiP1NkqClY6\niCte/Mpf5x/CgSHzmcD+kugkGdfJT8OR3JaHM7OnL3h+JpCXjN/d4wEIwp54ZBJG\nwKZoQqivFX6f5oFCKsLDd2ekw37gIq44ggrpjwpFP5dEs0dfkWCph2g7h0+eGJJT\n5qqlGJJm\n=vdUv\n-----END PGP SIGNATURE-----", "payload": "tree d4cb1893ddd2293e892daca857161fc89e718a36\nparent 7bd8fbbd28f38669bc83cb734e2ffef44f3de9ae\nauthor Jakub Ber\u00e1nek <berykubik@gmail.com> 1675346538 +0100\ncommitter Jakub Ber\u00e1nek <berykubik@gmail.com> 1675346538 +0100\n\nMake timer hierarchical\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4", "html_url": "https://github.com/rust-lang/rust/commit/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4/comments", "author": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bd8fbbd28f38669bc83cb734e2ffef44f3de9ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd8fbbd28f38669bc83cb734e2ffef44f3de9ae", "html_url": "https://github.com/rust-lang/rust/commit/7bd8fbbd28f38669bc83cb734e2ffef44f3de9ae"}], "stats": {"total": 158, "additions": 104, "deletions": 54}, "files": [{"sha": "662c9e36694c652d31f932e668054c5ec35c846f", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 104, "deletions": 54, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=7f9cfce18e9b4e01af4dd3fa00331bb9e364dcf4", "patch": "@@ -15,10 +15,9 @@\n import time\n import traceback\n import urllib.request\n-from collections import OrderedDict\n from io import StringIO\n from pathlib import Path\n-from typing import Callable, Dict, Iterable, List, Optional, Union\n+from typing import Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n \n PGO_HOST = os.environ[\"PGO_HOST\"]\n \n@@ -204,57 +203,105 @@ def supports_bolt(self) -> bool:\n         return False\n \n \n+def get_timestamp() -> float:\n+    return time.time()\n+\n+\n+Duration = float\n+TimerSection = Union[Duration, \"Timer\"]\n+\n+\n+def iterate_sections(section: TimerSection, name: str, level: int = 0) -> Iterator[Tuple[int, str, Duration]]:\n+    \"\"\"\n+    Hierarchically iterate the sections of a timer, in a depth-first order.\n+    \"\"\"\n+    if isinstance(section, Duration):\n+        yield (level, name, section)\n+    elif isinstance(section, Timer):\n+        yield (level, name, section.total_duration())\n+        for (child_name, child_section) in section.sections:\n+            yield from iterate_sections(child_section, child_name, level=level + 1)\n+    else:\n+        assert False\n+\n+\n class Timer:\n-    def __init__(self):\n-        # We want this dictionary to be ordered by insertion.\n-        # We use `OrderedDict` for compatibility with older Python versions.\n-        self.stages = OrderedDict()\n+    def __init__(self, parent_names: Tuple[str, ...] = ()):\n+        self.sections: List[Tuple[str, TimerSection]] = []\n+        self.section_active = False\n+        self.parent_names = parent_names\n \n     @contextlib.contextmanager\n-    def stage(self, name: str):\n-        assert name not in self.stages\n+    def section(self, name: str) -> \"Timer\":\n+        assert not self.section_active\n+        self.section_active = True\n \n-        start = time.time()\n+        start = get_timestamp()\n         exc = None\n+\n+        child_timer = Timer(parent_names=self.parent_names + (name, ))\n+        full_name = \" > \".join(child_timer.parent_names)\n         try:\n-            LOGGER.info(f\"Stage `{name}` starts\")\n-            yield\n+            LOGGER.info(f\"Section `{full_name}` starts\")\n+            yield child_timer\n         except BaseException as exception:\n             exc = exception\n             raise\n         finally:\n-            end = time.time()\n+            end = get_timestamp()\n             duration = end - start\n-            self.stages[name] = duration\n+\n+            if child_timer.has_children():\n+                self.sections.append((name, child_timer))\n+            else:\n+                self.sections.append((name, duration))\n             if exc is None:\n-                LOGGER.info(f\"Stage `{name}` ended: OK ({duration:.2f}s)\")\n+                LOGGER.info(f\"Section `{full_name}` ended: OK ({duration:.2f}s)\")\n+            else:\n+                LOGGER.info(f\"Section `{full_name}` ended: FAIL ({duration:.2f}s)\")\n+            self.section_active = False\n+\n+    def total_duration(self) -> Duration:\n+        duration = 0\n+        for (_, section) in self.sections:\n+            if isinstance(section, Duration):\n+                duration += section\n             else:\n-                LOGGER.info(f\"Stage `{name}` ended: FAIL ({duration:.2f}s)\")\n+                duration += section.total_duration()\n+        return duration\n+\n+    def has_children(self) -> bool:\n+        return len(self.sections) > 0\n \n     def print_stats(self):\n-        total_duration = sum(self.stages.values())\n+        rows = []\n+        for (child_name, child_section) in self.sections:\n+            for (level, name, duration) in iterate_sections(child_section, child_name, level=0):\n+                label = f\"{' ' * level}{name}:\"\n+                rows.append((label, duration))\n+\n+        # Empty row\n+        rows.append((\"\", \"\"))\n \n         total_duration_label = \"Total duration:\"\n+        total_duration = self.total_duration()\n+        rows.append((total_duration_label, humantime(total_duration)))\n \n-        # 1 is for \":\", 2 is horizontal space\n-        max_label_length = max(16, max(\n-            len(label) for label in list(self.stages.keys()) + [total_duration_label[:-1]]\n-        )) + 1 + 2\n+        space_after_label = 2\n+        max_label_length = max(16, max(len(label) for (label, _) in rows)) + space_after_label\n \n         table_width = max_label_length + 23\n         divider = \"-\" * table_width\n \n         with StringIO() as output:\n             print(divider, file=output)\n-            for (name, duration) in self.stages.items():\n-                pct = (duration / total_duration) * 100\n-                name_str = f\"{name}:\"\n-                print(f\"{name_str:<{max_label_length}} {duration:>12.2f}s ({pct:>5.2f}%)\",\n-                      file=output)\n-\n-            print(file=output)\n-            print(f\"{total_duration_label:<{max_label_length}} {humantime(total_duration):>22}\",\n-                  file=output)\n+            for (label, duration) in rows:\n+                if isinstance(duration, Duration):\n+                    pct = (duration / total_duration) * 100\n+                    value = f\"{duration:>12.2f}s ({pct:>5.2f}%)\"\n+                else:\n+                    value = f\"{duration:>{len(total_duration_label) + 7}}\"\n+                print(f\"{label:<{max_label_length}} {value}\", file=output)\n             print(divider, file=output, end=\"\")\n             LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n \n@@ -274,7 +321,7 @@ def change_cwd(dir: Path):\n         os.chdir(cwd)\n \n \n-def humantime(time_s: int) -> str:\n+def humantime(time_s: float) -> str:\n     hours = time_s // 3600\n     time_s = time_s % 3600\n     minutes = time_s // 60\n@@ -609,15 +656,16 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     pipeline.build_rustc_perf()\n \n     # Stage 1: Build rustc + PGO instrumented LLVM\n-    with timer.stage(\"Build rustc (LLVM PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--llvm-profile-generate\"\n-        ], env=dict(\n-            LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n-        ))\n+    with timer.section(\"Stage 1 (LLVM PGO)\") as stage1:\n+        with stage1.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--llvm-profile-generate\"\n+            ], env=dict(\n+                LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n+            ))\n \n-    with timer.stage(\"Gather profiles (LLVM PGO)\"):\n-        gather_llvm_profiles(pipeline)\n+        with stage1.section(\"Gather profiles\"):\n+            gather_llvm_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -626,14 +674,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     ]\n \n     # Stage 2: Build PGO instrumented rustc + LLVM\n-    with timer.stage(\"Build rustc (rustc PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--rust-profile-generate\",\n-            pipeline.rustc_profile_dir_root()\n-        ])\n+    with timer.section(\"Stage 2 (rustc PGO)\") as stage2:\n+        with stage2.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--rust-profile-generate\",\n+                pipeline.rustc_profile_dir_root()\n+            ])\n \n-    with timer.stage(\"Gather profiles (rustc PGO)\"):\n-        gather_rustc_profiles(pipeline)\n+        with stage2.section(\"Gather profiles\"):\n+            gather_rustc_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -643,14 +692,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     # Stage 3: Build rustc + BOLT instrumented LLVM\n     if pipeline.supports_bolt():\n-        with timer.stage(\"Build rustc (LLVM BOLT)\"):\n-            build_rustc(pipeline, args=[\n-                \"--llvm-profile-use\",\n-                pipeline.llvm_profile_merged_file(),\n-                \"--llvm-bolt-profile-generate\",\n-            ])\n-        with timer.stage(\"Gather profiles (LLVM BOLT)\"):\n-            gather_llvm_bolt_profiles(pipeline)\n+        with timer.section(\"Stage 3 (LLVM BOLT)\") as stage3:\n+            with stage3.section(\"Build rustc and LLVM\"):\n+                build_rustc(pipeline, args=[\n+                    \"--llvm-profile-use\",\n+                    pipeline.llvm_profile_merged_file(),\n+                    \"--llvm-bolt-profile-generate\",\n+                ])\n+            with stage3.section(\"Gather profiles\"):\n+                gather_llvm_bolt_profiles(pipeline)\n \n         clear_llvm_files(pipeline)\n         final_build_args += [\n@@ -659,7 +709,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         ]\n \n     # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n-    with timer.stage(\"Final build\"):\n+    with timer.section(\"Stage 4 (final build)\"):\n         cmd(final_build_args)\n \n "}]}