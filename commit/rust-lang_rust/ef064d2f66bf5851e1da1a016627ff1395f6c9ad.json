{"sha": "ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDY0ZDJmNjZiZjU4NTFlMWRhMWEwMTY2MjdmZjEzOTVmNmM5YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-02T08:09:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-02T08:09:15Z"}, "message": "Auto merge of #61871 - Zoxc:no-lift-branch, r=eddyb\n\nDon't use lift to detect local types\n\nThis overlaps with https://github.com/rust-lang/rust/pull/61392.\n\nr? @eddyb", "tree": {"sha": "559dae0e8f999c3e1ae5bff445ad4f352eae4fe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/559dae0e8f999c3e1ae5bff445ad4f352eae4fe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "html_url": "https://github.com/rust-lang/rust/commit/ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99abdfa0b515431133cb38d164e794a51ab58e36", "url": "https://api.github.com/repos/rust-lang/rust/commits/99abdfa0b515431133cb38d164e794a51ab58e36", "html_url": "https://github.com/rust-lang/rust/commit/99abdfa0b515431133cb38d164e794a51ab58e36"}, {"sha": "8465daf9825a380d3109ecf9fd79945f5e9b367a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8465daf9825a380d3109ecf9fd79945f5e9b367a", "html_url": "https://github.com/rust-lang/rust/commit/8465daf9825a380d3109ecf9fd79945f5e9b367a"}], "stats": {"total": 243, "additions": 141, "deletions": 102}, "files": [{"sha": "eca1ada851814b2211b3ff122da04731f2274f7f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -1456,7 +1456,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n         if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n-            if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n+            if !(param_env, ty).has_local_value() {\n                 return ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span);\n             }\n         }"}, {"sha": "c085df6a6e7ab6536a99192c8db0232fdfe1e83d", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -11,6 +11,10 @@ pub struct FreeRegionMap<'tcx> {\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn elements(&self) -> impl Iterator<Item=&Region<'tcx>> {\n+        self.relation.elements()\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n         self.relation.is_empty()\n     }"}, {"sha": "088c862dcb8796974e452f74a733f3f84bf9e717", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -465,9 +465,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> bool {\n         self.infcx.map(|infcx| infcx.type_is_copy_modulo_regions(param_env, ty, span))\n             .or_else(|| {\n-                self.tcx.lift_to_global(&(param_env, ty)).map(|(param_env, ty)| {\n-                    ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span)\n-                })\n+                if (param_env, ty).has_local_value() {\n+                    None\n+                } else {\n+                    Some(ty.is_copy_modulo_regions(self.tcx, param_env, span))\n+                }\n             })\n             .unwrap_or(true)\n     }"}, {"sha": "7be4a2206f5b8317c8e3c64d45168bd7aa3db1ae", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -37,6 +37,10 @@ impl ErrorHandled {\n     }\n }\n \n+CloneTypeFoldableImpls! {\n+    ErrorHandled,\n+}\n+\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n "}, {"sha": "99b5ef3894b9ce02c2c39f396530274a06fbd0c7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -461,41 +461,35 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                match self.selcx.tcx().lift_to_global(&obligation.param_env) {\n-                    None => {\n+                if obligation.param_env.has_local_value() {\n                         ProcessResult::Unchanged\n-                    }\n-                    Some(param_env) => {\n-                        match self.selcx.tcx().lift_to_global(&substs) {\n-                            Some(substs) => {\n-                                let instance = ty::Instance::resolve(\n-                                    self.selcx.tcx().global_tcx(),\n-                                    param_env,\n-                                    def_id,\n-                                    substs,\n-                                );\n-                                if let Some(instance) = instance {\n-                                    let cid = GlobalId {\n-                                        instance,\n-                                        promoted: None,\n-                                    };\n-                                    match self.selcx.tcx().at(obligation.cause.span)\n-                                                          .const_eval(param_env.and(cid)) {\n-                                        Ok(_) => ProcessResult::Changed(vec![]),\n-                                        Err(err) => ProcessResult::Error(\n-                                            CodeSelectionError(ConstEvalFailure(err)))\n-                                    }\n-                                } else {\n-                                    ProcessResult::Error(CodeSelectionError(\n-                                        ConstEvalFailure(ErrorHandled::TooGeneric)\n-                                    ))\n-                                }\n-                            },\n-                            None => {\n-                                pending_obligation.stalled_on = substs.types().collect();\n-                                ProcessResult::Unchanged\n+                } else {\n+                    if !substs.has_local_value() {\n+                        let instance = ty::Instance::resolve(\n+                            self.selcx.tcx().global_tcx(),\n+                            obligation.param_env,\n+                            def_id,\n+                            substs,\n+                        );\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None,\n+                            };\n+                            match self.selcx.tcx().at(obligation.cause.span)\n+                                                    .const_eval(obligation.param_env.and(cid)) {\n+                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Err(err) => ProcessResult::Error(\n+                                    CodeSelectionError(ConstEvalFailure(err)))\n                             }\n+                        } else {\n+                            ProcessResult::Error(CodeSelectionError(\n+                                ConstEvalFailure(ErrorHandled::TooGeneric)\n+                            ))\n                         }\n+                    } else {\n+                        pending_obligation.stalled_on = substs.types().collect();\n+                        ProcessResult::Unchanged\n                     }\n                 }\n             }"}, {"sha": "1ca92d79fa5f66bc5293cfd6dd2b7fd89e9e1fe9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -457,6 +457,16 @@ pub enum SelectionError<'tcx> {\n     Overflow,\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for SelectionError<'tcx> {\n+        (SelectionError::Unimplemented),\n+        (SelectionError::OutputTypeParameterMismatch)(a, b, c),\n+        (SelectionError::TraitNotObjectSafe)(a),\n+        (SelectionError::ConstEvalFailure)(a),\n+        (SelectionError::Overflow),\n+    }\n+}\n+\n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>\n@@ -782,13 +792,11 @@ fn do_normalize_predicates<'tcx>(\n                 return Err(ErrorReported)\n             }\n         };\n-\n-        match tcx.lift_to_global(&predicates) {\n-            Some(predicates) => Ok(predicates),\n-            None => {\n-                // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n-                Err(ErrorReported)\n-            }\n+        if predicates.has_local_value() {\n+            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+            Err(ErrorReported)\n+        } else {\n+            Ok(predicates)\n         }\n     })\n }"}, {"sha": "8bd8f941fb3dd6649426f97adccca765a04faf3e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -399,7 +399,8 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.selcx.tcx().global_tcx();\n-            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+            let param_env = self.param_env;\n+            if !param_env.has_local_value() {\n                 if substs.needs_infer() || substs.has_placeholders() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n@@ -414,7 +415,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                    if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n                         if let Some(instance) = instance {\n                             let cid = GlobalId {"}, {"sha": "55e622e46b966f80aec79911845b13fbd80f2bd7", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -193,7 +193,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.infcx.tcx.global_tcx();\n-            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+            let param_env = self.param_env;\n+            if !param_env.has_local_value() {\n                 if substs.needs_infer() || substs.has_placeholders() {\n                     let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n@@ -208,7 +209,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                    if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n                         if let Some(instance) = instance {\n                             let cid = GlobalId {"}, {"sha": "798a25fe7b1bc0d7be18935c9b0f21b574929bf3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -328,6 +328,23 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n     }\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for SelectionCandidate<'tcx> {\n+        (SelectionCandidate::BuiltinCandidate) { has_nested },\n+        (SelectionCandidate::ParamCandidate)(poly_trait_ref),\n+        (SelectionCandidate::ImplCandidate)(def_id),\n+        (SelectionCandidate::AutoImplCandidate)(def_id),\n+        (SelectionCandidate::ProjectionCandidate),\n+        (SelectionCandidate::ClosureCandidate),\n+        (SelectionCandidate::GeneratorCandidate),\n+        (SelectionCandidate::FnPointerCandidate),\n+        (SelectionCandidate::TraitAliasCandidate)(def_id),\n+        (SelectionCandidate::ObjectCandidate),\n+        (SelectionCandidate::BuiltinObjectCandidate),\n+        (SelectionCandidate::BuiltinUnsizeCandidate),\n+    }\n+}\n+\n struct SelectionCandidateSet<'tcx> {\n     // a list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -818,27 +835,25 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 let tcx = self.tcx();\n-                match tcx.lift_to_global(&(obligation.param_env, substs)) {\n-                    Some((param_env, substs)) => {\n-                        let instance =\n-                            ty::Instance::resolve(tcx.global_tcx(), param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None,\n-                            };\n-                            match self.tcx().const_eval(param_env.and(cid)) {\n-                                Ok(_) => Ok(EvaluatedToOk),\n-                                Err(_) => Ok(EvaluatedToErr),\n-                            }\n-                        } else {\n-                            Ok(EvaluatedToErr)\n+                if !(obligation.param_env, substs).has_local_value() {\n+                    let param_env = obligation.param_env;\n+                    let instance =\n+                        ty::Instance::resolve(tcx, param_env, def_id, substs);\n+                    if let Some(instance) = instance {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match self.tcx().const_eval(param_env.and(cid)) {\n+                            Ok(_) => Ok(EvaluatedToOk),\n+                            Err(_) => Ok(EvaluatedToErr),\n                         }\n+                    } else {\n+                        Ok(EvaluatedToErr)\n                     }\n-                    None => {\n-                        // Inference variables still left in param_env or substs.\n-                        Ok(EvaluatedToAmbig)\n-                    }\n+                } else {\n+                    // Inference variables still left in param_env or substs.\n+                    Ok(EvaluatedToAmbig)\n                 }\n             }\n         }\n@@ -1172,7 +1187,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if self.can_use_global_caches(param_env) {\n-            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+            if !trait_ref.has_local_value() {\n                 debug!(\n                     \"insert_evaluation_cache(trait_ref={:?}, candidate={:?}) global\",\n                     trait_ref, result,\n@@ -1645,8 +1660,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             if let Err(Overflow) = candidate {\n                 // Don't cache overflow globally; we only produce this\n                 // in certain modes.\n-            } else if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n-                if let Some(candidate) = tcx.lift_to_global(&candidate) {\n+            } else if !trait_ref.has_local_value() {\n+                if !candidate.has_local_value() {\n                     debug!(\n                         \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\",\n                         trait_ref, candidate,"}, {"sha": "3dd1fd100f2a4658a476818a7629654a8352bc5e", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -42,10 +42,10 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let Some(ty_lifted) = self.tcx.lift_to_global(&ty) {\n-            self.tcx.erase_regions_ty(ty_lifted)\n-        } else {\n+        if ty.has_local_value() {\n             ty.super_fold_with(self)\n+        } else {\n+            self.tcx.erase_regions_ty(ty)\n         }\n     }\n "}, {"sha": "ab7df8e4e845b25a045880068e17c814766ba154", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -91,6 +91,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n+    fn has_local_value(&self) -> bool {\n+        self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(\n             TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER | TypeFlags::HAS_CT_INFER\n@@ -922,6 +925,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n }\n \n+// FIXME: Optimize for checking for infer flags\n struct HasTypeFlagsVisitor {\n     flags: ty::TypeFlags,\n }"}, {"sha": "a6bfc2dee613b0ce04bb8e997f1cd4550cd390ff", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -550,7 +550,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         if let ConstValue::Unevaluated(def_id, substs) = x.val {\n             // FIXME(eddyb) get the right param_env.\n             let param_env = ty::ParamEnv::empty();\n-            if let Some(substs) = tcx.lift_to_global(&substs) {\n+            if !substs.has_local_value() {\n                 let instance = ty::Instance::resolve(\n                     tcx.global_tcx(),\n                     param_env,"}, {"sha": "27cd745c20fcba22c73657aff57107a450c10c6e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -821,6 +821,13 @@ EnumTypeFoldableImpl! {\n     } where T: TypeFoldable<'tcx>\n }\n \n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T, E> TypeFoldable<'tcx> for Result<T, E> {\n+        (Ok)(a),\n+        (Err)(a),\n+    } where T: TypeFoldable<'tcx>, E: TypeFoldable<'tcx>,\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Rc::new((**self).fold_with(folder))"}, {"sha": "d7cbd1e2e4b476e28a2b87727388997c6b9b4f46", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -58,6 +58,10 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         self.edges.is_empty()\n     }\n \n+    pub fn elements(&self) -> impl Iterator<Item=&T> {\n+        self.elements.iter()\n+    }\n+\n     fn index(&self, a: &T) -> Option<Index> {\n         self.map.get(a).cloned()\n     }"}, {"sha": "a4fa1d98255baee817e780051ade5e2f0d7806c5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -809,7 +809,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n-        let gcx = tcx.global_tcx();\n \n         debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n \n@@ -863,8 +862,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `lift_to_global` will only fail if we failed to promote some region.\n-        gcx.lift_to_global(&ty)?;\n+        // `has_local_value` will only be true if we failed to promote some region.\n+        if ty.has_local_value() {\n+            return None;\n+        }\n \n         Some(ClosureOutlivesSubject::Ty(ty))\n     }"}, {"sha": "d612d042f7f2381f37163574ac9ea42a85122e80", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -3,7 +3,7 @@ use crate::constrained_generic_params::{identify_constrained_generic_params, Par\n \n use crate::hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n+use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::ConstValue;\n@@ -261,14 +261,15 @@ fn check_type_defn<'tcx, F>(\n             let needs_drop_copy = || {\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n-                    fcx.tcx.erase_regions(&ty).lift_to_tcx(fcx_tcx)\n-                        .map(|ty| ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id)))\n-                        .unwrap_or_else(|| {\n+                    let ty = fcx.tcx.erase_regions(&ty);\n+                    if ty.has_local_value() {\n                             fcx_tcx.sess.delay_span_bug(\n                                 item.span, &format!(\"inference variables in {:?}\", ty));\n                             // Just treat unresolved type expression as if it needs drop.\n                             true\n-                        })\n+                    } else {\n+                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n+                    }\n                 }\n             };\n             let all_sized ="}, {"sha": "28711e32a4c51d5eaf1d26b2329276ec12829a1c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef064d2f66bf5851e1da1a016627ff1395f6c9ad/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ef064d2f66bf5851e1da1a016627ff1395f6c9ad", "patch": "@@ -363,10 +363,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        let free_region_map = self.tcx()\n-            .lift_to_global(&self.fcx.tables.borrow().free_region_map);\n-        let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n-        self.tables.free_region_map = free_region_map;\n+        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+        debug_assert!(!self.tables.free_region_map.elements().any(|r| r.has_local_value()));\n     }\n \n     fn visit_user_provided_tys(&mut self) {\n@@ -381,12 +379,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 local_id,\n             };\n \n-            let c_ty = if let Some(c_ty) = self.tcx().lift_to_global(c_ty) {\n-                c_ty\n-            } else {\n+            if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(\n                     hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_ty\n                 );\n             };\n@@ -423,12 +419,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n-            let c_sig = if let Some(c_sig) = self.tcx().lift_to_global(c_sig) {\n-                c_sig\n-            } else {\n+            if cfg!(debug_assertions) && c_sig.has_local_value() {\n                 span_bug!(\n                     self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_sig\n                 );\n             };\n@@ -592,10 +586,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             }\n \n-            if let Some(substs) = self.tcx().lift_to_global(&opaque_defn.substs) {\n+            if !opaque_defn.substs.has_local_value() {\n                 let new = ty::ResolvedOpaqueTy {\n                     concrete_type: definition_ty,\n-                    substs,\n+                    substs: opaque_defn.substs,\n                 };\n \n                 let old = self.tables\n@@ -617,7 +611,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             } else {\n                 self.tcx().sess.delay_span_bug(\n                     span,\n-                    \"cannot lift `opaque_defn` substs to global type context\",\n+                    \"`opaque_defn` is a local value\",\n                 );\n             }\n         }\n@@ -743,20 +737,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T::Lifted\n+    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T\n     where\n-        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n-        if let Some(lifted) = self.tcx().lift_to_global(&x) {\n-            lifted\n-        } else {\n+        if cfg!(debug_assertions) && x.has_local_value() {\n             span_bug!(\n                 span.to_span(self.fcx.tcx),\n-                \"writeback: `{:?}` missing from the global type context\",\n+                \"writeback: `{:?}` is a local value\",\n                 x\n             );\n         }\n+        x\n     }\n }\n "}]}