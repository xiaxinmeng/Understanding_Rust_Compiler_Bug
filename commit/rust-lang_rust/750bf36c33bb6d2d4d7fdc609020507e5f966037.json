{"sha": "750bf36c33bb6d2d4d7fdc609020507e5f966037", "node_id": "C_kwDOAAsO6NoAKDc1MGJmMzZjMzNiYjZkMmQ0ZDdmZGM2MDkwMjA1MDdlNWY5NjYwMzc", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-12-19T07:01:38Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-12-20T07:30:24Z"}, "message": "dedup assembly", "tree": {"sha": "c595cf4b99473668e99ea8e4cc9ed27046083fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c595cf4b99473668e99ea8e4cc9ed27046083fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/750bf36c33bb6d2d4d7fdc609020507e5f966037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/750bf36c33bb6d2d4d7fdc609020507e5f966037", "html_url": "https://github.com/rust-lang/rust/commit/750bf36c33bb6d2d4d7fdc609020507e5f966037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/750bf36c33bb6d2d4d7fdc609020507e5f966037/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a213bb36c953d2c342d8ae9303704e57bc8aab33", "url": "https://api.github.com/repos/rust-lang/rust/commits/a213bb36c953d2c342d8ae9303704e57bc8aab33", "html_url": "https://github.com/rust-lang/rust/commit/a213bb36c953d2c342d8ae9303704e57bc8aab33"}], "stats": {"total": 565, "additions": 267, "deletions": 298}, "files": [{"sha": "e9ddad11ff23e5707ad6297186d93846588e1e03", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=750bf36c33bb6d2d4d7fdc609020507e5f966037", "patch": "@@ -0,0 +1,150 @@\n+//! Code shared by trait and projection goals for candidate assembly.\n+\n+use super::infcx_ext::InferCtxtExt;\n+use super::{\n+    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n+    EvalCtxt, Goal,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{\n+    canonical::{CanonicalVarValues, OriginalQueryValues},\n+    InferCtxt,\n+};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+use std::fmt::Debug;\n+\n+/// A candidate is a possible way to prove a goal.\n+///\n+/// It consists of both the `source`, which describes how that goal would be proven,\n+/// and the `result` when using the given `source`.\n+///\n+/// For the list of possible candidates, please look at the documentation of\n+/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n+#[derive(Debug, Clone)]\n+pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n+    pub(super) source: G::CandidateSource,\n+    pub(super) result: CanonicalResponse<'tcx>,\n+}\n+\n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n+    type CandidateSource: Debug + Copy;\n+\n+    fn self_ty(self) -> Ty<'tcx>;\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n+\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n+        impl_def_id: DefId,\n+    );\n+}\n+\n+/// An abstraction which correctly deals with the canonical results for candidates.\n+///\n+/// It also deduplicates the behavior between trait and projection predicates.\n+pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n+    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n+    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n+    candidates: Vec<Candidate<'tcx, G>>,\n+}\n+\n+impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n+    pub(super) fn assemble_and_evaluate_candidates(\n+        cx: &'a mut EvalCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx, G>,\n+    ) -> Vec<Candidate<'tcx, G>> {\n+        let (ref infcx, goal, var_values) =\n+            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+\n+        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+\n+        acx.assemble_impl_candidates(goal);\n+\n+        acx.candidates\n+    }\n+\n+    pub(super) fn try_insert_candidate(\n+        &mut self,\n+        source: G::CandidateSource,\n+        certainty: Certainty,\n+    ) {\n+        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+            Ok(result) => self.candidates.push(Candidate { source, result }),\n+            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        }\n+    }\n+\n+    /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n+    ///\n+    /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n+    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n+    /// this case as projections as self types add `\n+    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n+        let tcx = self.cx.tcx;\n+        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n+        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+            return\n+        };\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n+            let normalizes_to_goal = goal.with(\n+                tcx,\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    term: normalized_ty.into(),\n+                }),\n+            );\n+            let normalization_certainty =\n+                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n+                    Ok((_, certainty)) => certainty,\n+                    Err(NoSolution) => return,\n+                };\n+\n+            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+            let mut orig_values = OriginalQueryValues::default();\n+            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let normalized_candidates =\n+                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n+\n+            // Map each candidate from being canonical wrt the current inference context to being\n+            // canonical wrt the caller.\n+            for Candidate { source, result } in normalized_candidates {\n+                self.infcx.probe(|_| {\n+                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n+                        &self.infcx,\n+                        &orig_values,\n+                        result,\n+                    );\n+\n+                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n+                    //\n+                    // If we have an ambiguous candidate it hides that normalization\n+                    // caused an overflow which may cause issues.\n+                    self.try_insert_candidate(\n+                        source,\n+                        normalization_certainty.unify_and(candidate_certainty),\n+                    )\n+                })\n+            }\n+        })\n+    }\n+\n+    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n+        self.cx.tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(self.cx.tcx),\n+            goal.predicate.self_ty(),\n+            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+        );\n+    }\n+}"}, {"sha": "7f5e3208f4e7c0fd03dba54521b106c640ac214b", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=750bf36c33bb6d2d4d7fdc609020507e5f966037", "patch": "@@ -30,6 +30,7 @@ use rustc_span::DUMMY_SP;\n \n use self::infcx_ext::InferCtxtExt;\n \n+mod assembly;\n mod cache;\n mod fulfill;\n mod infcx_ext;"}, {"sha": "b50f42c4d9416091243668ff3ddb0e3bc87da922", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 61, "deletions": 141, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=750bf36c33bb6d2d4d7fdc609020507e5f966037", "patch": "@@ -1,64 +1,40 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::infcx_ext::InferCtxtExt;\n-use super::{\n-    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n-    EvalCtxt, Goal, QueryResult,\n-};\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::canonical::{CanonicalVarValues, OriginalQueryValues};\n-use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::{ObligationCause, Reveal};\n-use rustc_middle::ty;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::TypeVisitable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n use std::iter;\n \n-// FIXME: Deduplicate the candidate code between projection and trait goal.\n-\n-/// Similar to [super::trait_goals::Candidate] but for `Projection` goals.\n-#[derive(Debug, Clone)]\n-struct Candidate<'tcx> {\n-    source: CandidateSource,\n-    result: CanonicalResponse<'tcx>,\n-}\n-\n #[allow(dead_code)] // FIXME: implement and use all variants.\n #[derive(Debug, Clone, Copy)]\n-enum CandidateSource {\n+pub(super) enum CandidateSource {\n     Impl(DefId),\n     ParamEnv(usize),\n     Builtin,\n }\n \n+type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n+\n impl<'tcx> EvalCtxt<'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = self.assemble_and_evaluate_project_candidates(goal);\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n         self.merge_project_candidates(candidates)\n     }\n \n-    fn assemble_and_evaluate_project_candidates(\n-        &mut self,\n-        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n-    ) -> Vec<Candidate<'tcx>> {\n-        let (ref infcx, goal, var_values) =\n-            self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n-        let mut acx = AssemblyCtxt { cx: self, infcx, var_values, candidates: Vec::new() };\n-\n-        acx.assemble_candidates_after_normalizing_self_ty(goal);\n-        acx.assemble_impl_candidates(goal);\n-        acx.candidates\n-    }\n-\n     fn merge_project_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n@@ -112,83 +88,27 @@ impl<'tcx> EvalCtxt<'tcx> {\n     }\n }\n \n-/// Similar to [super::trait_goals::AssemblyCtxt] but for `Projection` goals.\n-struct AssemblyCtxt<'a, 'tcx> {\n-    cx: &'a mut EvalCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-    candidates: Vec<Candidate<'tcx>>,\n-}\n+impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n \n-impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n-    fn try_insert_candidate(&mut self, source: CandidateSource, certainty: Certainty) {\n-        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n-            Ok(result) => self.candidates.push(Candidate { source, result }),\n-            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n-        }\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n     }\n \n-    fn assemble_candidates_after_normalizing_self_ty(\n-        &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n-    ) {\n-        let tcx = self.cx.tcx;\n-        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.projection_ty.self_ty().kind() else {\n-            return\n-        };\n-        self.infcx.probe(|_| {\n-            let normalized_ty = self.infcx.next_ty_infer();\n-            let normalizes_to_goal = goal.with(\n-                tcx,\n-                ty::Binder::dummy(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    term: normalized_ty.into(),\n-                }),\n-            );\n-            let normalization_certainty =\n-                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n-                    Ok((_, certainty)) => certainty,\n-                    Err(NoSolution) => return,\n-                };\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n-            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let mut orig_values = OriginalQueryValues::default();\n-            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n-            let normalized_candidates = self.cx.assemble_and_evaluate_project_candidates(goal);\n-            // Map each candidate from being canonical wrt the current inference context to being\n-            // canonical wrt the caller.\n-            for Candidate { source, result } in normalized_candidates {\n-                self.infcx.probe(|_| {\n-                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n-                        self.infcx,\n-                        &orig_values,\n-                        result,\n-                    );\n-                    self.try_insert_candidate(\n-                        source,\n-                        normalization_certainty.unify_and(candidate_certainty),\n-                    )\n-                })\n-            }\n-        })\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n     }\n \n-    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) {\n-        self.cx.tcx.for_each_relevant_impl(\n-            goal.predicate.trait_def_id(self.cx.tcx),\n-            goal.predicate.self_ty(),\n-            |impl_def_id| self.consider_impl_candidate(goal, impl_def_id),\n-        );\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.trait_def_id(tcx)\n     }\n \n     fn consider_impl_candidate(\n-        &mut self,\n+        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n     ) {\n-        let tcx = self.cx.tcx;\n+        let tcx = acx.cx.tcx;\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n@@ -198,11 +118,11 @@ impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        self.infcx.probe(|_| {\n-            let impl_substs = self.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = self\n+            let Ok(InferOk { obligations, .. }) = acx\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n@@ -213,9 +133,10 @@ impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n             };\n \n             let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(trait_ref_certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n+            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n \n-            let Some(assoc_def) = self.fetch_eligible_assoc_item_def(\n+            let Some(assoc_def) = fetch_eligible_assoc_item_def(\n+                acx.infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n@@ -247,7 +168,7 @@ impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n                 impl_trait_ref.substs,\n             );\n             let substs = translate_substs(\n-                self.infcx,\n+                acx.infcx,\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -267,7 +188,7 @@ impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let Ok(InferOk { obligations, .. }) = self\n+            let Ok(InferOk { obligations, .. }) = acx\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .define_opaque_types(false)\n@@ -278,47 +199,46 @@ impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n             };\n \n             let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(rhs_certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n+            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n \n             let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n-            self.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n         })\n     }\n+}\n \n-    /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n-    ///\n-    /// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n-    /// diverge.\n-    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n-    fn fetch_eligible_assoc_item_def(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        goal_trait_ref: ty::TraitRef<'tcx>,\n-        trait_assoc_def_id: DefId,\n-        impl_def_id: DefId,\n-    ) -> Option<LeafDef> {\n-        let node_item =\n-            specialization_graph::assoc_def(self.cx.tcx, impl_def_id, trait_assoc_def_id)\n-                .map_err(|ErrorGuaranteed { .. }| ())\n-                .ok()?;\n-\n-        let eligible = if node_item.is_final() {\n-            // Non-specializable items are always projectable.\n-            true\n+/// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n+///\n+/// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n+/// diverge.\n+#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+fn fetch_eligible_assoc_item_def<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    goal_trait_ref: ty::TraitRef<'tcx>,\n+    trait_assoc_def_id: DefId,\n+    impl_def_id: DefId,\n+) -> Option<LeafDef> {\n+    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+        .map_err(|ErrorGuaranteed { .. }| ())\n+        .ok()?;\n+\n+    let eligible = if node_item.is_final() {\n+        // Non-specializable items are always projectable.\n+        true\n+    } else {\n+        // Only reveal a specializable default if we're past type-checking\n+        // and the obligation is monomorphic, otherwise passes such as\n+        // transmute checking and polymorphic MIR optimizations could\n+        // get a result which isn't correct for all monomorphizations.\n+        if param_env.reveal() == Reveal::All {\n+            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            !poly_trait_ref.still_further_specializable()\n         } else {\n-            // Only reveal a specializable default if we're past type-checking\n-            // and the obligation is monomorphic, otherwise passes such as\n-            // transmute checking and polymorphic MIR optimizations could\n-            // get a result which isn't correct for all monomorphizations.\n-            if param_env.reveal() == Reveal::All {\n-                let poly_trait_ref = self.infcx.resolve_vars_if_possible(goal_trait_ref);\n-                !poly_trait_ref.still_further_specializable()\n-            } else {\n-                debug!(?node_item.item.def_id, \"not eligible due to default\");\n-                false\n-            }\n-        };\n+            debug!(?node_item.item.def_id, \"not eligible due to default\");\n+            false\n+        }\n+    };\n \n-        if eligible { Some(node_item) } else { None }\n-    }\n+    if eligible { Some(node_item) } else { None }\n }"}, {"sha": "10b45a77dabb0976f04eb22a1c14b58d04918ba4", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 55, "deletions": 157, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750bf36c33bb6d2d4d7fdc609020507e5f966037/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=750bf36c33bb6d2d4d7fdc609020507e5f966037", "patch": "@@ -2,35 +2,17 @@\n \n use std::iter;\n \n-use super::infcx_ext::InferCtxtExt;\n-use super::{\n-    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n-    EvalCtxt, Goal, QueryResult,\n-};\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::canonical::{CanonicalVarValues, OriginalQueryValues};\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferOk;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n-use rustc_middle::ty;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::TraitPredicate;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n-/// A candidate is a possible way to prove a goal.\n-///\n-/// It consists of both the `source`, which describes how that goal\n-/// would be proven, and the `result` when using the given `source`.\n-///\n-/// For the list of possible candidates, please look at the documentation\n-/// of [CandidateSource].\n-#[derive(Debug, Clone)]\n-pub(super) struct Candidate<'tcx> {\n-    source: CandidateSource,\n-    result: CanonicalResponse<'tcx>,\n-}\n-\n #[allow(dead_code)] // FIXME: implement and use all variants.\n #[derive(Debug, Clone, Copy)]\n pub(super) enum CandidateSource {\n@@ -67,37 +49,67 @@ pub(super) enum CandidateSource {\n     AutoImpl,\n }\n \n-struct AssemblyCtxt<'a, 'tcx> {\n-    cx: &'a mut EvalCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-    candidates: Vec<Candidate<'tcx>>,\n+type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n+\n+impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n+\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n+    }\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n+    }\n+\n+    fn trait_def_id(self, _: TyCtxt<'tcx>) -> DefId {\n+        self.def_id()\n+    }\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let impl_trait_ref = acx.cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(acx.cx.tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+\n+            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n }\n \n impl<'tcx> EvalCtxt<'tcx> {\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = self.assemble_and_evaluate_trait_candidates(goal);\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n         self.merge_trait_candidates_discard_reservation_impls(candidates)\n     }\n \n-    pub(super) fn assemble_and_evaluate_trait_candidates(\n-        &mut self,\n-        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n-    ) -> Vec<Candidate<'tcx>> {\n-        let (ref infcx, goal, var_values) =\n-            self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n-        let mut acx = AssemblyCtxt { cx: self, infcx, var_values, candidates: Vec::new() };\n-\n-        acx.assemble_candidates_after_normalizing_self_ty(goal);\n-        acx.assemble_impl_candidates(goal);\n-\n-        // FIXME: Remaining candidates\n-        acx.candidates\n-    }\n-\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn merge_trait_candidates_discard_reservation_impls(\n         &mut self,\n@@ -166,117 +178,3 @@ impl<'tcx> EvalCtxt<'tcx> {\n         candidate\n     }\n }\n-\n-impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n-    /// Adds a new candidate using the current state of the inference context.\n-    ///\n-    /// This does require each assembly method to correctly use `probe` to not taint\n-    /// the results of other candidates.\n-    fn try_insert_candidate(&mut self, source: CandidateSource, certainty: Certainty) {\n-        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n-            Ok(result) => self.candidates.push(Candidate { source, result }),\n-            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n-        }\n-    }\n-\n-    /// If the self type of a trait goal is a projection, computing the relevant candidates is difficult.\n-    ///\n-    /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n-    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n-    /// this case as projections as self types add `\n-    fn assemble_candidates_after_normalizing_self_ty(\n-        &mut self,\n-        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n-    ) {\n-        let tcx = self.cx.tcx;\n-        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n-        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n-            return\n-        };\n-        self.infcx.probe(|_| {\n-            let normalized_ty = self.infcx.next_ty_infer();\n-            let normalizes_to_goal = goal.with(\n-                tcx,\n-                ty::Binder::dummy(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    term: normalized_ty.into(),\n-                }),\n-            );\n-            let normalization_certainty =\n-                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n-                    Ok((_, certainty)) => certainty,\n-                    Err(NoSolution) => return,\n-                };\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n-            let goal = goal.with(tcx, goal.predicate.with_self_type(tcx, normalized_ty));\n-            let mut orig_values = OriginalQueryValues::default();\n-            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n-            let normalized_candidates = self.cx.assemble_and_evaluate_trait_candidates(goal);\n-\n-            // Map each candidate from being canonical wrt the current inference context to being\n-            // canonical wrt the caller.\n-            for Candidate { source, result } in normalized_candidates {\n-                self.infcx.probe(|_| {\n-                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n-                        self.infcx,\n-                        &orig_values,\n-                        result,\n-                    );\n-\n-                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n-                    //\n-                    // If we have an ambiguous candidate it hides that normalization\n-                    // caused an overflow which may cause issues.\n-                    self.try_insert_candidate(\n-                        source,\n-                        normalization_certainty.unify_and(candidate_certainty),\n-                    )\n-                })\n-            }\n-        })\n-    }\n-\n-    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, TraitPredicate<'tcx>>) {\n-        self.cx.tcx.for_each_relevant_impl(\n-            goal.predicate.def_id(),\n-            goal.predicate.self_ty(),\n-            |impl_def_id| self.consider_impl_candidate(goal, impl_def_id),\n-        );\n-    }\n-\n-    fn consider_impl_candidate(\n-        &mut self,\n-        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n-        impl_def_id: DefId,\n-    ) {\n-        let impl_trait_ref = self.cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n-        if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n-            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n-        {\n-            return;\n-        }\n-\n-        self.infcx.probe(|_| {\n-            let impl_substs = self.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-            let impl_trait_ref = impl_trait_ref.subst(self.cx.tcx, impl_substs);\n-\n-            let Ok(InferOk { obligations, .. }) = self\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal.predicate.trait_ref, impl_trait_ref)\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n-\n-            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-\n-            let Ok(certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n-            self.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n-        })\n-    }\n-}"}]}