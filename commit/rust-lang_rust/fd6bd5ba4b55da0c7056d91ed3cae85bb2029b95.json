{"sha": "fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNmJkNWJhNGI1NWRhMGM3MDU2ZDkxZWQzY2FlODViYjIwMjliOTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-12T09:56:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-12T09:58:18Z"}, "message": "rename things away from 'Shr' that are used for much more than just shared references", "tree": {"sha": "996a0345bbaff12c4d8483ea09b2b6e8fd6dfa42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996a0345bbaff12c4d8483ea09b2b6e8fd6dfa42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95", "html_url": "https://github.com/rust-lang/rust/commit/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c652032c0223de205c28e6e0ded117ca4e46e61", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c652032c0223de205c28e6e0ded117ca4e46e61", "html_url": "https://github.com/rust-lang/rust/commit/3c652032c0223de205c28e6e0ded117ca4e46e61"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "a52e115323c6ff98ae90b53f3d887ef1eb0ac049", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=fd6bd5ba4b55da0c7056d91ed3cae85bb2029b95", "patch": "@@ -21,19 +21,19 @@ pub type CallId = u64;\n pub enum Borrow {\n     /// A unique (mutable) reference.\n     Uniq(Timestamp),\n-    /// A shared reference.  This is also used by raw pointers, which do not track details\n+    /// An aliasing reference.  This is also used by raw pointers, which do not track details\n     /// of how or when they were created, hence the timestamp is optional.\n     /// Shr(Some(_)) does NOT mean that the destination of this reference is frozen;\n     /// that depends on the type!  Only those parts outside of an `UnsafeCell` are actually\n     /// frozen.\n-    Shr(Option<Timestamp>),\n+    Alias(Option<Timestamp>),\n }\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_shared(self) -> bool {\n+    pub fn is_aliasing(self) -> bool {\n         match self {\n-            Borrow::Shr(_) => true,\n+            Borrow::Alias(_) => true,\n             _ => false,\n         }\n     }\n@@ -49,7 +49,7 @@ impl Borrow {\n \n impl Default for Borrow {\n     fn default() -> Self {\n-        Borrow::Shr(None)\n+        Borrow::Alias(None)\n     }\n }\n \n@@ -58,10 +58,9 @@ impl Default for Borrow {\n pub enum BorStackItem {\n     /// Indicates the unique reference that may mutate.\n     Uniq(Timestamp),\n-    /// Indicates that the location has been shared.  Used for raw pointers, but\n-    /// also for shared references.  The latter *additionally* get frozen\n-    /// when there is no `UnsafeCell`.\n-    Shr,\n+    /// Indicates that the location has been mutably shared.  Used for raw pointers as\n+    /// well as for unfrozen shared references.\n+    Raw,\n     /// A barrier, tracking the function it belongs to by its index on the call stack\n     FnBarrier(CallId)\n }\n@@ -186,19 +185,19 @@ impl<'tcx> Stack {\n         kind: RefKind,\n     ) -> Result<Option<usize>, String> {\n         // Exclude unique ref with frozen tag.\n-        if let (RefKind::Unique, Borrow::Shr(Some(_))) = (kind, bor) {\n+        if let (RefKind::Unique, Borrow::Alias(Some(_))) = (kind, bor) {\n             return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n         }\n         // Checks related to freezing\n         match bor {\n-            Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+            Borrow::Alias(Some(bor_t)) if kind == RefKind::Frozen => {\n                 // We need the location to be frozen. This ensures F3.\n                 let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n                 return if frozen { Ok(None) } else {\n                     Err(format!(\"Location is not frozen long enough\"))\n                 }\n             }\n-            Borrow::Shr(_) if self.frozen_since.is_some() => {\n+            Borrow::Alias(_) if self.frozen_since.is_some() => {\n                 return Ok(None) // Shared deref to frozen location, looking good\n             }\n             _ => {} // Not sufficient, go on looking.\n@@ -210,8 +209,8 @@ impl<'tcx> Stack {\n                     // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared/raw item.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching aliasing/raw item.\n                     return Ok(Some(idx))\n                 }\n                 // Go on looking.  We ignore barriers!  When an `&mut` and an `&` alias,\n@@ -258,14 +257,15 @@ impl<'tcx> Stack {\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.  Continue after the match.\n                 }\n-                (BorStackItem::Shr, _) if kind == AccessKind::Read => {\n-                    // When reading, everything can use a shared item!\n+                (BorStackItem::Raw, _) if kind == AccessKind::Read => {\n+                    // When reading, everything can use a raw item!\n                     // We do not want to do this when writing: Writing to an `&mut`\n                     // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack).  Continue after the match.\n+                    // on top of the stack).\n+                    // Continue after the match.\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared item.  Continue after the match.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching raw item.  Continue after the match.\n                 }\n                 _ => {\n                     // Pop this, go on.  This ensures U2.\n@@ -309,7 +309,7 @@ impl<'tcx> Stack {\n         // of access (like writing through raw pointers) is permitted.\n         if kind == RefKind::Frozen {\n             let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n+                Borrow::Alias(Some(t)) => t,\n                 _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n             };\n             // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n@@ -328,12 +328,12 @@ impl<'tcx> Stack {\n         // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-            Borrow::Shr(_) => BorStackItem::Shr,\n+            Borrow::Alias(_) => BorStackItem::Raw,\n         };\n         if *self.borrows.last().unwrap() == itm {\n             // This is just an optimization, no functional change: Avoid stacking\n             // multiple `Shr` on top of each other.\n-            assert!(bor.is_shared());\n+            assert!(bor.is_aliasing());\n             trace!(\"create: Sharing a shared location is a NOP\");\n         } else {\n             // This ensures U1.\n@@ -440,7 +440,7 @@ impl<'tcx> Stacks {\n                     _ => false,\n                 };\n             if bor_redundant {\n-                assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n+                assert!(new_bor.is_aliasing(), \"A unique reborrow can never be redundant\");\n                 trace!(\"reborrow is redundant\");\n                 continue;\n             }\n@@ -465,7 +465,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n     #[inline(always)]\n     fn memory_allocated<'tcx>(size: Size, extra: &MemoryState) -> Self {\n         let stack = Stack {\n-            borrows: vec![BorStackItem::Shr],\n+            borrows: vec![BorStackItem::Raw],\n             frozen_since: None,\n         };\n         Stacks {\n@@ -511,7 +511,7 @@ impl<'tcx> Stacks {\n     ) {\n         for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n             assert!(stack.borrows.len() == 1);\n-            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Shr);\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Raw);\n             stack.borrows.push(itm);\n         }\n     }\n@@ -536,7 +536,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n-        if let Borrow::Shr(Some(_)) = new_bor {\n+        if let Borrow::Alias(Some(_)) = new_bor {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n@@ -574,7 +574,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let time = this.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n             Some(MutMutable) => Borrow::Uniq(time),\n-            Some(MutImmutable) => Borrow::Shr(Some(time)),\n+            Some(MutImmutable) => Borrow::Alias(Some(time)),\n             None => Borrow::default(),\n         };\n \n@@ -586,7 +586,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n             // We immediately share it, to allow read accesses\n             let two_phase_time = this.machine.stacked_borrows.increment_clock();\n-            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n+            let two_phase_bor = Borrow::Alias(Some(two_phase_time));\n             this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n         }\n \n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n-        if let Borrow::Shr(Some(_)) = ptr.tag {\n+        if let Borrow::Alias(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n             // We need a frozen-sensitive check\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {"}]}