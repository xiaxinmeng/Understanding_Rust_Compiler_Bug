{"sha": "91b2f0baafa5fe1827ed13c56721b5f505564e7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjJmMGJhYWZhNWZlMTgyN2VkMTNjNTY3MjFiNWY1MDU1NjRlN2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-27T08:06:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-27T08:06:18Z"}, "message": "Merge #5539\n\n5539: SSR: Fix path resolution of locals in current scope r=matklad a=davidlattimore\n\n\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "e47d887f72abf2e38df06956e0a7635c255acd5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47d887f72abf2e38df06956e0a7635c255acd5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b2f0baafa5fe1827ed13c56721b5f505564e7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfHor6CRBK7hj4Ov3rIwAAdHIIAKtgnMECfTGj/AlSjG8D4NGX\ngGFoM9gLnsciBaIoKrf4EX9LyVW2bkVawXUonOP6cxYzaad8U29yg8kqVJHJ4jhk\nsoiiNXOvpqaYOfTGHu5nWRGmeKwJVhAkSmjzV1V563aS/ngsWOzm/Vi6hU5QjNji\n2MYse7Wqzh+0yog1/N1/oSufQEMsqmocKmqXnXrMfPsFD4qqpclpfnMhmOa3WYuv\nbHxbBOUdEUXcx3u/COlR4bmN5zVqb5YQ3R2pYBzAhf4N8WCOD6LMvQFmA5a/v6w1\nVieNb5q0NAaaEZZpwzbJwuMTREzhTNzln3tSuX8d/dcRgANm3HsnQRekk4jpdGw=\n=zgLZ\n-----END PGP SIGNATURE-----\n", "payload": "tree e47d887f72abf2e38df06956e0a7635c255acd5b\nparent 401a9c25151c1b659b8e80e2ffe70fa96a1f8ef1\nparent b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1595837178 +0000\ncommitter GitHub <noreply@github.com> 1595837178 +0000\n\nMerge #5539\n\n5539: SSR: Fix path resolution of locals in current scope r=matklad a=davidlattimore\n\n\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b2f0baafa5fe1827ed13c56721b5f505564e7c", "html_url": "https://github.com/rust-lang/rust/commit/91b2f0baafa5fe1827ed13c56721b5f505564e7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b2f0baafa5fe1827ed13c56721b5f505564e7c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "401a9c25151c1b659b8e80e2ffe70fa96a1f8ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/401a9c25151c1b659b8e80e2ffe70fa96a1f8ef1", "html_url": "https://github.com/rust-lang/rust/commit/401a9c25151c1b659b8e80e2ffe70fa96a1f8ef1"}, {"sha": "b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "html_url": "https://github.com/rust-lang/rust/commit/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38"}], "stats": {"total": 130, "additions": 103, "deletions": 27}, "files": [{"sha": "7014a6ac66e49d040cdfa3a48d50b8aa569e2ff4", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=91b2f0baafa5fe1827ed13c56721b5f505564e7c", "patch": "@@ -51,8 +51,7 @@ pub struct MatchFinder<'db> {\n     /// Our source of information about the user's code.\n     sema: Semantics<'db, ra_ide_db::RootDatabase>,\n     rules: Vec<ResolvedRule>,\n-    scope: hir::SemanticsScope<'db>,\n-    hygiene: hir::Hygiene,\n+    resolution_scope: resolving::ResolutionScope<'db>,\n }\n \n impl<'db> MatchFinder<'db> {\n@@ -63,21 +62,8 @@ impl<'db> MatchFinder<'db> {\n         lookup_context: FilePosition,\n     ) -> MatchFinder<'db> {\n         let sema = Semantics::new(db);\n-        let file = sema.parse(lookup_context.file_id);\n-        // Find a node at the requested position, falling back to the whole file.\n-        let node = file\n-            .syntax()\n-            .token_at_offset(lookup_context.offset)\n-            .left_biased()\n-            .map(|token| token.parent())\n-            .unwrap_or_else(|| file.syntax().clone());\n-        let scope = sema.scope(&node);\n-        MatchFinder {\n-            sema: Semantics::new(db),\n-            rules: Vec::new(),\n-            scope,\n-            hygiene: hir::Hygiene::new(db, lookup_context.file_id.into()),\n-        }\n+        let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context);\n+        MatchFinder { sema: Semantics::new(db), rules: Vec::new(), resolution_scope }\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context.\n@@ -106,8 +92,7 @@ impl<'db> MatchFinder<'db> {\n         for parsed_rule in rule.parsed_rules {\n             self.rules.push(ResolvedRule::new(\n                 parsed_rule,\n-                &self.scope,\n-                &self.hygiene,\n+                &self.resolution_scope,\n                 self.rules.len(),\n             )?);\n         }\n@@ -140,8 +125,7 @@ impl<'db> MatchFinder<'db> {\n         for parsed_rule in pattern.parsed_rules {\n             self.rules.push(ResolvedRule::new(\n                 parsed_rule,\n-                &self.scope,\n-                &self.hygiene,\n+                &self.resolution_scope,\n                 self.rules.len(),\n             )?);\n         }"}, {"sha": "123bd2bb24e760f08d8fdbc2eb9ae3f546f29056", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=91b2f0baafa5fe1827ed13c56721b5f505564e7c", "patch": "@@ -3,10 +3,16 @@\n use crate::errors::error;\n use crate::{parsing, SsrError};\n use parsing::Placeholder;\n+use ra_db::FilePosition;\n use ra_syntax::{ast, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken};\n use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::mark;\n \n+pub(crate) struct ResolutionScope<'db> {\n+    scope: hir::SemanticsScope<'db>,\n+    hygiene: hir::Hygiene,\n+}\n+\n pub(crate) struct ResolvedRule {\n     pub(crate) pattern: ResolvedPattern,\n     pub(crate) template: Option<ResolvedPattern>,\n@@ -30,12 +36,11 @@ pub(crate) struct ResolvedPath {\n impl ResolvedRule {\n     pub(crate) fn new(\n         rule: parsing::ParsedRule,\n-        scope: &hir::SemanticsScope,\n-        hygiene: &hir::Hygiene,\n+        resolution_scope: &ResolutionScope,\n         index: usize,\n     ) -> Result<ResolvedRule, SsrError> {\n         let resolver =\n-            Resolver { scope, hygiene, placeholders_by_stand_in: rule.placeholders_by_stand_in };\n+            Resolver { resolution_scope, placeholders_by_stand_in: rule.placeholders_by_stand_in };\n         let resolved_template = if let Some(template) = rule.template {\n             Some(resolver.resolve_pattern_tree(template)?)\n         } else {\n@@ -57,8 +62,7 @@ impl ResolvedRule {\n }\n \n struct Resolver<'a, 'db> {\n-    scope: &'a hir::SemanticsScope<'db>,\n-    hygiene: &'a hir::Hygiene,\n+    resolution_scope: &'a ResolutionScope<'db>,\n     placeholders_by_stand_in: FxHashMap<SmolStr, parsing::Placeholder>,\n }\n \n@@ -104,6 +108,7 @@ impl Resolver<'_, '_> {\n                 && !self.path_contains_placeholder(&path)\n             {\n                 let resolution = self\n+                    .resolution_scope\n                     .resolve_path(&path)\n                     .ok_or_else(|| error!(\"Failed to resolve path `{}`\", node.text()))?;\n                 resolved_paths.insert(node, ResolvedPath { resolution, depth });\n@@ -131,9 +136,32 @@ impl Resolver<'_, '_> {\n         }\n         false\n     }\n+}\n+\n+impl<'db> ResolutionScope<'db> {\n+    pub(crate) fn new(\n+        sema: &hir::Semantics<'db, ra_ide_db::RootDatabase>,\n+        lookup_context: FilePosition,\n+    ) -> ResolutionScope<'db> {\n+        use ra_syntax::ast::AstNode;\n+        let file = sema.parse(lookup_context.file_id);\n+        // Find a node at the requested position, falling back to the whole file.\n+        let node = file\n+            .syntax()\n+            .token_at_offset(lookup_context.offset)\n+            .left_biased()\n+            .map(|token| token.parent())\n+            .unwrap_or_else(|| file.syntax().clone());\n+        let node = pick_node_for_resolution(node);\n+        let scope = sema.scope(&node);\n+        ResolutionScope {\n+            scope,\n+            hygiene: hir::Hygiene::new(sema.db, lookup_context.file_id.into()),\n+        }\n+    }\n \n     fn resolve_path(&self, path: &ast::Path) -> Option<hir::PathResolution> {\n-        let hir_path = hir::Path::from_src(path.clone(), self.hygiene)?;\n+        let hir_path = hir::Path::from_src(path.clone(), &self.hygiene)?;\n         // First try resolving the whole path. This will work for things like\n         // `std::collections::HashMap`, but will fail for things like\n         // `std::collections::HashMap::new`.\n@@ -158,6 +186,33 @@ impl Resolver<'_, '_> {\n     }\n }\n \n+/// Returns a suitable node for resolving paths in the current scope. If we create a scope based on\n+/// a statement node, then we can't resolve local variables that were defined in the current scope\n+/// (only in parent scopes). So we find another node, ideally a child of the statement where local\n+/// variable resolution is permitted.\n+fn pick_node_for_resolution(node: SyntaxNode) -> SyntaxNode {\n+    match node.kind() {\n+        SyntaxKind::EXPR_STMT => {\n+            if let Some(n) = node.first_child() {\n+                mark::hit!(cursor_after_semicolon);\n+                return n;\n+            }\n+        }\n+        SyntaxKind::LET_STMT | SyntaxKind::BIND_PAT => {\n+            if let Some(next) = node.next_sibling() {\n+                return pick_node_for_resolution(next);\n+            }\n+        }\n+        SyntaxKind::NAME => {\n+            if let Some(parent) = node.parent() {\n+                return pick_node_for_resolution(parent);\n+            }\n+        }\n+        _ => {}\n+    }\n+    node\n+}\n+\n /// Returns whether `path` or any of its qualifiers contains type arguments.\n fn path_contains_type_arguments(path: Option<ast::Path>) -> bool {\n     if let Some(path) = path {"}, {"sha": "18ef2506afa7714d9085a5f1b66b6515041ded21", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b2f0baafa5fe1827ed13c56721b5f505564e7c/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=91b2f0baafa5fe1827ed13c56721b5f505564e7c", "patch": "@@ -885,3 +885,40 @@ fn ufcs_matches_method_call() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn replace_local_variable_reference() {\n+    // The pattern references a local variable `foo` in the block containing the cursor. We should\n+    // only replace references to this variable `foo`, not other variables that just happen to have\n+    // the same name.\n+    mark::check!(cursor_after_semicolon);\n+    assert_ssr_transform(\n+        \"foo + $a ==>> $a - foo\",\n+        r#\"\n+            fn bar1() -> i32 {\n+                let mut res = 0;\n+                let foo = 5;\n+                res += foo + 1;\n+                let foo = 10;\n+                res += foo + 2;<|>\n+                res += foo + 3;\n+                let foo = 15;\n+                res += foo + 4;\n+                res\n+            }\n+            \"#,\n+        expect![[r#\"\n+            fn bar1() -> i32 {\n+                let mut res = 0;\n+                let foo = 5;\n+                res += foo + 1;\n+                let foo = 10;\n+                res += 2 - foo;\n+                res += 3 - foo;\n+                let foo = 15;\n+                res += foo + 4;\n+                res\n+            }\n+        \"#]],\n+    )\n+}"}]}