{"sha": "f34e49dd90603337da2347fe81e4d3158ae5fbd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNGU0OWRkOTA2MDMzMzdkYTIzNDdmZTgxZTRkMzE1OGFlNWZiZDE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T07:23:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-27T06:43:49Z"}, "message": "With `--test`, make `#[test]` functions `pub` in `InvocationCollector`\nand expand the `__test_reexports` in the correct scope.", "tree": {"sha": "351ef83fa92ff4e18cd9762b2b295594c069312c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/351ef83fa92ff4e18cd9762b2b295594c069312c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f34e49dd90603337da2347fe81e4d3158ae5fbd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f34e49dd90603337da2347fe81e4d3158ae5fbd1", "html_url": "https://github.com/rust-lang/rust/commit/f34e49dd90603337da2347fe81e4d3158ae5fbd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f34e49dd90603337da2347fe81e4d3158ae5fbd1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0613dac042fc45c40248b699f380aa93532336aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0613dac042fc45c40248b699f380aa93532336aa", "html_url": "https://github.com/rust-lang/rust/commit/0613dac042fc45c40248b699f380aa93532336aa"}], "stats": {"total": 94, "additions": 49, "deletions": 45}, "files": [{"sha": "1f721541ff8ffbca98fbd61133a1a5c6f5082fe4", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f34e49dd90603337da2347fe81e4d3158ae5fbd1", "patch": "@@ -43,6 +43,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n+    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n+        let mark = Mark::fresh();\n+        let module = self.module_map[&id];\n+        self.expansion_data.insert(mark.as_u32(), ExpansionData {\n+            module: module,\n+            def_index: module.def_id().unwrap().index,\n+        });\n+        mark\n+    }\n+\n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         self.collect_def_ids(mark, expansion);\n         self.current_module = self.expansion_data[&mark.as_u32()].module;"}, {"sha": "94a7f6030b9373d557fec1c6d3ec4c720f1430a9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f34e49dd90603337da2347fe81e4d3158ae5fbd1", "patch": "@@ -303,6 +303,6 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n \n-fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n+pub fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"test\") || attr.check_name(\"bench\")\n }"}, {"sha": "1d2a0dd0cbc65f2abfa2bd5db642ab2d75b9a4db", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f34e49dd90603337da2347fe81e4d3158ae5fbd1", "patch": "@@ -656,6 +656,7 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n+    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n     fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n@@ -671,6 +672,7 @@ pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n+    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n     fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}"}, {"sha": "aad895750c8696b359ca689c67a4e24a0d1c3e89", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f34e49dd90603337da2347fe81e4d3158ae5fbd1", "patch": "@@ -16,7 +16,7 @@ use ext::placeholders::{placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n-use config::StripUnconfigured;\n+use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n@@ -612,7 +612,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         let item = configure!(self, item);\n \n-        let (item, attr) = self.classify_item(item);\n+        let (mut item, attr) = self.classify_item(item);\n         if let Some(attr) = attr {\n             let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n             return self.collect_attr(attr, item, ExpansionKind::Items).make_items();\n@@ -669,6 +669,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.cx.current_expansion.module = orig_module;\n                 return result;\n             }\n+            // Ensure that test functions are accessible from the test harness.\n+            ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n+                if item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n+                    item = item.map(|mut item| { item.vis = ast::Visibility::Public; item });\n+                }\n+                noop_fold_item(item, self)\n+            }\n             _ => noop_fold_item(item, self),\n         }\n     }"}, {"sha": "e4510520a55a435c43de5671d48651a0a044b8c3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34e49dd90603337da2347fe81e4d3158ae5fbd1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f34e49dd90603337da2347fe81e4d3158ae5fbd1", "patch": "@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n \n-        let i = if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n+        if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n                 ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n@@ -136,54 +136,37 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n-                    // debug!(\"have {} test/bench functions\",\n-                    //        cx.testfns.len());\n-\n-                    // Make all tests public so we can call them from outside\n-                    // the module (note that the tests are re-exported and must\n-                    // be made public themselves to avoid privacy errors).\n-                    i.map(|mut i| {\n-                        i.vis = ast::Visibility::Public;\n-                        i\n-                    })\n                 }\n             }\n-        } else {\n-            i\n-        };\n+        }\n \n+        let mut item = i.unwrap();\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        let res = match i.node {\n-            ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n-            _ => SmallVector::one(i),\n-        };\n+        if let ast::ItemKind::Mod(module) = item.node {\n+            let tests = mem::replace(&mut self.tests, Vec::new());\n+            let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n+            let mut mod_folded = fold::noop_fold_mod(module, self);\n+            let tests = mem::replace(&mut self.tests, tests);\n+            let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n+\n+            if !tests.is_empty() || !tested_submods.is_empty() {\n+                let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n+                mod_folded.items.push(it);\n+\n+                if !self.cx.path.is_empty() {\n+                    self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n+                } else {\n+                    debug!(\"pushing nothing, sym: {:?}\", sym);\n+                    self.cx.toplevel_reexport = Some(sym);\n+                }\n+            }\n+            item.node = ast::ItemKind::Mod(mod_folded);\n+        }\n         if ident.name != keywords::Invalid.name() {\n             self.cx.path.pop();\n         }\n-        res\n-    }\n-\n-    fn fold_mod(&mut self, m: ast::Mod) -> ast::Mod {\n-        let tests = mem::replace(&mut self.tests, Vec::new());\n-        let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n-        let mut mod_folded = fold::noop_fold_mod(m, self);\n-        let tests = mem::replace(&mut self.tests, tests);\n-        let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n-\n-        if !tests.is_empty() || !tested_submods.is_empty() {\n-            let (it, sym) = mk_reexport_mod(&mut self.cx, tests, tested_submods);\n-            mod_folded.items.push(it);\n-\n-            if !self.cx.path.is_empty() {\n-                self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n-            } else {\n-                debug!(\"pushing nothing, sym: {:?}\", sym);\n-                self.cx.toplevel_reexport = Some(sym);\n-            }\n-        }\n-\n-        mod_folded\n+        SmallVector::one(P(item))\n     }\n \n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n@@ -239,7 +222,7 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n+fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident>,\n                    tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n     let super_ = token::str_to_ident(\"super\");\n \n@@ -257,6 +240,8 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n+    let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n+    cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),"}]}