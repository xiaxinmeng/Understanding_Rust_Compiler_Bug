{"sha": "e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OTAxNjQxNzU1ZGZkMmU3NThjN2U4NTViODJlZTBiY2Q4YjI5YzA=", "commit": {"author": {"name": "msizanoen1", "email": "qtmlabs@protonmail.com", "date": "2020-01-21T14:52:19Z"}, "committer": {"name": "msizanoen1", "email": "qtmlabs@protonmail.com", "date": "2020-02-04T04:55:31Z"}, "message": "Implement proper C ABI lowering for RISC-V", "tree": {"sha": "927a9318a7e766eaa974ca2fe1181a55a0b29c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/927a9318a7e766eaa974ca2fe1181a55a0b29c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "html_url": "https://github.com/rust-lang/rust/commit/e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/comments", "author": {"login": "msizanoen1", "id": 55322658, "node_id": "MDQ6VXNlcjU1MzIyNjU4", "avatar_url": "https://avatars.githubusercontent.com/u/55322658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msizanoen1", "html_url": "https://github.com/msizanoen1", "followers_url": "https://api.github.com/users/msizanoen1/followers", "following_url": "https://api.github.com/users/msizanoen1/following{/other_user}", "gists_url": "https://api.github.com/users/msizanoen1/gists{/gist_id}", "starred_url": "https://api.github.com/users/msizanoen1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msizanoen1/subscriptions", "organizations_url": "https://api.github.com/users/msizanoen1/orgs", "repos_url": "https://api.github.com/users/msizanoen1/repos", "events_url": "https://api.github.com/users/msizanoen1/events{/privacy}", "received_events_url": "https://api.github.com/users/msizanoen1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msizanoen1", "id": 55322658, "node_id": "MDQ6VXNlcjU1MzIyNjU4", "avatar_url": "https://avatars.githubusercontent.com/u/55322658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msizanoen1", "html_url": "https://github.com/msizanoen1", "followers_url": "https://api.github.com/users/msizanoen1/followers", "following_url": "https://api.github.com/users/msizanoen1/following{/other_user}", "gists_url": "https://api.github.com/users/msizanoen1/gists{/gist_id}", "starred_url": "https://api.github.com/users/msizanoen1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msizanoen1/subscriptions", "organizations_url": "https://api.github.com/users/msizanoen1/orgs", "repos_url": "https://api.github.com/users/msizanoen1/repos", "events_url": "https://api.github.com/users/msizanoen1/events{/privacy}", "received_events_url": "https://api.github.com/users/msizanoen1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d34a8772251b3f9d4dd05c81d9531d455a14fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d34a8772251b3f9d4dd05c81d9531d455a14fc2", "html_url": "https://github.com/rust-lang/rust/commit/0d34a8772251b3f9d4dd05c81d9531d455a14fc2"}], "stats": {"total": 346, "additions": 331, "deletions": 15}, "files": [{"sha": "c70473b667ea91b1942f9e4b3e297a976df90f5e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "patch": "@@ -2650,6 +2650,7 @@ where\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n                 .collect(),\n             c_variadic: sig.c_variadic,\n+            fixed_count: inputs.len(),\n             conv,\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);"}, {"sha": "175eb93e4e55fc55603c906e3087533f5fa8844e", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "patch": "@@ -120,6 +120,7 @@ impl Reg {\n     reg_ctor!(i16, Integer, 16);\n     reg_ctor!(i32, Integer, 32);\n     reg_ctor!(i64, Integer, 64);\n+    reg_ctor!(i128, Integer, 128);\n \n     reg_ctor!(f32, Float, 32);\n     reg_ctor!(f64, Float, 64);\n@@ -493,6 +494,12 @@ pub struct FnAbi<'a, Ty> {\n \n     pub c_variadic: bool,\n \n+    /// The count of non-variadic arguments.\n+    ///\n+    /// Should only be different from args.len() when c_variadic is true.\n+    /// This can be used to know wether an argument is variadic or not.\n+    pub fixed_count: usize,\n+\n     pub conv: Conv,\n }\n \n@@ -534,8 +541,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"nvptx\" => nvptx::compute_abi_info(self),\n             \"nvptx64\" => nvptx64::compute_abi_info(self),\n             \"hexagon\" => hexagon::compute_abi_info(self),\n-            \"riscv32\" => riscv::compute_abi_info(self, 32),\n-            \"riscv64\" => riscv::compute_abi_info(self, 64),\n+            \"riscv32\" | \"riscv64\" => riscv::compute_abi_info(cx, self),\n             \"wasm32\" if cx.target_spec().target_os != \"emscripten\" => {\n                 wasm32_bindgen_compat::compute_abi_info(self)\n             }"}, {"sha": "11d6c4d8191071870ab8755b9d72ab7a1cc5ff3f", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 322, "deletions": 13, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5901641755dfd2e758c7e855b82ee0bcd8b29c0/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=e5901641755dfd2e758c7e855b82ee0bcd8b29c0", "patch": "@@ -1,49 +1,358 @@\n // Reference: RISC-V ELF psABI specification\n // https://github.com/riscv/riscv-elf-psabi-doc\n+//\n+// Reference: Clang RISC-V ELF psABI lowering code\n+// https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n-use crate::abi::call::{ArgAbi, FnAbi};\n+use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::{\n+    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods,\n+};\n+use crate::spec::HasTargetSpec;\n+\n+#[derive(Copy, Clone)]\n+enum RegPassKind {\n+    Float(Reg),\n+    Integer(Reg),\n+    Unknown,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FloatConv {\n+    FloatPair(Reg, Reg),\n+    Float(Reg),\n+    MixedPair(Reg, Reg),\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CannotUseFpConv;\n+\n+fn is_riscv_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+    match arg.layout.abi {\n+        Abi::Vector { .. } => true,\n+        _ => arg.layout.is_aggregate(),\n+    }\n+}\n+\n+fn should_use_fp_conv_helper<'a, Ty, C>(\n+    cx: &C,\n+    arg_layout: &TyLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    field1_kind: &mut RegPassKind,\n+    field2_kind: &mut RegPassKind,\n+) -> Result<(), CannotUseFpConv>\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    match arg_layout.abi {\n+        Abi::Scalar(ref scalar) => match scalar.value {\n+            abi::Int(..) | abi::Pointer => {\n+                if arg_layout.size.bits() > xlen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {\n+                        *field2_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+            abi::F32 | abi::F64 => {\n+                if arg_layout.size.bits() > flen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    (_, RegPassKind::Unknown) => {\n+                        *field2_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+        },\n+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n+            FieldPlacement::Union(_) => {\n+                if !arg_layout.is_zst() {\n+                    return Err(CannotUseFpConv);\n+                }\n+            }\n+            FieldPlacement::Array { count, .. } => {\n+                for _ in 0..count {\n+                    let elem_layout = arg_layout.field(cx, 0);\n+                    should_use_fp_conv_helper(\n+                        cx,\n+                        &elem_layout,\n+                        xlen,\n+                        flen,\n+                        field1_kind,\n+                        field2_kind,\n+                    )?;\n+                }\n+            }\n+            FieldPlacement::Arbitrary { .. } => {\n+                match arg_layout.variants {\n+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n+                    abi::Variants::Single { .. } => (),\n+                }\n+                for i in arg_layout.fields.index_by_increasing_offset() {\n+                    let field = arg_layout.field(cx, i);\n+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;\n+                }\n+            }\n+        },\n+    }\n+    Ok(())\n+}\n+\n+fn should_use_fp_conv<'a, Ty, C>(\n+    cx: &C,\n+    arg: &TyLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+) -> Option<FloatConv>\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    let mut field1_kind = RegPassKind::Unknown;\n+    let mut field2_kind = RegPassKind::Unknown;\n+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {\n+        return None;\n+    }\n+    match (field1_kind, field2_kind) {\n+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),\n+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),\n+        _ => None,\n+    }\n+}\n+\n+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+        match conv {\n+            FloatConv::Float(f) => {\n+                arg.cast_to(f);\n+            }\n+            FloatConv::FloatPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+            FloatConv::MixedPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    let total = arg.layout.size;\n \n-fn classify_ret<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n     // replaced in the argument list with the address, as are C++ aggregates\n     // with nontrivial copy constructors, destructors, or vtables.\"\n-    if arg.layout.size.bits() > 2 * xlen {\n-        arg.make_indirect();\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_riscv_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        return true;\n+    }\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+    if is_riscv_aggregate(arg) {\n+        if total.bits() <= xlen {\n+            arg.cast_to(xlen_reg);\n+        } else {\n+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });\n+        }\n+        return false;\n     }\n \n     // \"When passed in registers, scalars narrower than XLEN bits are widened\n     // according to the sign of their type up to 32 bits, then sign-extended to\n     // XLEN bits.\"\n-    arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n+    extend_integer_width(arg, xlen);\n+    false\n }\n \n-fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n+fn classify_arg<'a, Ty, C>(\n+    cx: &C,\n+    arg: &mut ArgAbi<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    is_vararg: bool,\n+    avail_gprs: &mut u64,\n+    avail_fprs: &mut u64,\n+) where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    if !is_vararg {\n+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {\n+                *avail_fprs -= 1;\n+                arg.cast_to(f);\n+                return;\n+            }\n+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {\n+                *avail_fprs -= 2;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {\n+                *avail_gprs -= 1;\n+                *avail_fprs -= 1;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    let total = arg.layout.size;\n+    let align = arg.layout.align.abi.bits();\n+\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n     // replaced in the argument list with the address, as are C++ aggregates\n     // with nontrivial copy constructors, destructors, or vtables.\"\n-    if arg.layout.size.bits() > 2 * xlen {\n-        arg.make_indirect();\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_riscv_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    let double_xlen_reg = match xlen {\n+        32 => Reg::i64(),\n+        64 => Reg::i128(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    if total.bits() > xlen {\n+        let align_regs = align > xlen;\n+        if is_riscv_aggregate(arg) {\n+            arg.cast_to(Uniform {\n+                unit: if align_regs { double_xlen_reg } else { xlen_reg },\n+                total: Size::from_bits(xlen * 2),\n+            });\n+        }\n+        if align_regs && is_vararg {\n+            *avail_gprs -= *avail_gprs % 2;\n+        }\n+        if *avail_gprs >= 2 {\n+            *avail_gprs -= 2;\n+        } else {\n+            *avail_gprs = 0;\n+        }\n+        return;\n+    } else if is_riscv_aggregate(arg) {\n+        arg.cast_to(xlen_reg);\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n     }\n \n     // \"When passed in registers, scalars narrower than XLEN bits are widened\n     // according to the sign of their type up to 32 bits, then sign-extended to\n     // XLEN bits.\"\n-    arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n+    if *avail_gprs >= 1 {\n+        extend_integer_width(arg, xlen);\n+        *avail_gprs -= 1;\n+    }\n }\n \n-pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>, xlen: u64) {\n+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+    match arg.layout.abi {\n+        Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                abi::Int(i, _) => {\n+                    // 32-bit integers are always sign-extended\n+                    if i.size().bits() == 32 && xlen > 32 {\n+                        if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                            attrs.set(ArgAttribute::SExt);\n+                            return;\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+        _ => (),\n+    }\n+    arg.extend_integer_width_to(xlen);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+{\n+    let flen = match &cx.target_spec().options.llvm_abiname[..] {\n+        \"ilp32f\" | \"lp64f\" => 32,\n+        \"ilp32d\" | \"lp64d\" => 64,\n+        _ => 0,\n+    };\n+    let xlen = cx.data_layout().pointer_size.bits();\n+\n+    let mut avail_gprs = 8;\n+    let mut avail_fprs = 8;\n+\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(&mut fn_abi.ret, xlen);\n+        if classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+            avail_gprs -= 1;\n+        }\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg(arg, xlen);\n+        classify_arg(\n+            cx,\n+            arg,\n+            xlen,\n+            flen,\n+            i >= fn_abi.fixed_count,\n+            &mut avail_gprs,\n+            &mut avail_fprs,\n+        );\n     }\n }"}]}