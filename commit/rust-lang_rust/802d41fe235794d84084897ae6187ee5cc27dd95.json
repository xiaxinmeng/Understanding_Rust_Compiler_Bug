{"sha": "802d41fe235794d84084897ae6187ee5cc27dd95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMmQ0MWZlMjM1Nzk0ZDg0MDg0ODk3YWU2MTg3ZWU1Y2MyN2RkOTU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-21T14:31:32Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-23T04:13:53Z"}, "message": "libc: switch `free` to the proper signature\n\nThis does not attempt to fully propagate the mutability everywhere, but\ngives new code a hint to avoid the same issues.", "tree": {"sha": "6cd1eecb0ec529673396040e2c43ad08941732e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cd1eecb0ec529673396040e2c43ad08941732e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/802d41fe235794d84084897ae6187ee5cc27dd95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/802d41fe235794d84084897ae6187ee5cc27dd95", "html_url": "https://github.com/rust-lang/rust/commit/802d41fe235794d84084897ae6187ee5cc27dd95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/802d41fe235794d84084897ae6187ee5cc27dd95/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce792249e72a181f2ad52413b25b1db643c371f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce792249e72a181f2ad52413b25b1db643c371f", "html_url": "https://github.com/rust-lang/rust/commit/fce792249e72a181f2ad52413b25b1db643c371f"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "217eab527582ef020f97e251c173eb392bb81edd", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -230,7 +230,7 @@ impl<T: Send> Drop for Unique<T> {\n             // We need to move the object out of the box, so that\n             // the destructor is called (at the end of this scope.)\n             ptr::replace_ptr(self.ptr, x);\n-            free(self.ptr as *c_void)\n+            free(self.ptr as *mut c_void)\n         }\n     }\n }"}, {"sha": "35a6ccaa7083cb119f08c96304738cbbfe5b503c", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -172,7 +172,7 @@ mod tests {\n             let mem = malloc_raw(n);\n \n             CVec::new_with_dtor(mem as *mut u8, n,\n-                proc() { libc::free(mem as *c_void); })\n+                proc() { libc::free(mem as *mut c_void); })\n         }\n     }\n "}, {"sha": "faceb17af476792b5c5e2a124690aea0390e5059", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -53,7 +53,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n         assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n-        libc::free(res);\n+        libc::free(res as *mut c_void);\n         out\n     }\n }\n@@ -76,7 +76,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n         assert!(res as int != 0);\n         let out = vec::raw::from_buf_raw(res as *u8,\n                                          outsz as uint);\n-        libc::free(res);\n+        libc::free(res as *mut c_void);\n         out\n     }\n }"}, {"sha": "af06533d44bd1cb1844fa3809e405657be4acc14", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -548,13 +548,13 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             let p = Path::new(p);\n             let star = p.join(\"*\");\n             as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint) as *c_void;\n+                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n                 let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n                     let mut paths = ~[];\n                     let mut more_files = 1 as libc::c_int;\n                     while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n+                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n                         if fp_buf as uint == 0 {\n                             fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                         }\n@@ -567,7 +567,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n                     FindClose(find_handle);\n-                    free(wfd_ptr);\n+                    free(wfd_ptr as *mut c_void);\n                     Ok(paths)\n                 } else {\n                     Err(super::last_error())"}, {"sha": "3693b00951bcc84bacdfea7f51fe9b91c4d0fc0f", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -1836,7 +1836,7 @@ impl TypeNames {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n-            free(s as *c_void);\n+            free(s as *mut c_void);\n             ret\n         }\n     }\n@@ -1850,7 +1850,7 @@ impl TypeNames {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);\n-            free(s as *c_void);\n+            free(s as *mut c_void);\n             ret\n         }\n     }"}, {"sha": "0a6e23e995640d443f1fc0d59f1e4f3812680b65", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -373,7 +373,7 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n }\n \n pub unsafe fn free_handle(v: *c_void) {\n-    free(v)\n+    free(v as *mut c_void)\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n@@ -383,7 +383,7 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n }\n \n pub unsafe fn free_req(v: *c_void) {\n-    free(v)\n+    free(v as *mut c_void)\n }\n \n #[test]"}, {"sha": "22e93e5819442bbadd7786b3cef9e91c8f0c2889", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -183,7 +183,7 @@ impl Drop for CString {\n     fn drop(&mut self) {\n         if self.owns_buffer_ {\n             unsafe {\n-                libc::free(self.buf as *libc::c_void)\n+                libc::free(self.buf as *mut libc::c_void)\n             }\n         }\n     }\n@@ -459,7 +459,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n+        unsafe { libc::free(c_str.unwrap() as *mut libc::c_void) }\n     }\n \n     #[test]"}, {"sha": "a2aa182216a6269c0ffdb79055a4c3cf857c5db2", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -3225,7 +3225,7 @@ pub mod funcs {\n                 pub fn calloc(nobj: size_t, size: size_t) -> *c_void;\n                 pub fn malloc(size: size_t) -> *mut c_void;\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n-                pub fn free(p: *c_void);\n+                pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n                 // Omitted: atexit.\n                 pub fn system(s: *c_char) -> c_int;"}, {"sha": "ead78ce41ef9af3d27703249a2c1707dcbccbb8b", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -52,7 +52,7 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n     if size == 0 {\n-        free(ptr as *c_void);\n+        free(ptr);\n         mut_null()\n     } else {\n         let p = realloc(ptr as *mut c_void, size as size_t);\n@@ -107,7 +107,7 @@ pub unsafe fn exchange_free_(ptr: *u8) {\n \n #[inline]\n pub unsafe fn exchange_free(ptr: *u8) {\n-    free(ptr as *c_void);\n+    free(ptr as *mut c_void);\n }\n \n #[cfg(test)]"}, {"sha": "e740862fddfb407f3bd4277c38631a7413ab9a14", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -389,7 +389,7 @@ impl<T: Send> Buffer<T> {\n impl<T: Send> Drop for Buffer<T> {\n     fn drop(&mut self) {\n         // It is assumed that all buffers are empty on drop.\n-        unsafe { libc::free(self.storage as *libc::c_void) }\n+        unsafe { libc::free(self.storage as *mut libc::c_void) }\n     }\n }\n "}, {"sha": "69c6204cc3236a5ba6c6a2f0044866c4035b5b50", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802d41fe235794d84084897ae6187ee5cc27dd95/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=802d41fe235794d84084897ae6187ee5cc27dd95", "patch": "@@ -173,49 +173,49 @@ mod imp {\n     type pthread_condattr_t = libc::c_void;\n \n     pub unsafe fn init_lock() -> uint {\n-        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *pthread_mutex_t;\n+        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *mut pthread_mutex_t;\n         let n = pthread_mutex_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn init_cond() -> uint {\n-        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *pthread_cond_t;\n+        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *mut pthread_cond_t;\n         let n = pthread_cond_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn free_lock(h: uint) {\n-        let block = h as *libc::c_void;\n+        let block = h as *mut libc::c_void;\n         assert_eq!(pthread_mutex_destroy(block), 0);\n         libc::free(block);\n     }\n \n     pub unsafe fn free_cond(h: uint) {\n-        let block = h as *pthread_cond_t;\n+        let block = h as *mut pthread_cond_t;\n         assert_eq!(pthread_cond_destroy(block), 0);\n         libc::free(block);\n     }\n \n     pub unsafe fn lock(l: uint) {\n-        assert_eq!(pthread_mutex_lock(l as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_mutex_lock(l as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn trylock(l: uint) -> bool {\n-        pthread_mutex_trylock(l as *pthread_mutex_t) == 0\n+        pthread_mutex_trylock(l as *mut pthread_mutex_t) == 0\n     }\n \n     pub unsafe fn unlock(l: uint) {\n-        assert_eq!(pthread_mutex_unlock(l as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_mutex_unlock(l as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn wait(cond: uint, m: uint) {\n-        assert_eq!(pthread_cond_wait(cond as *pthread_cond_t, m as *pthread_mutex_t), 0);\n+        assert_eq!(pthread_cond_wait(cond as *mut pthread_cond_t, m as *mut pthread_mutex_t), 0);\n     }\n \n     pub unsafe fn signal(cond: uint) {\n-        assert_eq!(pthread_cond_signal(cond as *pthread_cond_t), 0);\n+        assert_eq!(pthread_cond_signal(cond as *mut pthread_cond_t), 0);\n     }\n \n     extern {\n@@ -224,19 +224,19 @@ mod imp {\n     }\n \n     extern {\n-        fn pthread_mutex_init(lock: *pthread_mutex_t,\n+        fn pthread_mutex_init(lock: *mut pthread_mutex_t,\n                               attr: *pthread_mutexattr_t) -> libc::c_int;\n-        fn pthread_mutex_destroy(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_init(cond: *pthread_cond_t,\n+        fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_init(cond: *mut pthread_cond_t,\n                               attr: *pthread_condattr_t) -> libc::c_int;\n-        fn pthread_cond_destroy(cond: *pthread_cond_t) -> libc::c_int;\n-        fn pthread_mutex_lock(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_trylock(lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_mutex_unlock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n+        fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n \n-        fn pthread_cond_wait(cond: *pthread_cond_t,\n-                             lock: *pthread_mutex_t) -> libc::c_int;\n-        fn pthread_cond_signal(cond: *pthread_cond_t) -> libc::c_int;\n+        fn pthread_cond_wait(cond: *mut pthread_cond_t,\n+                             lock: *mut pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n     }\n }\n \n@@ -263,7 +263,7 @@ mod imp {\n \n     pub unsafe fn free_lock(h: uint) {\n         DeleteCriticalSection(h as LPCRITICAL_SECTION);\n-        libc::free(h as *c_void);\n+        libc::free(h as *mut c_void);\n     }\n \n     pub unsafe fn free_cond(h: uint) {"}]}