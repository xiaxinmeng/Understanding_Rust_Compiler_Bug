{"sha": "87fded1eddf834f2decbfd05e6fda35cb1ee4747", "node_id": "C_kwDOAAsO6NoAKDg3ZmRlZDFlZGRmODM0ZjJkZWNiZmQwNWU2ZmRhMzVjYjFlZTQ3NDc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-06T14:04:42Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-16T13:08:26Z"}, "message": "Improve suggestions when its parts are far from each other\n\nPreviously we only show at most 6 lines of suggestions and, if the\nsuggestions are more than 6 lines apart, we've just showed ... at the\nend. This is probably fine, but quite confusing in my opinion.\n\nThis commit is an attempt to show ... in places where there is nothing\nto suggest instead, for example:\n\nBefore:\n```text\nhelp: consider enclosing expression in a block\n  |\n3 ~     'l: { match () { () => break 'l,\n4 |\n5 |\n6 |\n7 |\n8 |\n...\n```\n\nAfter:\n```text\nhelp: consider enclosing expression in a block\n  |\n3 ~     'l: { match () { () => break 'l,\n4 |\n...\n31|\n32~ } };\n  |\n```", "tree": {"sha": "8ecf8a1506d97dbebb4497d7842db11aa394a31a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ecf8a1506d97dbebb4497d7842db11aa394a31a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87fded1eddf834f2decbfd05e6fda35cb1ee4747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87fded1eddf834f2decbfd05e6fda35cb1ee4747", "html_url": "https://github.com/rust-lang/rust/commit/87fded1eddf834f2decbfd05e6fda35cb1ee4747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87fded1eddf834f2decbfd05e6fda35cb1ee4747/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260c5fd58778f14c4f4d19e1b91784a4e0a675e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/260c5fd58778f14c4f4d19e1b91784a4e0a675e3", "html_url": "https://github.com/rust-lang/rust/commit/260c5fd58778f14c4f4d19e1b91784a4e0a675e3"}], "stats": {"total": 167, "additions": 99, "deletions": 68}, "files": [{"sha": "269d34ea4325d02f519b8db47ed375205825c4bc", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 99, "deletions": 68, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/87fded1eddf834f2decbfd05e6fda35cb1ee4747/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87fded1eddf834f2decbfd05e6fda35cb1ee4747/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=87fded1eddf834f2decbfd05e6fda35cb1ee4747", "patch": "@@ -656,11 +656,6 @@ impl Emitter for SilentEmitter {\n     }\n }\n \n-/// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n-///\n-/// This should be replaced with a more involved mechanism to output multiline suggestions that\n-/// more closely mimics the regular diagnostic output, where irrelevant code lines are elided.\n-pub const MAX_SUGGESTION_HIGHLIGHT_LINES: usize = 6;\n /// Maximum number of suggestions to be shown\n ///\n /// Arbitrary, but taken from trait import suggestion limit\n@@ -1839,79 +1834,115 @@ impl EmitterWriter {\n                 }\n                 row_num += line_end - line_start;\n             }\n-            for (line_pos, (line, highlight_parts)) in\n-                lines.by_ref().zip(highlights).take(MAX_SUGGESTION_HIGHLIGHT_LINES).enumerate()\n-            {\n-                // Print the span column to avoid confusion\n-                buffer.puts(\n-                    row_num,\n-                    0,\n-                    &self.maybe_anonymized(line_start + line_pos),\n-                    Style::LineNumber,\n-                );\n-                if let DisplaySuggestion::Diff = show_code_change {\n-                    // Add the line number for both addition and removal to drive the point home.\n-                    //\n-                    // N - fn foo<A: T>(bar: A) {\n-                    // N + fn foo(bar: impl T) {\n+            let mut unhighlighted_lines = Vec::new();\n+            for (line_pos, (line, highlight_parts)) in lines.by_ref().zip(highlights).enumerate() {\n+                debug!(%line_pos, %line, ?highlight_parts);\n+\n+                let print_line = |line_pos: usize,\n+                                  line: &str,\n+                                  highlight_parts: &Vec<SubstitutionHighlight>,\n+                                  buffer: &mut StyledBuffer,\n+                                  row_num: &mut usize| {\n+                    // Print the span column to avoid confusion\n                     buffer.puts(\n-                        row_num - 1,\n+                        *row_num,\n                         0,\n                         &self.maybe_anonymized(line_start + line_pos),\n                         Style::LineNumber,\n                     );\n-                    buffer.puts(row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n-                    buffer.puts(\n-                        row_num - 1,\n-                        max_line_num_len + 3,\n-                        &normalize_whitespace(\n-                            &*file_lines\n-                                .file\n-                                .get_line(file_lines.lines[line_pos].line_index)\n-                                .unwrap(),\n-                        ),\n-                        Style::NoStyle,\n-                    );\n-                    buffer.puts(row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n-                } else if is_multiline {\n-                    match &highlight_parts[..] {\n-                        [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n-                            buffer.puts(row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n-                        }\n-                        [] => {\n-                            draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                        }\n-                        _ => {\n-                            buffer.puts(row_num, max_line_num_len + 1, \"~ \", Style::Addition);\n+                    if let DisplaySuggestion::Diff = show_code_change {\n+                        // Add the line number for both addition and removal to drive the point home.\n+                        //\n+                        // N - fn foo<A: T>(bar: A) {\n+                        // N + fn foo(bar: impl T) {\n+                        buffer.puts(\n+                            *row_num - 1,\n+                            0,\n+                            &self.maybe_anonymized(line_start + line_pos),\n+                            Style::LineNumber,\n+                        );\n+                        buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n+                        buffer.puts(\n+                            *row_num - 1,\n+                            max_line_num_len + 3,\n+                            &normalize_whitespace(\n+                                &*file_lines\n+                                    .file\n+                                    .get_line(file_lines.lines[line_pos].line_index)\n+                                    .unwrap(),\n+                            ),\n+                            Style::NoStyle,\n+                        );\n+                        buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+                    } else if is_multiline {\n+                        match &highlight_parts[..] {\n+                            [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n+                                buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+                            }\n+                            [] => {\n+                                draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n+                            }\n+                            _ => {\n+                                buffer.puts(*row_num, max_line_num_len + 1, \"~ \", Style::Addition);\n+                            }\n                         }\n+                    } else {\n+                        draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n                     }\n-                } else {\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                }\n \n-                // print the suggestion\n-                buffer.append(row_num, &normalize_whitespace(line), Style::NoStyle);\n+                    // print the suggestion\n+                    buffer.append(*row_num, &normalize_whitespace(line), Style::NoStyle);\n \n-                // Colorize addition/replacements with green.\n-                for &SubstitutionHighlight { start, end } in highlight_parts {\n-                    // Account for tabs when highlighting (#87972).\n-                    let tabs: usize = line\n-                        .chars()\n-                        .take(start)\n-                        .map(|ch| match ch {\n-                            '\\t' => 3,\n-                            _ => 0,\n-                        })\n-                        .sum();\n-                    buffer.set_style_range(\n-                        row_num,\n-                        max_line_num_len + 3 + start + tabs,\n-                        max_line_num_len + 3 + end + tabs,\n-                        Style::Addition,\n-                        true,\n-                    );\n+                    // Colorize addition/replacements with green.\n+                    for &SubstitutionHighlight { start, end } in highlight_parts {\n+                        // Account for tabs when highlighting (#87972).\n+                        let tabs: usize = line\n+                            .chars()\n+                            .take(start)\n+                            .map(|ch| match ch {\n+                                '\\t' => 3,\n+                                _ => 0,\n+                            })\n+                            .sum();\n+                        buffer.set_style_range(\n+                            *row_num,\n+                            max_line_num_len + 3 + start + tabs,\n+                            max_line_num_len + 3 + end + tabs,\n+                            Style::Addition,\n+                            true,\n+                        );\n+                    }\n+                    *row_num += 1;\n+                };\n+\n+                if highlight_parts.is_empty() {\n+                    unhighlighted_lines.push((line_pos, line));\n+                    continue;\n                 }\n-                row_num += 1;\n+\n+                match unhighlighted_lines.len() {\n+                    0 => (),\n+                    // Since we show first line, \"...\" line and last line,\n+                    // There is no reason to hide if there are 3 or less lines\n+                    // (because then we just replace a line with ... which is\n+                    // not helpful)\n+                    n if n <= 3 => unhighlighted_lines.drain(..).for_each(|(p, l)| {\n+                        print_line(p, l, &Vec::new(), &mut buffer, &mut row_num)\n+                    }),\n+                    _ => {\n+                        unhighlighted_lines\n+                            .drain(..1)\n+                            .next()\n+                            .map(|(p, l)| print_line(p, l, &Vec::new(), &mut buffer, &mut row_num));\n+                        buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n+                        row_num += 1;\n+                        unhighlighted_lines\n+                            .pop()\n+                            .map(|(p, l)| print_line(p, l, &Vec::new(), &mut buffer, &mut row_num));\n+                    }\n+                }\n+\n+                print_line(line_pos, line, highlight_parts, &mut buffer, &mut row_num)\n             }\n \n             // This offset and the ones below need to be signed to account for replacement code"}]}