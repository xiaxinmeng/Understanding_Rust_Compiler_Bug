{"sha": "c6f0947ddbf75a35287787ce6a45740ac9662d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZjA5NDdkZGJmNzVhMzUyODc3ODdjZTZhNDU3NDBhYzk2NjJkMzI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T13:01:28Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T17:28:27Z"}, "message": "Improve comments", "tree": {"sha": "7364ef2cb890a203f42663644e33010899832838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7364ef2cb890a203f42663644e33010899832838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6f0947ddbf75a35287787ce6a45740ac9662d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f0947ddbf75a35287787ce6a45740ac9662d32", "html_url": "https://github.com/rust-lang/rust/commit/c6f0947ddbf75a35287787ce6a45740ac9662d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6f0947ddbf75a35287787ce6a45740ac9662d32/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aff073ec9123a109f9b53bc0a2f1a997258d15ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff073ec9123a109f9b53bc0a2f1a997258d15ff", "html_url": "https://github.com/rust-lang/rust/commit/aff073ec9123a109f9b53bc0a2f1a997258d15ff"}], "stats": {"total": 75, "additions": 68, "deletions": 7}, "files": [{"sha": "fa6af2dad75b91c4342d8f45c9b789326dd73abb", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c6f0947ddbf75a35287787ce6a45740ac9662d32/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f0947ddbf75a35287787ce6a45740ac9662d32/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=c6f0947ddbf75a35287787ce6a45740ac9662d32", "patch": "@@ -1,5 +1,5 @@\n-/// Note: most tests relevant to this file can be found (at the time of writing)\n-/// in src/tests/ui/pattern/usefulness.\n+/// Note: most of the tests relevant to this file can be found (at the time of writing) in\n+/// src/tests/ui/pattern/usefulness.\n ///\n /// This file includes the logic for exhaustiveness and usefulness checking for\n /// pattern-matching. Specifically, given a list of patterns for a type, we can\n@@ -13,6 +13,8 @@\n /// summarise the algorithm here to hopefully save time and be a little clearer\n /// (without being so rigorous).\n ///\n+/// # Premise\n+///\n /// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n /// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n /// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n@@ -27,8 +29,52 @@\n /// pattern to those that have come before it doesn't increase the number of values\n /// we're matching).\n ///\n+/// # Core concept\n+///\n+/// The idea that powers everything that is done in this file is the following: a value is made\n+/// from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+/// (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+/// constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+///\n+/// Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+/// arguments. This is part of what makes constructors so general: we will consider plain values\n+/// like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+/// constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+/// made up from a tree of constructors, each having a given number of children. For example:\n+/// `(None, Ok(0))` is made from 4 different constructors.\n+///\n+/// This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+/// describe this set using constructors. For example, `Err(_)` captures all values of the type\n+/// `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+/// wildcard `_` captures all values of the given type starting with any of the constructors for\n+/// that type.\n+///\n+/// We use this to compute whether different patterns might capture a same value. Do the patterns\n+/// `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+/// captures only values starting with the `Ok` constructor and the second only values starting\n+/// with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+/// since they both capture values starting with `Some`. To be certain, we need to dig under the\n+/// `Some` constructor and continue asking the question. This is the main idea behind the\n+/// exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+/// figure out if some new pattern might capture a value that hadn't been captured by previous\n+/// patterns.\n+///\n+/// Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+/// Most of the complexity of this file resides in transforming between patterns and\n+/// (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+///\n+/// Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+/// a value of type `Rc<u64>` doesn't fit this idea very well, nor do function pointers and various\n+/// other things. However, the idea covers everything that can be pattern-matched, and this is all\n+/// we need for exhaustiveness checking.\n+///\n+///\n+/// # Algorithm\n+///\n+/// Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+/// adding a new pattern `p` will cover previously-uncovered values of the type.\n /// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-/// but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+/// but rather partially-deconstructed patterns in the form of a list of fields. The paper\n /// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n /// new pattern `p`.\n ///\n@@ -936,6 +982,9 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n+/// Some fields need to be explicitely hidden away in certain cases; see the comment above the\n+/// `Fields` struct. This struct represents such a potentially-hidden field. When a field is hidden\n+/// we still keep its type around.\n #[derive(Debug, Copy, Clone)]\n enum FilteredField<'p, 'tcx> {\n     Kept(&'p Pat<'tcx>),\n@@ -972,10 +1021,17 @@ impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n #[derive(Debug, Clone)]\n enum Fields<'p, 'tcx> {\n     /// Lists of patterns that don't contain any filtered fields.\n+    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n+    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n+    /// have not measured if it really made a difference.\n     Slice(&'p [Pat<'tcx>]),\n     Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden.\n-    Filtered { fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>, len: usize },\n+    /// Patterns where some of the fields need to be hidden. `len` caches the number of non-hidden\n+    /// fields.\n+    Filtered {\n+        fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n+        len: usize,\n+    },\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n@@ -1098,7 +1154,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         pats.into_iter()\n     }\n \n-    /// Overrides some of the fields with the provided patterns.\n+    /// Overrides some of the fields with the provided patterns. Exactly like\n+    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n     fn replace_with_fieldpats(\n         &self,\n         new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n@@ -1108,7 +1165,11 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         )\n     }\n \n-    /// Overrides some of the fields with the provided patterns.\n+    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start with a\n+    /// `Fields` that is just one wildcard per field of the `Foo` struct, and override the entry\n+    /// corresponding to `field1` with the pattern `Some(_)`. This is also used for slice patterns\n+    /// for the same reason.\n     fn replace_fields_indexed(\n         &self,\n         new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,"}]}