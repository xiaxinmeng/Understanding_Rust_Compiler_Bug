{"sha": "4c617e8fb32045e1d60940ba4c79942ef0301566", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNjE3ZThmYjMyMDQ1ZTFkNjA5NDBiYTRjNzk5NDJlZjAzMDE1NjY=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-03-16T01:07:44Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-04-03T04:21:06Z"}, "message": "deps: apply rustc module loading changes", "tree": {"sha": "f12585be126f8ff005af314f2b84de885008ea2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f12585be126f8ff005af314f2b84de885008ea2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c617e8fb32045e1d60940ba4c79942ef0301566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c617e8fb32045e1d60940ba4c79942ef0301566", "html_url": "https://github.com/rust-lang/rust/commit/4c617e8fb32045e1d60940ba4c79942ef0301566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c617e8fb32045e1d60940ba4c79942ef0301566/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2bc4b5acea1b2b89dcf09991beaf5b712e456c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2bc4b5acea1b2b89dcf09991beaf5b712e456c5", "html_url": "https://github.com/rust-lang/rust/commit/f2bc4b5acea1b2b89dcf09991beaf5b712e456c5"}], "stats": {"total": 72, "additions": 35, "deletions": 37}, "files": [{"sha": "caf24476e61baf0439821bc80a086dfbf906f0c7", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=4c617e8fb32045e1d60940ba4c79942ef0301566", "patch": "@@ -92,7 +92,7 @@ fn format_project<T: FormatHandler>(\n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n     let files = modules::ModResolver::new(\n         &context.parse_session,\n-        directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaMod),\n+        directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaBlock),\n         !input_is_stdin && !config.skip_children(),\n     )\n     .visit_crate(&krate)?;"}, {"sha": "ed4316974db2f65986595f55b870d18052a61104", "filename": "src/modules.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=4c617e8fb32045e1d60940ba4c79942ef0301566", "patch": "@@ -13,7 +13,7 @@ use crate::attr::MetaVisitor;\n use crate::config::FileName;\n use crate::items::is_mod_decl;\n use crate::syntux::parser::{\n-    Directory, DirectoryOwnership, ModulePathSuccess, Parser, ParserError,\n+    Directory, DirectoryOwnership, ModError, ModulePathSuccess, Parser, ParserError,\n };\n use crate::syntux::session::ParseSess;\n use crate::utils::contains_skip;\n@@ -61,6 +61,9 @@ impl<'a> AstLike for Module<'a> {\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<ast::Attribute>)) {\n         f(&mut self.inner_attr)\n     }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<rustc_ast::tokenstream::LazyTokenStream>> {\n+        unimplemented!()\n+    }\n }\n \n /// Maps each module to the corresponding file.\n@@ -331,7 +334,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     ) -> Result<Option<SubModKind<'c, 'ast>>, ModuleResolutionError> {\n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n-            DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n+            DirectoryOwnership::UnownedViaBlock => None,\n         };\n         if let Some(path) = Parser::submod_path_from_attr(attrs, &self.directory.path) {\n             if self.parse_sess.is_file_parsed(&path) {\n@@ -366,31 +369,32 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         match self\n             .parse_sess\n             .default_submod_path(mod_name, relative, &self.directory.path)\n-            .result\n         {\n             Ok(ModulePathSuccess {\n-                path, ownership, ..\n+                file_path,\n+                dir_ownership,\n+                ..\n             }) => {\n                 let outside_mods_empty = mods_outside_ast.is_empty();\n                 let should_insert = !mods_outside_ast\n                     .iter()\n-                    .any(|(outside_path, _, _)| outside_path == &path);\n-                if self.parse_sess.is_file_parsed(&path) {\n+                    .any(|(outside_path, _, _)| outside_path == &file_path);\n+                if self.parse_sess.is_file_parsed(&file_path) {\n                     if outside_mods_empty {\n                         return Ok(None);\n                     } else {\n                         if should_insert {\n-                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                            mods_outside_ast.push((file_path, dir_ownership, sub_mod.clone()));\n                         }\n                         return Ok(Some(SubModKind::MultiExternal(mods_outside_ast)));\n                     }\n                 }\n-                match Parser::parse_file_as_module(self.parse_sess, &path, sub_mod.span) {\n+                match Parser::parse_file_as_module(self.parse_sess, &file_path, sub_mod.span) {\n                     Ok((ref attrs, _, _)) if contains_skip(attrs) => Ok(None),\n                     Ok((attrs, items, span)) if outside_mods_empty => {\n                         Ok(Some(SubModKind::External(\n-                            path,\n-                            ownership,\n+                            file_path,\n+                            dir_ownership,\n                             Module::new(\n                                 span,\n                                 Some(Cow::Owned(ast::ModKind::Unloaded)),\n@@ -401,8 +405,8 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                     }\n                     Ok((attrs, items, span)) => {\n                         mods_outside_ast.push((\n-                            path.clone(),\n-                            ownership,\n+                            file_path.clone(),\n+                            dir_ownership,\n                             Module::new(\n                                 span,\n                                 Some(Cow::Owned(ast::ModKind::Unloaded)),\n@@ -411,39 +415,38 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                             ),\n                         ));\n                         if should_insert {\n-                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                            mods_outside_ast.push((file_path, dir_ownership, sub_mod.clone()));\n                         }\n                         Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n                     }\n                     Err(ParserError::ParseError) => Err(ModuleResolutionError {\n                         module: mod_name.to_string(),\n-                        kind: ModuleResolutionErrorKind::ParseError { file: path },\n+                        kind: ModuleResolutionErrorKind::ParseError { file: file_path },\n                     }),\n                     Err(..) if outside_mods_empty => Err(ModuleResolutionError {\n                         module: mod_name.to_string(),\n-                        kind: ModuleResolutionErrorKind::NotFound { file: path },\n+                        kind: ModuleResolutionErrorKind::NotFound { file: file_path },\n                     }),\n                     Err(..) => {\n                         if should_insert {\n-                            mods_outside_ast.push((path, ownership, sub_mod.clone()));\n+                            mods_outside_ast.push((file_path, dir_ownership, sub_mod.clone()));\n                         }\n                         Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n                     }\n                 }\n             }\n-            Err(mut e) if !mods_outside_ast.is_empty() => {\n-                e.cancel();\n+            Err(mod_err) if !mods_outside_ast.is_empty() => {\n+                if let ModError::ParserError(mut e) = mod_err {\n+                    e.cancel();\n+                }\n                 Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))\n             }\n-            Err(mut e) => {\n-                e.cancel();\n-                Err(ModuleResolutionError {\n-                    module: mod_name.to_string(),\n-                    kind: ModuleResolutionErrorKind::NotFound {\n-                        file: self.directory.path.clone(),\n-                    },\n-                })\n-            }\n+            Err(_) => Err(ModuleResolutionError {\n+                module: mod_name.to_string(),\n+                kind: ModuleResolutionErrorKind::NotFound {\n+                    file: self.directory.path.clone(),\n+                },\n+            }),\n         }\n     }\n "}, {"sha": "0b94749f3c6f4a04721965e8d043a50885ed0f83", "filename": "src/syntux/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fparser.rs?ref=4c617e8fb32045e1d60940ba4c79942ef0301566", "patch": "@@ -14,8 +14,9 @@ use crate::attr::first_attr_value_str_by_name;\n use crate::syntux::session::ParseSess;\n use crate::Input;\n \n-pub(crate) type DirectoryOwnership = rustc_expand::module::DirectoryOwnership;\n+pub(crate) type DirectoryOwnership = rustc_expand::module::DirOwnership;\n pub(crate) type ModulePathSuccess = rustc_expand::module::ModulePathSuccess;\n+pub(crate) type ModError<'a> = rustc_expand::module::ModError<'a>;\n \n #[derive(Clone)]\n pub(crate) struct Directory {"}, {"sha": "374d08f7f233828f1ded701afe291d1e8e114102", "filename": "src/syntux/session.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c617e8fb32045e1d60940ba4c79942ef0301566/src%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fsession.rs?ref=4c617e8fb32045e1d60940ba4c79942ef0301566", "patch": "@@ -150,14 +150,8 @@ impl ParseSess {\n         id: symbol::Ident,\n         relative: Option<symbol::Ident>,\n         dir_path: &Path,\n-    ) -> rustc_expand::module::ModulePath<'_> {\n-        rustc_expand::module::default_submod_path(\n-            &self.parse_sess,\n-            id,\n-            rustc_span::DUMMY_SP,\n-            relative,\n-            dir_path,\n-        )\n+    ) -> Result<rustc_expand::module::ModulePathSuccess, rustc_expand::module::ModError<'_>> {\n+        rustc_expand::module::default_submod_path(&self.parse_sess, id, relative, dir_path)\n     }\n \n     pub(crate) fn is_file_parsed(&self, path: &Path) -> bool {"}]}