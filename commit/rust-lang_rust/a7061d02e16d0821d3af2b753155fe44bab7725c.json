{"sha": "a7061d02e16d0821d3af2b753155fe44bab7725c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MDYxZDAyZTE2ZDA4MjFkM2FmMmI3NTMxNTVmZTQ0YmFiNzcyNWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-10T15:37:56Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:52Z"}, "message": "Tweak the startup routine to pass on linux\n\nWe need to be sure to init thread_info before we init args for example because\nargs is grabbing locks which may entail looking at the local thread eventually.", "tree": {"sha": "79cb020fe5ff6d7c2d7f5be49c7e8e947e34e48e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79cb020fe5ff6d7c2d7f5be49c7e8e947e34e48e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7061d02e16d0821d3af2b753155fe44bab7725c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7061d02e16d0821d3af2b753155fe44bab7725c", "html_url": "https://github.com/rust-lang/rust/commit/a7061d02e16d0821d3af2b753155fe44bab7725c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7061d02e16d0821d3af2b753155fe44bab7725c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a6c54c46e6ac28d82f940f1d1bf8d0a5fd7e820", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6c54c46e6ac28d82f940f1d1bf8d0a5fd7e820", "html_url": "https://github.com/rust-lang/rust/commit/7a6c54c46e6ac28d82f940f1d1bf8d0a5fd7e820"}], "stats": {"total": 133, "additions": 65, "deletions": 68}, "files": [{"sha": "28e9338ddfedc5910ee7ed6f029168301fe03235", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a7061d02e16d0821d3af2b753155fe44bab7725c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7061d02e16d0821d3af2b753155fe44bab7725c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a7061d02e16d0821d3af2b753155fe44bab7725c", "patch": "@@ -48,7 +48,6 @@\n \n #![allow(dead_code)]\n \n-use failure;\n use os;\n use thunk::Thunk;\n use kinds::Send;\n@@ -73,52 +72,24 @@ mod macros;\n // These should be refactored/moved/made private over time\n pub mod util;\n pub mod unwind;\n+pub mod args;\n \n-mod args;\n mod at_exit_imp;\n mod libunwind;\n \n /// The default error code of the rust runtime if the main task panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: int = 101;\n \n-/// One-time runtime initialization.\n-///\n-/// Initializes global state, including frobbing\n-/// the crate's logging flags, registering GC\n-/// metadata, and storing the process arguments.\n-// FIXME: this should be unsafe\n-#[allow(experimental)]\n-pub fn init(argc: int, argv: *const *const u8) {\n-    unsafe {\n-        args::init(argc, argv);\n-        thread::init();\n-        unwind::register(failure::on_fail);\n-    }\n-}\n-\n #[cfg(any(windows, android))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n+const OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n #[cfg(all(unix, not(android)))]\n-static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n+const OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use mem;\n-    start(argc, argv, Thunk::new(move|| {\n-        let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n-        main();\n-    }))\n-}\n-\n-/// Executes the given procedure after initializing the runtime with the given\n-/// argc/argv.\n-///\n-/// This procedure is guaranteed to run on the thread calling this function, but\n-/// the stack bounds for this rust task will *not* be set. Care must be taken\n-/// for this function to not overflow its stack.\n-pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n \n@@ -131,40 +102,59 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     // frames above our current position.\n     let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n \n-    // By default, some platforms will send a *signal* when a EPIPE error would\n-    // otherwise be delivered. This runtime doesn't install a SIGPIPE handler,\n-    // causing it to kill the program, which isn't exactly what we want!\n-    //\n-    // Hence, we set SIGPIPE to ignore when the program starts up in order to\n-    // prevent this problem.\n-    #[cfg(windows)] fn ignore_sigpipe() {}\n-    #[cfg(unix)] fn ignore_sigpipe() {\n-        use libc;\n-        use libc::funcs::posix01::signal::signal;\n-        unsafe {\n-            assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+    let failed = unsafe {\n+        // First, make sure we don't trigger any __morestack overflow checks,\n+        // and next set up our stack to have a guard page and run through our\n+        // own fault handlers if we hit it.\n+        sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom,\n+                                                          my_stack_top);\n+        sys::thread::guard::init();\n+        sys::stack_overflow::init();\n+\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread: Thread = NewThread::new(Some(\"<main>\".into_string()));\n+        thread_info::set((my_stack_bottom, my_stack_top),\n+                         sys::thread::guard::main(),\n+                         thread);\n+\n+        // By default, some platforms will send a *signal* when a EPIPE error\n+        // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n+        // handler, causing it to kill the program, which isn't exactly what we\n+        // want!\n+        //\n+        // Hence, we set SIGPIPE to ignore when the program starts up in order\n+        // to prevent this problem.\n+        #[cfg(windows)] fn ignore_sigpipe() {}\n+        #[cfg(unix)] fn ignore_sigpipe() {\n+            use libc;\n+            use libc::funcs::posix01::signal::signal;\n+            unsafe {\n+                assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != -1);\n+            }\n         }\n-    }\n-    ignore_sigpipe();\n-\n-    init(argc, argv);\n-    let mut exit_code = None;\n-\n-    let thread: Thread = NewThread::new(Some(\"<main>\".into_string()));\n-    thread_info::set((my_stack_bottom, my_stack_top),\n-                     unsafe { sys::thread::guard::main() },\n-                     thread);\n-    let mut main_opt = Some(main); // option dance\n-    unsafe {\n-        let _ = unwind::try(|| {\n-            sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n-            (main_opt.take().unwrap()).invoke();\n-            exit_code = Some(os::get_exit_status());\n+        ignore_sigpipe();\n+\n+        // Store our args if necessary in a squirreled away location\n+        args::init(argc, argv);\n+\n+        // And finally, let's run some code!\n+        let res = unwind::try(|| {\n+            let main: fn() = mem::transmute(main);\n+            main();\n         });\n         cleanup();\n+        res.is_err()\n+    };\n+\n+    // If the exit code wasn't set, then the try block must have panicked.\n+    if failed {\n+        rt::DEFAULT_ERROR_CODE\n+    } else {\n+        os::get_exit_status()\n     }\n-    // If the exit code wasn't set, then the task block must have panicked.\n-    return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n }\n \n /// Enqueues a procedure to run when the runtime is cleaned up"}, {"sha": "1beab8be90965a3b4145d5ccafa05151442eb0c5", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7061d02e16d0821d3af2b753155fe44bab7725c/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7061d02e16d0821d3af2b753155fe44bab7725c/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=a7061d02e16d0821d3af2b753155fe44bab7725c", "patch": "@@ -59,18 +59,20 @@\n \n use core::prelude::*;\n \n-use boxed::Box;\n-use string::String;\n-use str::StrAllocating;\n-use vec::Vec;\n use any::Any;\n-use sync::atomic;\n+use boxed::Box;\n use cmp;\n+use failure;\n use fmt;\n use intrinsics;\n+use libc::c_void;\n use mem;\n use raw::Closure;\n-use libc::c_void;\n+use str::StrAllocating;\n+use string::String;\n+use sync::atomic;\n+use sync::{Once, ONCE_INIT};\n+use vec::Vec;\n \n use sys_common::thread_info;\n use rt::libunwind as uw;\n@@ -541,6 +543,11 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n+    // Make sure the default failure handler is registered before we look at the\n+    // callbacks.\n+    static INIT: Once = ONCE_INIT;\n+    INIT.doit(|| unsafe { register(failure::on_fail); });\n+\n     // First, invoke call the user-defined callbacks triggered on task panic.\n     //\n     // By the time that we see a callback has been registered (by reading"}]}