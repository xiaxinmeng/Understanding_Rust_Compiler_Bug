{"sha": "999ac5f7770bff68bd65f490990d32c3ec1faaa6", "node_id": "C_kwDOAAsO6NoAKDk5OWFjNWY3NzcwYmZmNjhiZDY1ZjQ5MDk5MGQzMmMzZWMxZmFhYTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T08:48:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T08:48:44Z"}, "message": "Auto merge of #108070 - Dylan-DPC:rollup-v6xw7vk, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #105300 (rework min_choice algorithm of member constraints)\n - #107163 (Remove some superfluous type parameters from layout.rs.)\n - #107173 (Suggest the correct array length on mismatch)\n - #107411 (Handle discriminant in DataflowConstProp)\n - #107968 (Enable `#[thread_local]` on armv6k-nintendo-3ds)\n - #108032 (Un\ud83d\udce6ing the Resolver)\n - #108060 (Revert to using `RtlGenRandom` as a fallback)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9f3f7f01502659dd05406a67fa62c70c3ef1b7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f3f7f01502659dd05406a67fa62c70c3ef1b7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/999ac5f7770bff68bd65f490990d32c3ec1faaa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/999ac5f7770bff68bd65f490990d32c3ec1faaa6", "html_url": "https://github.com/rust-lang/rust/commit/999ac5f7770bff68bd65f490990d32c3ec1faaa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/999ac5f7770bff68bd65f490990d32c3ec1faaa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "068161ea483b1a80a959476cb3e31e6619a72737", "url": "https://api.github.com/repos/rust-lang/rust/commits/068161ea483b1a80a959476cb3e31e6619a72737", "html_url": "https://github.com/rust-lang/rust/commit/068161ea483b1a80a959476cb3e31e6619a72737"}, {"sha": "ef6de70c77a9c38a48224608d4d596610d4b75d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6de70c77a9c38a48224608d4d596610d4b75d2", "html_url": "https://github.com/rust-lang/rust/commit/ef6de70c77a9c38a48224608d4d596610d4b75d2"}], "stats": {"total": 1648, "additions": 1092, "deletions": 556}, "files": [{"sha": "54858b52008f9b3d7a2848cf6f5cb8378a6be965", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,11 +1,5 @@\n use super::*;\n-use std::{\n-    borrow::Borrow,\n-    cmp,\n-    fmt::Debug,\n-    iter,\n-    ops::{Bound, Deref},\n-};\n+use std::{borrow::Borrow, cmp, iter, ops::Bound};\n \n #[cfg(feature = \"randomize\")]\n use rand::{seq::SliceRandom, SeedableRng};\n@@ -33,7 +27,7 @@ pub trait LayoutCalculator {\n     fn delay_bug(&self, txt: &str);\n     fn current_data_layout(&self) -> Self::TargetDataLayoutRef;\n \n-    fn scalar_pair<V: Idx>(&self, a: Scalar, b: Scalar) -> LayoutS<V> {\n+    fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         let b_align = b.align(dl);\n@@ -49,7 +43,7 @@ pub trait LayoutCalculator {\n             .max_by_key(|niche| niche.available(dl));\n \n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n@@ -61,13 +55,13 @@ pub trait LayoutCalculator {\n         }\n     }\n \n-    fn univariant<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn univariant(\n         &self,\n         dl: &TargetDataLayout,\n-        fields: &[F],\n+        fields: &[Layout<'_>],\n         repr: &ReprOptions,\n         kind: StructKind,\n-    ) -> Option<LayoutS<V>> {\n+    ) -> Option<LayoutS> {\n         let pack = repr.pack;\n         let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n@@ -76,17 +70,17 @@ pub trait LayoutCalculator {\n             let end =\n                 if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n             let optimizing = &mut inverse_memory_index[..end];\n-            let effective_field_align = |f: &F| {\n+            let effective_field_align = |layout: Layout<'_>| {\n                 if let Some(pack) = pack {\n                     // return the packed alignment in bytes\n-                    f.align.abi.min(pack).bytes()\n+                    layout.align().abi.min(pack).bytes()\n                 } else {\n                     // returns log2(effective-align).\n                     // This is ok since `pack` applies to all fields equally.\n                     // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n                     //\n                     // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n-                    f.align.abi.bytes().max(f.size.bytes()).trailing_zeros() as u64\n+                    layout.align().abi.bytes().max(layout.size().bytes()).trailing_zeros() as u64\n                 }\n             };\n \n@@ -111,9 +105,9 @@ pub trait LayoutCalculator {\n                             // Place ZSTs first to avoid \"interesting offsets\",\n                             // especially with only one or two non-ZST fields.\n                             // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = &fields[x as usize];\n-                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n-                            (!f.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n+                            let f = fields[x as usize];\n+                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                            (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n                         });\n                     }\n \n@@ -123,8 +117,8 @@ pub trait LayoutCalculator {\n                         // And put the largest niche in an alignment group at the end\n                         // so it can be used as discriminant in jagged enums\n                         optimizing.sort_by_key(|&x| {\n-                            let f = &fields[x as usize];\n-                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n+                            let f = fields[x as usize];\n+                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n                             (effective_field_align(f), niche_size)\n                         });\n                     }\n@@ -160,23 +154,23 @@ pub trait LayoutCalculator {\n                 ));\n             }\n \n-            if field.is_unsized() {\n+            if field.0.is_unsized() {\n                 sized = false;\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n             let field_align = if let Some(pack) = pack {\n-                field.align.min(AbiAndPrefAlign::new(pack))\n+                field.align().min(AbiAndPrefAlign::new(pack))\n             } else {\n-                field.align\n+                field.align()\n             };\n             offset = offset.align_to(field_align.abi);\n             align = align.max(field_align);\n \n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n-            if let Some(mut niche) = field.largest_niche {\n+            if let Some(mut niche) = field.largest_niche() {\n                 let available = niche.available(dl);\n                 if available > largest_niche_available {\n                     largest_niche_available = available;\n@@ -185,7 +179,7 @@ pub trait LayoutCalculator {\n                 }\n             }\n \n-            offset = offset.checked_add(field.size, dl)?;\n+            offset = offset.checked_add(field.size(), dl)?;\n         }\n         if let Some(repr_align) = repr.align {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n@@ -205,24 +199,26 @@ pub trait LayoutCalculator {\n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n             // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.0.is_zst());\n \n             match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n                 // We have exactly one non-ZST field.\n                 (Some((i, field)), None, None) => {\n                     // Field fills the struct and it has a scalar or scalar pair ABI.\n-                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    if offsets[i].bytes() == 0\n+                        && align.abi == field.align().abi\n+                        && size == field.size()\n                     {\n-                        match field.abi {\n+                        match field.abi() {\n                             // For plain scalars, or vectors of them, we can't unpack\n                             // newtypes for `#[repr(C)]`, as that affects C ABIs.\n                             Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                abi = field.abi;\n+                                abi = field.abi();\n                             }\n                             // But scalar pairs are Rust-specific and get\n                             // treated as aggregates by C ABIs anyway.\n                             Abi::ScalarPair(..) => {\n-                                abi = field.abi;\n+                                abi = field.abi();\n                             }\n                             _ => {}\n                         }\n@@ -231,15 +227,15 @@ pub trait LayoutCalculator {\n \n                 // Two non-ZST fields, and they're both scalars.\n                 (Some((i, a)), Some((j, b)), None) => {\n-                    match (a.abi, b.abi) {\n+                    match (a.abi(), b.abi()) {\n                         (Abi::Scalar(a), Abi::Scalar(b)) => {\n                             // Order by the memory placement, not source order.\n                             let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n                                 ((i, a), (j, b))\n                             } else {\n                                 ((j, b), (i, a))\n                             };\n-                            let pair = self.scalar_pair::<V>(a, b);\n+                            let pair = self.scalar_pair(a, b);\n                             let pair_offsets = match pair.fields {\n                                 FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                     assert_eq!(memory_index, &[0, 1]);\n@@ -264,11 +260,11 @@ pub trait LayoutCalculator {\n                 _ => {}\n             }\n         }\n-        if fields.iter().any(|f| f.abi.is_uninhabited()) {\n+        if fields.iter().any(|f| f.abi().is_uninhabited()) {\n             abi = Abi::Uninhabited;\n         }\n         Some(LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n@@ -277,11 +273,11 @@ pub trait LayoutCalculator {\n         })\n     }\n \n-    fn layout_of_never_type<V: Idx>(&self) -> LayoutS<V> {\n+    fn layout_of_never_type(&self) -> LayoutS {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Uninhabited,\n             largest_niche: None,\n@@ -290,18 +286,18 @@ pub trait LayoutCalculator {\n         }\n     }\n \n-    fn layout_of_struct_or_enum<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn layout_of_struct_or_enum(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<V, Vec<F>>,\n+        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n         is_enum: bool,\n         is_unsafe_cell: bool,\n         scalar_valid_range: (Bound<u128>, Bound<u128>),\n         discr_range_of_repr: impl Fn(i128, i128) -> (Integer, bool),\n-        discriminants: impl Iterator<Item = (V, i128)>,\n+        discriminants: impl Iterator<Item = (VariantIdx, i128)>,\n         niche_optimize_enum: bool,\n         always_sized: bool,\n-    ) -> Option<LayoutS<V>> {\n+    ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n \n@@ -316,9 +312,9 @@ pub trait LayoutCalculator {\n         // but *not* an encoding of the discriminant (e.g., a tag value).\n         // See issue #49298 for more details on the need to leave space\n         // for non-ZST uninhabited data (mostly partial initialization).\n-        let absent = |fields: &[F]| {\n-            let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n-            let is_zst = fields.iter().all(|f| f.is_zst());\n+        let absent = |fields: &[Layout<'_>]| {\n+            let uninhabited = fields.iter().any(|f| f.abi().is_uninhabited());\n+            let is_zst = fields.iter().all(|f| f.0.is_zst());\n             uninhabited && is_zst\n         };\n         let (present_first, present_second) = {\n@@ -335,7 +331,7 @@ pub trait LayoutCalculator {\n             }\n             // If it's a struct, still compute a layout so that we can still compute the\n             // field offsets.\n-            None => V::new(0),\n+            None => VariantIdx::new(0),\n         };\n \n         let is_struct = !is_enum ||\n@@ -439,12 +435,12 @@ pub trait LayoutCalculator {\n         // variant layouts, so we can't store them in the\n         // overall LayoutS. Store the overall LayoutS\n         // and the variant LayoutSs here until then.\n-        struct TmpLayout<V: Idx> {\n-            layout: LayoutS<V>,\n-            variants: IndexVec<V, LayoutS<V>>,\n+        struct TmpLayout {\n+            layout: LayoutS,\n+            variants: IndexVec<VariantIdx, LayoutS>,\n         }\n \n-        let calculate_niche_filling_layout = || -> Option<TmpLayout<V>> {\n+        let calculate_niche_filling_layout = || -> Option<TmpLayout> {\n             if niche_optimize_enum {\n                 return None;\n             }\n@@ -464,15 +460,16 @@ pub trait LayoutCalculator {\n \n                     Some(st)\n                 })\n-                .collect::<Option<IndexVec<V, _>>>()?;\n+                .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n \n             let largest_variant_index = variant_layouts\n                 .iter_enumerated()\n                 .max_by_key(|(_i, layout)| layout.size.bytes())\n                 .map(|(i, _layout)| i)?;\n \n-            let all_indices = (0..=variants.len() - 1).map(V::new);\n-            let needs_disc = |index: V| index != largest_variant_index && !absent(&variants[index]);\n+            let all_indices = (0..=variants.len() - 1).map(VariantIdx::new);\n+            let needs_disc =\n+                |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n             let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n                 ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap().index();\n \n@@ -482,7 +479,7 @@ pub trait LayoutCalculator {\n             let (field_index, niche, (niche_start, niche_scalar)) = variants[largest_variant_index]\n                 .iter()\n                 .enumerate()\n-                .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n+                .filter_map(|(j, field)| Some((j, field.largest_niche()?)))\n                 .max_by_key(|(_, niche)| niche.available(dl))\n                 .and_then(|(j, niche)| Some((j, niche, niche.reserve(dl, count)?)))?;\n             let niche_offset =\n@@ -514,7 +511,7 @@ pub trait LayoutCalculator {\n                 match layout.fields {\n                     FieldsShape::Arbitrary { ref mut offsets, .. } => {\n                         for (j, offset) in offsets.iter_mut().enumerate() {\n-                            if !variants[i][j].is_zst() {\n+                            if !variants[i][j].0.is_zst() {\n                                 *offset += this_offset;\n                             }\n                         }\n@@ -572,8 +569,8 @@ pub trait LayoutCalculator {\n                     tag: niche_scalar,\n                     tag_encoding: TagEncoding::Niche {\n                         untagged_variant: largest_variant_index,\n-                        niche_variants: (V::new(*niche_variants.start())\n-                            ..=V::new(*niche_variants.end())),\n+                        niche_variants: (VariantIdx::new(*niche_variants.start())\n+                            ..=VariantIdx::new(*niche_variants.end())),\n                         niche_start,\n                     },\n                     tag_field: 0,\n@@ -598,7 +595,7 @@ pub trait LayoutCalculator {\n         let discr_type = repr.discr_type();\n         let bits = Integer::from_attr(dl, discr_type).size().bits();\n         for (i, mut val) in discriminants {\n-            if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+            if variants[i].iter().any(|f| f.abi().is_uninhabited()) {\n                 continue;\n             }\n             if discr_type.is_signed() {\n@@ -636,7 +633,7 @@ pub trait LayoutCalculator {\n         if repr.c() {\n             for fields in variants {\n                 for field in fields {\n-                    prefix_align = prefix_align.max(field.align.abi);\n+                    prefix_align = prefix_align.max(field.align().abi);\n                 }\n             }\n         }\n@@ -655,16 +652,16 @@ pub trait LayoutCalculator {\n                 // Find the first field we can't move later\n                 // to make room for a larger discriminant.\n                 for field in st.fields.index_by_increasing_offset().map(|j| &field_layouts[j]) {\n-                    if !field.is_zst() || field.align.abi.bytes() != 1 {\n-                        start_align = start_align.min(field.align.abi);\n+                    if !field.0.is_zst() || field.align().abi.bytes() != 1 {\n+                        start_align = start_align.min(field.align().abi);\n                         break;\n                     }\n                 }\n                 size = cmp::max(size, st.size);\n                 align = align.max(st.align);\n                 Some(st)\n             })\n-            .collect::<Option<IndexVec<V, _>>>()?;\n+            .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n \n         // Align the maximum variant size to the largest alignment.\n         size = size.align_to(align.abi);\n@@ -759,7 +756,7 @@ pub trait LayoutCalculator {\n                 let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                     panic!();\n                 };\n-                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n+                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.0.is_zst());\n                 let (field, offset) = match (fields.next(), fields.next()) {\n                     (None, None) => {\n                         common_prim_initialized_in_all_variants = false;\n@@ -771,7 +768,7 @@ pub trait LayoutCalculator {\n                         break;\n                     }\n                 };\n-                let prim = match field.abi {\n+                let prim = match field.abi() {\n                     Abi::Scalar(scalar) => {\n                         common_prim_initialized_in_all_variants &=\n                             matches!(scalar, Scalar::Initialized { .. });\n@@ -802,7 +799,7 @@ pub trait LayoutCalculator {\n                     // Common prim might be uninit.\n                     Scalar::Union { value: prim }\n                 };\n-                let pair = self.scalar_pair::<V>(tag, prim_scalar);\n+                let pair = self.scalar_pair(tag, prim_scalar);\n                 let pair_offsets = match pair.fields {\n                     FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                         assert_eq!(memory_index, &[0, 1]);\n@@ -862,9 +859,8 @@ pub trait LayoutCalculator {\n                 // pick the layout with the larger niche; otherwise,\n                 // pick tagged as it has simpler codegen.\n                 use cmp::Ordering::*;\n-                let niche_size = |tmp_l: &TmpLayout<V>| {\n-                    tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n-                };\n+                let niche_size =\n+                    |tmp_l: &TmpLayout| tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl));\n                 match (tl.layout.size.cmp(&nl.layout.size), niche_size(&tl).cmp(&niche_size(&nl))) {\n                     (Greater, _) => nl,\n                     (Equal, Less) => nl,\n@@ -884,11 +880,11 @@ pub trait LayoutCalculator {\n         Some(best_layout.layout)\n     }\n \n-    fn layout_of_union<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+    fn layout_of_union(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<V, Vec<F>>,\n-    ) -> Option<LayoutS<V>> {\n+        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n+    ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         let mut align = if repr.pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n@@ -900,15 +896,15 @@ pub trait LayoutCalculator {\n         let optimize = !repr.inhibit_union_abi_opt();\n         let mut size = Size::ZERO;\n         let mut abi = Abi::Aggregate { sized: true };\n-        let index = V::new(0);\n+        let index = VariantIdx::new(0);\n         for field in &variants[index] {\n-            assert!(field.is_sized());\n-            align = align.max(field.align);\n+            assert!(field.0.is_sized());\n+            align = align.max(field.align());\n \n             // If all non-ZST fields have the same ABI, forward this ABI\n-            if optimize && !field.is_zst() {\n+            if optimize && !field.0.is_zst() {\n                 // Discard valid range information and allow undef\n-                let field_abi = match field.abi {\n+                let field_abi = match field.abi() {\n                     Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n                     Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n                     Abi::Vector { element: x, count } => {\n@@ -926,7 +922,7 @@ pub trait LayoutCalculator {\n                 }\n             }\n \n-            size = cmp::max(size, field.size);\n+            size = cmp::max(size, field.size());\n         }\n \n         if let Some(pack) = repr.pack {"}, {"sha": "c88a60c62b9df7de4913c4787358b751eeaf7755", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -8,6 +8,7 @@ use std::ops::{Add, AddAssign, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n use bitflags::bitflags;\n+use rustc_data_structures::intern::Interned;\n #[cfg(feature = \"nightly\")]\n use rustc_data_structures::stable_hasher::StableOrd;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -1250,9 +1251,9 @@ impl Abi {\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub enum Variants<V: Idx> {\n+pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n-    Single { index: V },\n+    Single { index: VariantIdx },\n \n     /// Enum-likes with more than one inhabited variant: each variant comes with\n     /// a *discriminant* (usually the same as the variant index but the user can\n@@ -1262,15 +1263,15 @@ pub enum Variants<V: Idx> {\n     /// For enums, the tag is the sole field of the layout.\n     Multiple {\n         tag: Scalar,\n-        tag_encoding: TagEncoding<V>,\n+        tag_encoding: TagEncoding,\n         tag_field: usize,\n-        variants: IndexVec<V, LayoutS<V>>,\n+        variants: IndexVec<VariantIdx, LayoutS>,\n     },\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub enum TagEncoding<V: Idx> {\n+pub enum TagEncoding {\n     /// The tag directly stores the discriminant, but possibly with a smaller layout\n     /// (so converting the tag to the discriminant can require sign extension).\n     Direct,\n@@ -1285,7 +1286,11 @@ pub enum TagEncoding<V: Idx> {\n     /// For example, `Option<(usize, &T)>`  is represented such that\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n-    Niche { untagged_variant: V, niche_variants: RangeInclusive<V>, niche_start: u128 },\n+    Niche {\n+        untagged_variant: VariantIdx,\n+        niche_variants: RangeInclusive<VariantIdx>,\n+        niche_start: u128,\n+    },\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -1372,9 +1377,14 @@ impl Niche {\n     }\n }\n \n+rustc_index::newtype_index! {\n+    #[derive(HashStable_Generic)]\n+    pub struct VariantIdx {}\n+}\n+\n #[derive(PartialEq, Eq, Hash, Clone)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n-pub struct LayoutS<V: Idx> {\n+pub struct LayoutS {\n     /// Says where the fields are located within the layout.\n     pub fields: FieldsShape,\n \n@@ -1385,7 +1395,7 @@ pub struct LayoutS<V: Idx> {\n     ///\n     /// To access all fields of this layout, both `fields` and the fields of the active variant\n     /// must be taken into account.\n-    pub variants: Variants<V>,\n+    pub variants: Variants,\n \n     /// The `abi` defines how this data is passed between functions, and it defines\n     /// value restrictions via `valid_range`.\n@@ -1404,13 +1414,13 @@ pub struct LayoutS<V: Idx> {\n     pub size: Size,\n }\n \n-impl<V: Idx> LayoutS<V> {\n+impl LayoutS {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n         let size = scalar.size(cx);\n         let align = scalar.align(cx);\n         LayoutS {\n-            variants: Variants::Single { index: V::new(0) },\n+            variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n@@ -1420,7 +1430,7 @@ impl<V: Idx> LayoutS<V> {\n     }\n }\n \n-impl<V: Idx> fmt::Debug for LayoutS<V> {\n+impl fmt::Debug for LayoutS {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // This is how `Layout` used to print before it become\n         // `Interned<LayoutS>`. We print it like this to avoid having to update\n@@ -1437,6 +1447,43 @@ impl<V: Idx> fmt::Debug for LayoutS<V> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n+#[rustc_pass_by_value]\n+pub struct Layout<'a>(pub Interned<'a, LayoutS>);\n+\n+impl<'a> fmt::Debug for Layout<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // See comment on `<LayoutS as Debug>::fmt` above.\n+        self.0.0.fmt(f)\n+    }\n+}\n+\n+impl<'a> Layout<'a> {\n+    pub fn fields(self) -> &'a FieldsShape {\n+        &self.0.0.fields\n+    }\n+\n+    pub fn variants(self) -> &'a Variants {\n+        &self.0.0.variants\n+    }\n+\n+    pub fn abi(self) -> Abi {\n+        self.0.0.abi\n+    }\n+\n+    pub fn largest_niche(self) -> Option<Niche> {\n+        self.0.0.largest_niche\n+    }\n+\n+    pub fn align(self) -> AbiAndPrefAlign {\n+        self.0.0.align\n+    }\n+\n+    pub fn size(self) -> Size {\n+        self.0.0.size\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n     /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n@@ -1464,7 +1511,7 @@ pub enum InitKind {\n     UninitMitigated0x01Fill,\n }\n \n-impl<V: Idx> LayoutS<V> {\n+impl LayoutS {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         self.abi.is_unsized()"}, {"sha": "f2693bded590bb73505e9eb4ccc7a45e5860109c", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -746,20 +746,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n         debug!(?choice_regions, \"after ub\");\n \n-        // If we ruled everything out, we're done.\n-        if choice_regions.is_empty() {\n-            return false;\n-        }\n-\n-        // Otherwise, we need to find the minimum remaining choice, if\n-        // any, and take that.\n-        debug!(\"choice_regions remaining are {:#?}\", choice_regions);\n-        let Some(&min_choice) = choice_regions.iter().find(|&r1| {\n+        // At this point we can pick any member of `choice_regions`, but to avoid potential\n+        // non-determinism we will pick the *unique minimum* choice.\n+        //\n+        // Because universal regions are only partially ordered (i.e, not every two regions are\n+        // comparable), we will ignore any region that doesn't compare to all others when picking\n+        // the minimum choice.\n+        // For example, consider `choice_regions = ['static, 'a, 'b, 'c, 'd, 'e]`, where\n+        // `'static: 'a, 'static: 'b, 'a: 'c, 'b: 'c, 'c: 'd, 'c: 'e`.\n+        // `['d, 'e]` are ignored because they do not compare - the same goes for `['a, 'b]`.\n+        let totally_ordered_subset = choice_regions.iter().copied().filter(|&r1| {\n             choice_regions.iter().all(|&r2| {\n-                self.universal_region_relations.outlives(r2, *r1)\n+                self.universal_region_relations.outlives(r1, r2)\n+                    || self.universal_region_relations.outlives(r2, r1)\n             })\n+        });\n+        // Now we're left with `['static, 'c]`. Pick `'c` as the minimum!\n+        let Some(min_choice) = totally_ordered_subset.reduce(|r1, r2| {\n+            let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n+            let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n+            match (r1_outlives_r2, r2_outlives_r1) {\n+                (true, true) => r1.min(r2),\n+                (true, false) => r2,\n+                (false, true) => r1,\n+                (false, false) => bug!(\"incomparable regions in total order\"),\n+            }\n         }) else {\n-            debug!(\"no choice region outlived by all others\");\n+            debug!(\"no unique minimum choice\");\n             return false;\n         };\n "}, {"sha": "1d3fcf7571ebc83ca542c940c4250215be652739", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -64,6 +64,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n@@ -1985,6 +1986,70 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n                             self.suggest_let_for_letchains(&mut err, &trace.cause, span);\n                         }\n+                        (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n+                            let hir = self.tcx.hir();\n+                            let TypeError::FixedArraySize(sz) = terr else {\n+                                break 'block;\n+                            };\n+                            let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n+                                Some(hir::Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Fn(_, _, body_id),\n+                                    ..\n+                                })) => {\n+                                    let body = hir.body(*body_id);\n+                                    struct LetVisitor<'v> {\n+                                        span: Span,\n+                                        result: Option<&'v hir::Ty<'v>>,\n+                                    }\n+                                    impl<'v> Visitor<'v> for LetVisitor<'v> {\n+                                        fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n+                                            if self.result.is_some() {\n+                                                return;\n+                                            }\n+                                            // Find a local statement where the initializer has\n+                                            // the same span as the error and the type is specified.\n+                                            if let hir::Stmt {\n+                                                kind: hir::StmtKind::Local(hir::Local {\n+                                                    init: Some(hir::Expr {\n+                                                        span: init_span,\n+                                                        ..\n+                                                    }),\n+                                                    ty: Some(array_ty),\n+                                                    ..\n+                                                }),\n+                                                ..\n+                                            } = s\n+                                            && init_span == &self.span {\n+                                                self.result = Some(*array_ty);\n+                                            }\n+                                        }\n+                                    }\n+                                    let mut visitor = LetVisitor {span, result: None};\n+                                    visitor.visit_body(body);\n+                                    visitor.result.map(|r| &r.peel_refs().kind)\n+                                }\n+                                Some(hir::Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Const(ty, _),\n+                                    ..\n+                                })) => {\n+                                    Some(&ty.peel_refs().kind)\n+                                }\n+                                _ => None\n+                            };\n+\n+                            if let Some(tykind) = tykind\n+                                && let hir::TyKind::Array(_, length) = tykind\n+                                && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+                                && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"consider specifying the actual array length\",\n+                                    sz.found,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n                         _ => {}\n                     }\n                 }"}, {"sha": "d504aea77d0dac6ae8d51c7a0a73806c163815e4", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,4 +1,3 @@\n-pub use crate::passes::BoxedResolver;\n use crate::util;\n \n use rustc_ast::token;"}, {"sha": "6a94d19001e11d68b6ef718672bec3f9a9b4e281", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -23,9 +23,9 @@ use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str, validate_a\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n-use rustc_resolve::{Resolver, ResolverArenas};\n+use rustc_resolve::Resolver;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn, Untracked};\n+use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, Untracked};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -37,9 +37,7 @@ use rustc_trait_selection::traits;\n use std::any::Any;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n-use std::marker::PhantomPinned;\n use std::path::{Path, PathBuf};\n-use std::pin::Pin;\n use std::sync::{Arc, LazyLock};\n use std::{env, fs, iter};\n \n@@ -73,84 +71,6 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-pub use boxed_resolver::BoxedResolver;\n-mod boxed_resolver {\n-    use super::*;\n-\n-    pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n-\n-    struct BoxedResolverInner {\n-        session: Lrc<Session>,\n-        resolver_arenas: Option<ResolverArenas<'static>>,\n-        resolver: Option<Resolver<'static>>,\n-        _pin: PhantomPinned,\n-    }\n-\n-    // Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n-    // then resolver_arenas and session.\n-    impl Drop for BoxedResolverInner {\n-        fn drop(&mut self) {\n-            self.resolver.take();\n-            self.resolver_arenas.take();\n-        }\n-    }\n-\n-    impl BoxedResolver {\n-        pub(super) fn new(\n-            session: Lrc<Session>,\n-            make_resolver: impl for<'a> FnOnce(&'a Session, &'a ResolverArenas<'a>) -> Resolver<'a>,\n-        ) -> BoxedResolver {\n-            let mut boxed_resolver = Box::new(BoxedResolverInner {\n-                session,\n-                resolver_arenas: Some(Resolver::arenas()),\n-                resolver: None,\n-                _pin: PhantomPinned,\n-            });\n-            // SAFETY: `make_resolver` takes a resolver arena with an arbitrary lifetime and\n-            // returns a resolver with the same lifetime as the arena. We ensure that the arena\n-            // outlives the resolver in the drop impl and elsewhere so these transmutes are sound.\n-            unsafe {\n-                let resolver = make_resolver(\n-                    std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n-                    std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n-                        boxed_resolver.resolver_arenas.as_ref().unwrap(),\n-                    ),\n-                );\n-                boxed_resolver.resolver = Some(resolver);\n-                BoxedResolver(Pin::new_unchecked(boxed_resolver))\n-            }\n-        }\n-\n-        pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n-            // SAFETY: The resolver doesn't need to be pinned.\n-            let mut resolver = unsafe {\n-                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n-            };\n-            f((&mut *resolver).as_mut().unwrap())\n-        }\n-\n-        pub fn into_outputs(mut self) -> ty::ResolverOutputs {\n-            // SAFETY: The resolver doesn't need to be pinned.\n-            let mut resolver = unsafe {\n-                self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n-            };\n-            resolver.take().unwrap().into_outputs()\n-        }\n-    }\n-}\n-\n-pub fn create_resolver(\n-    sess: Lrc<Session>,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n-    krate: &ast::Crate,\n-    crate_name: Symbol,\n-) -> BoxedResolver {\n-    trace!(\"create_resolver\");\n-    BoxedResolver::new(sess, move |sess, resolver_arenas| {\n-        Resolver::new(sess, krate, crate_name, metadata_loader, resolver_arenas)\n-    })\n-}\n-\n pub fn register_plugins<'a>(\n     sess: &'a Session,\n     metadata_loader: &'a dyn MetadataLoader,\n@@ -256,7 +176,7 @@ pub fn configure_and_expand(\n     lint_store: &LintStore,\n     mut krate: ast::Crate,\n     crate_name: Symbol,\n-    resolver: &mut Resolver<'_>,\n+    resolver: &mut Resolver<'_, '_>,\n ) -> Result<ast::Crate> {\n     trace!(\"configure_and_expand\");\n     pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);"}, {"sha": "d727efdafc278a5534a07da127a4376f731bdbb6", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,6 +1,6 @@\n use crate::errors::{FailedWritingFile, RustcErrorFatal, RustcErrorUnexpectedAnnotation};\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver};\n+use crate::passes;\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n@@ -15,6 +15,7 @@ use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::{self, GlobalCtxt, TyCtxt};\n use rustc_query_impl::Queries as TcxQueries;\n+use rustc_resolve::Resolver;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n@@ -87,7 +88,6 @@ pub struct Queries<'tcx> {\n     parse: Query<ast::Crate>,\n     crate_name: Query<Symbol>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n-    expansion: Query<(Lrc<ast::Crate>, BoxedResolver, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n     // This just points to what's in `gcx_cell`.\n     gcx: Query<&'tcx GlobalCtxt<'tcx>>,\n@@ -106,7 +106,6 @@ impl<'tcx> Queries<'tcx> {\n             parse: Default::default(),\n             crate_name: Default::default(),\n             register_plugins: Default::default(),\n-            expansion: Default::default(),\n             dep_graph: Default::default(),\n             gcx: Default::default(),\n             ongoing_codegen: Default::default(),\n@@ -168,28 +167,6 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn expansion(\n-        &self,\n-    ) -> Result<QueryResult<'_, (Lrc<ast::Crate>, BoxedResolver, Lrc<LintStore>)>> {\n-        trace!(\"expansion\");\n-        self.expansion.compute(|| {\n-            let crate_name = *self.crate_name()?.borrow();\n-            let (krate, lint_store) = self.register_plugins()?.steal();\n-            let _timer = self.session().timer(\"configure_and_expand\");\n-            let sess = self.session();\n-            let mut resolver = passes::create_resolver(\n-                sess.clone(),\n-                self.codegen_backend().metadata_loader(),\n-                &krate,\n-                crate_name,\n-            );\n-            let krate = resolver.access(|resolver| {\n-                passes::configure_and_expand(sess, &lint_store, krate, crate_name, resolver)\n-            })?;\n-            Ok((Lrc::new(krate), resolver, lint_store))\n-        })\n-    }\n-\n     fn dep_graph(&self) -> Result<QueryResult<'_, DepGraph>> {\n         self.dep_graph.compute(|| {\n             let sess = self.session();\n@@ -209,13 +186,34 @@ impl<'tcx> Queries<'tcx> {\n     pub fn global_ctxt(&'tcx self) -> Result<QueryResult<'_, &'tcx GlobalCtxt<'tcx>>> {\n         self.gcx.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n-            let (krate, resolver, lint_store) = self.expansion()?.steal();\n+            let (krate, lint_store) = self.register_plugins()?.steal();\n+            let (krate, resolver_outputs) = {\n+                let _timer = self.session().timer(\"configure_and_expand\");\n+                let sess = self.session();\n+\n+                let arenas = Resolver::arenas();\n+                let mut resolver = Resolver::new(\n+                    sess,\n+                    &krate,\n+                    crate_name,\n+                    self.codegen_backend().metadata_loader(),\n+                    &arenas,\n+                );\n+                let krate = passes::configure_and_expand(\n+                    sess,\n+                    &lint_store,\n+                    krate,\n+                    crate_name,\n+                    &mut resolver,\n+                )?;\n+                (Lrc::new(krate), resolver.into_outputs())\n+            };\n \n             let ty::ResolverOutputs {\n                 untracked,\n                 global_ctxt: untracked_resolutions,\n                 ast_lowering: untracked_resolver_for_lowering,\n-            } = resolver.into_outputs();\n+            } = resolver_outputs;\n \n             let gcx = passes::create_global_ctxt(\n                 self.compiler,"}, {"sha": "38a559d892a35a0c3b7f12863169ce80fc646d78", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -8,7 +8,7 @@\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n-            [] layout: rustc_target::abi::LayoutS<rustc_target::abi::VariantIdx>,\n+            [] layout: rustc_target::abi::LayoutS,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n             [decode] adt_def: rustc_middle::ty::AdtDefData,"}, {"sha": "6996d91a80dcc428bb38f38f522af2cf2b20b435", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1642,6 +1642,14 @@ impl<'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if this `Place` contains a `Deref` projection.\n+    ///\n+    /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n+    /// same region of memory as its base.\n+    pub fn is_indirect(&self) -> bool {\n+        self.projection.iter().any(|elem| elem.is_indirect())\n+    }\n+\n     /// If MirPhase >= Derefered and if projection contains Deref,\n     /// It's guaranteed to be in the first place\n     pub fn has_deref(&self) -> bool {"}, {"sha": "4aef071cd98274ca90b1c0e38a7315981c7333ee", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -149,7 +149,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, ConstData<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n-    layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n+    layout: InternedSet<'tcx, LayoutS>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n     external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n }\n@@ -1520,7 +1520,7 @@ direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const_internal(ConstData<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n-    layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n+    layout: intern_layout(LayoutS): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n     external_constraints: intern_external_constraints(ExternalConstraintsData<'tcx>): ExternalConstraints -> ExternalConstraints<'tcx>,\n }"}, {"sha": "6f4e7fd4682c171f15512954fa9ff773fe63812a", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -121,7 +121,9 @@ where\n                 // for now. See discussion on [#61069].\n                 //\n                 // [#61069]: https://github.com/rust-lang/rust/pull/61069\n-                self.trans.gen(dropped_place.local);\n+                if !dropped_place.is_indirect() {\n+                    self.trans.gen(dropped_place.local);\n+                }\n             }\n \n             TerminatorKind::Abort"}, {"sha": "3e382f500afbe0bc27a2e63ef313afda907b3ca7", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,6 +1,7 @@\n #![feature(associated_type_defaults)]\n #![feature(box_patterns)]\n #![feature(exact_size_is_empty)]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "401db890a9810d1f811d63390c9f082f8beb57a9", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 214, "deletions": 61, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -24,7 +24,7 @@\n //! - The bottom state denotes uninitialized memory. Because we are only doing a sound approximation\n //! of the actual execution, we can also use this state for places where access would be UB.\n //!\n-//! - The assignment logic in `State::assign_place_idx` assumes that the places are non-overlapping,\n+//! - The assignment logic in `State::insert_place_idx` assumes that the places are non-overlapping,\n //! or identical. Note that this refers to place expressions, not memory locations.\n //!\n //! - Currently, places that have their reference taken cannot be tracked. Although this would be\n@@ -35,6 +35,7 @@\n use std::fmt::{Debug, Formatter};\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -64,10 +65,8 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Assign(box (place, rvalue)) => {\n                 self.handle_assign(*place, rvalue, state);\n             }\n-            StatementKind::SetDiscriminant { .. } => {\n-                // Could treat this as writing a constant to a pseudo-place.\n-                // But discriminants are currently not tracked, so we do nothing.\n-                // Related: https://github.com/rust-lang/unsafe-code-guidelines/issues/84\n+            StatementKind::SetDiscriminant { box ref place, .. } => {\n+                state.flood_discr(place.as_ref(), self.map());\n             }\n             StatementKind::Intrinsic(box intrinsic) => {\n                 self.handle_intrinsic(intrinsic, state);\n@@ -446,77 +445,93 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     }\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n-        if let Some(root) = map.find(place) {\n-            self.flood_idx_with(root, map, value);\n-        }\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        map.for_each_aliasing_place(place, None, &mut |place| {\n+            if let Some(vi) = map.places[place].value_index {\n+                values[vi] = value.clone();\n+            }\n+        });\n     }\n \n     pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n         self.flood_with(place, map, V::top())\n     }\n \n-    pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+    pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.preorder_invoke(place, &mut |place| {\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n             if let Some(vi) = map.places[place].value_index {\n                 values[vi] = value.clone();\n             }\n         });\n     }\n \n-    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map) {\n-        self.flood_idx_with(place, map, V::top())\n+    pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map) {\n+        self.flood_discr_with(place, map, V::top())\n+    }\n+\n+    /// Low-level method that assigns to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+        match result {\n+            ValueOrPlace::Value(value) => self.insert_value_idx(target, value, map),\n+            ValueOrPlace::Place(source) => self.insert_place_idx(target, source, map),\n+        }\n+    }\n+\n+    /// Low-level method that assigns a value to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_value_idx(&mut self, target: PlaceIndex, value: V, map: &Map) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        if let Some(value_index) = map.places[target].value_index {\n+            values[value_index] = value;\n+        }\n     }\n \n     /// Copies `source` to `target`, including all tracked places beneath.\n     ///\n     /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n     /// Top. Also, because this will copy all entries one after another, it may only be used for\n     /// places that are non-overlapping or identical.\n-    pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    fn insert_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n \n-        // If both places are tracked, we copy the value to the target. If the target is tracked,\n-        // but the source is not, we have to invalidate the value in target. If the target is not\n-        // tracked, then we don't have to do anything.\n+        // If both places are tracked, we copy the value to the target.\n+        // If the target is tracked, but the source is not, we do nothing, as invalidation has\n+        // already been performed.\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n                 values[target_value] = values[source_value].clone();\n-            } else {\n-                values[target_value] = V::top();\n             }\n         }\n         for target_child in map.children(target) {\n             // Try to find corresponding child and recurse. Reasoning is similar as above.\n             let projection = map.places[target_child].proj_elem.unwrap();\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n-                self.assign_place_idx(target_child, *source_child, map);\n-            } else {\n-                self.flood_idx(target_child, map);\n+                self.insert_place_idx(target_child, *source_child, map);\n             }\n         }\n     }\n \n+    /// Helper method to interpret `target = result`.\n     pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood(target, map);\n         if let Some(target) = map.find(target) {\n-            self.assign_idx(target, result, map);\n-        } else {\n-            // We don't track this place nor any projections, assignment can be ignored.\n+            self.insert_idx(target, result, map);\n         }\n     }\n \n-    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n-        match result {\n-            ValueOrPlace::Value(value) => {\n-                // First flood the target place in case we also track any projections (although\n-                // this scenario is currently not well-supported by the API).\n-                self.flood_idx(target, map);\n-                let StateData::Reachable(values) = &mut self.0 else { return };\n-                if let Some(value_index) = map.places[target].value_index {\n-                    values[value_index] = value;\n-                }\n-            }\n-            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n+    /// Helper method for assignments to a discriminant.\n+    pub fn assign_discr(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood_discr(target, map);\n+        if let Some(target) = map.find_discr(target) {\n+            self.insert_idx(target, result, map);\n         }\n     }\n \n@@ -525,6 +540,14 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n         map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n     }\n \n+    /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n+    pub fn get_discr(&self, place: PlaceRef<'_>, map: &Map) -> V {\n+        match map.find_discr(place) {\n+            Some(place) => self.get_idx(place, map),\n+            None => V::top(),\n+        }\n+    }\n+\n     /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n@@ -581,15 +604,15 @@ impl Map {\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n     /// chosen is an implementation detail and may not be relied upon (other than that their type\n     /// passes the filter).\n-    #[instrument(skip_all, level = \"debug\")]\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         filter: impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n         let exclude = excluded_locals(body);\n-        map.register_with_filter(tcx, body, filter, &exclude);\n+        map.register_with_filter(tcx, body, filter, exclude, place_limit);\n         debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n@@ -600,48 +623,85 @@ impl Map {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n-        exclude: &IndexVec<Local, bool>,\n+        exclude: BitSet<Local>,\n+        place_limit: Option<usize>,\n     ) {\n         // We use this vector as stack, pushing and popping projections.\n         let mut projection = Vec::new();\n         for (local, decl) in body.local_decls.iter_enumerated() {\n-            if !exclude[local] {\n-                self.register_with_filter_rec(tcx, local, &mut projection, decl.ty, &mut filter);\n+            if !exclude.contains(local) {\n+                self.register_with_filter_rec(\n+                    tcx,\n+                    local,\n+                    &mut projection,\n+                    decl.ty,\n+                    &mut filter,\n+                    place_limit,\n+                );\n             }\n         }\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n-    /// Invariant: The projection must only contain fields.\n+    /// Invariant: The projection must only contain trackable elements.\n     fn register_with_filter_rec<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         local: Local,\n         projection: &mut Vec<PlaceElem<'tcx>>,\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) {\n-        // Note: The framework supports only scalars for now.\n-        if filter(ty) && ty.is_scalar() {\n-            // We know that the projection only contains trackable elements.\n-            let place = self.make_place(local, projection).unwrap();\n+        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n+            return\n+        }\n+\n+        // We know that the projection only contains trackable elements.\n+        let place = self.make_place(local, projection).unwrap();\n \n-            // Allocate a value slot if it doesn't have one.\n-            if self.places[place].value_index.is_none() {\n-                self.places[place].value_index = Some(self.value_count.into());\n-                self.value_count += 1;\n+        // Allocate a value slot if it doesn't have one, and the user requested one.\n+        if self.places[place].value_index.is_none() && filter(ty) {\n+            self.places[place].value_index = Some(self.value_count.into());\n+            self.value_count += 1;\n+        }\n+\n+        if ty.is_enum() {\n+            let discr_ty = ty.discriminant_ty(tcx);\n+            if filter(discr_ty) {\n+                let discr = *self\n+                    .projections\n+                    .entry((place, TrackElem::Discriminant))\n+                    .or_insert_with(|| {\n+                        // Prepend new child to the linked list.\n+                        let next = self.places.push(PlaceInfo::new(Some(TrackElem::Discriminant)));\n+                        self.places[next].next_sibling = self.places[place].first_child;\n+                        self.places[place].first_child = Some(next);\n+                        next\n+                    });\n+\n+                // Allocate a value slot if it doesn't have one.\n+                if self.places[discr].value_index.is_none() {\n+                    self.places[discr].value_index = Some(self.value_count.into());\n+                    self.value_count += 1;\n+                }\n             }\n         }\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, |variant, field, ty| {\n-            if variant.is_some() {\n-                // Downcasts are currently not supported.\n+            if let Some(variant) = variant {\n+                projection.push(PlaceElem::Downcast(None, variant));\n+                let _ = self.make_place(local, projection);\n+                projection.push(PlaceElem::Field(field, ty));\n+                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n+                projection.pop();\n+                projection.pop();\n                 return;\n             }\n             projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n             projection.pop();\n         });\n     }\n@@ -684,23 +744,105 @@ impl Map {\n     }\n \n     /// Locates the given place, if it exists in the tree.\n-    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+    pub fn find_extra(\n+        &self,\n+        place: PlaceRef<'_>,\n+        extra: impl IntoIterator<Item = TrackElem>,\n+    ) -> Option<PlaceIndex> {\n         let mut index = *self.locals.get(place.local)?.as_ref()?;\n \n         for &elem in place.projection {\n             index = self.apply(index, elem.try_into().ok()?)?;\n         }\n+        for elem in extra {\n+            index = self.apply(index, elem)?;\n+        }\n \n         Some(index)\n     }\n \n+    /// Locates the given place, if it exists in the tree.\n+    pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        self.find_extra(place, [])\n+    }\n+\n+    /// Locates the given place and applies `Discriminant`, if it exists in the tree.\n+    pub fn find_discr(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        self.find_extra(place, [TrackElem::Discriminant])\n+    }\n+\n     /// Iterate over all direct children.\n     pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n         Children::new(self, parent)\n     }\n \n+    /// Invoke a function on the given place and all places that may alias it.\n+    ///\n+    /// In particular, when the given place has a variant downcast, we invoke the function on all\n+    /// the other variants.\n+    ///\n+    /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n+    /// as such.\n+    pub fn for_each_aliasing_place(\n+        &self,\n+        place: PlaceRef<'_>,\n+        tail_elem: Option<TrackElem>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        if place.is_indirect() {\n+            // We do not track indirect places.\n+            return;\n+        }\n+        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+            // The local is not tracked at all, so it does not alias anything.\n+            return;\n+        };\n+        let elems = place\n+            .projection\n+            .iter()\n+            .map(|&elem| elem.try_into())\n+            .chain(tail_elem.map(Ok).into_iter());\n+        for elem in elems {\n+            // A field aliases the parent place.\n+            f(index);\n+\n+            let Ok(elem) = elem else { return };\n+            let sub = self.apply(index, elem);\n+            if let TrackElem::Variant(..) | TrackElem::Discriminant = elem {\n+                // Enum variant fields and enum discriminants alias each another.\n+                self.for_each_variant_sibling(index, sub, f);\n+            }\n+            if let Some(sub) = sub {\n+                index = sub\n+            } else {\n+                return;\n+            }\n+        }\n+        self.preorder_invoke(index, f);\n+    }\n+\n+    /// Invoke the given function on all the descendants of the given place, except one branch.\n+    fn for_each_variant_sibling(\n+        &self,\n+        parent: PlaceIndex,\n+        preserved_child: Option<PlaceIndex>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        for sibling in self.children(parent) {\n+            let elem = self.places[sibling].proj_elem;\n+            // Only invalidate variants and discriminant. Fields (for generators) are not\n+            // invalidated by assignment to a variant.\n+            if let Some(TrackElem::Variant(..) | TrackElem::Discriminant) = elem\n+                // Only invalidate the other variants, the current one is fine.\n+                && Some(sibling) != preserved_child\n+            {\n+                self.preorder_invoke(sibling, f);\n+            }\n+        }\n+    }\n+\n     /// Invoke a function on the given place and all descendants.\n-    pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n+    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n         f(root);\n         for child in self.children(root) {\n             self.preorder_invoke(child, f);\n@@ -759,6 +901,7 @@ impl<'a> Iterator for Children<'a> {\n }\n \n /// Used as the result of an operand or r-value.\n+#[derive(Debug)]\n pub enum ValueOrPlace<V> {\n     Value(V),\n     Place(PlaceIndex),\n@@ -776,6 +919,8 @@ impl<V: HasTop> ValueOrPlace<V> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TrackElem {\n     Field(Field),\n+    Variant(VariantIdx),\n+    Discriminant,\n }\n \n impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n@@ -784,6 +929,7 @@ impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n     fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n         match value {\n             ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n+            ProjectionElem::Downcast(_, idx) => Ok(TrackElem::Variant(idx)),\n             _ => Err(()),\n         }\n     }\n@@ -824,26 +970,27 @@ pub fn iter_fields<'tcx>(\n }\n \n /// Returns all locals with projections that have their reference or address taken.\n-pub fn excluded_locals(body: &Body<'_>) -> IndexVec<Local, bool> {\n+pub fn excluded_locals(body: &Body<'_>) -> BitSet<Local> {\n     struct Collector {\n-        result: IndexVec<Local, bool>,\n+        result: BitSet<Local>,\n     }\n \n     impl<'tcx> Visitor<'tcx> for Collector {\n         fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n-            if context.is_borrow()\n+            if (context.is_borrow()\n                 || context.is_address_of()\n                 || context.is_drop()\n-                || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+                || context == PlaceContext::MutatingUse(MutatingUseContext::AsmOutput))\n+                && !place.is_indirect()\n             {\n                 // A pointer to a place could be used to access other places with the same local,\n                 // hence we have to exclude the local completely.\n-                self.result[place.local] = true;\n+                self.result.insert(place.local);\n             }\n         }\n     }\n \n-    let mut collector = Collector { result: IndexVec::from_elem(false, &body.local_decls) };\n+    let mut collector = Collector { result: BitSet::new_empty(body.local_decls.len()) };\n     collector.visit_body(body);\n     collector.result\n }\n@@ -899,6 +1046,12 @@ fn debug_with_context_rec<V: Debug + Eq>(\n     for child in map.children(place) {\n         let info_elem = map.places[child].proj_elem.unwrap();\n         let child_place_str = match info_elem {\n+            TrackElem::Discriminant => {\n+                format!(\"discriminant({})\", place_str)\n+            }\n+            TrackElem::Variant(idx) => {\n+                format!(\"({} as {:?})\", place_str, idx)\n+            }\n             TrackElem::Field(field) => {\n                 if place_str.starts_with('*') {\n                     format!(\"({}).{}\", place_str, field.index())"}, {"sha": "f3ca2337e59ca5a72455c309a359d88a1d5f4af2", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 95, "deletions": 32, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -13,6 +13,7 @@ use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, V\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Align;\n+use rustc_target::abi::VariantIdx;\n \n use crate::MirPass;\n \n@@ -30,14 +31,12 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n \n     #[instrument(skip_all level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(def_id = ?body.source.def_id());\n         if tcx.sess.mir_opt_level() < 4 && body.basic_blocks.len() > BLOCK_LIMIT {\n             debug!(\"aborted dataflow const prop due too many basic blocks\");\n             return;\n         }\n \n-        // Decide which places to track during the analysis.\n-        let map = Map::from_filter(tcx, body, Ty::is_scalar);\n-\n         // We want to have a somewhat linear runtime w.r.t. the number of statements/terminators.\n         // Let's call this number `n`. Dataflow analysis has `O(h*n)` transfer function\n         // applications, where `h` is the height of the lattice. Because the height of our lattice\n@@ -46,10 +45,10 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n         // `O(num_nodes * tracked_places * n)` in terms of time complexity. Since the number of\n         // map nodes is strongly correlated to the number of tracked places, this becomes more or\n         // less `O(n)` if we place a constant limit on the number of tracked places.\n-        if tcx.sess.mir_opt_level() < 4 && map.tracked_places() > PLACE_LIMIT {\n-            debug!(\"aborted dataflow const prop due to too many tracked places\");\n-            return;\n-        }\n+        let place_limit = if tcx.sess.mir_opt_level() < 4 { Some(PLACE_LIMIT) } else { None };\n+\n+        // Decide which places to track during the analysis.\n+        let map = Map::from_filter(tcx, body, Ty::is_scalar, place_limit);\n \n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);\n@@ -63,14 +62,31 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n     }\n }\n \n-struct ConstAnalysis<'tcx> {\n+struct ConstAnalysis<'a, 'tcx> {\n     map: Map,\n     tcx: TyCtxt<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n     ecx: InterpCx<'tcx, 'tcx, DummyMachine>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n+impl<'tcx> ConstAnalysis<'_, 'tcx> {\n+    fn eval_discriminant(\n+        &self,\n+        enum_ty: Ty<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Option<ScalarTy<'tcx>> {\n+        if !enum_ty.is_enum() {\n+            return None;\n+        }\n+        let discr = enum_ty.discriminant_for_variant(self.tcx, variant_index)?;\n+        let discr_layout = self.tcx.layout_of(self.param_env.and(discr.ty)).ok()?;\n+        let discr_value = Scalar::try_from_uint(discr.val, discr_layout.size)?;\n+        Some(ScalarTy(discr_value, discr.ty))\n+    }\n+}\n+\n+impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n     type Value = FlatSet<ScalarTy<'tcx>>;\n \n     const NAME: &'static str = \"ConstAnalysis\";\n@@ -79,6 +95,25 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         &self.map\n     }\n \n+    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { box ref place, variant_index } => {\n+                state.flood_discr(place.as_ref(), &self.map);\n+                if self.map.find_discr(place.as_ref()).is_some() {\n+                    let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n+                    if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n+                        state.assign_discr(\n+                            place.as_ref(),\n+                            ValueOrPlace::Value(FlatSet::Elem(discr)),\n+                            &self.map,\n+                        );\n+                    }\n+                }\n+            }\n+            _ => self.super_statement(statement, state),\n+        }\n+    }\n+\n     fn handle_assign(\n         &self,\n         target: Place<'tcx>,\n@@ -87,36 +122,47 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n     ) {\n         match rvalue {\n             Rvalue::Aggregate(kind, operands) => {\n-                let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    state.flood_idx_with(target, self.map(), FlatSet::Bottom);\n-                    let field_based = match **kind {\n-                        AggregateKind::Tuple | AggregateKind::Closure(..) => true,\n-                        AggregateKind::Adt(def_id, ..) => {\n-                            matches!(self.tcx.def_kind(def_id), DefKind::Struct)\n+                state.flood_with(target.as_ref(), self.map(), FlatSet::Bottom);\n+                if let Some(target_idx) = self.map().find(target.as_ref()) {\n+                    let (variant_target, variant_index) = match **kind {\n+                        AggregateKind::Tuple | AggregateKind::Closure(..) => {\n+                            (Some(target_idx), None)\n                         }\n-                        _ => false,\n+                        AggregateKind::Adt(def_id, variant_index, ..) => {\n+                            match self.tcx.def_kind(def_id) {\n+                                DefKind::Struct => (Some(target_idx), None),\n+                                DefKind::Enum => (Some(target_idx), Some(variant_index)),\n+                                _ => (None, None),\n+                            }\n+                        }\n+                        _ => (None, None),\n                     };\n-                    if field_based {\n+                    if let Some(target) = variant_target {\n                         for (field_index, operand) in operands.iter().enumerate() {\n                             if let Some(field) = self\n                                 .map()\n                                 .apply(target, TrackElem::Field(Field::from_usize(field_index)))\n                             {\n                                 let result = self.handle_operand(operand, state);\n-                                state.assign_idx(field, result, self.map());\n+                                state.insert_idx(field, result, self.map());\n                             }\n                         }\n                     }\n+                    if let Some(variant_index) = variant_index\n+                        && let Some(discr_idx) = self.map().apply(target_idx, TrackElem::Discriminant)\n+                    {\n+                        let enum_ty = target.ty(self.local_decls, self.tcx).ty;\n+                        if let Some(discr_val) = self.eval_discriminant(enum_ty, variant_index) {\n+                            state.insert_value_idx(discr_idx, FlatSet::Elem(discr_val), &self.map);\n+                        }\n+                    }\n                 }\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                // Flood everything now, so we can use `insert_value_idx` directly later.\n+                state.flood(target.as_ref(), self.map());\n+\n                 let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    // We should not track any projections other than\n-                    // what is overwritten below, but just in case...\n-                    state.flood_idx(target, self.map());\n-                }\n \n                 let value_target = target\n                     .and_then(|target| self.map().apply(target, TrackElem::Field(0_u32.into())));\n@@ -127,7 +173,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                     let (val, overflow) = self.binary_op(state, *op, left, right);\n \n                     if let Some(value_target) = value_target {\n-                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(value_target, val, self.map());\n                     }\n                     if let Some(overflow_target) = overflow_target {\n                         let overflow = match overflow {\n@@ -142,11 +189,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };\n-                        state.assign_idx(\n-                            overflow_target,\n-                            ValueOrPlace::Value(overflow),\n-                            self.map(),\n-                        );\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(overflow_target, overflow, self.map());\n                     }\n                 }\n             }\n@@ -195,6 +239,9 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                 FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n                 FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n             },\n+            Rvalue::Discriminant(place) => {\n+                ValueOrPlace::Value(state.get_discr(place.as_ref(), self.map()))\n+            }\n             _ => self.super_rvalue(rvalue, state),\n         }\n     }\n@@ -268,12 +315,13 @@ impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n     }\n }\n \n-impl<'tcx> ConstAnalysis<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, map: Map) -> Self {\n+impl<'a, 'tcx> ConstAnalysis<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, map: Map) -> Self {\n         let param_env = tcx.param_env(body.source.def_id());\n         Self {\n             map,\n             tcx,\n+            local_decls: &body.local_decls,\n             ecx: InterpCx::new(tcx, DUMMY_SP, param_env, DummyMachine),\n             param_env: param_env,\n         }\n@@ -466,6 +514,21 @@ impl<'tcx, 'map, 'a> Visitor<'tcx> for OperandCollector<'tcx, 'map, 'a> {\n             _ => (),\n         }\n     }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        match rvalue {\n+            Rvalue::Discriminant(place) => {\n+                match self.state.get_discr(place.as_ref(), self.visitor.map) {\n+                    FlatSet::Top => (),\n+                    FlatSet::Elem(value) => {\n+                        self.visitor.before_effect.insert((location, *place), value);\n+                    }\n+                    FlatSet::Bottom => (),\n+                }\n+            }\n+            _ => self.super_rvalue(rvalue, location),\n+        }\n+    }\n }\n \n struct DummyMachine;"}, {"sha": "8a37423b2a052b23d15c5f4fc8f3a2b08e309cc7", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,5 +1,5 @@\n use crate::MirPass;\n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::{BitSet, GrowableBitSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::*;\n@@ -26,10 +26,12 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n             debug!(?replacements);\n             let all_dead_locals = replace_flattened_locals(tcx, body, replacements);\n             if !all_dead_locals.is_empty() {\n-                for local in excluded.indices() {\n-                    excluded[local] |= all_dead_locals.contains(local);\n-                }\n-                excluded.raw.resize(body.local_decls.len(), false);\n+                excluded.union(&all_dead_locals);\n+                excluded = {\n+                    let mut growable = GrowableBitSet::from(excluded);\n+                    growable.ensure(body.local_decls.len());\n+                    growable.into()\n+                };\n             } else {\n                 break;\n             }\n@@ -44,11 +46,11 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n /// - the locals is a union or an enum;\n /// - the local's address is taken, and thus the relative addresses of the fields are observable to\n ///   client code.\n-fn escaping_locals(excluded: &IndexVec<Local, bool>, body: &Body<'_>) -> BitSet<Local> {\n+fn escaping_locals(excluded: &BitSet<Local>, body: &Body<'_>) -> BitSet<Local> {\n     let mut set = BitSet::new_empty(body.local_decls.len());\n     set.insert_range(RETURN_PLACE..=Local::from_usize(body.arg_count));\n     for (local, decl) in body.local_decls().iter_enumerated() {\n-        if decl.ty.is_union() || decl.ty.is_enum() || excluded[local] {\n+        if decl.ty.is_union() || decl.ty.is_enum() || excluded.contains(local) {\n             set.insert(local);\n         }\n     }\n@@ -172,7 +174,7 @@ fn replace_flattened_locals<'tcx>(\n     body: &mut Body<'tcx>,\n     replacements: ReplacementMap<'tcx>,\n ) -> BitSet<Local> {\n-    let mut all_dead_locals = BitSet::new_empty(body.local_decls.len());\n+    let mut all_dead_locals = BitSet::new_empty(replacements.fragments.len());\n     for (local, replacements) in replacements.fragments.iter_enumerated() {\n         if replacements.is_some() {\n             all_dead_locals.insert(local);"}, {"sha": "6d3518d53f7790b6c4e2043c8a6c50212e066575", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -65,7 +65,7 @@ impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span,\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     pub(crate) fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n@@ -214,18 +214,18 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b> {\n-    r: &'b mut Resolver<'a>,\n+struct BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n+    r: &'b mut Resolver<'a, 'tcx>,\n     parent_scope: ParentScope<'a>,\n }\n \n-impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n-    fn as_mut(&mut self) -> &mut Resolver<'a> {\n+impl<'a, 'tcx> AsMut<Resolver<'a, 'tcx>> for BuildReducedGraphVisitor<'a, '_, 'tcx> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a, 'tcx> {\n         self.r\n     }\n }\n \n-impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         self.try_resolve_visibility(vis, true).unwrap_or_else(|err| {\n             self.r.report_vis_error(err);\n@@ -1315,7 +1315,7 @@ macro_rules! method {\n     };\n }\n \n-impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     method!(visit_expr: ast::Expr, ast::ExprKind::MacCall, walk_expr);\n     method!(visit_pat: ast::Pat, ast::PatKind::MacCall, walk_pat);\n     method!(visit_ty: ast::Ty, ast::TyKind::MacCall, walk_ty);"}, {"sha": "294fd0a736f37765316cfa40ba85a68aabc211a4", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -49,16 +49,16 @@ impl<'a> UnusedImport<'a> {\n     }\n }\n \n-struct UnusedImportCheckVisitor<'a, 'b> {\n-    r: &'a mut Resolver<'b>,\n+struct UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+    r: &'a mut Resolver<'b, 'tcx>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: FxIndexMap<ast::NodeId, UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n }\n \n-impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n@@ -94,7 +94,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         self.item_span = item.span_with_attributes();\n \n@@ -222,7 +222,7 @@ fn calc_unused_spans(\n     }\n }\n \n-impl Resolver<'_> {\n+impl Resolver<'_, '_> {\n     pub(crate) fn check_unused(&mut self, krate: &ast::Crate) {\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {"}, {"sha": "e7ff236f84616e49af975ade2e83eccd6d669d05", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -9,7 +9,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n pub(crate) fn collect_definitions(\n-    resolver: &mut Resolver<'_>,\n+    resolver: &mut Resolver<'_, '_>,\n     fragment: &AstFragment,\n     expansion: LocalExpnId,\n ) {\n@@ -18,14 +18,14 @@ pub(crate) fn collect_definitions(\n }\n \n /// Creates `DefId`s for nodes in the AST.\n-struct DefCollector<'a, 'b> {\n-    resolver: &'a mut Resolver<'b>,\n+struct DefCollector<'a, 'b, 'tcx> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n     parent_def: LocalDefId,\n     impl_trait_context: ImplTraitContext,\n     expansion: LocalExpnId,\n }\n \n-impl<'a, 'b> DefCollector<'a, 'b> {\n+impl<'a, 'b, 'tcx> DefCollector<'a, 'b, 'tcx> {\n     fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n@@ -81,7 +81,7 @@ impl<'a, 'b> DefCollector<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n+impl<'a, 'b, 'tcx> visit::Visitor<'a> for DefCollector<'a, 'b, 'tcx> {\n     fn visit_item(&mut self, i: &'a Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "934d60589d4e21def520fb4718e2b7c74995b20b", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -114,7 +114,7 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n     sm.span_until_whitespace(impl_span)\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub(crate) fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n@@ -1883,7 +1883,7 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-impl<'a, 'b> ImportResolver<'a, 'b> {\n+impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// Adds suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,"}, {"sha": "0079c3e526d62a65f17621d2c4487fff57a5a189", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -29,8 +29,8 @@ impl ParentId<'_> {\n     }\n }\n \n-pub(crate) struct EffectiveVisibilitiesVisitor<'r, 'a> {\n-    r: &'r mut Resolver<'a>,\n+pub(crate) struct EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n+    r: &'r mut Resolver<'a, 'tcx>,\n     def_effective_visibilities: EffectiveVisibilities,\n     /// While walking import chains we need to track effective visibilities per-binding, and def id\n     /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n@@ -41,7 +41,7 @@ pub(crate) struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     changed: bool,\n }\n \n-impl Resolver<'_> {\n+impl Resolver<'_, '_> {\n     fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n         self.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n     }\n@@ -67,18 +67,21 @@ impl Resolver<'_> {\n     }\n }\n \n-impl<'a, 'b> IntoDefIdTree for &'b mut Resolver<'a> {\n-    type Tree = &'b Resolver<'a>;\n+impl<'a, 'b, 'tcx> IntoDefIdTree for &'b mut Resolver<'a, 'tcx> {\n+    type Tree = &'b Resolver<'a, 'tcx>;\n     fn tree(self) -> Self::Tree {\n         self\n     }\n }\n \n-impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n+impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n-    pub(crate) fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n+    pub(crate) fn compute_effective_visibilities<'c>(\n+        r: &'r mut Resolver<'a, 'tcx>,\n+        krate: &'c Crate,\n+    ) {\n         let mut visitor = EffectiveVisibilitiesVisitor {\n             r,\n             def_effective_visibilities: Default::default(),\n@@ -192,7 +195,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     }\n }\n \n-impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n+impl<'r, 'ast, 'tcx> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r, 'tcx> {\n     fn visit_item(&mut self, item: &'ast ast::Item) {\n         let def_id = self.r.local_def_id(item.id);\n         // Update effective visibilities of nested items."}, {"sha": "61a48b109b22a0f213f0ffabc061f7456498e495", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -28,7 +28,7 @@ use RibKind::*;\n \n type Visibility = ty::Visibility<LocalDefId>;\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// A generic scope visitor.\n     /// Visits scopes in order to resolve some identifier in them or perform other actions.\n     /// If the callback returns `Some` result, we stop visiting scopes and return it."}, {"sha": "da3e5095e531d3afb183f8a79d5896e5e23bc196", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -225,7 +225,7 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Given a binding and an import that resolves to it,\n     /// return the corresponding binding defined by the import.\n     pub(crate) fn import(\n@@ -333,7 +333,7 @@ impl<'a> Resolver<'a> {\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&mut self, module: Module<'a>, key: BindingKey, f: F) -> T\n     where\n-        F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T,\n+        F: FnOnce(&mut Resolver<'a, 'tcx>, &mut NameResolution<'a>) -> T,\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n@@ -405,11 +405,11 @@ struct UnresolvedImportError {\n     candidates: Option<Vec<ImportSuggestion>>,\n }\n \n-pub(crate) struct ImportResolver<'a, 'b> {\n-    pub r: &'a mut Resolver<'b>,\n+pub(crate) struct ImportResolver<'a, 'b, 'tcx> {\n+    pub r: &'a mut Resolver<'b, 'tcx>,\n }\n \n-impl<'a, 'b> ImportResolver<'a, 'b> {\n+impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts"}, {"sha": "d3bcbbabf55e541a04cdc39cd132e628dd0fee24", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -505,7 +505,7 @@ enum MaybeExported<'a> {\n }\n \n impl MaybeExported<'_> {\n-    fn eval(self, r: &Resolver<'_>) -> bool {\n+    fn eval(self, r: &Resolver<'_, '_>) -> bool {\n         let def_id = match self {\n             MaybeExported::Ok(node_id) => Some(r.local_def_id(node_id)),\n             MaybeExported::Impl(Some(trait_def_id)) | MaybeExported::ImplItem(Ok(trait_def_id)) => {\n@@ -584,8 +584,8 @@ struct DiagnosticMetadata<'ast> {\n     current_elision_failures: Vec<MissingLifetime>,\n }\n \n-struct LateResolutionVisitor<'a, 'b, 'ast> {\n-    r: &'b mut Resolver<'a>,\n+struct LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n+    r: &'b mut Resolver<'a, 'tcx>,\n \n     /// The module that represents the current item scope.\n     parent_scope: ParentScope<'a>,\n@@ -628,7 +628,7 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n-impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n+impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     fn visit_attribute(&mut self, _: &'ast Attribute) {\n         // We do not want to resolve expressions that appear in attributes,\n         // as they do not correspond to actual code.\n@@ -1199,8 +1199,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n }\n \n-impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n-    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b, 'ast> {\n+impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n+    fn new(resolver: &'b mut Resolver<'a, 'tcx>) -> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n@@ -2029,13 +2029,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// List all the lifetimes that appear in the provided type.\n     fn find_lifetime_for_self(&self, ty: &'ast Ty) -> Set1<LifetimeRes> {\n-        struct SelfVisitor<'r, 'a> {\n-            r: &'r Resolver<'a>,\n+        struct SelfVisitor<'r, 'a, 'tcx> {\n+            r: &'r Resolver<'a, 'tcx>,\n             impl_self: Option<Res>,\n             lifetime: Set1<LifetimeRes>,\n         }\n \n-        impl SelfVisitor<'_, '_> {\n+        impl SelfVisitor<'_, '_, '_> {\n             // Look for `self: &'a Self` - also desugared from `&'a self`,\n             // and if that matches, use it for elision and return early.\n             fn is_self_ty(&self, ty: &Ty) -> bool {\n@@ -2053,7 +2053,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        impl<'a> Visitor<'a> for SelfVisitor<'_, '_> {\n+        impl<'a> Visitor<'a> for SelfVisitor<'_, '_, '_> {\n             fn visit_ty(&mut self, ty: &'a Ty) {\n                 trace!(\"SelfVisitor considering ty={:?}\", ty);\n                 if let TyKind::Ref(lt, ref mt) = ty.kind && self.is_self_ty(&mt.ty) {\n@@ -4288,13 +4288,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n }\n \n-struct LifetimeCountVisitor<'a, 'b> {\n-    r: &'b mut Resolver<'a>,\n+struct LifetimeCountVisitor<'a, 'b, 'tcx> {\n+    r: &'b mut Resolver<'a, 'tcx>,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, counting the declared number of\n /// lifetime generic parameters.\n-impl<'ast> Visitor<'ast> for LifetimeCountVisitor<'_, '_> {\n+impl<'ast> Visitor<'ast> for LifetimeCountVisitor<'_, '_, '_> {\n     fn visit_item(&mut self, item: &'ast Item) {\n         match &item.kind {\n             ItemKind::TyAlias(box TyAlias { ref generics, .. })\n@@ -4328,7 +4328,7 @@ impl<'ast> Visitor<'ast> for LifetimeCountVisitor<'_, '_> {\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         visit::walk_crate(&mut LifetimeCountVisitor { r: self }, krate);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);"}, {"sha": "a3195a64366893a75120d1a2ca7c629f0aa990d1", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -166,7 +166,7 @@ impl TypoCandidate {\n     }\n }\n \n-impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n+impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n             LOCAL_CRATE => self.r.opt_span(def_id),\n@@ -318,7 +318,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n+    ) -> (DiagnosticBuilder<'tcx, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n         debug!(?res, ?source);\n         let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());"}, {"sha": "3db3b76fc26a296d2e63b60e31c20fbe89e29f38", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -147,7 +147,7 @@ struct ParentScope<'a> {\n impl<'a> ParentScope<'a> {\n     /// Creates a parent scope with the passed argument used as the module scope component,\n     /// and other scope components set to default empty values.\n-    fn module(module: Module<'a>, resolver: &Resolver<'a>) -> ParentScope<'a> {\n+    fn module(module: Module<'a>, resolver: &Resolver<'a, '_>) -> ParentScope<'a> {\n         ParentScope {\n             module,\n             expansion: LocalExpnId::ROOT,\n@@ -528,9 +528,9 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n-    fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n+    fn for_each_child<'tcx, R, F>(&'a self, resolver: &mut R, mut f: F)\n     where\n-        R: AsMut<Resolver<'a>>,\n+        R: AsMut<Resolver<'a, 'tcx>>,\n         F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>),\n     {\n         for (key, name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n@@ -541,9 +541,9 @@ impl<'a> ModuleData<'a> {\n     }\n \n     /// This modifies `self` in place. The traits will be stored in `self.traits`.\n-    fn ensure_traits<R>(&'a self, resolver: &mut R)\n+    fn ensure_traits<'tcx, R>(&'a self, resolver: &mut R)\n     where\n-        R: AsMut<Resolver<'a>>,\n+        R: AsMut<Resolver<'a, 'tcx>>,\n     {\n         let mut traits = self.traits.borrow_mut();\n         if traits.is_none() {\n@@ -864,8 +864,8 @@ struct MacroData {\n /// The main resolver class.\n ///\n /// This is the visitor that walks the whole crate.\n-pub struct Resolver<'a> {\n-    session: &'a Session,\n+pub struct Resolver<'a, 'tcx> {\n+    session: &'tcx Session,\n \n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n@@ -949,7 +949,7 @@ pub struct Resolver<'a> {\n     /// Ambiguity errors are delayed for deduplication.\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n     /// `use` injections are delayed for better placement and deduplication.\n-    use_injections: Vec<UseError<'a>>,\n+    use_injections: Vec<UseError<'tcx>>,\n     /// Crate-local macro expanded `macro_export` referred to by a module-relative path.\n     macro_expanded_macro_export_errors: BTreeSet<(Span, Span)>,\n \n@@ -1111,8 +1111,8 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n-    fn as_mut(&mut self) -> &mut Resolver<'a> {\n+impl<'a, 'tcx> AsMut<Resolver<'a, 'tcx>> for Resolver<'a, 'tcx> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a, 'tcx> {\n         self\n     }\n }\n@@ -1134,14 +1134,14 @@ impl DefIdTree for ResolverTree<'_> {\n     }\n }\n \n-impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+impl<'a, 'b, 'tcx> DefIdTree for &'a Resolver<'b, 'tcx> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n         ResolverTree(&self.untracked).opt_parent(id)\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'tcx> Resolver<'_, 'tcx> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n@@ -1200,14 +1200,14 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub fn new(\n-        session: &'a Session,\n+        session: &'tcx Session,\n         krate: &Crate,\n         crate_name: Symbol,\n         metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n-    ) -> Resolver<'a> {\n+    ) -> Resolver<'a, 'tcx> {\n         let root_def_id = CRATE_DEF_ID.to_def_id();\n         let mut module_map = FxHashMap::default();\n         let graph_root = arenas.new_module("}, {"sha": "1c220a81792da4e1e948d9c5937c963b5fe27fae", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -160,7 +160,7 @@ fn soft_custom_inner_attributes_gate(path: &ast::Path, invoc: &Invocation) -> bo\n     false\n }\n \n-impl<'a> ResolverExpand for Resolver<'a> {\n+impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     fn next_node_id(&mut self) -> NodeId {\n         self.next_node_id()\n     }\n@@ -467,7 +467,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     }\n }\n \n-impl<'a> Resolver<'a> {\n+impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolve macro path with error reporting and recovery.\n     /// Uses dummy syntax extensions for unresolved macros or macros with unexpected resolutions\n     /// for better error recovery."}, {"sha": "8d2e92cc76c6f2cb581cf6241475725b18a418e4", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -3,10 +3,8 @@ pub use Primitive::*;\n \n use crate::json::{Json, ToJson};\n \n-use std::fmt;\n use std::ops::Deref;\n \n-use rustc_data_structures::intern::Interned;\n use rustc_macros::HashStable_Generic;\n \n pub mod call;\n@@ -19,48 +17,6 @@ impl ToJson for Endian {\n     }\n }\n \n-rustc_index::newtype_index! {\n-    #[derive(HashStable_Generic)]\n-    pub struct VariantIdx {}\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n-#[rustc_pass_by_value]\n-pub struct Layout<'a>(pub Interned<'a, LayoutS<VariantIdx>>);\n-\n-impl<'a> fmt::Debug for Layout<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // See comment on `<LayoutS as Debug>::fmt` above.\n-        self.0.0.fmt(f)\n-    }\n-}\n-\n-impl<'a> Layout<'a> {\n-    pub fn fields(self) -> &'a FieldsShape {\n-        &self.0.0.fields\n-    }\n-\n-    pub fn variants(self) -> &'a Variants<VariantIdx> {\n-        &self.0.0.variants\n-    }\n-\n-    pub fn abi(self) -> Abi {\n-        self.0.0.abi\n-    }\n-\n-    pub fn largest_niche(self) -> Option<Niche> {\n-        self.0.0.largest_niche\n-    }\n-\n-    pub fn align(self) -> AbiAndPrefAlign {\n-        self.0.0.align\n-    }\n-\n-    pub fn size(self) -> Size {\n-        self.0.0.size\n-    }\n-}\n-\n /// The layout of a type, alongside the type itself.\n /// Provides various type traversal APIs (e.g., recursing into fields).\n ///\n@@ -75,8 +31,8 @@ pub struct TyAndLayout<'a, Ty> {\n }\n \n impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n-    type Target = &'a LayoutS<VariantIdx>;\n-    fn deref(&self) -> &&'a LayoutS<VariantIdx> {\n+    type Target = &'a LayoutS;\n+    fn deref(&self) -> &&'a LayoutS {\n         &self.layout.0.0\n     }\n }"}, {"sha": "23f4a5abf7795d696b5193675e0888e0e93b0048", "filename": "compiler/rustc_target/src/spec/armv6k_nintendo_3ds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6k_nintendo_3ds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6k_nintendo_3ds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6k_nintendo_3ds.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -29,8 +29,7 @@ pub fn target() -> Target {\n             pre_link_args,\n             exe_suffix: \".elf\".into(),\n             no_default_libraries: false,\n-            // There are some issues in debug builds with this enabled in certain programs.\n-            has_thread_local: false,\n+            has_thread_local: true,\n             ..Default::default()\n         },\n     }"}, {"sha": "2df4a5eab21001bc7bc2a447116b7c904201ad2e", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -78,10 +78,10 @@ fn invert_mapping(map: &[u32]) -> Vec<u32> {\n fn univariant_uninterned<'tcx>(\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n     ty: Ty<'tcx>,\n-    fields: &[TyAndLayout<'_>],\n+    fields: &[Layout<'_>],\n     repr: &ReprOptions,\n     kind: StructKind,\n-) -> Result<LayoutS<VariantIdx>, LayoutError<'tcx>> {\n+) -> Result<LayoutS, LayoutError<'tcx>> {\n     let dl = cx.data_layout();\n     let pack = repr.pack;\n     if pack.is_some() && repr.align.is_some() {\n@@ -106,7 +106,7 @@ fn layout_of_uncached<'tcx>(\n     };\n     let scalar = |value: Primitive| tcx.intern_layout(LayoutS::scalar(cx, scalar_unit(value)));\n \n-    let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n+    let univariant = |fields: &[Layout<'_>], repr: &ReprOptions, kind| {\n         Ok(tcx.intern_layout(univariant_uninterned(cx, ty, fields, repr, kind)?))\n     };\n     debug_assert!(!ty.has_non_region_infer());\n@@ -273,7 +273,7 @@ fn layout_of_uncached<'tcx>(\n         ty::Closure(_, ref substs) => {\n             let tys = substs.as_closure().upvar_tys();\n             univariant(\n-                &tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.map(|ty| Ok(cx.layout_of(ty)?.layout)).collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::AlwaysSized,\n             )?\n@@ -284,7 +284,7 @@ fn layout_of_uncached<'tcx>(\n                 if tys.len() == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n \n             univariant(\n-                &tys.iter().map(|k| cx.layout_of(k)).collect::<Result<Vec<_>, _>>()?,\n+                &tys.iter().map(|k| Ok(cx.layout_of(k)?.layout)).collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 kind,\n             )?\n@@ -413,7 +413,7 @@ fn layout_of_uncached<'tcx>(\n                 .map(|v| {\n                     v.fields\n                         .iter()\n-                        .map(|field| cx.layout_of(field.ty(tcx, substs)))\n+                        .map(|field| Ok(cx.layout_of(field.ty(tcx, substs))?.layout))\n                         .collect::<Result<Vec<_>, _>>()\n                 })\n                 .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n@@ -631,23 +631,21 @@ fn generator_layout<'tcx>(\n     // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n     let max_discr = (info.variant_fields.len() - 1) as u128;\n     let discr_int = Integer::fit_unsigned(max_discr);\n-    let discr_int_ty = discr_int.to_ty(tcx, false);\n     let tag = Scalar::Initialized {\n         value: Primitive::Int(discr_int, false),\n         valid_range: WrappingRange { start: 0, end: max_discr },\n     };\n     let tag_layout = cx.tcx.intern_layout(LayoutS::scalar(cx, tag));\n-    let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n     let promoted_layouts = ineligible_locals\n         .iter()\n         .map(|local| subst_field(info.field_tys[local].ty))\n         .map(|ty| tcx.mk_maybe_uninit(ty))\n-        .map(|ty| cx.layout_of(ty));\n+        .map(|ty| Ok(cx.layout_of(ty)?.layout));\n     let prefix_layouts = substs\n         .as_generator()\n         .prefix_tys()\n-        .map(|ty| cx.layout_of(ty))\n+        .map(|ty| Ok(cx.layout_of(ty)?.layout))\n         .chain(iter::once(Ok(tag_layout)))\n         .chain(promoted_layouts)\n         .collect::<Result<Vec<_>, _>>()?;\n@@ -716,7 +714,9 @@ fn generator_layout<'tcx>(\n             let mut variant = univariant_uninterned(\n                 cx,\n                 ty,\n-                &variant_only_tys.map(|ty| cx.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                &variant_only_tys\n+                    .map(|ty| Ok(cx.layout_of(ty)?.layout))\n+                    .collect::<Result<Vec<_>, _>>()?,\n                 &ReprOptions::default(),\n                 StructKind::Prefixed(prefix_size, prefix_align.abi),\n             )?;"}, {"sha": "f58dcf1287bef02b2c4e9bb19d90782b7c1d04eb", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -295,8 +295,6 @@ pub fn nt_success(status: NTSTATUS) -> bool {\n     status >= 0\n }\n \n-// \"RNG\\0\"\n-pub const BCRYPT_RNG_ALGORITHM: &[u16] = &[b'R' as u16, b'N' as u16, b'G' as u16, 0];\n pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n \n #[repr(C)]\n@@ -834,6 +832,10 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     #[link(name = \"advapi32\")]\n     extern \"system\" {\n+        // Forbidden when targeting UWP\n+        #[link_name = \"SystemFunction036\"]\n+        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n         // Allowed but unused by UWP\n         pub fn OpenProcessToken(\n             ProcessHandle: HANDLE,\n@@ -1258,13 +1260,6 @@ extern \"system\" {\n         cbBuffer: ULONG,\n         dwFlags: ULONG,\n     ) -> NTSTATUS;\n-    pub fn BCryptOpenAlgorithmProvider(\n-        phalgorithm: *mut BCRYPT_ALG_HANDLE,\n-        pszAlgId: LPCWSTR,\n-        pszimplementation: LPCWSTR,\n-        dwflags: ULONG,\n-    ) -> NTSTATUS;\n-    pub fn BCryptCloseAlgorithmProvider(hAlgorithm: BCRYPT_ALG_HANDLE, dwFlags: ULONG) -> NTSTATUS;\n }\n \n // Functions that aren't available on every version of Windows that we support,"}, {"sha": "cdf37cfe9117bfaffbaa29a3d38092b6eafd3ce1", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 27, "deletions": 94, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,106 +1,39 @@\n-//! # Random key generation\n-//!\n-//! This module wraps the RNG provided by the OS. There are a few different\n-//! ways to interface with the OS RNG so it's worth exploring each of the options.\n-//! Note that at the time of writing these all go through the (undocumented)\n-//! `bcryptPrimitives.dll` but they use different route to get there.\n-//!\n-//! Originally we were using [`RtlGenRandom`], however that function is\n-//! deprecated and warns it \"may be altered or unavailable in subsequent versions\".\n-//!\n-//! So we switched to [`BCryptGenRandom`] with the `BCRYPT_USE_SYSTEM_PREFERRED_RNG`\n-//! flag to query and find the system configured RNG. However, this change caused a small\n-//! but significant number of users to experience panics caused by a failure of\n-//! this function. See [#94098].\n-//!\n-//! The current version falls back to using `BCryptOpenAlgorithmProvider` if\n-//! `BCRYPT_USE_SYSTEM_PREFERRED_RNG` fails for any reason.\n-//!\n-//! [#94098]: https://github.com/rust-lang/rust/issues/94098\n-//! [`RtlGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom\n-//! [`BCryptGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n+use crate::io;\n use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n \n-/// Generates high quality secure random keys for use by [`HashMap`].\n-///\n-/// This is used to seed the default [`RandomState`].\n-///\n-/// [`HashMap`]: crate::collections::HashMap\n-/// [`RandomState`]: crate::collections::hash_map::RandomState\n pub fn hashmap_random_keys() -> (u64, u64) {\n-    Rng::SYSTEM.gen_random_keys().unwrap_or_else(fallback_rng)\n+    let mut v = (0, 0);\n+    let ret = unsafe {\n+        c::BCryptGenRandom(\n+            ptr::null_mut(),\n+            &mut v as *mut _ as *mut u8,\n+            mem::size_of_val(&v) as c::ULONG,\n+            c::BCRYPT_USE_SYSTEM_PREFERRED_RNG,\n+        )\n+    };\n+    if c::nt_success(ret) { v } else { fallback_rng() }\n }\n \n-struct Rng {\n-    algorithm: c::BCRYPT_ALG_HANDLE,\n-    flags: u32,\n-}\n-impl Rng {\n-    const SYSTEM: Self = unsafe { Self::new(ptr::null_mut(), c::BCRYPT_USE_SYSTEM_PREFERRED_RNG) };\n-\n-    /// Create the RNG from an existing algorithm handle.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The handle must either be null or a valid algorithm handle.\n-    const unsafe fn new(algorithm: c::BCRYPT_ALG_HANDLE, flags: u32) -> Self {\n-        Self { algorithm, flags }\n-    }\n-\n-    /// Open a handle to the RNG algorithm.\n-    fn open() -> Result<Self, c::NTSTATUS> {\n-        use crate::sync::atomic::AtomicPtr;\n-        use crate::sync::atomic::Ordering::{Acquire, Release};\n-\n-        // An atomic is used so we don't need to reopen the handle every time.\n-        static HANDLE: AtomicPtr<crate::ffi::c_void> = AtomicPtr::new(ptr::null_mut());\n-\n-        let mut handle = HANDLE.load(Acquire);\n-        if handle.is_null() {\n-            let status = unsafe {\n-                c::BCryptOpenAlgorithmProvider(\n-                    &mut handle,\n-                    c::BCRYPT_RNG_ALGORITHM.as_ptr(),\n-                    ptr::null(),\n-                    0,\n-                )\n-            };\n-            if c::nt_success(status) {\n-                // If another thread opens a handle first then use that handle instead.\n-                let result = HANDLE.compare_exchange(ptr::null_mut(), handle, Release, Acquire);\n-                if let Err(previous_handle) = result {\n-                    // Close our handle and return the previous one.\n-                    unsafe { c::BCryptCloseAlgorithmProvider(handle, 0) };\n-                    handle = previous_handle;\n-                }\n-                Ok(unsafe { Self::new(handle, 0) })\n-            } else {\n-                Err(status)\n-            }\n-        } else {\n-            Ok(unsafe { Self::new(handle, 0) })\n-        }\n-    }\n+/// Generate random numbers using the fallback RNG function (RtlGenRandom)\n+///\n+/// This is necessary because of a failure to load the SysWOW64 variant of the\n+/// bcryptprimitives.dll library from code that lives in bcrypt.dll\n+/// See <https://bugzilla.mozilla.org/show_bug.cgi?id=1788004#c9>\n+#[cfg(not(target_vendor = \"uwp\"))]\n+#[inline(never)]\n+fn fallback_rng() -> (u64, u64) {\n+    let mut v = (0, 0);\n+    let ret =\n+        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n \n-    fn gen_random_keys(self) -> Result<(u64, u64), c::NTSTATUS> {\n-        let mut v = (0, 0);\n-        let status = unsafe {\n-            let size = mem::size_of_val(&v).try_into().unwrap();\n-            c::BCryptGenRandom(self.algorithm, ptr::addr_of_mut!(v).cast(), size, self.flags)\n-        };\n-        if c::nt_success(status) { Ok(v) } else { Err(status) }\n-    }\n+    if ret != 0 { v } else { panic!(\"fallback RNG broken: {}\", io::Error::last_os_error()) }\n }\n \n-/// Generate random numbers using the fallback RNG function\n+/// We can't use RtlGenRandom with UWP, so there is no fallback\n+#[cfg(target_vendor = \"uwp\")]\n #[inline(never)]\n-fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n-    match Rng::open().and_then(|rng| rng.gen_random_keys()) {\n-        Ok(keys) => keys,\n-        Err(status) => {\n-            panic!(\"RNG broken: {rng_status:#x}, fallback RNG broken: {status:#x}\")\n-        }\n-    }\n+fn fallback_rng() -> (u64, u64) {\n+    panic!(\"fallback RNG broken: RtlGenRandom() not supported on UWP\");\n }"}, {"sha": "4ff1c93dc5d554ca2b851619f10d281397d137c0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::layout::LayoutError;\n use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::{LayoutS, Primitive, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{LayoutS, Primitive, TagEncoding, Variants};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -1833,7 +1833,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS<VariantIdx>, tag_size: u64) {\n+    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS, tag_size: u64) {\n         if layout.abi.is_unsized() {\n             write!(w, \"(unsized)\");\n         } else {"}, {"sha": "038e6c6bd900596a0ca54886a4f1c9e89c8c0133", "filename": "tests/mir-opt/dataflow-const-prop/enum.mutate_discriminant.DataflowConstProp.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `mutate_discriminant` before DataflowConstProp\n++ // MIR for `mutate_discriminant` after DataflowConstProp\n+  \n+  fn mutate_discriminant() -> u8 {\n+      let mut _0: u8;                      // return place in scope 0 at $DIR/enum.rs:+0:29: +0:31\n+      let mut _1: std::option::Option<NonZeroUsize>; // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+      let mut _2: isize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+          discriminant(_1) = 1;            // scope 0 at $DIR/enum.rs:+4:13: +4:34\n+          (((_1 as variant#1).0: NonZeroUsize).0: usize) = const 0_usize; // scope 0 at $DIR/enum.rs:+6:13: +6:64\n+          _2 = discriminant(_1);           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+          switchInt(_2) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/enum.rs:+9:13: +12:14\n+      }\n+  \n+      bb1: {\n+          _0 = const 1_u8;                 // scope 0 at $DIR/enum.rs:+15:13: +15:20\n+          return;                          // scope 0 at $DIR/enum.rs:+16:13: +16:21\n+      }\n+  \n+      bb2: {\n+          _0 = const 2_u8;                 // scope 0 at $DIR/enum.rs:+19:13: +19:20\n+          unreachable;                     // scope 0 at $DIR/enum.rs:+20:13: +20:26\n+      }\n+  }\n+  "}, {"sha": "7ea405bd9c408057f5cec1bdae6486d3f05ed16d", "filename": "tests/mir-opt/dataflow-const-prop/enum.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,13 +1,52 @@\n // unit-test: DataflowConstProp\n \n-// Not trackable, because variants could be aliased.\n+#![feature(custom_mir, core_intrinsics, rustc_attrs)]\n+\n+use std::intrinsics::mir::*;\n+\n enum E {\n     V1(i32),\n     V2(i32)\n }\n \n-// EMIT_MIR enum.main.DataflowConstProp.diff\n-fn main() {\n+// EMIT_MIR enum.simple.DataflowConstProp.diff\n+fn simple() {\n     let e = E::V1(0);\n     let x = match e { E::V1(x) => x, E::V2(x) => x };\n }\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+struct NonZeroUsize(usize);\n+\n+// EMIT_MIR enum.mutate_discriminant.DataflowConstProp.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+fn mutate_discriminant() -> u8 {\n+    mir!(\n+        let x: Option<NonZeroUsize>;\n+        {\n+            SetDiscriminant(x, 1);\n+            // This assignment overwrites the niche in which the discriminant is stored.\n+            place!(Field(Field(Variant(x, 1), 0), 0)) = 0_usize;\n+            // So we cannot know the value of this discriminant.\n+            let a = Discriminant(x);\n+            match a {\n+                0 => bb1,\n+                _ => bad,\n+            }\n+        }\n+        bb1 = {\n+            RET = 1;\n+            Return()\n+        }\n+        bad = {\n+            RET = 2;\n+            Unreachable()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    simple();\n+    mutate_discriminant();\n+}"}, {"sha": "1fb65e6584525dacb6507da722d147def7dc3dba", "filename": "tests/mir-opt/dataflow-const-prop/enum.simple.DataflowConstProp.diff", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -1,8 +1,8 @@\n-- // MIR for `main` before DataflowConstProp\n-+ // MIR for `main` after DataflowConstProp\n+- // MIR for `simple` before DataflowConstProp\n++ // MIR for `simple` after DataflowConstProp\n   \n-  fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:11: +0:11\n+  fn simple() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:13: +0:13\n       let _1: E;                           // in scope 0 at $DIR/enum.rs:+1:9: +1:10\n       let mut _3: isize;                   // in scope 0 at $DIR/enum.rs:+2:23: +2:31\n       scope 1 {\n@@ -25,8 +25,10 @@\n           StorageLive(_1);                 // scope 0 at $DIR/enum.rs:+1:9: +1:10\n           _1 = E::V1(const 0_i32);         // scope 0 at $DIR/enum.rs:+1:13: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n-          _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n-          switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n+-         _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n+-         switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n++         _3 = const 0_isize;              // scope 1 at $DIR/enum.rs:+2:19: +2:20\n++         switchInt(const 0_isize) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n       }\n   \n       bb1: {\n@@ -50,7 +52,7 @@\n       }\n   \n       bb4: {\n-          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:11: +3:2\n+          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:13: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/enum.rs:+3:1: +3:2\n           StorageDead(_1);                 // scope 0 at $DIR/enum.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/enum.rs:+3:2: +3:2", "previous_filename": "tests/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff"}, {"sha": "614f189729126535ab324194f7c85e41647381ce", "filename": "tests/ui/async-await/multiple-lifetimes/member-constraints-min-choice-issue-63033.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fmember-constraints-min-choice-issue-63033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fmember-constraints-min-choice-issue-63033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fmember-constraints-min-choice-issue-63033.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for #63033.\n+\n+// check-pass\n+// edition: 2018\n+\n+async fn test1(_: &'static u8, _: &'_ u8, _: &'_ u8) {}\n+\n+async fn test2<'s>(_: &'s u8, _: &'_ &'s u8, _: &'_ &'s u8) {}\n+\n+fn main() {}"}, {"sha": "b30ff61a99c53cb260c6125ac0d9f4b8a6bf7dc2", "filename": "tests/ui/consts/array-literal-len-mismatch.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,4 @@\n+const NUMBERS: [u8; 3] = [10, 20];\n+//~^ ERROR mismatched types\n+//~^^ HELP consider specifying the actual array length\n+fn main() {}"}, {"sha": "22fec638970a7cb37d0ecdb9b474d6b6f3cce0b3", "filename": "tests/ui/consts/array-literal-len-mismatch.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Farray-literal-len-mismatch.stderr?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/array-literal-len-mismatch.rs:1:26\n+   |\n+LL | const NUMBERS: [u8; 3] = [10, 20];\n+   |                     -    ^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 2 elements\n+   |                     |\n+   |                     help: consider specifying the actual array length: `2`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "029d94273fae1180030479332d6774856e42336a", "filename": "tests/ui/consts/const-array-oob-arith.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -2,13 +2,17 @@ error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:5:45\n    |\n LL | const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n-   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 element\n+   |                   ----------------------    ^^^ expected an array with a fixed size of 2 elements, found one with 1 element\n+   |                   |\n+   |                   help: consider specifying the actual array length: `1`\n \n error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:8:44\n    |\n LL | const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n-   |                                            ^^^^^^^ expected an array with a fixed size of 1 element, found one with 2 elements\n+   |                  ----------------------    ^^^^^^^ expected an array with a fixed size of 1 element, found one with 2 elements\n+   |                  |\n+   |                  help: consider specifying the actual array length: `2`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "149d061029bc3b80a5ce7fd85ce168a307e2e3bc", "filename": "tests/ui/inference/array-len-mismatch.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Finference%2Farray-len-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Finference%2Farray-len-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Farray-len-mismatch.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,12 @@\n+fn returns_arr() -> [u8; 2] {\n+    [1, 2]\n+}\n+\n+fn main() {\n+    let wrong: [u8; 3] = [10, 20];\n+    //~^ ERROR mismatched types\n+    //~^^ HELP consider specifying the actual array length\n+    let wrong: [u8; 3] = returns_arr();\n+    //~^ ERROR mismatched types\n+    //~^^ HELP consider specifying the actual array length\n+}"}, {"sha": "7358e47839725acd7832ae874f45fb8f23d1a2dd", "filename": "tests/ui/inference/array-len-mismatch.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Finference%2Farray-len-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Finference%2Farray-len-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Farray-len-mismatch.stderr?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/array-len-mismatch.rs:6:26\n+   |\n+LL |     let wrong: [u8; 3] = [10, 20];\n+   |                -------   ^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 2 elements\n+   |                |    |\n+   |                |    help: consider specifying the actual array length: `2`\n+   |                expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/array-len-mismatch.rs:9:26\n+   |\n+LL |     let wrong: [u8; 3] = returns_arr();\n+   |                -------   ^^^^^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 2 elements\n+   |                |    |\n+   |                |    help: consider specifying the actual array length: `2`\n+   |                expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "52ea0f28d69f30cf58c8da8a743c160220368441", "filename": "tests/ui/nll/member-constraints/min-choice-reject-ambiguous.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,43 @@\n+// ... continued from ./min-choice.rs\n+\n+// check-fail\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+fn type_test<'a, T: 'a>() -> &'a u8 { &0 }\n+\n+// Make sure we don't pick `'b`.\n+fn test_b<'a, 'b, 'c, T>() -> impl Cap<'a> + Cap<'b> + Cap<'c>\n+where\n+    'a: 'b,\n+    'a: 'c,\n+    T: 'b,\n+{\n+    type_test::<'_, T>() // This should pass if we pick 'b.\n+    //~^ ERROR the parameter type `T` may not live long enough\n+}\n+\n+// Make sure we don't pick `'c`.\n+fn test_c<'a, 'b, 'c, T>() -> impl Cap<'a> + Cap<'b> + Cap<'c>\n+where\n+    'a: 'b,\n+    'a: 'c,\n+    T: 'c,\n+{\n+    type_test::<'_, T>() // This should pass if we pick 'c.\n+    //~^ ERROR the parameter type `T` may not live long enough\n+}\n+\n+// We need to pick min_choice from `['b, 'c]`, but it's ambiguous which one to pick because\n+// they're incomparable.\n+fn test_ambiguous<'a, 'b, 'c>(s: &'a u8) -> impl Cap<'b> + Cap<'c>\n+where\n+    'a: 'b,\n+    'a: 'c,\n+{\n+    s\n+    //~^ ERROR captures lifetime that does not appear in bounds\n+}\n+\n+fn main() {}"}, {"sha": "1e6ef614dee247b2bf2c7f4704155ab10d735104", "filename": "tests/ui/nll/member-constraints/min-choice-reject-ambiguous.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice-reject-ambiguous.stderr?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,40 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/min-choice-reject-ambiguous.rs:17:5\n+   |\n+LL |     type_test::<'_, T>() // This should pass if we pick 'b.\n+   |     ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'b + 'a,\n+   |           ++++\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/min-choice-reject-ambiguous.rs:28:5\n+   |\n+LL |     type_test::<'_, T>() // This should pass if we pick 'c.\n+   |     ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     T: 'c + 'a,\n+   |           ++++\n+\n+error[E0700]: hidden type for `impl Cap<'b> + Cap<'c>` captures lifetime that does not appear in bounds\n+  --> $DIR/min-choice-reject-ambiguous.rs:39:5\n+   |\n+LL | fn test_ambiguous<'a, 'b, 'c>(s: &'a u8) -> impl Cap<'b> + Cap<'c>\n+   |                   -- hidden type `&'a u8` captures the lifetime `'a` as defined here\n+...\n+LL |     s\n+   |     ^\n+   |\n+help: to declare that `impl Cap<'b> + Cap<'c>` captures `'a`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn test_ambiguous<'a, 'b, 'c>(s: &'a u8) -> impl Cap<'b> + Cap<'c> + 'a\n+   |                                                                    ++++\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0309, E0700.\n+For more information about an error, try `rustc --explain E0309`."}, {"sha": "14b4dae7abfde2cfafda40e5b3bd57fd11d75476", "filename": "tests/ui/nll/member-constraints/min-choice.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fmin-choice.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,34 @@\n+// Assuming that the hidden type in these tests is `&'_#15r u8`,\n+// we have a member constraint: `'_#15r member ['static, 'a, 'b, 'c]`.\n+//\n+// Make sure we pick up the minimum non-ambiguous region among them.\n+// We will have to exclude `['b, 'c]` because they're incomparable,\n+// and then we should pick `'a` because we know `'static: 'a`.\n+\n+// check-pass\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+fn type_test<'a, T: 'a>() -> &'a u8 { &0 }\n+\n+// Basic test: make sure we don't bail out because 'b and 'c are incomparable.\n+fn basic<'a, 'b, 'c>() -> impl Cap<'a> + Cap<'b> + Cap<'c>\n+where\n+    'a: 'b,\n+    'a: 'c,\n+{\n+    &0\n+}\n+\n+// Make sure we don't pick `'static`.\n+fn test_static<'a, 'b, 'c, T>() -> impl Cap<'a> + Cap<'b> + Cap<'c>\n+where\n+    'a: 'b,\n+    'a: 'c,\n+    T: 'a,\n+{\n+    type_test::<'_, T>() // This will fail if we pick 'static\n+}\n+\n+fn main() {}"}, {"sha": "66ff828a84f7ce2459ac35d783f32cd1b6f87501", "filename": "tests/ui/nll/member-constraints/nested-impl-trait-fail.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,33 @@\n+// Nested impl-traits can impose different member constraints on the same region variable.\n+\n+// check-fail\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+// Assuming the hidden type is `[&'_#15r u8; 1]`, we have two distinct member constraints:\n+// - '_#15r member ['static, 'a, 'b] // from outer impl-trait\n+// - '_#15r member ['static, 'a, 'b] // from inner impl-trait\n+// To satisfy both we can choose 'a or 'b, so it's a failure due to ambiguity.\n+fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>\n+where\n+    's: 'a,\n+    's: 'b,\n+{\n+    [a]\n+    //~^ E0700\n+    //~| E0700\n+}\n+\n+// Same as the above but with late-bound regions.\n+fn fail_late_bound<'s, 'a, 'b>(\n+    a: &'s u8,\n+    _: &'a &'s u8,\n+    _: &'b &'s u8,\n+) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> {\n+    [a]\n+    //~^ E0700\n+    //~| E0700\n+}\n+\n+fn main() {}"}, {"sha": "6824e27ead02876ce842fa9b98f8ac4a361d3714", "filename": "tests/ui/nll/member-constraints/nested-impl-trait-fail.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-fail.stderr?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,75 @@\n+error[E0700]: hidden type for `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-impl-trait-fail.rs:17:5\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>\n+   |                     -- hidden type `[&'s u8; 1]` captures the lifetime `'s` as defined here\n+...\n+LL |     [a]\n+   |     ^^^\n+   |\n+help: to declare that `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> + 's\n+   |                                                                                                ++++\n+help: to declare that `impl Cap<'a> + Cap<'b>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b> + 's>\n+   |                                                                                               ++++\n+\n+error[E0700]: hidden type for `impl Cap<'a> + Cap<'b>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-impl-trait-fail.rs:17:5\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>\n+   |                     -- hidden type `&'s u8` captures the lifetime `'s` as defined here\n+...\n+LL |     [a]\n+   |     ^^^\n+   |\n+help: to declare that `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> + 's\n+   |                                                                                                ++++\n+help: to declare that `impl Cap<'a> + Cap<'b>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn fail_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b> + 's>\n+   |                                                                                               ++++\n+\n+error[E0700]: hidden type for `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-impl-trait-fail.rs:28:5\n+   |\n+LL | fn fail_late_bound<'s, 'a, 'b>(\n+   |                    -- hidden type `[&'s u8; 1]` captures the lifetime `'s` as defined here\n+...\n+LL |     [a]\n+   |     ^^^\n+   |\n+help: to declare that `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | ) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> + 's {\n+   |                                                       ++++\n+help: to declare that `impl Cap<'a> + Cap<'b>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | ) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b> + 's> {\n+   |                                                      ++++\n+\n+error[E0700]: hidden type for `impl Cap<'a> + Cap<'b>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-impl-trait-fail.rs:28:5\n+   |\n+LL | fn fail_late_bound<'s, 'a, 'b>(\n+   |                    -- hidden type `&'s u8` captures the lifetime `'s` as defined here\n+...\n+LL |     [a]\n+   |     ^^^\n+   |\n+help: to declare that `impl IntoIterator<Item = impl Cap<'a> + Cap<'b>>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | ) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b>> + 's {\n+   |                                                       ++++\n+help: to declare that `impl Cap<'a> + Cap<'b>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | ) -> impl IntoIterator<Item = impl Cap<'a> + Cap<'b> + 's> {\n+   |                                                      ++++\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "15540cb460e7a6a29994e374eaabbf1a4d44712b", "filename": "tests/ui/nll/member-constraints/nested-impl-trait-pass.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999ac5f7770bff68bd65f490990d32c3ec1faaa6/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fmember-constraints%2Fnested-impl-trait-pass.rs?ref=999ac5f7770bff68bd65f490990d32c3ec1faaa6", "patch": "@@ -0,0 +1,29 @@\n+// Nested impl-traits can impose different member constraints on the same region variable.\n+\n+// check-pass\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+// Assuming the hidden type is `[&'_#15r u8; 1]`, we have two distinct member constraints:\n+// - '_#15r member ['static, 'a, 'b] // from outer impl-trait\n+// - '_#15r member ['static, 'a]     // from inner impl-trait\n+// To satisfy both we can only choose 'a.\n+fn pass_early_bound<'s, 'a, 'b>(a: &'s u8) -> impl IntoIterator<Item = impl Cap<'a>> + Cap<'b>\n+where\n+    's: 'a,\n+    's: 'b,\n+{\n+    [a]\n+}\n+\n+// Same as the above but with late-bound regions.\n+fn pass_late_bound<'s, 'a, 'b>(\n+    a: &'s u8,\n+    _: &'a &'s u8,\n+    _: &'b &'s u8,\n+) -> impl IntoIterator<Item = impl Cap<'a>> + Cap<'b> {\n+    [a]\n+}\n+\n+fn main() {}"}]}