{"sha": "4bdc97c4a66eccfc3925cd691121965b08017908", "node_id": "C_kwDOAAsO6NoAKDRiZGM5N2M0YTY2ZWNjZmMzOTI1Y2Q2OTExMjE5NjViMDgwMTc5MDg", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-04T01:35:32Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-17T04:52:23Z"}, "message": "Account for auto-borrows and precedence in `redundant_slicing` lint", "tree": {"sha": "f2c5771349c323ba2a8545aa2cc2a73de4045020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2c5771349c323ba2a8545aa2cc2a73de4045020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bdc97c4a66eccfc3925cd691121965b08017908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bdc97c4a66eccfc3925cd691121965b08017908", "html_url": "https://github.com/rust-lang/rust/commit/4bdc97c4a66eccfc3925cd691121965b08017908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bdc97c4a66eccfc3925cd691121965b08017908/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faeeef3b9cd841b54ece2ff887d608d5bb54f41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/faeeef3b9cd841b54ece2ff887d608d5bb54f41c", "html_url": "https://github.com/rust-lang/rust/commit/faeeef3b9cd841b54ece2ff887d608d5bb54f41c"}], "stats": {"total": 76, "additions": 58, "deletions": 18}, "files": [{"sha": "1cc0990b283ddd91cc519ac627750591fd85c70c", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4bdc97c4a66eccfc3925cd691121965b08017908/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdc97c4a66eccfc3925cd691121965b08017908/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=4bdc97c4a66eccfc3925cd691121965b08017908", "patch": "@@ -3,9 +3,11 @@ use clippy_utils::get_parent_expr;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::{is_type_lang_item, peel_mid_ty_refs};\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::subst::GenericArg;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -57,44 +59,64 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n             then {\n                 let (expr_ty, expr_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(expr));\n                 let (indexed_ty, indexed_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(indexed));\n+                let parent_expr = get_parent_expr(cx, expr);\n+                let needs_parens_for_prefix = parent_expr.map_or(false, |parent| {\n+                    parent.precedence().order() > PREC_PREFIX\n+                });\n                 let mut app = Applicability::MachineApplicable;\n \n                 let (help, sugg) = if expr_ty == indexed_ty {\n                     if expr_ref_count > indexed_ref_count {\n+                        // Indexing takes self by reference and can't return a reference to that\n+                        // reference as it's a local variable. The only way this could happen is if\n+                        // `self` contains a reference to the `Self` type. If this occurs then the\n+                        // lint no longer applies as it's essentially a field access, which is not\n+                        // redundant.\n                         return;\n                     }\n+                    let deref_count = indexed_ref_count - expr_ref_count;\n \n                     let (reborrow_str, help_str) = if mutability == Mutability::Mut {\n                         // The slice was used to reborrow the mutable reference.\n                         (\"&mut *\", \"reborrow the original value instead\")\n                     } else if matches!(\n-                        get_parent_expr(cx, expr),\n+                        parent_expr,\n                         Some(Expr {\n                             kind: ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, _),\n                             ..\n                         })\n-                    ) {\n+                    ) || cx.typeck_results().expr_adjustments(expr).first().map_or(false, |a| {\n+                        matches!(a.kind, Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })))\n+                    }) {\n                         // The slice was used to make a temporary reference.\n                         (\"&*\", \"reborrow the original value instead\")\n-                    } else if expr_ref_count != indexed_ref_count {\n+                    } else if deref_count != 0 {\n                         (\"\", \"dereference the original value instead\")\n                     } else {\n                         (\"\", \"use the original value instead\")\n                     };\n \n                     let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n-                    (help_str, format!(\"{}{}{}\", reborrow_str, \"*\".repeat(indexed_ref_count - expr_ref_count), snip))\n+                    let sugg = if (deref_count != 0 || !reborrow_str.is_empty()) && needs_parens_for_prefix {\n+                        format!(\"({}{}{})\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                    } else {\n+                        format!(\"{}{}{}\", reborrow_str, \"*\".repeat(deref_count), snip)\n+                    };\n+\n+                    (help_str, sugg)\n                 } else if let Some(target_id) = cx.tcx.lang_items().deref_target() {\n                     if let Ok(deref_ty) = cx.tcx.try_normalize_erasing_regions(\n                         cx.param_env,\n                         cx.tcx.mk_projection(target_id, cx.tcx.mk_substs([GenericArg::from(indexed_ty)].into_iter())),\n                     ) {\n                         if deref_ty == expr_ty {\n                             let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n-                            (\n-                                \"dereference the original value instead\",\n-                                format!(\"&{}{}*{}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip),\n-                            )\n+                            let sugg = if needs_parens_for_prefix {\n+                                format!(\"(&{}{}*{})\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                            } else {\n+                                format!(\"&{}{}*{}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n+                            };\n+                            (\"dereference the original value instead\", sugg)\n                         } else {\n                             return;\n                         }"}, {"sha": "98b2adec440487769090fd6e9cb42cf3b3d1fca1", "filename": "tests/ui/redundant_slicing.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.fixed?ref=4bdc97c4a66eccfc3925cd691121965b08017908", "patch": "@@ -3,6 +3,8 @@\n #![allow(unused)]\n #![warn(clippy::redundant_slicing)]\n \n+use std::io::Read;\n+\n fn main() {\n     let slice: &[u32] = &[0];\n     let _ = slice; // Redundant slice\n@@ -37,4 +39,8 @@ fn main() {\n \n     let slice_ref = &slice;\n     let _ = *slice_ref; // Deref instead of slice\n+\n+    // Issue #7972\n+    let bytes: &[u8] = &[];\n+    let _ = (&*bytes).read_to_end(&mut vec![]).unwrap();\n }"}, {"sha": "b84a304ec674cbeb60f06e35cf83feff431fc3ec", "filename": "tests/ui/redundant_slicing.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.rs?ref=4bdc97c4a66eccfc3925cd691121965b08017908", "patch": "@@ -3,6 +3,8 @@\n #![allow(unused)]\n #![warn(clippy::redundant_slicing)]\n \n+use std::io::Read;\n+\n fn main() {\n     let slice: &[u32] = &[0];\n     let _ = &slice[..]; // Redundant slice\n@@ -37,4 +39,8 @@ fn main() {\n \n     let slice_ref = &slice;\n     let _ = &slice_ref[..]; // Deref instead of slice\n+\n+    // Issue #7972\n+    let bytes: &[u8] = &[];\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap();\n }"}, {"sha": "bce351117907870017c3214c4ed50a0bcf0fb8fc", "filename": "tests/ui/redundant_slicing.stderr", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bdc97c4a66eccfc3925cd691121965b08017908/tests%2Fui%2Fredundant_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.stderr?ref=4bdc97c4a66eccfc3925cd691121965b08017908", "patch": "@@ -1,58 +1,64 @@\n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:8:13\n+  --> $DIR/redundant_slicing.rs:10:13\n    |\n LL |     let _ = &slice[..]; // Redundant slice\n    |             ^^^^^^^^^^ help: use the original value instead: `slice`\n    |\n    = note: `-D clippy::redundant-slicing` implied by `-D warnings`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:11:13\n+  --> $DIR/redundant_slicing.rs:13:13\n    |\n LL |     let _ = &v[..]; // Deref instead of slice\n    |             ^^^^^^ help: dereference the original value instead: `&*v`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:12:13\n+  --> $DIR/redundant_slicing.rs:14:13\n    |\n LL |     let _ = &(&*v)[..]; // Outer borrow is redundant\n    |             ^^^^^^^^^^ help: use the original value instead: `(&*v)`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:15:20\n+  --> $DIR/redundant_slicing.rs:17:20\n    |\n LL |     let err = &mut &S[..]; // Should reborrow instead of slice\n    |                    ^^^^^^ help: reborrow the original value instead: `&*S`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:18:21\n+  --> $DIR/redundant_slicing.rs:20:21\n    |\n LL |     let mut_slice = &mut vec[..]; // Deref instead of slice\n    |                     ^^^^^^^^^^^^ help: dereference the original value instead: `&mut *vec`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:19:13\n+  --> $DIR/redundant_slicing.rs:21:13\n    |\n LL |     let _ = &mut mut_slice[..]; // Should reborrow instead of slice\n    |             ^^^^^^^^^^^^^^^^^^ help: reborrow the original value instead: `&mut *mut_slice`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:22:13\n+  --> $DIR/redundant_slicing.rs:24:13\n    |\n LL |     let _ = &ref_vec[..]; // Deref instead of slice\n    |             ^^^^^^^^^^^^ help: dereference the original value instead: `&**ref_vec`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:29:13\n+  --> $DIR/redundant_slicing.rs:31:13\n    |\n LL |     let _ = &m!(slice)[..];\n    |             ^^^^^^^^^^^^^^ help: use the original value instead: `slice`\n \n error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:39:13\n+  --> $DIR/redundant_slicing.rs:41:13\n    |\n LL |     let _ = &slice_ref[..]; // Deref instead of slice\n    |             ^^^^^^^^^^^^^^ help: dereference the original value instead: `*slice_ref`\n \n-error: aborting due to 9 previous errors\n+error: redundant slicing of the whole range\n+  --> $DIR/redundant_slicing.rs:45:13\n+   |\n+LL |     let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap();\n+   |             ^^^^^^^^^^^^ help: reborrow the original value instead: `(&*bytes)`\n+\n+error: aborting due to 10 previous errors\n "}]}