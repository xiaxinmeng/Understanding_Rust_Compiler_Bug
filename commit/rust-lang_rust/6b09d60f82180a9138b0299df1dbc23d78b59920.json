{"sha": "6b09d60f82180a9138b0299df1dbc23d78b59920", "node_id": "C_kwDOAAsO6NoAKDZiMDlkNjBmODIxODBhOTEzOGIwMjk5ZGYxZGJjMjNkNzhiNTk5MjA", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-18T22:48:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-18T22:48:16Z"}, "message": "Rollup merge of #103378 - nagisa:fix-infinite-offset, r=scottmcm\n\nFix mod_inv termination for the last iteration\n\nOn usize=u64 platforms, the 4th iteration would overflow the `mod_gate` back to 0. Similarly for usize=u32 platforms, the 3rd iteration would overflow much the same way.\n\nI tested various approaches to resolving this, including approaches with `saturating_mul` and `widening_mul` to a double usize. Turns out LLVM likes `mul_with_overflow` the best. In fact now, that LLVM can see the iteration count is limited, it will happily unroll the loop into a nice linear sequence.\n\nYou will also notice that the code around the loop got simplified somewhat. Now that LLVM is handling the loop nicely, there isn\u2019t any more reasons to manually unroll the first iteration out of the loop (though looking at the code today I\u2019m not sure all that complexity was necessary in the first place).\n\nFixes #103361", "tree": {"sha": "1678519e62fe742ddd42e4590e16d0f9750b71b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1678519e62fe742ddd42e4590e16d0f9750b71b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b09d60f82180a9138b0299df1dbc23d78b59920", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjeAuwCRBK7hj4Ov3rIwAAnTgIAAw8IRv9WKTqeqRumUHAg+DQ\nmefZkoOZi1XmbgmAlfsSzUrAitJsVFqHiSGDQcQk2H2rv80a/REMRxGVBftdZjKD\nlKrR/wQG87V9HzyFsl+ahrvAVTFy7iquyqRMFQdJkqtArzY11qmoWDFgKLjqAW6G\nSI+Odn/fx8/EKnEvFvrcCMDI3dyt1rMBpwOxCnmuON/RwbtJ6zHm0q27537Esf50\nNQ98+8KIXSivqrcVM6UwUHwt3t1PumSA96J4XF/X39tfjB/Zz9hl+Nxuq/122VvR\np+fHq3vDSKvRX289X9mnWbUGtT8tWPD9XX6apCGYhL830AVSdNJuvXxnuglkz3U=\n=eQWW\n-----END PGP SIGNATURE-----\n", "payload": "tree 1678519e62fe742ddd42e4590e16d0f9750b71b0\nparent 8aca6ccedd0916da959638e6d2aac610d11e79c5\nparent a3c3f722b7e71d5c9985ba318c700b697fd2c106\nauthor Manish Goregaokar <manishsmail@gmail.com> 1668811696 -0500\ncommitter GitHub <noreply@github.com> 1668811696 -0500\n\nRollup merge of #103378 - nagisa:fix-infinite-offset, r=scottmcm\n\nFix mod_inv termination for the last iteration\n\nOn usize=u64 platforms, the 4th iteration would overflow the `mod_gate` back to 0. Similarly for usize=u32 platforms, the 3rd iteration would overflow much the same way.\n\nI tested various approaches to resolving this, including approaches with `saturating_mul` and `widening_mul` to a double usize. Turns out LLVM likes `mul_with_overflow` the best. In fact now, that LLVM can see the iteration count is limited, it will happily unroll the loop into a nice linear sequence.\n\nYou will also notice that the code around the loop got simplified somewhat. Now that LLVM is handling the loop nicely, there isn\u2019t any more reasons to manually unroll the first iteration out of the loop (though looking at the code today I\u2019m not sure all that complexity was necessary in the first place).\n\nFixes #103361\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b09d60f82180a9138b0299df1dbc23d78b59920", "html_url": "https://github.com/rust-lang/rust/commit/6b09d60f82180a9138b0299df1dbc23d78b59920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b09d60f82180a9138b0299df1dbc23d78b59920/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8aca6ccedd0916da959638e6d2aac610d11e79c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aca6ccedd0916da959638e6d2aac610d11e79c5", "html_url": "https://github.com/rust-lang/rust/commit/8aca6ccedd0916da959638e6d2aac610d11e79c5"}, {"sha": "a3c3f722b7e71d5c9985ba318c700b697fd2c106", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c3f722b7e71d5c9985ba318c700b697fd2c106", "html_url": "https://github.com/rust-lang/rust/commit/a3c3f722b7e71d5c9985ba318c700b697fd2c106"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "e0ddb3154de126122588afc6e8c6f430fe33d562", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6b09d60f82180a9138b0299df1dbc23d78b59920/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09d60f82180a9138b0299df1dbc23d78b59920/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=6b09d60f82180a9138b0299df1dbc23d78b59920", "patch": "@@ -1591,8 +1591,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n-        cttz_nonzero, exact_div, unchecked_rem, unchecked_shl, unchecked_shr, unchecked_sub,\n-        wrapping_add, wrapping_mul, wrapping_sub,\n+        cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl, unchecked_shr,\n+        unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n@@ -1612,36 +1612,38 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n         const INV_TABLE_MOD: usize = 16;\n-        /// INV_TABLE_MOD\u00b2\n-        const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n-        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n         // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n         let m_minus_one = unsafe { unchecked_sub(m, 1) };\n-        if m <= INV_TABLE_MOD {\n-            table_inverse & m_minus_one\n-        } else {\n-            // We iterate \"up\" using the following formula:\n-            //\n-            // $$ xy \u2261 1 (mod 2\u207f) \u2192 xy (2 - xy) \u2261 1 (mod 2\u00b2\u207f) $$\n+        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n+        let mut mod_gate = INV_TABLE_MOD;\n+        // We iterate \"up\" using the following formula:\n+        //\n+        // $$ xy \u2261 1 (mod 2\u207f) \u2192 xy (2 - xy) \u2261 1 (mod 2\u00b2\u207f) $$\n+        //\n+        // This application needs to be applied at least until `2\u00b2\u207f \u2265 m`, at which point we can\n+        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n+        //\n+        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n+        // will always finish in at most 4 iterations.\n+        loop {\n+            // y = y * (2 - xy) mod n\n             //\n-            // until 2\u00b2\u207f \u2265 m. Then we can reduce to our desired `m` by taking the result `mod m`.\n-            let mut inverse = table_inverse;\n-            let mut going_mod = INV_TABLE_MOD_SQUARED;\n-            loop {\n-                // y = y * (2 - xy) mod n\n-                //\n-                // Note, that we use wrapping operations here intentionally \u2013 the original formula\n-                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n-                // usize::MAX` instead, because we take the result `mod n` at the end\n-                // anyway.\n-                inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n-                if going_mod >= m {\n-                    return inverse & m_minus_one;\n-                }\n-                going_mod = wrapping_mul(going_mod, going_mod);\n+            // Note, that we use wrapping operations here intentionally \u2013 the original formula\n+            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n+            // usize::MAX` instead, because we take the result `mod n` at the end\n+            // anyway.\n+            if mod_gate >= m {\n+                break;\n+            }\n+            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n+            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n+            if overflow {\n+                break;\n             }\n+            mod_gate = new_gate;\n         }\n+        inverse & m_minus_one\n     }\n \n     let addr = p.addr();"}, {"sha": "0977980ba47bf0e243c74adb4955907f67fc50b1", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b09d60f82180a9138b0299df1dbc23d78b59920/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09d60f82180a9138b0299df1dbc23d78b59920/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=6b09d60f82180a9138b0299df1dbc23d78b59920", "patch": "@@ -455,6 +455,18 @@ fn align_offset_various_strides() {\n     assert!(!x);\n }\n \n+#[test]\n+fn align_offset_issue_103361() {\n+    #[cfg(target_pointer_width = \"64\")]\n+    const SIZE: usize = 1 << 47;\n+    #[cfg(target_pointer_width = \"32\")]\n+    const SIZE: usize = 1 << 30;\n+    #[cfg(target_pointer_width = \"16\")]\n+    const SIZE: usize = 1 << 13;\n+    struct HugeSize([u8; SIZE - 1]);\n+    let _ = (SIZE as *const HugeSize).align_offset(SIZE);\n+}\n+\n #[test]\n fn offset_from() {\n     let mut a = [0; 5];"}]}