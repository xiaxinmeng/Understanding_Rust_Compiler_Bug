{"sha": "6ea27010b5e648ce6ca9405b732ff548d53f02a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYTI3MDEwYjVlNjQ4Y2U2Y2E5NDA1YjczMmZmNTQ4ZDUzZjAyYTQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-05T04:44:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-05T04:44:45Z"}, "message": "Rollup merge of #70752 - yoshuawuyts:slice_fill, r=dtolnay\n\nAdd slice::fill\n\nAdds the `slice::fill` method to fill a slice with an item. This replaces manual for loops where items are copied one-by-one. This is a counterpart to C++20's [`std::fill`](https://en.cppreference.com/w/cpp/algorithm/fill) function.\n\n## Usage\n\n```rust\nlet mut buf = vec![0; 10];\nbuf.fill(1);\nassert_eq!(buf, vec![1; 10]);\n```\n\n## Performance\n\nWhen compiling in release mode, for `[u8]` and `[u16]` this method will optimize to a `memset(3)` call ([godbolt](https://godbolt.org/z/85El_c)). The initial implementation relies on LLVM's optimizer to make it as fast as possible for any given input. But as @jonas-schievink [pointed out](https://twitter.com/sheevink/status/1245756597453885442) this can later be optimized through specialization to guarantee it has a specific performance profile.\n\n## Why now?\n\nConversations about adding `slice::fill` are not new. In fact, https://github.com/rust-lang/rfcs/issues/2067 was opened 3 years ago about this exact topic. However discussion stranded while discussing implementation details, and it's not seen much forward motion since.\n\nIn [\"The Hunt for the Fastest Zero\"](https://travisdowns.github.io/blog/2020/01/20/zero.html) Travis Downs provides disects C++'s `std::fill` performance profile on gcc, comparing it among others to `memset(3)`. Even though `memset(3)` outperforms `std::fill` in their tests, the author notes the following:\n\n>  That the optimization fails, perhaps unexpectedly, in some cases is unfortunate but it\u2019s nice that you can fix it yourself. [...] Do we throw out modern C++ idioms, at least where performance matters, for example by replacing std::fill with memset? I don\u2019t think so.\n\nMuch of the article focuses on how how to fix the performance of `std::fill` by providing specializations for specific input. In Rust we don't have any dedicated methods to fill slices with values, so it either needs to be optimized at the MIR layer, or more likely rely on LLVM's optimizer.\n\nBy adding a dedicated method for filling slices with values it opens up the ability for us to in the future guarantee that e.g. `Vec<u8>` will always optimize to `memset` even in debug mode. Or perhaps provide stronger guarantees about memory when zeroing values when a certain flag is passed. But regardless of that, it improves general ergonomics of working with slices by providing a dedicated method with documentation and examples.\n\n## References\n- [slice-fill prototype on docs.rs](https://docs.rs/slice-fill/1.0.1/slice_fill/)\n- [The Hunt For The Fastest Zero](https://travisdowns.github.io/blog/2020/01/20/zero.html)\n- [Safe memset for slices](https://github.com/rust-lang/rfcs/issues/2067)\n- [C++20 std::fill](https://en.cppreference.com/w/cpp/algorithm/fill)\n- [ASM output on Godbolt](https://godbolt.org/z/5-XU66)", "tree": {"sha": "34e108109eee74f8a5500fff645404cc42143bf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e108109eee74f8a5500fff645404cc42143bf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ea27010b5e648ce6ca9405b732ff548d53f02a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeiWI+CRBK7hj4Ov3rIwAAdHIIAKWEBbIwiL5muPiKkoDYX5AF\netF9AGwSj+ZN8Muedn4DyoZk21hsJi+iXt8JXZZExFUriCMiufbjKQQpTj6z7Z0R\nNkspFCtHZ8S74J52pukagJ92uADEE3DQGXiI8ccp2vTCTh5T9+zQSD12fYf2P0fO\ndpHRibCi4fH8rEAufvbIIg749ZVys++DlRrJXn6PoJDgNGJZZy1UodnaYQPVVef8\ncIjqMKLCwuSYCjuUggM2YuiI58FrBQQWQCFyyCiONzVsHd3AFgdVDqHN6qdfPHNk\niAb0u3IsiqeMDIq3zBVMOWPXuWOXs7Usj/GskkDGo38C5DCZXkiryg7sJVdUFMk=\n=etHi\n-----END PGP SIGNATURE-----\n", "payload": "tree 34e108109eee74f8a5500fff645404cc42143bf1\nparent 630414db422acb3bdf09e08e23d563c4981764fd\nparent edabceb4a3f0149323c381d5c75fe6957385addf\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586061885 +0200\ncommitter GitHub <noreply@github.com> 1586061885 +0200\n\nRollup merge of #70752 - yoshuawuyts:slice_fill, r=dtolnay\n\nAdd slice::fill\n\nAdds the `slice::fill` method to fill a slice with an item. This replaces manual for loops where items are copied one-by-one. This is a counterpart to C++20's [`std::fill`](https://en.cppreference.com/w/cpp/algorithm/fill) function.\n\n## Usage\n\n```rust\nlet mut buf = vec![0; 10];\nbuf.fill(1);\nassert_eq!(buf, vec![1; 10]);\n```\n\n## Performance\n\nWhen compiling in release mode, for `[u8]` and `[u16]` this method will optimize to a `memset(3)` call ([godbolt](https://godbolt.org/z/85El_c)). The initial implementation relies on LLVM's optimizer to make it as fast as possible for any given input. But as @jonas-schievink [pointed out](https://twitter.com/sheevink/status/1245756597453885442) this can later be optimized through specialization to guarantee it has a specific performance profile.\n\n## Why now?\n\nConversations about adding `slice::fill` are not new. In fact, https://github.com/rust-lang/rfcs/issues/2067 was opened 3 years ago about this exact topic. However discussion stranded while discussing implementation details, and it's not seen much forward motion since.\n\nIn [\"The Hunt for the Fastest Zero\"](https://travisdowns.github.io/blog/2020/01/20/zero.html) Travis Downs provides disects C++'s `std::fill` performance profile on gcc, comparing it among others to `memset(3)`. Even though `memset(3)` outperforms `std::fill` in their tests, the author notes the following:\n\n>  That the optimization fails, perhaps unexpectedly, in some cases is unfortunate but it\u2019s nice that you can fix it yourself. [...] Do we throw out modern C++ idioms, at least where performance matters, for example by replacing std::fill with memset? I don\u2019t think so.\n\nMuch of the article focuses on how how to fix the performance of `std::fill` by providing specializations for specific input. In Rust we don't have any dedicated methods to fill slices with values, so it either needs to be optimized at the MIR layer, or more likely rely on LLVM's optimizer.\n\nBy adding a dedicated method for filling slices with values it opens up the ability for us to in the future guarantee that e.g. `Vec<u8>` will always optimize to `memset` even in debug mode. Or perhaps provide stronger guarantees about memory when zeroing values when a certain flag is passed. But regardless of that, it improves general ergonomics of working with slices by providing a dedicated method with documentation and examples.\n\n## References\n- [slice-fill prototype on docs.rs](https://docs.rs/slice-fill/1.0.1/slice_fill/)\n- [The Hunt For The Fastest Zero](https://travisdowns.github.io/blog/2020/01/20/zero.html)\n- [Safe memset for slices](https://github.com/rust-lang/rfcs/issues/2067)\n- [C++20 std::fill](https://en.cppreference.com/w/cpp/algorithm/fill)\n- [ASM output on Godbolt](https://godbolt.org/z/5-XU66)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea27010b5e648ce6ca9405b732ff548d53f02a4", "html_url": "https://github.com/rust-lang/rust/commit/6ea27010b5e648ce6ca9405b732ff548d53f02a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ea27010b5e648ce6ca9405b732ff548d53f02a4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "630414db422acb3bdf09e08e23d563c4981764fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/630414db422acb3bdf09e08e23d563c4981764fd", "html_url": "https://github.com/rust-lang/rust/commit/630414db422acb3bdf09e08e23d563c4981764fd"}, {"sha": "edabceb4a3f0149323c381d5c75fe6957385addf", "url": "https://api.github.com/repos/rust-lang/rust/commits/edabceb4a3f0149323c381d5c75fe6957385addf", "html_url": "https://github.com/rust-lang/rust/commit/edabceb4a3f0149323c381d5c75fe6957385addf"}], "stats": {"total": 24, "additions": 24, "deletions": 0}, "files": [{"sha": "66aad3246183f5ee39f5de92d6a8ac150a19268f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ea27010b5e648ce6ca9405b732ff548d53f02a4/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea27010b5e648ce6ca9405b732ff548d53f02a4/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6ea27010b5e648ce6ca9405b732ff548d53f02a4", "patch": "@@ -23,6 +23,7 @@\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n+use crate::borrow::Borrow;\n use crate::cmp;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::fmt;\n@@ -2145,6 +2146,29 @@ impl<T> [T] {\n         }\n     }\n \n+    /// Fills `self` with elements by cloning `value`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_fill)]\n+    ///\n+    /// let mut buf = vec![0; 10];\n+    /// buf.fill(1);\n+    /// assert_eq!(buf, vec![1; 10]);\n+    /// ```\n+    #[unstable(feature = \"slice_fill\", issue = \"70758\")]\n+    pub fn fill<V>(&mut self, value: V)\n+    where\n+        V: Borrow<T>,\n+        T: Clone,\n+    {\n+        let value = value.borrow();\n+        for el in self {\n+            el.clone_from(value)\n+        }\n+    }\n+\n     /// Copies the elements from `src` into `self`.\n     ///\n     /// The length of `src` must be the same as `self`."}]}