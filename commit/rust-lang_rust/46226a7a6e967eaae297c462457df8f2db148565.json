{"sha": "46226a7a6e967eaae297c462457df8f2db148565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MjI2YTdhNmU5NjdlYWFlMjk3YzQ2MjQ1N2RmOGYyZGIxNDg1NjU=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2016-08-23T20:09:59Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2016-08-23T20:09:59Z"}, "message": "Yield Err in char::decode_utf8 per Unicode, like String::from_utf8_lossy", "tree": {"sha": "b141f3912cf5ad8b9813e5e0f1cb5f9756b4cd4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b141f3912cf5ad8b9813e5e0f1cb5f9756b4cd4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46226a7a6e967eaae297c462457df8f2db148565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46226a7a6e967eaae297c462457df8f2db148565", "html_url": "https://github.com/rust-lang/rust/commit/46226a7a6e967eaae297c462457df8f2db148565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46226a7a6e967eaae297c462457df8f2db148565/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892bf3d41d8f1b5c26f19fd0f20edd1584c958a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/892bf3d41d8f1b5c26f19fd0f20edd1584c958a1", "html_url": "https://github.com/rust-lang/rust/commit/892bf3d41d8f1b5c26f19fd0f20edd1584c958a1"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "070ad739fd76fdab94d6f3ed35e815b211e61405", "filename": "src/libcore/char.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/46226a7a6e967eaae297c462457df8f2db148565/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46226a7a6e967eaae297c462457df8f2db148565/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=46226a7a6e967eaae297c462457df8f2db148565", "patch": "@@ -737,25 +737,81 @@ pub struct InvalidSequence(());\n impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n     type Item = Result<char, InvalidSequence>;\n     #[inline]\n+\n     fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|b| {\n-            if b & 0x80 == 0 { Ok(b as char) } else {\n-                let l = (!b).leading_zeros() as usize; // number of bytes in UTF-8 representation\n-                if l < 2 || l > 6 { return Err(InvalidSequence(())) };\n-                let mut x = (b as u32) & (0x7F >> l);\n-                for _ in 0..l-1 {\n+        self.0.next().map(|first_byte| {\n+            // Emit InvalidSequence according to\n+            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n+            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n+\n+            // Roughly: consume at least one byte,\n+            // then validate one byte at a time and stop before the first unexpected byte\n+            // (which might be the valid start of the next byte sequence).\n+\n+            let mut code_point;\n+            macro_rules! first_byte {\n+                ($mask: expr) => {\n+                    code_point = u32::from(first_byte & $mask)\n+                }\n+            }\n+            macro_rules! continuation_byte {\n+                () => { continuation_byte!(0x80...0xBF) };\n+                ($range: pat) => {\n                     match self.0.peek() {\n-                        Some(&b) if b & 0xC0 == 0x80 => {\n+                        Some(&byte @ $range) => {\n+                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n                             self.0.next();\n-                            x = (x << 6) | (b as u32) & 0x3F;\n-                        },\n-                        _ => return Err(InvalidSequence(())),\n+                        }\n+                        _ => return Err(InvalidSequence(()))\n                     }\n                 }\n-                match from_u32(x) {\n-                    Some(x) if l == x.len_utf8() => Ok(x),\n-                    _ => Err(InvalidSequence(())),\n+            }\n+\n+            match first_byte {\n+                0x00...0x7F => {\n+                    first_byte!(0b1111_1111);\n+                }\n+                0xC2...0xDF => {\n+                    first_byte!(0b0001_1111);\n+                    continuation_byte!();\n+                }\n+                0xE0 => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n+                    continuation_byte!();\n                 }\n+                0xE1...0xEC | 0xEE...0xEF => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xED => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n+                    continuation_byte!();\n+                }\n+                0xF0 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF1...0xF3 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF4 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n+            }\n+            unsafe {\n+                Ok(from_u32_unchecked(code_point))\n             }\n         })\n     }"}, {"sha": "333503d738943b10cd74584cfb34c1119eed4579", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46226a7a6e967eaae297c462457df8f2db148565/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46226a7a6e967eaae297c462457df8f2db148565/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=46226a7a6e967eaae297c462457df8f2db148565", "patch": "@@ -367,12 +367,13 @@ fn test_decode_utf8() {\n             assert_eq!(s, $expected_str,\n                        \"input bytes: {:?}, expected str: {:?}, result: {:?}\",\n                        input_bytes, $expected_str, s);\n+            assert_eq!(String::from_utf8_lossy(&$input_bytes), $expected_str);\n         }\n     }\n \n     assert_decode_utf8!([], \"\");\n     assert_decode_utf8!([0x41], \"A\");\n-    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\");\n+    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\ufffd\");\n     assert_decode_utf8!([0xE2, 0x99, 0xA5], \"\u2665\");\n     assert_decode_utf8!([0xE2, 0x99, 0xA5, 0x41], \"\u2665A\");\n     assert_decode_utf8!([0xE2, 0x99], \"\ufffd\");\n@@ -385,4 +386,22 @@ fn test_decode_utf8() {\n     assert_decode_utf8!([0xFE, 0x41], \"\ufffdA\");\n     assert_decode_utf8!([0xFF], \"\ufffd\");\n     assert_decode_utf8!([0xFF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xC0, 0x80], \"\ufffd\ufffd\");\n+\n+    // Surrogates\n+    assert_decode_utf8!([0xED, 0x9F, 0xBF], \"\\u{D7FF}\");\n+    assert_decode_utf8!([0xED, 0xA0, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xED, 0xBF, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xEE, 0x80, 0x80], \"\\u{E000}\");\n+\n+    // char::MAX\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0xBF], \"\\u{10FFFF}\");\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xF4, 0x90, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\");\n+\n+    // 5 and 6 bytes sequence\n+    // Part of the original design of UTF-8,\n+    // but invalid now that UTF-8 is artificially restricted to match the range of UTF-16.\n+    assert_decode_utf8!([0xF8, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xFC, 0x80, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n }"}]}