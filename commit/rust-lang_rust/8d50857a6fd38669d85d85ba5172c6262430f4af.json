{"sha": "8d50857a6fd38669d85d85ba5172c6262430f4af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTA4NTdhNmZkMzg2NjlkODVkODViYTUxNzJjNjI2MjQzMGY0YWY=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2016-12-29T15:55:29Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2016-12-29T20:10:03Z"}, "message": "Check *all* errors in LLVMRustArchiveIterator* API\n\nIncrementing the `Archive::child_iterator` fetches and validates the next child.\nThis can trigger an error, which we previously checked on the *next* call to `LLVMRustArchiveIteratorNext()`.\nThis means we ignore the last error if we stop iterating halfway through.\nThis is harmless (we don't access the child, after all) but LLVM 4.0 calls `abort()` if *any* error goes unchecked, even a success value.\nThis means that basically any rustc invocation that opens an archive and searches through it would die.\n\nThe solution implemented here is to change the order of operations, such that\nadvancing the iterator and fetching the newly-validated iterator happens in the same `Next()` call.\nThis keeps the error handling behavior as before but ensures all `Error`s get checked.", "tree": {"sha": "ab08a5ac1dc2416adfb1b15f4865034278f683d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab08a5ac1dc2416adfb1b15f4865034278f683d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d50857a6fd38669d85d85ba5172c6262430f4af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d50857a6fd38669d85d85ba5172c6262430f4af", "html_url": "https://github.com/rust-lang/rust/commit/8d50857a6fd38669d85d85ba5172c6262430f4af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d50857a6fd38669d85d85ba5172c6262430f4af/comments", "author": null, "committer": null, "parents": [{"sha": "c74ac6cb97ae77429258c3bff2938714f6a329ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/c74ac6cb97ae77429258c3bff2938714f6a329ca", "html_url": "https://github.com/rust-lang/rust/commit/c74ac6cb97ae77429258c3bff2938714f6a329ca"}], "stats": {"total": 35, "additions": 26, "deletions": 9}, "files": [{"sha": "7304f384c61d601b771a18b4de0c784443e48e0c", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8d50857a6fd38669d85d85ba5172c6262430f4af/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8d50857a6fd38669d85d85ba5172c6262430f4af/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=8d50857a6fd38669d85d85ba5172c6262430f4af", "patch": "@@ -33,12 +33,15 @@ struct RustArchiveMember {\n \n \n struct RustArchiveIterator {\n+    bool first;\n     Archive::child_iterator cur;\n     Archive::child_iterator end;\n #if LLVM_VERSION_GE(3, 9)\n     Error err;\n \n-    RustArchiveIterator() : err(Error::success()) { }\n+    RustArchiveIterator() : first(true), err(Error::success()) { }\n+#else\n+    RustArchiveIterator() : first(true) { }\n #endif\n };\n \n@@ -120,6 +123,7 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n     rai->cur = ar->child_begin(rai->err);\n     if (rai->err) {\n         LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+        delete rai;\n         return NULL;\n     }\n #endif\n@@ -129,27 +133,40 @@ LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n \n extern \"C\" LLVMRustArchiveChildConstRef\n LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n+    if (rai->cur == rai->end) return nullptr;\n+\n+    // Advancing the iterator validates the next child, and this can\n+    // uncover an error. LLVM requires that we check all Errors,\n+    // so we only advance the iterator if we actually need to fetch\n+    // the next child.\n+    // This means we must not advance the iterator in the *first* call,\n+    // but instead advance it *before* fetching the child in all later calls.\n+    if (!rai->first) {\n+        ++rai->cur;\n #if LLVM_VERSION_GE(3, 9)\n-    if (rai->err) {\n-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-        return NULL;\n-    }\n+        if (rai->err) {\n+            LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+            return nullptr;\n+        }\n #endif\n-    if (rai->cur == rai->end)\n-        return NULL;\n+    } else {\n+      rai->first = false;\n+    }\n+\n+    if (rai->cur == rai->end) return nullptr;\n+\n #if LLVM_VERSION_EQ(3, 8)\n     const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n     if (!*cur) {\n         LLVMRustSetLastError(cur->getError().message().c_str());\n-        return NULL;\n+        return nullptr;\n     }\n     const Archive::Child &child = cur->get();\n #else\n     const Archive::Child &child = *rai->cur.operator->();\n #endif\n     Archive::Child *ret = new Archive::Child(child);\n \n-    ++rai->cur;\n     return ret;\n }\n "}]}