{"sha": "9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMzljYjFkOGU3NDFjNWRmYTZlYzI4NDk0Y2QxNjYzOTVlMjZiNjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T11:17:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T11:17:26Z"}, "message": "Rollup merge of #67367 - 0dvictor:options, r=Centril\n\nMove command line option definitions into a dedicated file\n\nconfig.rs has reached the 3000 line tidy limit, this commit moves command line option definitions into a new file - options.rs,  and leaves the rest of configuration infrastructure in config.rs.", "tree": {"sha": "ed957579c5c9d1e93499d496b43c44f4112f1572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed957579c5c9d1e93499d496b43c44f4112f1572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/K3GCRBK7hj4Ov3rIwAAdHIIACT3miz6fgvjOQlw51D7jhbp\nzpfcf6OaVii1SX8brwCFtyq1iWMu8IVFbhziiWpcbA9wIiUBVykXdxeJoGNrEhBc\nG3+LP9+k61qWqb+ZaOfzzvP/6oZrUfkLHH5RCpx2b2yANVx5Ris8OYbUuwnAW5Bc\ntVrEd6Eok9NGkrkY1EYrouNd+x5v2f5YyUQdP4JEYjw6iYc3FdjvXWNfa+66a21O\nlITzJK/jP1X5mEzcZua+RfVIm0aW9iaTQAuNWQi+1AljYHHHzYHW5gD2EWrQ5tOq\nAaGl+Unu8kSLyaSZul72xnpefNGND67WaXCi178jwC7SgBbKvXMbibsO2mzCk8A=\n=LE0/\n-----END PGP SIGNATURE-----\n", "payload": "tree ed957579c5c9d1e93499d496b43c44f4112f1572\nparent efd31c23e84a8208303edd3bc2045616a1dec8cc\nparent 83fc600a28044f8384bbce437c3251620f869254\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576840646 +0100\ncommitter GitHub <noreply@github.com> 1576840646 +0100\n\nRollup merge of #67367 - 0dvictor:options, r=Centril\n\nMove command line option definitions into a dedicated file\n\nconfig.rs has reached the 3000 line tidy limit, this commit moves command line option definitions into a new file - options.rs,  and leaves the rest of configuration infrastructure in config.rs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "html_url": "https://github.com/rust-lang/rust/commit/9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efd31c23e84a8208303edd3bc2045616a1dec8cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/efd31c23e84a8208303edd3bc2045616a1dec8cc", "html_url": "https://github.com/rust-lang/rust/commit/efd31c23e84a8208303edd3bc2045616a1dec8cc"}, {"sha": "83fc600a28044f8384bbce437c3251620f869254", "url": "https://api.github.com/repos/rust-lang/rust/commits/83fc600a28044f8384bbce437c3251620f869254", "html_url": "https://github.com/rust-lang/rust/commit/83fc600a28044f8384bbce437c3251620f869254"}], "stats": {"total": 1893, "additions": 957, "deletions": 936}, "files": [{"sha": "55e647729e97f31397c71b9182d1e0998d2ee8d6", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 3, "deletions": 936, "changes": 939, "blob_url": "https://github.com/rust-lang/rust/blob/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "patch": "@@ -1,8 +1,8 @@\n-// ignore-tidy-filelength\n-\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n+pub use crate::options::*;\n+\n use crate::lint;\n use crate::utils::NativeLibraryKind;\n use crate::{early_error, early_warn, Session};\n@@ -11,7 +11,6 @@ use crate::search_paths::SearchPath;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::impl_stable_hash_via_hash;\n \n-use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n \n use syntax_pos::source_map::{FileName, FilePathMapping};\n@@ -31,8 +30,6 @@ use std::collections::btree_map::{\n };\n use std::fmt;\n use std::str::{self, FromStr};\n-use std::hash::Hasher;\n-use std::collections::hash_map::DefaultHasher;\n use std::iter::{self, FromIterator};\n use std::path::{Path, PathBuf};\n \n@@ -382,131 +379,6 @@ impl ExternEntry {\n     }\n }\n \n-macro_rules! hash_option {\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n-        if $sub_hashes.insert(stringify!($opt_name),\n-                              $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n-            panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n-        }\n-    });\n-}\n-\n-macro_rules! top_level_options {\n-    (pub struct Options { $(\n-        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n-    )* } ) => (\n-        #[derive(Clone)]\n-        pub struct Options {\n-            $(pub $opt: $t),*\n-        }\n-\n-        impl Options {\n-            pub fn dep_tracking_hash(&self) -> u64 {\n-                let mut sub_hashes = BTreeMap::new();\n-                $({\n-                    hash_option!($opt,\n-                                 &self.$opt,\n-                                 &mut sub_hashes,\n-                                 [$dep_tracking_marker $($warn_val,\n-                                                         $warn_text,\n-                                                         self.error_format)*]);\n-                })*\n-                let mut hasher = DefaultHasher::new();\n-                dep_tracking::stable_hash(sub_hashes,\n-                                          &mut hasher,\n-                                          self.error_format);\n-                hasher.finish()\n-            }\n-        }\n-    );\n-}\n-\n-// The top-level command-line options struct.\n-//\n-// For each option, one has to specify how it behaves with regard to the\n-// dependency tracking system of incremental compilation. This is done via the\n-// square-bracketed directive after the field type. The options are:\n-//\n-// [TRACKED]\n-// A change in the given field will cause the compiler to completely clear the\n-// incremental compilation cache before proceeding.\n-//\n-// [UNTRACKED]\n-// Incremental compilation is not influenced by this option.\n-//\n-// If you add a new option to this struct or one of the sub-structs like\n-// `CodegenOptions`, think about how it influences incremental compilation. If in\n-// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n-// unnecessary re-compilation.\n-top_level_options!(\n-    pub struct Options {\n-        // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process.\n-        crate_types: Vec<CrateType> [TRACKED],\n-        optimize: OptLevel [TRACKED],\n-        // Include the `debug_assertions` flag in dependency tracking, since it\n-        // can influence whether overflow checks are done or not.\n-        debug_assertions: bool [TRACKED],\n-        debuginfo: DebugInfo [TRACKED],\n-        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n-        lint_cap: Option<lint::Level> [TRACKED],\n-        describe_lints: bool [UNTRACKED],\n-        output_types: OutputTypes [TRACKED],\n-        search_paths: Vec<SearchPath> [UNTRACKED],\n-        libs: Vec<(String, Option<String>, Option<NativeLibraryKind>)> [TRACKED],\n-        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n-\n-        target_triple: TargetTriple [TRACKED],\n-\n-        test: bool [TRACKED],\n-        error_format: ErrorOutputType [UNTRACKED],\n-\n-        // If `Some`, enable incremental compilation, using the given\n-        // directory to store intermediate results.\n-        incremental: Option<PathBuf> [UNTRACKED],\n-\n-        debugging_opts: DebuggingOptions [TRACKED],\n-        prints: Vec<PrintRequest> [UNTRACKED],\n-        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n-        // version of `debugging_opts.borrowck`, which is just a plain string.\n-        borrowck_mode: BorrowckMode [UNTRACKED],\n-        cg: CodegenOptions [TRACKED],\n-        externs: Externs [UNTRACKED],\n-        crate_name: Option<String> [TRACKED],\n-        // An optional name to use as the crate for std during std injection,\n-        // written `extern crate name as std`. Defaults to `std`. Used by\n-        // out-of-tree drivers.\n-        alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features.\n-        unstable_features: UnstableFeatures [TRACKED],\n-\n-        // Indicates whether this run of the compiler is actually rustdoc. This\n-        // is currently just a hack and will be removed eventually, so please\n-        // try to not rely on this too much.\n-        actually_rustdoc: bool [TRACKED],\n-\n-        // Specifications of codegen units / ThinLTO which are forced as a\n-        // result of parsing command line options. These are not necessarily\n-        // what rustc was invoked with, but massaged a bit to agree with\n-        // commands like `--emit llvm-ir` which they're often incompatible with\n-        // if we otherwise use the defaults of rustc.\n-        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n-        cli_forced_thinlto_off: bool [UNTRACKED],\n-\n-        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n-        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n-\n-        edition: Edition [TRACKED],\n-\n-        // `true` if we're emitting JSON blobs about each artifact produced\n-        // by the compiler.\n-        json_artifact_notifications: bool [TRACKED],\n-\n-        pretty: Option<PpMode> [UNTRACKED],\n-    }\n-);\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PrintRequest {\n     FileNames,\n@@ -767,811 +639,6 @@ impl Passes {\n     }\n }\n \n-/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n-/// macro is to define an interface that can be programmatically used by the option parser\n-/// to initialize the struct without hardcoding field names all over the place.\n-///\n-/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n-/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n-/// generated code to parse an option into its respective field in the struct. There are a few\n-/// hand-written parsers for parsing specific types of values in this module.\n-macro_rules! options {\n-    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n-     $buildfn:ident, $prefix:expr, $outputname:expr,\n-     $stat:ident, $mod_desc:ident, $mod_set:ident,\n-     $($opt:ident : $t:ty = (\n-        $init:expr,\n-        $parse:ident,\n-        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n-        $desc:expr)\n-     ),* ,) =>\n-(\n-    #[derive(Clone)]\n-    pub struct $struct_name { $(pub $opt: $t),* }\n-\n-    pub fn $defaultfn() -> $struct_name {\n-        $struct_name { $($opt: $init),* }\n-    }\n-\n-    pub fn $buildfn(matches: &getopts::Matches, error_format: ErrorOutputType) -> $struct_name\n-    {\n-        let mut op = $defaultfn();\n-        for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(2, '=');\n-            let key = iter.next().unwrap();\n-            let value = iter.next();\n-            let option_to_lookup = key.replace(\"-\", \"_\");\n-            let mut found = false;\n-            for &(candidate, setter, opt_type_desc, _) in $stat {\n-                if option_to_lookup != candidate { continue }\n-                if !setter(&mut op, value) {\n-                    match (value, opt_type_desc) {\n-                        (Some(..), None) => {\n-                            early_error(error_format, &format!(\"{} option `{}` takes no \\\n-                                                                value\", $outputname, key))\n-                        }\n-                        (None, Some(type_desc)) => {\n-                            early_error(error_format, &format!(\"{0} option `{1}` requires \\\n-                                                                {2} ({3} {1}=<value>)\",\n-                                                               $outputname, key,\n-                                                               type_desc, $prefix))\n-                        }\n-                        (Some(value), Some(type_desc)) => {\n-                            early_error(error_format, &format!(\"incorrect value `{}` for {} \\\n-                                                                option `{}` - {} was expected\",\n-                                                               value, $outputname,\n-                                                               key, type_desc))\n-                        }\n-                        (None, None) => panic!()\n-                    }\n-                }\n-                found = true;\n-                break;\n-            }\n-            if !found {\n-                early_error(error_format, &format!(\"unknown {} option: `{}`\",\n-                                                   $outputname, key));\n-            }\n-        }\n-        return op;\n-    }\n-\n-    impl dep_tracking::DepTrackingHash for $struct_name {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n-            let mut sub_hashes = BTreeMap::new();\n-            $({\n-                hash_option!($opt,\n-                             &self.$opt,\n-                             &mut sub_hashes,\n-                             [$dep_tracking_marker $($dep_warn_val,\n-                                                     $dep_warn_text,\n-                                                     error_format)*]);\n-            })*\n-            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n-        }\n-    }\n-\n-    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n-    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n-        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n-\n-    #[allow(non_upper_case_globals, dead_code)]\n-    mod $mod_desc {\n-        pub const parse_bool: Option<&str> = None;\n-        pub const parse_opt_bool: Option<&str> =\n-            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n-        pub const parse_string: Option<&str> = Some(\"a string\");\n-        pub const parse_string_push: Option<&str> = Some(\"a string\");\n-        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n-        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n-        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n-        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n-        pub const parse_threads: Option<&str> = Some(\"a number\");\n-        pub const parse_uint: Option<&str> = Some(\"a number\");\n-        pub const parse_passes: Option<&str> =\n-            Some(\"a space-separated list of passes, or `all`\");\n-        pub const parse_opt_uint: Option<&str> =\n-            Some(\"a number\");\n-        pub const parse_panic_strategy: Option<&str> =\n-            Some(\"either `unwind` or `abort`\");\n-        pub const parse_relro_level: Option<&str> =\n-            Some(\"one of: `full`, `partial`, or `off`\");\n-        pub const parse_sanitizer: Option<&str> =\n-            Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n-        pub const parse_sanitizer_list: Option<&str> =\n-            Some(\"comma separated list of sanitizers\");\n-        pub const parse_sanitizer_memory_track_origins: Option<&str> = None;\n-        pub const parse_linker_flavor: Option<&str> =\n-            Some(::rustc_target::spec::LinkerFlavor::one_of());\n-        pub const parse_optimization_fuel: Option<&str> =\n-            Some(\"crate=integer\");\n-        pub const parse_unpretty: Option<&str> =\n-            Some(\"`string` or `string=string`\");\n-        pub const parse_treat_err_as_bug: Option<&str> =\n-            Some(\"either no value or a number bigger than 0\");\n-        pub const parse_lto: Option<&str> =\n-            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n-                  `fat`, or omitted\");\n-        pub const parse_linker_plugin_lto: Option<&str> =\n-            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n-                  or the path to the linker plugin\");\n-        pub const parse_switch_with_opt_path: Option<&str> =\n-            Some(\"an optional path to the profiling data output directory\");\n-        pub const parse_merge_functions: Option<&str> =\n-            Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n-        pub const parse_symbol_mangling_version: Option<&str> =\n-            Some(\"either `legacy` or `v0` (RFC 2603)\");\n-    }\n-\n-    #[allow(dead_code)]\n-    mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n-            SymbolManglingVersion};\n-        use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n-        use std::path::PathBuf;\n-        use std::str::FromStr;\n-\n-        $(\n-            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n-                $parse(&mut cg.$opt, v)\n-            }\n-        )*\n-\n-        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                Some(..) => false,\n-                None => { *slot = true; true }\n-            }\n-        }\n-\n-        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s {\n-                        \"n\" | \"no\" | \"off\" => {\n-                            *slot = Some(false);\n-                        }\n-                        \"y\" | \"yes\" | \"on\" => {\n-                            *slot = Some(true);\n-                        }\n-                        _ => { return false; }\n-                    }\n-\n-                    true\n-                },\n-                None => { *slot = Some(true); true }\n-            }\n-        }\n-\n-        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(s.to_string()); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.to_string(); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(s.to_string()); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(PathBuf::from(s)); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    slot.extend(s.split_whitespace().map(|s| s.to_string()));\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split(',').map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(0) => { *slot = ::num_cpus::get(); true },\n-                Some(i) => { *slot = i; true },\n-                None => false\n-            }\n-        }\n-\n-        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(i) => { *slot = i; true },\n-                None => false\n-            }\n-        }\n-\n-        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n-                None => { *slot = None; false }\n-            }\n-        }\n-\n-        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"all\") => {\n-                    *slot = Passes::All;\n-                    true\n-                }\n-                v => {\n-                    let mut passes = vec![];\n-                    if parse_list(&mut passes, v) {\n-                        *slot = Passes::Some(passes);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n-                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n-                _ => return false\n-            }\n-            true\n-        }\n-\n-        fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s.parse::<RelroLevel>() {\n-                        Ok(level) => *slot = Some(level),\n-                        _ => return false\n-                    }\n-                },\n-                _ => return false\n-            }\n-            true\n-        }\n-\n-        fn parse_sanitizer(slot: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n-            if let Some(Ok(s)) =  v.map(str::parse) {\n-                *slot = Some(s);\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        fn parse_sanitizer_list(slot: &mut Vec<Sanitizer>, v: Option<&str>) -> bool {\n-            if let Some(v) = v {\n-                for s in v.split(',').map(str::parse) {\n-                    if let Ok(s) = s {\n-                        if !slot.contains(&s) {\n-                            slot.push(s);\n-                        }\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.map(|s| s.parse()) {\n-                None => {\n-                    *slot = 2;\n-                    true\n-                }\n-                Some(Ok(i)) if i <= 2 => {\n-                    *slot = i;\n-                    true\n-                }\n-                _ => {\n-                    false\n-                }\n-            }\n-        }\n-\n-        fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n-            match v.and_then(LinkerFlavor::from_str) {\n-                Some(lf) => *slote = Some(lf),\n-                _ => return false,\n-            }\n-            true\n-        }\n-\n-        fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) => {\n-                    let parts = s.split('=').collect::<Vec<_>>();\n-                    if parts.len() != 2 { return false; }\n-                    let crate_name = parts[0].to_string();\n-                    let fuel = parts[1].parse::<u64>();\n-                    if fuel.is_err() { return false; }\n-                    *slot = Some((crate_name, fuel.unwrap()));\n-                    true\n-                }\n-            }\n-        }\n-\n-        fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) if s.split('=').count() <= 2 => {\n-                    *slot = Some(s.to_string());\n-                    true\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n-                None => { *slot = Some(1); true }\n-            }\n-        }\n-\n-        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LtoCli::Yes\n-                    } else {\n-                        LtoCli::No\n-                    };\n-                    return true\n-                }\n-            }\n-\n-            *slot = match v {\n-                None => LtoCli::NoParam,\n-                Some(\"thin\") => LtoCli::Thin,\n-                Some(\"fat\") => LtoCli::Fat,\n-                Some(_) => return false,\n-            };\n-            true\n-        }\n-\n-        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LinkerPluginLto::LinkerPluginAuto\n-                    } else {\n-                        LinkerPluginLto::Disabled\n-                    };\n-                    return true\n-                }\n-            }\n-\n-            *slot = match v {\n-                None => LinkerPluginLto::LinkerPluginAuto,\n-                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n-            };\n-            true\n-        }\n-\n-        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n-            *slot = match v {\n-                None => SwitchWithOptPath::Enabled(None),\n-                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n-            };\n-            true\n-        }\n-\n-        fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n-                Some(mergefunc) => *slot = Some(mergefunc),\n-                _ => return false,\n-            }\n-            true\n-        }\n-\n-        fn parse_symbol_mangling_version(\n-            slot: &mut SymbolManglingVersion,\n-            v: Option<&str>,\n-        ) -> bool {\n-            *slot = match v {\n-                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n-                Some(\"v0\") => SymbolManglingVersion::V0,\n-                _ => return false,\n-            };\n-            true\n-        }\n-    }\n-) }\n-\n-options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n-          build_codegen_options, \"C\", \"codegen\",\n-          CG_OPTIONS, cg_type_desc, cgsetters,\n-    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"this option is deprecated and does nothing\"),\n-    linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n-        \"system linker to link outputs with\"),\n-    link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n-        \"a single extra argument to append to the linker invocation (can be used several times)\"),\n-    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n-        \"extra arguments to append to the linker invocation (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n-        \"perform LLVM link-time optimizations\"),\n-    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"select target processor (`rustc --print target-cpus` for details)\"),\n-    target_feature: String = (String::new(), parse_string, [TRACKED],\n-        \"target specific attributes. (`rustc --print target-features` for details). \\\n-        This feature is unsafe.\"),\n-    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"a list of arguments to pass to LLVM (space separated)\"),\n-    save_temps: bool = (false, parse_bool, [UNTRACKED],\n-        \"save all temporary output files during compilation\"),\n-    rpath: bool = (false, parse_bool, [UNTRACKED],\n-        \"set rpath values in libs/exes\"),\n-    overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"use overflow checks for integer arithmetic\"),\n-    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n-        \"don't pre-populate the pass manager with a list of passes\"),\n-    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n-        \"don't run the loop vectorization optimization passes\"),\n-    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n-        \"don't run LLVM's SLP vectorization pass\"),\n-    soft_float: bool = (false, parse_bool, [TRACKED],\n-        \"use soft float ABI (*eabihf targets only)\"),\n-    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n-        \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n-        \"use an external assembler rather than LLVM's integrated one\"),\n-    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"disable the use of the redzone\"),\n-    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the relocation model to use (`rustc --print relocation-models` for details)\"),\n-    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the code model to use (`rustc --print code-models` for details)\"),\n-    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"metadata to mangle symbol names with\"),\n-    extra_filename: String = (String::new(), parse_string, [UNTRACKED],\n-        \"extra data to put in each output filename\"),\n-    codegen_units: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n-        \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (Passes::Some(Vec::new()), parse_passes, [UNTRACKED],\n-        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n-    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"the `--no-stack-check` flag is deprecated and does nothing\"),\n-    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-        \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n-         2 = full debug info with variable and type information\"),\n-    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"optimize with possible levels 0-3, s, or z\"),\n-    force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"force use of the frame pointers\"),\n-    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"explicitly enable the `cfg(debug_assertions)` directive\"),\n-    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-        \"set the threshold for inlining a function (default: 225)\"),\n-    panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n-        [TRACKED], \"panic strategy to compile crate with\"),\n-    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"enable incremental compilation\"),\n-    default_linker_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n-        \"allow the linker to link its default libraries\"),\n-    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n-                                           \"linker flavor\"),\n-    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n-        parse_linker_plugin_lto, [TRACKED],\n-        \"generate build artifacts that are compatible with linker-based LTO.\"),\n-    profile_generate: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n-        parse_switch_with_opt_path, [TRACKED],\n-        \"compile the program with profiling instrumentation\"),\n-    profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n-        \"use the given `.profdata` file for profile-guided optimization\"),\n-}\n-\n-options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n-          build_debugging_options, \"Z\", \"debugging\",\n-          DB_OPTIONS, db_type_desc, dbsetters,\n-    codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the backend to use\"),\n-    verbose: bool = (false, parse_bool, [UNTRACKED],\n-        \"in general, enable more debug printouts\"),\n-    span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n-        \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n-    identify_regions: bool = (false, parse_bool, [UNTRACKED],\n-        \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n-    borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"select which borrowck is used (`mir` or `migrate`)\"),\n-    time_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of each rustc pass\"),\n-    time: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of rustc processes\"),\n-    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of each LLVM pass\"),\n-    input_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather statistics about the input\"),\n-    asm_comments: bool = (false, parse_bool, [TRACKED],\n-        \"generate comments into the assembly (may change behavior)\"),\n-    verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n-        \"verify LLVM IR\"),\n-    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather borrowck statistics\"),\n-    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n-        \"omit landing pads for unwinding\"),\n-    fewer_names: bool = (false, parse_bool, [TRACKED],\n-        \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR)\"),\n-    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather metadata statistics\"),\n-    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the arguments passed to the linker\"),\n-    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"prints the LLVM optimization passes being run\"),\n-    ast_json: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the AST as JSON and halt\"),\n-    // We default to 1 here since we want to behave like\n-    // a sequential compiler for now. This'll likely be adjusted\n-    // in the future. Note that -Zthreads=0 is the way to get\n-    // the num_cpus behavior.\n-    threads: usize = (1, parse_threads, [UNTRACKED],\n-        \"use a thread pool with N threads\"),\n-    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the pre-expansion AST as JSON and halt\"),\n-    ls: bool = (false, parse_bool, [UNTRACKED],\n-        \"list the symbols defined by a library crate\"),\n-    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information, in \\\n-         addition to normal output\"),\n-    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"prints region inference graph. \\\n-         Use with RUST_REGION_GRAPH=help for more info\"),\n-    parse_only: bool = (false, parse_bool, [UNTRACKED],\n-        \"parse only; do not compile, assemble, or link\"),\n-    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n-        \"load proc macros for both target and host, but only link to the target\"),\n-    no_codegen: bool = (false, parse_bool, [TRACKED],\n-        \"run all passes except codegen; no output\"),\n-    treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n-        \"treat error number `val` that occurs as bug\"),\n-    report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n-        \"immediately print bugs registered with `delay_span_bug`\"),\n-    external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n-        \"show macro backtraces even for non-local macros\"),\n-    teach: bool = (false, parse_bool, [TRACKED],\n-        \"show extended diagnostic help\"),\n-    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n-        \"set the current terminal width\"),\n-    panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n-        \"support compiling tests with panic=abort\"),\n-    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n-        \"attempt to recover from parse errors (experimental)\"),\n-    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n-        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n-    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"enable incremental compilation (experimental)\"),\n-    incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n-        \"enable incremental compilation support for queries (experimental)\"),\n-    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n-        \"print high-level information about incremental reuse (or the lack thereof)\"),\n-    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n-        \"dump hash information in textual format to stdout\"),\n-    incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n-        \"verify incr. comp. hashes of green query instances\"),\n-    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n-        \"ignore spans during ICH computation -- used for testing\"),\n-    instrument_mcount: bool = (false, parse_bool, [TRACKED],\n-        \"insert function instrument code for mcount-based tracing\"),\n-    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n-    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"enable queries of the dependency graph for regression testing\"),\n-    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"parse and expand the source, but run no analysis\"),\n-    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n-        \"adds unstable command line options to rustc interface\"),\n-    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"force overflow checks on or off\"),\n-    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n-        \"for every macro invocation, print its name and arguments\"),\n-    debug_macros: bool = (false, parse_bool, [TRACKED],\n-        \"emit line numbers debug info inside macros\"),\n-    generate_arange_section: bool = (true, parse_bool, [TRACKED],\n-        \"generate DWARF address ranges for faster lookups\"),\n-    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't clear the hygiene data after analysis\"),\n-    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n-        \"keep the AST after lowering it to HIR\"),\n-    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"show spans for compiler debugging (expr|pat|ty)\"),\n-    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n-        \"print layout information for each type encountered\"),\n-    print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"print the result of the monomorphization collection pass\"),\n-    mir_opt_level: usize = (1, parse_uint, [TRACKED],\n-        \"set the MIR optimization level (0-3, default: 1)\"),\n-    mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"emit noalias metadata for mutable references (default: no)\"),\n-    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"dump MIR state to file.\n-        `val` is used to select which passes and functions to dump. For example:\n-        `all` matches all passes and functions,\n-        `foo` matches all passes for functions whose name contains 'foo',\n-        `foo & ConstProp` only the 'ConstProp' pass for function names containing 'foo',\n-        `foo | bar` all passes for function names containing 'foo' or 'bar'.\"),\n-\n-    dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n-        \"the directory the MIR is dumped into\"),\n-    dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n-        \"in addition to `.mir` files, create graphviz `.dot` files\"),\n-    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n-        \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n-    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n-        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n-    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some performance-related statistics\"),\n-    query_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some statistics about the query system\"),\n-    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some statistics about AST and HIR\"),\n-    always_encode_mir: bool = (false, parse_bool, [TRACKED],\n-        \"encode MIR of all functions into the crate metadata\"),\n-    json_rendered: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"describes how to render the `rendered` field of json diagnostics\"),\n-    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n-        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n-    osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n-        \"pass `-install_name @rpath/...` to the macOS linker\"),\n-    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n-                                    \"use a sanitizer\"),\n-    sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n-        \"Enable recovery for selected sanitizers\"),\n-    sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n-        \"Enable origins tracking in MemorySanitizer\"),\n-    fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n-        \"set the optimization fuel quota for a crate\"),\n-    print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"make rustc print the total optimization fuel used by a crate\"),\n-    force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n-        \"force all crates to be `rustc_private` unstable\"),\n-    pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n-        \"a single extra argument to prepend the linker invocation (can be used several times)\"),\n-    pre_link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n-        \"extra arguments to prepend to the linker invocation (space separated)\"),\n-    profile: bool = (false, parse_bool, [TRACKED],\n-                     \"insert profiling code\"),\n-    disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n-        \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n-    relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n-        \"choose which RELRO level to use\"),\n-    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n-                       \"dump facts from NLL analysis into side files\"),\n-    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n-        \"in match codegen, do not include FakeRead statements (used by mir-borrowck)\"),\n-    dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n-        \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting).\"),\n-    polonius: bool = (false, parse_bool, [UNTRACKED],\n-        \"enable polonius-based borrow-checker\"),\n-    codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n-    thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"enable ThinLTO when possible\"),\n-    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"control whether `#[inline]` functions are in all CGUs\"),\n-    tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n-    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n-        \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n-         the max/min integer respectively, and NaN is mapped to 0\"),\n-    human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n-        \"generate human-readable, predictable names for codegen units\"),\n-    dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],\n-        \"in dep-info output, omit targets for tracking dependencies of the dep-info files \\\n-         themselves\"),\n-    unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n-        \"present the input source, unstable (and less-pretty) variants;\n-        valid types are any of the types for `--pretty`, as well as:\n-        `expanded`, `expanded,identified`,\n-        `expanded,hygiene` (with internal representations),\n-        `everybody_loops` (all function bodies replaced with `loop {}`),\n-        `hir` (the HIR), `hir,identified`,\n-        `hir,typed` (HIR with types for each node),\n-        `hir-tree` (dump the raw HIR),\n-        `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n-    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"run `dsymutil` and delete intermediate object files\"),\n-    ui_testing: bool = (false, parse_bool, [UNTRACKED],\n-        \"format compiler diagnostics in a way that's better suitable for UI testing\"),\n-    embed_bitcode: bool = (false, parse_bool, [TRACKED],\n-        \"embed LLVM bitcode in object files\"),\n-    strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n-    share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"make the current crate share its generic instantiations\"),\n-    chalk: bool = (false, parse_bool, [TRACKED],\n-        \"enable the experimental Chalk-based trait solving engine\"),\n-    no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n-    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n-    no_interleave_lints: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't interleave execution of lints; allows benchmarking individual lints\"),\n-    crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n-        \"inject the given attribute in the crate\"),\n-    self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n-        parse_switch_with_opt_path, [UNTRACKED],\n-        \"run the self profiler and output the raw event data\"),\n-    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n-        \"specifies which kinds of events get recorded by the self profiler\"),\n-    emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n-        \"emits a section containing stack size metadata\"),\n-    plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-          \"whether to use the PLT when calling into shared libraries;\n-          only has effect for PIC code on systems with ELF binaries\n-          (default: PLT is disabled if full relro is enabled)\"),\n-    merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n-        \"control the operation of the MergeFunctions LLVM pass, taking\n-         the same values as the target option of the same name\"),\n-    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n-        \"only allow the listed language features to be enabled in code (space separated)\"),\n-    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n-        parse_symbol_mangling_version, [TRACKED],\n-        \"which mangling version to use for symbol names\"),\n-    binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n-        \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n-    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n-        \"fix undefined behavior when a thread doesn't eventually make progress \\\n-         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n-}\n-\n pub const fn default_lib_output() -> CrateType {\n     CrateType::Rlib\n }\n@@ -2953,7 +2020,7 @@ impl PpMode {\n /// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n-mod dep_tracking {\n+crate mod dep_tracking {\n     use crate::lint;\n     use crate::utils::NativeLibraryKind;\n     use std::collections::BTreeMap;"}, {"sha": "39e997a3b91accf3d2345cb212c60b5f5f03bd7a", "filename": "src/librustc_session/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flib.rs?ref=9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "patch": "@@ -1,3 +1,4 @@\n+#![feature(crate_visibility_modifier)]\n #![feature(test)]\n \n // Use the test crate here so we depend on getopts through it. This allow tools to link to both\n@@ -13,7 +14,9 @@ pub mod node_id;\n pub mod parse;\n \n mod code_stats;\n+#[macro_use]\n pub mod config;\n+mod options;\n pub mod filesearch;\n pub mod search_paths;\n "}, {"sha": "9ddc9c0d602af4967fdc208514c1f1837baaa70d", "filename": "src/librustc_session/options.rs", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f39cb1d8e741c5dfa6ec28494cd166395e26b63/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=9f39cb1d8e741c5dfa6ec28494cd166395e26b63", "patch": "@@ -0,0 +1,951 @@\n+use crate::config::*;\n+\n+use crate::lint;\n+use crate::utils::NativeLibraryKind;\n+use crate::early_error;\n+use crate::search_paths::SearchPath;\n+\n+use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n+use rustc_target::spec::TargetTriple;\n+\n+use syntax_pos::edition::Edition;\n+use rustc_feature::UnstableFeatures;\n+\n+use getopts;\n+\n+use std::collections::BTreeMap;\n+\n+use std::str;\n+use std::hash::Hasher;\n+use std::collections::hash_map::DefaultHasher;\n+use std::path::PathBuf;\n+\n+macro_rules! hash_option {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n+        if $sub_hashes.insert(stringify!($opt_name),\n+                              $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n+            panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+        }\n+    });\n+}\n+\n+macro_rules! top_level_options {\n+    (pub struct Options { $(\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+    )* } ) => (\n+        #[derive(Clone)]\n+        pub struct Options {\n+            $(pub $opt: $t),*\n+        }\n+\n+        impl Options {\n+            pub fn dep_tracking_hash(&self) -> u64 {\n+                let mut sub_hashes = BTreeMap::new();\n+                $({\n+                    hash_option!($opt,\n+                                 &self.$opt,\n+                                 &mut sub_hashes,\n+                                 [$dep_tracking_marker $($warn_val,\n+                                                         $warn_text,\n+                                                         self.error_format)*]);\n+                })*\n+                let mut hasher = DefaultHasher::new();\n+                dep_tracking::stable_hash(sub_hashes,\n+                                          &mut hasher,\n+                                          self.error_format);\n+                hasher.finish()\n+            }\n+        }\n+    );\n+}\n+\n+// The top-level command-line options struct.\n+//\n+// For each option, one has to specify how it behaves with regard to the\n+// dependency tracking system of incremental compilation. This is done via the\n+// square-bracketed directive after the field type. The options are:\n+//\n+// [TRACKED]\n+// A change in the given field will cause the compiler to completely clear the\n+// incremental compilation cache before proceeding.\n+//\n+// [UNTRACKED]\n+// Incremental compilation is not influenced by this option.\n+//\n+// If you add a new option to this struct or one of the sub-structs like\n+// `CodegenOptions`, think about how it influences incremental compilation. If in\n+// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n+// unnecessary re-compilation.\n+top_level_options!(\n+    pub struct Options {\n+        // The crate config requested for the session, which may be combined\n+        // with additional crate configurations during the compile process.\n+        crate_types: Vec<CrateType> [TRACKED],\n+        optimize: OptLevel [TRACKED],\n+        // Include the `debug_assertions` flag in dependency tracking, since it\n+        // can influence whether overflow checks are done or not.\n+        debug_assertions: bool [TRACKED],\n+        debuginfo: DebugInfo [TRACKED],\n+        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n+        lint_cap: Option<lint::Level> [TRACKED],\n+        describe_lints: bool [UNTRACKED],\n+        output_types: OutputTypes [TRACKED],\n+        search_paths: Vec<SearchPath> [UNTRACKED],\n+        libs: Vec<(String, Option<String>, Option<NativeLibraryKind>)> [TRACKED],\n+        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n+\n+        target_triple: TargetTriple [TRACKED],\n+\n+        test: bool [TRACKED],\n+        error_format: ErrorOutputType [UNTRACKED],\n+\n+        // If `Some`, enable incremental compilation, using the given\n+        // directory to store intermediate results.\n+        incremental: Option<PathBuf> [UNTRACKED],\n+\n+        debugging_opts: DebuggingOptions [TRACKED],\n+        prints: Vec<PrintRequest> [UNTRACKED],\n+        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n+        // version of `debugging_opts.borrowck`, which is just a plain string.\n+        borrowck_mode: BorrowckMode [UNTRACKED],\n+        cg: CodegenOptions [TRACKED],\n+        externs: Externs [UNTRACKED],\n+        crate_name: Option<String> [TRACKED],\n+        // An optional name to use as the crate for std during std injection,\n+        // written `extern crate name as std`. Defaults to `std`. Used by\n+        // out-of-tree drivers.\n+        alt_std_name: Option<String> [TRACKED],\n+        // Indicates how the compiler should treat unstable features.\n+        unstable_features: UnstableFeatures [TRACKED],\n+\n+        // Indicates whether this run of the compiler is actually rustdoc. This\n+        // is currently just a hack and will be removed eventually, so please\n+        // try to not rely on this too much.\n+        actually_rustdoc: bool [TRACKED],\n+\n+        // Specifications of codegen units / ThinLTO which are forced as a\n+        // result of parsing command line options. These are not necessarily\n+        // what rustc was invoked with, but massaged a bit to agree with\n+        // commands like `--emit llvm-ir` which they're often incompatible with\n+        // if we otherwise use the defaults of rustc.\n+        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n+        cli_forced_thinlto_off: bool [UNTRACKED],\n+\n+        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n+        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n+\n+        edition: Edition [TRACKED],\n+\n+        // `true` if we're emitting JSON blobs about each artifact produced\n+        // by the compiler.\n+        json_artifact_notifications: bool [TRACKED],\n+\n+        pretty: Option<PpMode> [UNTRACKED],\n+    }\n+);\n+\n+/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n+/// macro is to define an interface that can be programmatically used by the option parser\n+/// to initialize the struct without hardcoding field names all over the place.\n+///\n+/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n+/// generated code to parse an option into its respective field in the struct. There are a few\n+/// hand-written parsers for parsing specific types of values in this module.\n+macro_rules! options {\n+    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n+     $buildfn:ident, $prefix:expr, $outputname:expr,\n+     $stat:ident, $mod_desc:ident, $mod_set:ident,\n+     $($opt:ident : $t:ty = (\n+        $init:expr,\n+        $parse:ident,\n+        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        $desc:expr)\n+     ),* ,) =>\n+(\n+    #[derive(Clone)]\n+    pub struct $struct_name { $(pub $opt: $t),* }\n+\n+    pub fn $defaultfn() -> $struct_name {\n+        $struct_name { $($opt: $init),* }\n+    }\n+\n+    pub fn $buildfn(matches: &getopts::Matches, error_format: ErrorOutputType) -> $struct_name\n+    {\n+        let mut op = $defaultfn();\n+        for option in matches.opt_strs($prefix) {\n+            let mut iter = option.splitn(2, '=');\n+            let key = iter.next().unwrap();\n+            let value = iter.next();\n+            let option_to_lookup = key.replace(\"-\", \"_\");\n+            let mut found = false;\n+            for &(candidate, setter, opt_type_desc, _) in $stat {\n+                if option_to_lookup != candidate { continue }\n+                if !setter(&mut op, value) {\n+                    match (value, opt_type_desc) {\n+                        (Some(..), None) => {\n+                            early_error(error_format, &format!(\"{} option `{}` takes no \\\n+                                                                value\", $outputname, key))\n+                        }\n+                        (None, Some(type_desc)) => {\n+                            early_error(error_format, &format!(\"{0} option `{1}` requires \\\n+                                                                {2} ({3} {1}=<value>)\",\n+                                                               $outputname, key,\n+                                                               type_desc, $prefix))\n+                        }\n+                        (Some(value), Some(type_desc)) => {\n+                            early_error(error_format, &format!(\"incorrect value `{}` for {} \\\n+                                                                option `{}` - {} was expected\",\n+                                                               value, $outputname,\n+                                                               key, type_desc))\n+                        }\n+                        (None, None) => panic!()\n+                    }\n+                }\n+                found = true;\n+                break;\n+            }\n+            if !found {\n+                early_error(error_format, &format!(\"unknown {} option: `{}`\",\n+                                                   $outputname, key));\n+            }\n+        }\n+        return op;\n+    }\n+\n+    impl dep_tracking::DepTrackingHash for $struct_name {\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+            let mut sub_hashes = BTreeMap::new();\n+            $({\n+                hash_option!($opt,\n+                             &self.$opt,\n+                             &mut sub_hashes,\n+                             [$dep_tracking_marker $($dep_warn_val,\n+                                                     $dep_warn_text,\n+                                                     error_format)*]);\n+            })*\n+            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+        }\n+    }\n+\n+    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n+    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n+        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n+\n+    #[allow(non_upper_case_globals, dead_code)]\n+    mod $mod_desc {\n+        pub const parse_bool: Option<&str> = None;\n+        pub const parse_opt_bool: Option<&str> =\n+            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n+        pub const parse_string: Option<&str> = Some(\"a string\");\n+        pub const parse_string_push: Option<&str> = Some(\"a string\");\n+        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n+        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n+        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n+        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n+        pub const parse_threads: Option<&str> = Some(\"a number\");\n+        pub const parse_uint: Option<&str> = Some(\"a number\");\n+        pub const parse_passes: Option<&str> =\n+            Some(\"a space-separated list of passes, or `all`\");\n+        pub const parse_opt_uint: Option<&str> =\n+            Some(\"a number\");\n+        pub const parse_panic_strategy: Option<&str> =\n+            Some(\"either `unwind` or `abort`\");\n+        pub const parse_relro_level: Option<&str> =\n+            Some(\"one of: `full`, `partial`, or `off`\");\n+        pub const parse_sanitizer: Option<&str> =\n+            Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n+        pub const parse_sanitizer_list: Option<&str> =\n+            Some(\"comma separated list of sanitizers\");\n+        pub const parse_sanitizer_memory_track_origins: Option<&str> = None;\n+        pub const parse_linker_flavor: Option<&str> =\n+            Some(::rustc_target::spec::LinkerFlavor::one_of());\n+        pub const parse_optimization_fuel: Option<&str> =\n+            Some(\"crate=integer\");\n+        pub const parse_unpretty: Option<&str> =\n+            Some(\"`string` or `string=string`\");\n+        pub const parse_treat_err_as_bug: Option<&str> =\n+            Some(\"either no value or a number bigger than 0\");\n+        pub const parse_lto: Option<&str> =\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n+                  `fat`, or omitted\");\n+        pub const parse_linker_plugin_lto: Option<&str> =\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n+                  or the path to the linker plugin\");\n+        pub const parse_switch_with_opt_path: Option<&str> =\n+            Some(\"an optional path to the profiling data output directory\");\n+        pub const parse_merge_functions: Option<&str> =\n+            Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n+        pub const parse_symbol_mangling_version: Option<&str> =\n+            Some(\"either `legacy` or `v0` (RFC 2603)\");\n+    }\n+\n+    #[allow(dead_code)]\n+    mod $mod_set {\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+            SymbolManglingVersion};\n+        use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n+        use std::path::PathBuf;\n+        use std::str::FromStr;\n+\n+        $(\n+            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n+                $parse(&mut cg.$opt, v)\n+            }\n+        )*\n+\n+        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+            match v {\n+                Some(..) => false,\n+                None => { *slot = true; true }\n+            }\n+        }\n+\n+        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s {\n+                        \"n\" | \"no\" | \"off\" => {\n+                            *slot = Some(false);\n+                        }\n+                        \"y\" | \"yes\" | \"on\" => {\n+                            *slot = Some(true);\n+                        }\n+                        _ => { return false; }\n+                    }\n+\n+                    true\n+                },\n+                None => { *slot = Some(true); true }\n+            }\n+        }\n+\n+        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(s.to_string()); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.to_string(); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(s.to_string()); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    slot.extend(s.split_whitespace().map(|s| s.to_string()));\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split(',').map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.and_then(|s| s.parse().ok()) {\n+                Some(0) => { *slot = ::num_cpus::get(); true },\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n+\n+        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.and_then(|s| s.parse().ok()) {\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n+\n+        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n+                None => { *slot = None; false }\n+            }\n+        }\n+\n+        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"all\") => {\n+                    *slot = Passes::All;\n+                    true\n+                }\n+                v => {\n+                    let mut passes = vec![];\n+                    if parse_list(&mut passes, v) {\n+                        *slot = Passes::Some(passes);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n+                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n+                _ => return false\n+            }\n+            true\n+        }\n+\n+        fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s.parse::<RelroLevel>() {\n+                        Ok(level) => *slot = Some(level),\n+                        _ => return false\n+                    }\n+                },\n+                _ => return false\n+            }\n+            true\n+        }\n+\n+        fn parse_sanitizer(slot: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(Ok(s)) =  v.map(str::parse) {\n+                *slot = Some(s);\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_list(slot: &mut Vec<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(v) = v {\n+                for s in v.split(',').map(str::parse) {\n+                    if let Ok(s) = s {\n+                        if !slot.contains(&s) {\n+                            slot.push(s);\n+                        }\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.map(|s| s.parse()) {\n+                None => {\n+                    *slot = 2;\n+                    true\n+                }\n+                Some(Ok(i)) if i <= 2 => {\n+                    *slot = i;\n+                    true\n+                }\n+                _ => {\n+                    false\n+                }\n+            }\n+        }\n+\n+        fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n+            match v.and_then(LinkerFlavor::from_str) {\n+                Some(lf) => *slote = Some(lf),\n+                _ => return false,\n+            }\n+            true\n+        }\n+\n+        fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n+            match v {\n+                None => false,\n+                Some(s) => {\n+                    let parts = s.split('=').collect::<Vec<_>>();\n+                    if parts.len() != 2 { return false; }\n+                    let crate_name = parts[0].to_string();\n+                    let fuel = parts[1].parse::<u64>();\n+                    if fuel.is_err() { return false; }\n+                    *slot = Some((crate_name, fuel.unwrap()));\n+                    true\n+                }\n+            }\n+        }\n+\n+        fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+            match v {\n+                None => false,\n+                Some(s) if s.split('=').count() <= 2 => {\n+                    *slot = Some(s.to_string());\n+                    true\n+                }\n+                _ => false,\n+            }\n+        }\n+\n+        fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n+                None => { *slot = Some(1); true }\n+            }\n+        }\n+\n+        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        LtoCli::Yes\n+                    } else {\n+                        LtoCli::No\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            *slot = match v {\n+                None => LtoCli::NoParam,\n+                Some(\"thin\") => LtoCli::Thin,\n+                Some(\"fat\") => LtoCli::Fat,\n+                Some(_) => return false,\n+            };\n+            true\n+        }\n+\n+        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        LinkerPluginLto::LinkerPluginAuto\n+                    } else {\n+                        LinkerPluginLto::Disabled\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            *slot = match v {\n+                None => LinkerPluginLto::LinkerPluginAuto,\n+                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n+            };\n+            true\n+        }\n+\n+        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n+            *slot = match v {\n+                None => SwitchWithOptPath::Enabled(None),\n+                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n+            };\n+            true\n+        }\n+\n+        fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n+            match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n+                Some(mergefunc) => *slot = Some(mergefunc),\n+                _ => return false,\n+            }\n+            true\n+        }\n+\n+        fn parse_symbol_mangling_version(\n+            slot: &mut SymbolManglingVersion,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n+                Some(\"v0\") => SymbolManglingVersion::V0,\n+                _ => return false,\n+            };\n+            true\n+        }\n+    }\n+) }\n+\n+options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n+          build_codegen_options, \"C\", \"codegen\",\n+          CG_OPTIONS, cg_type_desc, cgsetters,\n+    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"this option is deprecated and does nothing\"),\n+    linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n+        \"system linker to link outputs with\"),\n+    link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to append to the linker invocation (can be used several times)\"),\n+    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n+        \"extra arguments to append to the linker invocation (space separated)\"),\n+    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n+    lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n+        \"perform LLVM link-time optimizations\"),\n+    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"select target processor (`rustc --print target-cpus` for details)\"),\n+    target_feature: String = (String::new(), parse_string, [TRACKED],\n+        \"target specific attributes. (`rustc --print target-features` for details). \\\n+        This feature is unsafe.\"),\n+    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"a list of extra LLVM passes to run (space separated)\"),\n+    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"a list of arguments to pass to LLVM (space separated)\"),\n+    save_temps: bool = (false, parse_bool, [UNTRACKED],\n+        \"save all temporary output files during compilation\"),\n+    rpath: bool = (false, parse_bool, [UNTRACKED],\n+        \"set rpath values in libs/exes\"),\n+    overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use overflow checks for integer arithmetic\"),\n+    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n+        \"don't pre-populate the pass manager with a list of passes\"),\n+    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n+        \"don't run the loop vectorization optimization passes\"),\n+    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n+        \"don't run LLVM's SLP vectorization pass\"),\n+    soft_float: bool = (false, parse_bool, [TRACKED],\n+        \"use soft float ABI (*eabihf targets only)\"),\n+    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n+        \"prefer dynamic linking to static linking\"),\n+    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n+        \"use an external assembler rather than LLVM's integrated one\"),\n+    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"disable the use of the redzone\"),\n+    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the relocation model to use (`rustc --print relocation-models` for details)\"),\n+    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the code model to use (`rustc --print code-models` for details)\"),\n+    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"metadata to mangle symbol names with\"),\n+    extra_filename: String = (String::new(), parse_string, [UNTRACKED],\n+        \"extra data to put in each output filename\"),\n+    codegen_units: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"divide crate into N units to optimize in parallel\"),\n+    remark: Passes = (Passes::Some(Vec::new()), parse_passes, [UNTRACKED],\n+        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n+    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"the `--no-stack-check` flag is deprecated and does nothing\"),\n+    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n+        \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n+         2 = full debug info with variable and type information\"),\n+    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"optimize with possible levels 0-3, s, or z\"),\n+    force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"force use of the frame pointers\"),\n+    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"explicitly enable the `cfg(debug_assertions)` directive\"),\n+    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n+        \"set the threshold for inlining a function (default: 225)\"),\n+    panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n+        [TRACKED], \"panic strategy to compile crate with\"),\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"enable incremental compilation\"),\n+    default_linker_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n+        \"allow the linker to link its default libraries\"),\n+    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n+                                           \"linker flavor\"),\n+    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n+        parse_linker_plugin_lto, [TRACKED],\n+        \"generate build artifacts that are compatible with linker-based LTO.\"),\n+    profile_generate: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [TRACKED],\n+        \"compile the program with profiling instrumentation\"),\n+    profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"use the given `.profdata` file for profile-guided optimization\"),\n+}\n+\n+options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n+          build_debugging_options, \"Z\", \"debugging\",\n+          DB_OPTIONS, db_type_desc, dbsetters,\n+    codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"the backend to use\"),\n+    verbose: bool = (false, parse_bool, [UNTRACKED],\n+        \"in general, enable more debug printouts\"),\n+    span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n+        \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n+    identify_regions: bool = (false, parse_bool, [UNTRACKED],\n+        \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"select which borrowck is used (`mir` or `migrate`)\"),\n+    time_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of each rustc pass\"),\n+    time: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of rustc processes\"),\n+    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of each LLVM pass\"),\n+    input_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather statistics about the input\"),\n+    asm_comments: bool = (false, parse_bool, [TRACKED],\n+        \"generate comments into the assembly (may change behavior)\"),\n+    verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n+        \"verify LLVM IR\"),\n+    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather borrowck statistics\"),\n+    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n+        \"omit landing pads for unwinding\"),\n+    fewer_names: bool = (false, parse_bool, [TRACKED],\n+        \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR)\"),\n+    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather metadata statistics\"),\n+    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the arguments passed to the linker\"),\n+    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"prints the LLVM optimization passes being run\"),\n+    ast_json: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the AST as JSON and halt\"),\n+    // We default to 1 here since we want to behave like\n+    // a sequential compiler for now. This'll likely be adjusted\n+    // in the future. Note that -Zthreads=0 is the way to get\n+    // the num_cpus behavior.\n+    threads: usize = (1, parse_threads, [UNTRACKED],\n+        \"use a thread pool with N threads\"),\n+    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the pre-expansion AST as JSON and halt\"),\n+    ls: bool = (false, parse_bool, [UNTRACKED],\n+        \"list the symbols defined by a library crate\"),\n+    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n+        \"write syntax and type analysis (in JSON format) information, in \\\n+         addition to normal output\"),\n+    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"prints region inference graph. \\\n+         Use with RUST_REGION_GRAPH=help for more info\"),\n+    parse_only: bool = (false, parse_bool, [UNTRACKED],\n+        \"parse only; do not compile, assemble, or link\"),\n+    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n+        \"load proc macros for both target and host, but only link to the target\"),\n+    no_codegen: bool = (false, parse_bool, [TRACKED],\n+        \"run all passes except codegen; no output\"),\n+    treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n+        \"treat error number `val` that occurs as bug\"),\n+    report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n+        \"immediately print bugs registered with `delay_span_bug`\"),\n+    external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n+        \"show macro backtraces even for non-local macros\"),\n+    teach: bool = (false, parse_bool, [TRACKED],\n+        \"show extended diagnostic help\"),\n+    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"set the current terminal width\"),\n+    panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n+        \"support compiling tests with panic=abort\"),\n+    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n+        \"attempt to recover from parse errors (experimental)\"),\n+    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n+        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"enable incremental compilation (experimental)\"),\n+    incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n+        \"enable incremental compilation support for queries (experimental)\"),\n+    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n+        \"print high-level information about incremental reuse (or the lack thereof)\"),\n+    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump hash information in textual format to stdout\"),\n+    incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n+        \"verify incr. comp. hashes of green query instances\"),\n+    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n+        \"ignore spans during ICH computation -- used for testing\"),\n+    instrument_mcount: bool = (false, parse_bool, [TRACKED],\n+        \"insert function instrument code for mcount-based tracing\"),\n+    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n+    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"enable queries of the dependency graph for regression testing\"),\n+    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n+        \"parse and expand the source, but run no analysis\"),\n+    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n+        \"adds unstable command line options to rustc interface\"),\n+    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"force overflow checks on or off\"),\n+    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n+        \"for every macro invocation, print its name and arguments\"),\n+    debug_macros: bool = (false, parse_bool, [TRACKED],\n+        \"emit line numbers debug info inside macros\"),\n+    generate_arange_section: bool = (true, parse_bool, [TRACKED],\n+        \"generate DWARF address ranges for faster lookups\"),\n+    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't clear the hygiene data after analysis\"),\n+    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n+        \"keep the AST after lowering it to HIR\"),\n+    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"show spans for compiler debugging (expr|pat|ty)\"),\n+    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n+        \"print layout information for each type encountered\"),\n+    print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"print the result of the monomorphization collection pass\"),\n+    mir_opt_level: usize = (1, parse_uint, [TRACKED],\n+        \"set the MIR optimization level (0-3, default: 1)\"),\n+    mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"emit noalias metadata for mutable references (default: no)\"),\n+    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"dump MIR state to file.\n+        `val` is used to select which passes and functions to dump. For example:\n+        `all` matches all passes and functions,\n+        `foo` matches all passes for functions whose name contains 'foo',\n+        `foo & ConstProp` only the 'ConstProp' pass for function names containing 'foo',\n+        `foo | bar` all passes for function names containing 'foo' or 'bar'.\"),\n+\n+    dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n+        \"the directory the MIR is dumped into\"),\n+    dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n+        \"in addition to `.mir` files, create graphviz `.dot` files\"),\n+    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n+        \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n+    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n+        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n+    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some performance-related statistics\"),\n+    query_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some statistics about the query system\"),\n+    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some statistics about AST and HIR\"),\n+    always_encode_mir: bool = (false, parse_bool, [TRACKED],\n+        \"encode MIR of all functions into the crate metadata\"),\n+    json_rendered: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"describes how to render the `rendered` field of json diagnostics\"),\n+    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n+        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n+    osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n+        \"pass `-install_name @rpath/...` to the macOS linker\"),\n+    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n+                                    \"use a sanitizer\"),\n+    sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n+        \"Enable recovery for selected sanitizers\"),\n+    sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n+        \"Enable origins tracking in MemorySanitizer\"),\n+    fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n+        \"set the optimization fuel quota for a crate\"),\n+    print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"make rustc print the total optimization fuel used by a crate\"),\n+    force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n+        \"force all crates to be `rustc_private` unstable\"),\n+    pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to prepend the linker invocation (can be used several times)\"),\n+    pre_link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n+        \"extra arguments to prepend to the linker invocation (space separated)\"),\n+    profile: bool = (false, parse_bool, [TRACKED],\n+                     \"insert profiling code\"),\n+    disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n+        \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n+    relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n+        \"choose which RELRO level to use\"),\n+    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n+                       \"dump facts from NLL analysis into side files\"),\n+    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n+        \"in match codegen, do not include FakeRead statements (used by mir-borrowck)\"),\n+    dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n+        \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting).\"),\n+    polonius: bool = (false, parse_bool, [UNTRACKED],\n+        \"enable polonius-based borrow-checker\"),\n+    codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n+    thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"enable ThinLTO when possible\"),\n+    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether `#[inline]` functions are in all CGUs\"),\n+    tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n+    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n+        \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n+         the max/min integer respectively, and NaN is mapped to 0\"),\n+    human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n+        \"generate human-readable, predictable names for codegen units\"),\n+    dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],\n+        \"in dep-info output, omit targets for tracking dependencies of the dep-info files \\\n+         themselves\"),\n+    unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n+        \"present the input source, unstable (and less-pretty) variants;\n+        valid types are any of the types for `--pretty`, as well as:\n+        `expanded`, `expanded,identified`,\n+        `expanded,hygiene` (with internal representations),\n+        `everybody_loops` (all function bodies replaced with `loop {}`),\n+        `hir` (the HIR), `hir,identified`,\n+        `hir,typed` (HIR with types for each node),\n+        `hir-tree` (dump the raw HIR),\n+        `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n+    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"run `dsymutil` and delete intermediate object files\"),\n+    ui_testing: bool = (false, parse_bool, [UNTRACKED],\n+        \"format compiler diagnostics in a way that's better suitable for UI testing\"),\n+    embed_bitcode: bool = (false, parse_bool, [TRACKED],\n+        \"embed LLVM bitcode in object files\"),\n+    strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n+    share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"make the current crate share its generic instantiations\"),\n+    chalk: bool = (false, parse_bool, [TRACKED],\n+        \"enable the experimental Chalk-based trait solving engine\"),\n+    no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n+    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n+    no_interleave_lints: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't interleave execution of lints; allows benchmarking individual lints\"),\n+    crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n+        \"inject the given attribute in the crate\"),\n+    self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [UNTRACKED],\n+        \"run the self profiler and output the raw event data\"),\n+    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n+        \"specifies which kinds of events get recorded by the self profiler\"),\n+    emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n+        \"emits a section containing stack size metadata\"),\n+    plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+          \"whether to use the PLT when calling into shared libraries;\n+          only has effect for PIC code on systems with ELF binaries\n+          (default: PLT is disabled if full relro is enabled)\"),\n+    merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n+        \"control the operation of the MergeFunctions LLVM pass, taking\n+         the same values as the target option of the same name\"),\n+    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n+        \"only allow the listed language features to be enabled in code (space separated)\"),\n+    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n+        parse_symbol_mangling_version, [TRACKED],\n+        \"which mangling version to use for symbol names\"),\n+    binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n+        \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n+    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n+        \"fix undefined behavior when a thread doesn't eventually make progress \\\n+         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n+}"}]}