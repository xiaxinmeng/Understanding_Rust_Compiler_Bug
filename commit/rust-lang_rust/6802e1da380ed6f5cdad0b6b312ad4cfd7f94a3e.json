{"sha": "6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "node_id": "C_kwDOAAsO6NoAKDY4MDJlMWRhMzgwZWQ2ZjVjZGFkMGI2YjMxMmFkNGNmZDdmOTRhM2U", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-30T07:57:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-31T11:21:46Z"}, "message": "Use AdtDef in wfcheck.", "tree": {"sha": "5a0a5dcc00e52d242095dd5db686f0e2d7070d69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0a5dcc00e52d242095dd5db686f0e2d7070d69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "html_url": "https://github.com/rust-lang/rust/commit/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b03502b35d111bef0399a66ab3cc765f0802e8ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/b03502b35d111bef0399a66ab3cc765f0802e8ba", "html_url": "https://github.com/rust-lang/rust/commit/b03502b35d111bef0399a66ab3cc765f0802e8ba"}], "stats": {"total": 107, "additions": 28, "deletions": 79}, "files": [{"sha": "99d0beacfa0a1b9a7b5fee2815d696375591bfef", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 28, "deletions": 79, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "patch": "@@ -218,19 +218,16 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Struct(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Union(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n-\n+        hir::ItemKind::Enum(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Trait(..) => {\n@@ -1037,35 +1034,33 @@ fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'tcx>,\n-    all_sized: bool,\n-    mut lookup_fields: F,\n-) where\n-    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-{\n+fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: bool) {\n     let _ = tcx.representability(item.owner_id.def_id);\n+    let adt_def = tcx.adt_def(item.owner_id);\n \n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.owner_id).repr().packed();\n+        let variants = adt_def.variants();\n+        let packed = adt_def.repr().packed();\n \n-        for variant in &variants {\n+        for variant in variants.iter() {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n-                    field.span,\n-                    Some(WellFormedLoc::Ty(field.def_id)),\n-                    field.ty.into(),\n+                    hir_ty.span,\n+                    Some(WellFormedLoc::Ty(field_id)),\n+                    ty.into(),\n                 )\n             }\n \n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1084,27 +1079,31 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n-                        field.span,\n+                        hir_ty.span,\n                         wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },\n-                            span: field.span,\n+                            span: hir_ty.span,\n                             last,\n                         },\n                     ),\n                     wfcx.param_env,\n-                    field.ty,\n+                    ty,\n                     tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n-            if let Some(discr_def_id) = variant.explicit_discr {\n+            if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1114,7 +1113,7 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::Const::from_anon_const(tcx, discr_def_id),\n+                        ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n                     ))\n                     .to_predicate(tcx),\n                 ));\n@@ -1925,56 +1924,6 @@ fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n-struct AdtVariant<'tcx> {\n-    /// Types of fields in the variant, that must be well-formed.\n-    fields: Vec<AdtField<'tcx>>,\n-\n-    /// Explicit discriminant of this variant (e.g. `A = 123`),\n-    /// that must evaluate to a constant value.\n-    explicit_discr: Option<LocalDefId>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    def_id: LocalDefId,\n-    span: Span,\n-}\n-\n-impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n-    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n-        let fields = struct_def\n-            .fields()\n-            .iter()\n-            .map(|field| {\n-                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx().type_of(def_id);\n-                let field_ty = self.normalize(field.ty.span, None, field_ty);\n-                debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n-                AdtField { ty: field_ty, span: field.ty.span, def_id }\n-            })\n-            .collect();\n-        AdtVariant { fields, explicit_discr: None }\n-    }\n-\n-    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def\n-            .variants\n-            .iter()\n-            .map(|variant| AdtVariant {\n-                fields: self.non_enum_variant(&variant.data).fields,\n-                explicit_discr: variant\n-                    .disr_expr\n-                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n-            })\n-            .collect()\n-    }\n-}\n-\n fn error_392(\n     tcx: TyCtxt<'_>,\n     span: Span,"}]}