{"sha": "5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd", "node_id": "C_kwDOAAsO6NoAKDVkZmMxN2YwNDVhY2E1MmFkMzdhNzY4ZDBmNjcwNGVhNWI0ZmQ0ZGQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-10T23:36:55Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-10T23:36:55Z"}, "message": "prune some unused code", "tree": {"sha": "d9dad8dd3308bff6c0be805071e9cdde64a506f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9dad8dd3308bff6c0be805071e9cdde64a506f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd", "html_url": "https://github.com/rust-lang/rust/commit/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e49b4625df65bdbbd36de83a3f209a8031d65fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e49b4625df65bdbbd36de83a3f209a8031d65fec", "html_url": "https://github.com/rust-lang/rust/commit/e49b4625df65bdbbd36de83a3f209a8031d65fec"}], "stats": {"total": 113, "additions": 4, "deletions": 109}, "files": [{"sha": "79157eae7ed6d9d4f235904f56b9f55687bf328c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 4, "deletions": 109, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=5dfc17f045aca52ad37a768d0f6704ea5b4fd4dd", "patch": "@@ -36,9 +36,7 @@\n //! ```\n \n use crate::FnCtxt;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n-};\n+use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -58,7 +56,7 @@ use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{self, BytePos, DesugaringKind, Span};\n+use rustc_span::{self, DesugaringKind};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -1702,9 +1700,6 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = fcx.err_ctxt().report_mismatched_types(cause, expected, found, ty_err);\n \n-        let mut pointing_at_return_type = false;\n-        let mut fn_output = None;\n-\n         let parent_id = fcx.tcx.hir().parent_id(id);\n         let parent = fcx.tcx.hir().get(parent_id);\n         if let Some(expr) = expression\n@@ -1717,7 +1712,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         // label pointing out the cause for the type coercion will be wrong\n         // as prior return coercions would not be relevant (#57664).\n         let fn_decl = if let (Some(expr), Some(blk_id)) = (expression, blk_id) {\n-            pointing_at_return_type =\n+            let pointing_at_return_type =\n                 fcx.suggest_mismatched_types_on_tail(&mut err, expr, expected, found, blk_id);\n             if let (Some(cond_expr), true, false) = (\n                 fcx.tcx.hir().get_if_cause(expr.hir_id),\n@@ -1749,7 +1744,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n         if let Some((fn_id, fn_decl, can_suggest)) = fn_decl {\n             if blk_id.is_none() {\n-                pointing_at_return_type |= fcx.suggest_missing_return_type(\n+                fcx.suggest_missing_return_type(\n                     &mut err,\n                     &fn_decl,\n                     expected,\n@@ -1758,9 +1753,6 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     fn_id,\n                 );\n             }\n-            if !pointing_at_return_type {\n-                fn_output = Some(&fn_decl.output); // `impl Trait` return type\n-            }\n         }\n \n         let parent_id = fcx.tcx.hir().get_parent_item(id);\n@@ -1795,106 +1787,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             );\n         }\n \n-        if let (Some(sp), Some(fn_output)) = (ret_coercion_span, fn_output) {\n-            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, sp, fn_output);\n-        }\n-\n         err\n     }\n \n-    fn add_impl_trait_explanation<'a>(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'tcx>,\n-        fcx: &FnCtxt<'a, 'tcx>,\n-        expected: Ty<'tcx>,\n-        sp: Span,\n-        fn_output: &hir::FnRetTy<'_>,\n-    ) {\n-        let return_sp = fn_output.span();\n-        err.span_label(return_sp, \"expected because this return type...\");\n-        err.span_label(\n-            sp,\n-            format!(\"...is found to be `{}` here\", fcx.resolve_vars_with_obligations(expected)),\n-        );\n-        let impl_trait_msg = \"for information on `impl Trait`, see \\\n-                <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                #returning-types-that-implement-traits>\";\n-        let trait_obj_msg = \"for information on trait objects, see \\\n-                <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n-                #using-trait-objects-that-allow-for-values-of-different-types>\";\n-        err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n-        err.note(impl_trait_msg);\n-        let snippet = fcx\n-            .tcx\n-            .sess\n-            .source_map()\n-            .span_to_snippet(return_sp)\n-            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n-        let mut snippet_iter = snippet.split_whitespace();\n-        let has_impl = snippet_iter.next().is_some_and(|s| s == \"impl\");\n-        // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n-        let mut is_object_safe = false;\n-        if let hir::FnRetTy::Return(ty) = fn_output\n-            // Get the return type.\n-            && let hir::TyKind::OpaqueDef(..) = ty.kind\n-        {\n-            let ty = fcx.astconv().ast_ty_to_ty( ty);\n-            // Get the `impl Trait`'s `DefId`.\n-            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind()\n-                // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n-                // get the `Trait`'s `DefId`.\n-                && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n-                    fcx.tcx.hir().expect_item(def_id.expect_local()).kind\n-            {\n-                // Are of this `impl Trait`'s traits object safe?\n-                is_object_safe = bounds.iter().all(|bound| {\n-                    bound\n-                        .trait_ref()\n-                        .and_then(|t| t.trait_def_id())\n-                        .is_some_and(|def_id| {\n-                            fcx.tcx.check_is_object_safe(def_id)\n-                        })\n-                })\n-            }\n-        };\n-        if has_impl {\n-            if is_object_safe {\n-                err.multipart_suggestion(\n-                    \"you could change the return type to be a boxed trait object\",\n-                    vec![\n-                        (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                        (return_sp.shrink_to_hi(), \">\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-                let sugg = [sp, cause.span]\n-                    .into_iter()\n-                    .flat_map(|sp| {\n-                        [\n-                            (sp.shrink_to_lo(), \"Box::new(\".to_string()),\n-                            (sp.shrink_to_hi(), \")\".to_string()),\n-                        ]\n-                        .into_iter()\n-                    })\n-                    .collect::<Vec<_>>();\n-                err.multipart_suggestion(\n-                    \"if you change the return type to expect trait objects, box the returned \\\n-                     expressions\",\n-                    sugg,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.help(format!(\n-                    \"if the trait `{}` were object safe, you could return a boxed trait object\",\n-                    &snippet[5..]\n-                ));\n-            }\n-            err.note(trait_obj_msg);\n-        }\n-        err.help(\"you could instead create a new `enum` with a variant for each returned type\");\n-    }\n-\n     /// Checks whether the return type is unsized via an obligation, which makes\n     /// sure we consider `dyn Trait: Sized` where clauses, which are trivially\n     /// false but technically valid for typeck."}]}