{"sha": "cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZDIyNjAyNWI4NjhjOWExZjdlZDA4YjdiZmMzMDAwZjBmM2E1ZGU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-10T12:47:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-10T13:39:20Z"}, "message": "librustc: implement a #[packed] attribute for structs.\n\nA struct (inc. tuple struct) can be annotated with #[packed], so that there\nis no padding between its elements, like GCC's `__attribute__((packed))`.\n\nCloses #1704", "tree": {"sha": "fa0314ae3c2b2155fbca551e1654872c9ac76426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa0314ae3c2b2155fbca551e1654872c9ac76426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "html_url": "https://github.com/rust-lang/rust/commit/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72228012343db793ff453b7cf038d973ccac61a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/72228012343db793ff453b7cf038d973ccac61a7", "html_url": "https://github.com/rust-lang/rust/commit/72228012343db793ff453b7cf038d973ccac61a7"}], "stats": {"total": 221, "additions": 150, "deletions": 71}, "files": [{"sha": "36958fa706ed538ff696c8b358db22236a89cb9d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -88,6 +88,7 @@ pub enum Repr {\n struct Struct {\n     size: u64,\n     align: u64,\n+    packed: bool,\n     fields: ~[ty::t]\n }\n \n@@ -109,17 +110,18 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     }\n     let repr = @match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems), false)\n+            Univariant(mk_struct(cx, *elems, false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n             let ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n             };\n+            let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n             let ftys =\n                 if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n-            Univariant(mk_struct(cx, ftys), dtor)\n+            Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n@@ -132,15 +134,15 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             };\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                Univariant(mk_struct(cx, ~[]), false)\n+                Univariant(mk_struct(cx, ~[], false), false)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n                 CEnum(discrs.min(), discrs.max())\n             } else if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n                 assert!(cases[0].discr == 0);\n-                Univariant(mk_struct(cx, cases[0].tys), false)\n+                Univariant(mk_struct(cx, cases[0].tys, false), false)\n             } else {\n                 // The general case.  Since there's at least one\n                 // non-empty body, explicit discriminants should have\n@@ -151,7 +153,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n                                      ty::item_path_str(cx.tcx, def_id)))\n                 }\n                 let discr = ~[ty::mk_int(cx.tcx)];\n-                General(cases.map(|c| mk_struct(cx, discr + c.tys)))\n+                General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n             }\n         }\n         _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n@@ -160,12 +162,13 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     return repr;\n }\n \n-fn mk_struct(cx: @CrateContext, tys: &[ty::t]) -> Struct {\n+fn mk_struct(cx: @CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = T_struct(lltys);\n+    let llty_rec = T_struct(lltys, packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n+        packed: packed,\n         fields: vec::from_slice(tys)\n     }\n }\n@@ -358,7 +361,8 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n \n     let val = if needs_cast {\n         let real_llty = T_struct(st.fields.map(\n-            |&ty| type_of::type_of(ccx, ty)));\n+            |&ty| type_of::type_of(ccx, ty)),\n+                                 st.packed);\n         PointerCast(bcx, val, T_ptr(real_llty))\n     } else {\n         val"}, {"sha": "cbcefdd5fdb77c2a38fcb4340776859d77dcb82d", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -108,7 +108,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n     } else if numOutputs == 1 {\n         val_ty(outputs[0])\n     } else {\n-        T_struct(outputs.map(|o| val_ty(*o)))\n+        T_struct(outputs.map(|o| val_ty(*o)), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "d94f2bf3c2fe5f828a7ef901172e89c986658841", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -938,7 +938,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n-    let llretty = T_struct(~[T_ptr(T_i8()), T_i32()]);\n+    let llretty = T_struct(~[T_ptr(T_i8()), T_i32()], false);\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n@@ -2837,7 +2837,7 @@ pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: &str) {\n }\n \n pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n-    let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n+    let elttype = T_struct(~[ccx.int_type, ccx.int_type], false);\n     let maptype = T_array(elttype, ccx.module_data.len() + 1);\n     let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n         unsafe {\n@@ -2877,7 +2877,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n-    let maptype = T_struct(~[T_i32(), T_ptr(T_i8()), int_type, arrtype]);\n+    let maptype = T_struct(~[T_i32(), T_ptr(T_i8()), int_type, arrtype], false);\n     let map = str::as_c_str(sym_name, |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype, buf)"}, {"sha": "1b94e990545ea63c15421f395230165d1dd3a98d", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -12,6 +12,7 @@ use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::struct_tys;\n use lib::llvm::TypeRef;\n use lib::llvm::{Attribute, StructRetAttribute};\n+use lib::llvm::True;\n use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n use middle::trans::common::{T_array, T_ptr, T_void};\n@@ -39,8 +40,12 @@ fn ty_align(ty: TypeRef) -> uint {\n             Float => 4,\n             Double => 8,\n             Struct => {\n-                do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                    uint::max(a, ty_align(*t))\n+                if llvm::LLVMIsPackedStruct(ty) == True {\n+                    1\n+                } else {\n+                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n+                        uint::max(a, ty_align(*t))\n+                    }\n                 }\n             }\n             Array => {\n@@ -62,10 +67,16 @@ fn ty_size(ty: TypeRef) -> uint {\n             Float => 4,\n             Double => 8,\n             Struct => {\n-                let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                    align(s, *t) + ty_size(*t)\n-                };\n-                align(size, ty)\n+                if llvm::LLVMIsPackedStruct(ty) == True {\n+                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                        s + ty_size(*t)\n+                    }\n+                } else {\n+                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                        align(s, *t) + ty_size(*t)\n+                    };\n+                    align(size, ty)\n+                }\n             }\n             Array => {\n                 let len = llvm::LLVMGetArrayLength(ty) as uint;"}, {"sha": "ce37455560b5cb88fd212b9cf37601ef7df63788", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,6 +14,7 @@ use core::libc::c_uint;\n use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute};\n+use lib::llvm::True;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n@@ -49,8 +50,12 @@ fn ty_align(ty: TypeRef) -> uint {\n             Float => 4,\n             Double => 8,\n             Struct => {\n-              do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                  uint::max(a, ty_align(*t))\n+              if llvm::LLVMIsPackedStruct(ty) == True {\n+                1\n+              } else {\n+                do vec::foldl(1, struct_tys(ty)) |a, t| {\n+                    uint::max(a, ty_align(*t))\n+                }\n               }\n             }\n             Array => {\n@@ -72,10 +77,16 @@ fn ty_size(ty: TypeRef) -> uint {\n             Float => 4,\n             Double => 8,\n             Struct => {\n-              let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                  align(s, *t) + ty_size(*t)\n-              };\n-              align(size, ty)\n+                if llvm::LLVMIsPackedStruct(ty) == True {\n+                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                        s + ty_size(*t)\n+                    }\n+                } else {\n+                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                        align(s, *t) + ty_size(*t)\n+                    };\n+                    align(size, ty)\n+                }\n             }\n             Array => {\n               let len = llvm::LLVMGetArrayLength(ty) as uint;\n@@ -174,7 +185,7 @@ fn struct_ty(ty: TypeRef,\n         fields.push(ty);\n     }\n \n-    return T_struct(fields);\n+    return T_struct(fields, false);\n }\n \n enum MIPS_ABIInfo { MIPS_ABIInfo }"}, {"sha": "0e4bf5ce574a127ea0ab1b74782fde63d4791af5", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,6 +15,7 @@ use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n use lib::llvm::struct_tys;\n+use lib::llvm::True;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n@@ -76,8 +77,12 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                  do vec::foldl(1, struct_tys(ty)) |a, t| {\n+                  if llvm::LLVMIsPackedStruct(ty) == True {\n+                    1\n+                  } else {\n+                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n                       uint::max(a, ty_align(*t))\n+                    }\n                   }\n                 }\n                 Array => {\n@@ -99,10 +104,16 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                  let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                  if llvm::LLVMIsPackedStruct(ty) == True {\n+                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n+                      s + ty_size(*t)\n+                    }\n+                  } else {\n+                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n                       align(s, *t) + ty_size(*t)\n-                  };\n-                  align(size, ty)\n+                    };\n+                    align(size, ty)\n+                  }\n                 }\n                 Array => {\n                   let len = llvm::LLVMGetArrayLength(ty) as uint;\n@@ -308,7 +319,7 @@ fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n             }\n             i += 1u;\n         }\n-        return T_struct(tys);\n+        return T_struct(tys, false);\n     }\n }\n "}, {"sha": "4701a166ea766cd94b7dd10a71b7ac56bfbf29fd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -765,7 +765,7 @@ pub fn T_void() -> TypeRef {\n }\n \n pub fn T_nil() -> TypeRef {\n-    return T_struct(~[])\n+    return T_struct(~[], false)\n }\n \n pub fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n@@ -848,7 +848,7 @@ pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n }\n \n pub fn T_fn_pair(cx: @CrateContext, tfn: TypeRef) -> TypeRef {\n-    return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n+    return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n }\n \n pub fn T_ptr(t: TypeRef) -> TypeRef {\n@@ -863,11 +863,11 @@ pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n     }\n }\n \n-pub fn T_struct(elts: &[TypeRef]) -> TypeRef {\n+pub fn T_struct(elts: &[TypeRef], packed: bool) -> TypeRef {\n     unsafe {\n         return llvm::LLVMStructType(to_ptr(elts),\n                                     elts.len() as c_uint,\n-                                    False);\n+                                    packed as Bool);\n     }\n }\n \n@@ -878,16 +878,16 @@ pub fn T_named_struct(name: &str) -> TypeRef {\n     }\n }\n \n-pub fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n+pub fn set_struct_body(t: TypeRef, elts: &[TypeRef], packed: bool) {\n     unsafe {\n         llvm::LLVMStructSetBody(t,\n                                 to_ptr(elts),\n                                 elts.len() as c_uint,\n-                                False);\n+                                packed as Bool);\n     }\n }\n \n-pub fn T_empty_struct() -> TypeRef { return T_struct(~[]); }\n+pub fn T_empty_struct() -> TypeRef { return T_struct(~[], false); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other vtables that it closes over. But the types and number\n@@ -913,7 +913,7 @@ pub fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let elems =\n         ~[t_int, t_int, t_int, t_int,\n          t_int, t_int, t_int, t_int];\n-    set_struct_body(t, elems);\n+    set_struct_body(t, elems, false);\n     return t;\n }\n \n@@ -956,7 +956,7 @@ pub fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n         ~[int_type, int_type,\n           glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n           T_ptr(T_i8()), T_ptr(T_i8())];\n-    set_struct_body(tydesc, elems);\n+    set_struct_body(tydesc, elems, false);\n     return tydesc;\n }\n \n@@ -969,8 +969,9 @@ pub fn T_array(t: TypeRef, n: uint) -> TypeRef {\n // Interior vector.\n pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n     return T_struct(~[T_int(targ_cfg), // fill\n-                  T_int(targ_cfg), // alloc\n-                  T_array(t, 0u)]); // elements\n+                      T_int(targ_cfg), // alloc\n+                      T_array(t, 0u)], // elements\n+                    false);\n }\n \n pub fn T_vec(ccx: @CrateContext, t: TypeRef) -> TypeRef {\n@@ -1001,11 +1002,11 @@ pub fn T_box_header_fields(cx: @CrateContext) -> ~[TypeRef] {\n }\n \n pub fn T_box_header(cx: @CrateContext) -> TypeRef {\n-    return T_struct(T_box_header_fields(cx));\n+    return T_struct(T_box_header_fields(cx), false);\n }\n \n pub fn T_box(cx: @CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n+    return T_struct(vec::append(T_box_header_fields(cx), ~[t]), false);\n }\n \n pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n@@ -1023,7 +1024,7 @@ pub fn T_opaque_box_ptr(cx: @CrateContext) -> TypeRef {\n }\n \n pub fn T_unique(cx: @CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n+    return T_struct(vec::append(T_box_header_fields(cx), ~[t]), false);\n }\n \n pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n@@ -1033,12 +1034,12 @@ pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n }\n \n pub fn T_port(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct(~[cx.int_type]); // Refcount\n+    return T_struct(~[cx.int_type], false); // Refcount\n \n }\n \n pub fn T_chan(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct(~[cx.int_type]); // Refcount\n+    return T_struct(~[cx.int_type], false); // Refcount\n \n }\n \n@@ -1056,21 +1057,22 @@ pub fn T_enum_discrim(cx: @CrateContext) -> TypeRef {\n }\n \n pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n-    return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n+    return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)), false);\n }\n \n pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n     match store {\n         ty::BoxTraitStore => {\n-            T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n+            T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n         }\n         ty::UniqTraitStore => {\n             T_struct(~[T_ptr(cx.tydesc_type),\n                        T_unique_ptr(T_unique(cx, T_i8())),\n-                       T_ptr(cx.tydesc_type)])\n+                       T_ptr(cx.tydesc_type)],\n+                     false)\n         }\n         ty::RegionTraitStore(_) => {\n-            T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n+            T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())], false)\n         }\n     }\n }"}, {"sha": "387caa4d8d31f4c1ad02a0d878cc6378871030da", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -106,7 +106,8 @@ fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n     let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n-                                             T_ptr(llsig.llret_ty)));\n+                                             T_ptr(llsig.llret_ty)),\n+                             false);\n     let ret_def =\n         !ty::type_is_bot(fn_sig.output) &&\n         !ty::type_is_nil(fn_sig.output);"}, {"sha": "cd90f964e452eb7192eeca004d746b51de38cbdc", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -142,9 +142,9 @@ pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n                        *cx.tcx.sess.str_of(variant.name),\n-                       ty_str(cx.tn, T_struct(lltypes)));\n+                       ty_str(cx.tn, T_struct(lltypes, false)));\n \n-                let this_size = llsize_of_real(cx, T_struct(lltypes));\n+                let this_size = llsize_of_real(cx, T_struct(lltypes, false));\n                 if max_size < this_size {\n                     max_size = this_size;\n                 }"}, {"sha": "1c94fe2842219362d1846ff5542db82947f067bd", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -128,11 +128,11 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_estr(ty::vstore_slice(*)) |\n         ty::ty_evec(_, ty::vstore_slice(*)) => {\n-            T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())])\n+            T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())], false)\n         }\n \n         ty::ty_bare_fn(*) => T_ptr(T_i8()),\n-        ty::ty_closure(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())]),\n+        ty::ty_closure(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())], false),\n         ty::ty_trait(_, _, store) => T_opaque_trait(cx, store),\n \n         ty::ty_estr(ty::vstore_fixed(size)) => T_array(T_i8(), size),\n@@ -142,9 +142,15 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n \n-        ty::ty_tup(*) | ty::ty_struct(*) | ty::ty_enum(*) => {\n+        ty::ty_tup(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n-            T_struct(adt::sizing_fields_of(cx, repr))\n+            T_struct(adt::sizing_fields_of(cx, repr), false)\n+        }\n+\n+        ty::ty_struct(did, _) => {\n+            let repr = adt::represent_type(cx, t);\n+            let packed = ty::lookup_packed(cx.tcx, did);\n+            T_struct(adt::sizing_fields_of(cx, repr), packed)\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n@@ -223,12 +229,14 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n         T_struct(~[T_ptr(type_of(cx, mt.ty)),\n-                   T_uint_ty(cx, ast::ty_u)])\n+                   T_uint_ty(cx, ast::ty_u)],\n+                 false)\n       }\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n         T_struct(~[T_ptr(T_i8()),\n-                   T_uint_ty(cx, ast::ty_u)])\n+                   T_uint_ty(cx, ast::ty_u)],\n+                 false)\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {\n@@ -245,7 +253,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n-          T_struct(adt::fields_of(cx, repr))\n+          T_struct(adt::fields_of(cx, repr), false)\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n@@ -268,9 +276,17 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-      ty::ty_enum(*) | ty::ty_struct(*) => {\n+      ty::ty_enum(*) => {\n           let repr = adt::represent_type(cx, t);\n-          common::set_struct_body(llty, adt::fields_of(cx, repr));\n+          common::set_struct_body(llty, adt::fields_of(cx, repr),\n+                                  false);\n+      }\n+\n+      ty::ty_struct(did, _) => {\n+        let repr = adt::represent_type(cx, t);\n+        let packed = ty::lookup_packed(cx.tcx, did);\n+        common::set_struct_body(llty, adt::fields_of(cx, repr),\n+                                packed);\n       }\n       _ => ()\n     }"}, {"sha": "335c9824354d23de8e73a735a8977577a7c9657e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad226025b868c9a1f7ed08b7bfc3000f0f3a5de/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cad226025b868c9a1f7ed08b7bfc3000f0f3a5de", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -44,6 +44,7 @@ use std::smallintmap::SmallIntMap;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust;\n@@ -3933,6 +3934,28 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n     }\n }\n \n+// Determine whether an item is annotated with #[packed] or not\n+pub fn lookup_packed(tcx: ctxt,\n+                  did: def_id) -> bool {\n+    if is_local(did) {\n+        match tcx.items.find(&did.node) {\n+            Some(\n+                &ast_map::node_item(@ast::item {\n+                    attrs: ref attrs,\n+                    _\n+                }, _)) => attr::attrs_contains_name(*attrs, \"packed\"),\n+            _ => tcx.sess.bug(fmt!(\"lookup_packed: %? is not an item\",\n+                                   did))\n+        }\n+    } else {\n+        let mut ret = false;\n+        do csearch::get_item_attrs(tcx.cstore, did) |meta_items| {\n+            ret = attr::contains_name(meta_items, \"packed\");\n+        }\n+        ret\n+    }\n+}\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,"}]}