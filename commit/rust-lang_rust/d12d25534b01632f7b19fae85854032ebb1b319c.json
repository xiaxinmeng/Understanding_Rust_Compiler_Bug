{"sha": "d12d25534b01632f7b19fae85854032ebb1b319c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMmQyNTUzNGIwMTYzMmY3YjE5ZmFlODU4NTQwMzJlYmIxYjMxOWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-04T00:37:08Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:59Z"}, "message": "libcore: Remove more mutable fields from comm", "tree": {"sha": "07c9469bebd7b18bd22c08a991400684f5187683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c9469bebd7b18bd22c08a991400684f5187683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d12d25534b01632f7b19fae85854032ebb1b319c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d12d25534b01632f7b19fae85854032ebb1b319c", "html_url": "https://github.com/rust-lang/rust/commit/d12d25534b01632f7b19fae85854032ebb1b319c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d12d25534b01632f7b19fae85854032ebb1b319c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8919f32f8320847501182e517b26b9755fc97041", "url": "https://api.github.com/repos/rust-lang/rust/commits/8919f32f8320847501182e517b26b9755fc97041", "html_url": "https://github.com/rust-lang/rust/commit/8919f32f8320847501182e517b26b9755fc97041"}], "stats": {"total": 187, "additions": 114, "deletions": 73}, "files": [{"sha": "5b2bb3a132f723a08ea0745690f372047cba2aa6", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d12d25534b01632f7b19fae85854032ebb1b319c", "patch": "@@ -234,8 +234,9 @@ impl<T: Owned> Selectable for Port<T> {\n }\n \n /// Treat many ports as one.\n+#[unsafe_mut_field(ports)]\n pub struct PortSet<T> {\n-    mut ports: ~[Port<T>],\n+    ports: ~[Port<T>],\n }\n \n pub impl<T: Owned> PortSet<T> {\n@@ -246,7 +247,10 @@ pub impl<T: Owned> PortSet<T> {\n     }\n \n     fn add(&self, port: Port<T>) {\n-        self.ports.push(port)\n+        unsafe {\n+            let self_ports = transmute_mut(&self.ports);\n+            self_ports.push(port)\n+        }\n     }\n \n     fn chan(&self) -> Chan<T> {\n@@ -258,25 +262,28 @@ pub impl<T: Owned> PortSet<T> {\n \n impl<T:Owned> GenericPort<T> for PortSet<T> {\n     fn try_recv(&self) -> Option<T> {\n-        let mut result = None;\n-        // we have to swap the ports array so we aren't borrowing\n-        // aliasable mutable memory.\n-        let mut ports = ~[];\n-        ports <-> self.ports;\n-        while result.is_none() && ports.len() > 0 {\n-            let i = wait_many(ports);\n-            match ports[i].try_recv() {\n-                Some(m) => {\n-                    result = Some(m);\n-                }\n-                None => {\n-                    // Remove this port.\n-                    let _ = ports.swap_remove(i);\n+        unsafe {\n+            let mut self_ports = transmute_mut(&self.ports);\n+            let mut result = None;\n+            // we have to swap the ports array so we aren't borrowing\n+            // aliasable mutable memory.\n+            let mut ports = ~[];\n+            ports <-> *self_ports;\n+            while result.is_none() && ports.len() > 0 {\n+                let i = wait_many(ports);\n+                match ports[i].try_recv() {\n+                    Some(m) => {\n+                        result = Some(m);\n+                    }\n+                    None => {\n+                        // Remove this port.\n+                        let _ = ports.swap_remove(i);\n+                    }\n                 }\n             }\n+            ports <-> *self_ports;\n+            result\n         }\n-        ports <-> self.ports;\n-        result\n     }\n     fn recv(&self) -> T {\n         self.try_recv().expect(\"port_set: endpoints closed\")\n@@ -288,10 +295,9 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-            // XXX: Botch pending demuting.\n-            unsafe {\n-                let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n-                if port.peek() { return true }\n+            let port: &Port<T> = &self.ports[i];\n+            if port.peek() {\n+                return true;\n             }\n         }\n         false"}, {"sha": "63335f7e952cd2851bad5ca4f88f129dad3e3b69", "filename": "src/libcore/io.rs", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d12d25534b01632f7b19fae85854032ebb1b319c", "patch": "@@ -983,36 +983,50 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n // Byte readers\n pub struct BytesReader<'self> {\n     bytes: &'self [u8],\n-    mut pos: uint\n+    pos: @mut uint\n }\n \n impl<'self> Reader for BytesReader<'self> {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        let count = uint::min(len, self.bytes.len() - self.pos);\n+        let count = uint::min(len, self.bytes.len() - *self.pos);\n \n-        let view = vec::slice(self.bytes, self.pos, self.bytes.len());\n+        let view = vec::slice(self.bytes, *self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n \n-        self.pos += count;\n+        *self.pos += count;\n \n         count\n     }\n+\n     fn read_byte(&self) -> int {\n-        if self.pos == self.bytes.len() { return -1; }\n-        let b = self.bytes[self.pos];\n-        self.pos += 1u;\n-        return b as int;\n+        if *self.pos == self.bytes.len() {\n+            return -1;\n+        }\n+\n+        let b = self.bytes[*self.pos];\n+        *self.pos += 1u;\n+        b as int\n     }\n-    fn eof(&self) -> bool { self.pos == self.bytes.len() }\n+\n+    fn eof(&self) -> bool {\n+        *self.pos == self.bytes.len()\n+    }\n+\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = self.pos;\n-        self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n+        let pos = *self.pos;\n+        *self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n+    }\n+\n+    fn tell(&self) -> uint {\n+        *self.pos\n     }\n-    fn tell(&self) -> uint { self.pos }\n }\n \n-pub fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n-    f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n+pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n+    f(@BytesReader {\n+        bytes: bytes,\n+        pos: @mut 0\n+    } as @Reader)\n }\n \n pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n@@ -1498,49 +1512,67 @@ pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n-pub fn print(s: &str) { stdout().write_str(s); }\n-pub fn println(s: &str) { stdout().write_line(s); }\n+pub fn print(s: &str) {\n+    stdout().write_str(s);\n+}\n+\n+pub fn println(s: &str) {\n+    stdout().write_line(s);\n+}\n \n pub struct BytesWriter {\n-    mut bytes: ~[u8],\n-    mut pos: uint,\n+    bytes: @mut ~[u8],\n+    pos: @mut uint,\n }\n \n impl Writer for BytesWriter {\n     fn write(&self, v: &[u8]) {\n         let v_len = v.len();\n-        let bytes_len = vec::uniq_len(&const self.bytes);\n+        let bytes_len = vec::uniq_len(&const *self.bytes);\n \n-        let count = uint::max(bytes_len, self.pos + v_len);\n-        vec::reserve(&mut self.bytes, count);\n+        let count = uint::max(bytes_len, *self.pos + v_len);\n+        vec::reserve(&mut *self.bytes, count);\n \n         unsafe {\n-            vec::raw::set_len(&mut self.bytes, count);\n-            let view = vec::mut_slice(self.bytes, self.pos, count);\n+            vec::raw::set_len(&mut *self.bytes, count);\n+            let view = vec::mut_slice(*self.bytes, *self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);\n         }\n \n-        self.pos += v_len;\n+        *self.pos += v_len;\n     }\n+\n     fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = self.pos;\n-        let len = vec::uniq_len(&const self.bytes);\n-        self.pos = seek_in_buf(offset, pos, len, whence);\n+        let pos = *self.pos;\n+        let len = vec::uniq_len(&const *self.bytes);\n+        *self.pos = seek_in_buf(offset, pos, len, whence);\n+    }\n+\n+    fn tell(&self) -> uint {\n+        *self.pos\n+    }\n+\n+    fn flush(&self) -> int {\n+        0\n+    }\n+\n+    fn get_type(&self) -> WriterType {\n+        File\n     }\n-    fn tell(&self) -> uint { self.pos }\n-    fn flush(&self) -> int { 0 }\n-    fn get_type(&self) -> WriterType { File }\n }\n \n pub fn BytesWriter() -> BytesWriter {\n-    BytesWriter { bytes: ~[], mut pos: 0u }\n+    BytesWriter {\n+        bytes: @mut ~[],\n+        pos: @mut 0\n+    }\n }\n \n pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as @Writer);\n-    let @BytesWriter{bytes, _} = wr;\n-    return bytes;\n+    let @BytesWriter { bytes, _ } = wr;\n+    copy *bytes\n }\n \n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n@@ -1550,7 +1582,9 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     v.push(0);\n     assert!(str::is_utf8(v));\n \n-    unsafe { ::cast::transmute(v) }\n+    unsafe {\n+        ::cast::transmute(v)\n+    }\n }\n \n // Utility functions"}, {"sha": "c84bebdfd39df6cd5a2d1a32c89eb2f40f3cf02d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d12d25534b01632f7b19fae85854032ebb1b319c", "patch": "@@ -1372,41 +1372,40 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n-    let mut i = wr.pos;\n+    let mut i = *wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes = wr.pos - i;\n+    ecx.stats.attr_bytes = *wr.pos - i;\n \n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes = wr.pos - i;\n+    ecx.stats.dep_bytes = *wr.pos - i;\n \n     // Encode the language items.\n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_lang_items(ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes = wr.pos - i;\n+    ecx.stats.lang_item_bytes = *wr.pos - i;\n \n     // Encode the link args.\n-    i = wr.pos;\n+    i = *wr.pos;\n     encode_link_args(ecx, &mut ebml_w);\n-    ecx.stats.link_args_bytes = wr.pos - i;\n+    ecx.stats.link_args_bytes = *wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = wr.pos;\n+    i = *wr.pos;\n     let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes = wr.pos - i;\n+    ecx.stats.item_bytes = *wr.pos - i;\n \n-    i = wr.pos;\n+    i = *wr.pos;\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_int);\n-    ecx.stats.index_bytes = wr.pos - i;\n+    ecx.stats.index_bytes = *wr.pos - i;\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes = wr.pos;\n+    ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-\n         do wr.bytes.each |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n@@ -1438,9 +1437,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     //\n     //   vec::from_slice(metadata_encoding_version) +\n \n+    let writer_bytes: &mut ~[u8] = wr.bytes;\n+\n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8).to_vec()\n-    }) + flate::deflate_bytes(wr.bytes)\n+    }) + flate::deflate_bytes(*writer_bytes)\n }\n \n // Get the encoded string for a type"}, {"sha": "7d43663cc808b0db971d74a3eaa65e2e0e0b2d7d", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12d25534b01632f7b19fae85854032ebb1b319c/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=d12d25534b01632f7b19fae85854032ebb1b319c", "patch": "@@ -29,13 +29,13 @@ pub impl BufReader {\n         // I can't get the borrowing to work correctly\n         let bytes_reader = BytesReader {\n             bytes: ::core::util::id::<&[u8]>(self.buf),\n-            pos: *self.pos\n+            pos: @mut *self.pos\n         };\n \n         let res = f(&bytes_reader);\n \n         // FIXME #4429: This isn't correct if f fails\n-        *self.pos = bytes_reader.pos;\n+        *self.pos = *bytes_reader.pos;\n \n         return res;\n     }"}]}