{"sha": "6718ea1cff98da785c10079cac1c1ecc30c12d52", "node_id": "C_kwDOAAsO6NoAKDY3MThlYTFjZmY5OGRhNzg1YzEwMDc5Y2FjMWMxZWNjMzBjMTJkNTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T00:51:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T00:51:37Z"}, "message": "Auto merge of #101834 - compiler-errors:super-deduce-closure-sig, r=lcnr\n\nElaborate supertrait obligations when deducing closure signatures\n\nWe elaborate the supertrait obligations of any registered predicates for a closure to see if we can infer a closure signature.\n\nThis is not as general of a fix as it *could* be, since we just elaborate supertrait bounds instead of doing a theoretical walk of _all_ registered predicates that might cause us to deduce `Fn` trait information for a closure infer var. I don't even know how to come up with an example that fails here but would work with a more general system.\n\nFixes #23012\nAlso fixes the existing compile failure in #57611\n\nr? `@ghost` for now until I do a perf run\ncc `@nikomatsakis` since you commented on https://github.com/rust-lang/rust/issues/23012#issuecomment-1152397290", "tree": {"sha": "d179bc4bac78c8f4694be899cf28128220bb87fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d179bc4bac78c8f4694be899cf28128220bb87fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6718ea1cff98da785c10079cac1c1ecc30c12d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6718ea1cff98da785c10079cac1c1ecc30c12d52", "html_url": "https://github.com/rust-lang/rust/commit/6718ea1cff98da785c10079cac1c1ecc30c12d52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6718ea1cff98da785c10079cac1c1ecc30c12d52/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215e3cd218b83b8a3152d84d92f17109253c25e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/215e3cd218b83b8a3152d84d92f17109253c25e1", "html_url": "https://github.com/rust-lang/rust/commit/215e3cd218b83b8a3152d84d92f17109253c25e1"}, {"sha": "bc3516d474a6ab5e5116a2ec32f5d236d479cab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3516d474a6ab5e5116a2ec32f5d236d479cab3", "html_url": "https://github.com/rust-lang/rust/commit/bc3516d474a6ab5e5116a2ec32f5d236d479cab3"}], "stats": {"total": 227, "additions": 125, "deletions": 102}, "files": [{"sha": "14f6e7d36be2cf1299b31d801899cd804353450c", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6718ea1cff98da785c10079cac1c1ecc30c12d52/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6718ea1cff98da785c10079cac1c1ecc30c12d52/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6718ea1cff98da785c10079cac1c1ecc30c12d52", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n@@ -225,33 +226,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expected_vid: ty::TyVid,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let expected_sig =\n-            self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(?obligation.predicate);\n-\n-                let bound_predicate = obligation.predicate.kind();\n-                if let ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.kind().skip_binder()\n-                {\n-                    // Given a Projection predicate, we can potentially infer\n-                    // the complete signature.\n-                    self.deduce_sig_from_projection(\n-                        Some(obligation.cause.span),\n-                        bound_predicate.rebind(proj_predicate),\n-                    )\n-                } else {\n-                    None\n-                }\n-            });\n+        let mut expected_sig = None;\n+        let mut expected_kind = None;\n+\n+        for obligation in traits::elaborate_obligations(\n+            self.tcx,\n+            // Reverse the obligations here, since `elaborate_*` uses a stack,\n+            // and we want to keep inference generally in the same order of\n+            // the registered obligations.\n+            self.obligations_for_self_ty(expected_vid).rev().collect(),\n+        ) {\n+            debug!(?obligation.predicate);\n+            let bound_predicate = obligation.predicate.kind();\n+\n+            // Given a Projection predicate, we can potentially infer\n+            // the complete signature.\n+            if expected_sig.is_none()\n+                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+            {\n+                expected_sig = self.deduce_sig_from_projection(\n+                    Some(obligation.cause.span),\n+                    bound_predicate.rebind(proj_predicate),\n+                );\n+            }\n \n-        // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur when we elaborate a predicate\n-        // like `F : Fn<A>`. Note that due to subtyping we could encounter\n-        // many viable options, so pick the most restrictive.\n-        let expected_kind = self\n-            .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n-            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+            // Even if we can't infer the full signature, we may be able to\n+            // infer the kind. This can occur when we elaborate a predicate\n+            // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+            // many viable options, so pick the most restrictive.\n+            let trait_def_id = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Projection(data) => {\n+                    Some(data.projection_ty.trait_def_id(self.tcx))\n+                }\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                _ => None,\n+            };\n+            if let Some(closure_kind) =\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+            {\n+                expected_kind = Some(\n+                    expected_kind\n+                        .map_or_else(|| closure_kind, |current| cmp::min(current, closure_kind)),\n+                );\n+            }\n+        }\n \n         (expected_sig, expected_kind)\n     }\n@@ -689,7 +707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let output_ty = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => {\n-                self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n+                self.obligations_for_self_ty(ret_vid).find_map(|obligation| {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }"}, {"sha": "7c22eaf18f8557ce3e951a0443d3af1d46574fdc", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6718ea1cff98da785c10079cac1c1ecc30c12d52/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6718ea1cff98da785c10079cac1c1ecc30c12d52/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=6718ea1cff98da785c10079cac1c1ecc30c12d52", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMut\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPolyTraitRef,\n-    ToPredicate, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPredicate, Ty,\n+    UserType,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -650,12 +650,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> bool {\n-        let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n+    fn self_type_matches_expected_vid(&self, self_ty: Ty<'tcx>, expected_vid: ty::TyVid) -> bool {\n+        let self_ty = self.shallow_resolve(self_ty);\n         debug!(?self_ty);\n \n         match *self_ty.kind() {\n@@ -674,54 +670,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n-    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n-    + Captures<'tcx>\n-    + 'b {\n+    ) -> impl DoubleEndedIterator<Item = traits::PredicateObligation<'tcx>> + Captures<'tcx> + 'b\n+    {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n         trace!(\"pending_obligations = {:#?}\", self.fulfillment_cx.borrow().pending_obligations());\n \n-        self.fulfillment_cx\n-            .borrow()\n-            .pending_obligations()\n-            .into_iter()\n-            .filter_map(move |obligation| {\n-                let bound_predicate = obligation.predicate.kind();\n-                match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => Some((\n-                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n-                        obligation,\n-                    )),\n-                    ty::PredicateKind::Trait(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n-                    }\n-                    ty::PredicateKind::Subtype(..) => None,\n-                    ty::PredicateKind::Coerce(..) => None,\n-                    ty::PredicateKind::RegionOutlives(..) => None,\n-                    ty::PredicateKind::TypeOutlives(..) => None,\n-                    ty::PredicateKind::WellFormed(..) => None,\n-                    ty::PredicateKind::ObjectSafe(..) => None,\n-                    ty::PredicateKind::ConstEvaluatable(..) => None,\n-                    ty::PredicateKind::ConstEquate(..) => None,\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of an unresolved\n-                    // inference variable.\n-                    ty::PredicateKind::ClosureKind(..) => None,\n-                    ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n+            move |obligation| match &obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(data)\n+                    if self.self_type_matches_expected_vid(\n+                        data.projection_ty.self_ty(),\n+                        ty_var_root,\n+                    ) =>\n+                {\n+                    Some(obligation)\n                 }\n-            })\n-            .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+                ty::PredicateKind::Trait(data)\n+                    if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n+                {\n+                    Some(obligation)\n+                }\n+\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of an unresolved\n+                // inference variable.\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+            },\n+        )\n     }\n \n     pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n-        self.obligations_for_self_ty(self_ty)\n-            .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n+        let sized_did = self.tcx.lang_items().sized_trait();\n+        self.obligations_for_self_ty(self_ty).any(|obligation| {\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                _ => false,\n+            }\n+        })\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {"}, {"sha": "5899b703e7c132bfa31dd7fe50d9ac591ce1e56c", "filename": "src/test/ui/closures/issue-23012-supertrait-signature-inference.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6718ea1cff98da785c10079cac1c1ecc30c12d52/src%2Ftest%2Fui%2Fclosures%2Fissue-23012-supertrait-signature-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6718ea1cff98da785c10079cac1c1ecc30c12d52/src%2Ftest%2Fui%2Fclosures%2Fissue-23012-supertrait-signature-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-23012-supertrait-signature-inference.rs?ref=6718ea1cff98da785c10079cac1c1ecc30c12d52", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+// Checks that we can infer a closure signature even if the `FnOnce` bound is\n+// a supertrait of the obligations we have currently registered for the Ty var.\n+\n+pub trait Receive<T, E>: FnOnce(Result<T, E>) {\n+    fn receive(self, res: Result<T, E>);\n+}\n+\n+impl<T, E, F: FnOnce(Result<T, E>)> Receive<T, E> for F {\n+    fn receive(self, res: Result<T, E>) {\n+        self(res)\n+    }\n+}\n+\n+pub trait Async<T, E> {\n+    fn receive<F: Receive<T, E>>(self, f: F);\n+}\n+\n+impl<T, E> Async<T, E> for Result<T, E> {\n+    fn receive<F: Receive<T, E>>(self, f: F) {\n+        f(self)\n+    }\n+}\n+\n+pub fn main() {\n+    Ok::<u32, ()>(123).receive(|res| {\n+        res.unwrap();\n+    });\n+}"}, {"sha": "cad3e0f66774d48e52d4015faf003a6fbee5b36c", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6718ea1cff98da785c10079cac1c1ecc30c12d52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6718ea1cff98da785c10079cac1c1ecc30c12d52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=6718ea1cff98da785c10079cac1c1ecc30c12d52", "patch": "@@ -1,7 +1,6 @@\n+// check-pass\n // Regression test for issue #57611\n // Ensures that we don't ICE\n-// FIXME: This should compile, but it currently doesn't\n-// known-bug: unknown\n \n #![feature(trait_alias)]\n #![feature(type_alias_impl_trait)]"}, {"sha": "6344f114a9131fcfa73b669b48bca5b2b0549386", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/215e3cd218b83b8a3152d84d92f17109253c25e1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/215e3cd218b83b8a3152d84d92f17109253c25e1/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=215e3cd218b83b8a3152d84d92f17109253c25e1", "patch": "@@ -1,26 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^ one type is more general than the other\n-   |\n-   = note: expected trait `for<'a> Fn<(&'a X,)>`\n-              found trait `Fn<(&X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n-   |\n-LL |         |x| x\n-   |         ^^^\n-\n-error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^ implementation of `FnOnce` is not general enough\n-   |\n-   = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n-   = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}]}