{"sha": "2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTdmMmVjZTUxN2E1MjAyNDIxZjdhNGE3Y2RkOTliZDE4NjJhYzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-08T13:23:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-08T13:23:12Z"}, "message": "Merge #6750\n\n6750: Remove documentation query, move doc handling to attributes r=matklad a=Veykril\n\nFixes #3182\r\n\r\nRemoves the documentation query in favor of `Attrs::docs`. Attrs already handlded doc comments partially but the alloc saving check was wrong so it only worked when other attributes existed as well. Unfortunately the `new` constructor has to do an intermediate allocation now because we need to keep the order of mixed doc attributes and doc comments.\r\n\r\nI've also partially adjusted the `hover` module to have its tests check the changes, it still has some `HasSource` trait usage due to the `ShortLabel` trait usage, as that is only implemented on the Ast parts and not the Hir, should this ideally be implemented for the Hir types as well?(would be a follow up PR of course)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "fcdf682d2175735262a7d733043bb510fd86526e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcdf682d2175735262a7d733043bb510fd86526e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfz35ACRBK7hj4Ov3rIwAAdHIIAIIeD0wQyTPWKmFBsckxeWov\ndzPRG1gphD5yiYYKiu7N9DBAa1P7EE7jJlkAFVfaQ2LqnY3QPkdhwNVo+2VMVu6f\nSGY1tzqe3oIKp4XQjyW0n0s47RGuQK0fjaXdm5G9yN3UkBrJv8KHuGNHqX076Xvw\nkXpsiVpHA5i59nnAZuw+m4guBzB4Xm1vx/7aKMKRwpHL1Kh3hY4g4L82HQi/hH//\nlp9C3pnnSL695LSfvg6BjdHl+L2t+SgeBTt6/URrl5sqHiCh5wul+OTuUBQrx1EE\nx7ho5EKbb7nfXs4spEWQ4OSDElmZxbemv5XeASxOTUi42Wp0CkZ0HaKiC3LYql0=\n=9tUX\n-----END PGP SIGNATURE-----\n", "payload": "tree fcdf682d2175735262a7d733043bb510fd86526e\nparent 4d4f11925f793c45560c45c088d4b3139c2c171c\nparent 3174e941dbb7d91bad011ba51a9b55736996b36c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607433792 +0000\ncommitter GitHub <noreply@github.com> 1607433792 +0000\n\nMerge #6750\n\n6750: Remove documentation query, move doc handling to attributes r=matklad a=Veykril\n\nFixes #3182\r\n\r\nRemoves the documentation query in favor of `Attrs::docs`. Attrs already handlded doc comments partially but the alloc saving check was wrong so it only worked when other attributes existed as well. Unfortunately the `new` constructor has to do an intermediate allocation now because we need to keep the order of mixed doc attributes and doc comments.\r\n\r\nI've also partially adjusted the `hover` module to have its tests check the changes, it still has some `HasSource` trait usage due to the `ShortLabel` trait usage, as that is only implemented on the Ast parts and not the Hir, should this ideally be implemented for the Hir types as well?(would be a follow up PR of course)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "html_url": "https://github.com/rust-lang/rust/commit/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4f11925f793c45560c45c088d4b3139c2c171c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4f11925f793c45560c45c088d4b3139c2c171c", "html_url": "https://github.com/rust-lang/rust/commit/4d4f11925f793c45560c45c088d4b3139c2c171c"}, {"sha": "3174e941dbb7d91bad011ba51a9b55736996b36c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3174e941dbb7d91bad011ba51a9b55736996b36c", "html_url": "https://github.com/rust-lang/rust/commit/3174e941dbb7d91bad011ba51a9b55736996b36c"}], "stats": {"total": 350, "additions": 137, "deletions": 213}, "files": [{"sha": "1f2ee2580018565036ffdd4aa5f72a634faeeb89", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -1,6 +1,9 @@\n //! Attributes & documentation for hir types.\n use hir_def::{\n-    attr::Attrs, docs::Documentation, path::ModPath, resolver::HasResolver, AttrDefId, ModuleDefId,\n+    attr::{Attrs, Documentation},\n+    path::ModPath,\n+    resolver::HasResolver,\n+    AttrDefId, ModuleDefId,\n };\n use hir_expand::hygiene::Hygiene;\n use hir_ty::db::HirDatabase;\n@@ -38,7 +41,7 @@ macro_rules! impl_has_attrs {\n             }\n             fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n                 let def = AttrDefId::$def_id(self.into());\n-                db.documentation(def)\n+                db.attrs(def).docs()\n             }\n             fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<ModuleDef> {\n                 let def = AttrDefId::$def_id(self.into());"}, {"sha": "8d949b26476826dbacbac09e8f5ee0041ac3bc4c", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -2,12 +2,12 @@\n \n pub use hir_def::db::{\n     AttrsQuery, BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQueryQuery,\n-    CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery,\n-    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n-    InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n-    InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n-    InternUnionQuery, ItemTreeQuery, LangItemQuery, ModuleLangItemsQuery, StaticDataQuery,\n-    StructDataQuery, TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n+    CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, EnumDataQuery, ExprScopesQuery,\n+    FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery, InternConstQuery,\n+    InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery, InternImplQuery,\n+    InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery, InternUnionQuery,\n+    ItemTreeQuery, LangItemQuery, ModuleLangItemsQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,"}, {"sha": "c7c7377d73f258149882f3e60f0ca759c8f08708", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -44,10 +44,9 @@ pub use crate::{\n \n pub use hir_def::{\n     adt::StructKind,\n-    attr::Attrs,\n+    attr::{Attrs, Documentation},\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n-    docs::Documentation,\n     find_path::PrefixKind,\n     import_map,\n     item_scope::ItemInNs,"}, {"sha": "12f4b02e2990171aa14c5995b282d2a94e9c545e", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -5,10 +5,11 @@ use std::{ops, sync::Arc};\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n+use itertools::Itertools;\n use mbe::ast_to_token_tree;\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n-    SmolStr,\n+    AstToken, SmolStr,\n };\n use tt::Subtree;\n \n@@ -21,6 +22,22 @@ use crate::{\n     AdtId, AttrDefId, Lookup,\n };\n \n+/// Holds documentation\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Documentation(String);\n+\n+impl Documentation {\n+    pub fn as_str(&self) -> &str {\n+        &self.0\n+    }\n+}\n+\n+impl Into<String> for Documentation {\n+    fn into(self) -> String {\n+        self.0\n+    }\n+}\n+\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct Attrs {\n     entries: Option<Arc<[Attr]>>,\n@@ -93,18 +110,25 @@ impl Attrs {\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n-        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).doc_comment_text().map(\n-            |docs_text| Attr {\n-                input: Some(AttrInput::Literal(SmolStr::new(docs_text))),\n-                path: ModPath::from(hir_expand::name!(doc)),\n-            },\n-        );\n-        let mut attrs = owner.attrs().peekable();\n-        let entries = if attrs.peek().is_none() {\n+        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).map(|docs_text| {\n+            (\n+                docs_text.syntax().text_range().start(),\n+                docs_text.doc_comment().map(|doc| Attr {\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: ModPath::from(hir_expand::name!(doc)),\n+                }),\n+            )\n+        });\n+        let attrs = owner\n+            .attrs()\n+            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n+        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n+        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let entries = if attrs.is_empty() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).chain(docs).collect())\n+            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n         };\n         Attrs { entries }\n     }\n@@ -140,6 +164,24 @@ impl Attrs {\n             Some(cfg) => cfg_options.check(&cfg) != Some(false),\n         }\n     }\n+\n+    pub fn docs(&self) -> Option<Documentation> {\n+        let docs = self\n+            .by_key(\"doc\")\n+            .attrs()\n+            .flat_map(|attr| match attr.input.as_ref()? {\n+                AttrInput::Literal(s) => Some(s),\n+                AttrInput::TokenTree(_) => None,\n+            })\n+            .intersperse(&SmolStr::new_inline(\"\\n\"))\n+            .map(|it| it.as_str())\n+            .collect::<String>();\n+        if docs.is_empty() {\n+            None\n+        } else {\n+            Some(Documentation(docs.into()))\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -160,8 +202,10 @@ impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n         let path = ModPath::from_src(ast.path()?, hygiene)?;\n         let input = if let Some(lit) = ast.literal() {\n-            // FIXME: escape? raw string?\n-            let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n+            let value = match lit.kind() {\n+                ast::LiteralKind::String(string) => string.value()?.into(),\n+                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n+            };\n             Some(AttrInput::Literal(value))\n         } else if let Some(tt) = ast.token_tree() {\n             Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))"}, {"sha": "7f250da3307f59da491726859c4c1cfd444837ef", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -10,7 +10,6 @@ use crate::{\n     attr::Attrs,\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n-    docs::Documentation,\n     generics::GenericParams,\n     import_map::ImportMap,\n     item_tree::ItemTree,\n@@ -105,11 +104,6 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(LangItems::lang_item_query)]\n     fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n \n-    // FIXME(https://github.com/rust-analyzer/rust-analyzer/issues/2148#issuecomment-550519102)\n-    // Remove this query completely, in favor of `Attrs::docs` method\n-    #[salsa::invoke(Documentation::documentation_query)]\n-    fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n-\n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n }"}, {"sha": "3e59a8f47fd9f25c144a8fb1529cb999676636ff", "filename": "crates/hir_def/src/docs.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fhir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4f11925f793c45560c45c088d4b3139c2c171c/crates%2Fhir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdocs.rs?ref=4d4f11925f793c45560c45c088d4b3139c2c171c", "patch": "@@ -1,121 +0,0 @@\n-//! Defines hir documentation.\n-//!\n-//! This really shouldn't exist, instead, we should deshugar doc comments into attributes, see\n-//! https://github.com/rust-analyzer/rust-analyzer/issues/2148#issuecomment-550519102\n-\n-use std::sync::Arc;\n-\n-use either::Either;\n-use itertools::Itertools;\n-use syntax::{ast, SmolStr};\n-\n-use crate::{\n-    db::DefDatabase,\n-    src::{HasChildSource, HasSource},\n-    AdtId, AttrDefId, Lookup,\n-};\n-\n-/// Holds documentation\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct Documentation(Arc<str>);\n-\n-impl Into<String> for Documentation {\n-    fn into(self) -> String {\n-        self.as_str().to_owned()\n-    }\n-}\n-\n-impl Documentation {\n-    fn new(s: &str) -> Documentation {\n-        Documentation(s.into())\n-    }\n-\n-    pub fn from_ast<N>(node: &N) -> Option<Documentation>\n-    where\n-        N: ast::DocCommentsOwner + ast::AttrsOwner,\n-    {\n-        docs_from_ast(node)\n-    }\n-\n-    pub fn as_str(&self) -> &str {\n-        &*self.0\n-    }\n-\n-    pub(crate) fn documentation_query(\n-        db: &dyn DefDatabase,\n-        def: AttrDefId,\n-    ) -> Option<Documentation> {\n-        match def {\n-            AttrDefId::ModuleId(module) => {\n-                let def_map = db.crate_def_map(module.krate);\n-                let src = def_map[module.local_id].declaration_source(db)?;\n-                docs_from_ast(&src.value)\n-            }\n-            AttrDefId::FieldId(it) => {\n-                let src = it.parent.child_source(db);\n-                match &src.value[it.local_id] {\n-                    Either::Left(_tuple) => None,\n-                    Either::Right(record) => docs_from_ast(record),\n-                }\n-            }\n-            AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-                AdtId::EnumId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-                AdtId::UnionId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            },\n-            AttrDefId::EnumVariantId(it) => {\n-                let src = it.parent.child_source(db);\n-                docs_from_ast(&src.value[it.local_id])\n-            }\n-            AttrDefId::TraitId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::MacroDefId(it) => docs_from_ast(&it.ast_id?.to_node(db.upcast())),\n-            AttrDefId::ConstId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::StaticId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::FunctionId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::TypeAliasId(it) => docs_from_ast(&it.lookup(db).source(db).value),\n-            AttrDefId::ImplId(_) => None,\n-        }\n-    }\n-}\n-\n-pub(crate) fn docs_from_ast<N>(node: &N) -> Option<Documentation>\n-where\n-    N: ast::DocCommentsOwner + ast::AttrsOwner,\n-{\n-    let doc_comment_text = node.doc_comment_text();\n-    let doc_attr_text = expand_doc_attrs(node);\n-    let docs = merge_doc_comments_and_attrs(doc_comment_text, doc_attr_text);\n-    docs.map(|it| Documentation::new(&it))\n-}\n-\n-fn merge_doc_comments_and_attrs(\n-    doc_comment_text: Option<String>,\n-    doc_attr_text: Option<String>,\n-) -> Option<String> {\n-    match (doc_comment_text, doc_attr_text) {\n-        (Some(mut comment_text), Some(attr_text)) => {\n-            comment_text.push_str(\"\\n\");\n-            comment_text.push_str(&attr_text);\n-            Some(comment_text)\n-        }\n-        (Some(comment_text), None) => Some(comment_text),\n-        (None, Some(attr_text)) => Some(attr_text),\n-        (None, None) => None,\n-    }\n-}\n-\n-fn expand_doc_attrs(owner: &dyn ast::AttrsOwner) -> Option<String> {\n-    let mut docs = String::new();\n-    owner\n-        .attrs()\n-        .filter_map(|attr| attr.as_simple_key_value().filter(|(key, _)| key == \"doc\"))\n-        .map(|(_, value)| value)\n-        .intersperse(SmolStr::new_inline(\"\\n\"))\n-        // No FromIterator<SmolStr> for String\n-        .for_each(|s| docs.push_str(s.as_str()));\n-    if docs.is_empty() {\n-        None\n-    } else {\n-        Some(docs)\n-    }\n-}"}, {"sha": "02ed30e4d62468a21285c1ec099197c30e68dd68", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -31,7 +31,6 @@ pub mod adt;\n pub mod data;\n pub mod generics;\n pub mod lang_item;\n-pub mod docs;\n \n pub mod expr;\n pub mod body;"}, {"sha": "e80b593aabc57ab11de5095fb291acd5611535e0", "filename": "crates/hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -372,7 +372,7 @@ fn module_resolution_explicit_path_mod_rs_with_win_separator() {\n     check(\n         r#\"\n //- /main.rs\n-#[path = \"module\\bar\\mod.rs\"]\n+#[path = r\"module\\bar\\mod.rs\"]\n mod foo;\n \n //- /module/bar/mod.rs"}, {"sha": "1b6ff6d2109f3f0ad3f848ec47dc0521fdcdc7d9", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -1,6 +1,6 @@\n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n-    Module, ModuleDef, ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, FieldSource, HasAttrs, HasSource, HirDisplay, Module,\n+    ModuleDef, ModuleSource, Semantics,\n };\n use ide_db::base_db::SourceDatabase;\n use ide_db::{\n@@ -319,31 +319,27 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n     let mod_path = definition_mod_path(db, &def);\n     return match def {\n         Definition::Macro(it) => {\n-            let src = it.source(db);\n-            let docs = Documentation::from_ast(&src.value).map(Into::into);\n-            hover_markup(docs, Some(macro_label(&src.value)), mod_path)\n+            let label = macro_label(&it.source(db).value);\n+            from_def_source_labeled(db, it, Some(label), mod_path)\n         }\n-        Definition::Field(it) => {\n-            let src = it.source(db);\n-            match src.value {\n-                FieldSource::Named(it) => {\n-                    let docs = Documentation::from_ast(&it).map(Into::into);\n-                    hover_markup(docs, it.short_label(), mod_path)\n-                }\n-                _ => None,\n+        Definition::Field(def) => {\n+            let src = def.source(db).value;\n+            if let FieldSource::Named(it) = src {\n+                from_def_source_labeled(db, def, it.short_label(), mod_path)\n+            } else {\n+                None\n             }\n         }\n         Definition::ModuleDef(it) => match it {\n-            ModuleDef::Module(it) => match it.definition_source(db).value {\n-                ModuleSource::Module(it) => {\n-                    let docs = Documentation::from_ast(&it).map(Into::into);\n-                    hover_markup(docs, it.short_label(), mod_path)\n-                }\n-                ModuleSource::SourceFile(it) => {\n-                    let docs = Documentation::from_ast(&it).map(Into::into);\n-                    hover_markup(docs, it.short_label(), mod_path)\n-                }\n-            },\n+            ModuleDef::Module(it) => from_def_source_labeled(\n+                db,\n+                it,\n+                match it.definition_source(db).value {\n+                    ModuleSource::Module(it) => it.short_label(),\n+                    ModuleSource::SourceFile(it) => it.short_label(),\n+                },\n+                mod_path,\n+            ),\n             ModuleDef::Function(it) => from_def_source(db, it, mod_path),\n             ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it, mod_path),\n             ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it, mod_path),\n@@ -371,12 +367,24 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n \n     fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n     where\n-        D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel + ast::AttrsOwner,\n+        D: HasSource<Ast = A> + HasAttrs + Copy,\n+        A: ShortLabel,\n+    {\n+        let short_label = def.source(db).value.short_label();\n+        from_def_source_labeled(db, def, short_label, mod_path)\n+    }\n+\n+    fn from_def_source_labeled<D>(\n+        db: &RootDatabase,\n+        def: D,\n+        short_label: Option<String>,\n+        mod_path: Option<String>,\n+    ) -> Option<Markup>\n+    where\n+        D: HasAttrs,\n     {\n-        let src = def.source(db);\n-        let docs = Documentation::from_ast(&src.value).map(Into::into);\n-        hover_markup(docs, src.value.short_label(), mod_path)\n+        let docs = def.attrs(db).docs().map(Into::into);\n+        hover_markup(docs, short_label, mod_path)\n     }\n }\n "}, {"sha": "e2251f2b7d1b4a4816c03a2426dd284416fe30e4", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -166,7 +166,6 @@ impl RootDatabase {\n             hir::db::ModuleLangItemsQuery\n             hir::db::CrateLangItemsQuery\n             hir::db::LangItemQuery\n-            hir::db::DocumentationQuery\n             hir::db::ImportMapQuery\n \n             // HirDatabase"}, {"sha": "a10b1477804acd3e20d01ce7862ded255ec3864e", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -24,6 +24,28 @@ impl ast::Comment {\n             .unwrap();\n         prefix\n     }\n+\n+    /// Returns the textual content of a doc comment block as a single string.\n+    /// That is, strips leading `///` (+ optional 1 character of whitespace),\n+    /// trailing `*/`, trailing whitespace and then joins the lines.\n+    pub fn doc_comment(&self) -> Option<&str> {\n+        let kind = self.kind();\n+        match kind {\n+            CommentKind { shape, doc: Some(_) } => {\n+                let prefix = kind.prefix();\n+                let text = &self.text().as_str()[prefix.len()..];\n+                let ws = text.chars().next().filter(|c| c.is_whitespace());\n+                let text = ws.map_or(text, |ws| &text[ws.len_utf8()..]);\n+                match shape {\n+                    CommentShape::Block if text.ends_with(\"*/\") => {\n+                        Some(&text[..text.len() - \"*/\".len()])\n+                    }\n+                    _ => Some(text),\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n@@ -73,6 +95,11 @@ impl CommentKind {\n             .unwrap();\n         kind\n     }\n+\n+    fn prefix(&self) -> &'static str {\n+        let &(prefix, _) = CommentKind::BY_PREFIX.iter().find(|(_, kind)| kind == self).unwrap();\n+        prefix\n+    }\n }\n \n impl ast::Whitespace {"}, {"sha": "13a769d51a07971b4db7064ff6f673fbf7eb1fc3", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=2aa7f2ece517a5202421f7a4a7cdd99bd1862ac8", "patch": "@@ -91,40 +91,12 @@ impl CommentIter {\n     /// That is, strips leading `///` (+ optional 1 character of whitespace),\n     /// trailing `*/`, trailing whitespace and then joins the lines.\n     pub fn doc_comment_text(self) -> Option<String> {\n-        let mut has_comments = false;\n-        let docs = self\n-            .filter(|comment| comment.kind().doc.is_some())\n-            .map(|comment| {\n-                has_comments = true;\n-                let prefix_len = comment.prefix().len();\n-\n-                let line: &str = comment.text().as_str();\n-\n-                // Determine if the prefix or prefix + 1 char is stripped\n-                let pos =\n-                    if let Some(ws) = line.chars().nth(prefix_len).filter(|c| c.is_whitespace()) {\n-                        prefix_len + ws.len_utf8()\n-                    } else {\n-                        prefix_len\n-                    };\n-\n-                let end = if comment.kind().shape.is_block() && line.ends_with(\"*/\") {\n-                    line.len() - 2\n-                } else {\n-                    line.len()\n-                };\n-\n-                // Note that we do not trim the end of the line here\n-                // since whitespace can have special meaning at the end\n-                // of a line in markdown.\n-                line[pos..end].to_owned()\n-            })\n-            .join(\"\\n\");\n-\n-        if has_comments {\n-            Some(docs)\n-        } else {\n+        let docs =\n+            self.filter_map(|comment| comment.doc_comment().map(ToOwned::to_owned)).join(\"\\n\");\n+        if docs.is_empty() {\n             None\n+        } else {\n+            Some(docs)\n         }\n     }\n }"}]}