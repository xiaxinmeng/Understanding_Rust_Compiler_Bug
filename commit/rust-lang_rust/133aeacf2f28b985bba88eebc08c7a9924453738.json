{"sha": "133aeacf2f28b985bba88eebc08c7a9924453738", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzM2FlYWNmMmYyOGI5ODViYmE4OGVlYmMwOGM3YTk5MjQ0NTM3Mzg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-11-30T15:03:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-12-05T16:05:25Z"}, "message": "Refactor symbol export list generation.", "tree": {"sha": "7fd5602e564381dc270d989389fcb21f567aa096", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fd5602e564381dc270d989389fcb21f567aa096"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/133aeacf2f28b985bba88eebc08c7a9924453738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/133aeacf2f28b985bba88eebc08c7a9924453738", "html_url": "https://github.com/rust-lang/rust/commit/133aeacf2f28b985bba88eebc08c7a9924453738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/133aeacf2f28b985bba88eebc08c7a9924453738/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fd7c2bfef50e00fdd6b2f5dc07b17c2c324f396", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd7c2bfef50e00fdd6b2f5dc07b17c2c324f396", "html_url": "https://github.com/rust-lang/rust/commit/5fd7c2bfef50e00fdd6b2f5dc07b17c2c324f396"}], "stats": {"total": 541, "additions": 371, "deletions": 170}, "files": [{"sha": "4357518b332cc64a911958b2c3980314dcf9e1e5", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -328,6 +328,7 @@ pub trait CrateStore<'tcx> {\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n     fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n     fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>;\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n@@ -491,6 +492,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n+        { bug!(\"derive_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n         { bug!(\"native_libraries\") }\n     fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"exported_symbols\") }"}, {"sha": "aca1d2f76128128f92e1d2236a3d1c05f5af2d49", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -306,6 +306,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n+    {\n+        self.get_crate_data(cnum).root.macro_derive_registrar.map(|index| DefId {\n+            krate: cnum,\n+            index: index\n+        })\n+    }\n+\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n     {\n         self.get_crate_data(cnum).get_native_libraries()"}, {"sha": "933813ac4d9310ffb2bd08df487e8d7b727c14bf", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -17,11 +17,11 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use context::SharedCrateContext;\n-use monomorphize::Instance;\n \n use back::archive;\n+use back::symbol_export::{self, ExportedSymbols};\n use middle::dependency_format::Linkage;\n-use rustc::hir::def_id::CrateNum;\n+use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use session::Session;\n use session::config::CrateType;\n use session::config;\n@@ -34,7 +34,7 @@ pub struct LinkerInfo {\n \n impl<'a, 'tcx> LinkerInfo {\n     pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n-               exports: &[String]) -> LinkerInfo {\n+               exports: &ExportedSymbols) -> LinkerInfo {\n         LinkerInfo {\n             exports: scx.sess().crate_types.borrow().iter().map(|&c| {\n                 (c, exported_symbols(scx, exports, c))\n@@ -473,43 +473,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n }\n \n fn exported_symbols(scx: &SharedCrateContext,\n-                    exported_symbols: &[String],\n+                    exported_symbols: &ExportedSymbols,\n                     crate_type: CrateType)\n                     -> Vec<String> {\n-    // See explanation in GnuLinker::export_symbols, for\n-    // why we don't ever need dylib symbols on non-MSVC.\n-    if crate_type == CrateType::CrateTypeDylib ||\n-       crate_type == CrateType::CrateTypeProcMacro {\n-        if !scx.sess().target.target.options.is_like_msvc {\n-            return vec![];\n-        }\n-    }\n-\n-    let mut symbols = exported_symbols.to_vec();\n+    let export_threshold = symbol_export::crate_export_threshold(crate_type);\n \n-    // If we're producing anything other than a dylib then the `reachable` array\n-    // above is the exhaustive set of symbols we should be exporting.\n-    //\n-    // For dylibs, however, we need to take a look at how all upstream crates\n-    // are linked into this dynamic library. For all statically linked\n-    // libraries we take all their reachable symbols and emit them as well.\n-    if crate_type != CrateType::CrateTypeDylib {\n-        return symbols\n-    }\n+    let mut symbols = Vec::new();\n+    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, export_threshold, |name, _| {\n+        symbols.push(name.to_owned());\n+    });\n \n-    let cstore = &scx.sess().cstore;\n     let formats = scx.sess().dependency_formats.borrow();\n     let deps = formats[&crate_type].iter();\n-    symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n-        if *f == Linkage::Static {\n-            Some(CrateNum::new(i + 1))\n-        } else {\n-            None\n+\n+    for (index, dep_format) in deps.enumerate() {\n+        let cnum = CrateNum::new(index + 1);\n+        // For each dependency that we are linking to statically ...\n+        if *dep_format == Linkage::Static {\n+            // ... we add its symbol list to our export list.\n+            exported_symbols.for_each_exported_symbol(cnum, export_threshold, |name, _| {\n+                symbols.push(name.to_owned());\n+            })\n         }\n-    }).flat_map(|cnum| {\n-        cstore.exported_symbols(cnum)\n-    }).map(|did| -> String {\n-        Instance::mono(scx, did).symbol_name(scx)\n-    }));\n+    }\n+\n     symbols\n }"}, {"sha": "1960b368278749613cd8d256a888e24083d3ad29", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::link;\n-use super::write;\n+use back::link;\n+use back::write;\n+use back::symbol_export::{self, ExportedSymbols};\n use rustc::session::{self, config};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use back::write::{ModuleConfig, with_llvm_pmb};\n \n use libc;\n@@ -24,8 +26,23 @@ use flate;\n use std::ffi::CString;\n use std::path::Path;\n \n-pub fn run(sess: &session::Session, llmod: ModuleRef,\n-           tm: TargetMachineRef, exported_symbols: &[String],\n+pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeCdylib     => true,\n+\n+        config::CrateTypeDylib     |\n+        config::CrateTypeRlib      |\n+        config::CrateTypeMetadata  |\n+        config::CrateTypeProcMacro => false,\n+    }\n+}\n+\n+pub fn run(sess: &session::Session,\n+           llmod: ModuleRef,\n+           tm: TargetMachineRef,\n+           exported_symbols: &ExportedSymbols,\n            config: &ModuleConfig,\n            temp_no_opt_bc_filename: &Path) {\n     if sess.opts.cg.prefer_dynamic {\n@@ -38,17 +55,31 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n     // Make sure we actually can run LTO\n     for crate_type in sess.crate_types.borrow().iter() {\n-        match *crate_type {\n-            config::CrateTypeExecutable |\n-            config::CrateTypeCdylib |\n-            config::CrateTypeStaticlib => {}\n-            _ => {\n-                sess.fatal(\"lto can only be run for executables and \\\n+        if !crate_type_allows_lto(*crate_type) {\n+            sess.fatal(\"lto can only be run for executables and \\\n                             static library outputs\");\n-            }\n         }\n     }\n \n+    let export_threshold =\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+\n+    let symbol_filter = &|&(ref name, level): &(String, _)| {\n+        if symbol_export::is_below_threshold(level, export_threshold) {\n+            let mut bytes = Vec::with_capacity(name.len() + 1);\n+            bytes.extend(name.bytes());\n+            Some(CString::new(bytes).unwrap())\n+        } else {\n+            None\n+        }\n+    };\n+\n+    let mut symbol_white_list: Vec<CString> = exported_symbols\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(symbol_filter)\n+        .collect();\n+\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n@@ -58,6 +89,11 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             return;\n         }\n \n+        symbol_white_list.extend(\n+            exported_symbols.exported_symbols(cnum)\n+                            .iter()\n+                            .filter_map(symbol_filter));\n+\n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n             child.ok().and_then(|c| c.name().map(|name| (name, c)))\n@@ -119,10 +155,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     });\n \n     // Internalize everything but the exported symbols of the current module\n-    let cstrs: Vec<CString> = exported_symbols.iter().map(|s| {\n-        CString::new(s.clone()).unwrap()\n-    }).collect();\n-    let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n+    let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n+                                                         .map(|c| c.as_ptr())\n+                                                         .collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,"}, {"sha": "2290cb0f48785089033b5aa5f05675f83a2a9329", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+use symbol_map::SymbolMap;\n+use util::nodemap::FxHashMap;\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::session::config;\n+use syntax::attr;\n+use trans_item::TransItem;\n+\n+/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n+/// the symbol will be exported. `C` symbols will be exported from any\n+/// kind of crate, including cdylibs which export very few things.\n+/// `Rust` will only be exported if the crate produced is a Rust\n+/// dylib.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SymbolExportLevel {\n+    C,\n+    Rust,\n+}\n+\n+/// The set of symbols exported from each crate in the crate graph.\n+pub struct ExportedSymbols {\n+    exports: FxHashMap<CrateNum, Vec<(String, SymbolExportLevel)>>,\n+}\n+\n+impl ExportedSymbols {\n+\n+    pub fn empty() -> ExportedSymbols {\n+        ExportedSymbols {\n+            exports: FxHashMap(),\n+        }\n+    }\n+\n+    pub fn compute_from<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                  symbol_map: &SymbolMap<'tcx>)\n+                                  -> ExportedSymbols {\n+        let mut local_crate: Vec<_> = scx\n+            .exported_symbols()\n+            .iter()\n+            .map(|&node_id| {\n+                scx.tcx().map.local_def_id(node_id)\n+            })\n+            .map(|def_id| {\n+                (symbol_for_def_id(scx, def_id, symbol_map),\n+                 export_level(scx, def_id))\n+            })\n+            .collect();\n+\n+        if scx.sess().entry_fn.borrow().is_some() {\n+            local_crate.push((\"main\".to_string(), SymbolExportLevel::C));\n+        }\n+\n+        if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n+            local_crate.push((scx.metadata_symbol_name(),\n+                              SymbolExportLevel::Rust));\n+        }\n+\n+        let mut exports = FxHashMap();\n+        exports.insert(LOCAL_CRATE, local_crate);\n+\n+        for cnum in scx.sess().cstore.crates() {\n+            debug_assert!(cnum != LOCAL_CRATE);\n+\n+            if scx.sess().cstore.plugin_registrar_fn(cnum).is_some() ||\n+               scx.sess().cstore.derive_registrar_fn(cnum).is_some() {\n+                continue;\n+            }\n+\n+            let crate_exports = scx\n+                .sess()\n+                .cstore\n+                .exported_symbols(cnum)\n+                .iter()\n+                .map(|&def_id| {\n+                    debug!(\"EXTERN-SYMBOL: {:?}\", def_id);\n+                    let name = Instance::mono(scx, def_id).symbol_name(scx);\n+                    (name, export_level(scx, def_id))\n+                })\n+                .collect();\n+\n+            exports.insert(cnum, crate_exports);\n+        }\n+\n+        return ExportedSymbols {\n+            exports: exports\n+        };\n+\n+        fn export_level(scx: &SharedCrateContext,\n+                        sym_def_id: DefId)\n+                        -> SymbolExportLevel {\n+            let attrs = scx.tcx().get_attrs(sym_def_id);\n+            if attr::contains_extern_indicator(scx.sess().diagnostic(), &attrs) {\n+                SymbolExportLevel::C\n+            } else {\n+                SymbolExportLevel::Rust\n+            }\n+        }\n+    }\n+\n+    pub fn exported_symbols(&self,\n+                            cnum: CrateNum)\n+                            -> &[(String, SymbolExportLevel)] {\n+        match self.exports.get(&cnum) {\n+            Some(exports) => &exports[..],\n+            None => &[]\n+        }\n+    }\n+\n+    pub fn for_each_exported_symbol<F>(&self,\n+                                       cnum: CrateNum,\n+                                       export_threshold: SymbolExportLevel,\n+                                       mut f: F)\n+        where F: FnMut(&str, SymbolExportLevel)\n+    {\n+        for &(ref name, export_level) in self.exported_symbols(cnum) {\n+            if is_below_threshold(export_level, export_threshold) {\n+                f(&name[..], export_level)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn crate_export_threshold(crate_type: config::CrateType)\n+                                     -> SymbolExportLevel {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeCdylib     => SymbolExportLevel::C,\n+        config::CrateTypeProcMacro  |\n+        config::CrateTypeRlib       |\n+        config::CrateTypeMetadata   |\n+        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n+    }\n+}\n+\n+pub fn crates_export_threshold(crate_types: &[config::CrateType])\n+                                      -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type| {\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n+    }) {\n+        SymbolExportLevel::Rust\n+    } else {\n+        SymbolExportLevel::C\n+    }\n+}\n+\n+pub fn is_below_threshold(level: SymbolExportLevel,\n+                          threshold: SymbolExportLevel)\n+                          -> bool {\n+    if threshold == SymbolExportLevel::Rust {\n+        // We export everything from Rust dylibs\n+        true\n+    } else {\n+        level == SymbolExportLevel::C\n+    }\n+}\n+\n+fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                               def_id: DefId,\n+                               symbol_map: &SymbolMap<'tcx>)\n+                               -> String {\n+    // Just try to look things up in the symbol map. If nothing's there, we\n+    // recompute.\n+    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n+            return sym.to_owned();\n+        }\n+    }\n+\n+    let instance = Instance::mono(scx, def_id);\n+\n+    symbol_map.get(TransItem::Fn(instance))\n+              .map(str::to_owned)\n+              .unwrap_or_else(|| instance.symbol_name(scx))\n+}"}, {"sha": "ffab0bde7abde743cff20dce98787caeb0e4df62", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -10,6 +10,7 @@\n \n use back::lto;\n use back::link::{get_linker, remove};\n+use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use session::config::{OutputFilenames, OutputTypes, Passes, SomePasses, AllPasses};\n use session::Session;\n@@ -328,7 +329,7 @@ impl ModuleConfig {\n struct CodegenContext<'a> {\n     // Extra resources used for LTO: (sess, reachable).  This will be `None`\n     // when running in a worker thread.\n-    lto_ctxt: Option<(&'a Session, &'a [String])>,\n+    lto_ctxt: Option<(&'a Session, &'a ExportedSymbols)>,\n     // Handler to use for diagnostics produced during codegen.\n     handler: &'a Handler,\n     // LLVM passes added by plugins.\n@@ -343,7 +344,9 @@ struct CodegenContext<'a> {\n }\n \n impl<'a> CodegenContext<'a> {\n-    fn new_with_session(sess: &'a Session, exported_symbols: &'a [String]) -> CodegenContext<'a> {\n+    fn new_with_session(sess: &'a Session,\n+                        exported_symbols: &'a ExportedSymbols)\n+                        -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, exported_symbols)),\n             handler: sess.diagnostic(),\n@@ -997,7 +1000,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n }\n \n fn run_work_singlethreaded(sess: &Session,\n-                           exported_symbols: &[String],\n+                           exported_symbols: &ExportedSymbols,\n                            work_items: Vec<WorkItem>) {\n     let cgcx = CodegenContext::new_with_session(sess, exported_symbols);\n "}, {"sha": "a31b61e42c440a2434c0433a4eacc55dc25be3e4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 95, "deletions": 115, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -33,10 +33,10 @@ use super::ModuleTranslation;\n use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n+use back::symbol_export::{self, ExportedSymbols};\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -84,7 +84,6 @@ use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::rc::Rc;\n@@ -1313,51 +1312,67 @@ fn write_metadata(cx: &SharedCrateContext,\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n-                                 exported_symbols: &FxHashSet<&str>) {\n+                                 exported_symbols: &ExportedSymbols) {\n+    let export_threshold =\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+\n+    let exported_symbols = exported_symbols\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter(|&&(_, export_level)| {\n+            symbol_export::is_below_threshold(export_level, export_threshold)\n+        })\n+        .map(|&(ref name, _)| &name[..])\n+        .collect::<FxHashSet<&str>>();\n+\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n-    // In incr. comp. mode, we can't necessarily see all refs since we\n-    // don't generate LLVM IR for reused modules, so skip this\n-    // step. Later we should get smarter.\n-    if sess.opts.debugging_opts.incremental.is_some() {\n-        return;\n-    }\n+    let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n \n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n         let mut referenced_somewhere = FxHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n-        // are referenced via a declaration in some other codegen unit.\n-        for ccx in ccxs.iter_need_trans() {\n-            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n-                let linkage = llvm::LLVMRustGetLinkage(val);\n-                // We only care about external declarations (not definitions)\n-                // and available_externally definitions.\n-                let is_available_externally = linkage == llvm::Linkage::AvailableExternallyLinkage;\n-                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n-\n-                if is_decl || is_available_externally {\n-                    let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    referenced_somewhere.insert(symbol_name);\n+        // are referenced via a declaration in some other codegen unit. In\n+        // incremental compilation, we don't need to collect. See below for more\n+        // information.\n+        if !incr_comp {\n+            for ccx in ccxs.iter_need_trans() {\n+                for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                    let linkage = llvm::LLVMRustGetLinkage(val);\n+                    // We only care about external declarations (not definitions)\n+                    // and available_externally definitions.\n+                    let is_available_externally =\n+                        linkage == llvm::Linkage::AvailableExternallyLinkage;\n+                    let is_decl = llvm::LLVMIsDeclaration(val) == llvm::True;\n+\n+                    if is_decl || is_available_externally {\n+                        let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                        referenced_somewhere.insert(symbol_name);\n+                    }\n                 }\n             }\n         }\n \n         // Also collect all symbols for which we cannot adjust linkage, because\n-        // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n-        let linkage_fixed_explicitly: FxHashSet<_> = scx\n-            .translation_items()\n-            .borrow()\n-            .iter()\n-            .cloned()\n-            .filter(|trans_item|{\n-                trans_item.explicit_linkage(tcx).is_some()\n-            })\n-            .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n-            .collect();\n+        // it is fixed by some directive in the source code.\n+        let (locally_defined_symbols, linkage_fixed_explicitly) = {\n+            let mut locally_defined_symbols = FxHashSet();\n+            let mut linkage_fixed_explicitly = FxHashSet();\n+\n+            for trans_item in scx.translation_items().borrow().iter() {\n+                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                if trans_item.explicit_linkage(tcx).is_some() {\n+                    linkage_fixed_explicitly.insert(symbol_name.clone());\n+                }\n+                locally_defined_symbols.insert(symbol_name);\n+            }\n+\n+            (locally_defined_symbols, linkage_fixed_explicitly)\n+        };\n \n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n@@ -1369,23 +1384,46 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                 let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n                                             (linkage == llvm::Linkage::LinkOnceODRLinkage) ||\n                                             (linkage == llvm::Linkage::WeakODRLinkage);\n-                let is_definition = llvm::LLVMIsDeclaration(val) == 0;\n-\n-                // If this is a definition (as opposed to just a declaration)\n-                // and externally visible, check if we can internalize it\n-                if is_definition && is_externally_visible {\n-                    let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    let name_str = name_cstr.to_str().unwrap();\n-                    let name_cow = Cow::Borrowed(name_str);\n-\n-                    let is_referenced_somewhere = referenced_somewhere.contains(&name_cstr);\n-                    let is_reachable = exported_symbols.contains(&name_str);\n-                    let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n-\n-                    if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n-                        llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n-                        llvm::LLVMSetDLLStorageClass(val,\n-                                                     llvm::DLLStorageClass::Default);\n+\n+                if !is_externally_visible {\n+                    // This symbol is not visible outside of its codegen unit,\n+                    // so there is nothing to do for it.\n+                    continue;\n+                }\n+\n+                let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                let name_str = name_cstr.to_str().unwrap();\n+\n+                if exported_symbols.contains(&name_str) {\n+                    // This symbol is explicitly exported, so we can't\n+                    // mark it as internal or hidden.\n+                    continue;\n+                }\n+\n+                let is_declaration = llvm::LLVMIsDeclaration(val) == llvm::True;\n+\n+                if is_declaration {\n+                    if locally_defined_symbols.contains(name_str) {\n+                        // Only mark declarations from the current crate as hidden.\n+                        // Otherwise we would mark things as hidden that are\n+                        // imported from other crates or native libraries.\n+                        llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n+                    }\n+                } else {\n+                    let has_fixed_linkage = linkage_fixed_explicitly.contains(name_str);\n+\n+                    if !has_fixed_linkage {\n+                        // In incremental compilation mode, we can't be sure that\n+                        // we saw all references because we don't know what's in\n+                        // cached compilation units, so we always assume that the\n+                        // given item has been referenced.\n+                        if incr_comp || referenced_somewhere.contains(&name_cstr) {\n+                            llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n+                        } else {\n+                            llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n+                        }\n+\n+                        llvm::LLVMSetDLLStorageClass(val, llvm::DLLStorageClass::Default);\n                         llvm::UnsetComdat(val);\n                     }\n                 }\n@@ -1602,13 +1640,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        tcx.sess.crate_types.borrow().iter().all(|ct| ct == &config::CrateTypeMetadata) {\n-        let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n+        let linker_info = LinkerInfo::new(&shared_ccx, &ExportedSymbols::empty());\n         return CrateTranslation {\n             modules: modules,\n             metadata_module: metadata_module,\n             link: link_meta,\n             metadata: metadata,\n-            exported_symbols: vec![],\n+            exported_symbols: ExportedSymbols::empty(),\n             no_builtins: no_builtins,\n             linker_info: linker_info,\n             windows_subsystem: None,\n@@ -1688,56 +1726,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let sess = shared_ccx.sess();\n-    let mut exported_symbols = shared_ccx.exported_symbols().iter().map(|&id| {\n-        let def_id = shared_ccx.tcx().map.local_def_id(id);\n-        symbol_for_def_id(def_id, &shared_ccx, &symbol_map)\n-    }).collect::<Vec<_>>();\n-\n-    if sess.entry_fn.borrow().is_some() {\n-        exported_symbols.push(\"main\".to_string());\n-    }\n-\n-    if sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-        exported_symbols.push(shared_ccx.metadata_symbol_name());\n-    }\n \n-    // For the purposes of LTO or when creating a cdylib, we add to the\n-    // reachable set all of the upstream reachable extern fns. These functions\n-    // are all part of the public ABI of the final product, so we need to\n-    // preserve them.\n-    //\n-    // Note that this happens even if LTO isn't requested or we're not creating\n-    // a cdylib. In those cases, though, we're not even reading the\n-    // `exported_symbols` list later on so it should be ok.\n-    for cnum in sess.cstore.crates() {\n-        let syms = sess.cstore.exported_symbols(cnum);\n-        exported_symbols.extend(syms.into_iter().filter(|&def_id| {\n-            let applicable = match sess.cstore.describe_def(def_id) {\n-                Some(Def::Static(..)) => true,\n-                Some(Def::Fn(_)) => {\n-                    shared_ccx.tcx().item_generics(def_id).types.is_empty()\n-                }\n-                _ => false\n-            };\n-\n-            if applicable {\n-                let attrs = shared_ccx.tcx().get_attrs(def_id);\n-                attr::contains_extern_indicator(sess.diagnostic(), &attrs)\n-            } else {\n-                false\n-            }\n-        }).map(|did| {\n-            symbol_for_def_id(did, &shared_ccx, &symbol_map)\n-        }));\n-    }\n+    let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n+                                                         &symbol_map);\n \n+    // Now that we have all symbols that are exported from the CGUs of this\n+    // crate, we can run the `internalize_symbols` pass.\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n                             &crate_context_list,\n                             &symbol_map,\n-                            &exported_symbols.iter()\n-                                              .map(|s| &s[..])\n-                                              .collect())\n+                            &exported_symbols);\n     });\n \n     if tcx.sess.opts.debugging_opts.print_type_sizes {\n@@ -2107,22 +2106,3 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     (codegen_units, symbol_map)\n }\n-\n-fn symbol_for_def_id<'a, 'tcx>(def_id: DefId,\n-                               scx: &SharedCrateContext<'a, 'tcx>,\n-                               symbol_map: &SymbolMap<'tcx>)\n-                               -> String {\n-    // Just try to look things up in the symbol map. If nothing's there, we\n-    // recompute.\n-    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n-        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n-            return sym.to_owned();\n-        }\n-    }\n-\n-    let instance = Instance::mono(scx, def_id);\n-\n-    symbol_map.get(TransItem::Fn(instance))\n-              .map(str::to_owned)\n-              .unwrap_or_else(|| instance.symbol_name(scx))\n-}"}, {"sha": "e2da635b1592ae3ac1992f83e25fdbb95eb102a3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -78,6 +78,7 @@ pub mod back {\n     pub mod linker;\n     pub mod link;\n     pub mod lto;\n+    pub mod symbol_export;\n     pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n@@ -169,7 +170,7 @@ pub struct CrateTranslation {\n     pub metadata_module: ModuleTranslation,\n     pub link: middle::cstore::LinkMeta,\n     pub metadata: Vec<u8>,\n-    pub exported_symbols: Vec<String>,\n+    pub exported_symbols: back::symbol_export::ExportedSymbols,\n     pub no_builtins: bool,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo"}, {"sha": "720dfff2c0438cefaa1e7815daf04e9f4be4ed80", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/133aeacf2f28b985bba88eebc08c7a9924453738/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=133aeacf2f28b985bba88eebc08c7a9924453738", "patch": "@@ -10,5 +10,5 @@ all:\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*normal)\" -eq \"1\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ i32\\ .*normal)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ hidden\\ i32\\ .*normal)\" -eq \"1\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ hidden\\ i32\\ .*normal)\" -eq \"2\" ]"}]}