{"sha": "191b328f31556e473c0dd934d8b7cbce2c032aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MWIzMjhmMzE1NTZlNDczYzBkZDkzNGQ4YjdjYmNlMmMwMzJhZWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-20T10:22:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-21T00:32:42Z"}, "message": "tutorial: Move method discussion after closures, before generics\n\n/cc: #4217", "tree": {"sha": "17a3fa298bf0ca65a85f1f67678d80b231438afe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17a3fa298bf0ca65a85f1f67678d80b231438afe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/191b328f31556e473c0dd934d8b7cbce2c032aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/191b328f31556e473c0dd934d8b7cbce2c032aea", "html_url": "https://github.com/rust-lang/rust/commit/191b328f31556e473c0dd934d8b7cbce2c032aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/191b328f31556e473c0dd934d8b7cbce2c032aea/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af5cd341d3c6719c02cd4869dc27a7d47aa2c0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/af5cd341d3c6719c02cd4869dc27a7d47aa2c0d5", "html_url": "https://github.com/rust-lang/rust/commit/af5cd341d3c6719c02cd4869dc27a7d47aa2c0d5"}], "stats": {"total": 275, "additions": 136, "deletions": 139}, "files": [{"sha": "b9ad8900a4fca7d9717aa354de7b150da19222bd", "filename": "doc/tutorial.md", "status": "modified", "additions": 136, "deletions": 139, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/191b328f31556e473c0dd934d8b7cbce2c032aea/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/191b328f31556e473c0dd934d8b7cbce2c032aea/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=191b328f31556e473c0dd934d8b7cbce2c032aea", "patch": "@@ -1480,145 +1480,6 @@ if favorite_crayon_name.len() > 5 {\n }\n ~~~\n \n-# Methods\n-\n-Methods are like functions except that they always begin with a special argument,\n-called `self`,\n-which has the type of the method's receiver. The\n-`self` argument is like `this` in C++ and many other languages.\n-Methods are called with dot notation, as in `my_vec.len()`.\n-\n-_Implementations_, written with the `impl` keyword, can define\n-methods on most Rust types, including structs and enums.\n-As an example, let's define a `draw` method on our `Shape` enum.\n-\n-~~~\n-# fn draw_circle(p: Point, f: float) { }\n-# fn draw_rectangle(p: Point, p: Point) { }\n-struct Point {\n-    x: float,\n-    y: float\n-}\n-\n-enum Shape {\n-    Circle(Point, float),\n-    Rectangle(Point, Point)\n-}\n-\n-impl Shape {\n-    fn draw(&self) {\n-        match *self {\n-            Circle(p, f) => draw_circle(p, f),\n-            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n-        }\n-    }\n-}\n-\n-let s = Circle(Point { x: 1f, y: 2f }, 3f);\n-s.draw();\n-~~~\n-\n-This defines an _implementation_ for `Shape` containing a single\n-method, `draw`. In most respects the `draw` method is defined\n-like any other function, except for the name `self`.\n-\n-The type of `self` is the type on which the method is implemented,\n-or a pointer thereof. As an argument it is written either `self`,\n-`&self`, `@self`, or `~self`.\n-A caller must in turn have a compatible pointer type to call the method.\n-\n-~~~\n-# fn draw_circle(p: Point, f: float) { }\n-# fn draw_rectangle(p: Point, p: Point) { }\n-# struct Point { x: float, y: float }\n-# enum Shape {\n-#     Circle(Point, float),\n-#     Rectangle(Point, Point)\n-# }\n-impl Shape {\n-    fn draw_borrowed(&self) { ... }\n-    fn draw_managed(@self) { ... }\n-    fn draw_owned(~self) { ... }\n-    fn draw_value(self) { ... }\n-}\n-\n-let s = Circle(Point { x: 1f, y: 2f }, 3f);\n-\n-(@s).draw_managed();\n-(~s).draw_owned();\n-(&s).draw_borrowed();\n-s.draw_value();\n-~~~\n-\n-Methods typically take a borrowed pointer self type,\n-so the compiler will go to great lengths to convert a callee\n-to a borrowed pointer.\n-\n-~~~\n-# fn draw_circle(p: Point, f: float) { }\n-# fn draw_rectangle(p: Point, p: Point) { }\n-# struct Point { x: float, y: float }\n-# enum Shape {\n-#     Circle(Point, float),\n-#     Rectangle(Point, Point)\n-# }\n-# impl Shape {\n-#    fn draw_borrowed(&self) { ... }\n-#    fn draw_managed(@self) { ... }\n-#    fn draw_owned(~self) { ... }\n-#    fn draw_value(self) { ... }\n-# }\n-# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n-// As with typical function arguments, managed and unique pointers\n-// are automatically converted to borrowed pointers\n-\n-(@s).draw_borrowed();\n-(~s).draw_borrowed();\n-\n-// Unlike typical function arguments, the self value will\n-// automatically be referenced ...\n-s.draw_borrowed();\n-\n-// ... and dereferenced\n-(& &s).draw_borrowed();\n-\n-// ... and dereferenced, and borrowed, and\n-(&@~s).draw_borrowed();\n-~~~\n-\n-Implementations may also define _static_ methods,\n-which don't have an explicit `self` argument.\n-The `static` keyword distinguishes static methods from methods that have a `self`:\n-\n-~~~~ {.xfail-test}\n-impl Circle {\n-    fn area(&self) -> float { ... }\n-    static fn new(area: float) -> Circle { ... }\n-}\n-~~~~\n-\n-> ***Note***: In the future the `static` keyword will be removed and static methods\n-> will be distinguished solely by the presence or absence of the `self` argument.\n-> In the current langugage instance methods may also be declared without an explicit\n-> `self` argument, in which case `self` is an implicit reference.\n-> That form of method is deprecated.\n-\n-Constructors are one common application for static methods, as in `new` above.\n-To call a static method, you have to prefix it with the type name and a double colon:\n-\n-~~~~\n-# use float::consts::pi;\n-# use float::sqrt;\n-struct Circle { radius: float }\n-impl Circle {\n-    static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n-}\n-let c = Circle::new(42.5);\n-~~~~\n-\n-We'll discuss implementations more in the context of [traits and\n-generics](#generics).\n-\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local\n@@ -1886,6 +1747,142 @@ fn contains(v: &[int], elt: int) -> bool {\n > the keywords `break`, `loop`, and `return` work, in varying degree,\n > with `while`, `loop`, `do`, and `for` constructs.\n \n+# Methods\n+\n+Methods are like functions except that they always begin with a special argument,\n+called `self`,\n+which has the type of the method's receiver. The\n+`self` argument is like `this` in C++ and many other languages.\n+Methods are called with dot notation, as in `my_vec.len()`.\n+\n+_Implementations_, written with the `impl` keyword, can define\n+methods on most Rust types, including structs and enums.\n+As an example, let's define a `draw` method on our `Shape` enum.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+struct Point {\n+    x: float,\n+    y: float\n+}\n+\n+enum Shape {\n+    Circle(Point, float),\n+    Rectangle(Point, Point)\n+}\n+\n+impl Shape {\n+    fn draw(&self) {\n+        match *self {\n+            Circle(p, f) => draw_circle(p, f),\n+            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n+        }\n+    }\n+}\n+\n+let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+s.draw();\n+~~~\n+\n+This defines an _implementation_ for `Shape` containing a single\n+method, `draw`. In most respects the `draw` method is defined\n+like any other function, except for the name `self`.\n+\n+The type of `self` is the type on which the method is implemented,\n+or a pointer thereof. As an argument it is written either `self`,\n+`&self`, `@self`, or `~self`.\n+A caller must in turn have a compatible pointer type to call the method.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+# struct Point { x: float, y: float }\n+# enum Shape {\n+#     Circle(Point, float),\n+#     Rectangle(Point, Point)\n+# }\n+impl Shape {\n+    fn draw_borrowed(&self) { ... }\n+    fn draw_managed(@self) { ... }\n+    fn draw_owned(~self) { ... }\n+    fn draw_value(self) { ... }\n+}\n+\n+let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+\n+(@s).draw_managed();\n+(~s).draw_owned();\n+(&s).draw_borrowed();\n+s.draw_value();\n+~~~\n+\n+Methods typically take a borrowed pointer self type,\n+so the compiler will go to great lengths to convert a callee\n+to a borrowed pointer.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+# struct Point { x: float, y: float }\n+# enum Shape {\n+#     Circle(Point, float),\n+#     Rectangle(Point, Point)\n+# }\n+# impl Shape {\n+#    fn draw_borrowed(&self) { ... }\n+#    fn draw_managed(@self) { ... }\n+#    fn draw_owned(~self) { ... }\n+#    fn draw_value(self) { ... }\n+# }\n+# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+// As with typical function arguments, managed and unique pointers\n+// are automatically converted to borrowed pointers\n+\n+(@s).draw_borrowed();\n+(~s).draw_borrowed();\n+\n+// Unlike typical function arguments, the self value will\n+// automatically be referenced ...\n+s.draw_borrowed();\n+\n+// ... and dereferenced\n+(& &s).draw_borrowed();\n+\n+// ... and dereferenced, and borrowed, and\n+(&@~s).draw_borrowed();\n+~~~\n+\n+Implementations may also define _static_ methods,\n+which don't have an explicit `self` argument.\n+The `static` keyword distinguishes static methods from methods that have a `self`:\n+\n+~~~~ {.xfail-test}\n+impl Circle {\n+    fn area(&self) -> float { ... }\n+    static fn new(area: float) -> Circle { ... }\n+}\n+~~~~\n+\n+> ***Note***: In the future the `static` keyword will be removed and static methods\n+> will be distinguished solely by the presence or absence of the `self` argument.\n+> In the current langugage instance methods may also be declared without an explicit\n+> `self` argument, in which case `self` is an implicit reference.\n+> That form of method is deprecated.\n+\n+Constructors are one common application for static methods, as in `new` above.\n+To call a static method, you have to prefix it with the type name and a double colon:\n+\n+~~~~\n+# use float::consts::pi;\n+# use float::sqrt;\n+struct Circle { radius: float }\n+impl Circle {\n+    static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n+}\n+let c = Circle::new(42.5);\n+~~~~\n+\n # Generics\n \n Throughout this tutorial, we've been defining functions that act only"}]}