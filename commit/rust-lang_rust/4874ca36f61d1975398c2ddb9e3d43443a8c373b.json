{"sha": "4874ca36f61d1975398c2ddb9e3d43443a8c373b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NzRjYTM2ZjYxZDE5NzUzOThjMmRkYjllM2Q0MzQ0M2E4YzM3M2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-23T00:18:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-23T00:18:57Z"}, "message": "Auto merge of #21530 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #21056, #21091, #21217, #21325, #21373, #21450, #21471, #21472, #21477, #21479, #21484, #21496, #21500, #21516, #21517\n- Failed merges:", "tree": {"sha": "998f61bf7d4c0bc1aa1f2c714599ed3a8e9d6ddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/998f61bf7d4c0bc1aa1f2c714599ed3a8e9d6ddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4874ca36f61d1975398c2ddb9e3d43443a8c373b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4874ca36f61d1975398c2ddb9e3d43443a8c373b", "html_url": "https://github.com/rust-lang/rust/commit/4874ca36f61d1975398c2ddb9e3d43443a8c373b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4874ca36f61d1975398c2ddb9e3d43443a8c373b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8160fc4786383fb2df5f99d7e35a3e6ac82c1b12", "url": "https://api.github.com/repos/rust-lang/rust/commits/8160fc4786383fb2df5f99d7e35a3e6ac82c1b12", "html_url": "https://github.com/rust-lang/rust/commit/8160fc4786383fb2df5f99d7e35a3e6ac82c1b12"}, {"sha": "9fb672b0944114c867f5c54074b6ed57ab22e384", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb672b0944114c867f5c54074b6ed57ab22e384", "html_url": "https://github.com/rust-lang/rust/commit/9fb672b0944114c867f5c54074b6ed57ab22e384"}], "stats": {"total": 1276, "additions": 937, "deletions": 339}, "files": [{"sha": "b3f0034ca894f1bd2d6d2d650db280522e74478f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -248,6 +248,9 @@ pub fn run_tests(config: &Config) {\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n     io::test::raise_fd_limit();\n+    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n+    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n+    os::setenv(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n     let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}"}, {"sha": "1bcb5a7b4a0c02063a5889b8d7dd457237403f9b", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -739,6 +739,15 @@ Rust syntax is restricted in two ways:\n * `concat!` : concatenates a comma-separated list of literals\n * `concat_idents!` : create a new identifier by concatenating the arguments\n \n+The following attributes are used for quasiquoting in procedural macros:\n+\n+* `quote_expr!`\n+* `quote_item!`\n+* `quote_pat!`\n+* `quote_stmt!`\n+* `quote_tokens!`\n+* `quote_ty!`\n+\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*\n@@ -2028,6 +2037,9 @@ type int8_t = i8;\n   item](#language-items) for more details.\n - `test` - indicates that this function is a test function, to only be compiled\n   in case of `--test`.\n+- `should_fail` - indicates that this test function should panic, inverting the success condition.\n+- `cold` - The function is unlikely to be executed, so optimize it (and calls\n+  to it) differently.\n \n ### Static-only attributes\n "}, {"sha": "d4a25efec17f6895baeed32178ca69baad319159", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 294, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -1,296 +1,3 @@\n % Rust Documentation\n \n-`rustdoc` is the built-in tool for generating documentation. It integrates\n-with the compiler to provide accurate hyperlinking between usage of types and\n-their documentation. Furthermore, by not using a separate parser, it will\n-never reject your valid Rust code.\n-\n-# Creating Documentation\n-\n-Documenting Rust APIs is quite simple. To document a given item, we have \"doc\n-comments\":\n-\n-~~~\n-# #![allow(unused_attribute)]\n-// the \"link\" crate attribute is currently required for rustdoc, but normally\n-// isn't needed.\n-#![crate_id = \"universe\"]\n-#![crate_type=\"lib\"]\n-\n-//! Tools for dealing with universes (this is a doc comment, and is shown on\n-//! the crate index page. The ! makes it apply to the parent of the comment,\n-//! rather than what follows).\n-\n-# mod workaround_the_outer_function_rustdoc_inserts {\n-/// Widgets are very common (this is a doc comment, and will show up on\n-/// Widget's documentation).\n-pub struct Widget {\n-\t/// All widgets have a purpose (this is a doc comment, and will show up\n-\t/// the field's documentation).\n-\tpurpose: String,\n-\t/// Humans are not allowed to understand some widgets\n-\tunderstandable: bool\n-}\n-\n-pub fn recalibrate() {\n-\t//! Recalibrate a pesky universe (this is also a doc comment, like above,\n-\t//! the documentation will be applied to the *parent* item, so\n-\t//! `recalibrate`).\n-\t/* ... */\n-}\n-# }\n-~~~\n-\n-Documentation can also be controlled via the `doc` attribute on items. This is\n-implicitly done by the compiler when using the above form of doc comments\n-(converting the slash-based comments to `#[doc]` attributes).\n-\n-~~~\n-#[doc = \"\n-Calculates the factorial of a number.\n-\n-Given the input integer `n`, this function will calculate `n!` and return it.\n-\"]\n-pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n - 1)} }\n-# fn main() {}\n-~~~\n-\n-The `doc` attribute can also be used to control how rustdoc emits documentation\n-in some cases.\n-\n-```\n-// Rustdoc will inline documentation of a `pub use` into this crate when the\n-// `pub use` reaches across crates, but this behavior can also be disabled.\n-#[doc(no_inline)]\n-pub use std::option::Option;\n-# fn main() {}\n-```\n-\n-Doc comments are markdown, and are currently parsed with the\n-[hoedown][hoedown] library. rustdoc does not yet do any fanciness such as\n-referencing other items inline, like javadoc's `@see`. One exception to this\n-is that the first paragraph will be used as the \"summary\" of an item in the\n-generated documentation:\n-\n-~~~\n-/// A whizbang. Does stuff. (this line is the summary)\n-///\n-/// Whizbangs are ...\n-struct Whizbang;\n-~~~\n-\n-To generate the docs, run `rustdoc universe.rs`. By default, it generates a\n-directory called `doc`, with the documentation for `universe` being in\n-`doc/universe/index.html`. If you are using other crates with `extern crate`,\n-rustdoc will even link to them when you use their types, as long as their\n-documentation has already been generated by a previous run of rustdoc, or the\n-crate advertises that its documentation is hosted at a given URL.\n-\n-The generated output can be controlled with the `doc` crate attribute, which\n-is how the above advertisement works. An example from the `libstd`\n-documentation:\n-\n-~~~\n-#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-      html_root_url = \"http://doc.rust-lang.org/\")];\n-~~~\n-\n-The `html_root_url` is the prefix that rustdoc will apply to any references to\n-that crate's types etc.\n-\n-rustdoc can also generate JSON, for consumption by other tools, with\n-`rustdoc --output-format json`, and also consume already-generated JSON with\n-`rustdoc --input-format json`.\n-\n-rustdoc also supports personalizing the output from crates' documentation,\n-similar to markdown options.\n-\n-- `--html-in-header FILE`: includes the contents of `FILE` at the\n-  end of the `<head>...</head>` section.\n-- `--html-before-content FILE`: includes the contents of `FILE`\n-  directly after `<body>`, before the rendered content (including the\n-  search bar).\n-- `--html-after-content FILE`: includes the contents of `FILE`\n-  after all the rendered content.\n-\n-# Using the Documentation\n-\n-The web pages generated by rustdoc present the same logical hierarchy that one\n-writes a library with. Every kind of item (function, struct, etc) has its own\n-color, and one can always click on a colored type to jump to its\n-documentation. There is a search bar at the top, which is powered by some\n-JavaScript and a statically-generated search index. No special web server is\n-required for the search.\n-\n-[hoedown]: https://github.com/hoedown/hoedown\n-\n-# Testing the Documentation\n-\n-`rustdoc` has support for testing code examples which appear in the\n-documentation. This is helpful for keeping code examples up to date with the\n-source code.\n-\n-To test documentation, the `--test` argument is passed to rustdoc:\n-\n-~~~ {.sh}\n-rustdoc --test crate.rs\n-~~~\n-\n-## Defining tests\n-\n-Rust documentation currently uses the markdown format, and rustdoc treats all\n-code blocks as testable-by-default unless they carry a language tag of another\n-language. In order to not run a test over a block of code, the `ignore` string\n-can be added to the three-backtick form of markdown code block.\n-\n-~~~md\n-```\n-// This is a testable code block\n-```\n-\n-```rust{.example}\n-// This is rust and also testable\n-```\n-\n-```ignore\n-// This is not a testable code block\n-```\n-\n-    // This is a testable code block (4-space indent)\n-\n-```sh\n-# this is shell code and not tested\n-```\n-~~~\n-\n-You can specify that the test's execution should fail with the `should_fail`\n-directive.\n-\n-~~~md\n-```should_fail\n-// This code block is expected to generate a panic when run\n-```\n-~~~\n-\n-You can specify that the code block should be compiled but not run with the\n-`no_run` directive.\n-\n-~~~md\n-```no_run\n-// This code will be compiled but not executed\n-```\n-~~~\n-\n-Lastly, you can specify that a code block be compiled as if `--test`\n-were passed to the compiler using the `test_harness` directive.\n-\n-~~~md\n-```test_harness\n-#[test]\n-fn foo() {\n-    panic!(\"oops! (will run & register as a failed test)\")\n-}\n-```\n-~~~\n-\n-Rustdoc also supplies some extra sugar for helping with some tedious\n-documentation examples. If a line is prefixed with `# `, then the line\n-will not show up in the HTML documentation, but it will be used when\n-testing the code block (NB. the space after the `#` is required, so\n-that one can still write things like `#[derive(Eq)]`).\n-\n-~~~md\n-```\n-# /!\\ The three following lines are comments, which are usually stripped off by\n-# the doc-generating tool.  In order to display them anyway in this particular\n-# case, the character following the leading '#' is not a usual space like in\n-# these first five lines but a non breakable one.\n-#\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n-#\u00a0// what's actually being documented.\n-#\u00a0fn fib(n: int) { n + 2 }\n-\n-spawn(move || { fib(200); })\n-```\n-~~~\n-\n-The documentation online would look like `spawn(move || { fib(200); })`, but when\n-testing this code, the `fib` function will be included (so it can compile).\n-\n-Rustdoc will automatically add a `main()` wrapper around your code, and in the right\n-place. For example:\n-\n-```\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-# fn foo() {}\n-```\n-\n-This will end up testing:\n-\n-```\n-fn main() {\n-    use std::rc::Rc;\n-    let five = Rc::new(5);\n-}\n-```\n-\n-Here's the full algorithm:\n-\n-1. Given a code block, if it does not contain `fn main`, it is wrapped in `fn main() { your_code }`\n-2. Given that result, if it contains no `extern crate` directives but it also\n-   contains the name of the crate being tested, then `extern crate <name>` is\n-   injected at the top.\n-3. Some common `allow` attributes are added for documentation examples at the top.\n-\n-## Running tests (advanced)\n-\n-Running tests often requires some special configuration to filter tests, find\n-libraries, or try running ignored examples. The testing framework that rustdoc\n-uses is built on crate `test`, which is also used when you compile crates with\n-rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n-with the `--test-args` flag.\n-\n-~~~console\n-# Only run tests containing 'foo' in their name\n-$ rustdoc --test lib.rs --test-args 'foo'\n-\n-# See what's possible when running tests\n-$ rustdoc --test lib.rs --test-args '--help'\n-~~~\n-\n-When testing a library, code examples will often show how functions are used,\n-and this code often requires `use`-ing paths from the crate. To accommodate this,\n-rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name of\n-the crate being tested to the top of each code example. This means that rustdoc\n-must be able to find a compiled version of the library crate being tested. Extra\n-search paths may be added via the `-L` flag to `rustdoc`.\n-\n-# Standalone Markdown files\n-\n-As well as Rust crates, rustdoc supports rendering pure Markdown files\n-into HTML and testing the code snippets from them. A Markdown file is\n-detected by a `.md` or `.markdown` extension.\n-\n-There are 4 options to modify the output that Rustdoc creates.\n-\n-- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n-- `--html-in-header FILE`: includes the contents of `FILE` at the\n-  end of the `<head>...</head>` section.\n-- `--html-before-content FILE`: includes the contents of `FILE`\n-  directly after `<body>`, before the rendered content (including the\n-  title).\n-- `--html-after-content FILE`: includes the contents of `FILE`\n-  directly before `</body>`, after all the rendered content.\n-\n-All of these can be specified multiple times, and they are output in\n-the order in which they are specified. The first line of the file being rendered must\n-be the title, prefixed with `%` (e.g. this page has `% Rust\n-Documentation` on the first line).\n-\n-Like with a Rust crate, the `--test` argument will run the code\n-examples to check they compile, and obeys any `--test-args` flags. The\n-tests are named after the last `#` heading.\n+This has been moved [into the book](book/documentation.html)."}, {"sha": "6131e1b8a70703066498f0c28a25122ae0aabcfc", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -16,6 +16,7 @@\n     * [Standard Input](standard-input.md)\n     * [Guessing Game](guessing-game.md)\n * [II: Intermediate Rust](intermediate.md)\n+    * [More Strings](more-strings.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [Testing](testing.md)\n     * [Pointers](pointers.md)\n@@ -28,6 +29,7 @@\n     * [Traits](traits.md)\n     * [Threads](threads.md)\n     * [Error Handling](error-handling.md)\n+    * [Documentation](documentation.md)\n * [III: Advanced Topics](advanced.md)\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)"}, {"sha": "efeb201efe8474977dc617783a395ec41811625c", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -287,8 +287,7 @@ mentioned earlier, you can use double colons to refer to sub-modules and the\n functions inside of them.\n \n Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n-rather than a library crate. Once we compile `src/main.rs`, we'll get an\n-executable that we can run. Our package now has two crates: `src/lib.rs` and\n+rather than a library crate. Our package now has two crates: `src/lib.rs` and\n `src/main.rs`. This pattern is quite common for executable crates: most\n functionality is in a library crate, and the executable crate uses that\n library. This way, other programs can also use the library crate, and it's also"}, {"sha": "0b686eb76dbfb2d5dcf1eba88d965d1c2b069cc7", "filename": "src/doc/trpl/documentation.md", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -0,0 +1,296 @@\n+% Rust Documentation\n+\n+`rustdoc` is the built-in tool for generating documentation. It integrates\n+with the compiler to provide accurate hyperlinking between usage of types and\n+their documentation. Furthermore, by not using a separate parser, it will\n+never reject your valid Rust code.\n+\n+# Creating Documentation\n+\n+Documenting Rust APIs is quite simple. To document a given item, we have \"doc\n+comments\":\n+\n+~~~\n+# #![allow(unused_attribute)]\n+// the \"link\" crate attribute is currently required for rustdoc, but normally\n+// isn't needed.\n+#![crate_id = \"universe\"]\n+#![crate_type=\"lib\"]\n+\n+//! Tools for dealing with universes (this is a doc comment, and is shown on\n+//! the crate index page. The ! makes it apply to the parent of the comment,\n+//! rather than what follows).\n+\n+# mod workaround_the_outer_function_rustdoc_inserts {\n+/// Widgets are very common (this is a doc comment, and will show up on\n+/// Widget's documentation).\n+pub struct Widget {\n+\t/// All widgets have a purpose (this is a doc comment, and will show up\n+\t/// the field's documentation).\n+\tpurpose: String,\n+\t/// Humans are not allowed to understand some widgets\n+\tunderstandable: bool\n+}\n+\n+pub fn recalibrate() {\n+\t//! Recalibrate a pesky universe (this is also a doc comment, like above,\n+\t//! the documentation will be applied to the *parent* item, so\n+\t//! `recalibrate`).\n+\t/* ... */\n+}\n+# }\n+~~~\n+\n+Documentation can also be controlled via the `doc` attribute on items. This is\n+implicitly done by the compiler when using the above form of doc comments\n+(converting the slash-based comments to `#[doc]` attributes).\n+\n+~~~\n+#[doc = \"\n+Calculates the factorial of a number.\n+\n+Given the input integer `n`, this function will calculate `n!` and return it.\n+\"]\n+pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n - 1)} }\n+# fn main() {}\n+~~~\n+\n+The `doc` attribute can also be used to control how rustdoc emits documentation\n+in some cases.\n+\n+```\n+// Rustdoc will inline documentation of a `pub use` into this crate when the\n+// `pub use` reaches across crates, but this behavior can also be disabled.\n+#[doc(no_inline)]\n+pub use std::option::Option;\n+# fn main() {}\n+```\n+\n+Doc comments are markdown, and are currently parsed with the\n+[hoedown][hoedown] library. rustdoc does not yet do any fanciness such as\n+referencing other items inline, like javadoc's `@see`. One exception to this\n+is that the first paragraph will be used as the \"summary\" of an item in the\n+generated documentation:\n+\n+~~~\n+/// A whizbang. Does stuff. (this line is the summary)\n+///\n+/// Whizbangs are ...\n+struct Whizbang;\n+~~~\n+\n+To generate the docs, run `rustdoc universe.rs`. By default, it generates a\n+directory called `doc`, with the documentation for `universe` being in\n+`doc/universe/index.html`. If you are using other crates with `extern crate`,\n+rustdoc will even link to them when you use their types, as long as their\n+documentation has already been generated by a previous run of rustdoc, or the\n+crate advertises that its documentation is hosted at a given URL.\n+\n+The generated output can be controlled with the `doc` crate attribute, which\n+is how the above advertisement works. An example from the `libstd`\n+documentation:\n+\n+~~~\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/\")];\n+~~~\n+\n+The `html_root_url` is the prefix that rustdoc will apply to any references to\n+that crate's types etc.\n+\n+rustdoc can also generate JSON, for consumption by other tools, with\n+`rustdoc --output-format json`, and also consume already-generated JSON with\n+`rustdoc --input-format json`.\n+\n+rustdoc also supports personalizing the output from crates' documentation,\n+similar to markdown options.\n+\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--html-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  search bar).\n+- `--html-after-content FILE`: includes the contents of `FILE`\n+  after all the rendered content.\n+\n+# Using the Documentation\n+\n+The web pages generated by rustdoc present the same logical hierarchy that one\n+writes a library with. Every kind of item (function, struct, etc) has its own\n+color, and one can always click on a colored type to jump to its\n+documentation. There is a search bar at the top, which is powered by some\n+JavaScript and a statically-generated search index. No special web server is\n+required for the search.\n+\n+[hoedown]: https://github.com/hoedown/hoedown\n+\n+# Testing the Documentation\n+\n+`rustdoc` has support for testing code examples which appear in the\n+documentation. This is helpful for keeping code examples up to date with the\n+source code.\n+\n+To test documentation, the `--test` argument is passed to rustdoc:\n+\n+~~~ {.sh}\n+rustdoc --test crate.rs\n+~~~\n+\n+## Defining tests\n+\n+Rust documentation currently uses the markdown format, and rustdoc treats all\n+code blocks as testable-by-default unless they carry a language tag of another\n+language. In order to not run a test over a block of code, the `ignore` string\n+can be added to the three-backtick form of markdown code block.\n+\n+~~~md\n+```\n+// This is a testable code block\n+```\n+\n+```rust{.example}\n+// This is rust and also testable\n+```\n+\n+```ignore\n+// This is not a testable code block\n+```\n+\n+    // This is a testable code block (4-space indent)\n+\n+```sh\n+# this is shell code and not tested\n+```\n+~~~\n+\n+You can specify that the test's execution should fail with the `should_fail`\n+directive.\n+\n+~~~md\n+```should_fail\n+// This code block is expected to generate a panic when run\n+```\n+~~~\n+\n+You can specify that the code block should be compiled but not run with the\n+`no_run` directive.\n+\n+~~~md\n+```no_run\n+// This code will be compiled but not executed\n+```\n+~~~\n+\n+Lastly, you can specify that a code block be compiled as if `--test`\n+were passed to the compiler using the `test_harness` directive.\n+\n+~~~md\n+```test_harness\n+#[test]\n+fn foo() {\n+    panic!(\"oops! (will run & register as a failed test)\")\n+}\n+```\n+~~~\n+\n+Rustdoc also supplies some extra sugar for helping with some tedious\n+documentation examples. If a line is prefixed with `# `, then the line\n+will not show up in the HTML documentation, but it will be used when\n+testing the code block (NB. the space after the `#` is required, so\n+that one can still write things like `#[derive(Eq)]`).\n+\n+~~~md\n+```\n+# /!\\ The three following lines are comments, which are usually stripped off by\n+# the doc-generating tool.  In order to display them anyway in this particular\n+# case, the character following the leading '#' is not a usual space like in\n+# these first five lines but a non breakable one.\n+#\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n+#\u00a0// what's actually being documented.\n+#\u00a0fn fib(n: int) { n + 2 }\n+\n+spawn(move || { fib(200); })\n+```\n+~~~\n+\n+The documentation online would look like `spawn(move || { fib(200); })`, but when\n+testing this code, the `fib` function will be included (so it can compile).\n+\n+Rustdoc will automatically add a `main()` wrapper around your code, and in the right\n+place. For example:\n+\n+```\n+/// ```\n+/// use std::rc::Rc;\n+///\n+/// let five = Rc::new(5);\n+/// ```\n+# fn foo() {}\n+```\n+\n+This will end up testing:\n+\n+```\n+fn main() {\n+    use std::rc::Rc;\n+    let five = Rc::new(5);\n+}\n+```\n+\n+Here's the full algorithm:\n+\n+1. Given a code block, if it does not contain `fn main`, it is wrapped in `fn main() { your_code }`\n+2. Given that result, if it contains no `extern crate` directives but it also\n+   contains the name of the crate being tested, then `extern crate <name>` is\n+   injected at the top.\n+3. Some common `allow` attributes are added for documentation examples at the top.\n+\n+## Running tests (advanced)\n+\n+Running tests often requires some special configuration to filter tests, find\n+libraries, or try running ignored examples. The testing framework that rustdoc\n+uses is built on crate `test`, which is also used when you compile crates with\n+rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n+with the `--test-args` flag.\n+\n+~~~console\n+# Only run tests containing 'foo' in their name\n+$ rustdoc --test lib.rs --test-args 'foo'\n+\n+# See what's possible when running tests\n+$ rustdoc --test lib.rs --test-args '--help'\n+~~~\n+\n+When testing a library, code examples will often show how functions are used,\n+and this code often requires `use`-ing paths from the crate. To accommodate this,\n+rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name of\n+the crate being tested to the top of each code example. This means that rustdoc\n+must be able to find a compiled version of the library crate being tested. Extra\n+search paths may be added via the `-L` flag to `rustdoc`.\n+\n+# Standalone Markdown files\n+\n+As well as Rust crates, rustdoc supports rendering pure Markdown files\n+into HTML and testing the code snippets from them. A Markdown file is\n+detected by a `.md` or `.markdown` extension.\n+\n+There are 4 options to modify the output that Rustdoc creates.\n+\n+- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--html-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  title).\n+- `--html-after-content FILE`: includes the contents of `FILE`\n+  directly before `</body>`, after all the rendered content.\n+\n+All of these can be specified multiple times, and they are output in\n+the order in which they are specified. The first line of the file being rendered must\n+be the title, prefixed with `%` (e.g. this page has `% Rust\n+Documentation` on the first line).\n+\n+Like with a Rust crate, the `--test` argument will run the code\n+examples to check they compile, and obeys any `--test-args` flags. The\n+tests are named after the last `#` heading."}, {"sha": "07b49751b10a0f377c53919256d610217b9c410d", "filename": "src/doc/trpl/more-strings.md", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -0,0 +1,283 @@\n+% More Strings\n+\n+Strings are an important concept to master in any programming language. If you\n+come from a managed language background, you may be surprised at the complexity\n+of string handling in a systems programming language. Efficient access and\n+allocation of memory for a dynamically sized structure involves a lot of\n+details. Luckily, Rust has lots of tools to help us here.\n+\n+A **string** is a sequence of unicode scalar values encoded as a stream of\n+UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n+Additionally, strings are not null-terminated and can contain null bytes.\n+\n+Rust has two main types of strings: `&str` and `String`.\n+\n+# &str\n+\n+The first kind is a `&str`. This is pronounced a 'string slice'.\n+String literals are of the type `&str`:\n+\n+```\n+let string = \"Hello there.\";\n+```\n+\n+Like any Rust reference, string slices have an associated lifetime. A string\n+literal is a `&'static str`.  A string slice can be written without an explicit\n+lifetime in many cases, such as in function arguments. In these cases the\n+lifetime will be inferred:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+```\n+\n+Like vector slices, string slices are simply a pointer plus a length. This\n+means that they're a 'view' into an already-allocated string, such as a\n+string literal or a `String`.\n+\n+# String\n+\n+A `String` is a heap-allocated string. This string is growable, and is also\n+guaranteed to be UTF-8.\n+\n+```\n+let mut s = \"Hello\".to_string();\n+println!(\"{}\", s);\n+\n+s.push_str(\", world.\");\n+println!(\"{}\", s);\n+```\n+\n+You can coerce a `String` into a `&str` by dereferencing it:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+\n+fn main() {\n+    let s = \"Hello\".to_string();\n+    takes_slice(&*s);\n+}\n+```\n+\n+You can also get a `&str` from a stack-allocated array of bytes:\n+\n+```\n+use std::str;\n+\n+let x: &[u8] = &[b'a', b'b'];\n+let stack_str: &str = str::from_utf8(x).unwrap();\n+```\n+\n+# Best Practices\n+\n+## `String` vs. `&str`\n+\n+In general, you should prefer `String` when you need ownership, and `&str` when\n+you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n+and `T` vs `&T` in general.\n+\n+This means starting off with this:\n+\n+```{rust,ignore}\n+fn foo(s: &str) {\n+```\n+\n+and only moving to this:\n+\n+```{rust,ignore}\n+fn foo(s: String) {\n+```\n+\n+If you have good reason. It's not polite to hold on to ownership you don't\n+need, and it can make your lifetimes more complex.\n+\n+## Generic functions\n+\n+To write a function that's generic over types of strings, use `&str`.\n+\n+```\n+fn some_string_length(x: &str) -> uint {\n+        x.len()\n+}\n+\n+fn main() {\n+    let s = \"Hello, world\";\n+\n+    println!(\"{}\", some_string_length(s));\n+\n+    let s = \"Hello, world\".to_string();\n+\n+    println!(\"{}\", some_string_length(s.as_slice()));\n+}\n+```\n+\n+Both of these lines will print `12`.\n+\n+## Indexing strings\n+\n+You may be tempted to try to access a certain character of a `String`, like\n+this:\n+\n+```{rust,ignore}\n+let s = \"hello\".to_string();\n+\n+println!(\"{}\", s[0]);\n+```\n+\n+This does not compile. This is on purpose. In the world of UTF-8, direct\n+indexing is basically never what you want to do. The reason is that each\n+character can be a variable number of bytes. This means that you have to iterate\n+through the characters anyway, which is an O(n) operation.\n+\n+There's 3 basic levels of unicode (and its encodings):\n+\n+- code units, the underlying data type used to store everything\n+- code points/unicode scalar values (char)\n+- graphemes (visible characters)\n+\n+Rust provides iterators for each of these situations:\n+\n+- `.bytes()` will iterate over the underlying bytes\n+- `.chars()` will iterate over the code points\n+- `.graphemes()` will iterate over each grapheme\n+\n+Usually, the `graphemes()` method on `&str` is what you want:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.graphemes(true) {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\u0354\n+n\u030e\u0348\u0330\n+i\u0319\u032e\u035a\u0326\n+c\u0309\u035a\n+o\u0357\u033c\u0329\u0330\n+d\u0306\u0343\u0365\u0354\n+e\u0301\n+```\n+\n+Note that `l` has the type `&str` here, since a single grapheme can consist of\n+multiple codepoints, so a `char` wouldn't be appropriate.\n+\n+This will print out each visible character in turn, as you'd expect: first \"u\u0354\", then\n+\"n\u030e\u0348\u0330\", etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.chars() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\n+\u0354\n+n\n+\u030e\n+\u0348\n+\u0330\n+i\n+\u0319\n+\u032e\n+\u035a\n+\u0326\n+c\n+\u0309\n+\u035a\n+o\n+\u0357\n+\u033c\n+\u0329\n+\u0330\n+d\n+\u0306\n+\u0343\n+\u0365\n+\u0354\n+e\n+\u0301\n+```\n+\n+You can see how some of them are combining characters, and therefore the output\n+looks a bit odd.\n+\n+If you want the individual byte representation of each codepoint, you can use\n+`.bytes()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.bytes() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This will print:\n+\n+```text\n+117\n+205\n+148\n+110\n+204\n+142\n+205\n+136\n+204\n+176\n+105\n+204\n+153\n+204\n+174\n+205\n+154\n+204\n+166\n+99\n+204\n+137\n+205\n+154\n+111\n+205\n+151\n+204\n+188\n+204\n+169\n+204\n+176\n+100\n+204\n+134\n+205\n+131\n+205\n+165\n+205\n+148\n+101\n+204\n+129\n+```\n+\n+Many more bytes than graphemes!\n+\n+# Other Documentation\n+\n+* [the `&str` API documentation](std/str/index.html)\n+* [the `String` API documentation](std/string/index.html)"}, {"sha": "56cb5b1de699c4fd0aa40427db595d5a83faf39a", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -244,8 +244,8 @@ three. The ownership system in Rust does this through a concept called\n Remember the function that borrowed an `i32`? Let's look at it again.\n \n ```rust\n-fn add_one(num: &i32) -> i32 {\n-    *num + 1\n+fn add_one(num: &mut i32) {\n+    *num += 1;\n }\n ```\n \n@@ -255,8 +255,8 @@ cover the others later. Without eliding the lifetimes, `add_one` looks like\n this:\n \n ```rust\n-fn add_one<'a>(num: &'a i32) -> i32 {\n-    *num + 1\n+fn add_one<'a>(num: &'a mut i32) {\n+    *num += 1;\n }\n ```\n \n@@ -278,12 +278,12 @@ fn add_two<'a, 'b>(...)\n Then in our parameter list, we use the lifetimes we've named:\n \n ```{rust,ignore}\n-...(num: &'a i32) -> ...\n+...(num: &'a mut i32)\n ```\n \n-If you compare `&i32` to `&'a i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `i32`. We read `&i32` as \"a\n-reference to an i32\" and `&'a i32` as \"a reference to an i32 with the lifetime 'a.'\"\n+If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n+lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n+mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n \n Why do lifetimes matter? Well, for example, here's some code:\n "}, {"sha": "29986d7f23577c499982e3118311aa4f8f8d89f6", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -87,7 +87,7 @@ println!(\"{}\", x + z);\n This gives us an error:\n \n ```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `i32` but found `&i32` (expected i32 but found &-ptr)\n+hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n ```\n@@ -305,7 +305,7 @@ References are immutable by default:\n let x = 5;\n let y = &x;\n \n-*y = 5; // error: cannot assign to immutable dereference of `&`-pointer `*y`\n+*y = 5; // error: cannot assign to immutable borrowed content `*y`\n ```\n \n They can be made mutable with `mut`, but only if its referent is also mutable.\n@@ -668,7 +668,7 @@ struct BigStruct {\n }\n \n fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n-    return Box::new(*x);\n+    Box::new(*x)\n }\n \n fn main() {\n@@ -696,7 +696,7 @@ struct BigStruct {\n }\n \n fn foo(x: Box<BigStruct>) -> BigStruct {\n-    return *x;\n+    *x\n }\n \n fn main() {"}, {"sha": "c4abedf3fe89a4324e4aa84a1153c154db3d19d9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 68, "deletions": 11, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -8,7 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A unique pointer type.\n+//! A pointer type for heap allocation.\n+//!\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n+//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n+//! scope.\n+//!\n+//! Boxes are useful in two situations: recursive data structures, and occasionally when returning\n+//! data. [The Pointer chapter of the Book](../../../book/pointers.html#best-practices-1) explains\n+//! these cases in detail.\n+//!\n+//! # Examples\n+//!\n+//! Creating a box:\n+//!\n+//! ```\n+//! let x = Box::new(5);\n+//! ```\n+//!\n+//! Creating a recursive data structure:\n+//!\n+//! ```\n+//! #[derive(Show)]\n+//! enum List<T> {\n+//!     Cons(T, Box<List<T>>),\n+//!     Nil,\n+//! }\n+//!\n+//! fn main() {\n+//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//!     println!(\"{:?}\", list);\n+//! }\n+//! ```\n+//!\n+//! This will print `Cons(1i32, Box(Cons(2i32, Box(Nil))))`.\n \n #![stable]\n \n@@ -29,8 +62,8 @@ use core::raw::TraitObject;\n use core::result::Result::{Ok, Err};\n use core::result::Result;\n \n-/// A value that represents the global exchange heap. This is the default\n-/// place that the `box` keyword allocates into when no place is supplied.\n+/// A value that represents the heap. This is the default place that the `box` keyword allocates\n+/// into when no place is supplied.\n ///\n /// The following two examples are equivalent:\n ///\n@@ -39,23 +72,29 @@ use core::result::Result;\n /// use std::boxed::HEAP;\n ///\n /// fn main() {\n-/// # struct Bar;\n-/// # impl Bar { fn new(_a: int) { } }\n-///     let foo = box(HEAP) Bar::new(2);\n-///     let foo = box Bar::new(2);\n+///     let foo = box(HEAP) 5;\n+///     let foo = box 5;\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n #[unstable = \"may be renamed; uncertain about custom allocator design\"]\n pub static HEAP: () = ();\n \n-/// A type that represents a uniquely-owned value.\n+/// A pointer type for heap allocation.\n+///\n+/// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n-    /// Moves `x` into a freshly allocated box on the global exchange heap.\n+    /// Allocates memory on the heap and then moves `x` into it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(x: T) -> Box<T> {\n         box x\n@@ -76,11 +115,29 @@ impl<T> Default for Box<[T]> {\n \n #[stable]\n impl<T: Clone> Clone for Box<T> {\n-    /// Returns a copy of the owned box.\n+    /// Returns a new box with a `clone()` of this box's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let y = x.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Box<T> { box {(**self).clone()} }\n \n-    /// Performs copy-assignment from `source` by reusing the existing allocation.\n+    /// Copies `source`'s contents into `self` without creating a new allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let mut y = Box::new(10);\n+    ///\n+    /// y.clone_from(&x);\n+    ///\n+    /// assert_eq!(*y, 5);\n+    /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n         (**self).clone_from(&(**source));"}, {"sha": "f65802de5ac6e79d88f5dc5177f27c28f6833c1a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -967,11 +967,30 @@ impl<T> SliceExt for [T] {\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"hello\", \"world\"];\n+    ///\n+    /// let s: String = v.concat();\n+    ///\n+    /// println!(\"{}\", s); // prints \"helloworld\"\n+    /// ```\n     #[stable]\n     fn concat(&self) -> U;\n \n-    /// Flattens a slice of `T` into a single value `U`, placing a\n-    /// given separator between each.\n+    /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"hello\", \"world\"];\n+    ///\n+    /// let s: String = v.connect(\" \");\n+    ///\n+    /// println!(\"{}\", s); // prints \"hello world\"\n+    /// ```\n     #[stable]\n     fn connect(&self, sep: &T) -> U;\n }"}, {"sha": "7f73be9eb5f4dd94598236dc6eb75c17b3dc1c0f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -74,6 +74,10 @@\n //! }\n //! ```\n //!\n+//! Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\n+//! scenarios. Consider using `Mutex<T>` if you need shared mutability in a multi-threaded\n+//! situation.\n+//!\n //! ## Implementation details of logically-immutable methods\n //!\n //! Occasionally it may be desirable not to expose in an API that"}, {"sha": "a07fd61cd8c34cd95d1e3ff93c2d856d892866b7", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -555,7 +555,8 @@ pub mod types {\n                 pub type mode_t = u16;\n                 pub type ssize_t = i32;\n             }\n-            #[cfg(target_arch = \"x86\")]\n+            #[cfg(any(target_arch = \"x86\",\n+                      target_arch = \"powerpc\"))]\n             pub mod posix01 {\n                 use types::os::arch::c95::{c_short, c_long, time_t};\n                 use types::os::arch::posix88::{dev_t, gid_t, ino_t};\n@@ -646,8 +647,7 @@ pub mod types {\n                 }\n             }\n             #[cfg(any(target_arch = \"mips\",\n-                      target_arch = \"mipsel\",\n-                      target_arch = \"powerpc\"))]\n+                      target_arch = \"mipsel\"))]\n             pub mod posix01 {\n                 use types::os::arch::c95::{c_long, c_ulong, time_t};\n                 use types::os::arch::posix88::{gid_t, ino_t};\n@@ -2491,7 +2491,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n-                  target_arch = \"aarch64\"))]\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod posix88 {\n             use types::os::arch::c95::c_int;\n             use types::common::c95::c_void;\n@@ -2704,8 +2705,7 @@ pub mod consts {\n         }\n \n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod posix88 {\n             use types::os::arch::c95::c_int;\n             use types::common::c95::c_void;\n@@ -3002,7 +3002,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"arm\",\n                   target_arch = \"aarch64\",\n                   target_arch = \"x86\",\n-                  target_arch = \"x86_64\"))]\n+                  target_arch = \"x86_64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod bsd44 {\n             use types::os::arch::c95::c_int;\n \n@@ -3050,8 +3051,7 @@ pub mod consts {\n             pub const SHUT_RDWR: c_int = 2;\n         }\n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod bsd44 {\n             use types::os::arch::c95::c_int;\n \n@@ -3099,7 +3099,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n-                  target_arch = \"aarch64\"))]\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n \n@@ -3127,8 +3128,7 @@ pub mod consts {\n             pub const MAP_STACK : c_int = 0x020000;\n         }\n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n "}, {"sha": "39413d63482499bc828e13b751c6409ce73a2c0e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -2088,7 +2088,13 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+\n+    // The `Ty` values returned by `ty::struct_fields` can still contain\n+    // `ty_projection` variants, so normalize those away.\n+    for field in fields.iter_mut() {\n+        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n+    }\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,"}, {"sha": "21bea5dcdcb82f334066b85eed23d4134029f1c4", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -49,8 +49,8 @@\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `DList` when:\n-//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate inconsistent\n-//! performance during insertions.\n+//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate amortization.\n+//! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n //!\n //! ### Use a `HashMap` when:\n@@ -85,6 +85,56 @@\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n //!\n+//! # Performance\n+//!\n+//! Choosing the right collection for the job requires an understanding of what each collection\n+//! is good at. Here we briefly summarize the performance of different collections for certain\n+//! important operations. For further details, see each type's documentation.\n+//!\n+//! Throughout the documentation, we will follow a few conventions. For all operations,\n+//! the collection's size is denoted by n. If another collection is involved in the operation, it\n+//! contains m elements. Operations which have an *amortized* cost are suffixed with a `*`.\n+//! Operations with an *expected* cost are suffixed with a `~`.\n+//!\n+//! All amortized costs are for the potential need to resize when capacity is exhausted.\n+//! If a resize occurs it will take O(n) time. Our collections never automatically shrink,\n+//! so removal operations aren't amortized. Over a sufficiently large series of\n+//! operations, the average cost per operation will deterministically equal the given cost.\n+//!\n+//! Only HashMap has expected costs, due to the probabilistic nature of hashing. It is\n+//! theoretically possible, though very unlikely, for HashMap to experience worse performance.\n+//!\n+//! ## Sequences\n+//!\n+//! |         | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |---------|----------------|-----------------|----------------|--------|----------------|\n+//! | Vec     | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | RingBuf | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | DList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! | Bitv    | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//!\n+//! Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf\n+//! is generally going to be faster than DList. Bitv is not a general purpose collection, and\n+//! therefore cannot reasonably be compared.\n+//!\n+//! ## Maps\n+//!\n+//! For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,\n+//! refer to VecMap.\n+//!\n+//! |          | get       | insert   | remove   | predecessor |\n+//! |----------|-----------|----------|----------|-------------|\n+//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         |\n+//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    |\n+//! | VecMap   | O(1)      | O(1)?    | O(1)     | O(n)        |\n+//!\n+//! Note that VecMap is *incredibly* inefficient in terms of space. The O(1) insertion time\n+//! assumes space for the element is already allocated. Otherwise, a large key may require a\n+//! massive reallocation, with no direct relation to the number of elements in the collection.\n+//! VecMap should only be seriously considered for small keys.\n+//!\n+//! Note also that BTreeMap's precise preformance depends on the value of B.\n+//!\n //! # Correct and Efficient Usage of Collections\n //!\n //! Of course, knowing which collection is the right one for the job doesn't instantly"}, {"sha": "b313a5312bcfa10617e09288cfcd37bb8afcfbf0", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -152,7 +152,7 @@ pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n     }\n }\n \n-/// Test if the current thread is currently panicking.\n+/// Determines whether the current thread is unwinding because of panic.\n pub fn panicking() -> bool {\n     PANICKING.with(|s| s.get())\n }"}, {"sha": "8cc2cac33ecdce6dede3e8a0283772a8ab529265", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -130,7 +130,15 @@ pub struct RwLockWriteGuard<'a, T: 'a> {\n impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T: Send + Sync> RwLock<T> {\n-    /// Creates a new instance of an RwLock which is unlocked and read to go.\n+    /// Creates a new instance of an `RwLock<T>` which is unlocked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }"}, {"sha": "a86b82b8c62ec210817f71c2d8f6620d76915b13", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -382,7 +382,7 @@ impl Thread {\n         unsafe { imp::yield_now() }\n     }\n \n-    /// Determines whether the current thread is panicking.\n+    /// Determines whether the current thread is unwinding because of panic.\n     #[inline]\n     #[stable]\n     pub fn panicking() -> bool {"}, {"sha": "6a624e39e326775c93c0bf3d9a2522a3ad8984d4", "filename": "src/test/debuginfo/associated-types.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4874ca36f61d1975398c2ddb9e3d43443a8c373b/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs?ref=4874ca36f61d1975398c2ddb9e3d43443a8c373b", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+// gdb-command:run\n+\n+// gdb-command:print arg\n+// gdb-check:$1 = {b = -1, b1 = 0}\n+// gdb-command:continue\n+\n+// gdb-command:print inferred\n+// gdb-check:$2 = 1\n+// gdb-command:print explicitly\n+// gdb-check:$3 = 1\n+// gdb-command:continue\n+\n+// gdb-command:print arg\n+// gdb-check:$4 = 2\n+// gdb-command:continue\n+\n+// gdb-command:print arg\n+// gdb-check:$5 = {4, 5}\n+// gdb-command:continue\n+\n+// gdb-command:print a\n+// gdb-check:$6 = 6\n+// gdb-command:print b\n+// gdb-check:$7 = 7\n+// gdb-command:continue\n+\n+// gdb-command:print a\n+// gdb-check:$8 = 8\n+// gdb-command:print b\n+// gdb-check:$9 = 9\n+// gdb-command:continue\n+\n+// === LLDB TESTS ==================================================================================\n+// lldb-command:run\n+\n+// lldb-command:print arg\n+// lldb-check:[...]$0 = Struct<i32> { b: -1, b1: 0 }\n+// lldb-command:continue\n+\n+// lldb-command:print inferred\n+// lldb-check:[...]$1 = 1\n+// lldb-command:print explicitly\n+// lldb-check:[...]$2 = 1\n+// lldb-command:continue\n+\n+// lldb-command:print arg\n+// lldb-check:[...]$3 = 2\n+// lldb-command:continue\n+\n+// lldb-command:print arg\n+// lldb-check:[...]$4 = (4, 5)\n+// lldb-command:continue\n+\n+// lldb-command:print a\n+// lldb-check:[...]$5 = 6\n+// lldb-command:print b\n+// lldb-check:[...]$6 = 7\n+// lldb-command:continue\n+\n+// lldb-command:print a\n+// lldb-check:[...]$7 = 8\n+// lldb-command:print b\n+// lldb-check:[...]$8 = 9\n+// lldb-command:continue\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![omit_gdb_pretty_printer_section]\n+\n+trait TraitWithAssocType {\n+    type Type;\n+\n+    fn get_value(&self) -> Self::Type;\n+}\n+impl TraitWithAssocType for i32 {\n+    type Type = i64;\n+\n+    fn get_value(&self) -> i64 { *self as i64 }\n+}\n+\n+struct Struct<T: TraitWithAssocType> {\n+    b: T,\n+    b1: T::Type,\n+}\n+\n+enum Enum<T: TraitWithAssocType> {\n+    Variant1(T, T::Type),\n+    Variant2(T::Type, T)\n+}\n+\n+fn assoc_struct<T: TraitWithAssocType>(arg: Struct<T>) {\n+    zzz(); // #break\n+}\n+\n+fn assoc_local<T: TraitWithAssocType>(x: T) {\n+    let inferred = x.get_value();\n+    let explicitly: T::Type = x.get_value();\n+\n+    zzz(); // #break\n+}\n+\n+fn assoc_arg<T: TraitWithAssocType>(arg: T::Type) {\n+    zzz(); // #break\n+}\n+\n+fn assoc_return_value<T: TraitWithAssocType>(arg: T) -> T::Type {\n+    return arg.get_value();\n+}\n+\n+fn assoc_tuple<T: TraitWithAssocType>(arg: (T, T::Type)) {\n+    zzz(); // #break\n+}\n+\n+fn assoc_enum<T: TraitWithAssocType>(arg: Enum<T>) {\n+\n+    match arg {\n+        Enum::Variant1(a, b) => {\n+            zzz(); // #break\n+        }\n+        Enum::Variant2(a, b) => {\n+            zzz(); // #break\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assoc_struct(Struct { b: -1i32, b1: 0i64 });\n+    assoc_local(1i32);\n+    assoc_arg::<i32>(2i64);\n+    assoc_return_value(3i32);\n+    assoc_tuple((4i32, 5i64));\n+    assoc_enum(Enum::Variant1(6i32, 7i64));\n+    assoc_enum(Enum::Variant2(8i64, 9i32));\n+}\n+\n+fn zzz() { () }\n\\ No newline at end of file"}]}