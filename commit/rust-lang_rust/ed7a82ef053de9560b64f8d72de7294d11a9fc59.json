{"sha": "ed7a82ef053de9560b64f8d72de7294d11a9fc59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkN2E4MmVmMDUzZGU5NTYwYjY0ZjhkNzJkZTcyOTRkMTFhOWZjNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-17T22:02:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-17T22:02:04Z"}, "message": "Auto merge of #7653 - lengyijun:same_name_method_crate, r=llogiq\n\nNew lint: `same_name_method`\n\nchangelog: ``[`same_name_method`]``\nfix: https://github.com/rust-lang/rust-clippy/issues/7632\n\nIt only compares a method in `impl` with another in `impl trait for`\nIt doesn't lint two methods in two traits.\n\nI'm not sure my approach is the best way. I meet difficulty in other approaches.", "tree": {"sha": "3bf9173934b2117b7202ddeee1e7b80f73420fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bf9173934b2117b7202ddeee1e7b80f73420fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed7a82ef053de9560b64f8d72de7294d11a9fc59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7a82ef053de9560b64f8d72de7294d11a9fc59", "html_url": "https://github.com/rust-lang/rust/commit/ed7a82ef053de9560b64f8d72de7294d11a9fc59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed7a82ef053de9560b64f8d72de7294d11a9fc59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f99b4adb93ec17ad2d31309deb9275f08ff5c506", "url": "https://api.github.com/repos/rust-lang/rust/commits/f99b4adb93ec17ad2d31309deb9275f08ff5c506", "html_url": "https://github.com/rust-lang/rust/commit/f99b4adb93ec17ad2d31309deb9275f08ff5c506"}, {"sha": "e2cdaec98437ea317eead6c90336d3462c779608", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2cdaec98437ea317eead6c90336d3462c779608", "html_url": "https://github.com/rust-lang/rust/commit/e2cdaec98437ea317eead6c90336d3462c779608"}], "stats": {"total": 340, "additions": 340, "deletions": 0}, "files": [{"sha": "72fe6ae31735608be01f1a143293fdbdc1a35ceb", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a82ef053de9560b64f8d72de7294d11a9fc59/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a82ef053de9560b64f8d72de7294d11a9fc59/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ed7a82ef053de9560b64f8d72de7294d11a9fc59", "patch": "@@ -2906,6 +2906,7 @@ Released 2018-09-13\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n+[`same_name_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_name_method\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`self_named_constructors`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_constructors"}, {"sha": "59d87aa96dcf408872f1d954b60357d7e3b6e074", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a82ef053de9560b64f8d72de7294d11a9fc59/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a82ef053de9560b64f8d72de7294d11a9fc59/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ed7a82ef053de9560b64f8d72de7294d11a9fc59", "patch": "@@ -331,6 +331,7 @@ mod reference;\n mod regex;\n mod repeat_once;\n mod returns;\n+mod same_name_method;\n mod self_assignment;\n mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n@@ -910,6 +911,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         repeat_once::REPEAT_ONCE,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n+        same_name_method::SAME_NAME_METHOD,\n         self_assignment::SELF_ASSIGNMENT,\n         self_named_constructors::SELF_NAMED_CONSTRUCTORS,\n         semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED,\n@@ -1053,6 +1055,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(panic_unimplemented::UNIMPLEMENTED),\n         LintId::of(panic_unimplemented::UNREACHABLE),\n         LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+        LintId::of(same_name_method::SAME_NAME_METHOD),\n         LintId::of(shadow::SHADOW_REUSE),\n         LintId::of(shadow::SHADOW_SAME),\n         LintId::of(strings::STRING_ADD),\n@@ -1922,6 +1925,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n \n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n+    store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow));"}, {"sha": "014898e6dab11ce533cd4d84db40c3d795e460f3", "filename": "clippy_lints/src/same_name_method.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a82ef053de9560b64f8d72de7294d11a9fc59/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a82ef053de9560b64f8d72de7294d11a9fc59/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=ed7a82ef053de9560b64f8d72de7294d11a9fc59", "patch": "@@ -0,0 +1,160 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{Crate, Impl, ItemKind, Node, Path, QPath, TraitRef, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::AssocKind;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+use std::collections::{BTreeMap, BTreeSet};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It lints if a struct has two method with same time:\n+    /// one from a trait, another not from trait.\n+    ///\n+    /// ### Why is this bad?\n+    /// Confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// trait T {\n+    ///     fn foo(&self) {}\n+    /// }\n+    ///\n+    /// struct S;\n+    ///\n+    /// impl T for S {\n+    ///     fn foo(&self) {}\n+    /// }\n+    ///\n+    /// impl S {\n+    ///     fn foo(&self) {}\n+    /// }\n+    /// ```\n+    pub SAME_NAME_METHOD,\n+    restriction,\n+    \"two method with same name\"\n+}\n+\n+declare_lint_pass!(SameNameMethod => [SAME_NAME_METHOD]);\n+\n+struct ExistingName {\n+    impl_methods: BTreeMap<Symbol, Span>,\n+    trait_methods: BTreeMap<Symbol, Vec<Span>>,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'tcx>) {\n+        let mut map = FxHashMap::<Res, ExistingName>::default();\n+\n+        for item in krate.items() {\n+            if let ItemKind::Impl(Impl {\n+                items,\n+                of_trait,\n+                self_ty,\n+                ..\n+            }) = &item.kind\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind {\n+                    if !map.contains_key(res) {\n+                        map.insert(\n+                            *res,\n+                            ExistingName {\n+                                impl_methods: BTreeMap::new(),\n+                                trait_methods: BTreeMap::new(),\n+                            },\n+                        );\n+                    }\n+                    let existing_name = map.get_mut(res).unwrap();\n+\n+                    match of_trait {\n+                        Some(trait_ref) => {\n+                            let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n+                                if let Some(Node::TraitRef(TraitRef { path, .. })) =\n+                                    cx.tcx.hir().find(trait_ref.hir_ref_id);\n+                                if let Res::Def(DefKind::Trait, did) = path.res;\n+                                then{\n+                                    // FIXME: if\n+                                    // `rustc_middle::ty::assoc::AssocItems::items` is public,\n+                                    // we can iterate its keys instead of `in_definition_order`,\n+                                    // which's more efficient\n+                                    cx.tcx\n+                                        .associated_items(did)\n+                                        .in_definition_order()\n+                                        .filter(|assoc_item| {\n+                                            matches!(assoc_item.kind, AssocKind::Fn)\n+                                        })\n+                                        .map(|assoc_item| assoc_item.ident.name)\n+                                        .collect()\n+                                }else{\n+                                    BTreeSet::new()\n+                                }\n+                            };\n+\n+                            let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n+                                if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        SAME_NAME_METHOD,\n+                                        *impl_span,\n+                                        \"method's name is same to an existing method in a trait\",\n+                                        |diag| {\n+                                            diag.span_note(\n+                                                trait_method_span,\n+                                                &format!(\"existing `{}` defined here\", method_name),\n+                                            );\n+                                        },\n+                                    );\n+                                }\n+                                if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n+                                    v.push(trait_method_span);\n+                                } else {\n+                                    existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n+                                }\n+                            };\n+\n+                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                            }) {\n+                                let method_name = impl_item_ref.ident.name;\n+                                methods_in_trait.remove(&method_name);\n+                                check_trait_method(method_name, impl_item_ref.span);\n+                            }\n+\n+                            for method_name in methods_in_trait {\n+                                check_trait_method(method_name, item.span);\n+                            }\n+                        },\n+                        None => {\n+                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                            }) {\n+                                let method_name = impl_item_ref.ident.name;\n+                                let impl_span = impl_item_ref.span;\n+                                if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        SAME_NAME_METHOD,\n+                                        impl_span,\n+                                        \"method's name is same to an existing method in a trait\",\n+                                        |diag| {\n+                                            // TODO should we `span_note` on every trait?\n+                                            // iterate on trait_spans?\n+                                            diag.span_note(\n+                                                trait_spans[0],\n+                                                &format!(\"existing `{}` defined here\", method_name),\n+                                            );\n+                                        },\n+                                    );\n+                                }\n+                                existing_name.impl_methods.insert(method_name, impl_span);\n+                            }\n+                        },\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "12e10ba6c493b8c9e539ce2b1e7b33faa4d285e8", "filename": "tests/ui/same_name_method.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a82ef053de9560b64f8d72de7294d11a9fc59/tests%2Fui%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a82ef053de9560b64f8d72de7294d11a9fc59/tests%2Fui%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_name_method.rs?ref=ed7a82ef053de9560b64f8d72de7294d11a9fc59", "patch": "@@ -0,0 +1,111 @@\n+#![warn(clippy::same_name_method)]\n+#![allow(dead_code, non_camel_case_types)]\n+\n+trait T1 {\n+    fn foo() {}\n+}\n+\n+trait T2 {\n+    fn foo() {}\n+}\n+\n+mod should_lint {\n+\n+    mod test_basic_case {\n+        use crate::T1;\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod test_derive {\n+\n+        #[derive(Clone)]\n+        struct S;\n+\n+        impl S {\n+            fn clone() {}\n+        }\n+    }\n+\n+    mod with_generic {\n+        use crate::T1;\n+\n+        struct S<U>(U);\n+\n+        impl<U> S<U> {\n+            fn foo() {}\n+        }\n+\n+        impl<U: Copy> T1 for S<U> {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod default_method {\n+        use crate::T1;\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {}\n+    }\n+\n+    mod mulitply_conflicit_trait {\n+        use crate::{T1, T2};\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {}\n+\n+        impl T2 for S {}\n+    }\n+}\n+\n+mod should_not_lint {\n+\n+    mod not_lint_two_trait_method {\n+        use crate::{T1, T2};\n+\n+        struct S;\n+\n+        impl T1 for S {\n+            fn foo() {}\n+        }\n+\n+        impl T2 for S {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod only_lint_on_method {\n+        trait T3 {\n+            type foo;\n+        }\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+        impl T3 for S {\n+            type foo = usize;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0f9139b41b99dae76e7d06f5d1f8d900ec82b784", "filename": "tests/ui/same_name_method.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a82ef053de9560b64f8d72de7294d11a9fc59/tests%2Fui%2Fsame_name_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a82ef053de9560b64f8d72de7294d11a9fc59/tests%2Fui%2Fsame_name_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_name_method.stderr?ref=ed7a82ef053de9560b64f8d72de7294d11a9fc59", "patch": "@@ -0,0 +1,64 @@\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:20:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::same-name-method` implied by `-D warnings`\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:24:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:44:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:48:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:58:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:61:9\n+   |\n+LL |         impl T1 for S {}\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:70:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:73:9\n+   |\n+LL |         impl T1 for S {}\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:34:13\n+   |\n+LL |             fn clone() {}\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: existing `clone` defined here\n+  --> $DIR/same_name_method.rs:30:18\n+   |\n+LL |         #[derive(Clone)]\n+   |                  ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 5 previous errors\n+"}]}