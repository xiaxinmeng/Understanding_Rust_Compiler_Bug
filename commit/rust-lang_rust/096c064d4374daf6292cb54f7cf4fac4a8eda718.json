{"sha": "096c064d4374daf6292cb54f7cf4fac4a8eda718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NmMwNjRkNDM3NGRhZjYyOTJjYjU0ZjdjZjRmYWM0YThlZGE3MTg=", "commit": {"author": {"name": "Florian Hartwig", "email": "florian.j.hartwig@gmail.com", "date": "2015-11-19T19:13:36Z"}, "committer": {"name": "Florian Hartwig", "email": "florian.j.hartwig@gmail.com", "date": "2015-11-19T19:13:36Z"}, "message": "Simplify has_debug_impl", "tree": {"sha": "6fa635b3b482d307e2cc0b02de34cabe760f0d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa635b3b482d307e2cc0b02de34cabe760f0d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/096c064d4374daf6292cb54f7cf4fac4a8eda718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/096c064d4374daf6292cb54f7cf4fac4a8eda718", "html_url": "https://github.com/rust-lang/rust/commit/096c064d4374daf6292cb54f7cf4fac4a8eda718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/096c064d4374daf6292cb54f7cf4fac4a8eda718/comments", "author": {"login": "fhartwig", "id": 83271, "node_id": "MDQ6VXNlcjgzMjcx", "avatar_url": "https://avatars.githubusercontent.com/u/83271?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhartwig", "html_url": "https://github.com/fhartwig", "followers_url": "https://api.github.com/users/fhartwig/followers", "following_url": "https://api.github.com/users/fhartwig/following{/other_user}", "gists_url": "https://api.github.com/users/fhartwig/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhartwig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhartwig/subscriptions", "organizations_url": "https://api.github.com/users/fhartwig/orgs", "repos_url": "https://api.github.com/users/fhartwig/repos", "events_url": "https://api.github.com/users/fhartwig/events{/privacy}", "received_events_url": "https://api.github.com/users/fhartwig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhartwig", "id": 83271, "node_id": "MDQ6VXNlcjgzMjcx", "avatar_url": "https://avatars.githubusercontent.com/u/83271?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhartwig", "html_url": "https://github.com/fhartwig", "followers_url": "https://api.github.com/users/fhartwig/followers", "following_url": "https://api.github.com/users/fhartwig/following{/other_user}", "gists_url": "https://api.github.com/users/fhartwig/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhartwig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhartwig/subscriptions", "organizations_url": "https://api.github.com/users/fhartwig/orgs", "repos_url": "https://api.github.com/users/fhartwig/repos", "events_url": "https://api.github.com/users/fhartwig/events{/privacy}", "received_events_url": "https://api.github.com/users/fhartwig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516f6484607166f062d723544f335d7d5e5c2fb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/516f6484607166f062d723544f335d7d5e5c2fb5", "html_url": "https://github.com/rust-lang/rust/commit/516f6484607166f062d723544f335d7d5e5c2fb5"}], "stats": {"total": 93, "additions": 27, "deletions": 66}, "files": [{"sha": "d977ed07bfd2f9830762ada2882559bb5a7af0ff", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/096c064d4374daf6292cb54f7cf4fac4a8eda718/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096c064d4374daf6292cb54f7cf4fac4a8eda718/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=096c064d4374daf6292cb54f7cf4fac4a8eda718", "patch": "@@ -85,7 +85,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n-    reg.register_late_lint_pass(box methods::MethodsPass::new());\n+    reg.register_late_lint_pass(box methods::MethodsPass);\n     reg.register_late_lint_pass(box shadow::ShadowPass);\n     reg.register_late_lint_pass(box types::LetPass);\n     reg.register_late_lint_pass(box types::UnitCmp);"}, {"sha": "858a5a3dca087f06f4cb889f1b8852260a28c172", "filename": "src/methods.rs", "status": "modified", "additions": 23, "deletions": 64, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/096c064d4374daf6292cb54f7cf4fac4a8eda718/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096c064d4374daf6292cb54f7cf4fac4a8eda718/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=096c064d4374daf6292cb54f7cf4fac4a8eda718", "patch": "@@ -4,7 +4,6 @@ use rustc::middle::ty;\n use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n-use std::collections::HashSet;\n \n use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth,\n     walk_ptrs_ty};\n@@ -13,69 +12,8 @@ use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n use self::SelfKind::*;\n use self::OutType::*;\n \n-use rustc::middle::def_id::DefId;\n-\n-use rustc::middle::ty::TypeFlags;\n-\n #[derive(Clone)]\n-pub struct MethodsPass { types_implementing_debug: Option<HashSet<DefId>> }\n-\n-impl MethodsPass {\n-    pub fn new() -> MethodsPass {\n-        MethodsPass { types_implementing_debug: None }\n-    }\n-\n-    fn get_debug_impls(&mut self, cx: &LateContext) -> Option<&HashSet<DefId>> {\n-        if self.types_implementing_debug.is_none() {\n-            let debug = match cx.tcx.lang_items.debug_trait() {\n-                Some(debug) => debug,\n-                None => return None\n-            };\n-            let debug_def = cx.tcx.lookup_trait_def(debug);\n-            let mut impls = HashSet::new();\n-            debug_def.for_each_impl(cx.tcx, |d| {\n-                let o_self_ty = &cx.tcx.impl_trait_ref(d)\n-                                    .map(|x| x.substs)\n-                                    .and_then(|x| x.self_ty());\n-                let self_ty = match *o_self_ty {\n-                    Some(self_type) => self_type,\n-                    None => return\n-                };\n-                let self_ty_def_id = self_ty.ty_to_def_id();\n-                if let Some(self_ty_def_id) = self_ty_def_id {\n-                    let has_params = self_ty.flags.get().contains(TypeFlags::HAS_PARAMS);\n-                    if !has_params {\n-                        impls.insert(self_ty_def_id);\n-                    }\n-                }\n-            });\n-            self.types_implementing_debug = Some(impls);\n-        }\n-        self.types_implementing_debug.as_ref()\n-    }\n-\n-    // This checks whether a given type is known to implement Debug. It's\n-    // conservative, i.e. it should not return false positives, but will return\n-    // false negatives.\n-    fn has_debug_impl(&mut self, ty: ty::Ty, cx: &LateContext) -> bool {\n-        let debug_impls = match self.get_debug_impls(cx) {\n-            Some(debug_impls) => debug_impls,\n-            None => return false\n-        };\n-        match walk_ptrs_ty(ty).sty {\n-            ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..)\n-                       | ty::TyFloat(..) | ty::TyStr => true,\n-            ty::TyTuple(ref v) if v.is_empty() => true,\n-            ty::TyStruct(..) | ty::TyEnum(..) => {\n-                match ty.ty_to_def_id() {\n-                    Some(ref ty_def_id) => debug_impls.contains(ty_def_id),\n-                    None => false\n-                }\n-            },\n-            _ => false\n-        }\n-    }\n-}\n+pub struct MethodsPass;\n \n declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n               \"using `Option.unwrap()`, which should at least get a better message using `expect()`\");\n@@ -144,7 +82,7 @@ impl LateLintPass for MethodsPass {\n                             && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n                         let result_type = cx.tcx.expr_ty(&inner_args[0]);\n                         if let Some(error_type) = get_error_type(cx, result_type) {\n-                            if self.has_debug_impl(error_type, cx) {\n+                            if has_debug_impl(error_type, cx) {\n                                 span_lint(cx, OK_EXPECT, expr.span,\n                                          \"called `ok().expect()` on a Result \\\n                                           value. You can call `expect` directly\n@@ -212,6 +150,27 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n+// This checks whether a given type is known to implement Debug. It's\n+// conservative, i.e. it should not return false positives, but will return\n+// false negatives.\n+fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+    let ty = walk_ptrs_ty(ty);\n+    let debug = match cx.tcx.lang_items.debug_trait() {\n+        Some(debug) => debug,\n+        None => return false\n+    };\n+    let debug_def = cx.tcx.lookup_trait_def(debug);\n+    let mut debug_impl_exists = false;\n+    debug_def.for_each_relevant_impl(cx.tcx, ty, |d| {\n+        let self_ty = &cx.tcx.impl_trait_ref(d).and_then(|im| im.substs.self_ty());\n+        if let Some(self_ty) = *self_ty {\n+            if !self_ty.flags.get().contains(ty::TypeFlags::HAS_PARAMS) {\n+                debug_impl_exists = true;\n+            }\n+        }\n+    });\n+    debug_impl_exists\n+}\n \n const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n     (\"into_\", &[ValueSelf]),"}, {"sha": "6d543596cf5c4e5136ddf8d234f99c68cadcd0db", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/096c064d4374daf6292cb54f7cf4fac4a8eda718/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096c064d4374daf6292cb54f7cf4fac4a8eda718/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=096c064d4374daf6292cb54f7cf4fac4a8eda718", "patch": "@@ -54,14 +54,16 @@ fn main() {\n     // the error type implements `Debug`\n     let res2: Result<i32, MyError> = Ok(0);\n     res2.ok().expect(\"oh noes!\");\n-    // we're currently don't warn if the error type has a type parameter\n+    // we currently don't warn if the error type has a type parameter\n     // (but it would be nice if we did)\n     let res3: Result<u32, MyErrorWithParam<u8>>= Ok(0);\n     res3.ok().expect(\"whoof\");\n     let res4: Result<u32, io::Error> = Ok(0);\n     res4.ok().expect(\"argh\"); //~ERROR called `ok().expect()`\n     let res5: io::Result<u32> = Ok(0);\n     res5.ok().expect(\"oops\"); //~ERROR called `ok().expect()`\n+    let res6: Result<u32, &str> = Ok(0);\n+    res6.ok().expect(\"meh\"); //~ERROR called `ok().expect()`\n }\n \n struct MyError(()); // doesn't implement Debug"}]}