{"sha": "d66acc23a92a966c711382ac8b86c006fddb4fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NmFjYzIzYTkyYTk2NmM3MTEzODJhYzhiODZjMDA2ZmRkYjRmZDI=", "commit": {"author": {"name": "Matthias Seiffert", "email": "matthias-seiffert@hotmail.de", "date": "2019-10-06T18:10:30Z"}, "committer": {"name": "Matthias Seiffert", "email": "matthias-seiffert@hotmail.de", "date": "2019-10-07T17:13:10Z"}, "message": "Make if_chain more readable", "tree": {"sha": "6714fec91d822ba40841bb8d14a7f82bd4787eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6714fec91d822ba40841bb8d14a7f82bd4787eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d66acc23a92a966c711382ac8b86c006fddb4fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d66acc23a92a966c711382ac8b86c006fddb4fd2", "html_url": "https://github.com/rust-lang/rust/commit/d66acc23a92a966c711382ac8b86c006fddb4fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d66acc23a92a966c711382ac8b86c006fddb4fd2/comments", "author": {"login": "Lythenas", "id": 32217236, "node_id": "MDQ6VXNlcjMyMjE3MjM2", "avatar_url": "https://avatars.githubusercontent.com/u/32217236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lythenas", "html_url": "https://github.com/Lythenas", "followers_url": "https://api.github.com/users/Lythenas/followers", "following_url": "https://api.github.com/users/Lythenas/following{/other_user}", "gists_url": "https://api.github.com/users/Lythenas/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lythenas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lythenas/subscriptions", "organizations_url": "https://api.github.com/users/Lythenas/orgs", "repos_url": "https://api.github.com/users/Lythenas/repos", "events_url": "https://api.github.com/users/Lythenas/events{/privacy}", "received_events_url": "https://api.github.com/users/Lythenas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lythenas", "id": 32217236, "node_id": "MDQ6VXNlcjMyMjE3MjM2", "avatar_url": "https://avatars.githubusercontent.com/u/32217236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lythenas", "html_url": "https://github.com/Lythenas", "followers_url": "https://api.github.com/users/Lythenas/followers", "following_url": "https://api.github.com/users/Lythenas/following{/other_user}", "gists_url": "https://api.github.com/users/Lythenas/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lythenas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lythenas/subscriptions", "organizations_url": "https://api.github.com/users/Lythenas/orgs", "repos_url": "https://api.github.com/users/Lythenas/repos", "events_url": "https://api.github.com/users/Lythenas/events{/privacy}", "received_events_url": "https://api.github.com/users/Lythenas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72a5d7b612b5e6ef1dbf0cff88dbfded744c280a", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a5d7b612b5e6ef1dbf0cff88dbfded744c280a", "html_url": "https://github.com/rust-lang/rust/commit/72a5d7b612b5e6ef1dbf0cff88dbfded744c280a"}], "stats": {"total": 93, "additions": 55, "deletions": 38}, "files": [{"sha": "aff52de0fac68848ff2754b8cade345c64008c55", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 55, "deletions": 38, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d66acc23a92a966c711382ac8b86c006fddb4fd2/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66acc23a92a966c711382ac8b86c006fddb4fd2/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=d66acc23a92a966c711382ac8b86c006fddb4fd2", "patch": "@@ -1,5 +1,6 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_qpath, span_help_and_lint};\n+use crate::utils::paths;\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, resolve_node, span_help_and_lint};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -99,59 +100,75 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n     }\n }\n \n-// fn get_assert_args(snip: String) -> Option<Vec<String>> {\n-//\n-// }\n-\n+/// Check if the expression matches\n+///\n+/// ```rust,ignore\n+/// match { let _t = !c; _t } {\n+///     true => {\n+///         {\n+///             ::std::rt::begin_panic(message, _)\n+///         }\n+///     }\n+///     _ => { }\n+/// };\n+/// ```\n+///\n+/// where `message` is a string literal and `c` is a constant bool.\n+///\n+/// TODO extend this to match anything as message not just string literals\n+///\n+/// Returns the `message` argument of `begin_panic` and the value of `c` which is the\n+/// first argument of `assert!`.\n fn assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<(LocalInternedString, bool)> {\n     if_chain! {\n-        if let ExprKind::Match(ref expr, ref arms, MatchSource::IfDesugar { contains_else_clause: false }) = expr.kind;\n-        // match expr\n+        if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n+        // matches { let _t = expr; _t }\n         if let ExprKind::DropTemps(ref expr) = expr.kind;\n         if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n-        //if let ExprKind::Lit(ref lit) = expr.kind;\n+        // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, expr);\n-        //if is_true;\n-        // match arms\n         // arm 1 pattern\n         if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n         if let ExprKind::Lit(ref lit) = lit_expr.kind;\n         if let LitKind::Bool(true) = lit.node;\n-        //if let LitKind::Bool(true) = lit1.node;\n         // arm 1 block\n-        if let ExprKind::Block(ref block1, _) = arms[0].body.kind;\n-        if let Some(trailing_expr1) = &block1.expr;\n-        if block1.stmts.len() == 0;\n-        //\n-        if let ExprKind::Block(ref actual_block1, _) = trailing_expr1.kind;\n-        if let Some(block1_expr) = &actual_block1.expr;\n+        if let ExprKind::Block(ref block, _) = arms[0].body.kind;\n+        if block.stmts.len() == 0;\n+        if let Some(block_expr) = &block.expr;\n+        if let ExprKind::Block(ref inner_block, _) = block_expr.kind;\n+        if let Some(begin_panic_call) = &inner_block.expr;\n         // function call\n-        if let ExprKind::Call(ref func, ref args) = block1_expr.kind;\n-        if let ExprKind::Path(ref path) = func.kind;\n-        // [\"{{root}}\", \"std\", \"rt\", \"begin_panic\"] does not work\n-        if match_qpath(path, &[\"$crate\", \"rt\", \"begin_panic\"]);\n-        // arguments\n+        if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n         if args.len() == 2;\n         if let ExprKind::Lit(ref lit) = args[0].kind;\n         if let LitKind::Str(ref s, _) = lit.node;\n-        let panic_message = s.as_str(); // bind the panic message\n-        if let ExprKind::AddrOf(MutImmutable, ref inner) = args[1].kind;\n-        if let ExprKind::Tup(ref elements) = inner.kind;\n-        if elements.len() == 3;\n-        if let ExprKind::Lit(ref lit1) = elements[0].kind;\n-        if let LitKind::Str(ref s1, _) = lit1.node;\n-        if let ExprKind::Lit(ref lit2) = elements[1].kind;\n-        if let LitKind::Int(_, _) = lit2.node;\n-        if let ExprKind::Lit(ref lit3) = elements[2].kind;\n-        if let LitKind::Int(_, _) = lit3.node;\n-        // arm 2 block\n-        if let PatKind::Wild = arms[1].pat.kind;\n-        if let ExprKind::Block(ref block2, _) = arms[1].body.kind;\n-        if let None = &block2.expr;\n-        if block2.stmts.len() == 0;\n+        // bind the second argument of the `assert!` macro\n+        let panic_message = s.as_str();\n+        // second argument of begin_panic is irrelevant\n+        // as is the second match arm\n         then {\n             return Some((panic_message, is_true));\n         }\n     }\n-    return None;\n+    None\n+}\n+\n+/// Matches a function call with the given path and returns the arguments.\n+///\n+/// Usage:\n+///\n+/// ```rust,ignore\n+/// if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n+/// ```\n+fn match_function_call<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, path: &[&str]) -> Option<&'a [Expr]> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, fun_def_id, path);\n+        then {\n+            return Some(&args)\n+        }\n+    };\n+    None\n }"}]}