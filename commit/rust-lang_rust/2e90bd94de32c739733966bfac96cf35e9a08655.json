{"sha": "2e90bd94de32c739733966bfac96cf35e9a08655", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOTBiZDk0ZGUzMmM3Mzk3MzM5NjZiZmFjOTZjZjM1ZTlhMDg2NTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-07T00:56:44Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-07T00:58:18Z"}, "message": "Continued sketching out code for checking states against preconditions.\n\nIt's still sketchy. I added a typestate annotation field to statements\ntagged stmt_decl or stmt_expr, because a stmt_decl statement has a typestate\nthat's different from that of its child node. This necessitated trivial\nchanges to a bunch of other files all over to the compiler. I also added a\nfew small standard library functions, some of which I didn't actually end\nup using but which I thought might be useful anyway.", "tree": {"sha": "01cecc3fbc92d27e01177b5d3cb0785239877ea9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01cecc3fbc92d27e01177b5d3cb0785239877ea9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e90bd94de32c739733966bfac96cf35e9a08655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e90bd94de32c739733966bfac96cf35e9a08655", "html_url": "https://github.com/rust-lang/rust/commit/2e90bd94de32c739733966bfac96cf35e9a08655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e90bd94de32c739733966bfac96cf35e9a08655/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36d75d6391873b34a1f4e10c34d3d58c54a453c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/36d75d6391873b34a1f4e10c34d3d58c54a453c5", "html_url": "https://github.com/rust-lang/rust/commit/36d75d6391873b34a1f4e10c34d3d58c54a453c5"}], "stats": {"total": 475, "additions": 343, "deletions": 132}, "files": [{"sha": "184f140273cfdfd321fecc958d213ec331a34934", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -52,3 +52,4 @@ config.mk\n /test/\n /build/\n src/.DS_Store\n+/stage0/"}, {"sha": "cf4145a5598060bf1bd56cb95ec36fc3d4a55f60", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -215,8 +215,8 @@ tag mode {\n \n type stmt = spanned[stmt_];\n tag stmt_ {\n-    stmt_decl(@decl);\n-    stmt_expr(@expr);\n+    stmt_decl(@decl, option.t[@ts_ann]);\n+    stmt_expr(@expr, option.t[@ts_ann]);\n     // These only exist in crate-level blocks.\n     stmt_crate_directive(@crate_directive);\n }\n@@ -495,7 +495,7 @@ fn index_native_view_item(native_mod_index index, @view_item it) {\n \n fn index_stmt(block_index index, @stmt s) {\n     alt (s.node) {\n-        case (ast.stmt_decl(?d)) {\n+        case (ast.stmt_decl(?d,_)) {\n             alt (d.node) {\n                 case (ast.decl_local(?loc)) {\n                     index.insert(loc.ident, ast.bie_local(loc));"}, {"sha": "7d1323cbafe5046899b2e065836d38e239a997e3", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -11,6 +11,7 @@ import util.common;\n import util.common.filename;\n import util.common.span;\n import util.common.new_str_hash;\n+import util.typestate_ann.ts_ann;\n \n tag restriction {\n     UNRESTRICTED;\n@@ -1555,13 +1556,13 @@ impure fn parse_source_stmt(parser p) -> @ast.stmt {\n         case (token.LET) {\n             auto decl = parse_let(p);\n             auto hi = p.get_span();\n-            ret @spanned(lo, hi, ast.stmt_decl(decl));\n+            ret @spanned(lo, hi, ast.stmt_decl(decl, none[@ts_ann]));\n         }\n \n         case (token.AUTO) {\n             auto decl = parse_auto(p);\n             auto hi = p.get_span();\n-            ret @spanned(lo, hi, ast.stmt_decl(decl));\n+            ret @spanned(lo, hi, ast.stmt_decl(decl, none[@ts_ann]));\n         }\n \n         case (_) {\n@@ -1570,13 +1571,13 @@ impure fn parse_source_stmt(parser p) -> @ast.stmt {\n                 auto i = parse_item(p);\n                 auto hi = i.span;\n                 auto decl = @spanned(lo, hi, ast.decl_item(i));\n-                ret @spanned(lo, hi, ast.stmt_decl(decl));\n+                ret @spanned(lo, hi, ast.stmt_decl(decl, none[@ts_ann]));\n \n             } else {\n                 // Remainder are line-expr stmts.\n                 auto e = parse_expr(p);\n                 auto hi = p.get_span();\n-                ret @spanned(lo, hi, ast.stmt_expr(e));\n+                ret @spanned(lo, hi, ast.stmt_expr(e, none[@ts_ann]));\n             }\n         }\n     }\n@@ -1613,21 +1614,21 @@ fn index_arm(@ast.pat pat) -> hashmap[ast.ident,ast.def_id] {\n \n fn stmt_to_expr(@ast.stmt stmt) -> option.t[@ast.expr] {\n     alt (stmt.node) {\n-        case (ast.stmt_expr(?e)) { ret some[@ast.expr](e); }\n+        case (ast.stmt_expr(?e,_)) { ret some[@ast.expr](e); }\n         case (_) { /* fall through */ }\n     }\n     ret none[@ast.expr];\n }\n \n fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n     alt (stmt.node) {\n-        case (ast.stmt_decl(?d)) {\n+        case (ast.stmt_decl(?d,_)) {\n             alt (d.node) {\n                 case (ast.decl_local(_)) { ret true; }\n                 case (ast.decl_item(_)) { ret false; }\n             }\n         }\n-        case (ast.stmt_expr(?e)) {\n+        case (ast.stmt_expr(?e,_)) {\n             alt (e.node) {\n                 case (ast.expr_vec(_,_,_))      { ret true; }\n                 case (ast.expr_tup(_,_))        { ret true; }"}, {"sha": "fa85f791e762e45fb2da25efbdf3170c19edd8d7", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -7,6 +7,7 @@ import util.common.new_str_hash;\n import util.common.spanned;\n import util.common.span;\n import util.common.ty_mach;\n+import util.typestate_ann.ts_ann;\n \n import front.ast;\n import front.ast.fn_decl;\n@@ -232,10 +233,12 @@ type ast_fold[ENV] =\n \n      // Stmt folds.\n      (fn(&ENV e, &span sp,\n-         @decl decl) -> @stmt)                    fold_stmt_decl,\n+         @decl decl, option.t[@ts_ann] a)\n+      -> @stmt)                                   fold_stmt_decl,\n \n      (fn(&ENV e, &span sp,\n-         @expr e) -> @stmt)                       fold_stmt_expr,\n+         @expr e, option.t[@ts_ann] a)\n+      -> @stmt)                                   fold_stmt_expr,\n \n      // Item folds.\n      (fn(&ENV e, &span sp, ident ident,\n@@ -788,14 +791,14 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n     }\n \n     alt (s.node) {\n-        case (ast.stmt_decl(?d)) {\n+        case (ast.stmt_decl(?d, ?a)) {\n             auto dd = fold_decl(env_, fld, d);\n-            ret fld.fold_stmt_decl(env_, s.span, dd);\n+            ret fld.fold_stmt_decl(env_, s.span, dd, a);\n         }\n \n-        case (ast.stmt_expr(?e)) {\n+        case (ast.stmt_expr(?e, ?a)) {\n             auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_expr(env_, s.span, ee);\n+            ret fld.fold_stmt_expr(env_, s.span, ee, a);\n         }\n     }\n     fail;\n@@ -1386,12 +1389,14 @@ fn identity_fold_pat_tag[ENV](&ENV e, &span sp, path p, vec[@pat] args,\n \n // Stmt identities.\n \n-fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d) -> @stmt {\n-    ret @respan(sp, ast.stmt_decl(d));\n+fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d,\n+                                option.t[@ts_ann] a) -> @stmt {\n+    ret @respan(sp, ast.stmt_decl(d, a));\n }\n \n-fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n-    ret @respan(sp, ast.stmt_expr(x));\n+fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x,\n+                                option.t[@ts_ann] a) -> @stmt {\n+    ret @respan(sp, ast.stmt_expr(x, a));\n }\n \n \n@@ -1642,8 +1647,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_pat_bind    = bind identity_fold_pat_bind[ENV](_,_,_,_,_),\n          fold_pat_tag     = bind identity_fold_pat_tag[ENV](_,_,_,_,_,_),\n \n-         fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_),\n-         fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_),\n+         fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_,_),\n+         fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_,_),\n \n          fold_item_const= bind identity_fold_item_const[ENV](_,_,_,_,_,_,_),\n          fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_,_,_,_),"}, {"sha": "28ae07dc85bba0773156c01029675ca48a166ada", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -6,6 +6,7 @@ import front.creader;\n import driver.session;\n import util.common.new_def_hash;\n import util.common.span;\n+import util.typestate_ann.ts_ann;\n import std.map.hashmap;\n import std.list.list;\n import std.list.nil;\n@@ -348,7 +349,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n \n     fn found_decl_stmt(@ast.stmt s, namespace ns) -> def_wrap {\n         alt (s.node) {\n-            case (ast.stmt_decl(?d)) {\n+            case (ast.stmt_decl(?d,_)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?loc)) {\n                         auto t = ast.def_local(loc.id);"}, {"sha": "fff3f126948d5978608083d607f949b220b9c3ed", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -5208,11 +5208,11 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto bcx = cx;\n     alt (s.node) {\n-        case (ast.stmt_expr(?e)) {\n+        case (ast.stmt_expr(?e,_)) {\n             bcx = trans_expr(cx, e).bcx;\n         }\n \n-        case (ast.stmt_decl(?d)) {\n+        case (ast.stmt_decl(?d,_)) {\n             alt (d.node) {\n                 case (ast.decl_local(?local)) {\n                     bcx = init_local(bcx, local).bcx;\n@@ -5302,7 +5302,7 @@ iter block_locals(&ast.block b) -> @ast.local {\n     // use the index here.\n     for (@ast.stmt s in b.node.stmts) {\n         alt (s.node) {\n-            case (ast.stmt_decl(?d)) {\n+            case (ast.stmt_decl(?d,_)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?local)) {\n                         put local;"}, {"sha": "09c89fdfc28ce3ec2ee42145ecd316911b63f62f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -731,7 +731,7 @@ fn item_ty(@ast.item it) -> ty_params_and_ty {\n \n fn stmt_ty(@ast.stmt s) -> @t {\n     alt (s.node) {\n-        case (ast.stmt_expr(?e)) {\n+        case (ast.stmt_expr(?e,_)) {\n             ret expr_ty(e);\n         }\n         case (_) {"}, {"sha": "d969df5a25e4e425a971a5f586f304f68bae6159", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -2479,12 +2479,12 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n \n fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n     alt (stmt.node) {\n-        case (ast.stmt_decl(?decl)) {\n+        case (ast.stmt_decl(?decl,?a)) {\n             alt (decl.node) {\n                 case (ast.decl_local(_)) {\n                     auto decl_1 = check_decl_local(fcx, decl);\n                     ret @fold.respan[ast.stmt_](stmt.span,\n-                                                ast.stmt_decl(decl_1));\n+                                                ast.stmt_decl(decl_1, a));\n                 }\n \n                 case (ast.decl_item(_)) {\n@@ -2495,9 +2495,9 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n             ret stmt;\n         }\n \n-        case (ast.stmt_expr(?expr)) {\n+        case (ast.stmt_expr(?expr,?a)) {\n             auto expr_t = check_expr(fcx, expr);\n-            ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t));\n+            ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t, a));\n         }\n     }\n "}, {"sha": "24bee1bd0348857e275eba283ed85771868e4d84", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 188, "deletions": 94, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -11,6 +11,7 @@ import front.ast.stmt;\n import front.ast.stmt_;\n import front.ast.stmt_decl;\n import front.ast.stmt_expr;\n+import front.ast.stmt_crate_directive;\n import front.ast.decl_local;\n import front.ast.decl_item;\n import front.ast.ident;\n@@ -70,9 +71,17 @@ import util.typestate_ann.prestate;\n import util.typestate_ann.pre_and_post;\n import util.typestate_ann.get_pre;\n import util.typestate_ann.get_post;\n+import util.typestate_ann.ann_precond;\n+import util.typestate_ann.ann_prestate;\n+import util.typestate_ann.set_precondition;\n+import util.typestate_ann.set_postcondition;\n+import util.typestate_ann.set_in_postcond;\n import util.typestate_ann.implies;\n import util.typestate_ann.pre_and_post_state;\n import util.typestate_ann.empty_states;\n+import util.typestate_ann.empty_prestate;\n+import util.typestate_ann.empty_ann;\n+import util.typestate_ann.extend_prestate;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -97,6 +106,7 @@ import std.option;\n import std.option.t;\n import std.option.some;\n import std.option.none;\n+import std.option.from_maybe;\n import std.map.hashmap;\n import std.list;\n import std.list.list;\n@@ -106,6 +116,8 @@ import std.list.foldl;\n import std.list.find;\n import std._uint;\n import std.bitv;\n+import std.util.fst;\n+import std.util.snd;\n \n import util.typestate_ann;\n import util.typestate_ann.difference;\n@@ -342,50 +354,41 @@ fn expr_ann(&expr e) -> ann {\n   }\n }\n \n-/* returns ann_none if this is the sort\n- of statement where an ann doesn't make sense */\n-fn stmt_ann(&stmt s) -> ann {\n-  alt (s.node) {\n-    case (stmt_decl(?d)) {\n-      alt (d.node) {\n-        case (decl_local(?l)) {\n-          ret l.ann;\n-        }\n-        case (decl_item(?i)) {\n-          ret ann_none; /* ????? */\n-        }\n+fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n+  alt (a) {\n+    case (ann_none)         { ret empty_ann(nv); }\n+    case (ann_type(_,_,?t)) {\n+      alt (t) {\n+        /* Kind of inconsistent. empty_ann()s everywhere\n+         or an option of a ts_ann? */\n+        case (none[@ts_ann])     { ret empty_ann(nv); }\n+        case (some[@ts_ann](?t)) { ret *t; }\n       }\n     }\n-    case (stmt_expr(?e)) {\n-      ret expr_ann(*e);\n-    }\n-    case (_) {\n-      ret ann_none;\n-    }\n   }\n }\n \n-/* fails if e has no annotation */\n-fn expr_pp(&expr e) -> pre_and_post {\n-  alt (expr_ann(e)) {\n-    case (ann_none) {\n-      log \"expr_pp: the impossible happened (no annotation)\";\n-      fail;\n+fn stmt_ann(&stmt s) -> option.t[@ts_ann] {\n+  alt (s.node) {\n+    case (stmt_decl(_,?a)) {\n+      ret a;\n     }\n-    case (ann_type(_, _, ?maybe_pp)) {\n-      alt (maybe_pp) {\n-        case (none[@ts_ann]) {\n-          log \"expr_pp: the impossible happened (no pre/post)\";\n-          fail;\n-        }\n-        case (some[@ts_ann](?p)) {\n-          ret p.conditions;\n-        }\n-      }\n+    case (stmt_expr(_,?a)) {\n+      ret a;\n+    }\n+    case (stmt_crate_directive(_)) {\n+      ret none[@ts_ann];\n     }\n   }\n }\n \n+/*\n+/* fails if no annotation */\n+fn stmt_pp(&stmt s) -> pre_and_post {\n+  ret (stmt_ann(s)).conditions;\n+}\n+*/\n+\n /* fails if e has no annotation */\n fn expr_states(&expr e) -> pre_and_post_state {\n   alt (expr_ann(e)) {\n@@ -400,22 +403,24 @@ fn expr_states(&expr e) -> pre_and_post_state {\n           fail;\n         }\n         case (some[@ts_ann](?p)) {\n-          ret p.states;\n+          // ret p.states;\n         }\n       }\n     }\n   }\n }\n \n-/* fails if no annotation */\n-fn stmt_pp(&stmt s) -> pre_and_post {\n-  alt (stmt_ann(s)) {\n+/* fails if e has no annotation */\n+fn expr_pp(&expr e) -> pre_and_post {\n+  alt (expr_ann(e)) {\n     case (ann_none) {\n+      log \"expr_pp: the impossible happened (no annotation)\";\n       fail;\n     }\n     case (ann_type(_, _, ?maybe_pp)) {\n       alt (maybe_pp) {\n         case (none[@ts_ann]) {\n+          log \"expr_pp: the impossible happened (no pre/post)\";\n           fail;\n         }\n         case (some[@ts_ann](?p)) {\n@@ -426,25 +431,18 @@ fn stmt_pp(&stmt s) -> pre_and_post {\n   }\n }\n \n-/* fails if no annotation */\n-fn stmt_states(&stmt s) -> pre_and_post_state {\n+fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n   alt (stmt_ann(s)) {\n-    case (ann_none) {\n-      fail;\n+    case (none[@ts_ann]) {\n+      ret empty_states(nv);\n     }\n-    case (ann_type(_, _, ?maybe_pp)) {\n-      alt (maybe_pp) {\n-        case (none[@ts_ann]) {\n-          fail;\n-        }\n-        case (some[@ts_ann](?p)) {\n-          ret p.states;\n-        }\n-      }\n+    case (some[@ts_ann](?a)) {\n+      ret a.states;\n     }\n   }\n }\n \n+\n fn expr_precond(&expr e) -> precond {\n   ret (expr_pp(e)).precondition;\n }\n@@ -461,20 +459,27 @@ fn expr_poststate(&expr e) -> poststate {\n   ret (expr_states(e)).poststate;\n }\n \n+/*\n fn stmt_precond(&stmt s) -> precond {\n   ret (stmt_pp(s)).precondition;\n }\n \n fn stmt_postcond(&stmt s) -> postcond {\n   ret (stmt_pp(s)).postcondition;\n }\n+*/\n+\n+fn states_to_poststate(&pre_and_post_state ss) -> poststate {\n+  ret ss.poststate;\n+}\n \n+/*\n fn stmt_prestate(&stmt s) -> prestate {\n   ret (stmt_states(s)).prestate;\n }\n-\n-fn stmt_poststate(&stmt s) -> poststate {\n-  ret (stmt_states(s)).poststate;\n+*/\n+fn stmt_poststate(&stmt s, uint nv) -> poststate {\n+  ret (stmt_states(s, nv)).poststate;\n }\n \n /* returns a new annotation where the pre_and_post is p */\n@@ -684,12 +689,19 @@ fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   }\n }\n \n-fn find_pre_post_for_each_stmt(_fn_info_map fm, &fn_info enclosing,\n-                               &ast.stmt s) -> ast.stmt {\n+impure fn gen(&fn_info enclosing, ts_ann a, def_id id) {\n+  check(enclosing.contains_key(id));\n+  let uint i = enclosing.get(id);\n+\n+  set_in_postcond(i, a.conditions);\n+}\n+\n+fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n+  -> ast.stmt {\n   auto num_local_vars = num_locals(enclosing);\n \n   alt(s.node) {\n-    case(ast.stmt_decl(?adecl)) {\n+    case(ast.stmt_decl(?adecl, ?a)) {\n       alt(adecl.node) {\n         case(ast.decl_local(?alocal)) {\n           alt(alocal.init) {\n@@ -702,9 +714,25 @@ fn find_pre_post_for_each_stmt(_fn_info_map fm, &fn_info enclosing,\n                 @rec(ty=alocal.ty, infer=alocal.infer,\n                      ident=alocal.ident, init=some[initializer](a_i),\n                      id=alocal.id, ann=res_ann);\n+\n+              let ts_ann stmt_ann;\n+              alt (a) {\n+                case (none[@ts_ann]) {\n+                  stmt_ann = empty_ann(num_local_vars);\n+                }\n+                case (some[@ts_ann](?aa)) {\n+                  stmt_ann = *aa;\n+                }\n+              }\n+              /* Inherit ann from initializer, and add var being\n+                 initialized to the postcondition */\n+              set_precondition(stmt_ann, expr_precond(*r));\n+              set_postcondition(stmt_ann, expr_postcond(*r));\n+              gen(enclosing, stmt_ann, alocal.id); \n               let stmt_ res = stmt_decl(@respan(adecl.span,\n-                                                decl_local(res_local)));\n-              ret (respan(s.span, res));\n+                                                decl_local(res_local)),\n+                                        some[@ts_ann](@stmt_ann));\n+              ret (respan(s.span, res)); \n             }\n             case(none[ast.initializer]) {\n               // log(\"pre/post for init of \" + alocal.ident + \": none\");\n@@ -716,30 +744,38 @@ fn find_pre_post_for_each_stmt(_fn_info_map fm, &fn_info enclosing,\n                      id=alocal.id, ann=res_ann);\n               let stmt_ res =\n                 stmt_decl\n-                (@respan(adecl.span, decl_local(res_local)));\n-              ret (respan (s.span, res));\n+                (@respan(adecl.span, decl_local(res_local)),\n+                 some[@ts_ann](@empty_ann(num_local_vars)));\n+              ret respan(s.span, res); /* inherit ann from initializer */\n             }\n           }\n         }\n         case(decl_item(?anitem)) {\n           auto res_item = find_pre_post_item(fm, enclosing, *anitem);\n-          ret (respan(s.span, stmt_decl(@respan(adecl.span,\n-                                               decl_item(@res_item))))); \n+          ret respan(s.span,\n+                     stmt_decl(@respan(adecl.span,\n+                                       decl_item(@res_item)),\n+                               some[@ts_ann](@empty_ann(num_local_vars))));\n         }\n       }\n     }\n-    case(stmt_expr(?e)) {\n+    case(stmt_expr(?e,_)) {\n       log_expr(e);\n       let @expr e_pp = find_pre_post_expr(enclosing, *e);\n-      ret (respan(s.span, stmt_expr(e_pp)));\n+      /* inherit ann from expr */\n+      ret respan(s.span,\n+                 stmt_expr(e_pp,\n+                           some[@ts_ann]\n+                           (@ann_to_ts_ann(expr_ann(*e_pp),\n+                                           num_local_vars)))); \n     }    \n   }\n }\n \n fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n   -> block {\n   fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> @stmt {\n-    ret (@find_pre_post_for_each_stmt(fm, i, *s));\n+    ret (@find_pre_post_stmt(fm, i, *s));\n   }\n   auto do_one = bind do_one_(fm, enclosing, _);\n  \n@@ -767,65 +803,123 @@ fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n   ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n }\n \n-/* Returns a pair of a new function, with possibly a changed pre- or\n-   post-state, and a boolean flag saying whether the function's pre- or \n-   poststate changed */\n-fn find_pre_post_state_fn(fn_info f_info, &ast._fn f) -> tup(bool, ast._fn) {\n-  log (\"Implement find_pre_post_state_fn!\");\n+/* FIXME */\n+fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n+                            &prestate pres, expr e)\n+  -> tup(bool, @expr) {\n+  log(\"Implement find_pre_post_state_expr!\");\n   fail;\n }\n \n-fn fixed_point_states(fn_info f_info,\n-                      fn (fn_info, &ast._fn) -> tup(bool, ast._fn) f,\n+/* FIXME: This isn't done yet. */\n+fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n+                            &prestate pres, @stmt s) -> bool {\n+  auto changed = false;\n+  alt (s.node) {\n+    case (stmt_decl(?adecl, ?a)) {\n+      alt (adecl.node) {\n+        case (ast.decl_local(?alocal)) {\n+          alt (alocal.init) {\n+            case (some[ast.initializer](?an_init)) {\n+              auto p = find_pre_post_state_expr(fm, enclosing,\n+                                                pres, *an_init.expr);\n+              fail; /* FIXME */\n+              /* Next: copy pres into a's prestate;\n+                 find the poststate by taking p's poststate\n+                 and setting the bit for alocal.id */\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+/* Returns a pair of a new block, with possibly a changed pre- or\n+   post-state, and a boolean flag saying whether the function's pre- or \n+   poststate changed */\n+fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n+  -> tup(bool, block) {\n+  auto changed = false;\n+  auto num_local_vars = num_locals(enclosing);\n+\n+  /* First, set the pre-states and post-states for every expression */\n+  auto pres = empty_prestate(num_local_vars);\n+  \n+  /* Iterate over each stmt. The new prestate is <pres>. The poststate\n+   consist of improving <pres> with whatever variables this stmt initializes.\n+  Then <pres> becomes the new poststate. */ \n+  for (@stmt s in b.node.stmts) {\n+    changed = changed || find_pre_post_state_stmt(fm, enclosing, pres, s);\n+      /* Shouldn't need to rebuild the stmt.\n+         This just updates bit-vectors\n+         in a side-effecting way. */\n+    extend_prestate(pres, stmt_poststate(*s, num_local_vars));\n+  }\n+\n+  fn do_inner_(_fn_info_map fm, fn_info i, prestate p, &@expr e)\n+    -> tup (bool, @expr) {\n+    ret find_pre_post_state_expr(fm, i, p, *e);\n+  }\n+  auto do_inner = bind do_inner_(fm, enclosing, pres, _);\n+  let option.t[tup(bool, @expr)] e_ =\n+    option.map[@expr, tup(bool, @expr)](do_inner, b.node.expr);\n+  auto s = snd[bool, @expr];\n+  auto f = fst[bool, @expr];\n+  changed = changed ||\n+    from_maybe[bool](false,\n+                     option.map[tup(bool, @expr), bool](f, e_));\n+  let block_ b_res = rec(stmts=b.node.stmts,\n+                         expr=option.map[tup(bool, @expr), @expr](s, e_),\n+                         index=b.node.index);\n+  ret tup(changed, respan(b.span, b_res));\n+}\n+\n+fn find_pre_post_state_fn(_fn_info_map f_info, fn_info fi, &ast._fn f)\n+  -> tup(bool, ast._fn) {\n+  auto p = find_pre_post_state_block(f_info, fi, f.body);\n+  ret tup(p._0, rec(decl=f.decl, proto=f.proto, body=p._1));\n+}\n+\n+fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n+                      fn (_fn_info_map, fn_info, &ast._fn)\n+                           -> tup(bool, ast._fn) f,\n                       &ast._fn start) -> ast._fn {\n-  auto next = f(f_info, start);\n+  auto next = f(fm, f_info, start);\n \n   if (next._0) {\n     // something changed\n-    be fixed_point_states(f_info, f, next._1);\n+    be fixed_point_states(fm, f_info, f, next._1);\n   }\n   else {\n     // we're done!\n     ret next._1;\n   }\n }\n \n-fn check_states_expr(fn_info enclosing, &expr e) -> () {\n+impure fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let precond prec    = expr_precond(e);\n-  let postcond postc  = expr_postcond(e);\n   let prestate pres   = expr_prestate(e);\n-  let poststate posts = expr_poststate(e);\n \n   if (!implies(pres, prec)) {\n     log(\"check_states_expr: unsatisfied precondition\");\n     fail;\n   }\n-  if (!implies(posts, postc)) {\n-    log(\"check_states_expr: unsatisfied postcondition\");\n-    fail;\n-  }\n }\n \n fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n   alt (stmt_ann(s)) {\n-    case (ann_none) {\n-      // Statement doesn't require an annotation -- do nothing\n+    case (none[@ts_ann]) {\n       ret;\n     }\n-    case (ann_type(_,_,?m_pp)) {\n-      let precond prec    = stmt_precond(s);\n-      let postcond postc  = stmt_postcond(s);\n-      let prestate pres   = stmt_prestate(s);\n-      let poststate posts = stmt_poststate(s);\n+    case (some[@ts_ann](?a)) {\n+      let precond prec    = ann_precond(*a);\n+      let prestate pres   = ann_prestate(*a);\n \n       if (!implies(pres, prec)) {\n         log(\"check_states_stmt: unsatisfied precondition\");\n         fail;\n       }\n-      if (!implies(posts, postc)) {\n-        log(\"check_states_stmt: unsatisfied postcondition\");\n-        fail;\n-      }\n     }\n   }\n }\n@@ -855,7 +949,7 @@ fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n \n   /* Compute the pre- and post-states for this function */\n   auto g = find_pre_post_state_fn;\n-  auto res_f = fixed_point_states(f_info, g, f);\n+  auto res_f = fixed_point_states(f_info_map, f_info, g, f);\n \n   /* Now compare each expr's pre-state to its precondition\n      and post-state to its postcondition */"}, {"sha": "ee11a43ad20edeb87ec11aba05a9d3b52c868aed", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -339,8 +339,8 @@ impure fn print_block(ps s, ast.block blk) {\n         cur_line = st.span.hi.line;\n         maybe_print_comment(s, st.span.lo);\n         alt (st.node) {\n-            case (ast.stmt_decl(?decl)) {print_decl(s, decl);}\n-            case (ast.stmt_expr(?expr)) {print_expr(s, expr);}\n+          case (ast.stmt_decl(?decl,_)) {print_decl(s, decl);}\n+          case (ast.stmt_expr(?expr,_)) {print_expr(s, expr);}\n         }\n         if (front.parser.stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n         if (!maybe_print_line_comment(s, st.span)) {line(s.s);}"}, {"sha": "e34d1faec4092d0f657f4786089171b50c5b97d0", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -62,7 +62,11 @@ auth middle.typestate_check.log_expr = impure;\n auth lib.llvm = unsafe;\n auth pretty.pprust = impure;\n auth middle.typestate_check.find_pre_post_block = impure;\n-auth middle.typestate_check.find_pre_post_expr = impure;\n+auth middle.typestate_check.find_pre_post_state_block = impure;\n+auth middle.typestate_check.find_pre_post_expr  = impure;\n+auth middle.typestate_check.find_pre_post_stmt  = impure;\n+auth middle.typestate_check.check_states_against_conditions = impure;\n+auth middle.typestate_check.check_states_stmt   = impure;\n auth util.typestate_ann.implies = impure;\n \n mod lib {"}, {"sha": "53f9a71cf22d86857df4131b7cc9b1554006dc56", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -36,16 +36,29 @@ fn true_postcond(uint num_vars) -> postcond {\n   be true_precond(num_vars);\n }\n \n+fn empty_prestate(uint num_vars) -> prestate {\n+  be true_precond(num_vars);\n+}\n+\n+fn empty_poststate(uint num_vars) -> poststate {\n+  be true_precond(num_vars);\n+}\n+\n fn empty_pre_post(uint num_vars) -> pre_and_post {\n-  ret(rec(precondition=true_precond(num_vars),\n-           postcondition=true_postcond(num_vars)));\n+  ret(rec(precondition=empty_prestate(num_vars),\n+          postcondition=empty_poststate(num_vars)));\n }\n \n fn empty_states(uint num_vars) -> pre_and_post_state {\n   ret(rec(prestate=true_precond(num_vars),\n            poststate=true_postcond(num_vars)));\n }\n \n+fn empty_ann(uint num_vars) -> ts_ann {\n+  ret(rec(conditions=empty_pre_post(num_vars),\n+          states=empty_states(num_vars)));\n+}\n+\n fn get_pre(&pre_and_post p) -> precond {\n   ret p.precondition;\n }\n@@ -74,7 +87,37 @@ impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   bitv.set(p.postcondition, i, true);\n }\n \n-fn implies(bitv.t a, bitv.t b) -> bool {\n+impure fn set_in_postcond(uint i, &pre_and_post p) -> () {\n+  // sets the ith bit in p's post\n+  bitv.set(p.postcondition, i, true);\n+}\n+\n+// Sets all the bits in a's precondition to equal the\n+// corresponding bit in p's precondition.\n+impure fn set_precondition(&ts_ann a, &precond p) -> () {\n+  bitv.copy(p, a.conditions.precondition);\n+}\n+\n+// Sets all the bits in a's postcondition to equal the\n+// corresponding bit in p's postcondition.\n+impure fn set_postcondition(&ts_ann a, &postcond p) -> () {\n+  bitv.copy(p, a.conditions.postcondition);\n+}\n+\n+// Set all the bits in p that are set in new\n+impure fn extend_prestate(&prestate p, &poststate new) -> () {\n+  bitv.union(p, new);\n+}\n+\n+fn ann_precond(&ts_ann a) -> precond {\n+  ret a.conditions.precondition;\n+}\n+\n+fn ann_prestate(&ts_ann a) -> prestate {\n+  ret a.states.prestate;\n+}\n+\n+impure fn implies(bitv.t a, bitv.t b) -> bool {\n   bitv.difference(b, a);\n-  ret (bitv.equal(b, bitv.create(b.nbits, false)));\n+  be bitv.is_false(b);\n }"}, {"sha": "916a8205f23e7a536704cde1720d016a1780cf77", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -1,5 +1,6 @@\n import option.none;\n import option.some;\n+import util.orb;\n \n type vbuf = rustrt.vbuf;\n \n@@ -230,6 +231,26 @@ fn foldl[T, U](fn (&U, &T) -> U p, &U z, &vec[T] v) -> U {\n     }\n }\n \n+fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n+    auto sz = len[tup(T, U)](v);\n+\n+    if (sz == 0u) {\n+        ret tup(alloc[T](0u), alloc[U](0u));\n+    }\n+    else {\n+        auto rest = slice[tup(T, U)](v, 1u, sz);\n+        auto tl   = unzip[T, U](rest);\n+        auto a    = vec(v.(0)._0);\n+        auto b    = vec(v.(0)._1);\n+        ret tup(a + tl._0, b + tl._1);\n+    }\n+}\n+\n+fn or(&vec[bool] v) -> bool {\n+    auto f = orb;\n+    be _vec.foldl[bool, bool](f, false, v);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "98e6c0401d6f1decac9588e0620441de25a2137a", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -135,6 +135,28 @@ impure fn set(&t v, uint i, bool x) {\n     }\n }\n \n+/* true if all bits are 1 */\n+fn is_true(&t v) -> bool {\n+    for(uint i in v.storage) {\n+        if (i != 1u) {\n+            ret false;\n+        }\n+    }\n+\n+    ret true;\n+}\n+\n+/* true if all bits are non-1 */\n+fn is_false(&t v) -> bool {\n+    for(uint i in v.storage) {\n+        if (i == 1u) {\n+            ret false;\n+        }\n+    }\n+\n+    ret true;\n+}\n+\n fn init_to_vec(t v, uint i) -> uint {\n     if (get(v, i)) {\n         ret 1u;"}, {"sha": "66a41bcac68ea229b10a781da8239a674a48be7f", "filename": "src/lib/option.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -38,6 +38,13 @@ fn is_none[T](&t[T] opt) -> bool {\n     }\n }\n \n+fn from_maybe[T](&T def, &t[T] opt) -> T {\n+    alt(opt) {\n+        case (none[T])     { ret def; }\n+        case (some[T](?t)) { ret t; }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "2f797f69216f3634859c74784f5c58a234a8a5cc", "filename": "src/lib/util.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e90bd94de32c739733966bfac96cf35e9a08655/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=2e90bd94de32c739733966bfac96cf35e9a08655", "patch": "@@ -11,6 +11,18 @@ fn rational_leq(&rational x, &rational y) -> bool {\n     ret x.num * y.den <= y.num * x.den;\n }\n \n+fn fst[T, U](&tup(T, U) x) -> T {\n+    ret x._0;\n+}\n+\n+fn snd[T, U](&tup(T, U) x) -> U {\n+    ret x._1;\n+}\n+\n+fn orb(&bool a, &bool b) -> bool {\n+    ret a || b;\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}