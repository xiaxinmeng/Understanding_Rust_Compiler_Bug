{"sha": "d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Njk4NjlmN2E4YzdhNGMyM2IxNGZhZGJlZjYzZDRkYmM5NDliY2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T12:56:20Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T12:56:20Z"}, "message": "Decouple more", "tree": {"sha": "d29a985e08ec7ac000d968d0b94545415e997937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d29a985e08ec7ac000d968d0b94545415e997937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "html_url": "https://github.com/rust-lang/rust/commit/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35f57f35ec484422f06772ebe109c8fd28966ec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/35f57f35ec484422f06772ebe109c8fd28966ec5", "html_url": "https://github.com/rust-lang/rust/commit/35f57f35ec484422f06772ebe109c8fd28966ec5"}], "stats": {"total": 81, "additions": 41, "deletions": 40}, "files": [{"sha": "6d71bde9215b13ff11adf6e74f68658fdc4891f2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "patch": "@@ -647,7 +647,7 @@ impl Function {\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n-        infer.add_diagnostics(db, self, sink);\n+        infer.add_diagnostics(db, self.id, sink);\n         let mut validator = ExprValidator::new(self, infer, sink);\n         validator.validate_body(db);\n     }"}, {"sha": "0de36abd1666bd134aa393c94f0fca862a067b9e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "patch": "@@ -214,17 +214,17 @@ impl SourceAnalyzer {\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         let expr_id = self.expr_id(&call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id)\n+        self.infer.as_ref()?.method_resolution(expr_id).map(Function::from)\n     }\n \n     pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.clone().into())?;\n-        self.infer.as_ref()?.field_resolution(expr_id)\n+        self.infer.as_ref()?.field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<crate::StructField> {\n         let expr_id = self.expr_id(&field.expr()?)?;\n-        self.infer.as_ref()?.record_field_resolution(expr_id)\n+        self.infer.as_ref()?.record_field_resolution(expr_id).map(|it| it.into())\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<crate::VariantDef> {"}, {"sha": "7b6dfd61b962ab0a1d00c0a1f841b78f38b3bbfb", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "patch": "@@ -22,28 +22,28 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n+    body::Body,\n     data::{ConstData, FunctionData},\n-    path::known,\n+    expr::{BindingAnnotation, ExprId, PatId},\n+    path::{known, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId,\n+    AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n+    primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n     TypeWalk, Uncertain,\n };\n use crate::{\n-    code_model::TypeAlias,\n-    db::HirDatabase,\n-    expr::{BindingAnnotation, Body, ExprId, PatId},\n-    ty::infer::diagnostics::InferenceDiagnostic,\n-    AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n+    db::HirDatabase, ty::infer::diagnostics::InferenceDiagnostic, AssocItem, DefWithBody,\n+    VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -121,11 +121,11 @@ pub struct TypeMismatch {\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n-    method_resolutions: FxHashMap<ExprId, Function>,\n+    method_resolutions: FxHashMap<ExprId, FunctionId>,\n     /// For each field access expr, records the field it resolves to.\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n+    field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each field in record literal, records the field it resolves to.\n-    record_field_resolutions: FxHashMap<ExprId, StructField>,\n+    record_field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each struct literal, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantDef>,\n     /// For each associated item record what it resolves to\n@@ -137,13 +137,13 @@ pub struct InferenceResult {\n }\n \n impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<FunctionId> {\n         self.method_resolutions.get(&expr).copied()\n     }\n-    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.field_resolutions.get(&expr).copied()\n     }\n-    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+    pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.record_field_resolutions.get(&expr).copied()\n     }\n     pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantDef> {\n@@ -164,7 +164,7 @@ impl InferenceResult {\n     pub(crate) fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n-        owner: Function,\n+        owner: FunctionId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n@@ -243,11 +243,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.type_of_expr.insert(expr, ty);\n     }\n \n-    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+    fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId) {\n         self.result.method_resolutions.insert(expr, func);\n     }\n \n-    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructFieldId) {\n         self.result.field_resolutions.insert(expr, field);\n     }\n \n@@ -557,22 +557,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.infer_expr(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n     }\n \n-    fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n+    fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = known::std_iter_into_iterator();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n+    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n         let path = known::std_ops_try();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n     }\n \n-    fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n+    fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_future_future();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE).map(TypeAlias::from)\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n@@ -696,9 +696,10 @@ impl Expectation {\n }\n \n mod diagnostics {\n+    use hir_def::{expr::ExprId, FunctionId, HasSource, Lookup};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField, expr::ExprId, Function, HasSource};\n+    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n@@ -709,13 +710,14 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &impl HirDatabase,\n-            owner: Function,\n+            owner: FunctionId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let file = owner.source(db).file_id;\n-                    let field = owner.body_source_map(db).field_syntax(*expr, *field);\n+                    let file = owner.lookup(db).source(db).file_id;\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file, field })\n                 }\n             }"}, {"sha": "d9ea6da4230e418c60dd1ae2624bff3a42b2315d", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "patch": "@@ -100,7 +100,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias.id,\n+                                associated_ty: into_iter_item_alias,\n                                 parameters: Substs::single(iterable_ty),\n                             },\n                         };\n@@ -230,7 +230,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     });\n                     if let Some(field_def) = field_def {\n-                        self.result.record_field_resolutions.insert(field.expr, field_def);\n+                        self.result.record_field_resolutions.insert(field.expr, field_def.into());\n                     }\n                     let field_ty = field_def\n                         .map_or(Ty::Unknown, |it| field_types[it.id].clone())\n@@ -262,7 +262,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n                                 let field = StructFieldId { parent: s.into(), local_id }.into();\n                                 self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types(s.into())[field.id]\n+                                self.db.field_types(s.into())[field.local_id]\n                                     .clone()\n                                     .subst(&a_ty.parameters)\n                             })\n@@ -285,7 +285,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias.id,\n+                                associated_ty: future_future_output_alias,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };\n@@ -304,7 +304,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias.id,\n+                                associated_ty: ops_try_ok_alias,\n                                 parameters: Substs::single(inner_ty),\n                             },\n                         };\n@@ -557,7 +557,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.id.into()), Some(self.db.generic_params(func.id.into())))\n+                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };"}, {"sha": "5cc2498552c01329d63fce1c2bd6be7d0ba2284d", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d569869f7a8c7a4c23b14fadbef63d4dbc949bcd/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=d569869f7a8c7a4c23b14fadbef63d4dbc949bcd", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use hir_def::{\n     lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, type_ref::Mutability,\n-    AssocItemId, AstItemDef, HasModule, ImplId, TraitId,\n+    AssocItemId, AstItemDef, FunctionId, HasModule, ImplId, TraitId,\n };\n use hir_expand::name::Name;\n use ra_db::CrateId;\n@@ -18,7 +18,6 @@ use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{utils::all_super_traits, Ty, TypeCtor},\n-    Function,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -154,10 +153,10 @@ pub(crate) fn lookup_method(\n     db: &impl HirDatabase,\n     name: &Name,\n     resolver: &Resolver,\n-) -> Option<(Ty, Function)> {\n+) -> Option<(Ty, FunctionId)> {\n     iterate_method_candidates(ty, db, resolver, Some(name), LookupMode::MethodCall, |ty, f| match f\n     {\n-        AssocItemId::FunctionId(f) => Some((ty.clone(), f.into())),\n+        AssocItemId::FunctionId(f) => Some((ty.clone(), f)),\n         _ => None,\n     })\n }"}]}