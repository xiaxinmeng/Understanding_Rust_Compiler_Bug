{"sha": "6489ee10410f7be70dbefad322d1a3e1533ab282", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ODllZTEwNDEwZjdiZTcwZGJlZmFkMzIyZDFhM2UxNTMzYWIyODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T11:11:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T11:11:02Z"}, "message": "Auto merge of #83723 - cjgillot:ownernode, r=petrochenkov\n\nStore all HIR owners in the same container\n\nThis replaces the previous storage in a BTreeMap for each of Item/ImplItem/TraitItem/ForeignItem.\nThis should allow for a more compact storage.\n\nBased on https://github.com/rust-lang/rust/pull/83114", "tree": {"sha": "79e33e87955dfb85756c97f4854866c9a608ef17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79e33e87955dfb85756c97f4854866c9a608ef17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6489ee10410f7be70dbefad322d1a3e1533ab282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6489ee10410f7be70dbefad322d1a3e1533ab282", "html_url": "https://github.com/rust-lang/rust/commit/6489ee10410f7be70dbefad322d1a3e1533ab282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6489ee10410f7be70dbefad322d1a3e1533ab282/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71a6c7c80398143a67e27b01412f4b2ec12bde8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/71a6c7c80398143a67e27b01412f4b2ec12bde8b", "html_url": "https://github.com/rust-lang/rust/commit/71a6c7c80398143a67e27b01412f4b2ec12bde8b"}, {"sha": "f798510d02005c2bbb1269c384c321918c578f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/f798510d02005c2bbb1269c384c321918c578f74", "html_url": "https://github.com/rust-lang/rust/commit/f798510d02005c2bbb1269c384c321918c578f74"}], "stats": {"total": 1051, "additions": 572, "deletions": 479}, "files": [{"sha": "0fddb0ee4cc8c8f29c0d424acc4e14c3b2987a2c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -82,15 +82,11 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => {\n                 let hir_item = lctx.lower_trait_item(item);\n-                let id = hir_item.trait_item_id();\n-                lctx.trait_items.insert(id, hir_item);\n-                lctx.modules.entry(lctx.current_module).or_default().trait_items.insert(id);\n+                lctx.insert_trait_item(hir_item);\n             }\n             AssocCtxt::Impl => {\n                 let hir_item = lctx.lower_impl_item(item);\n-                let id = hir_item.impl_item_id();\n-                lctx.impl_items.insert(id, hir_item);\n-                lctx.modules.entry(lctx.current_module).or_default().impl_items.insert(id);\n+                lctx.insert_impl_item(hir_item);\n             }\n         });\n \n@@ -101,9 +97,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_foreign_item(item);\n-            let id = hir_item.foreign_item_id();\n-            lctx.foreign_items.insert(id, hir_item);\n-            lctx.modules.entry(lctx.current_module).or_default().foreign_items.insert(id);\n+            lctx.insert_foreign_item(hir_item);\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -123,7 +117,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n+        let parent_generics = match self.owners[parent_hir_id.def_id].unwrap().expect_item().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n@@ -224,7 +218,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let hir_id = self.lower_node_id(i.id);\n                 self.lower_attrs(hir_id, &i.attrs);\n                 let body = P(self.lower_mac_args(body));\n-                self.exported_macros.push(hir::MacroDef {\n+                self.insert_macro_def(hir::MacroDef {\n                     ident,\n                     vis,\n                     def_id: hir_id.expect_owner(),"}, {"sha": "57bf7be40566e16fbbc3ad8942926e6cfd4c6015", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -101,13 +101,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    items: BTreeMap<hir::ItemId, hir::Item<'hir>>,\n-\n-    trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem<'hir>>,\n-    impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem<'hir>>,\n-    foreign_items: BTreeMap<hir::ForeignItemId, hir::ForeignItem<'hir>>,\n+    owners: IndexVec<LocalDefId, Option<hir::OwnerNode<'hir>>>,\n     bodies: BTreeMap<hir::BodyId, hir::Body<'hir>>,\n-    exported_macros: Vec<hir::MacroDef<'hir>>,\n     non_exported_macro_attrs: Vec<ast::Attribute>,\n \n     trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n@@ -330,15 +325,11 @@ pub fn lower_crate<'a, 'hir>(\n         resolver,\n         nt_to_tokenstream,\n         arena,\n-        items: BTreeMap::new(),\n-        trait_items: BTreeMap::new(),\n-        impl_items: BTreeMap::new(),\n-        foreign_items: BTreeMap::new(),\n+        owners: IndexVec::default(),\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n         attrs: BTreeMap::default(),\n-        exported_macros: Vec::new(),\n         non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n@@ -521,8 +512,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.lower_mod(&c.items, c.span);\n+        let module = self.arena.alloc(self.lower_mod(&c.items, c.span));\n         self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n+        self.owners.ensure_contains_elem(CRATE_DEF_ID, || None);\n+        self.owners[CRATE_DEF_ID] = Some(hir::OwnerNode::Crate(module));\n+\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n@@ -557,13 +551,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         let krate = hir::Crate {\n-            item: module,\n-            exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n-            items: self.items,\n-            trait_items: self.trait_items,\n-            impl_items: self.impl_items,\n-            foreign_items: self.foreign_items,\n+            owners: self.owners,\n             bodies: self.bodies,\n             body_ids,\n             trait_impls: self.trait_impls,\n@@ -576,12 +565,48 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n-        let id = hir::ItemId { def_id: item.def_id };\n-        self.items.insert(id, item);\n+        let id = item.item_id();\n+        let item = self.arena.alloc(item);\n+        self.owners.ensure_contains_elem(id.def_id, || None);\n+        self.owners[id.def_id] = Some(hir::OwnerNode::Item(item));\n         self.modules.entry(self.current_module).or_default().items.insert(id);\n         id\n     }\n \n+    fn insert_foreign_item(&mut self, item: hir::ForeignItem<'hir>) -> hir::ForeignItemId {\n+        let id = item.foreign_item_id();\n+        let item = self.arena.alloc(item);\n+        self.owners.ensure_contains_elem(id.def_id, || None);\n+        self.owners[id.def_id] = Some(hir::OwnerNode::ForeignItem(item));\n+        self.modules.entry(self.current_module).or_default().foreign_items.insert(id);\n+        id\n+    }\n+\n+    fn insert_impl_item(&mut self, item: hir::ImplItem<'hir>) -> hir::ImplItemId {\n+        let id = item.impl_item_id();\n+        let item = self.arena.alloc(item);\n+        self.owners.ensure_contains_elem(id.def_id, || None);\n+        self.owners[id.def_id] = Some(hir::OwnerNode::ImplItem(item));\n+        self.modules.entry(self.current_module).or_default().impl_items.insert(id);\n+        id\n+    }\n+\n+    fn insert_trait_item(&mut self, item: hir::TraitItem<'hir>) -> hir::TraitItemId {\n+        let id = item.trait_item_id();\n+        let item = self.arena.alloc(item);\n+        self.owners.ensure_contains_elem(id.def_id, || None);\n+        self.owners[id.def_id] = Some(hir::OwnerNode::TraitItem(item));\n+        self.modules.entry(self.current_module).or_default().trait_items.insert(id);\n+        id\n+    }\n+\n+    fn insert_macro_def(&mut self, item: hir::MacroDef<'hir>) {\n+        let def_id = item.def_id;\n+        let item = self.arena.alloc(item);\n+        self.owners.ensure_contains_elem(def_id, || None);\n+        self.owners[def_id] = Some(hir::OwnerNode::MacroDef(item));\n+    }\n+\n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n         // Set up the counter if needed.\n         self.item_local_id_counters.entry(owner).or_insert(0);"}, {"sha": "c4cff79f6c525c5509821b620c4948b43334e08d", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -29,11 +29,14 @@ macro_rules! arena_types {\n             [] fn_decl: rustc_hir::FnDecl<$tcx>,\n             [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n             [few] foreign_item_ref: rustc_hir::ForeignItemRef<$tcx>,\n+            [] impl_item: rustc_hir::ImplItem<$tcx>,\n             [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n+            [] item: rustc_hir::Item<$tcx>,\n             [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n             [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n             [few] macro_def: rustc_hir::MacroDef<$tcx>,\n+            [few] mod_: rustc_hir::Mod<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,\n             [] pat: rustc_hir::Pat<$tcx>,\n             [] path: rustc_hir::Path<$tcx>,\n@@ -42,6 +45,7 @@ macro_rules! arena_types {\n             [] qpath: rustc_hir::QPath<$tcx>,\n             [] stmt: rustc_hir::Stmt<$tcx>,\n             [] field_def: rustc_hir::FieldDef<$tcx>,\n+            [] trait_item: rustc_hir::TraitItem<$tcx>,\n             [] trait_item_ref: rustc_hir::TraitItemRef,\n             [] ty: rustc_hir::Ty<$tcx>,\n             [] type_binding: rustc_hir::TypeBinding<$tcx>,"}, {"sha": "389d1e5899f70b77defab04752e6d6739754a3ed", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 213, "deletions": 58, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-filelength\n use crate::def::{CtorKind, DefKind, Res};\n-use crate::def_id::DefId;\n+use crate::def_id::{DefId, CRATE_DEF_ID};\n crate use crate::hir_id::{HirId, ItemLocalId};\n use crate::{itemlikevisit, LangItem};\n \n@@ -12,6 +12,7 @@ pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -627,22 +628,10 @@ pub struct ModuleItems {\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n #[derive(Debug)]\n pub struct Crate<'hir> {\n-    pub item: Mod<'hir>,\n-    pub exported_macros: &'hir [MacroDef<'hir>],\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n     pub non_exported_macro_attrs: &'hir [Attribute],\n \n-    // N.B., we use a `BTreeMap` here so that `visit_all_items` iterates\n-    // over the ids in increasing order. In principle it should not\n-    // matter what order we visit things in, but in *practice* it\n-    // does, because it can affect the order in which errors are\n-    // detected, which in turn can make UI tests yield\n-    // slightly different results.\n-    pub items: BTreeMap<ItemId, Item<'hir>>,\n-\n-    pub trait_items: BTreeMap<TraitItemId, TraitItem<'hir>>,\n-    pub impl_items: BTreeMap<ImplItemId, ImplItem<'hir>>,\n-    pub foreign_items: BTreeMap<ForeignItemId, ForeignItem<'hir>>,\n+    pub owners: IndexVec<LocalDefId, Option<OwnerNode<'hir>>>,\n     pub bodies: BTreeMap<BodyId, Body<'hir>>,\n     pub trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n@@ -668,20 +657,24 @@ pub struct Crate<'hir> {\n }\n \n impl Crate<'hir> {\n-    pub fn item(&self, id: ItemId) -> &Item<'hir> {\n-        &self.items[&id]\n+    pub fn module(&self) -> &'hir Mod<'hir> {\n+        if let Some(OwnerNode::Crate(m)) = self.owners[CRATE_DEF_ID] { m } else { panic!() }\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &TraitItem<'hir> {\n-        &self.trait_items[&id]\n+    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n+        self.owners[id.def_id].as_ref().unwrap().expect_item()\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem<'hir> {\n-        &self.impl_items[&id]\n+    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n+        self.owners[id.def_id].as_ref().unwrap().expect_trait_item()\n     }\n \n-    pub fn foreign_item(&self, id: ForeignItemId) -> &ForeignItem<'hir> {\n-        &self.foreign_items[&id]\n+    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n+        self.owners[id.def_id].as_ref().unwrap().expect_impl_item()\n+    }\n+\n+    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+        self.owners[id.def_id].as_ref().unwrap().expect_foreign_item()\n     }\n \n     pub fn body(&self, id: BodyId) -> &Body<'hir> {\n@@ -702,20 +695,14 @@ impl Crate<'_> {\n     where\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n-        for item in self.items.values() {\n-            visitor.visit_item(item);\n-        }\n-\n-        for trait_item in self.trait_items.values() {\n-            visitor.visit_trait_item(trait_item);\n-        }\n-\n-        for impl_item in self.impl_items.values() {\n-            visitor.visit_impl_item(impl_item);\n-        }\n-\n-        for foreign_item in self.foreign_items.values() {\n-            visitor.visit_foreign_item(foreign_item);\n+        for owner in self.owners.iter().filter_map(Option::as_ref) {\n+            match owner {\n+                OwnerNode::Item(item) => visitor.visit_item(item),\n+                OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n+                OwnerNode::ImplItem(item) => visitor.visit_impl_item(item),\n+                OwnerNode::TraitItem(item) => visitor.visit_trait_item(item),\n+                OwnerNode::MacroDef(_) | OwnerNode::Crate(_) => {}\n+            }\n         }\n     }\n \n@@ -724,28 +711,27 @@ impl Crate<'_> {\n     where\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n-        parallel!(\n-            {\n-                par_for_each_in(&self.items, |(_, item)| {\n-                    visitor.visit_item(item);\n-                });\n-            },\n-            {\n-                par_for_each_in(&self.trait_items, |(_, trait_item)| {\n-                    visitor.visit_trait_item(trait_item);\n-                });\n-            },\n-            {\n-                par_for_each_in(&self.impl_items, |(_, impl_item)| {\n-                    visitor.visit_impl_item(impl_item);\n-                });\n-            },\n-            {\n-                par_for_each_in(&self.foreign_items, |(_, foreign_item)| {\n-                    visitor.visit_foreign_item(foreign_item);\n-                });\n-            }\n-        );\n+        par_for_each_in(&self.owners.raw, |owner| match owner {\n+            Some(OwnerNode::Item(item)) => visitor.visit_item(item),\n+            Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n+            Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n+            Some(OwnerNode::TraitItem(item)) => visitor.visit_trait_item(item),\n+            Some(OwnerNode::MacroDef(_)) | Some(OwnerNode::Crate(_)) | None => {}\n+        })\n+    }\n+\n+    pub fn items<'hir>(&'hir self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n+        self.owners.iter().filter_map(|owner| match owner {\n+            Some(OwnerNode::Item(item)) => Some(*item),\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn exported_macros<'hir>(&'hir self) -> impl Iterator<Item = &'hir MacroDef<'hir>> + 'hir {\n+        self.owners.iter().filter_map(|owner| match owner {\n+            Some(OwnerNode::MacroDef(macro_def)) => Some(*macro_def),\n+            _ => None,\n+        })\n     }\n }\n \n@@ -2956,6 +2942,163 @@ pub struct TraitCandidate {\n     pub import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n+pub enum OwnerNode<'hir> {\n+    Item(&'hir Item<'hir>),\n+    ForeignItem(&'hir ForeignItem<'hir>),\n+    TraitItem(&'hir TraitItem<'hir>),\n+    ImplItem(&'hir ImplItem<'hir>),\n+    MacroDef(&'hir MacroDef<'hir>),\n+    Crate(&'hir Mod<'hir>),\n+}\n+\n+impl<'hir> OwnerNode<'hir> {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            OwnerNode::Item(Item { ident, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { ident, .. })\n+            | OwnerNode::ImplItem(ImplItem { ident, .. })\n+            | OwnerNode::TraitItem(TraitItem { ident, .. })\n+            | OwnerNode::MacroDef(MacroDef { ident, .. }) => Some(*ident),\n+            OwnerNode::Crate(..) => None,\n+        }\n+    }\n+\n+    pub fn span(&self) -> Span {\n+        match self {\n+            OwnerNode::Item(Item { span, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { span, .. })\n+            | OwnerNode::ImplItem(ImplItem { span, .. })\n+            | OwnerNode::TraitItem(TraitItem { span, .. })\n+            | OwnerNode::MacroDef(MacroDef { span, .. })\n+            | OwnerNode::Crate(Mod { inner: span, .. }) => *span,\n+        }\n+    }\n+\n+    pub fn fn_decl(&self) -> Option<&FnDecl<'hir>> {\n+        match self {\n+            OwnerNode::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n+            | OwnerNode::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n+            | OwnerNode::Item(Item { kind: ItemKind::Fn(fn_sig, _, _), .. }) => Some(fn_sig.decl),\n+            OwnerNode::ForeignItem(ForeignItem {\n+                kind: ForeignItemKind::Fn(fn_decl, _, _),\n+                ..\n+            }) => Some(fn_decl),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn body_id(&self) -> Option<BodyId> {\n+        match self {\n+            OwnerNode::TraitItem(TraitItem {\n+                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | OwnerNode::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n+            | OwnerNode::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn generics(&self) -> Option<&'hir Generics<'hir>> {\n+        match self {\n+            OwnerNode::TraitItem(TraitItem { generics, .. })\n+            | OwnerNode::ImplItem(ImplItem { generics, .. }) => Some(generics),\n+            OwnerNode::Item(item) => item.kind.generics(),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn def_id(self) -> LocalDefId {\n+        match self {\n+            OwnerNode::Item(Item { def_id, .. })\n+            | OwnerNode::TraitItem(TraitItem { def_id, .. })\n+            | OwnerNode::ImplItem(ImplItem { def_id, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { def_id, .. })\n+            | OwnerNode::MacroDef(MacroDef { def_id, .. }) => *def_id,\n+            OwnerNode::Crate(..) => crate::CRATE_HIR_ID.owner,\n+        }\n+    }\n+\n+    pub fn expect_item(self) -> &'hir Item<'hir> {\n+        match self {\n+            OwnerNode::Item(n) => n,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n+        match self {\n+            OwnerNode::ForeignItem(n) => n,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n+        match self {\n+            OwnerNode::ImplItem(n) => n,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n+        match self {\n+            OwnerNode::TraitItem(n) => n,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    pub fn expect_macro_def(self) -> &'hir MacroDef<'hir> {\n+        match self {\n+            OwnerNode::MacroDef(n) => n,\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+impl<'hir> Into<OwnerNode<'hir>> for &'hir Item<'hir> {\n+    fn into(self) -> OwnerNode<'hir> {\n+        OwnerNode::Item(self)\n+    }\n+}\n+\n+impl<'hir> Into<OwnerNode<'hir>> for &'hir ForeignItem<'hir> {\n+    fn into(self) -> OwnerNode<'hir> {\n+        OwnerNode::ForeignItem(self)\n+    }\n+}\n+\n+impl<'hir> Into<OwnerNode<'hir>> for &'hir ImplItem<'hir> {\n+    fn into(self) -> OwnerNode<'hir> {\n+        OwnerNode::ImplItem(self)\n+    }\n+}\n+\n+impl<'hir> Into<OwnerNode<'hir>> for &'hir TraitItem<'hir> {\n+    fn into(self) -> OwnerNode<'hir> {\n+        OwnerNode::TraitItem(self)\n+    }\n+}\n+\n+impl<'hir> Into<OwnerNode<'hir>> for &'hir MacroDef<'hir> {\n+    fn into(self) -> OwnerNode<'hir> {\n+        OwnerNode::MacroDef(self)\n+    }\n+}\n+\n+impl<'hir> Into<Node<'hir>> for OwnerNode<'hir> {\n+    fn into(self) -> Node<'hir> {\n+        match self {\n+            OwnerNode::Item(n) => Node::Item(n),\n+            OwnerNode::ForeignItem(n) => Node::ForeignItem(n),\n+            OwnerNode::ImplItem(n) => Node::ImplItem(n),\n+            OwnerNode::TraitItem(n) => Node::TraitItem(n),\n+            OwnerNode::MacroDef(n) => Node::MacroDef(n),\n+            OwnerNode::Crate(n) => Node::Crate(n),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum Node<'hir> {\n     Param(&'hir Param<'hir>),\n@@ -3084,6 +3227,18 @@ impl<'hir> Node<'hir> {\n             _ => Constness::NotConst,\n         }\n     }\n+\n+    pub fn as_owner(self) -> Option<OwnerNode<'hir>> {\n+        match self {\n+            Node::Item(i) => Some(OwnerNode::Item(i)),\n+            Node::ForeignItem(i) => Some(OwnerNode::ForeignItem(i)),\n+            Node::TraitItem(i) => Some(OwnerNode::TraitItem(i)),\n+            Node::ImplItem(i) => Some(OwnerNode::ImplItem(i)),\n+            Node::MacroDef(i) => Some(OwnerNode::MacroDef(i)),\n+            Node::Crate(i) => Some(OwnerNode::Crate(i)),\n+            _ => None,\n+        }\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "711b62c4a314259a61e1803c252adbedd084c55b", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -478,8 +478,9 @@ pub trait Visitor<'v>: Sized {\n \n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n-    visitor.visit_mod(&krate.item, krate.item.inner, CRATE_HIR_ID);\n-    walk_list!(visitor, visit_macro_def, krate.exported_macros);\n+    let top_mod = krate.module();\n+    visitor.visit_mod(top_mod, top_mod.inner, CRATE_HIR_ID);\n+    walk_list!(visitor, visit_macro_def, krate.exported_macros());\n     for (&id, attrs) in krate.attrs.iter() {\n         for a in *attrs {\n             visitor.visit_attribute(id, a)"}, {"sha": "4177c2f8d525e9081eb0096f3c298b8e48fd6c24", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -169,7 +169,7 @@ pub fn print_crate<'a>(\n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.item, s.attrs(hir::CRATE_HIR_ID));\n+    s.print_mod(&krate.module(), s.attrs(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }"}, {"sha": "b3c64b76820f11e3b55aa4da2437d1c8d3444a0d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -568,9 +568,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.item.inner, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.module().inner, \"the\", \"crate\");\n \n-        for macro_def in krate.exported_macros {\n+        for macro_def in krate.exported_macros() {\n             // Non exported macros should be skipped, since `missing_docs` only\n             // applies to externally visible items.\n             if !cx.access_levels.is_exported(macro_def.hir_id()) {"}, {"sha": "4f223afcc27a0055613882dde239db97172d66f6", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -33,11 +33,11 @@ fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n     let mut builder = LintLevelMapBuilder { levels, tcx, store };\n     let krate = tcx.hir().krate();\n \n-    builder.levels.id_to_set.reserve(krate.exported_macros.len() + 1);\n+    builder.levels.id_to_set.reserve(krate.owners.len() + 1);\n \n     let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n-    for macro_def in krate.exported_macros {\n+    for macro_def in krate.exported_macros() {\n         builder.levels.register_id(macro_def.hir_id());\n     }\n     intravisit::walk_crate(&mut builder, krate);"}, {"sha": "45a4762c700e41d6c83fbd2582516eccb3850d99", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -439,7 +439,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(CRATE_DEF_ID, &krate.item);\n+        self.encode_info_for_mod(CRATE_DEF_ID, krate.module());\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n \n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n-        for macro_def in krate.exported_macros {\n+        for macro_def in krate.exported_macros() {\n             self.visit_macro_def(macro_def);\n         }\n     }"}, {"sha": "0eb0c3eca4e3f226c0b2883a4a90d73f11c13887", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 50, "deletions": 123, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::def_id::CRATE_DEF_INDEX;\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n@@ -75,46 +75,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         arena: &'hir Arena<'hir>,\n         krate: &'hir Crate<'hir>,\n         definitions: &'a definitions::Definitions,\n-        mut hcx: StableHashingContext<'a>,\n+        hcx: StableHashingContext<'a>,\n     ) -> NodeCollector<'a, 'hir> {\n-        let hash = {\n-            let Crate {\n-                ref item,\n-                // These fields are handled separately:\n-                exported_macros: _,\n-                non_exported_macro_attrs: _,\n-                items: _,\n-                trait_items: _,\n-                impl_items: _,\n-                foreign_items: _,\n-                bodies: _,\n-                trait_impls: _,\n-                body_ids: _,\n-                modules: _,\n-                proc_macros: _,\n-                trait_map: _,\n-                attrs: _,\n-            } = *krate;\n-\n-            hash_body(&mut hcx, item)\n-        };\n-\n         let mut collector = NodeCollector {\n             arena,\n             krate,\n             source_map: sess.source_map(),\n             parent_node: hir::CRATE_HIR_ID,\n-            current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n+            current_dep_node_owner: CRATE_DEF_ID,\n             definitions,\n             hcx,\n             map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n             parenting: FxHashMap::default(),\n         };\n-        collector.insert_entry(\n-            hir::CRATE_HIR_ID,\n-            Entry { parent: hir::CRATE_HIR_ID, node: Node::Crate(&krate.item) },\n-            hash,\n-        );\n+        collector.insert_owner(CRATE_DEF_ID, OwnerNode::Crate(krate.module()));\n \n         collector\n     }\n@@ -128,53 +102,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         IndexedHir { map: self.map, parenting: self.parenting }\n     }\n \n-    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>, hash: Fingerprint) {\n-        let i = id.local_id.as_u32() as usize;\n-\n-        let arena = self.arena;\n+    fn insert_owner(&mut self, owner: LocalDefId, node: OwnerNode<'hir>) {\n+        let hash = hash_body(&mut self.hcx, node);\n \n-        let data = &mut self.map[id.owner];\n-\n-        if i == 0 {\n-            debug_assert!(data.is_none());\n-            *data = Some(arena.alloc(OwnerNodes {\n-                hash,\n-                nodes: IndexVec::new(),\n-                bodies: FxHashMap::default(),\n-            }));\n-\n-            let dk_parent = self.definitions.def_key(id.owner).parent;\n-            if let Some(dk_parent) = dk_parent {\n-                let dk_parent = LocalDefId { local_def_index: dk_parent };\n-                let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n-                if dk_parent.owner != entry.parent.owner {\n-                    panic!(\n-                        \"Different parents for {:?} => dk_parent={:?} actual={:?}\",\n-                        id.owner, dk_parent, entry.parent,\n-                    )\n-                }\n+        let mut nodes = IndexVec::new();\n+        nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: node.into() }));\n \n-                debug_assert_eq!(self.parenting.get(&id.owner), Some(&entry.parent));\n-            }\n-        } else {\n-            debug_assert_eq!(entry.parent.owner, id.owner);\n-        }\n-\n-        let data = data.as_mut().unwrap();\n-\n-        insert_vec_map(\n-            &mut data.nodes,\n-            id.local_id,\n-            ParentedNode { parent: entry.parent.local_id, node: entry.node },\n-        );\n+        debug_assert!(self.map[owner].is_none());\n+        self.map[owner] =\n+            Some(self.arena.alloc(OwnerNodes { hash, nodes, bodies: FxHashMap::default() }));\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n-        self.insert_with_hash(span, hir_id, node, Fingerprint::ZERO)\n-    }\n-\n-    fn insert_with_hash(&mut self, span: Span, hir_id: HirId, node: Node<'hir>, hash: Fingerprint) {\n-        let entry = Entry { parent: self.parent_node, node };\n+        debug_assert_eq!(self.current_dep_node_owner, hir_id.owner);\n+        debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n@@ -201,7 +142,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(hir_id, entry, hash);\n+        let nodes = self.map[hir_id.owner].as_mut().unwrap();\n+\n+        debug_assert_eq!(self.parent_node.owner, self.current_dep_node_owner);\n+        insert_vec_map(\n+            &mut nodes.nodes,\n+            hir_id.local_id,\n+            ParentedNode { parent: self.parent_node.local_id, node: node },\n+        );\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_node_id: HirId, f: F) {\n@@ -211,21 +159,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<\n-        T: for<'b> HashStable<StableHashingContext<'b>>,\n-        F: FnOnce(&mut Self, Fingerprint),\n-    >(\n-        &mut self,\n-        dep_node_owner: LocalDefId,\n-        item_like: &T,\n-        f: F,\n-    ) {\n+    fn with_dep_node_owner(&mut self, dep_node_owner: LocalDefId, f: impl FnOnce(&mut Self)) {\n         let prev_owner = self.current_dep_node_owner;\n-        let hash = hash_body(&mut self.hcx, item_like);\n+        let prev_parent = self.parent_node;\n \n         self.current_dep_node_owner = dep_node_owner;\n-        f(self, hash);\n+        self.parent_node = HirId::make_owner(dep_node_owner);\n+        f(self);\n         self.current_dep_node_owner = prev_owner;\n+        self.parent_node = prev_parent;\n     }\n \n     fn insert_nested(&mut self, item: LocalDefId) {\n@@ -291,28 +233,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.with_dep_node_owner(i.def_id, i, |this, hash| {\n-            let hir_id = i.hir_id();\n-            this.insert_with_hash(i.span, hir_id, Node::Item(i), hash);\n-            this.with_parent(hir_id, |this| {\n-                if let ItemKind::Struct(ref struct_def, _) = i.kind {\n-                    // If this is a tuple or unit-like struct, register the constructor.\n-                    if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                        this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n-                    }\n+        self.insert_owner(i.def_id, OwnerNode::Item(i));\n+        self.with_dep_node_owner(i.def_id, |this| {\n+            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+                // If this is a tuple or unit-like struct, register the constructor.\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n                 }\n-                intravisit::walk_item(this, i);\n-            });\n+            }\n+            intravisit::walk_item(this, i);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        self.with_dep_node_owner(fi.def_id, fi, |this, hash| {\n-            this.insert_with_hash(fi.span, fi.hir_id(), Node::ForeignItem(fi), hash);\n-\n-            this.with_parent(fi.hir_id(), |this| {\n-                intravisit::walk_foreign_item(this, fi);\n-            });\n+        self.insert_owner(fi.def_id, OwnerNode::ForeignItem(fi));\n+        self.with_dep_node_owner(fi.def_id, |this| {\n+            intravisit::walk_foreign_item(this, fi);\n         });\n     }\n \n@@ -322,26 +258,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_const_param_default(&mut self, param: HirId, ct: &'hir AnonConst) {\n-        self.with_parent(param, |this| intravisit::walk_const_param_default(this, ct))\n+        self.with_parent(param, |this| {\n+            intravisit::walk_const_param_default(this, ct);\n+        })\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        self.with_dep_node_owner(ti.def_id, ti, |this, hash| {\n-            this.insert_with_hash(ti.span, ti.hir_id(), Node::TraitItem(ti), hash);\n-\n-            this.with_parent(ti.hir_id(), |this| {\n-                intravisit::walk_trait_item(this, ti);\n-            });\n+        self.insert_owner(ti.def_id, OwnerNode::TraitItem(ti));\n+        self.with_dep_node_owner(ti.def_id, |this| {\n+            intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        self.with_dep_node_owner(ii.def_id, ii, |this, hash| {\n-            this.insert_with_hash(ii.span, ii.hir_id(), Node::ImplItem(ii), hash);\n-\n-            this.with_parent(ii.hir_id(), |this| {\n-                intravisit::walk_impl_item(this, ii);\n-            });\n+        self.insert_owner(ii.def_id, OwnerNode::ImplItem(ii));\n+        self.with_dep_node_owner(ii.def_id, |this| {\n+            intravisit::walk_impl_item(this, ii);\n         });\n     }\n \n@@ -433,7 +365,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_local(&mut self, l: &'hir Local<'hir>) {\n         self.insert(l.span, l.hir_id, Node::Local(l));\n-        self.with_parent(l.hir_id, |this| intravisit::walk_local(this, l))\n+        self.with_parent(l.hir_id, |this| {\n+            intravisit::walk_local(this, l);\n+        })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n@@ -460,16 +394,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let parent = def_key.parent.map_or(hir::CRATE_HIR_ID, |local_def_index| {\n             self.definitions.local_def_id_to_hir_id(LocalDefId { local_def_index })\n         });\n+        self.insert_owner(macro_def.def_id, OwnerNode::MacroDef(macro_def));\n         self.with_parent(parent, |this| {\n             this.insert_nested(macro_def.def_id);\n-            this.with_dep_node_owner(macro_def.def_id, macro_def, |this, hash| {\n-                this.insert_with_hash(\n-                    macro_def.span,\n-                    macro_def.hir_id(),\n-                    Node::MacroDef(macro_def),\n-                    hash,\n-                );\n-            })\n         });\n     }\n "}, {"sha": "1a3d875c5ba6b0d03767932070a2d6ceddb19659", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 46, "deletions": 57, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,6 +1,6 @@\n use self::collector::NodeCollector;\n \n-use crate::hir::{AttributeMap, IndexedHir};\n+use crate::hir::{AttributeMap, IndexedHir, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -121,13 +121,13 @@ pub struct ParentOwnerIterator<'map, 'hir> {\n }\n \n impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n-    type Item = (HirId, Node<'hir>);\n+    type Item = (HirId, OwnerNode<'hir>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id.local_id.index() != 0 {\n             self.current_id.local_id = ItemLocalId::new(0);\n-            if let Some(node) = self.map.find(self.current_id) {\n-                return Some((self.current_id, node));\n+            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+                return Some((self.current_id, node.node));\n             }\n         }\n         if self.current_id == CRATE_HIR_ID {\n@@ -144,8 +144,8 @@ impl<'hir> Iterator for ParentOwnerIterator<'_, 'hir> {\n             self.current_id = HirId::make_owner(parent_id);\n \n             // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n-            if let Some(node) = self.map.find(self.current_id) {\n-                return Some((self.current_id, node));\n+            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+                return Some((self.current_id, node.node));\n             }\n         }\n     }\n@@ -313,7 +313,7 @@ impl<'hir> Map<'hir> {\n     pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             let owner = self.tcx.hir_owner(id.owner)?;\n-            Some(owner.node)\n+            Some(owner.node.into())\n         } else {\n             let owner = self.tcx.hir_owner_nodes(id.owner)?;\n             let node = owner.nodes[id.local_id].as_ref()?;\n@@ -331,10 +331,12 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        self.get_if_local(id).and_then(|node| match &node {\n-            Node::ImplItem(impl_item) => Some(&impl_item.generics),\n-            Node::TraitItem(trait_item) => Some(&trait_item.generics),\n-            Node::Item(Item {\n+        let id = id.as_local()?;\n+        let node = self.tcx.hir_owner(id)?;\n+        match node.node {\n+            OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n+            OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n+            OwnerNode::Item(Item {\n                 kind:\n                     ItemKind::Fn(_, generics, _)\n                     | ItemKind::TyAlias(_, generics)\n@@ -347,35 +349,23 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => Some(generics),\n             _ => None,\n-        })\n+        }\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::Item(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::TraitItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::ImplItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n     }\n \n     pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        match self.find(id.hir_id()).unwrap() {\n-            Node::ForeignItem(item) => item,\n-            _ => bug!(),\n-        }\n+        self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n@@ -519,10 +509,12 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n-        let hir_id = self.local_def_id_to_hir_id(module);\n-        match self.get(hir_id) {\n-            Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate(item) => (&item, item.inner, hir_id),\n+        let hir_id = HirId::make_owner(module);\n+        match self.tcx.hir_owner(module).map(|o| o.node) {\n+            Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n+                (m, span, hir_id)\n+            }\n+            Some(OwnerNode::Crate(item)) => (item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -554,8 +546,8 @@ impl<'hir> Map<'hir> {\n     where\n         V: Visitor<'hir>,\n     {\n-        for id in self.krate().exported_macros {\n-            visitor.visit_macro_def(self.expect_macro_def(id.hir_id()));\n+        for macro_def in self.krate().exported_macros() {\n+            visitor.visit_macro_def(macro_def);\n         }\n     }\n \n@@ -659,24 +651,20 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n-            if let Node::Crate(_)\n-            | Node::Item(_)\n-            | Node::ForeignItem(_)\n-            | Node::TraitItem(_)\n-            | Node::ImplItem(_) = node\n-            {\n-                return hir_id;\n-            }\n+        if let Some((hir_id, _node)) = self.parent_owner_iter(hir_id).next() {\n+            // A MacroDef does not have children.\n+            debug_assert!(!matches!(_node, OwnerNode::MacroDef(_)));\n+            hir_id\n+        } else {\n+            CRATE_HIR_ID\n         }\n-        CRATE_HIR_ID\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n         for (hir_id, node) in self.parent_owner_iter(hir_id) {\n-            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+            if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n         }\n@@ -749,31 +737,32 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(node) = self.find(parent) {\n-            if let Node::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node {\n+        if let Some(node) = self.tcx.hir_owner(self.local_def_id(parent)) {\n+            if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n+            {\n                 return *abi;\n             }\n         }\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n     pub fn expect_item(&self, id: HirId) -> &'hir Item<'hir> {\n-        match self.find(id) {\n-            Some(Node::Item(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::Item(item) }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::ImplItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::ImplItem(item) }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::TraitItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::TraitItem(item) }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id)),\n         }\n     }\n@@ -786,15 +775,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem<'hir> {\n-        match self.find(id) {\n-            Some(Node::ForeignItem(item)) => item,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::ForeignItem(item) }) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_macro_def(&self, id: HirId) -> &'hir MacroDef<'hir> {\n-        match self.find(id) {\n-            Some(Node::MacroDef(macro_def)) => macro_def,\n+        match self.tcx.hir_owner(id.expect_owner()) {\n+            Some(Owner { node: OwnerNode::MacroDef(macro_def) }) => macro_def,\n             _ => bug!(\"expected macro def, found {}\", self.node_to_string(id)),\n         }\n     }"}, {"sha": "158499bc0aef787661ac8e3164344293597f62c4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -33,9 +33,12 @@ pub struct IndexedHir<'hir> {\n \n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n+///\n+/// This struct exists to encapsulate all access to the hir_owner query in this module, and to\n+/// implement HashStable without hashing bodies.\n #[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n-    node: Node<'tcx>,\n+    node: OwnerNode<'tcx>,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n@@ -140,7 +143,8 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| {\n         let owner = tcx.index_hir(()).map[id].as_ref()?;\n-        let node = owner.nodes[ItemLocalId::new(0)].as_ref()?.node;\n+        let node = owner.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n         Some(Owner { node })\n     };\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();"}, {"sha": "dc94124e62ab6a031d22990bfeeb87dc9a8aac40", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -2307,7 +2307,7 @@ define_print_and_forward_display! {\n fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, Namespace, DefId)) {\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n-    for item in hir.krate().items.values() {\n+    for item in hir.krate().items() {\n         if item.ident.name.as_str().is_empty() || matches!(item.kind, ItemKind::Use(_, _)) {\n             continue;\n         }"}, {"sha": "ee9057a3bab779af567d853b4a10e84fa1a57f56", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1644,11 +1644,11 @@ fn check_invalid_macro_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let check_attr_visitor = &mut CheckAttrVisitor { tcx };\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut check_attr_visitor.as_deep_visitor());\n-    tcx.hir().visit_exported_macros_in_krate(check_attr_visitor);\n-    check_invalid_macro_level_attr(tcx, tcx.hir().krate().non_exported_macro_attrs);\n     if module_def_id.is_top_level_module() {\n         check_attr_visitor.check_attributes(CRATE_HIR_ID, &DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());\n+        tcx.hir().visit_exported_macros_in_krate(check_attr_visitor);\n+        check_invalid_macro_level_attr(tcx, tcx.hir().krate().non_exported_macro_attrs);\n     }\n }\n "}, {"sha": "3cf1d0cdd94b7a59e9b79771ecce68031ea523e6", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -108,7 +108,7 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> FxHashMap<Symbol\n     // Collect diagnostic items in this crate.\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n-    for m in tcx.hir().krate().exported_macros {\n+    for m in tcx.hir().krate().exported_macros() {\n         collector.observe_item(m.def_id);\n     }\n "}, {"sha": "876edbd1f6d55569eaf9ae447193dd9e70e58640", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -183,7 +183,7 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n }\n \n fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n-    let sp = tcx.hir().krate().item.inner;\n+    let sp = tcx.hir().krate().module().inner;\n     if *tcx.sess.parse_sess.reached_eof.borrow() {\n         // There's an unclosed brace that made the parser reach `Eof`, we shouldn't complain about\n         // the missing `fn main()` then as it might have been hidden inside an unclosed block."}, {"sha": "3db0409d8f009c959b9a7116f5be6ca87e974d5a", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -732,7 +732,7 @@ fn stability_index(tcx: TyCtxt<'tcx>, (): ()) -> Index<'tcx> {\n \n         annotator.annotate(\n             hir::CRATE_HIR_ID,\n-            krate.item.inner,\n+            krate.module().inner,\n             None,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n@@ -929,7 +929,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n-        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.item.inner);\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.module().inner);\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "b5033897ae65fff1c648e634491bdd35a3fbfc97", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1015,24 +1015,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-                                let parent_is_item = if let Some(parent_def_id) =\n-                                    parent_id.as_owner()\n-                                {\n-                                    let parent_item_id = hir::ItemId { def_id: parent_def_id };\n-                                    let parent_impl_id = hir::ImplItemId { def_id: parent_def_id };\n-                                    let parent_trait_id =\n-                                        hir::TraitItemId { def_id: parent_def_id };\n-                                    let parent_foreign_id =\n-                                        hir::ForeignItemId { def_id: parent_def_id };\n-                                    let krate = self.tcx.hir().krate();\n-\n-                                    krate.items.contains_key(&parent_item_id)\n-                                        || krate.impl_items.contains_key(&parent_impl_id)\n-                                        || krate.trait_items.contains_key(&parent_trait_id)\n-                                        || krate.foreign_items.contains_key(&parent_foreign_id)\n-                                } else {\n-                                    false\n-                                };\n+                                // FIXME(cjgillot) Can this check be replaced by\n+                                // `let parent_is_item = parent_id.is_owner();`?\n+                                let parent_is_item =\n+                                    if let Some(parent_def_id) = parent_id.as_owner() {\n+                                        matches!(\n+                                            self.tcx.hir().krate().owners.get(parent_def_id),\n+                                            Some(Some(_)),\n+                                        )\n+                                    } else {\n+                                        false\n+                                    };\n \n                                 if !parent_is_item {\n                                     if !self.trait_definition_only {"}, {"sha": "4f8dc7d16d4b9578dea145825cf7d98ba19277de", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             },\n             crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n             external_crates: self.save_ctxt.get_external_crates(),\n-            span: self.span_from_span(krate.item.inner),\n+            span: self.span_from_span(krate.module().inner),\n         };\n \n         self.dumper.crate_prelude(data);\n@@ -1092,11 +1092,12 @@ impl<'tcx> DumpVisitor<'tcx> {\n             format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()));\n \n         let sm = self.tcx.sess.source_map();\n-        let filename = sm.span_to_filename(krate.item.inner);\n+        let krate_mod = krate.module();\n+        let filename = sm.span_to_filename(krate_mod.inner);\n         let data_id = id_from_hir_id(id, &self.save_ctxt);\n         let children =\n-            krate.item.item_ids.iter().map(|i| id_from_def_id(i.def_id.to_def_id())).collect();\n-        let span = self.span_from_span(krate.item.inner);\n+            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.def_id.to_def_id())).collect();\n+        let span = self.span_from_span(krate_mod.inner);\n         let attrs = self.tcx.hir().attrs(id);\n \n         self.dumper.dump_def("}, {"sha": "101d3b400c3dfaf62173c06025a4f2e9677031cb", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -227,7 +227,7 @@ impl ExternalCrate {\n         if root.is_local() {\n             tcx.hir()\n                 .krate()\n-                .item\n+                .module()\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {\n@@ -293,7 +293,7 @@ impl ExternalCrate {\n         if root.is_local() {\n             tcx.hir()\n                 .krate()\n-                .item\n+                .module()\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {"}, {"sha": "d5268abeec79584c55e41b5f4f23ff7284a00c9b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -144,7 +144,7 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n                 hir_collector.visit_testable(\n                     \"\".to_string(),\n                     CRATE_HIR_ID,\n-                    krate.item.inner,\n+                    krate.module().inner,\n                     |this| {\n                         intravisit::walk_crate(this, krate);\n                     },"}, {"sha": "d74b3b4627284321b391a4de5363ef2517e3a5aa", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -72,18 +72,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     crate fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n-        let span = krate.item.inner;\n+        let span = krate.module().inner;\n         let mut top_level_module = self.visit_mod_contents(\n             &Spanned { span, node: hir::VisibilityKind::Public },\n             hir::CRATE_HIR_ID,\n-            &krate.item,\n+            &krate.module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n         );\n         // Attach the crate's exported macros to the top-level module.\n         // In the case of macros 2.0 (`pub macro`), and for built-in `derive`s or attributes as\n         // well (_e.g._, `Copy`), these are wrongly bundled in there too, so we need to fix that by\n         // moving them back to their correct locations.\n-        'exported_macros: for def in krate.exported_macros {\n+        'exported_macros: for def in krate.exported_macros() {\n             // The `def` of a macro in `exported_macros` should correspond to either:\n             //  - a `#[macro_export] macro_rules!` macro,\n             //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,"}, {"sha": "1f494e444846fa3555aa3e2907120090684607fc", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -33,7 +33,7 @@ macro_rules! fake_lint_pass {\n                     if !cx.sess().contains_name(attrs, $attr) {\n                         cx.lint(CRATE_NOT_OKAY, |lint| {\n                              let msg = format!(\"crate is not marked with #![{}]\", $attr);\n-                             lint.build(&msg).set_span(krate.item.inner).emit()\n+                             lint.build(&msg).set_span(krate.module().inner).emit()\n                         });\n                     }\n                 )*"}, {"sha": "122a544e9d4699706fff947e2d274eb0a16af64d", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n         if !cx.sess().contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n             cx.lint(CRATE_NOT_OKAY, |lint| {\n                 lint.build(\"crate is not marked with #![crate_okay]\")\n-                    .set_span(krate.item.inner)\n+                    .set_span(krate.module().inner)\n                     .emit()\n             });\n         }"}, {"sha": "77915a80a79b07713b60cd863739a309aa3be642", "filename": "src/test/ui/associated-item/issue-48027.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,18 +1,3 @@\n-error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/issue-48027.rs:6:6\n-   |\n-LL | impl dyn Bar {}\n-   |      ^^^^^^^ `Bar` cannot be made into an object\n-   |\n-   = help: consider moving `X` to another trait\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-48027.rs:2:11\n-   |\n-LL | trait Bar {\n-   |       --- this trait cannot be made into an object...\n-LL |     const X: usize;\n-   |           ^ ...because it contains this associated `const`\n-\n error[E0283]: type annotations needed\n   --> $DIR/issue-48027.rs:3:32\n    |\n@@ -30,6 +15,21 @@ note: required by `Bar::X`\n LL |     const X: usize;\n    |     ^^^^^^^^^^^^^^^\n \n+error[E0038]: the trait `Bar` cannot be made into an object\n+  --> $DIR/issue-48027.rs:6:6\n+   |\n+LL | impl dyn Bar {}\n+   |      ^^^^^^^ `Bar` cannot be made into an object\n+   |\n+   = help: consider moving `X` to another trait\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/issue-48027.rs:2:11\n+   |\n+LL | trait Bar {\n+   |       --- this trait cannot be made into an object...\n+LL |     const X: usize;\n+   |           ^ ...because it contains this associated `const`\n+\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0038, E0283."}, {"sha": "853705dae09f2d4c75b65e55a17cc1f92b888a13", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -14,31 +14,31 @@ LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n              <&T as Clone>\n \n error[E0277]: the trait bound `for<'b> <u16 as Z<'b, u16>>::W: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-2.rs:16:14\n+  --> $DIR/hr-associated-type-bound-param-2.rs:4:8\n    |\n LL | trait Z<'a, T: ?Sized>\n    |       - required by a bound in this\n+LL | where\n+LL |     T: Z<'a, u16>,\n+   |        ^^^^^^^^^^ the trait `for<'b> Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n ...\n LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n    |                                   ----- required by this bound in `Z`\n-...\n-LL |     type W = str;\n-   |              ^^^ the trait `for<'b> Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n    |\n    = help: the following implementations were found:\n              <&T as Clone>\n \n error[E0277]: the trait bound `for<'b> <u16 as Z<'b, u16>>::W: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-2.rs:4:8\n+  --> $DIR/hr-associated-type-bound-param-2.rs:16:14\n    |\n LL | trait Z<'a, T: ?Sized>\n    |       - required by a bound in this\n-LL | where\n-LL |     T: Z<'a, u16>,\n-   |        ^^^^^^^^^^ the trait `for<'b> Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n ...\n LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n    |                                   ----- required by this bound in `Z`\n+...\n+LL |     type W = str;\n+   |              ^^^ the trait `for<'b> Clone` is not implemented for `<u16 as Z<'b, u16>>::W`\n    |\n    = help: the following implementations were found:\n              <&T as Clone>"}, {"sha": "613918f78f36c84364310452a6847dbf15d1756c", "filename": "src/test/ui/const-generics/const-param-elided-lifetime.min.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -47,28 +47,28 @@ LL | impl<const N: &u8> A<N> {\n    = help: more complex types are supported with `#![feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n-  --> $DIR/const-param-elided-lifetime.rs:23:15\n+  --> $DIR/const-param-elided-lifetime.rs:18:21\n    |\n-LL | impl<const N: &u8> B for A<N> {}\n-   |               ^^^\n+LL |     fn foo<const M: &u8>(&self) {}\n+   |                     ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n-  --> $DIR/const-param-elided-lifetime.rs:27:17\n+  --> $DIR/const-param-elided-lifetime.rs:23:15\n    |\n-LL | fn bar<const N: &u8>() {}\n-   |                 ^^^\n+LL | impl<const N: &u8> B for A<N> {}\n+   |               ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n-  --> $DIR/const-param-elided-lifetime.rs:18:21\n+  --> $DIR/const-param-elided-lifetime.rs:27:17\n    |\n-LL |     fn foo<const M: &u8>(&self) {}\n-   |                     ^^^\n+LL | fn bar<const N: &u8>() {}\n+   |                 ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(const_generics)]`"}, {"sha": "b81aeabab7ff1b0dc483f4211acfc2fb12c01a5b", "filename": "src/test/ui/dep-graph/dep-graph-struct-signature.stderr", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-struct-signature.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -16,6 +16,12 @@ error: no path from `WillChange` to `trait_def`\n LL |     #[rustc_then_this_would_need(trait_def)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: OK\n+  --> $DIR/dep-graph-struct-signature.rs:31:9\n+   |\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:35:5\n    |\n@@ -46,12 +52,36 @@ error: OK\n LL |     #[rustc_then_this_would_need(type_of)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: OK\n+  --> $DIR/dep-graph-struct-signature.rs:47:9\n+   |\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: OK\n+  --> $DIR/dep-graph-struct-signature.rs:48:9\n+   |\n+LL |         #[rustc_then_this_would_need(typeck)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:52:5\n    |\n LL |     #[rustc_then_this_would_need(type_of)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: OK\n+  --> $DIR/dep-graph-struct-signature.rs:54:9\n+   |\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: OK\n+  --> $DIR/dep-graph-struct-signature.rs:55:9\n+   |\n+LL |         #[rustc_then_this_would_need(typeck)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: OK\n   --> $DIR/dep-graph-struct-signature.rs:60:9\n    |\n@@ -76,6 +106,12 @@ error: no path from `WillChange` to `type_of`\n LL |     #[rustc_then_this_would_need(type_of)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: no path from `WillChange` to `fn_sig`\n+  --> $DIR/dep-graph-struct-signature.rs:76:9\n+   |\n+LL |         #[rustc_then_this_would_need(fn_sig)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: no path from `WillChange` to `fn_sig`\n   --> $DIR/dep-graph-struct-signature.rs:80:5\n    |\n@@ -94,41 +130,5 @@ error: no path from `WillChange` to `typeck`\n LL |     #[rustc_then_this_would_need(typeck)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: OK\n-  --> $DIR/dep-graph-struct-signature.rs:31:9\n-   |\n-LL |         #[rustc_then_this_would_need(fn_sig)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: no path from `WillChange` to `fn_sig`\n-  --> $DIR/dep-graph-struct-signature.rs:76:9\n-   |\n-LL |         #[rustc_then_this_would_need(fn_sig)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-struct-signature.rs:47:9\n-   |\n-LL |         #[rustc_then_this_would_need(fn_sig)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-struct-signature.rs:48:9\n-   |\n-LL |         #[rustc_then_this_would_need(typeck)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-struct-signature.rs:54:9\n-   |\n-LL |         #[rustc_then_this_would_need(fn_sig)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-struct-signature.rs:55:9\n-   |\n-LL |         #[rustc_then_this_would_need(typeck)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: aborting due to 22 previous errors\n "}, {"sha": "e698ce8f628b4e898947fcd7db2a4fee01120dda", "filename": "src/test/ui/dep-graph/dep-graph-type-alias.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-type-alias.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -28,12 +28,30 @@ error: no path from `TypeAlias` to `type_of`\n LL | #[rustc_then_this_would_need(type_of)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: OK\n+  --> $DIR/dep-graph-type-alias.rs:35:5\n+   |\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: no path from `TypeAlias` to `type_of`\n   --> $DIR/dep-graph-type-alias.rs:41:1\n    |\n LL | #[rustc_then_this_would_need(type_of)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: OK\n+  --> $DIR/dep-graph-type-alias.rs:43:5\n+   |\n+LL |     #[rustc_then_this_would_need(fn_sig)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: OK\n+  --> $DIR/dep-graph-type-alias.rs:44:5\n+   |\n+LL |     #[rustc_then_this_would_need(typeck)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: OK\n   --> $DIR/dep-graph-type-alias.rs:48:1\n    |\n@@ -52,23 +70,5 @@ error: OK\n LL | #[rustc_then_this_would_need(typeck)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: OK\n-  --> $DIR/dep-graph-type-alias.rs:35:5\n-   |\n-LL |     #[rustc_then_this_would_need(fn_sig)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-type-alias.rs:43:5\n-   |\n-LL |     #[rustc_then_this_would_need(fn_sig)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: OK\n-  --> $DIR/dep-graph-type-alias.rs:44:5\n-   |\n-LL |     #[rustc_then_this_would_need(typeck)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: aborting due to 12 previous errors\n "}, {"sha": "f9c53a66c4b84a1cb63cd66661bb9e460f125059", "filename": "src/test/ui/feature-gates/feature-gate-arbitrary_self_types-raw-pointer.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: `*const Self` cannot be used as the type of `self` without the `arbitrary_self_types` feature\n-  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:9:18\n+error[E0658]: `*const Foo` cannot be used as the type of `self` without the `arbitrary_self_types` feature\n+  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:4:18\n    |\n-LL |     fn bar(self: *const Self);\n+LL |     fn foo(self: *const Self) {}\n    |                  ^^^^^^^^^^^\n    |\n    = note: see issue #44874 <https://github.com/rust-lang/rust/issues/44874> for more information\n    = help: add `#![feature(arbitrary_self_types)]` to the crate attributes to enable\n    = help: consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one of the previous types except `Self`)\n \n-error[E0658]: `*const Foo` cannot be used as the type of `self` without the `arbitrary_self_types` feature\n-  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:4:18\n+error[E0658]: `*const Self` cannot be used as the type of `self` without the `arbitrary_self_types` feature\n+  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:9:18\n    |\n-LL |     fn foo(self: *const Self) {}\n+LL |     fn bar(self: *const Self);\n    |                  ^^^^^^^^^^^\n    |\n    = note: see issue #44874 <https://github.com/rust-lang/rust/issues/44874> for more information"}, {"sha": "28f87a75f0f1521691ce67fd81b335f68b429b44", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -25,6 +25,24 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    = note: 127 redundant requirements hidden\n    = note: required because of the requirements on the impl of `Foo` for `NoData<T>`\n \n+error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n+  --> $DIR/issue-20413.rs:8:36\n+   |\n+LL | trait Foo {\n+   | --------- required by this bound in `Foo`\n+...\n+LL | impl<T> Foo for T where NoData<T>: Foo {\n+   |                                    ^^^\n+   |\n+   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n+note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-20413.rs:8:9\n+   |\n+LL | impl<T> Foo for T where NoData<T>: Foo {\n+   |         ^^^     ^\n+   = note: 127 redundant requirements hidden\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<T>`\n+\n error[E0275]: overflow evaluating the requirement `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Baz`\n   --> $DIR/issue-20413.rs:28:42\n    |\n@@ -48,47 +66,6 @@ LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    = note: 126 redundant requirements hidden\n    = note: required because of the requirements on the impl of `Baz` for `EvenLessData<T>`\n \n-error[E0275]: overflow evaluating the requirement `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Bar`\n-  --> $DIR/issue-20413.rs:36:42\n-   |\n-LL | trait Bar {\n-   | --------- required by this bound in `Bar`\n-...\n-LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n-   |                                          ^^^\n-   |\n-   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n-note: required because of the requirements on the impl of `Baz` for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/issue-20413.rs:36:9\n-   |\n-LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n-   |         ^^^     ^\n-note: required because of the requirements on the impl of `Bar` for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/issue-20413.rs:28:9\n-   |\n-LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n-   |         ^^^     ^\n-   = note: 126 redundant requirements hidden\n-   = note: required because of the requirements on the impl of `Bar` for `AlmostNoData<T>`\n-\n-error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n-  --> $DIR/issue-20413.rs:8:36\n-   |\n-LL | trait Foo {\n-   | --------- required by this bound in `Foo`\n-...\n-LL | impl<T> Foo for T where NoData<T>: Foo {\n-   |                                    ^^^\n-   |\n-   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n-note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n-  --> $DIR/issue-20413.rs:8:9\n-   |\n-LL | impl<T> Foo for T where NoData<T>: Foo {\n-   |         ^^^     ^\n-   = note: 127 redundant requirements hidden\n-   = note: required because of the requirements on the impl of `Foo` for `NoData<T>`\n-\n error[E0275]: overflow evaluating the requirement `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Baz`\n   --> $DIR/issue-20413.rs:28:42\n    |\n@@ -135,6 +112,29 @@ LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    = note: 126 redundant requirements hidden\n    = note: required because of the requirements on the impl of `Bar` for `AlmostNoData<T>`\n \n+error[E0275]: overflow evaluating the requirement `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Bar`\n+  --> $DIR/issue-20413.rs:36:42\n+   |\n+LL | trait Bar {\n+   | --------- required by this bound in `Bar`\n+...\n+LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n+   |                                          ^^^\n+   |\n+   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n+note: required because of the requirements on the impl of `Baz` for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-20413.rs:36:9\n+   |\n+LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n+   |         ^^^     ^\n+note: required because of the requirements on the impl of `Bar` for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n+  --> $DIR/issue-20413.rs:28:9\n+   |\n+LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n+   |         ^^^     ^\n+   = note: 126 redundant requirements hidden\n+   = note: required because of the requirements on the impl of `Bar` for `AlmostNoData<T>`\n+\n error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0275, E0392."}, {"sha": "18ba7254446b4768a133b98113bcfafb393113c0", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,22 +1,3 @@\n-error[E0277]: the size for values of type `T` cannot be known at compilation time\n-  --> $DIR/adt-param-with-implicit-sized-bound.rs:25:9\n-   |\n-LL | struct X<T>(T);\n-   |          - required by this bound in `X`\n-...\n-LL | struct Struct5<T: ?Sized>{\n-   |                - this type parameter needs to be `std::marker::Sized`\n-LL |     _t: X<T>,\n-   |         ^^^^ doesn't have a size known at compile-time\n-   |\n-help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n-  --> $DIR/adt-param-with-implicit-sized-bound.rs:18:10\n-   |\n-LL | struct X<T>(T);\n-   |          ^  - ...if indirection were used here: `Box<T>`\n-   |          |\n-   |          this could be changed to `T: ?Sized`...\n-\n error[E0277]: the size for values of type `Self` cannot be known at compilation time\n   --> $DIR/adt-param-with-implicit-sized-bound.rs:2:19\n    |\n@@ -92,6 +73,25 @@ help: consider relaxing the implicit `Sized` restriction\n LL | struct Struct4<T: ?Sized>{\n    |                 ^^^^^^^^\n \n+error[E0277]: the size for values of type `T` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:25:9\n+   |\n+LL | struct X<T>(T);\n+   |          - required by this bound in `X`\n+...\n+LL | struct Struct5<T: ?Sized>{\n+   |                - this type parameter needs to be `std::marker::Sized`\n+LL |     _t: X<T>,\n+   |         ^^^^ doesn't have a size known at compile-time\n+   |\n+help: you could relax the implicit `Sized` bound on `T` if it were used through indirection like `&T` or `Box<T>`\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:18:10\n+   |\n+LL | struct X<T>(T);\n+   |          ^  - ...if indirection were used here: `Box<T>`\n+   |          |\n+   |          this could be changed to `T: ?Sized`...\n+\n error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4a53706f9772e0a761fa57fd2c66bc7e1422e1cb", "filename": "src/test/ui/suggestions/object-unsafe-trait-should-use-where-sized.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fobject-unsafe-trait-should-use-where-sized.stderr?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -1,3 +1,12 @@\n+error[E0307]: invalid `self` parameter type: ()\n+  --> $DIR/object-unsafe-trait-should-use-where-sized.rs:6:18\n+   |\n+LL |     fn bar(self: ()) {}\n+   |                  ^^\n+   |\n+   = note: type of `self` must be `Self` or a type that dereferences to it\n+   = help: consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one of the previous types except `Self`)\n+\n error[E0038]: the trait `Trait` cannot be made into an object\n   --> $DIR/object-unsafe-trait-should-use-where-sized.rs:9:12\n    |\n@@ -26,15 +35,6 @@ help: consider changing method `bar`'s `self` parameter to be `&self`\n LL |     fn bar(self: &Self) {}\n    |                  ^^^^^\n \n-error[E0307]: invalid `self` parameter type: ()\n-  --> $DIR/object-unsafe-trait-should-use-where-sized.rs:6:18\n-   |\n-LL |     fn bar(self: ()) {}\n-   |                  ^^\n-   |\n-   = note: type of `self` must be `Self` or a type that dereferences to it\n-   = help: consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one of the previous types except `Self`)\n-\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0038, E0307."}, {"sha": "6ad702f8eafdf28a1130c4c9f6a8bea66313bb91", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6489ee10410f7be70dbefad322d1a3e1533ab282/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=6489ee10410f7be70dbefad322d1a3e1533ab282", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n         let attrs = cx.tcx.hir().attrs(hir::CRATE_HIR_ID);\n-        self.check_missing_docs_attrs(cx, attrs, krate.item.inner, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, attrs, krate.module().inner, \"the\", \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {"}]}