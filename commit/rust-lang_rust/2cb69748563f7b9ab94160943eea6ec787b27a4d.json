{"sha": "2cb69748563f7b9ab94160943eea6ec787b27a4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYjY5NzQ4NTYzZjdiOWFiOTQxNjA5NDNlZWE2ZWM3ODdiMjdhNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T11:33:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T11:33:58Z"}, "message": "auto merge of #5640 : dbaupp/rust/syntax-generalise-deriving, r=thestinger\n\nThis refactors much of the ast generation required for `deriving` instances into a common interface, so that new instances only need to specify what they do with the actual data, rather than worry about naming function arguments and extracting fields from structs and enum. (This all happens in `generic.rs`. I've tried to make sure it was well commented and explained, since it's a little abstract at points, but I'm sure it's still a little confusing.)\r\n\r\nIt makes instances like the comparison traits and `Clone` short and easy to write.\r\n\r\nCaveats:\r\n- Not surprisingly, this slows the expansion pass (in some cases, dramatically, specifically deriving Ord or TotalOrd on enums with many variants).   However, this shouldn't be too concerning, since in a more realistic case (compiling `core.rc`) the time increased by 0.01s, which isn't worth mentioning. And, it possibly slows type checking very slightly (about 2% worst case), but I'm having trouble measuring it (and I don't understand why this would happen). I think this could be resolved by using traits and encoding it all in the type system so that monomorphisation handles everything, but that would probably be a little tricky to arrange nicely, reduce flexibility and make compiling rustc take longer. (Maybe some judicious use of `#[inline(always)]` would help too; I'll have a bit of a play with it.)\r\n- The abstraction is not currently powerful enough for:\r\n  - `IterBytes`: doesn't support arguments of type other than `&Self`.\r\n  - `Encodable`/`Decodable` (#5090): doesn't support traits with parameters.\r\n  - `Rand` & `FromStr`; doesn't support static functions and arguments of type other than `&Self`.\r\n   - `ToStr`: I don't think it supports returning `~str` yet, but I haven't actually tried.\r\n\r\n  (The last 3 are traits that might be nice to have: the derived `ToStr`/`FromStr` could just read/write the same format as `fmt!(\"%?\", x)`, like `Show` and `Read` in Haskell.)\r\n \r\n  I have ideas to resolve all of these, but I feel like it would essentially be a simpler version of the `mt` & `ty_` parts of `ast.rs`, and I'm not sure if the simplification is worth having 2 copies of similar code.\r\n\r\nAlso, makes Ord, TotalOrd and TotalEq derivable (closes #4269, #5588 and #5589), although a snapshot is required before they can be used in the rust repo.\r\n\r\nIf there is anything that is unclear (or incorrect) either here or in the code, I'd like to get it pointed out now, so I can explain/fix it while I'm still intimately familiar with the code.", "tree": {"sha": "654986de9ce5341784942e77f225dd9983bd6d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/654986de9ce5341784942e77f225dd9983bd6d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cb69748563f7b9ab94160943eea6ec787b27a4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb69748563f7b9ab94160943eea6ec787b27a4d", "html_url": "https://github.com/rust-lang/rust/commit/2cb69748563f7b9ab94160943eea6ec787b27a4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cb69748563f7b9ab94160943eea6ec787b27a4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b74efaa7b584428a00812697d66a4449884e3e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b74efaa7b584428a00812697d66a4449884e3e1", "html_url": "https://github.com/rust-lang/rust/commit/8b74efaa7b584428a00812697d66a4449884e3e1"}, {"sha": "5c376e53d0febb493bcb7de21564d6f60a6da514", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c376e53d0febb493bcb7de21564d6f60a6da514", "html_url": "https://github.com/rust-lang/rust/commit/5c376e53d0febb493bcb7de21564d6f60a6da514"}], "stats": {"total": 2399, "additions": 1608, "deletions": 791}, "files": [{"sha": "2c2b7f40f318f3913fb114804422238b0d6fef4d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -116,6 +116,19 @@ totalord_impl!(i64)\n totalord_impl!(int)\n totalord_impl!(uint)\n \n+/**\n+Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n+lexical ordering on a type `(int, int)`.\n+*/\n+// used in deriving code in libsyntax\n+#[inline(always)]\n+pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n+    match o1 {\n+        Equal => o2,\n+        _ => o1\n+    }\n+}\n+\n /**\n * Trait for values that can be compared for a sort-order.\n *\n@@ -184,6 +197,8 @@ pub fn max<T:Ord>(v1: T, v2: T) -> T {\n \n #[cfg(test)]\n mod test {\n+    use super::lexical_ordering;\n+\n     #[test]\n     fn test_int_totalord() {\n         assert_eq!(5.cmp(&10), Less);\n@@ -204,4 +219,16 @@ mod test {\n         assert!(Less < Equal);\n         assert_eq!(Greater.cmp(&Less), Greater);\n     }\n+\n+    #[test]\n+    fn test_lexical_ordering() {\n+        fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n+            assert_eq!(lexical_ordering(o1, o2), e);\n+        }\n+        for [Less, Equal, Greater].each |&o| {\n+            t(Less, o, Less);\n+            t(Equal, o, o);\n+            t(Greater, o, Greater);\n+         }\n+    }\n }"}, {"sha": "d996bca60a367aac4cafb1204d9e7f92cd45c374", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 65, "deletions": 257, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -8,29 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::prelude::*;\n-\n-use ast;\n-use ast::*;\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n+use ext::deriving::generic::*;\n+use core::option::{None,Some};\n \n-use core::uint;\n \n pub fn expand_deriving_clone(cx: @ext_ctxt,\n                              span: span,\n-                             _: @meta_item,\n+                             mitem: @meta_item,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_clone_struct_def,\n-                    expand_deriving_clone_enum_def)\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"clone\", ~\"Clone\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"clone\",\n+                nargs: 0,\n+                output_type: None, // return Self\n+                const_nonmatching: false,\n+                combine_substructure: cs_clone\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span,\n+                            mitem, in_items,\n+                            &trait_def)\n }\n \n pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n@@ -42,251 +49,52 @@ pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n     in_items\n }\n \n-fn create_derived_clone_impl(cx: @ext_ctxt,\n-                             span: span,\n-                             type_ident: ident,\n-                             generics: &Generics,\n-                             method: @method)\n-                          -> @item {\n-    let methods = [ method ];\n-    let trait_path = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"clone\"),\n-        cx.ident_of(~\"Clone\"),\n-    ];\n-    let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n-}\n-// Creates a method from the given expression conforming to the signature of\n-// the `clone` method.\n-fn create_clone_method(cx: @ext_ctxt,\n-                       span: span,\n-                       +type_ident: ast::ident,\n-                       generics: &Generics,\n-                       expr: @ast::expr)\n-                    -> @method {\n-    // Create the type parameters of the return value.\n-    let mut output_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n-        output_ty_params.push(path);\n-    }\n-\n-    // Create the type of the return value.\n-    let output_type_path = build::mk_raw_path_(span,\n-                                               ~[ type_ident ],\n-                                               output_ty_params);\n-    let output_type = ast::ty_path(output_type_path, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n-\n-    // Create the self type and method identifier.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"clone\");\n-\n-    // Create the method.\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public,\n+fn cs_clone(cx: @ext_ctxt, span: span,\n+            substr: &Substructure) -> @expr {\n+    let clone_ident = substr.method_ident;\n+    let ctor_ident;\n+    let all_fields;\n+    let subcall = |field|\n+        build::mk_method_call(cx, span, field, clone_ident, ~[]);\n+\n+    match *substr.fields {\n+        Struct(af) => {\n+            ctor_ident = ~[ substr.type_ident ];\n+            all_fields = af;\n+        }\n+        EnumMatching(_, variant, af) => {\n+            ctor_ident = ~[ variant.node.name ];\n+            all_fields = af;\n+        },\n+        EnumNonMatching(*) => cx.bug(\"Non-matching enum variants in `deriving(Clone)`\")\n     }\n-}\n-\n-fn call_substructure_clone_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  self_field: @expr)\n-                               -> @expr {\n-    // Call the substructure method.\n-    let clone_ident = cx.ident_of(~\"clone\");\n-    build::mk_method_call(cx, span,\n-                          self_field, clone_ident,\n-                          ~[])\n-}\n-\n-fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-                                 -> @item {\n-    // Create the method.\n-    let method = if !is_struct_tuple(struct_def) {\n-        expand_deriving_clone_struct_method(cx,\n-                                            span,\n-                                            struct_def,\n-                                            type_ident,\n-                                            generics)\n-    } else {\n-        expand_deriving_clone_tuple_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  type_ident,\n-                                                  generics)\n-    };\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  type_ident: ident,\n-                                  generics: &Generics)\n-                               -> @item {\n-    // Create the method.\n-    let method = expand_deriving_clone_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   type_ident,\n-                                                   generics);\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       struct_def: &struct_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the new fields.\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n \n-                // Call the substructure method.\n-                let call = call_substructure_clone_method(cx,\n-                                                          span,\n-                                                          self_field);\n-\n-                let field = build::Field { ident: ident, ex: call };\n-                fields.push(field);\n-            }\n-            unnamed_field => {\n-                cx.span_bug(span, ~\"unnamed fields in `deriving(Clone)`\");\n+    match all_fields {\n+        [(None, _, _), .. _] => {\n+            // enum-like\n+            let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n+            build::mk_call(cx, span, ctor_ident, subcalls)\n+        },\n+        _ => {\n+            // struct-like\n+            let fields = do all_fields.map |&(o_id, self_f, _)| {\n+                let ident = match o_id {\n+                    Some(i) => i,\n+                    None => cx.span_bug(span,\n+                                        ~\"unnamed field in normal struct \\\n+                                          in `deriving(Clone)`\")\n+                };\n+                build::Field { ident: ident, ex: subcall(self_f) }\n+            };\n+\n+            if fields.is_empty() {\n+                // no fields, so construct like `None`\n+                build::mk_path(cx, span, ctor_ident)\n+            } else {\n+                build::mk_struct_e(cx, span,\n+                                   ctor_ident,\n+                                   fields)\n             }\n         }\n     }\n-\n-    // Create the struct literal.\n-    let struct_literal = build::mk_struct_e(cx,\n-                                            span,\n-                                            ~[ type_ident ],\n-                                            fields);\n-    create_clone_method(cx, span, type_ident, generics, struct_literal)\n-}\n-\n-fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n-                                             span: span,\n-                                             struct_def: &struct_def,\n-                                             type_ident: ident,\n-                                             generics: &Generics)\n-                                          -> @method {\n-    // Create the pattern for the match.\n-    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n-    let field_count = struct_def.fields.len();\n-    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n-    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n-\n-    // Create the new fields.\n-    let mut subcalls = ~[];\n-    for uint::range(0, struct_def.fields.len()) |i| {\n-        // Create the expression for this field.\n-        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-        let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-        // Call the substructure method.\n-        let subcall = call_substructure_clone_method(cx, span, field);\n-        subcalls.push(subcall);\n-    }\n-\n-    // Create the call to the struct constructor.\n-    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n-\n-    // Create the pattern body.\n-    let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-    // Create the arm.\n-    let arm = ast::arm {\n-        pats: ~[ pat ],\n-        guard: None,\n-        body: match_body_block\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n-                                     span: span,\n-                                     enum_definition: &enum_def,\n-                                     type_ident: ident,\n-                                     generics: &Generics)\n-                                  -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.map |variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Iterate over the variant arguments, creating the subcalls.\n-        let mut subcalls = ~[];\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let subcall = call_substructure_clone_method(cx, span, field);\n-            subcalls.push(subcall);\n-        }\n-\n-        // Create the call to the enum variant (if necessary).\n-        let call = if subcalls.len() > 0 {\n-            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n-        } else {\n-            build::mk_path(cx, span, ~[ variant.node.name ])\n-        };\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-        // Create the arm.\n-        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n }"}, {"sha": "c0060cc67dc3364deb553dcc43be4cbb3185ae27", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+use core::option::Some;\n+\n+pub fn expand_deriving_eq(cx: @ext_ctxt,\n+                          span: span,\n+                          mitem: @meta_item,\n+                          in_items: ~[@item]) -> ~[@item] {\n+    // structures are equal if all fields are equal, and non equal, if\n+    // any fields are not equal or if the enum variants are different\n+    fn cs_eq(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+                                 cx, span, substr)\n+    }\n+    fn cs_ne(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_or(|cx, span, _| build::mk_bool(cx, span, true),\n+              cx, span, substr)\n+    }\n+    macro_rules! md (\n+        ($name:expr, $f:ident) => {\n+            MethodDef {\n+                name: $name,\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                const_nonmatching: true,\n+                combine_substructure: $f\n+            },\n+        }\n+    )\n+\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"Eq\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            md!(~\"eq\", cs_eq),\n+            md!(~\"ne\", cs_ne)\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n+                                span: span,\n+                                _mitem: @meta_item,\n+                                in_items: ~[@item]) -> ~[@item] {\n+    cx.span_err(span, ~\"`#[deriving_eq]` is obsolete; use `#[deriving(Eq)]` instead\");\n+    in_items\n+}"}, {"sha": "398e27eb3e3857a5262fe25228db74c593319022", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr_if, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+use core::option::Some;\n+\n+macro_rules! md {\n+    ($name:expr, $less:expr, $equal:expr) => {\n+        MethodDef {\n+            name: $name,\n+            output_type: Some(~[~\"bool\"]),\n+            nargs: 1,\n+            const_nonmatching: false,\n+            combine_substructure: |cx, span, substr|\n+                    cs_ord($less, $equal, cx, span, substr)\n+        }\n+    }\n+}\n+\n+pub fn expand_deriving_ord(cx: @ext_ctxt,\n+                           span: span,\n+                           mitem: @meta_item,\n+                           in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"Ord\"],\n+        // XXX: Ord doesn't imply Eq yet\n+        additional_bounds: ~[~[~\"core\", ~\"cmp\", ~\"Eq\"]],\n+        methods: ~[\n+            md!(~\"lt\", true,  false),\n+            md!(~\"le\", true,  true),\n+            md!(~\"gt\", false, false),\n+            md!(~\"ge\", false, true)\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+/// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n+fn cs_ord(less: bool, equal: bool,\n+          cx: @ext_ctxt, span: span,\n+          substr: &Substructure) -> @expr {\n+    let binop = if less {\n+        cx.ident_of(~\"lt\")\n+    } else {\n+        cx.ident_of(~\"gt\")\n+    };\n+    let false_blk_expr = build::mk_block(cx, span,\n+                                         ~[], ~[],\n+                                         Some(build::mk_bool(cx, span, false)));\n+    let true_blk = build::mk_simple_block(cx, span,\n+                                          build::mk_bool(cx, span, true));\n+    let base = build::mk_bool(cx, span, equal);\n+\n+    cs_fold(\n+        false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            /*\n+\n+            build up a series of nested ifs from the inside out to get\n+            lexical ordering (hence foldr), i.e.\n+\n+            ```\n+            if self.f1 `binop` other.f1 {\n+                true\n+            } else if self.f1 == other.f1 {\n+                if self.f2 `binop` other.f2 {\n+                    true\n+                } else if self.f2 == other.f2 {\n+                    `equal`\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+            ```\n+\n+            The inner \"`equal`\" case is only reached if the two\n+            items have all fields equal.\n+            */\n+            if other_fs.len() != 1 {\n+                cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n+            }\n+\n+            let cmp = build::mk_method_call(cx, span,\n+                                            self_f, cx.ident_of(~\"eq\"), other_fs);\n+            let subexpr = build::mk_simple_block(cx, span, subexpr);\n+            let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n+            let elseif = build::mk_expr(cx, span, elseif);\n+\n+            let cmp = build::mk_method_call(cx, span,\n+                                            self_f, binop, other_fs);\n+            let if_ = expr_if(cmp, true_blk, Some(elseif));\n+\n+            build::mk_expr(cx, span, if_)\n+        },\n+        base,\n+        |cx, span, args| {\n+            // nonmatching enums, order by the order the variants are\n+            // written\n+            match args {\n+                [(self_var, _, _),\n+                 (other_var, _, _)] =>\n+                    build::mk_bool(cx, span,\n+                                   if less {\n+                                       self_var < other_var\n+                                   } else {\n+                                       self_var > other_var\n+                                   }),\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n+            }\n+        },\n+        cx, span, substr)\n+}"}, {"sha": "fc8ec103a6021b7c4272e34ab01039cc18b8f34a", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+use core::option::Some;\n+\n+pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n+                          span: span,\n+                          mitem: @meta_item,\n+                          in_items: ~[@item]) -> ~[@item] {\n+\n+    fn cs_equals(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+        cs_and(|cx, span, _| build::mk_bool(cx, span, false),\n+               cx, span, substr)\n+    }\n+\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"TotalEq\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"equals\",\n+                output_type: Some(~[~\"bool\"]),\n+                nargs: 1,\n+                const_nonmatching: true,\n+                combine_substructure: cs_equals\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}"}, {"sha": "a098a7463d3e75bdbca81e1e86a9c957924c3c61", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+use core::cmp::{Ordering, Equal, Less, Greater};\n+use core::option::Some;\n+\n+pub fn expand_deriving_totalord(cx: @ext_ctxt,\n+                                span: span,\n+                                mitem: @meta_item,\n+                                in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: ~[~\"core\", ~\"cmp\", ~\"TotalOrd\"],\n+        additional_bounds: ~[],\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"cmp\",\n+                output_type: Some(~[~\"core\", ~\"cmp\", ~\"Ordering\"]),\n+                nargs: 1,\n+                const_nonmatching: false,\n+                combine_substructure: cs_cmp\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n+}\n+\n+\n+pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n+    let cnst = match cnst {\n+        Less => ~\"Less\",\n+        Equal => ~\"Equal\",\n+        Greater => ~\"Greater\"\n+    };\n+    build::mk_path_global(cx, span,\n+                          ~[cx.ident_of(~\"core\"),\n+                            cx.ident_of(~\"cmp\"),\n+                            cx.ident_of(cnst)])\n+}\n+\n+pub fn cs_cmp(cx: @ext_ctxt, span: span,\n+              substr: &Substructure) -> @expr {\n+    let lexical_ord = ~[cx.ident_of(~\"core\"),\n+                        cx.ident_of(~\"cmp\"),\n+                        cx.ident_of(~\"lexical_ordering\")];\n+\n+    cs_same_method_fold(\n+        // foldr (possibly) nests the matches in lexical_ordering better\n+        false,\n+        |cx, span, old, new| {\n+            build::mk_call_global(cx, span, lexical_ord, ~[old, new])\n+        },\n+        ordering_const(cx, span, Equal),\n+        |cx, span, list| {\n+            match list {\n+                // an earlier nonmatching variant is Less than a\n+                // later one\n+                [(self_var, _, _),\n+                 (other_var, _, _)] => ordering_const(cx, span,\n+                                                      self_var.cmp(&other_var)),\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(TotalOrd)`\")\n+            }\n+        },\n+        cx, span, substr)\n+}"}, {"sha": "df3536a3caef7a99bfa43b311bdb887d14b24267", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -81,7 +81,8 @@ fn create_derived_decodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params\n+        generic_ty_params,\n+        opt_vec::Empty\n     )\n }\n "}, {"sha": "9776f484818ccb47bcf2d1653459402b85b378c8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -81,7 +81,8 @@ fn create_derived_encodable_impl(\n         generics,\n         methods,\n         trait_path,\n-        generic_ty_params\n+        generic_ty_params,\n+        opt_vec::Empty\n     )\n }\n \n@@ -306,7 +307,7 @@ fn expand_deriving_encodable_enum_method(\n         let variant_arg_len = variant_arg_count(cx, span, variant);\n         for uint::range(0, variant_arg_len) |j| {\n             // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n             let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n             // Call the substructure method."}, {"sha": "c427a206c2e329d76348e66d84e3aa274b820255", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "removed", "additions": 0, "deletions": 500, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/8b74efaa7b584428a00812697d66a4449884e3e1/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b74efaa7b584428a00812697d66a4449884e3e1/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=8b74efaa7b584428a00812697d66a4449884e3e1", "patch": "@@ -1,500 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use ast;\n-use ast::*;\n-use ext::base::ext_ctxt;\n-use ext::build;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n-\n-use core::uint;\n-\n-enum Junction {\n-    Conjunction,\n-    Disjunction,\n-}\n-\n-pub impl Junction {\n-    fn to_binop(self) -> binop {\n-        match self {\n-            Conjunction => and,\n-            Disjunction => or,\n-        }\n-    }\n-}\n-\n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n-                          span: span,\n-                          _mitem: @meta_item,\n-                          in_items: ~[@item])\n-                       -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_eq_struct_def,\n-                    expand_deriving_eq_enum_def)\n-}\n-\n-pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n-                                span: span,\n-                                _mitem: @meta_item,\n-                                in_items: ~[@item])\n-                             -> ~[@item] {\n-    cx.span_err(span, ~\"`#[deriving_eq]` is obsolete; use `#[deriving(Eq)]` instead\");\n-    in_items\n-}\n-\n-/// Creates a method from the given expression, the signature of which\n-/// conforms to the `eq` or `ne` method.\n-fn create_eq_method(cx: @ext_ctxt,\n-                    span: span,\n-                    method_ident: ident,\n-                    type_ident: ident,\n-                    generics: &Generics,\n-                    body: @expr)\n-                 -> @method {\n-    // Create the type of the `other` parameter.\n-    let arg_path_type = create_self_type_with_params(cx,\n-                                                     span,\n-                                                     type_ident,\n-                                                     generics);\n-    let arg_type = ty_rptr(\n-        None,\n-        ast::mt { ty: arg_path_type, mutbl: m_imm }\n-    );\n-    let arg_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: arg_type,\n-        span: span,\n-    };\n-\n-    // Create the `other` parameter.\n-    let other_ident = cx.ident_of(~\"__other\");\n-    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n-\n-    // Create the type of the return value.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n-    let output_type = ty_path(output_type, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span,\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, body);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn create_derived_eq_impl(cx: @ext_ctxt,\n-                          span: span,\n-                          type_ident: ident,\n-                          generics: &Generics,\n-                          eq_method: @method,\n-                          ne_method: @method)\n-                       -> @item {\n-    let methods = [ eq_method, ne_method ];\n-    let trait_path = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"cmp\"),\n-        cx.ident_of(~\"Eq\")\n-    ];\n-    let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n-}\n-\n-fn call_substructure_eq_method(cx: @ext_ctxt,\n-                               span: span,\n-                               self_field: @expr,\n-                               other_field_ref: @expr,\n-                               method_ident: ident,\n-                               junction: Junction,\n-                               chain_expr: &mut Option<@expr>) {\n-    // Call the substructure method.\n-    let self_call = build::mk_method_call(cx, span,\n-                                          self_field, method_ident,\n-                                          ~[ other_field_ref ]);\n-\n-    // Connect to the outer expression if necessary.\n-    *chain_expr = match *chain_expr {\n-        None => Some(self_call),\n-        Some(copy old_outer_expr) => {\n-            let binop = junction.to_binop();\n-            let chain_expr = build::mk_binary(cx,\n-                                              span,\n-                                              binop,\n-                                              old_outer_expr,\n-                                              self_call);\n-            Some(chain_expr)\n-        }\n-    };\n-}\n-\n-fn finish_eq_chain_expr(cx: @ext_ctxt,\n-                        span: span,\n-                        chain_expr: Option<@expr>,\n-                        junction: Junction)\n-                     -> @expr {\n-    match chain_expr {\n-        None => {\n-            match junction {\n-                Conjunction => build::mk_bool(cx, span, true),\n-                Disjunction => build::mk_bool(cx, span, false),\n-            }\n-        }\n-        Some(ref outer_expr) => *outer_expr,\n-    }\n-}\n-\n-fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n-                                 span: span,\n-                                 struct_def: &struct_def,\n-                                 type_ident: ident,\n-                                 generics: &Generics)\n-                              -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-\n-    let derive_struct_fn = if is_struct_tuple(struct_def) {\n-        expand_deriving_eq_struct_tuple_method\n-    } else {\n-        expand_deriving_eq_struct_method\n-    };\n-\n-    let eq_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     eq_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Conjunction);\n-    let ne_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     ne_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               type_ident: ident,\n-                               generics: &Generics)\n-                            -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   eq_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Conjunction);\n-    let ne_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   ne_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    method_ident: ident,\n-                                    type_ident: ident,\n-                                    generics: &Generics,\n-                                    junction: Junction)\n-                                 -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    // Create the body of the method.\n-    let mut outer_expr = None;\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for the other field.\n-                let other_field = build::mk_access(cx,\n-                                                   span,\n-                                                   ~[ other_ident ],\n-                                                   ident);\n-                let other_field_ref = build::mk_addr_of(cx,\n-                                                        span,\n-                                                        other_field);\n-\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                call_substructure_eq_method(cx,\n-                                            span,\n-                                            self_field,\n-                                            other_field_ref,\n-                                            method_ident,\n-                                            junction,\n-                                            &mut outer_expr);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span, ~\"unnamed fields with `deriving(Eq)`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            body);\n-}\n-\n-fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  method_ident: ident,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  junction: Junction)\n-                               -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    let is_eq;\n-    match junction {\n-        Conjunction => is_eq = true,\n-        Disjunction => is_eq = false,\n-    }\n-\n-    // Create the arms of the self match in the method body.\n-    let mut self_arms = ~[];\n-    for enum_definition.variants.each |self_variant| {\n-        let mut other_arms = ~[];\n-\n-        // Create the matching pattern.\n-        let matching_pat = create_enum_variant_pattern(cx,\n-                                                       span,\n-                                                       self_variant,\n-                                                       ~\"__other\");\n-\n-        // Create the matching pattern body.\n-        let mut matching_body_expr = None;\n-        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n-            // Create the expression for the other field.\n-            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n-            let other_field = build::mk_path(cx,\n-                                             span,\n-                                             ~[ other_field_ident ]);\n-\n-            // Create the expression for this field.\n-            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-            // Call the substructure method.\n-            call_substructure_eq_method(cx,\n-                                        span,\n-                                        self_field,\n-                                        other_field,\n-                                        method_ident,\n-                                        junction,\n-                                        &mut matching_body_expr);\n-        }\n-\n-        let matching_body_expr = finish_eq_chain_expr(cx,\n-                                                      span,\n-                                                      matching_body_expr,\n-                                                      junction);\n-        let matching_body_block = build::mk_simple_block(cx,\n-                                                         span,\n-                                                         matching_body_expr);\n-\n-        // Create the matching arm.\n-        let matching_arm = ast::arm {\n-            pats: ~[ matching_pat ],\n-            guard: None,\n-            body: matching_body_block\n-        };\n-        other_arms.push(matching_arm);\n-\n-        // Maybe generate a non-matching case. If there is only one\n-        // variant then there will always be a match.\n-        if enum_definition.variants.len() > 1 {\n-            // Create the nonmatching pattern.\n-            let nonmatching_pat = @ast::pat {\n-                id: cx.next_id(),\n-                node: pat_wild,\n-                span: span\n-            };\n-\n-            // Create the nonmatching pattern body.\n-            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n-            let nonmatching_body_block =\n-                build::mk_simple_block(cx,\n-                                       span,\n-                                       nonmatching_expr);\n-\n-            // Create the nonmatching arm.\n-            let nonmatching_arm = ast::arm {\n-                pats: ~[ nonmatching_pat ],\n-                guard: None,\n-                body: nonmatching_body_block,\n-            };\n-            other_arms.push(nonmatching_arm);\n-        }\n-\n-        // Create the self pattern.\n-        let self_pat = create_enum_variant_pattern(cx,\n-                                                   span,\n-                                                   self_variant,\n-                                                   ~\"__self\");\n-\n-        // Create the self pattern body.\n-        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n-        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_match_expr = expr_match(other_expr, other_arms);\n-        let other_match_expr = build::mk_expr(cx,\n-                                              span,\n-                                              other_match_expr);\n-        let other_match_body_block = build::mk_simple_block(cx,\n-                                                            span,\n-                                                            other_match_expr);\n-\n-        // Create the self arm.\n-        let self_arm = ast::arm {\n-            pats: ~[ self_pat ],\n-            guard: None,\n-            body: other_match_body_block,\n-        };\n-        self_arms.push(self_arm);\n-    }\n-\n-    // Create the method body.\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            self_match_expr);\n-}\n-\n-fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          struct_def: &struct_def,\n-                                          method_ident: ident,\n-                                          type_ident: ident,\n-                                          generics: &Generics,\n-                                          junction: Junction)\n-                                        -> @method {\n-    let self_str = ~\"self\";\n-    let other_str = ~\"__other\";\n-    let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = copy struct_def.fields;\n-\n-    // Create comparison expression, comparing each of the fields\n-    let mut match_body = None;\n-    for fields.eachi |i, _| {\n-        let other_field_ident = cx.ident_of(other_str + i.to_str());\n-        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n-\n-        let self_field_ident = cx.ident_of(self_str + i.to_str());\n-        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-        call_substructure_eq_method(cx, span, self_field, other_field,\n-            method_ident, junction, &mut match_body);\n-    }\n-    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n-\n-    // Create arm for the '__other' match, containing the comparison expr\n-    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n-    let other_arm = ast::arm {\n-        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, match_body),\n-    };\n-\n-    // Create the match on '__other'\n-    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n-    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n-    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n-\n-    // Create arm for the 'self' match, which contains the '__other' match\n-    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n-    let self_arm = ast::arm {\n-        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, other_match_expr),\n-    };\n-\n-    // Create the match on 'self'\n-    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    create_eq_method(cx, span, method_ident,\n-        type_ident, generics, self_match_expr)\n-}"}, {"sha": "dfbb98fa23388394884a3af0959fb2dd00d48d35", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "added", "additions": 906, "deletions": 0, "changes": 906, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,906 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Some code that abstracts away much of the boilerplate of writing\n+`deriving` instances for traits. Among other things it manages getting\n+access to the fields of the 4 different sorts of structs and enum\n+variants, as well as creating the method and impl ast instances.\n+\n+Supported features (fairly exhaustive):\n+- Methods taking any number of parameters of type `&Self`, including\n+  none other than `self`. (`MethodDef.nargs`)\n+- Methods returning `Self` or a non-parameterised type\n+  (e.g. `bool` or `core::cmp::Ordering`). (`MethodDef.output_type`)\n+- Generating `impl`s for types with type parameters\n+  (e.g. `Option<T>`), the parameters are automatically given the\n+  current trait as a bound.\n+- Additional bounds on the type parameters, e.g. the `Ord` instance\n+  requires an explicit `Eq` bound at the\n+  moment. (`TraitDef.additional_bounds`)\n+\n+(Key unsupported things: methods with arguments of non-`&Self` type,\n+traits with parameters, methods returning parameterised types, static\n+methods.)\n+\n+The most important thing for implementers is the `Substructure` and\n+`SubstructureFields` objects. The latter groups 3 possibilities of the\n+arguments:\n+\n+- `Struct`, when `Self` is a struct (including tuple structs, e.g\n+  `struct T(int, char)`).\n+- `EnumMatching`, when `Self` is an enum and all the arguments are the\n+  same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n+- `EnumNonMatching` when `Self` is an enum and the arguments are not\n+  the same variant (e.g. `None`, `Some(1)` and `None`). If\n+  `const_nonmatching` is true, this will contain an empty list.\n+\n+In the first two cases, the values from the corresponding fields in\n+all the arguments are grouped together. In the `EnumNonMatching` case\n+this isn't possible (different variants have different fields), so the\n+fields are grouped by which argument they come from.\n+\n+All of the cases have `Option<ident>` in several places associated\n+with field `expr`s. This represents the name of the field it is\n+associated with. It is only not `None` when the associated field has\n+an identifier in the source code. For example, the `x`s in the\n+following snippet\n+\n+    struct A { x : int }\n+\n+    struct B(int);\n+\n+    enum C {\n+        C0(int),\n+        C1 { x: int }\n+    }\n+\n+The `int`s in `B` and `C0` don't have an identifier, so the\n+`Option<ident>`s would be `None` for them.\n+\n+# Examples\n+\n+The following simplified `Eq` is used for in-code examples:\n+\n+    trait Eq {\n+        fn eq(&self, other: &Self);\n+    }\n+    impl Eq for int {\n+        fn eq(&self, other: &int) -> bool {\n+            *self == *other\n+        }\n+    }\n+\n+Some examples of the values of `SubstructureFields` follow, using the\n+above `Eq`, `A`, `B` and `C`.\n+\n+## Structs\n+\n+When generating the `expr` for the `A` impl, the `SubstructureFields` is\n+\n+    Struct(~[(Some(<ident of x>),\n+             <expr for self.x>,\n+             ~[<expr for other.x])])\n+\n+For the `B` impl, called with `B(a)` and `B(b)`,\n+\n+    Struct(~[(None,\n+              <expr for a>\n+              ~[<expr for b>])])\n+\n+## Enums\n+\n+When generating the `expr` for a call with `self == C0(a)` and `other\n+== C0(b)`, the SubstructureFields is\n+\n+    EnumMatching(0, <ast::variant for C0>,\n+                 ~[None,\n+                   <expr for a>,\n+                   ~[<expr for b>]])\n+\n+For `C1 {x}` and `C1 {x}`,\n+\n+    EnumMatching(1, <ast::variant for C1>,\n+                 ~[Some(<ident of x>),\n+                   <expr for self.x>,\n+                   ~[<expr for other.x>]])\n+\n+For `C0(a)` and `C1 {x}` ,\n+\n+    EnumNonMatching(~[(0, <ast::variant for B0>,\n+                       ~[(None, <expr for a>)]),\n+                      (1, <ast::variant for B1>,\n+                       ~[(Some(<ident of x>),\n+                          <expr for other.x>)])])\n+\n+(and vice verse, but with the order of the outermost list flipped.)\n+\n+*/\n+\n+use core::prelude::*;\n+\n+use ast;\n+\n+use ast::{\n+    and, binop, deref, enum_def, expr, expr_match, ident, impure_fn,\n+    item, Generics, m_imm, meta_item, method, named_field, or,\n+    pat_wild, public, struct_def, sty_region, ty_rptr, ty_path,\n+    variant};\n+\n+use ast_util;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span,respan};\n+use opt_vec;\n+\n+pub fn expand_deriving_generic(cx: @ext_ctxt,\n+                               span: span,\n+                               _mitem: @meta_item,\n+                               in_items: ~[@item],\n+                               trait_def: &TraitDef) -> ~[@item] {\n+    let expand_enum: ExpandDerivingEnumDefFn =\n+        |cx, span, enum_def, type_ident, generics| {\n+        trait_def.expand_enum_def(cx, span, enum_def, type_ident, generics)\n+    };\n+    let expand_struct: ExpandDerivingStructDefFn =\n+        |cx, span, struct_def, type_ident, generics| {\n+        trait_def.expand_struct_def(cx, span, struct_def, type_ident, generics)\n+    };\n+\n+    expand_deriving(cx, span, in_items,\n+                    expand_struct,\n+                    expand_enum)\n+}\n+\n+pub struct TraitDef<'self> {\n+    /// Path of the trait\n+    path: ~[~str],\n+    /// Additional bounds required of any type parameters, other than\n+    /// the current trait\n+    additional_bounds: ~[~[~str]],\n+    methods: ~[MethodDef<'self>]\n+}\n+\n+pub struct MethodDef<'self> {\n+    /// name of the method\n+    name: ~str,\n+    /// The path of return type of the method, e.g. `~[~\"core\",\n+    /// ~\"cmp\", ~\"Eq\"]`. `None` for `Self`.\n+    output_type: Option<~[~str]>,\n+    /// Number of arguments other than `self` (all of type `&Self`)\n+    nargs: uint,\n+\n+    /// if the value of the nonmatching enums is independent of the\n+    /// actual enums, i.e. can use _ => .. match.\n+    const_nonmatching: bool,\n+\n+    combine_substructure: CombineSubstructureFunc<'self>\n+}\n+\n+/// All the data about the data structure/method being derived upon.\n+pub struct Substructure<'self> {\n+    type_ident: ident,\n+    method_ident: ident,\n+    fields: &'self SubstructureFields\n+}\n+\n+/// A summary of the possible sets of fields. See above for details\n+/// and examples\n+pub enum SubstructureFields {\n+    /**\n+    Vec of `(field ident, self, [others])` where the field ident is\n+    the ident of the current field (`None` for all fields in tuple\n+    structs)\n+    */\n+    Struct(~[(Option<ident>, @expr, ~[@expr])]),\n+\n+    /**\n+    Matching variants of the enum: variant index, ast::variant,\n+    fields: `(field ident, self, [others])`, where the field ident is\n+    only non-`None` in the case of a struct variant.\n+    */\n+    EnumMatching(uint, variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+\n+    /**\n+    non-matching variants of the enum, [(variant index, ast::variant,\n+    [field ident, fields])] (i.e. all fields for self are in the\n+    first tuple, for other1 are in the second tuple, etc.)\n+    */\n+    EnumNonMatching(~[(uint, variant, ~[(Option<ident>, @expr)])])\n+}\n+\n+\n+/**\n+Combine the values of all the fields together. The last argument is\n+all the fields of all the structures, see above for details.\n+*/\n+pub type CombineSubstructureFunc<'self> =\n+    &'self fn(@ext_ctxt, span, &Substructure) -> @expr;\n+\n+/**\n+Deal with non-matching enum variants, the argument is a list\n+representing each variant: (variant index, ast::variant instance,\n+[variant fields])\n+*/\n+pub type EnumNonMatchFunc<'self> =\n+    &'self fn(@ext_ctxt, span, ~[(uint, variant, ~[(Option<ident>, @expr)])]) -> @expr;\n+\n+\n+\n+impl<'self> TraitDef<'self> {\n+    fn create_derived_impl(&self, cx: @ext_ctxt, span: span,\n+                           type_ident: ident, generics: &Generics,\n+                           methods: ~[@method]) -> @item {\n+        let trait_path = build::mk_raw_path_global(\n+            span,\n+            do self.path.map |&s| { cx.ident_of(s) });\n+\n+        let additional_bounds = opt_vec::from(\n+            do self.additional_bounds.map |v| {\n+                do v.map |&s| { cx.ident_of(s) }\n+            });\n+        create_derived_impl(cx, span,\n+                            type_ident, generics,\n+                            methods, trait_path,\n+                            opt_vec::Empty,\n+                            additional_bounds)\n+    }\n+\n+    fn expand_struct_def(&self, cx: @ext_ctxt,\n+                         span: span,\n+                         struct_def: &struct_def,\n+                         type_ident: ident,\n+                         generics: &Generics)\n+    -> @item {\n+        let is_tuple = is_struct_tuple(struct_def);\n+\n+        let methods = do self.methods.map |method_def| {\n+            let body = if is_tuple {\n+                method_def.expand_struct_tuple_method_body(cx, span,\n+                                                           struct_def,\n+                                                           type_ident)\n+            } else {\n+                method_def.expand_struct_method_body(cx, span,\n+                                                     struct_def,\n+                                                     type_ident)\n+            };\n+\n+            method_def.create_method(cx, span, type_ident, generics, body)\n+        };\n+\n+        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+    }\n+\n+    fn expand_enum_def(&self,\n+                       cx: @ext_ctxt, span: span,\n+                       enum_def: &enum_def,\n+                       type_ident: ident,\n+                       generics: &Generics) -> @item {\n+        let methods = do self.methods.map |method_def| {\n+            let body = method_def.expand_enum_method_body(cx, span,\n+                                                          enum_def,\n+                                                          type_ident);\n+\n+            method_def.create_method(cx, span, type_ident, generics, body)\n+        };\n+\n+        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+    }\n+}\n+\n+impl<'self> MethodDef<'self> {\n+    fn call_substructure_method(&self,\n+                                cx: @ext_ctxt,\n+                                span: span,\n+                                type_ident: ident,\n+                                fields: &SubstructureFields)\n+        -> @expr {\n+        let substructure = Substructure {\n+            type_ident: type_ident,\n+            method_ident: cx.ident_of(self.name),\n+            fields: fields\n+        };\n+        (self.combine_substructure)(cx, span,\n+                                    &substructure)\n+    }\n+\n+    fn get_output_type_path(&self, cx: @ext_ctxt, span: span,\n+                              generics: &Generics, type_ident: ident) -> @ast::Path {\n+        match self.output_type {\n+            None => { // Self, add any type parameters\n+                let out_ty_params = do vec::build |push| {\n+                    for generics.ty_params.each |ty_param| {\n+                        push(build::mk_ty_path(cx, span, ~[ ty_param.ident ]));\n+                    }\n+                };\n+\n+                build::mk_raw_path_(span, ~[ type_ident ], out_ty_params)\n+            }\n+            Some(str_path) => {\n+                let p = do str_path.map |&s| { cx.ident_of(s) };\n+                build::mk_raw_path_global(span, p)\n+            }\n+        }\n+    }\n+\n+    fn create_method(&self, cx: @ext_ctxt, span: span,\n+                     type_ident: ident,\n+                     generics: &Generics, body: @expr) -> @method {\n+        // Create the `Self` type of the `other` parameters.\n+        let arg_path_type = create_self_type_with_params(cx,\n+                                                         span,\n+                                                         type_ident,\n+                                                         generics);\n+        let arg_type = ty_rptr(\n+            None,\n+            ast::mt { ty: arg_path_type, mutbl: m_imm }\n+        );\n+        let arg_type = @ast::Ty {\n+            id: cx.next_id(),\n+            node: arg_type,\n+            span: span,\n+        };\n+\n+        // create the arguments\n+        let other_idents = create_other_idents(cx, self.nargs);\n+        let args = do other_idents.map |&id| {\n+            build::mk_arg(cx, span, id, arg_type)\n+        };\n+\n+        let output_type = self.get_output_type_path(cx, span, generics, type_ident);\n+        let output_type = ty_path(output_type, cx.next_id());\n+        let output_type = @ast::Ty {\n+            id: cx.next_id(),\n+            node: output_type,\n+            span: span,\n+        };\n+\n+        let method_ident = cx.ident_of(self.name);\n+        let fn_decl = build::mk_fn_decl(args, output_type);\n+        let body_block = build::mk_simple_block(cx, span, body);\n+\n+        // Create the method.\n+        let self_ty = respan(span, sty_region(None, m_imm));\n+        @ast::method {\n+            ident: method_ident,\n+            attrs: ~[],\n+            generics: ast_util::empty_generics(),\n+            self_ty: self_ty,\n+            purity: impure_fn,\n+            decl: fn_decl,\n+            body: body_block,\n+            id: cx.next_id(),\n+            span: span,\n+            self_id: cx.next_id(),\n+            vis: public\n+        }\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    struct A(int, int);\n+\n+    // equivalent to:\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) -> bool {\n+            match *self {\n+                (ref self_1, ref self_2) => {\n+                    match *__other_1 {\n+                        (ref __other_1_1, ref __other_1_2) => {\n+                            self_1.eq(__other_1_1) && self_2.eq(__other_1_2)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_struct_tuple_method_body(&self,\n+                                           cx: @ext_ctxt,\n+                                               span: span,\n+                                               struct_def: &struct_def,\n+                                           type_ident: ident) -> @expr {\n+        let self_str = ~\"self\";\n+        let other_strs = create_other_strs(self.nargs);\n+        let num_fields = struct_def.fields.len();\n+\n+\n+        let fields = do struct_def.fields.mapi |i, _| {\n+            let other_fields = do other_strs.map |&other_str| {\n+                let other_field_ident = cx.ident_of(fmt!(\"%s_%u\", other_str, i));\n+                build::mk_path(cx, span, ~[ other_field_ident ])\n+            };\n+\n+            let self_field_ident = cx.ident_of(fmt!(\"%s_%u\", self_str, i));\n+            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+            (None, self_field, other_fields)\n+        };\n+\n+        let mut match_body = self.call_substructure_method(cx, span, type_ident, &Struct(fields));\n+\n+        let type_path = build::mk_raw_path(span, ~[type_ident]);\n+\n+        // create the matches from inside to out (i.e. other_{self.nargs} to other_1)\n+        for other_strs.each_reverse |&other_str| {\n+            match_body = create_deref_match(cx, span, type_path,\n+                                            other_str, num_fields,\n+                                            match_body)\n+        }\n+\n+        // create the match on self\n+        return create_deref_match(cx, span, type_path,\n+                                  ~\"self\", num_fields, match_body);\n+\n+        /**\n+        Creates a match expression against a tuple that needs to\n+        be dereferenced, but nothing else\n+\n+        ```\n+        match *`to_match` {\n+            (`to_match`_1, ..., `to_match`_`num_fields`) => `match_body`\n+        }\n+        ```\n+        */\n+        fn create_deref_match(cx: @ext_ctxt,\n+                              span: span,\n+                              type_path: @ast::Path,\n+                              to_match: ~str,\n+                              num_fields: uint,\n+                              match_body: @expr) -> @expr {\n+            let match_subpats = create_subpatterns(cx, span, to_match, num_fields);\n+            let match_arm = ast::arm {\n+                pats: ~[ build::mk_pat_enum(cx, span, type_path, match_subpats) ],\n+                guard: None,\n+                body: build::mk_simple_block(cx, span, match_body),\n+            };\n+\n+            let deref_expr = build::mk_unary(cx, span, deref,\n+                                             build::mk_path(cx, span,\n+                                                            ~[ cx.ident_of(to_match)]));\n+            let match_expr = build::mk_expr(cx, span, expr_match(deref_expr, ~[match_arm]));\n+\n+            match_expr\n+        }\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    struct A { x: int, y: int }\n+\n+    // equivalent to:\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) -> bool {\n+            self.x.eq(&__other_1.x) &&\n+                self.y.eq(&__other_1.y)\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_struct_method_body(&self,\n+                                     cx: @ext_ctxt,\n+                                     span: span,\n+                                     struct_def: &struct_def,\n+                                     type_ident: ident)\n+        -> @expr {\n+        let self_ident = cx.ident_of(~\"self\");\n+        let other_idents = create_other_idents(cx, self.nargs);\n+\n+        let fields = do struct_def.fields.map |struct_field| {\n+            match struct_field.node.kind {\n+                named_field(ident, _, _) => {\n+                    // Create the accessor for this field in the other args.\n+                    let other_fields = do other_idents.map |&id| {\n+                        build::mk_access(cx, span, ~[id], ident)\n+                    };\n+                    let other_field_refs = do other_fields.map |&other_field| {\n+                        build::mk_addr_of(cx, span, other_field)\n+                    };\n+\n+                    // Create the accessor for this field in self.\n+                    let self_field =\n+                        build::mk_access(\n+                            cx, span,\n+                            ~[ self_ident ],\n+                            ident);\n+\n+                    (Some(ident), self_field, other_field_refs)\n+                }\n+                unnamed_field => {\n+                    cx.span_unimpl(span, ~\"unnamed fields with `deriving_generic`\");\n+                }\n+            }\n+        };\n+\n+        self.call_substructure_method(cx, span, type_ident, &Struct(fields))\n+    }\n+\n+    /**\n+    ```\n+    #[deriving(Eq)]\n+    enum A {\n+        A1\n+        A2(int)\n+    }\n+\n+    // is equivalent to\n+\n+    impl Eq for A {\n+        fn eq(&self, __other_1: &A) {\n+            match *self {\n+                A1 => match *__other_1 {\n+                    A1 => true,\n+                    A2(ref __other_1_1) => false\n+                },\n+                A2(self_1) => match *__other_1 {\n+                    A1 => false,\n+                    A2(ref __other_1_1) => self_1.eq(__other_1_1)\n+                }\n+            }\n+        }\n+    }\n+    ```\n+    */\n+    fn expand_enum_method_body(&self,\n+                               cx: @ext_ctxt,\n+                               span: span,\n+                               enum_def: &enum_def,\n+                               type_ident: ident)\n+        -> @expr {\n+        self.build_enum_match(cx, span, enum_def, type_ident,\n+                              None, ~[], 0)\n+    }\n+\n+\n+    /**\n+    Creates the nested matches for an enum definition recursively, i.e.\n+\n+    ```\n+    match self {\n+       Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n+       Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n+       ...\n+    }\n+    ```\n+\n+    It acts in the most naive way, so every branch (and subbranch,\n+    subsubbranch, etc) exists, not just the ones where all the variants in\n+    the tree are the same. Hopefully the optimisers get rid of any\n+    repetition, otherwise derived methods with many Self arguments will be\n+    exponentially large.\n+\n+    `matching` is Some(n) if all branches in the tree above the\n+    current position are variant `n`, `None` otherwise (including on\n+    the first call).\n+    */\n+    fn build_enum_match(&self,\n+                        cx: @ext_ctxt, span: span,\n+                        enum_def: &enum_def,\n+                        type_ident: ident,\n+                        matching: Option<uint>,\n+                        matches_so_far: ~[(uint, variant,\n+                                           ~[(Option<ident>, @expr)])],\n+                        match_count: uint) -> @expr {\n+        if match_count == self.nargs + 1 {\n+            // we've matched against all arguments, so make the final\n+            // expression at the bottom of the match tree\n+            match matches_so_far {\n+                [] => cx.bug(~\"no self match on an enum in `deriving_generic`\"),\n+                _ => {\n+                    // we currently have a vec of vecs, where each\n+                    // subvec is the fields of one of the arguments,\n+                    // but if the variants all match, we want this as\n+                    // vec of tuples, where each tuple represents a\n+                    // field.\n+\n+                    let substructure;\n+\n+                    // most arms don't have matching variants, so do a\n+                    // quick check to see if they match (even though\n+                    // this means iterating twice) instead of being\n+                    // optimistic and doing a pile of allocations etc.\n+                    match matching {\n+                        Some(variant_index) => {\n+                            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+                            // let (variant_index, ref self_vec) = matches_so_far[0];\n+                            let (variant, self_vec) = match matches_so_far[0] {\n+                                (_, v, ref s) => (v, s)\n+                            };\n+\n+                            let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+\n+                            for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                                for other_fields.eachi |i, &(_, other_field)| {\n+                                    enum_matching_fields[i].push(other_field);\n+                                }\n+                            }\n+                            let field_tuples =\n+                                do vec::map2(*self_vec,\n+                                             enum_matching_fields) |&(id, self_f), &other| {\n+                                (id, self_f, other)\n+                            };\n+                            substructure = EnumMatching(variant_index, variant, field_tuples);\n+                        }\n+                        None => {\n+                            substructure = EnumNonMatching(matches_so_far);\n+                        }\n+                    }\n+                    self.call_substructure_method(cx, span, type_ident, &substructure)\n+                }\n+            }\n+\n+        } else {  // there are still matches to create\n+            let (current_match_ident, current_match_str) = if match_count == 0 {\n+                (cx.ident_of(~\"self\"), ~\"__self\")\n+            } else {\n+                let s = fmt!(\"__other_%u\", matches_so_far.len() - 1);\n+                (cx.ident_of(s), s)\n+            };\n+\n+            let mut arms = ~[];\n+\n+            // this is used as a stack\n+            let mut matches_so_far = matches_so_far;\n+\n+            macro_rules! mk_arm(\n+                ($pat:expr, $expr:expr) => {\n+                    {\n+                        let blk = build::mk_simple_block(cx, span, $expr);\n+                        let arm = ast::arm {\n+                            pats: ~[$ pat ],\n+                            guard: None,\n+                            body: blk\n+                        };\n+                        arm\n+                    }\n+                }\n+            )\n+\n+            // the code for nonmatching variants only matters when\n+            // we've seen at least one other variant already\n+            if self.const_nonmatching && match_count > 0 {\n+                // make a matching-variant match, and a _ match.\n+                let index = match matching {\n+                    Some(i) => i,\n+                    None => cx.span_bug(span, ~\"Non-matching variants when required to\\\n+                                                be matching in `deriving_generic`\")\n+                };\n+\n+                // matching-variant match\n+                let variant = &enum_def.variants[index];\n+                let pattern = create_enum_variant_pattern(cx, span,\n+                                                          variant,\n+                                                          current_match_str);\n+\n+                let idents = do vec::build |push| {\n+                    for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n+                        let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n+                        push((field_id, build::mk_path(cx, span, ~[ id ])));\n+                    }\n+                };\n+\n+                matches_so_far.push((index, *variant, idents));\n+                let arm_expr = self.build_enum_match(cx, span,\n+                                                     enum_def,\n+                                                     type_ident,\n+                                                     matching,\n+                                                     matches_so_far,\n+                                                     match_count + 1);\n+                matches_so_far.pop();\n+                let arm = mk_arm!(pattern, arm_expr);\n+                arms.push(arm);\n+\n+                if enum_def.variants.len() > 1 {\n+                    // _ match, if necessary\n+                    let wild_pat = @ast::pat {\n+                        id: cx.next_id(),\n+                        node: pat_wild,\n+                        span: span\n+                    };\n+\n+                    let wild_expr = self.call_substructure_method(cx, span, type_ident,\n+                                                                  &EnumNonMatching(~[]));\n+                    let wild_arm = mk_arm!(wild_pat, wild_expr);\n+                    arms.push(wild_arm);\n+                }\n+            } else {\n+                // create an arm matching on each variant\n+                for enum_def.variants.eachi |index, variant| {\n+                    let pattern = create_enum_variant_pattern(cx, span,\n+                                                              variant,\n+                                                              current_match_str);\n+\n+                    let idents = do vec::build |push| {\n+                        for each_variant_arg_ident(cx, span, variant) |i, field_id| {\n+                            let id = cx.ident_of(fmt!(\"%s_%u\", current_match_str, i));\n+                            push((field_id, build::mk_path(cx, span, ~[ id ])));\n+                        }\n+                    };\n+\n+                    matches_so_far.push((index, *variant, idents));\n+                    let new_matching =\n+                        match matching {\n+                            _ if match_count == 0 => Some(index),\n+                            Some(i) if index == i => Some(i),\n+                            _ => None\n+                        };\n+                    let arm_expr = self.build_enum_match(cx, span,\n+                                                         enum_def,\n+                                                         type_ident,\n+                                                         new_matching,\n+                                                         matches_so_far,\n+                                                         match_count + 1);\n+                    matches_so_far.pop();\n+\n+                    let arm = mk_arm!(pattern, arm_expr);\n+                    arms.push(arm);\n+                }\n+            }\n+            let deref_expr = build::mk_unary(cx, span, deref,\n+                                             build::mk_path(cx, span,\n+                                                            ~[ current_match_ident ]));\n+            let match_expr = build::mk_expr(cx, span,\n+                                            expr_match(deref_expr, arms));\n+\n+            match_expr\n+        }\n+    }\n+}\n+\n+/// Create variable names (as strings) to refer to the non-self\n+/// parameters\n+fn create_other_strs(n: uint) -> ~[~str] {\n+    do vec::build |push| {\n+        for uint::range(0, n) |i| {\n+            push(fmt!(\"__other_%u\", i));\n+        }\n+    }\n+}\n+/// Like `create_other_strs`, but returns idents for the strings\n+fn create_other_idents(cx: @ext_ctxt, n: uint) -> ~[ident] {\n+    do create_other_strs(n).map |&s| {\n+        cx.ident_of(s)\n+    }\n+}\n+\n+\n+\n+/* helpful premade recipes */\n+\n+/**\n+Fold the fields. `use_foldl` controls whether this is done\n+left-to-right (`true`) or right-to-left (`false`).\n+*/\n+pub fn cs_fold(use_foldl: bool,\n+               f: &fn(@ext_ctxt, span,\n+                      old: @expr,\n+                      self_f: @expr, other_fs: ~[@expr]) -> @expr,\n+               base: @expr,\n+               enum_nonmatch_f: EnumNonMatchFunc,\n+               cx: @ext_ctxt, span: span,\n+               substructure: &Substructure) -> @expr {\n+    match *substructure.fields {\n+        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+            if use_foldl {\n+                do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n+                    f(cx, span, old, self_f, other_fs)\n+                }\n+            } else {\n+                do all_fields.foldr(base) |&(_, self_f, other_fs), old| {\n+                    f(cx, span, old, self_f, other_fs)\n+                }\n+            }\n+        },\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+    }\n+}\n+\n+\n+/**\n+Call the method that is being derived on all the fields, and then\n+process the collected results. i.e.\n+\n+```\n+f(cx, span, ~[self_1.method(__other_1_1, __other_2_1),\n+              self_2.method(__other_1_2, __other_2_2)])\n+```\n+*/\n+pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n+                      enum_nonmatch_f: EnumNonMatchFunc,\n+                      cx: @ext_ctxt, span: span,\n+                      substructure: &Substructure) -> @expr {\n+    match *substructure.fields {\n+        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+            // call self_n.method(other_1_n, other_2_n, ...)\n+            let called = do all_fields.map |&(_, self_field, other_fields)| {\n+                build::mk_method_call(cx, span,\n+                                      self_field,\n+                                      substructure.method_ident,\n+                                      other_fields)\n+            };\n+\n+            f(cx, span, called)\n+        },\n+        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span, all_enums)\n+    }\n+}\n+\n+/**\n+Fold together the results of calling the derived method on all the\n+fields. `use_foldl` controls whether this is done left-to-right\n+(`true`) or right-to-left (`false`).\n+*/\n+pub fn cs_same_method_fold(use_foldl: bool,\n+                           f: &fn(@ext_ctxt, span, @expr, @expr) -> @expr,\n+                           base: @expr,\n+                           enum_nonmatch_f: EnumNonMatchFunc,\n+                           cx: @ext_ctxt, span: span,\n+                           substructure: &Substructure) -> @expr {\n+    cs_same_method(\n+        |cx, span, vals| {\n+            if use_foldl {\n+                do vals.foldl(base) |&old, &new| {\n+                    f(cx, span, old, new)\n+                }\n+            } else {\n+                do vals.foldr(base) |&new, old| {\n+                    f(cx, span, old, new)\n+                }\n+            }\n+        },\n+        enum_nonmatch_f,\n+        cx, span, substructure)\n+\n+}\n+\n+/**\n+Use a given binop to combine the result of calling the derived method\n+on all the fields.\n+*/\n+pub fn cs_binop(binop: binop, base: @expr,\n+                enum_nonmatch_f: EnumNonMatchFunc,\n+                cx: @ext_ctxt, span: span,\n+                substructure: &Substructure) -> @expr {\n+    cs_same_method_fold(\n+        true, // foldl is good enough\n+        |cx, span, old, new| {\n+            build::mk_binary(cx, span,\n+                             binop,\n+                             old, new)\n+\n+        },\n+        base,\n+        enum_nonmatch_f,\n+        cx, span, substructure)\n+}\n+\n+/// cs_binop with binop == or\n+pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n+             cx: @ext_ctxt, span: span,\n+             substructure: &Substructure) -> @expr {\n+    cs_binop(or, build::mk_bool(cx, span, false),\n+             enum_nonmatch_f,\n+             cx, span, substructure)\n+}\n+/// cs_binop with binop == and\n+pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n+              cx: @ext_ctxt, span: span,\n+              substructure: &Substructure) -> @expr {\n+    cs_binop(and, build::mk_bool(cx, span, true),\n+             enum_nonmatch_f,\n+             cx, span, substructure)\n+}"}, {"sha": "75215b90eb0da715bceebe8f105fb73f110fb40f", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -56,7 +56,8 @@ fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n         cx.ident_of(~\"IterBytes\")\n     ];\n     let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path,\n+                        opt_vec::Empty, opt_vec::Empty)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -230,7 +231,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n         // as well.\n         for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n             // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n             let field = build::mk_path(cx, span, ~[ field_ident ]);\n \n             // Call the substructure method."}, {"sha": "78faf5556b2cec0273f877efa38db65d1272e1e8", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -24,30 +24,41 @@ use ast::{tuple_variant_kind};\n use ast::{ty_path, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n-use codemap::span;\n+use codemap::{span, respan};\n use parse::token::special_idents::clownshoes_extensions;\n use opt_vec;\n \n use core::uint;\n \n pub mod clone;\n-pub mod eq;\n pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n \n-type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n-                                                  span,\n-                                                  x: &struct_def,\n-                                                  ident,\n-                                                  y: &Generics)\n-                                               -> @item;\n-type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n-                                                span,\n-                                                x: &enum_def,\n-                                                ident,\n-                                                y: &Generics)\n-                                             -> @item;\n+#[path=\"cmp/eq.rs\"]\n+pub mod eq;\n+#[path=\"cmp/totaleq.rs\"]\n+pub mod totaleq;\n+#[path=\"cmp/ord.rs\"]\n+pub mod ord;\n+#[path=\"cmp/totalord.rs\"]\n+pub mod totalord;\n+\n+\n+pub mod generic;\n+\n+pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n+                                                       span,\n+                                                       x: &struct_def,\n+                                                       ident,\n+                                                       y: &Generics)\n+                                                 -> @item;\n+pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n+                                                    span,\n+                                                    x: &enum_def,\n+                                                    ident,\n+                                                    y: &Generics)\n+                                                 -> @item;\n \n pub fn expand_meta_deriving(cx: @ext_ctxt,\n                             _span: span,\n@@ -74,14 +85,20 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                         match *tname {\n                             ~\"Clone\" => clone::expand_deriving_clone(cx,\n                                 titem.span, titem, in_items),\n-                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n-                                titem, in_items),\n                             ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n                                 titem.span, titem, in_items),\n                             ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n                                 titem.span, titem, in_items),\n                             ~\"Decodable\" => decodable::expand_deriving_decodable(cx,\n                                 titem.span, titem, in_items),\n+                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n+                                                             titem, in_items),\n+                            ~\"TotalEq\" => totaleq::expand_deriving_totaleq(cx, titem.span,\n+                                                                           titem, in_items),\n+                            ~\"Ord\" => ord::expand_deriving_ord(cx, titem.span,\n+                                                               titem, in_items),\n+                            ~\"TotalOrd\" => totalord::expand_deriving_totalord(cx, titem.span,\n+                                                                              titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));\n@@ -126,9 +143,19 @@ pub fn expand_deriving(cx: @ext_ctxt,\n }\n \n fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n+    let doc_attr = respan(span,\n+                          ast::lit_str(@~\"Automatically derived.\"));\n+    let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n+    let doc_attr = ast::attribute_ {\n+        style: ast::attr_outer,\n+        value: @doc_attr,\n+        is_sugared_doc: false\n+    };\n+    let doc_attr = respan(span, doc_attr);\n+\n     @ast::item {\n         ident: clownshoes_extensions,\n-        attrs: ~[],\n+        attrs: ~[doc_attr],\n         id: cx.next_id(),\n         node: item,\n         vis: public,\n@@ -164,14 +191,17 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n                            generics: &Generics,\n                            methods: &[@method],\n                            trait_path: @ast::Path,\n-                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>)\n+                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>,\n+                           bounds_paths: opt_vec::OptVec<~[ident]>)\n                         -> @item {\n     /*!\n      *\n      * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n      * 'z, A, ..., Z>`, creates an impl like:\n      *\n-     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n+     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where B1, B2, ... are the bounds given by `bounds_paths`.\n      *\n      * FIXME(#5090): Remove code duplication between this and the\n      * code in auto_encode.rs\n@@ -182,16 +212,21 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n         build::mk_lifetime(cx, l.span, l.ident)\n     });\n \n-    // Create the reference to the trait.\n-    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n-\n     // Create the type parameters.\n     for generics.ty_params.each |ty_param| {\n-        let bounds = @opt_vec::with(\n-            build::mk_trait_ty_param_bound_(cx, trait_path)\n-        );\n-        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, bounds));\n-    };\n+        let mut bounds = do bounds_paths.map |&bound_path| {\n+            build::mk_trait_ty_param_bound_global(cx, span, bound_path)\n+        };\n+\n+        let this_trait_bound =\n+            build::mk_trait_ty_param_bound_(cx, trait_path);\n+        bounds.push(this_trait_bound);\n+\n+        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n+    }\n+\n+    // Create the reference to the trait.\n+    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n@@ -216,8 +251,8 @@ pub fn create_subpatterns(cx: @ext_ctxt,\n     let mut subpats = ~[];\n     for uint::range(0, n) |_i| {\n         // Create the subidentifier.\n-        let index = subpats.len().to_str();\n-        let ident = cx.ident_of(prefix + index);\n+        let index = subpats.len();\n+        let ident = cx.ident_of(fmt!(\"%s_%u\", prefix, index));\n \n         // Create the subpattern.\n         let subpath = build::mk_raw_path(span, ~[ ident ]);\n@@ -287,6 +322,29 @@ pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &variant) -> uint\n     }\n }\n \n+/// Iterate through the idents of the variant arguments. The field is\n+/// unnamed (i.e. it's not a struct-like enum), then `None`.\n+pub fn each_variant_arg_ident(_cx: @ext_ctxt, _span: span,\n+                              variant: &variant, it: &fn(uint, Option<ident>) -> bool) {\n+    match variant.node.kind {\n+        tuple_variant_kind(ref args) => {\n+            for uint::range(0, args.len()) |i| {\n+                if !it(i, None) { break }\n+            }\n+        }\n+        struct_variant_kind(ref struct_def) => {\n+            for struct_def.fields.eachi |i, f| {\n+                let id = match f.node.kind {\n+                    named_field(ident, _, _) => Some(ident),\n+                    unnamed_field => None\n+                };\n+                if !it(i, id) { break }\n+            }\n+        }\n+    }\n+}\n+\n+\n pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])"}, {"sha": "a2651ddac3d19e6e9151a198b9d680b6c1f73d43", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+enum E<T> {\n+    E0,\n+    E1(T),\n+    E2(T,T)\n+}\n+\n+pub fn main() {\n+    let e0 = E0, e11 = E1(1), e12 = E1(2), e21 = E2(1,1), e22 = E2(1, 2);\n+\n+    // in order for both Ord and TotalOrd\n+    let es = [e0, e11, e12, e21, e22];\n+\n+    for es.eachi |i, e1| {\n+        for es.eachi |j, e2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*e1 == *e2, eq);\n+            assert_eq!(*e1 != *e2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(e1.equals(e2), eq);\n+\n+            // Ord\n+            assert_eq!(*e1 < *e2, lt);\n+            assert_eq!(*e1 > *e2, gt);\n+\n+            assert_eq!(*e1 <= *e2, le);\n+            assert_eq!(*e1 >= *e2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(e1.cmp(e2), ord);\n+        }\n+    }\n+}"}, {"sha": "6f6e8d79d8b92cf432ee0340366caf72014c003d", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,52 @@\n+// xfail-test #5530\n+\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+enum ES<T> {\n+    ES1 { x: T },\n+    ES2 { x: T, y: T }\n+}\n+\n+\n+pub fn main() {\n+    let es11 = ES1 {x: 1}, es12 = ES1 {x: 2}, es21 = ES2 {x: 1, y: 1}, es22 = ES2 {x: 1, y: 2};\n+\n+    // in order for both Ord and TotalOrd\n+    let ess = [es11, es12, es21, es22];\n+\n+    for ess.eachi |i, es1| {\n+        for ess.eachi |j, es2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*es1 == *es2, eq);\n+            assert_eq!(*es1 != *es2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(es1.equals(es2), eq);\n+\n+            // Ord\n+            assert_eq!(*es1 < *es2, lt);\n+            assert_eq!(*es1 > *es2, gt);\n+\n+            assert_eq!(*es1 <= *es2, le);\n+            assert_eq!(*es1 >= *es2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(es1.cmp(es2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "bd3e02ba29b30836e2d7369d10d018caa944e9d7", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+struct S<T> {\n+    x: T,\n+    y: T\n+}\n+\n+pub fn main() {\n+    let s1 = S {x: 1, y: 1}, s2 = S {x: 1, y: 2};\n+\n+    // in order for both Ord and TotalOrd\n+    let ss = [s1, s2];\n+\n+    for ss.eachi |i, s1| {\n+        for ss.eachi |j, s2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*s1 == *s2, eq);\n+            assert_eq!(*s1 != *s2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(s1.equals(s2), eq);\n+\n+            // Ord\n+            assert_eq!(*s1 < *s2, lt);\n+            assert_eq!(*s1 > *s2, gt);\n+\n+            assert_eq!(*s1 <= *s2, le);\n+            assert_eq!(*s1 >= *s2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(s1.cmp(s2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "733b19a9ae2da6a4bb820a13ed5c7579b319dc6d", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb69748563f7b9ab94160943eea6ec787b27a4d/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=2cb69748563f7b9ab94160943eea6ec787b27a4d", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+struct TS<T>(T,T);\n+\n+\n+pub fn main() {\n+    let ts1 = TS(1, 1), ts2 = TS(1,2);\n+\n+    // in order for both Ord and TotalOrd\n+    let tss = [ts1, ts2];\n+\n+    for tss.eachi |i, ts1| {\n+        for tss.eachi |j, ts2| {\n+            let ord = i.cmp(&j);\n+\n+            let eq = i == j;\n+            let lt = i < j, le = i <= j;\n+            let gt = i > j, ge = i >= j;\n+\n+            // Eq\n+            assert_eq!(*ts1 == *ts2, eq);\n+            assert_eq!(*ts1 != *ts2, !eq);\n+\n+            // TotalEq\n+            assert_eq!(ts1.equals(ts2), eq);\n+\n+            // Ord\n+            assert_eq!(*ts1 < *ts2, lt);\n+            assert_eq!(*ts1 > *ts2, gt);\n+\n+            assert_eq!(*ts1 <= *ts2, le);\n+            assert_eq!(*ts1 >= *ts2, ge);\n+\n+            // TotalOrd\n+            assert_eq!(ts1.cmp(ts2), ord);\n+        }\n+    }\n+}\n\\ No newline at end of file"}]}