{"sha": "533a356c49759da02fcb2457c62aed58af70579c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzM2EzNTZjNDk3NTlkYTAyZmNiMjQ1N2M2MmFlZDU4YWY3MDU3OWM=", "commit": {"author": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-08-30T20:44:38Z"}, "committer": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-08-30T20:47:17Z"}, "message": "remove directory libstd/sys/vxworks/backtrace which is not used any more", "tree": {"sha": "dcd9454edb3c67bcd170deecc2108c1cc9f8918a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd9454edb3c67bcd170deecc2108c1cc9f8918a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/533a356c49759da02fcb2457c62aed58af70579c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/533a356c49759da02fcb2457c62aed58af70579c", "html_url": "https://github.com/rust-lang/rust/commit/533a356c49759da02fcb2457c62aed58af70579c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/533a356c49759da02fcb2457c62aed58af70579c/comments", "author": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cce631a5a49c327eb301c9d65a17a39d7863da64", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce631a5a49c327eb301c9d65a17a39d7863da64", "html_url": "https://github.com/rust-lang/rust/commit/cce631a5a49c327eb301c9d65a17a39d7863da64"}], "stats": {"total": 324, "additions": 0, "deletions": 324}, "files": [{"sha": "0887e5a4df937ed97486ceb77367defe4ab1f833", "filename": "src/libstd/sys/vxworks/backtrace/mod.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,110 +0,0 @@\n-/// Backtrace support built on libgcc with some extra OS-specific support\n-///\n-/// Some methods of getting a backtrace:\n-///\n-/// * The backtrace() functions on unix. It turns out this doesn't work very\n-///   well for green threads on macOS, and the address to symbol portion of it\n-///   suffers problems that are described below.\n-///\n-/// * Using libunwind. This is more difficult than it sounds because libunwind\n-///   isn't installed everywhere by default. It's also a bit of a hefty library,\n-///   so possibly not the best option. When testing, libunwind was excellent at\n-///   getting both accurate backtraces and accurate symbols across platforms.\n-///   This route was not chosen in favor of the next option, however.\n-///\n-/// * We're already using libgcc_s for exceptions in rust (triggering thread\n-///   unwinding and running destructors on the stack), and it turns out that it\n-///   conveniently comes with a function that also gives us a backtrace. All of\n-///   these functions look like _Unwind_*, but it's not quite the full\n-///   repertoire of the libunwind API. Due to it already being in use, this was\n-///   the chosen route of getting a backtrace.\n-///\n-/// After choosing libgcc_s for backtraces, the sad part is that it will only\n-/// give us a stack trace of instruction pointers. Thankfully these instruction\n-/// pointers are accurate (they work for green and native threads), but it's\n-/// then up to us again to figure out how to translate these addresses to\n-/// symbols. As with before, we have a few options. Before, that, a little bit\n-/// of an interlude about symbols. This is my very limited knowledge about\n-/// symbol tables, and this information is likely slightly wrong, but the\n-/// general idea should be correct.\n-///\n-/// When talking about symbols, it's helpful to know a few things about where\n-/// symbols are located. Some symbols are located in the dynamic symbol table\n-/// of the executable which in theory means that they're available for dynamic\n-/// linking and lookup. Other symbols end up only in the local symbol table of\n-/// the file. This loosely corresponds to pub and priv functions in Rust.\n-///\n-/// Armed with this knowledge, we know that our solution for address to symbol\n-/// translation will need to consult both the local and dynamic symbol tables.\n-/// With that in mind, here's our options of translating an address to\n-/// a symbol.\n-///\n-/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n-///   behind the scenes to translate, and this is why backtrace() was not used.\n-///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n-///   uses magic to consult the local symbol table, or we're putting everything\n-///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n-///   method used for translation. It's provided by the system and easy to do.o\n-///\n-///   Sadly, all other systems have a dladdr() implementation that does not\n-///   consult the local symbol table. This means that most functions are blank\n-///   because they don't have symbols. This means that we need another solution.\n-///\n-/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n-///   libgcc_s version of the libunwind api), but involves taking a dependency\n-///   to libunwind. We may pursue this route in the future if we bundle\n-///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n-///   this time to provide this functionality.\n-///\n-/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n-///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n-///   so in theory it could invoke readelf, parse the output, and consult the\n-///   local/dynamic symbol tables from there. This ended up not getting chosen\n-///   due to the craziness of the idea plus the advent of the next option.\n-///\n-/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n-///   the gcc repository which provides backtrace and symbol translation\n-///   functionality. All we really need from it is the backtrace functionality,\n-///   and we only really need this on everything that's not macOS, so this is the\n-///   chosen route for now.\n-///\n-/// In summary, the current situation uses libgcc_s to get a trace of stack\n-/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n-/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n-/// all unix platforms we support right now, so it at least gets the job done.\n-\n-pub use self::tracing::unwind_backtrace;\n-pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n-\n-// tracing impls:\n-mod tracing;\n-// symbol resolvers:\n-mod printing;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub mod gnu {\n-    use crate::io;\n-    use crate::fs;\n-\n-    use libc::c_char;\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        use crate::env;\n-        use crate::os::unix::ffi::OsStrExt;\n-\n-        let filename = env::current_exe()?;\n-        let file = fs::File::open(&filename)?;\n-        let mut filename_cstr: Vec<_> = filename.as_os_str().as_bytes().iter()\n-            .map(|&x| x as c_char).collect();\n-        filename_cstr.push(0); // Null terminate\n-        Ok((filename_cstr, file))\n-    }\n-}\n-\n-pub struct BacktraceContext;"}, {"sha": "202164dd3c4d7655c0239ffee22891984b4cd18d", "filename": "src/libstd/sys/vxworks/backtrace/printing/dladdr.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,35 +0,0 @@\n-use crate::io;\n-use crate::intrinsics;\n-use crate::ffi::CStr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          _: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    unsafe {\n-        let mut info: Dl_info = intrinsics::init();\n-        let symname = if dladdr(frame.exact_position as *mut _, &mut info) == 0 ||\n-                         info.dli_sname.is_null() {\n-            None\n-        } else {\n-            CStr::from_ptr(info.dli_sname).to_str().ok()\n-        };\n-        callback(symname)\n-    }\n-}\n-\n-#[repr(C)]\n-struct Dl_info {\n-    dli_fname: *const libc::c_char,\n-    dli_fbase: *mut libc::c_void,\n-    dli_sname: *const libc::c_char,\n-    dli_saddr: *mut libc::c_void,\n-}\n-\n-extern {\n-    #[ link_name = \"_rtld_dladdr\" ]\n-    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n-}"}, {"sha": "d090caede437abc25749831a46fe2d99896a7300", "filename": "src/libstd/sys/vxworks/backtrace/printing/mod.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,33 +0,0 @@\n-mod dladdr;\n-\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-use crate::io;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub use self::dladdr::resolve_symname;\n-\n-#[cfg(target_os = \"emscripten\")]\n-pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n-where\n-    F: FnMut(&[u8], u32) -> io::Result<()>\n-{\n-    Ok(false)\n-}\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub use crate::sys_common::gnu::libbacktrace::foreach_symbol_fileline;\n-\n-#[cfg(not(target_os = \"emscripten\"))]\n-pub fn resolve_symname<F>(frame: Frame, callback: F, bc: &BacktraceContext) -> io::Result<()>\n-where\n-    F: FnOnce(Option<&str>) -> io::Result<()>\n-{\n-    crate::sys_common::gnu::libbacktrace::resolve_symname(frame, |symname| {\n-        if symname.is_some() {\n-            callback(symname)\n-        } else {\n-            dladdr::resolve_symname(frame, callback, bc)\n-        }\n-    }, bc)\n-}"}, {"sha": "a628d107ad6fbd94f523f7c49a951cdea4c941c6", "filename": "src/libstd/sys/vxworks/backtrace/tracing/backtrace_fn.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,39 +0,0 @@\n-/// As always - iOS on arm uses SjLj exceptions and\n-/// _Unwind_Backtrace is even not available there. Still,\n-/// backtraces could be extracted using a backtrace function,\n-/// which thanks god is public\n-///\n-/// As mentioned in a huge comment block in `super::super`, backtrace\n-/// doesn't play well with green threads, so while it is extremely nice and\n-/// simple to use it should be used only on iOS devices as the only viable\n-/// option.\n-\n-use crate::io;\n-use crate::ptr;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    const FRAME_LEN: usize = 100;\n-    assert!(FRAME_LEN >= frames.len());\n-    let mut raw_frames = [ptr::null_mut(); FRAME_LEN];\n-    let nb_frames = unsafe {\n-        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n-    } as usize;\n-    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n-        *to = Frame {\n-            exact_position: *from as *mut u8,\n-            symbol_addr: *from as *mut u8,\n-            inline_context: 0,\n-        };\n-    }\n-    Ok((nb_frames as usize, BacktraceContext))\n-}\n-\n-extern {\n-    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n-}"}, {"sha": "e6379132bafbe35552adac17dd543aaef39accf4", "filename": "src/libstd/sys/vxworks/backtrace/tracing/gcc_s.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,99 +0,0 @@\n-use crate::error::Error;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::backtrace::BacktraceContext;\n-use crate::sys_common::backtrace::Frame;\n-\n-use unwind as uw;\n-\n-struct Context<'a> {\n-    idx: usize,\n-    frames: &'a mut [Frame],\n-}\n-\n-#[derive(Debug)]\n-struct UnwindError(uw::_Unwind_Reason_Code);\n-\n-impl Error for UnwindError {\n-    fn description(&self) -> &'static str {\n-        \"unexpected return value while unwinding\"\n-    }\n-}\n-\n-impl fmt::Display for UnwindError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", self.description(), self.0)\n-    }\n-}\n-\n-#[inline(never)] // if we know this is a function call, we can skip it when\n-                 // tracing\n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    let mut cx = Context {\n-        idx: 0,\n-        frames,\n-    };\n-    let result_unwind = unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context<'_>\n-                              as *mut libc::c_void)\n-    };\n-    // See libunwind:src/unwind/Backtrace.c for the return values.\n-    // No, there is no doc.\n-    match result_unwind {\n-        // These return codes seem to be benign and need to be ignored for backtraces\n-        // to show up properly on all tested platforms.\n-        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n-            Ok((cx.idx, BacktraceContext))\n-        }\n-        _ => {\n-            Err(io::Error::new(io::ErrorKind::Other,\n-                               UnwindError(result_unwind)))\n-        }\n-    }\n-}\n-\n-extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n-                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n-    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n-    if cx.idx >= cx.frames.len() {\n-        return uw::_URC_NORMAL_STOP;\n-    }\n-\n-    let mut ip_before_insn = 0;\n-    let mut ip = unsafe {\n-        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n-    };\n-    if !ip.is_null() && ip_before_insn == 0 {\n-        // this is a non-signaling frame, so `ip` refers to the address\n-        // after the calling instruction. account for that.\n-        ip = (ip as usize - 1) as *mut _;\n-    }\n-\n-    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n-    // it appears to work fine without it, so we only use\n-    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n-    // slightly more accurate stack trace in the process.\n-    //\n-    // This is often because panic involves the last instruction of a\n-    // function being \"call std::rt::begin_unwind\", with no ret\n-    // instructions after it. This means that the return instruction\n-    // pointer points *outside* of the calling function, and by\n-    // unwinding it we go back to the original function.\n-    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n-        ip\n-    } else {\n-        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n-    };\n-\n-    cx.frames[cx.idx] = Frame {\n-        symbol_addr: symaddr as *mut u8,\n-        exact_position: ip as *mut u8,\n-        inline_context: 0,\n-    };\n-    cx.idx += 1;\n-\n-    uw::_URC_NO_REASON\n-}"}, {"sha": "11863e6454525b2c955b2103ac33dca3799a92ea", "filename": "src/libstd/sys/vxworks/backtrace/tracing/mod.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cce631a5a49c327eb301c9d65a17a39d7863da64/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs?ref=cce631a5a49c327eb301c9d65a17a39d7863da64", "patch": "@@ -1,8 +0,0 @@\n-pub use self::imp::*;\n-\n-#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-#[path = \"gcc_s.rs\"]\n-mod imp;\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[path = \"backtrace_fn.rs\"]\n-mod imp;"}]}