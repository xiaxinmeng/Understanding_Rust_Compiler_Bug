{"sha": "7e20929e55c5c76bc1466568da746cea4171bc71", "node_id": "C_kwDOAAsO6NoAKDdlMjA5MjllNTVjNWM3NmJjMTQ2NjU2OGRhNzQ2Y2VhNDE3MWJjNzE", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-10-03T13:28:02Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-10-10T13:20:16Z"}, "message": "macros: separate suggestion fmt'ing and emission\n\nDiagnostic derives have previously had to take special care when\nordering the generated code so that fields were not used after a move.\n\nThis is unlikely for most fields because a field is either annotated\nwith a subdiagnostic attribute and is thus likely a `Span` and copiable,\nor is a argument, in which case it is only used once by `set_arg`\nanyway.\n\nHowever, format strings for code in suggestions can result in fields\nbeing used after being moved if not ordered carefully. As a result, the\nderive currently puts `set_arg` calls last (just before emission), such\nas:\n\n```rust\nlet diag = { /* create diagnostic */ };\n\ndiag.span_suggestion_with_style(\n    span,\n    fluent::crate::slug,\n    format!(\"{}\", __binding_0),\n    Applicability::Unknown,\n    SuggestionStyle::ShowAlways\n);\n/* + other subdiagnostic additions */\n\ndiag.set_arg(\"foo\", __binding_0);\n/* + other `set_arg` calls */\n\ndiag.emit();\n```\n\nFor eager translation, this doesn't work, as the message being\ntranslated eagerly can assume that all arguments are available - so\narguments _must_ be set first.\n\nFormat strings for suggestion code are now separated into two parts - an\ninitialization line that performs the formatting into a variable, and a\nusage in the subdiagnostic addition.\n\nBy separating these parts, the initialization can happen before\narguments are set, preserving the desired order so that code compiles,\nwhile still enabling arguments to be set before subdiagnostics are\nadded.\n\n```rust\nlet diag = { /* create diagnostic */ };\n\nlet __code_0 = format!(\"{}\", __binding_0);\n/* + other formatting */\n\ndiag.set_arg(\"foo\", __binding_0);\n/* + other `set_arg` calls */\n\ndiag.span_suggestion_with_style(\n    span,\n    fluent::crate::slug,\n    __code_0,\n    Applicability::Unknown,\n    SuggestionStyle::ShowAlways\n);\n/* + other subdiagnostic additions */\n\ndiag.emit();\n```\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "f52736deb422fc0ab02dfbe0c1609a755b0d18e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52736deb422fc0ab02dfbe0c1609a755b0d18e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e20929e55c5c76bc1466568da746cea4171bc71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e20929e55c5c76bc1466568da746cea4171bc71", "html_url": "https://github.com/rust-lang/rust/commit/7e20929e55c5c76bc1466568da746cea4171bc71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e20929e55c5c76bc1466568da746cea4171bc71/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113e94369cb72a98648c12c263475821bbff7d9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/113e94369cb72a98648c12c263475821bbff7d9c", "html_url": "https://github.com/rust-lang/rust/commit/113e94369cb72a98648c12c263475821bbff7d9c"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "017bf2365d62baecbd8147b11026423de41eef33", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=7e20929e55c5c76bc1466568da746cea4171bc71", "patch": "@@ -426,7 +426,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::Suggestion {\n                 suggestion_kind,\n                 applicability: static_applicability,\n-                code,\n+                code_field,\n+                code_init,\n             } => {\n                 let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n \n@@ -440,10 +441,11 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let style = suggestion_kind.to_suggestion_style();\n \n                 Ok(quote! {\n+                    #code_init\n                     #diag.span_suggestion_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n-                        #code,\n+                        #code_field,\n                         #applicability,\n                         #style\n                     );"}, {"sha": "3d4c3ab9fd7c9f1db983eed8de0db0f0afdebfe8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=7e20929e55c5c76bc1466568da746cea4171bc71", "patch": "@@ -5,7 +5,7 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, report_error_if_not_applied_to_applicability,\n+    build_field_mapping, new_code_ident, report_error_if_not_applied_to_applicability,\n     report_error_if_not_applied_to_span, FieldInfo, FieldInnerTy, FieldMap, HasFieldMap, SetOnce,\n     SpannedOption, SubdiagnosticKind,\n };\n@@ -57,6 +57,7 @@ impl SubdiagnosticDeriveBuilder {\n                     parent: &self,\n                     variant,\n                     span,\n+                    formatting_init: TokenStream::new(),\n                     fields: build_field_mapping(variant),\n                     span_field: None,\n                     applicability: None,\n@@ -105,6 +106,9 @@ struct SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     /// Span for the entire type.\n     span: proc_macro::Span,\n \n+    /// Initialization of format strings for code suggestions.\n+    formatting_init: TokenStream,\n+\n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: FieldMap,\n@@ -230,7 +234,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 };\n \n                 let generated = self\n-                    .generate_field_code_inner(kind_stats, attr, info)\n+                    .generate_field_code_inner(kind_stats, attr, info, inner_ty.will_iterate())\n                     .unwrap_or_else(|v| v.to_compile_error());\n \n                 inner_ty.with(binding, generated)\n@@ -243,13 +247,18 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let meta = attr.parse_meta()?;\n         match meta {\n             Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => {\n-                self.generate_field_code_inner_list(kind_stats, attr, info, list)\n-            }\n+            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+                kind_stats,\n+                attr,\n+                info,\n+                list,\n+                clone_suggestion_code,\n+            ),\n             _ => throw_invalid_attr!(attr, &meta),\n         }\n     }\n@@ -353,6 +362,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n         list: MetaList,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n         let ident = &list.path.segments.last().unwrap().ident;\n@@ -390,22 +400,29 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once(formatted_str, span);\n+                            let code_field = new_code_ident();\n+                            code.set_once((code_field, formatted_str), span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }\n                 }\n \n-                let Some((code, _)) = code else {\n+                let Some((code_field, formatted_str)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                     return Ok(quote! {});\n                 };\n                 let binding = info.binding;\n \n-                Ok(quote! { suggestions.push((#binding, #code)); })\n+                self.formatting_init.extend(quote! { let #code_field = #formatted_str; });\n+                let code_field = if clone_suggestion_code {\n+                    quote! { #code_field.clone() }\n+                } else {\n+                    quote! { #code_field }\n+                };\n+                Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n             _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n                 let mut span_attrs = vec![];\n@@ -459,7 +476,14 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n \n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n             let call = match kind {\n-                SubdiagnosticKind::Suggestion { suggestion_kind, applicability, code } => {\n+                SubdiagnosticKind::Suggestion {\n+                    suggestion_kind,\n+                    applicability,\n+                    code_init,\n+                    code_field,\n+                } => {\n+                    self.formatting_init.extend(code_init);\n+\n                     let applicability = applicability\n                         .value()\n                         .map(|a| quote! { #a })\n@@ -468,8 +492,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n \n                     if let Some(span) = span_field {\n                         let style = suggestion_kind.to_suggestion_style();\n-\n-                        quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                        quote! { #diag.#name(#span, #message, #code_field, #applicability, #style); }\n                     } else {\n                         span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n                         quote! { unreachable!(); }\n@@ -510,6 +533,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     }\n                 }\n             };\n+\n             calls.extend(call);\n         }\n \n@@ -521,11 +545,13 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             .map(|binding| self.generate_field_set_arg(binding))\n             .collect();\n \n+        let formatting_init = &self.formatting_init;\n         Ok(quote! {\n             #init\n+            #formatting_init\n             #attr_args\n-            #calls\n             #plain_args\n+            #calls\n         })\n     }\n }"}, {"sha": "5e1cd842b9bbb81a83abdcb54236efff36cf7400", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e20929e55c5c76bc1466568da746cea4171bc71/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=7e20929e55c5c76bc1466568da746cea4171bc71", "patch": "@@ -4,6 +4,7 @@ use crate::diagnostics::error::{\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n+use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n@@ -14,6 +15,19 @@ use synstructure::{BindStyle, BindingInfo, VariantInfo};\n \n use super::error::invalid_nested_attr;\n \n+thread_local! {\n+    pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n+}\n+\n+/// Returns an ident of the form `__code_N` where `N` is incremented once with every call.\n+pub(crate) fn new_code_ident() -> syn::Ident {\n+    CODE_IDENT_COUNT.with(|count| {\n+        let ident = format_ident!(\"__code_{}\", *count.borrow());\n+        *count.borrow_mut() += 1;\n+        ident\n+    })\n+}\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n@@ -142,6 +156,15 @@ impl<'ty> FieldInnerTy<'ty> {\n         unreachable!();\n     }\n \n+    /// Returns `true` if `FieldInnerTy::with` will result in iteration for this inner type (i.e.\n+    /// that cloning might be required for values moved in the loop body).\n+    pub(crate) fn will_iterate(&self) -> bool {\n+        match self {\n+            FieldInnerTy::Vec(..) => true,\n+            FieldInnerTy::Option(..) | FieldInnerTy::None => false,\n+        }\n+    }\n+\n     /// Returns `Option` containing inner type if there is one.\n     pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n         match self {\n@@ -434,7 +457,12 @@ pub(super) enum SubdiagnosticKind {\n     Suggestion {\n         suggestion_kind: SuggestionKind,\n         applicability: SpannedOption<Applicability>,\n-        code: TokenStream,\n+        /// Identifier for variable used for formatted code, e.g. `___code_0`. Enables separation\n+        /// of formatting and diagnostic emission so that `set_arg` calls can happen in-between..\n+        code_field: syn::Ident,\n+        /// Initialization logic for `code_field`'s variable, e.g.\n+        /// `let __formatted_code = /* whatever */;`\n+        code_init: TokenStream,\n     },\n     /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n     MultipartSuggestion {\n@@ -469,7 +497,8 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion {\n                         suggestion_kind,\n                         applicability: None,\n-                        code: TokenStream::new(),\n+                        code_field: new_code_ident(),\n+                        code_init: TokenStream::new(),\n                     }\n                 } else if let Some(suggestion_kind) =\n                     name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n@@ -548,9 +577,10 @@ impl SubdiagnosticKind {\n             };\n \n             match (nested_name, &mut kind) {\n-                (\"code\", SubdiagnosticKind::Suggestion { .. }) => {\n+                (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let formatted_str = fields.build_format(&value.value(), value.span());\n-                    code.set_once(formatted_str, span);\n+                    let code_init = quote! { let #code_field = #formatted_str; };\n+                    code.set_once(code_init, span);\n                 }\n                 (\n                     \"applicability\",\n@@ -582,13 +612,13 @@ impl SubdiagnosticKind {\n         }\n \n         match kind {\n-            SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                *code_field = if let Some((code, _)) = code {\n-                    code\n+            SubdiagnosticKind::Suggestion { ref code_field, ref mut code_init, .. } => {\n+                *code_init = if let Some(init) = code.value() {\n+                    init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                    quote! { \"\" }\n-                }\n+                    quote! { let #code_field: String = unreachable!(); }\n+                };\n             }\n             SubdiagnosticKind::Label\n             | SubdiagnosticKind::Note"}, {"sha": "e873c36e0b39a14f3adbdd86f9b189df92fd2519", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e20929e55c5c76bc1466568da746cea4171bc71/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e20929e55c5c76bc1466568da746cea4171bc71/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=7e20929e55c5c76bc1466568da746cea4171bc71", "patch": "@@ -725,3 +725,27 @@ struct SubdiagnosticEagerCorrect {\n     #[subdiagnostic(eager)]\n     note: Note,\n }\n+\n+// Check that formatting of `correct` in suggestion doesn't move the binding for that field, making\n+// the `set_arg` call a compile error; and that isn't worked around by moving the `set_arg` call\n+// after the `span_suggestion` call - which breaks eager translation.\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion_short(\n+    parser::use_instead,\n+    applicability = \"machine-applicable\",\n+    code = \"{correct}\"\n+)]\n+pub(crate) struct SubdiagnosticWithSuggestion {\n+    #[primary_span]\n+    span: Span,\n+    invalid: String,\n+    correct: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerSuggestion {\n+    #[subdiagnostic(eager)]\n+    sub: SubdiagnosticWithSuggestion,\n+}"}]}