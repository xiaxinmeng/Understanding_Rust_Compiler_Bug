{"sha": "c84e7976423bb910bb5eb5eecffc7e33a897a97f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NGU3OTc2NDIzYmI5MTBiYjVlYjVlZWNmZmM3ZTMzYTg5N2E5N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T12:10:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T12:10:10Z"}, "message": "Auto merge of #58098 - oli-obk:maybe_allow_internal_unstable, r=petrochenkov\n\nRequire a list of features in `#[allow_internal_unstable]`\n\nThe blanket-permission slip is not great and will likely give us trouble some point down the road.", "tree": {"sha": "24570884cb7742fe817286a3cde2643722eb8c6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24570884cb7742fe817286a3cde2643722eb8c6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84e7976423bb910bb5eb5eecffc7e33a897a97f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84e7976423bb910bb5eb5eecffc7e33a897a97f", "html_url": "https://github.com/rust-lang/rust/commit/c84e7976423bb910bb5eb5eecffc7e33a897a97f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84e7976423bb910bb5eb5eecffc7e33a897a97f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a54b5c7a645ead203d77e78245362f9e0f00dd3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a54b5c7a645ead203d77e78245362f9e0f00dd3c", "html_url": "https://github.com/rust-lang/rust/commit/a54b5c7a645ead203d77e78245362f9e0f00dd3c"}, {"sha": "bbe524d7c1a1028737a93c7c71c508a68363b681", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe524d7c1a1028737a93c7c71c508a68363b681", "html_url": "https://github.com/rust-lang/rust/commit/bbe524d7c1a1028737a93c7c71c508a68363b681"}], "stats": {"total": 1134, "additions": 622, "deletions": 512}, "files": [{"sha": "7ae57a8dc79841284c23e0e6588391c14e30e787", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -34,7 +34,8 @@\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(box_syntax))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n macro_rules! vec {\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)"}, {"sha": "6b5fe84ff61dfa4cb7dec2ce4e10339726deffed", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,6 +1,7 @@\n /// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(core_panic, __rust_unstable_column))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -409,7 +410,8 @@ macro_rules! write {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(format_args_nl))]\n macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")"}, {"sha": "43c756def88be5f492d2a087918557ae6d628060", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -44,6 +44,7 @@ use crate::middle::cstore::CrateStore;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_data_structures::sync::Lrc;\n use crate::session::Session;\n use crate::session::config::nightly_options;\n use crate::util::common::FN_OUTPUT_NAME;\n@@ -681,13 +682,20 @@ impl<'a> LoweringContext<'a> {\n         Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n-    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    fn mark_span_with_reason(\n+        &self,\n+        reason: CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(source_map::ExpnInfo {\n             call_site: span,\n             def_site: Some(span),\n             format: source_map::CompilerDesugaring(reason),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: source_map::hygiene::default_edition(),\n@@ -964,7 +972,13 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n+        let unstable_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Async,\n+            span,\n+            Some(vec![\n+                Symbol::intern(\"gen_future\"),\n+            ].into()),\n+        );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n@@ -1360,9 +1374,10 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.allow_internal_unstable(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n+            None,\n         );\n \n         let exist_ty_def_index = self\n@@ -3927,8 +3942,13 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span =\n-                        this.allow_internal_unstable(CompilerDesugaringKind::TryBlock, body.span);\n+                    let unstable_span = this.mark_span_with_reason(\n+                        CompilerDesugaringKind::TryBlock,\n+                        body.span,\n+                        Some(vec![\n+                            Symbol::intern(\"try_trait\"),\n+                        ].into()),\n+                    );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n@@ -4360,9 +4380,10 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.allow_internal_unstable(\n+                let desugared_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n+                    None,\n                 );\n \n                 let iter = self.str_to_ident(\"iter\");\n@@ -4525,8 +4546,13 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span =\n-                    self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n+                let unstable_span = self.mark_span_with_reason(\n+                    CompilerDesugaringKind::QuestionMark,\n+                    e.span,\n+                    Some(vec![\n+                        Symbol::intern(\"try_trait\")\n+                    ].into()),\n+                );\n \n                 // `Try::into_result(<expr>)`\n                 let discr = {"}, {"sha": "5d606abb3cd79f621ae3a758faed16c0626cb838", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -561,11 +561,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n     pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n-        if span.allows_unstable() {\n-            debug!(\"stability: skipping span={:?} since it is internal\", span);\n-            return EvalResult::Allow;\n-        }\n-\n         let lint_deprecated = |def_id: DefId,\n                                id: NodeId,\n                                note: Option<Symbol>,\n@@ -694,6 +689,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+                if span.allows_unstable(&feature.as_str()) {\n+                    debug!(\"stability: skipping span={:?} since it is internal\", span);\n+                    return EvalResult::Allow;\n+                }\n                 if self.stability().active_features.contains(&feature) {\n                     return EvalResult::Allow;\n                 }"}, {"sha": "758a0d63886b1e91eadeee8cc6fa42d77aa95fe0", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -91,7 +91,9 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n             call_site: item.span, // use the call site of the static\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable: Some(vec![\n+                Symbol::intern(\"rustc_attrs\"),\n+            ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: hygiene::default_edition(),"}, {"sha": "af1f2910461ecc9d203b35dff841589b44cc52e5", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,7 +1,8 @@\n /// A simple static assertion macro. The first argument should be a unique\n /// ALL_CAPS identifier that describes the condition.\n #[macro_export]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(type_ascription))]\n macro_rules! static_assert {\n     ($name:ident: $test:expr) => {\n         // Use the bool to access an array such that if the bool is false, the access"}, {"sha": "90b0fb249aa616f6d52ca78bb5209823fa08831c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -570,7 +570,7 @@ impl<'a> CrateLoader<'a> {\n                 ProcMacro::Bang { name, client } => {\n                     (name, SyntaxExtension::ProcMacro {\n                         expander: Box::new(BangProcMacro { client }),\n-                        allow_internal_unstable: false,\n+                        allow_internal_unstable: None,\n                         edition: root.edition,\n                     })\n                 }"}, {"sha": "f49b88f14e60e24fb7c73134a2834317c3d9e0e1", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -425,7 +425,9 @@ impl cstore::CStore {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let ext = SyntaxExtension::ProcMacro {\n                 expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: true,\n+                allow_internal_unstable: Some(vec![\n+                    Symbol::intern(\"proc_macro_def_site\"),\n+                ].into()),\n                 edition: data.root.edition,\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));"}, {"sha": "c553398b9b1c59a7151758f1d0bbbc23ae3d1f4c", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -909,7 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if self.span.allows_unstable() {\n+                                    if self.span.allows_unstable(&feature.as_str()) {\n                                         // `allow_internal_unstable` can make such calls stable.\n                                         is_const_fn = true;\n                                     } else {"}, {"sha": "2da520d39694852baad4304922643b830d492005", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -110,8 +110,8 @@ impl<'a> Registry<'a> {\n                     edition,\n                 }\n             }\n-            IdentTT(ext, _, allow_internal_unstable) => {\n-                IdentTT(ext, Some(self.krate_span), allow_internal_unstable)\n+            IdentTT { expander, span: _, allow_internal_unstable } => {\n+                IdentTT { expander, span: Some(self.krate_span), allow_internal_unstable }\n             }\n             _ => extension,\n         }));\n@@ -126,7 +126,7 @@ impl<'a> Registry<'a> {\n         self.register_syntax_extension(Symbol::intern(name), NormalTT {\n             expander: Box::new(expander),\n             def_info: None,\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             unstable_feature: None,"}, {"sha": "506b6d4e8e0a84c3216a283f524b75d07fc0503b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -53,7 +53,8 @@\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(__rust_unstable_column, libstd_sys_internals))]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n@@ -111,7 +112,8 @@ macro_rules! panic {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(print_internals))]\n macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n@@ -143,7 +145,8 @@ macro_rules! print {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(print_internals, format_args_nl))]\n macro_rules! println {\n     () => (print!(\"\\n\"));\n     ($($arg:tt)*) => ({\n@@ -174,7 +177,8 @@ macro_rules! println {\n /// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(print_internals))]\n macro_rules! eprint {\n     ($($arg:tt)*) => ($crate::io::_eprint(format_args!($($arg)*)));\n }\n@@ -202,7 +206,8 @@ macro_rules! eprint {\n /// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(print_internals, format_args_nl))]\n macro_rules! eprintln {\n     () => (eprint!(\"\\n\"));\n     ($($arg:tt)*) => ({\n@@ -325,7 +330,8 @@ macro_rules! dbg {\n /// A macro to await on an async call.\n #[macro_export]\n #[unstable(feature = \"await_macro\", issue = \"50547\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(gen_future, generators))]\n #[allow_internal_unsafe]\n macro_rules! await {\n     ($e:expr) => { {"}, {"sha": "a8843549b8abcb7cb608bf35dadd8abb6deeed67", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -279,6 +279,9 @@ use self::select::StartResult;\n use self::select::StartResult::*;\n use self::blocking::SignalToken;\n \n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod select_tests;\n+\n mod blocking;\n mod oneshot;\n mod select;"}, {"sha": "e34fc5487cf90dd36d374eecec9314988b527e8b", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 415, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -158,7 +158,7 @@ impl Select {\n     }\n \n     /// Helper method for skipping the preflight checks during testing\n-    fn wait2(&self, do_preflight_checks: bool) -> usize {\n+    pub(super) fn wait2(&self, do_preflight_checks: bool) -> usize {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all receivers in the set ahead of time,\n         // so this method shouldn't really have to iterate over all of them yet\n@@ -352,417 +352,3 @@ impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n         f.debug_struct(\"Handle\").finish()\n     }\n }\n-\n-#[allow(unused_imports)]\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use thread;\n-    use sync::mpsc::*;\n-\n-    // Don't use the libstd version so we can pull in the right Select structure\n-    // (std::comm points at the wrong one)\n-    macro_rules! select {\n-        (\n-            $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-        ) => ({\n-            let sel = Select::new();\n-            $( let mut $rx = sel.handle(&$rx); )+\n-            unsafe {\n-                $( $rx.add(); )+\n-            }\n-            let ret = sel.wait();\n-            $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-            { unreachable!() }\n-        })\n-    }\n-\n-    #[test]\n-    fn smoke() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        tx1.send(1).unwrap();\n-        select! {\n-            foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n-            _bar = rx2.recv() => { panic!() }\n-        }\n-        tx2.send(2).unwrap();\n-        select! {\n-            _foo = rx1.recv() => { panic!() },\n-            bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n-        }\n-        drop(tx1);\n-        select! {\n-            foo = rx1.recv() => { assert!(foo.is_err()); },\n-            _bar = rx2.recv() => { panic!() }\n-        }\n-        drop(tx2);\n-        select! {\n-            bar = rx2.recv() => { assert!(bar.is_err()); }\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke2() {\n-        let (_tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (_tx3, rx3) = channel::<i32>();\n-        let (_tx4, rx4) = channel::<i32>();\n-        let (tx5, rx5) = channel::<i32>();\n-        tx5.send(4).unwrap();\n-        select! {\n-            _foo = rx1.recv() => { panic!(\"1\") },\n-            _foo = rx2.recv() => { panic!(\"2\") },\n-            _foo = rx3.recv() => { panic!(\"3\") },\n-            _foo = rx4.recv() => { panic!(\"4\") },\n-            foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n-        }\n-    }\n-\n-    #[test]\n-    fn closed() {\n-        let (_tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        drop(tx2);\n-\n-        select! {\n-            _a1 = rx1.recv() => { panic!() },\n-            a2 = rx2.recv() => { assert!(a2.is_err()); }\n-        }\n-    }\n-\n-    #[test]\n-    fn unblocks() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<i32>();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..20 { thread::yield_now(); }\n-            tx1.send(1).unwrap();\n-            rx3.recv().unwrap();\n-            for _ in 0..20 { thread::yield_now(); }\n-        });\n-\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            _b = rx2.recv() => { panic!() }\n-        }\n-        tx3.send(1).unwrap();\n-        select! {\n-            a = rx1.recv() => { assert!(a.is_err()) },\n-            _b = rx2.recv() => { panic!() }\n-        }\n-    }\n-\n-    #[test]\n-    fn both_ready() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..20 { thread::yield_now(); }\n-            tx1.send(1).unwrap();\n-            tx2.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-        }\n-        select! {\n-            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-        }\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[test]\n-    fn stress() {\n-        const AMT: i32 = 10000;\n-        let (tx1, rx1) = channel::<i32>();\n-        let (tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            for i in 0..AMT {\n-                if i % 2 == 0 {\n-                    tx1.send(i).unwrap();\n-                } else {\n-                    tx2.send(i).unwrap();\n-                }\n-                rx3.recv().unwrap();\n-            }\n-        });\n-\n-        for i in 0..AMT {\n-            select! {\n-                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n-                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n-            }\n-            tx3.send(()).unwrap();\n-        }\n-    }\n-\n-    #[allow(unused_must_use)]\n-    #[test]\n-    fn cloning() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            rx3.recv().unwrap();\n-            tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-            tx1.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        tx3.send(()).unwrap();\n-        select! {\n-            _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => panic!()\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[allow(unused_must_use)]\n-    #[test]\n-    fn cloning2() {\n-        let (tx1, rx1) = channel::<i32>();\n-        let (_tx2, rx2) = channel::<i32>();\n-        let (tx3, rx3) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            rx3.recv().unwrap();\n-            tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-            tx1.send(2).unwrap();\n-            rx3.recv().unwrap();\n-        });\n-\n-        tx3.send(()).unwrap();\n-        select! {\n-            _i1 = rx1.recv() => {},\n-            _i2 = rx2.recv() => panic!()\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-\n-    #[test]\n-    fn cloning3() {\n-        let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<()>();\n-        let (tx3, rx3) = channel::<()>();\n-        let _t = thread::spawn(move|| {\n-            let s = Select::new();\n-            let mut h1 = s.handle(&rx1);\n-            let mut h2 = s.handle(&rx2);\n-            unsafe { h2.add(); }\n-            unsafe { h1.add(); }\n-            assert_eq!(s.wait(), h2.id);\n-            tx3.send(()).unwrap();\n-        });\n-\n-        for _ in 0..1000 { thread::yield_now(); }\n-        drop(tx1.clone());\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn preflight1() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight2() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight3() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        select! {\n-            _n = rx.recv() => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn preflight4() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight5() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight6() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight7() {\n-        let (tx, rx) = channel::<()>();\n-        drop(tx);\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight8() {\n-        let (tx, rx) = channel();\n-        tx.send(()).unwrap();\n-        drop(tx);\n-        rx.recv().unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn preflight9() {\n-        let (tx, rx) = channel();\n-        drop(tx.clone());\n-        tx.send(()).unwrap();\n-        drop(tx);\n-        rx.recv().unwrap();\n-        let s = Select::new();\n-        let mut h = s.handle(&rx);\n-        unsafe { h.add(); }\n-        assert_eq!(s.wait2(false), h.id);\n-    }\n-\n-    #[test]\n-    fn oneshot_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn stream_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        tx1.send(()).unwrap();\n-        tx1.send(()).unwrap();\n-        rx1.recv().unwrap();\n-        rx1.recv().unwrap();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn shared_data_waiting() {\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        drop(tx1.clone());\n-        tx1.send(()).unwrap();\n-        rx1.recv().unwrap();\n-        let _t = thread::spawn(move|| {\n-            select! {\n-                _n = rx1.recv() => {}\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        for _ in 0..100 { thread::yield_now() }\n-        tx1.send(()).unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn sync1() {\n-        let (tx, rx) = sync_channel::<i32>(1);\n-        tx.send(1).unwrap();\n-        select! {\n-            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-        }\n-    }\n-\n-    #[test]\n-    fn sync2() {\n-        let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..100 { thread::yield_now() }\n-            tx.send(1).unwrap();\n-        });\n-        select! {\n-            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-        }\n-    }\n-\n-    #[test]\n-    fn sync3() {\n-        let (tx1, rx1) = sync_channel::<i32>(0);\n-        let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n-        let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n-        let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n-        select! {\n-            n = rx1.recv() => {\n-                let n = n.unwrap();\n-                assert_eq!(n, 1);\n-                assert_eq!(rx2.recv().unwrap(), 2);\n-            },\n-            n = rx2.recv() => {\n-                let n = n.unwrap();\n-                assert_eq!(n, 2);\n-                assert_eq!(rx1.recv().unwrap(), 1);\n-            }\n-        }\n-    }\n-}"}, {"sha": "be048511caaec9a6e2773c4fcea3c57aaf8c7cc1", "filename": "src/libstd/sync/mpsc/select_tests.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -0,0 +1,413 @@\n+#![allow(unused_imports)]\n+\n+/// This file exists to hack around https://github.com/rust-lang/rust/issues/47238\n+\n+use thread;\n+use sync::mpsc::*;\n+\n+// Don't use the libstd version so we can pull in the right Select structure\n+// (std::comm points at the wrong one)\n+macro_rules! select {\n+    (\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        let sel = Select::new();\n+        $( let mut $rx = sel.handle(&$rx); )+\n+        unsafe {\n+            $( $rx.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}\n+\n+#[test]\n+fn smoke() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    tx1.send(1).unwrap();\n+    select! {\n+        foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n+        _bar = rx2.recv() => { panic!() }\n+    }\n+    tx2.send(2).unwrap();\n+    select! {\n+        _foo = rx1.recv() => { panic!() },\n+        bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n+    }\n+    drop(tx1);\n+    select! {\n+        foo = rx1.recv() => { assert!(foo.is_err()); },\n+        _bar = rx2.recv() => { panic!() }\n+    }\n+    drop(tx2);\n+    select! {\n+        bar = rx2.recv() => { assert!(bar.is_err()); }\n+    }\n+}\n+\n+#[test]\n+fn smoke2() {\n+    let (_tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (_tx3, rx3) = channel::<i32>();\n+    let (_tx4, rx4) = channel::<i32>();\n+    let (tx5, rx5) = channel::<i32>();\n+    tx5.send(4).unwrap();\n+    select! {\n+        _foo = rx1.recv() => { panic!(\"1\") },\n+        _foo = rx2.recv() => { panic!(\"2\") },\n+        _foo = rx3.recv() => { panic!(\"3\") },\n+        _foo = rx4.recv() => { panic!(\"4\") },\n+        foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n+    }\n+}\n+\n+#[test]\n+fn closed() {\n+    let (_tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    drop(tx2);\n+\n+    select! {\n+        _a1 = rx1.recv() => { panic!() },\n+        a2 = rx2.recv() => { assert!(a2.is_err()); }\n+    }\n+}\n+\n+#[test]\n+fn unblocks() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<i32>();\n+\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..20 { thread::yield_now(); }\n+        tx1.send(1).unwrap();\n+        rx3.recv().unwrap();\n+        for _ in 0..20 { thread::yield_now(); }\n+    });\n+\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        _b = rx2.recv() => { panic!() }\n+    }\n+    tx3.send(1).unwrap();\n+    select! {\n+        a = rx1.recv() => { assert!(a.is_err()) },\n+        _b = rx2.recv() => { panic!() }\n+    }\n+}\n+\n+#[test]\n+fn both_ready() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..20 { thread::yield_now(); }\n+        tx1.send(1).unwrap();\n+        tx2.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n+    }\n+    select! {\n+        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n+    }\n+    assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+    assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n+    tx3.send(()).unwrap();\n+}\n+\n+#[test]\n+fn stress() {\n+    const AMT: i32 = 10000;\n+    let (tx1, rx1) = channel::<i32>();\n+    let (tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        for i in 0..AMT {\n+            if i % 2 == 0 {\n+                tx1.send(i).unwrap();\n+            } else {\n+                tx2.send(i).unwrap();\n+            }\n+            rx3.recv().unwrap();\n+        }\n+    });\n+\n+    for i in 0..AMT {\n+        select! {\n+            i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n+            i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n+        }\n+        tx3.send(()).unwrap();\n+    }\n+}\n+\n+#[allow(unused_must_use)]\n+#[test]\n+fn cloning() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        rx3.recv().unwrap();\n+        tx1.clone();\n+        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+        tx1.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    tx3.send(()).unwrap();\n+    select! {\n+        _i1 = rx1.recv() => {},\n+        _i2 = rx2.recv() => panic!()\n+    }\n+    tx3.send(()).unwrap();\n+}\n+\n+#[allow(unused_must_use)]\n+#[test]\n+fn cloning2() {\n+    let (tx1, rx1) = channel::<i32>();\n+    let (_tx2, rx2) = channel::<i32>();\n+    let (tx3, rx3) = channel::<()>();\n+\n+    let _t = thread::spawn(move|| {\n+        rx3.recv().unwrap();\n+        tx1.clone();\n+        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+        tx1.send(2).unwrap();\n+        rx3.recv().unwrap();\n+    });\n+\n+    tx3.send(()).unwrap();\n+    select! {\n+        _i1 = rx1.recv() => {},\n+        _i2 = rx2.recv() => panic!()\n+    }\n+    tx3.send(()).unwrap();\n+}\n+\n+#[test]\n+fn cloning3() {\n+    let (tx1, rx1) = channel::<()>();\n+    let (tx2, rx2) = channel::<()>();\n+    let (tx3, rx3) = channel::<()>();\n+    let _t = thread::spawn(move|| {\n+        let s = Select::new();\n+        let mut h1 = s.handle(&rx1);\n+        let mut h2 = s.handle(&rx2);\n+        unsafe { h2.add(); }\n+        unsafe { h1.add(); }\n+        assert_eq!(s.wait(), h2.id());\n+        tx3.send(()).unwrap();\n+    });\n+\n+    for _ in 0..1000 { thread::yield_now(); }\n+    drop(tx1.clone());\n+    tx2.send(()).unwrap();\n+    rx3.recv().unwrap();\n+}\n+\n+#[test]\n+fn preflight1() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight2() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight3() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    select! {\n+        _n = rx.recv() => {}\n+    }\n+}\n+\n+#[test]\n+fn preflight4() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn preflight5() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn preflight6() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn preflight7() {\n+    let (tx, rx) = channel::<()>();\n+    drop(tx);\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn preflight8() {\n+    let (tx, rx) = channel();\n+    tx.send(()).unwrap();\n+    drop(tx);\n+    rx.recv().unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn preflight9() {\n+    let (tx, rx) = channel();\n+    drop(tx.clone());\n+    tx.send(()).unwrap();\n+    drop(tx);\n+    rx.recv().unwrap();\n+    let s = Select::new();\n+    let mut h = s.handle(&rx);\n+    unsafe { h.add(); }\n+    assert_eq!(s.wait2(false), h.id());\n+}\n+\n+#[test]\n+fn oneshot_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn stream_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    tx1.send(()).unwrap();\n+    tx1.send(()).unwrap();\n+    rx1.recv().unwrap();\n+    rx1.recv().unwrap();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn shared_data_waiting() {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    drop(tx1.clone());\n+    tx1.send(()).unwrap();\n+    rx1.recv().unwrap();\n+    let _t = thread::spawn(move|| {\n+        select! {\n+            _n = rx1.recv() => {}\n+        }\n+        tx2.send(()).unwrap();\n+    });\n+\n+    for _ in 0..100 { thread::yield_now() }\n+    tx1.send(()).unwrap();\n+    rx2.recv().unwrap();\n+}\n+\n+#[test]\n+fn sync1() {\n+    let (tx, rx) = sync_channel::<i32>(1);\n+    tx.send(1).unwrap();\n+    select! {\n+        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n+    }\n+}\n+\n+#[test]\n+fn sync2() {\n+    let (tx, rx) = sync_channel::<i32>(0);\n+    let _t = thread::spawn(move|| {\n+        for _ in 0..100 { thread::yield_now() }\n+        tx.send(1).unwrap();\n+    });\n+    select! {\n+        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n+    }\n+}\n+\n+#[test]\n+fn sync3() {\n+    let (tx1, rx1) = sync_channel::<i32>(0);\n+    let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n+    let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n+    let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n+    select! {\n+        n = rx1.recv() => {\n+            let n = n.unwrap();\n+            assert_eq!(n, 1);\n+            assert_eq!(rx2.recv().unwrap(), 2);\n+        },\n+        n = rx2.recv() => {\n+            let n = n.unwrap();\n+            assert_eq!(n, 2);\n+            assert_eq!(rx1.recv().unwrap(), 1);\n+        }\n+    }\n+}"}, {"sha": "8207709e1f9f00ca07de1b6ad7bb53a110b6d589", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -126,7 +126,8 @@ impl<T: 'static> fmt::Debug for LocalKey<T> {\n /// [`std::thread::LocalKey`]: ../std/thread/struct.LocalKey.html\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(thread_local_internals))]\n macro_rules! thread_local {\n     // empty (base case for the recursion)\n     () => {};\n@@ -148,7 +149,10 @@ macro_rules! thread_local {\n            reason = \"should not be necessary\",\n            issue = \"0\")]\n #[macro_export]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(\n+    thread_local_internals, cfg_target_thread_local, thread_local,\n+))]\n #[allow_internal_unsafe]\n macro_rules! __thread_local_inner {\n     (@key $(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {"}, {"sha": "f7225810aca7450de9cf4c85d005d838c61e011d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -621,7 +621,8 @@ pub enum SyntaxExtension {\n     /// A function-like procedural macro. TokenStream -> TokenStream.\n     ProcMacro {\n         expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        allow_internal_unstable: bool,\n+        /// Whitelist of unstable features that are treated as stable inside this macro\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n         edition: Edition,\n     },\n \n@@ -638,8 +639,10 @@ pub enum SyntaxExtension {\n         expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         /// Whether the contents of the macro can\n-        /// directly use `#[unstable]` things (true == yes).\n-        allow_internal_unstable: bool,\n+        /// directly use `#[unstable]` things.\n+        ///\n+        /// Only allows things that require a feature gate in the given whitelist\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n         /// Whether the contents of the macro can use `unsafe`\n         /// without triggering the `unsafe_code` lint.\n         allow_internal_unsafe: bool,\n@@ -654,8 +657,11 @@ pub enum SyntaxExtension {\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n-    ///\n-    IdentTT(Box<dyn IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n+    IdentTT {\n+        expander: Box<dyn IdentMacroExpander + sync::Sync + sync::Send>,\n+        span: Option<Span>,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    },\n \n     /// An attribute-like procedural macro. TokenStream -> TokenStream.\n     /// The input is the annotated item.\n@@ -682,7 +688,7 @@ impl SyntaxExtension {\n         match *self {\n             SyntaxExtension::DeclMacro { .. } |\n             SyntaxExtension::NormalTT { .. } |\n-            SyntaxExtension::IdentTT(..) |\n+            SyntaxExtension::IdentTT { .. } |\n             SyntaxExtension::ProcMacro { .. } =>\n                 MacroKind::Bang,\n             SyntaxExtension::NonMacroAttr { .. } |\n@@ -716,7 +722,7 @@ impl SyntaxExtension {\n             SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n             // Unstable legacy stuff\n             SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::IdentTT(..) |\n+            SyntaxExtension::IdentTT { .. } |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n             SyntaxExtension::BuiltinDerive(..) => hygiene::default_edition(),"}, {"sha": "6df369133d01dd99630a838bc672ed6e3abe2000", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -58,7 +58,10 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         call_site: span,\n         def_site: None,\n         format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: true,\n+        allow_internal_unstable: Some(vec![\n+            Symbol::intern(\"rustc_attrs\"),\n+            Symbol::intern(\"structural_match\"),\n+        ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: hygiene::default_edition(),"}, {"sha": "60359531b7f63987d2adde8dc167c2c19e61556b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -558,7 +558,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             call_site: attr.span,\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(&attr.path.to_string())),\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: ext.edition(),\n@@ -725,7 +725,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n                 if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n-                    && !span.allows_unstable() && this.cx.ecfg.features.map_or(true, |feats| {\n+                    && !span.allows_unstable(&feature.as_str())\n+                    && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n                     !feats.declared_lib_features.iter().any(|&(feat, _)| feat == feature)\n                 }) {\n@@ -757,7 +758,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let opt_expanded = match *ext {\n             DeclMacro { ref expander, def_info, edition, .. } => {\n                 if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    false, false, false, None,\n+                                                                    None, false, false, None,\n                                                                     edition) {\n                     dummy_span\n                 } else {\n@@ -768,14 +769,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             NormalTT {\n                 ref expander,\n                 def_info,\n-                allow_internal_unstable,\n+                ref allow_internal_unstable,\n                 allow_internal_unsafe,\n                 local_inner_macros,\n                 unstable_feature,\n                 edition,\n             } => {\n                 if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    allow_internal_unstable,\n+                                                                    allow_internal_unstable.clone(),\n                                                                     allow_internal_unsafe,\n                                                                     local_inner_macros,\n                                                                     unstable_feature,\n@@ -791,7 +792,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n+            IdentTT { ref expander, span: tt_span, ref allow_internal_unstable } => {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", path));\n@@ -802,7 +803,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         call_site: span,\n                         def_site: tt_span,\n                         format: macro_bang_format(path),\n-                        allow_internal_unstable,\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n                         edition: hygiene::default_edition(),\n@@ -827,7 +828,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::ProcMacro { ref expander, allow_internal_unstable, edition } => {\n+            SyntaxExtension::ProcMacro { ref expander, ref allow_internal_unstable, edition } => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -843,7 +844,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         def_site: None,\n                         format: macro_bang_format(path),\n                         // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable,\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n                         edition,\n@@ -918,7 +919,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             call_site: span,\n             def_site: None,\n             format: MacroAttribute(pretty_name),\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: ext.edition(),\n@@ -937,7 +938,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             BuiltinDerive(func) => {\n-                expn_info.allow_internal_unstable = true;\n+                expn_info.allow_internal_unstable = Some(vec![\n+                    Symbol::intern(\"rustc_attrs\"),\n+                    Symbol::intern(\"derive_clone_copy\"),\n+                    Symbol::intern(\"derive_eq\"),\n+                    Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n+                ].into());\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();"}, {"sha": "549de1628eb550e5979d72767cc150a740e82ced", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -44,7 +44,7 @@ pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTr\n /* __rust_unstable_column!(): expands to the current column number */\n pub fn expand_column_gated(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n-    if sp.allows_unstable() {\n+    if sp.allows_unstable(\"__rust_unstable_column\") {\n         expand_column(cx, sp, tts)\n     } else {\n         cx.span_fatal(sp, \"the __rust_unstable_column macro is unstable\");"}, {"sha": "cc5531c4010462ca5a72c095edb35f95a4fcf114", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -376,7 +376,24 @@ pub fn compile(\n     });\n \n     if body.legacy {\n-        let allow_internal_unstable = attr::contains_name(&def.attrs, \"allow_internal_unstable\");\n+        let allow_internal_unstable = attr::find_by_name(&def.attrs, \"allow_internal_unstable\")\n+            .map(|attr| attr\n+                .meta_item_list()\n+                .map(|list| list.iter()\n+                    .map(|it| it.name().unwrap_or_else(|| sess.span_diagnostic.span_bug(\n+                        it.span, \"allow internal unstable expects feature names\",\n+                    )))\n+                    .collect::<Vec<Symbol>>().into()\n+                )\n+                .unwrap_or_else(|| {\n+                    sess.span_diagnostic.span_warn(\n+                        attr.span, \"allow_internal_unstable expects list of feature names. In the \\\n+                        future this will become a hard error. Please use `allow_internal_unstable(\\\n+                        foo, bar)` to only allow the `foo` and `bar` features\",\n+                    );\n+                    vec![Symbol::intern(\"allow_internal_unstable_backcompat_hack\")].into()\n+                })\n+            );\n         let allow_internal_unsafe = attr::contains_name(&def.attrs, \"allow_internal_unsafe\");\n         let mut local_inner_macros = false;\n         if let Some(macro_export) = attr::find_by_name(&def.attrs, \"macro_export\") {"}, {"sha": "4d24c7bfb40387cb9ff06169a51613781de99d9b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1091,7 +1091,8 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n                                               stable\",\n                                              cfg_fn!(profiler_runtime))),\n \n-    (\"allow_internal_unstable\", Normal, template!(Word), Gated(Stability::Unstable,\n+    (\"allow_internal_unstable\", Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+                                              Gated(Stability::Unstable,\n                                               \"allow_internal_unstable\",\n                                               EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n                                               cfg_fn!(allow_internal_unstable))),\n@@ -1199,7 +1200,7 @@ pub const BUILTIN_ATTRIBUTES: &[(&str, AttributeType, AttributeTemplate, Attribu\n     (\"proc_macro\", Normal, template!(Word), Ungated),\n \n     (\"rustc_proc_macro_decls\", Normal, template!(Word), Gated(Stability::Unstable,\n-                                             \"rustc_proc_macro_decls\",\n+                                             \"rustc_attrs\",\n                                              \"used internally by rustc\",\n                                              cfg_fn!(rustc_attrs))),\n \n@@ -1284,7 +1285,7 @@ impl GatedCfg {\n \n     pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) && !self.span.allows_unstable() {\n+        if !has_feature(features) && !self.span.allows_unstable(feature) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n             emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n         }\n@@ -1303,7 +1304,7 @@ macro_rules! gate_feature_fn {\n              name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n-        if !has_feature && !span.allows_unstable() {\n+        if !has_feature && !span.allows_unstable($name) {\n             leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n                 .emit();\n         }\n@@ -1328,7 +1329,11 @@ impl<'a> Context<'a> {\n         for &(n, ty, _template, ref gateage) in BUILTIN_ATTRIBUTES {\n             if name == n {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n-                    gate_feature_fn!(self, has_feature, attr.span, name, desc, GateStrength::Hard);\n+                    if !attr.span.allows_unstable(name) {\n+                        gate_feature_fn!(\n+                            self, has_feature, attr.span, name, desc, GateStrength::Hard\n+                        );\n+                    }\n                 } else if name == \"doc\" {\n                     if let Some(content) = attr.meta_item_list() {\n                         if content.iter().any(|c| c.check_name(\"include\")) {\n@@ -1493,13 +1498,13 @@ struct PostExpansionVisitor<'a> {\n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable() {\n+        if !span.allows_unstable(stringify!($feature)) {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n     }};\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable() {\n+        if !span.allows_unstable(stringify!($feature)) {\n             gate_feature!(cx.context, $feature, span, $explain, $level)\n         }\n     }}\n@@ -1610,10 +1615,8 @@ impl<'a> PostExpansionVisitor<'a> {\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if !attr.span.allows_unstable() {\n-            // check for gated attributes\n-            self.context.check_attribute(attr, false);\n-        }\n+        // check for gated attributes\n+        self.context.check_attribute(attr, false);\n \n         if attr.check_name(\"doc\") {\n             if let Some(content) = attr.meta_item_list() {"}, {"sha": "b9758bd655c155ea92a15d048c7ae0e3515fdbac", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -20,7 +20,9 @@ fn ignored_span(sp: Span) -> Span {\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: true,\n+        allow_internal_unstable: Some(vec![\n+            Symbol::intern(\"prelude_import\"),\n+        ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: hygiene::default_edition(),"}, {"sha": "f45bf034ba2f89cd5603c198266ad543596cb5ec", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -285,7 +285,11 @@ fn generate_test_harness(sess: &ParseSess,\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(Symbol::intern(\"test_case\")),\n-        allow_internal_unstable: true,\n+        allow_internal_unstable: Some(vec![\n+            Symbol::intern(\"main\"),\n+            Symbol::intern(\"test\"),\n+            Symbol::intern(\"rustc_attrs\"),\n+        ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: hygiene::default_edition(),"}, {"sha": "fff54814a38c40cd814197d03415c86e8c605661", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -136,11 +136,16 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    if cx.current_expansion.mark.expn_info().unwrap().allow_internal_unstable {\n+    let intrinsic_allowed_via_allow_internal_unstable = cx\n+        .current_expansion.mark.expn_info().unwrap()\n+        .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n+            s == \"core_intrinsics\"\n+        ));\n+    if intrinsic_allowed_via_allow_internal_unstable {\n         span = span.with_ctxt(cx.backtrace());\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.allow_internal_unstable = true;\n+        info.allow_internal_unstable = Some(vec![Symbol::intern(\"core_intrinsics\")].into());\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n         span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));"}, {"sha": "1b17fc0d040a5e12110366557bb6e48564850a1c", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -711,7 +711,7 @@ pub fn expand_format_args_nl<'cx>(\n     //if !ecx.ecfg.enable_allow_internal_unstable() {\n \n     // For some reason, the only one that actually works for `println` is the first check\n-    if !sp.allows_unstable()   // the enclosing span is marked as `#[allow_insternal_unsable]`\n+    if !sp.allows_unstable(\"format_args_nl\") // the span is marked as `#[allow_insternal_unsable]`\n         && !ecx.ecfg.enable_allow_internal_unstable()  // NOTE: when is this enabled?\n         && !ecx.ecfg.enable_format_args_nl()  // enabled using `#[feature(format_args_nl]`\n     {"}, {"sha": "05c8084a51ed2451a26160fe959813afcf4915c4", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -61,7 +61,7 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                      NormalTT {\n                         expander: Box::new($f as MacroExpanderFn),\n                         def_info: None,\n-                        allow_internal_unstable: false,\n+                        allow_internal_unstable: None,\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n                         unstable_feature: None,\n@@ -104,7 +104,9 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n              NormalTT {\n                 expander: Box::new(format::expand_format_args),\n                 def_info: None,\n-                allow_internal_unstable: true,\n+                allow_internal_unstable: Some(vec![\n+                    Symbol::intern(\"fmt_internals\"),\n+                ].into()),\n                 allow_internal_unsafe: false,\n                 local_inner_macros: false,\n                 unstable_feature: None,\n@@ -114,7 +116,9 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n              NormalTT {\n                  expander: Box::new(format::expand_format_args_nl),\n                  def_info: None,\n-                 allow_internal_unstable: true,\n+                 allow_internal_unstable: Some(vec![\n+                     Symbol::intern(\"fmt_internals\"),\n+                 ].into()),\n                  allow_internal_unsafe: false,\n                  local_inner_macros: false,\n                  unstable_feature: None,"}, {"sha": "5730081ce018a1e98c9ea0082be478e565751b84", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -333,7 +333,10 @@ fn mk_decls(\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n-        allow_internal_unstable: true,\n+        allow_internal_unstable: Some(vec![\n+            Symbol::intern(\"rustc_attrs\"),\n+            Symbol::intern(\"proc_macro_internals\"),\n+        ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: hygiene::default_edition(),"}, {"sha": "371862465487b3f2cb5d7e13c53fe06f122d1341", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -66,7 +66,10 @@ pub fn expand_test_or_bench(\n             call_site: DUMMY_SP,\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(\"test\")),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable: Some(vec![\n+                Symbol::intern(\"rustc_attrs\"),\n+                Symbol::intern(\"test\"),\n+            ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: hygiene::default_edition(),"}, {"sha": "1ed1ab0a07b9683b4d25c7359ffe7aa57a5f737f", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -41,7 +41,10 @@ pub fn expand(\n             call_site: DUMMY_SP,\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(\"test_case\")),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable: Some(vec![\n+                Symbol::intern(\"test\"),\n+                Symbol::intern(\"rustc_attrs\"),\n+            ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: hygiene::default_edition(),"}, {"sha": "d5c0a2ca85f641fdbe1182809845e770833af7bb", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -12,6 +12,7 @@ use crate::symbol::{keywords, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n use std::{fmt, mem};\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n@@ -550,10 +551,10 @@ pub struct ExpnInfo {\n     pub def_site: Option<Span>,\n     /// The format with which the macro was invoked.\n     pub format: ExpnFormat,\n-    /// Whether the macro is allowed to use #[unstable]/feature-gated\n-    /// features internally without forcing the whole crate to opt-in\n+    /// List of #[unstable]/feature-gated features that the macro is allowed to use\n+    /// internally without forcing the whole crate to opt-in\n     /// to them.\n-    pub allow_internal_unstable: bool,\n+    pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     /// Whether the macro is allowed to use `unsafe` internally\n     /// even if the user crate has `#![forbid(unsafe_code)]`.\n     pub allow_internal_unsafe: bool,"}, {"sha": "042005ea538899eca3b795e57b915c4d12f4ca2b", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -386,9 +386,13 @@ impl Span {\n     /// Check if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n-    pub fn allows_unstable(&self) -> bool {\n+    pub fn allows_unstable(&self, feature: &str) -> bool {\n         match self.ctxt().outer().expn_info() {\n-            Some(info) => info.allow_internal_unstable,\n+            Some(info) => info\n+                .allow_internal_unstable\n+                .map_or(false, |features| features.iter().any(|&f|\n+                    f == feature || f == \"allow_internal_unstable_backcompat_hack\"\n+                )),\n             None => false,\n         }\n     }"}, {"sha": "309acb25184a8f54b6c898c8bc19d2e7f4b60c65", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -43,7 +43,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         NormalTT {\n             expander: Box::new(Expander { args: args, }),\n             def_info: None,\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             unstable_feature: None,"}, {"sha": "ee48f9516299abe838ee657351b0950132532cb8", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable-nested-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -5,7 +5,7 @@\n macro_rules! bar {\n     () => {\n         // more layers don't help:\n-        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+        #[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n         macro_rules! baz {\n             () => {}\n         }"}, {"sha": "802c74239d71933e9a2981c5a3350d997e06a1e6", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable-nested-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: allow_internal_unstable side-steps feature gating and stability checks\n   --> $DIR/feature-gate-allow-internal-unstable-nested-macro.rs:8:9\n    |\n-LL |         #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         #[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | bar!();\n    | ------- in this macro invocation"}, {"sha": "ede969097d5ae2209b8f5c6cfbc0c766b68bbcf9", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,7 +1,7 @@\n // checks that this attribute is caught on non-macro items.\n // this needs a different test since this is done after expansion\n \n-#[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+#[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n struct S;\n \n fn main() {}"}, {"sha": "d619f1e3239cadb0254241d29f247bfbafe76f81", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-struct.stderr?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: allow_internal_unstable side-steps feature gating and stability checks\n   --> $DIR/feature-gate-allow-internal-unstable-struct.rs:4:1\n    |\n-LL | #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(allow_internal_unstable)] to the crate attributes to enable\n "}, {"sha": "0a1b6acd9bff25e254897439a5ded1180f101ed6", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,6 +1,6 @@\n #![allow(unused_macros)]\n \n-#[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+#[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n macro_rules! foo {\n     () => {}\n }"}, {"sha": "aa4f6648c4fbd354d44807d4ec69db3a720c3159", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable.stderr?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: allow_internal_unstable side-steps feature gating and stability checks\n   --> $DIR/feature-gate-allow-internal-unstable.rs:3:1\n    |\n-LL | #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[allow_internal_unstable()] //~ ERROR allow_internal_unstable side-steps\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(allow_internal_unstable)] to the crate attributes to enable\n "}, {"sha": "7c79dcb752272e169081497e2cf9f993dd09c5cc", "filename": "src/test/ui/internal/auxiliary/internal_unstable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -23,14 +23,14 @@ pub struct Bar {\n }\n \n #[stable(feature = \"stable\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[allow_internal_unstable(function)]\n #[macro_export]\n macro_rules! call_unstable_allow {\n     () => { $crate::unstable() }\n }\n \n #[stable(feature = \"stable\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[allow_internal_unstable(struct_field)]\n #[macro_export]\n macro_rules! construct_unstable_allow {\n     ($e: expr) => {\n@@ -39,21 +39,21 @@ macro_rules! construct_unstable_allow {\n }\n \n #[stable(feature = \"stable\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[allow_internal_unstable(method)]\n #[macro_export]\n macro_rules! call_method_allow {\n     ($e: expr) => { $e.method() }\n }\n \n #[stable(feature = \"stable\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[allow_internal_unstable(struct_field, struct2_field)]\n #[macro_export]\n macro_rules! access_field_allow {\n     ($e: expr) => { $e.x }\n }\n \n #[stable(feature = \"stable\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[allow_internal_unstable()]\n #[macro_export]\n macro_rules! pass_through_allow {\n     ($e: expr) => { $e }"}, {"sha": "e09a5d89172e81d329a8a9f8fa79de385668b551", "filename": "src/test/ui/internal/internal-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -13,7 +13,7 @@ macro_rules! foo {\n     }}\n }\n \n-#[allow_internal_unstable]\n+#[allow_internal_unstable(function)]\n macro_rules! bar {\n     ($e: expr) => {{\n         foo!($e,"}, {"sha": "ed2218f09d26b3ad12c58681e94245a65cef42d5", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84e7976423bb910bb5eb5eecffc7e33a897a97f/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=c84e7976423bb910bb5eb5eecffc7e33a897a97f", "patch": "@@ -58,6 +58,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libstd/sys_common/net.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test crate needs it.\n     \"src/libtest\", // Probably should defer to unstable `std::sys` APIs.\n+    \"src/libstd/sync/mpsc\", // some tests are only run on non-emscripten\n \n     // std testing crates, okay for now at least\n     \"src/libcore/tests\","}]}