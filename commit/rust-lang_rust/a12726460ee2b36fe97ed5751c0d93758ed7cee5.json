{"sha": "a12726460ee2b36fe97ed5751c0d93758ed7cee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjcyNjQ2MGVlMmIzNmZlOTdlZDU3NTFjMGQ5Mzc1OGVkN2NlZTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-19T23:08:08Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-23T17:09:21Z"}, "message": "expansion: Rename `Expansion` to `AstFragment`", "tree": {"sha": "c5263fb0a134ddc5c7673a5356a2f4d3368591e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5263fb0a134ddc5c7673a5356a2f4d3368591e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a12726460ee2b36fe97ed5751c0d93758ed7cee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a12726460ee2b36fe97ed5751c0d93758ed7cee5", "html_url": "https://github.com/rust-lang/rust/commit/a12726460ee2b36fe97ed5751c0d93758ed7cee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a12726460ee2b36fe97ed5751c0d93758ed7cee5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c", "html_url": "https://github.com/rust-lang/rust/commit/869fa27d131d3376c3a7b6e1d3a1fb0d1ce20c9c"}], "stats": {"total": 401, "additions": 207, "deletions": 194}, "files": [{"sha": "1c49e8f475302f3b947094c59c5c292cf8610d0d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a12726460ee2b36fe97ed5751c0d93758ed7cee5", "patch": "@@ -23,7 +23,7 @@ use syntax::attr::{self, HasAttrs};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{Expansion, ExpansionKind, Invocation, InvocationKind, find_attr_invoc};\n+use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark, Transparency};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n@@ -187,9 +187,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.whitelisted_legacy_custom_derives.contains(&name)\n     }\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) {\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n+                                            derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n-        self.collect_def_ids(mark, invocation, expansion);\n+        self.collect_def_ids(mark, invocation, fragment);\n \n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n@@ -202,7 +203,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             legacy_scope: LegacyScope::Invocation(invocation),\n             expansion: mark,\n         };\n-        expansion.visit_with(&mut visitor);\n+        fragment.visit_with(&mut visitor);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -396,14 +397,14 @@ impl<'a> Resolver<'a> {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here.\n-                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+                        let dummy_item = placeholder(AstFragmentKind::Items, ast::DUMMY_NODE_ID)\n                             .make_items().pop().unwrap();\n                         let dummy_item = Annotatable::Item(dummy_item);\n                         *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n                             let inert_attr = attr.take().unwrap();\n                             attr::mark_known(&inert_attr);\n                             if self.proc_macro_enabled {\n-                                *attr = find_attr_invoc(&mut attrs);\n+                                *attr = expand::find_attr_invoc(&mut attrs);\n                             }\n                             attrs.push(inert_attr);\n                             attrs\n@@ -769,7 +770,7 @@ impl<'a> Resolver<'a> {\n     fn collect_def_ids(&mut self,\n                        mark: Mark,\n                        invocation: &'a InvocationData<'a>,\n-                       expansion: &Expansion) {\n+                       fragment: &AstFragment) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n         let InvocationData { def_index, .. } = *invocation;\n \n@@ -787,7 +788,7 @@ impl<'a> Resolver<'a> {\n         let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| {\n-            expansion.visit_with(def_collector)\n+            fragment.visit_with(def_collector)\n         });\n     }\n "}, {"sha": "b7f4bc614354599e0ede0d1badf5a7eb8b5d88b0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a12726460ee2b36fe97ed5751c0d93758ed7cee5", "patch": "@@ -16,7 +16,7 @@ use codemap::{self, CodeMap, Spanned, respan};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n-use ext::expand::{self, Expansion, Invocation};\n+use ext::expand::{self, AstFragment, Invocation};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n@@ -697,7 +697,8 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n+                                            derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n@@ -726,7 +727,8 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n-    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n+    fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n+                                            _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}"}, {"sha": "f67ced13a9fdf18eb3a9c19303f1c36aa2674c15", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 159, "deletions": 150, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a12726460ee2b36fe97ed5751c0d93758ed7cee5", "patch": "@@ -40,46 +40,51 @@ use std::mem;\n use std::rc::Rc;\n use std::path::PathBuf;\n \n-macro_rules! expansions {\n+macro_rules! ast_fragments {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n             $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n             $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n+        /// A fragment of AST that can be produced by a single macro expansion.\n+        /// Can also serve as an input and intermediate result for macro expansion operations.\n+        pub enum AstFragment { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+\n+        /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n-        pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n-        pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+        pub enum AstFragmentKind { OptExpr, $( $kind, )*  }\n \n-        impl ExpansionKind {\n+        impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n-                    ExpansionKind::OptExpr => \"expression\",\n-                    $( ExpansionKind::$kind => $kind_name, )*\n+                    AstFragmentKind::OptExpr => \"expression\",\n+                    $( AstFragmentKind::$kind => $kind_name, )*\n                 }\n             }\n \n-            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<Expansion> {\n+            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<AstFragment> {\n                 match self {\n-                    ExpansionKind::OptExpr => result.make_expr().map(Some).map(Expansion::OptExpr),\n-                    $( ExpansionKind::$kind => result.$make().map(Expansion::$kind), )*\n+                    AstFragmentKind::OptExpr =>\n+                        result.make_expr().map(Some).map(AstFragment::OptExpr),\n+                    $( AstFragmentKind::$kind => result.$make().map(AstFragment::$kind), )*\n                 }\n             }\n         }\n \n-        impl Expansion {\n+        impl AstFragment {\n             pub fn make_opt_expr(self) -> Option<P<ast::Expr>> {\n                 match self {\n-                    Expansion::OptExpr(expr) => expr,\n-                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                    AstFragment::OptExpr(expr) => expr,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n             }\n             $( pub fn $make(self) -> $ty {\n                 match self {\n-                    Expansion::$kind(ast) => ast,\n-                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                    AstFragment::$kind(ast) => ast,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n             } )*\n \n             pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-                use self::Expansion::*;\n+                use self::AstFragment::*;\n                 match self {\n                     OptExpr(expr) => OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n                     $($( $kind(ast) => $kind(folder.$fold(ast)), )*)*\n@@ -91,10 +96,10 @@ macro_rules! expansions {\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n-                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n-                    Expansion::OptExpr(None) => {}\n-                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n-                    $($( Expansion::$kind(ref ast) => for ast in &ast[..] {\n+                    AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    AstFragment::OptExpr(None) => {}\n+                    $($( AstFragment::$kind(ref ast) => visitor.$visit(ast), )*)*\n+                    $($( AstFragment::$kind(ref ast) => for ast in &ast[..] {\n                         visitor.$visit_elt(ast);\n                     }, )*)*\n                 }\n@@ -103,25 +108,25 @@ macro_rules! expansions {\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n             fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand(Expansion::OptExpr(Some(expr))).make_opt_expr()\n+                self.expand(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n             }\n             $($(fn $fold(&mut self, node: $ty) -> $ty {\n-                self.expand(Expansion::$kind(node)).$make()\n+                self.expand(AstFragment::$kind(node)).$make()\n             })*)*\n             $($(fn $fold_elt(&mut self, node: $ty_elt) -> $ty {\n-                self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n+                self.expand(AstFragment::$kind(SmallVector::one(node))).$make()\n             })*)*\n         }\n \n         impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n             $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n-                Some(self.make(ExpansionKind::$kind).$make())\n+                Some(self.make(AstFragmentKind::$kind).$make())\n             })*\n         }\n     }\n }\n \n-expansions! {\n+ast_fragments! {\n     Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n     Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n     Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n@@ -137,29 +142,31 @@ expansions! {\n         \"foreign item\", .make_foreign_items, lift .fold_foreign_item, lift .visit_foreign_item;\n }\n \n-impl ExpansionKind {\n-    fn dummy(self, span: Span) -> Option<Expansion> {\n+impl AstFragmentKind {\n+    fn dummy(self, span: Span) -> Option<AstFragment> {\n         self.make_from(DummyResult::any(span))\n     }\n \n-    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n+    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I)\n+                                                                     -> AstFragment {\n         let mut items = items.into_iter();\n         match self {\n-            ExpansionKind::Items =>\n-                Expansion::Items(items.map(Annotatable::expect_item).collect()),\n-            ExpansionKind::ImplItems =>\n-                Expansion::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n-            ExpansionKind::TraitItems =>\n-                Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n-            ExpansionKind::ForeignItems =>\n-                Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n-            ExpansionKind::Stmts => Expansion::Stmts(items.map(Annotatable::expect_stmt).collect()),\n-            ExpansionKind::Expr => Expansion::Expr(\n+            AstFragmentKind::Items =>\n+                AstFragment::Items(items.map(Annotatable::expect_item).collect()),\n+            AstFragmentKind::ImplItems =>\n+                AstFragment::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n+            AstFragmentKind::TraitItems =>\n+                AstFragment::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n+            AstFragmentKind::ForeignItems =>\n+                AstFragment::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n+            AstFragmentKind::Stmts =>\n+                AstFragment::Stmts(items.map(Annotatable::expect_stmt).collect()),\n+            AstFragmentKind::Expr => AstFragment::Expr(\n                 items.next().expect(\"expected exactly one expression\").expect_expr()\n             ),\n-            ExpansionKind::OptExpr =>\n-                Expansion::OptExpr(items.next().map(Annotatable::expect_expr)),\n-            ExpansionKind::Pat | ExpansionKind::Ty =>\n+            AstFragmentKind::OptExpr =>\n+                AstFragment::OptExpr(items.next().map(Annotatable::expect_expr)),\n+            AstFragmentKind::Pat | AstFragmentKind::Ty =>\n                 panic!(\"patterns and types aren't annotatable\"),\n         }\n     }\n@@ -187,7 +194,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n \n pub struct Invocation {\n     pub kind: InvocationKind,\n-    expansion_kind: ExpansionKind,\n+    fragment_kind: AstFragmentKind,\n     pub expansion_data: ExpansionData,\n }\n \n@@ -244,7 +251,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let orig_mod_span = krate.module.inner;\n \n-        let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n+        let krate_item = AstFragment::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n             node: ast::ItemKind::Mod(krate.module),\n@@ -273,16 +280,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Fully expand all the invocations in `expansion`.\n-    fn expand(&mut self, expansion: Expansion) -> Expansion {\n+    // Fully expand all macro invocations in this AST fragment.\n+    fn expand(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n \n-        let (expansion, mut invocations) = self.collect_invocations(expansion, &[]);\n+        let (fragment_with_placeholders, mut invocations)\n+            = self.collect_invocations(input_fragment, &[]);\n         self.resolve_imports();\n         invocations.reverse();\n \n-        let mut expansions = Vec::new();\n+        let mut expanded_fragments = Vec::new();\n         let mut derives = HashMap::new();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n@@ -314,11 +322,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             self.cx.current_expansion.mark = scope;\n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expansion, new_invocations) = if let Some(ext) = ext {\n+            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n                 if let Some(ext) = ext {\n-                    let dummy = invoc.expansion_kind.dummy(invoc.span()).unwrap();\n-                    let expansion = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n-                    self.collect_invocations(expansion, &[])\n+                    let dummy = invoc.fragment_kind.dummy(invoc.span()).unwrap();\n+                    let fragment = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n+                    self.collect_invocations(fragment, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n                     if !item.derive_allowed() {\n                         let attr = attr::find_by_name(item.attrs(), \"derive\")\n@@ -359,27 +367,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         };\n                         invocations.push(Invocation {\n                             kind: InvocationKind::Derive { path: path.clone(), item: item },\n-                            expansion_kind: invoc.expansion_kind,\n+                            fragment_kind: invoc.fragment_kind,\n                             expansion_data: ExpansionData {\n                                 mark,\n                                 ..invoc.expansion_data.clone()\n                             },\n                         });\n                     }\n-                    let expansion = invoc.expansion_kind\n+                    let fragment = invoc.fragment_kind\n                         .expect_from_annotatables(::std::iter::once(item_with_markers));\n-                    self.collect_invocations(expansion, derives)\n+                    self.collect_invocations(fragment, derives)\n                 } else {\n                     unreachable!()\n                 }\n             } else {\n-                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()).unwrap(), &[])\n+                self.collect_invocations(invoc.fragment_kind.dummy(invoc.span()).unwrap(), &[])\n             };\n \n-            if expansions.len() < depth {\n-                expansions.push(Vec::new());\n+            if expanded_fragments.len() < depth {\n+                expanded_fragments.push(Vec::new());\n             }\n-            expansions[depth - 1].push((mark, expansion));\n+            expanded_fragments[depth - 1].push((mark, expanded_fragment));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -388,14 +396,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.current_expansion = orig_expansion_data;\n \n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n-        while let Some(expansions) = expansions.pop() {\n-            for (mark, expansion) in expansions.into_iter().rev() {\n+        while let Some(expanded_fragments) = expanded_fragments.pop() {\n+            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n                 let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_mark(mark), expansion, derives);\n+                placeholder_expander.add(NodeId::placeholder_from_mark(mark),\n+                                         expanded_fragment, derives);\n             }\n         }\n \n-        expansion.fold_with(&mut placeholder_expander)\n+        fragment_with_placeholders.fold_with(&mut placeholder_expander)\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -406,9 +415,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn collect_invocations(&mut self, expansion: Expansion, derives: &[Mark])\n-                           -> (Expansion, Vec<Invocation>) {\n-        let result = {\n+    fn collect_invocations(&mut self, fragment: AstFragment, derives: &[Mark])\n+                           -> (AstFragment, Vec<Invocation>) {\n+        let (fragment_with_placeholders, invocations) = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n                     should_test: self.cx.ecfg.should_test,\n@@ -419,17 +428,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n             };\n-            (expansion.fold_with(&mut collector), collector.invocations)\n+            (fragment.fold_with(&mut collector), collector.invocations)\n         };\n \n         if self.monotonic {\n             let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n             let mark = self.cx.current_expansion.mark;\n-            self.cx.resolver.visit_expansion(mark, &result.0, derives);\n+            self.cx.resolver.visit_ast_fragment_with_placeholders(mark, &fragment_with_placeholders,\n+                                                                  derives);\n             self.cx.resolve_err_count += self.cx.parse_sess.span_diagnostic.err_count() - err_count;\n         }\n \n-        result\n+        (fragment_with_placeholders, invocations)\n     }\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n@@ -464,7 +474,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<Expansion> {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n@@ -491,8 +501,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_attr_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<Expansion> {\n-        let Invocation { expansion_kind: kind, .. } = invoc;\n+                         -> Option<AstFragment> {\n         let (attr, item) = match invoc.kind {\n             InvocationKind::Attr { attr, item, .. } => (attr?, item),\n             _ => unreachable!(),\n@@ -515,15 +524,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n-                Some(kind.expect_from_annotatables(item))\n+                Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .expect(\"derive meta should already have been parsed\");\n                 mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac, ..) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n@@ -537,20 +546,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 })).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n                 let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n-                let res = self.parse_expansion(tok_result, kind, &attr.path, attr.span);\n+                let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n+                                                  &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n                 self.cx.trace_macros_diag();\n-                kind.dummy(attr.span)\n+                invoc.fragment_kind.dummy(attr.span)\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n                 self.cx.span_err(attr.span, msg);\n                 self.cx.trace_macros_diag();\n-                kind.dummy(attr.span)\n+                invoc.fragment_kind.dummy(attr.span)\n             }\n         }\n     }\n@@ -598,16 +608,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn gate_proc_macro_expansion(&self, span: Span, expansion: &Option<Expansion>) {\n+    fn gate_proc_macro_expansion(&self, span: Span, fragment: &Option<AstFragment>) {\n         if self.cx.ecfg.proc_macro_gen() {\n             return\n         }\n-        let expansion = match expansion {\n-            Some(expansion) => expansion,\n+        let fragment = match fragment {\n+            Some(fragment) => fragment,\n             None => return,\n         };\n \n-        expansion.visit_with(&mut DisallowModules {\n+        fragment.visit_with(&mut DisallowModules {\n             span,\n             parse_sess: self.cx.parse_sess,\n         });\n@@ -642,12 +652,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    /// Expand a macro invocation. Returns the result of expansion.\n+    /// Expand a macro invocation. Returns the resulting expanded AST fragment.\n     fn expand_bang_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<Expansion> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n+                         -> Option<AstFragment> {\n+        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n@@ -790,7 +800,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     });\n \n                     let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n-                    let result = self.parse_expansion(tok_result, kind, path, span);\n+                    let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n                     result\n                 }\n@@ -808,17 +818,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn gate_proc_macro_expansion_kind(&self, span: Span, kind: ExpansionKind) {\n+    fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n-            ExpansionKind::Expr => \"expressions\",\n-            ExpansionKind::OptExpr => \"expressions\",\n-            ExpansionKind::Pat => \"patterns\",\n-            ExpansionKind::Ty => \"types\",\n-            ExpansionKind::Stmts => \"statements\",\n-            ExpansionKind::Items => return,\n-            ExpansionKind::TraitItems => return,\n-            ExpansionKind::ImplItems => return,\n-            ExpansionKind::ForeignItems => return,\n+            AstFragmentKind::Expr => \"expressions\",\n+            AstFragmentKind::OptExpr => \"expressions\",\n+            AstFragmentKind::Pat => \"patterns\",\n+            AstFragmentKind::Ty => \"types\",\n+            AstFragmentKind::Stmts => \"statements\",\n+            AstFragmentKind::Items => return,\n+            AstFragmentKind::TraitItems => return,\n+            AstFragmentKind::ImplItems => return,\n+            AstFragmentKind::ForeignItems => return,\n         };\n         if self.cx.ecfg.proc_macro_non_items() {\n             return\n@@ -832,12 +842,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    /// Expand a derive invocation. Returns the result of expansion.\n+    /// Expand a derive invocation. Returns the resulting expanded AST fragment.\n     fn expand_derive_invoc(&mut self,\n                            invoc: Invocation,\n                            ext: &SyntaxExtension)\n-                           -> Option<Expansion> {\n-        let Invocation { expansion_kind: kind, .. } = invoc;\n+                           -> Option<AstFragment> {\n         let (path, item) = match invoc.kind {\n             InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n@@ -876,36 +885,36 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     node: ast::MetaItemKind::Word,\n                 };\n                 let items = ext.expand(self.cx, span, &dummy, item);\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             BuiltinDerive(func) => {\n                 expn_info.callee.allow_internal_unstable = true;\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();\n                 func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n                 self.cx.span_err(span, msg);\n                 self.cx.trace_macros_diag();\n-                kind.dummy(span)\n+                invoc.fragment_kind.dummy(span)\n             }\n         }\n     }\n \n-    fn parse_expansion(&mut self,\n-                       toks: TokenStream,\n-                       kind: ExpansionKind,\n-                       path: &Path,\n-                       span: Span)\n-                       -> Option<Expansion> {\n+    fn parse_ast_fragment(&mut self,\n+                          toks: TokenStream,\n+                          kind: AstFragmentKind,\n+                          path: &Path,\n+                          span: Span)\n+                          -> Option<AstFragment> {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n-        match parser.parse_expansion(kind, false) {\n-            Ok(expansion) => {\n+        match parser.parse_ast_fragment(kind, false) {\n+            Ok(fragment) => {\n                 parser.ensure_complete_parse(path, kind.name(), span);\n-                Some(expansion)\n+                Some(fragment)\n             }\n             Err(mut err) => {\n                 err.set_span(span);\n@@ -918,40 +927,40 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)\n-                           -> PResult<'a, Expansion> {\n+    pub fn parse_ast_fragment(&mut self, kind: AstFragmentKind, macro_legacy_warnings: bool)\n+                              -> PResult<'a, AstFragment> {\n         Ok(match kind {\n-            ExpansionKind::Items => {\n+            AstFragmentKind::Items => {\n                 let mut items = SmallVector::new();\n                 while let Some(item) = self.parse_item()? {\n                     items.push(item);\n                 }\n-                Expansion::Items(items)\n+                AstFragment::Items(items)\n             }\n-            ExpansionKind::TraitItems => {\n+            AstFragmentKind::TraitItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_trait_item(&mut false)?);\n                 }\n-                Expansion::TraitItems(items)\n+                AstFragment::TraitItems(items)\n             }\n-            ExpansionKind::ImplItems => {\n+            AstFragmentKind::ImplItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_impl_item(&mut false)?);\n                 }\n-                Expansion::ImplItems(items)\n+                AstFragment::ImplItems(items)\n             }\n-            ExpansionKind::ForeignItems => {\n+            AstFragmentKind::ForeignItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     if let Some(item) = self.parse_foreign_item()? {\n                         items.push(item);\n                     }\n                 }\n-                Expansion::ForeignItems(items)\n+                AstFragment::ForeignItems(items)\n             }\n-            ExpansionKind::Stmts => {\n+            AstFragmentKind::Stmts => {\n                 let mut stmts = SmallVector::new();\n                 while self.token != token::Eof &&\n                       // won't make progress on a `}`\n@@ -960,18 +969,18 @@ impl<'a> Parser<'a> {\n                         stmts.push(stmt);\n                     }\n                 }\n-                Expansion::Stmts(stmts)\n+                AstFragment::Stmts(stmts)\n             }\n-            ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n-            ExpansionKind::OptExpr => {\n+            AstFragmentKind::Expr => AstFragment::Expr(self.parse_expr()?),\n+            AstFragmentKind::OptExpr => {\n                 if self.token != token::Eof {\n-                    Expansion::OptExpr(Some(self.parse_expr()?))\n+                    AstFragment::OptExpr(Some(self.parse_expr()?))\n                 } else {\n-                    Expansion::OptExpr(None)\n+                    AstFragment::OptExpr(None)\n                 }\n             },\n-            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n-            ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n+            AstFragmentKind::Ty => AstFragment::Ty(self.parse_ty()?),\n+            AstFragmentKind::Pat => AstFragment::Pat(self.parse_pat()?),\n         })\n     }\n \n@@ -998,30 +1007,30 @@ struct InvocationCollector<'a, 'b: 'a> {\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n-    fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n+    fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n         let mark = Mark::fresh(self.cx.current_expansion.mark);\n         self.invocations.push(Invocation {\n             kind,\n-            expansion_kind,\n+            fragment_kind,\n             expansion_data: ExpansionData {\n                 mark,\n                 depth: self.cx.current_expansion.depth + 1,\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(expansion_kind, NodeId::placeholder_from_mark(mark))\n+        placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n     }\n \n-    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion {\n+    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n         self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n                     traits: Vec<Path>,\n                     item: Annotatable,\n-                    kind: ExpansionKind)\n-                    -> Expansion {\n+                    kind: AstFragmentKind)\n+                    -> AstFragment {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n@@ -1119,14 +1128,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             // expansion will eat the attribute so it won't error later\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            // ExpansionKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n-                .make_expr();\n+            // AstFragmentKind::Expr requires the macro to emit an expression\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                     AstFragmentKind::Expr).make_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, ExpansionKind::Expr).make_expr()\n+            self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -1143,13 +1152,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     ExpansionKind::OptExpr)\n+                                     AstFragmentKind::OptExpr)\n                 .make_opt_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, ExpansionKind::OptExpr).make_opt_expr()\n+            self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr).make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -1163,7 +1172,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         }\n \n         pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, ExpansionKind::Pat).make_pat(),\n+            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n             _ => unreachable!(),\n         })\n     }\n@@ -1187,7 +1196,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives,\n-                                         Annotatable::Stmt(P(stmt_)), ExpansionKind::Stmts)\n+                                         Annotatable::Stmt(P(stmt_)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n \n@@ -1197,7 +1206,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         if let StmtKind::Mac(mac) = stmt.node {\n             let (mac, style, attrs) = mac.into_inner();\n             self.check_attributes(&attrs);\n-            let mut placeholder = self.collect_bang(mac, stmt.span, ExpansionKind::Stmts)\n+            let mut placeholder = self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts)\n                                         .make_stmts();\n \n             // If this is a macro invocation with a semicolon, then apply that\n@@ -1233,15 +1242,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, mut item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::Item(item);\n-            return self.collect_attr(attr, traits, item, ExpansionKind::Items).make_items();\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::Items).make_items();\n         }\n \n         match item.node {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.node {\n                     ItemKind::Mac(mac) => {\n-                        self.collect(ExpansionKind::Items, InvocationKind::Bang {\n+                        self.collect(AstFragmentKind::Items, InvocationKind::Bang {\n                             mac,\n                             ident: Some(item.ident),\n                             span: item.span,\n@@ -1317,15 +1326,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::TraitItem(P(item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::TraitItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::TraitItems)\n                 .make_trait_items()\n         }\n \n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n-                self.collect_bang(mac, span, ExpansionKind::TraitItems).make_trait_items()\n+                self.collect_bang(mac, span, AstFragmentKind::TraitItems).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -1337,15 +1346,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::ImplItem(P(item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::ImplItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::ImplItems)\n                 .make_impl_items();\n         }\n \n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n-                self.collect_bang(mac, span, ExpansionKind::ImplItems).make_impl_items()\n+                self.collect_bang(mac, span, AstFragmentKind::ImplItems).make_impl_items()\n             }\n             _ => fold::noop_fold_impl_item(item, self),\n         }\n@@ -1358,7 +1367,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         };\n \n         match ty.node {\n-            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, ExpansionKind::Ty).make_ty(),\n+            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n             _ => unreachable!(),\n         }\n     }\n@@ -1386,7 +1395,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }\n \n             let item = Annotatable::ForeignItem(P(foreign_item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::ForeignItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::ForeignItems)\n                 .make_foreign_items();\n         }\n \n@@ -1398,7 +1407,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                                  GateIssue::Language, explain);\n             }\n \n-            return self.collect_bang(mac, foreign_item.span, ExpansionKind::ForeignItems)\n+            return self.collect_bang(mac, foreign_item.span, AstFragmentKind::ForeignItems)\n                 .make_foreign_items();\n         }\n "}, {"sha": "968cf508edaaae102ff17ce5566b012204f702b5", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=a12726460ee2b36fe97ed5751c0d93758ed7cee5", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, NodeId};\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n-use ext::expand::{Expansion, ExpansionKind};\n+use ext::expand::{AstFragment, AstFragmentKind};\n use ext::hygiene::Mark;\n use tokenstream::TokenStream;\n use fold::*;\n@@ -22,7 +22,7 @@ use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n \n-pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n+pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     fn mac_placeholder() -> ast::Mac {\n         dummy_spanned(ast::Mac_ {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n@@ -43,43 +43,44 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     });\n \n     match kind {\n-        ExpansionKind::Expr => Expansion::Expr(expr_placeholder()),\n-        ExpansionKind::OptExpr => Expansion::OptExpr(Some(expr_placeholder())),\n-        ExpansionKind::Items => Expansion::Items(SmallVector::one(P(ast::Item {\n+        AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n+        AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n+        AstFragmentKind::Items => AstFragment::Items(SmallVector::one(P(ast::Item {\n             id, span, ident, vis, attrs,\n             node: ast::ItemKind::Mac(mac_placeholder()),\n             tokens: None,\n         }))),\n-        ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n+        AstFragmentKind::TraitItems => AstFragment::TraitItems(SmallVector::one(ast::TraitItem {\n             id, span, ident, attrs, generics,\n             node: ast::TraitItemKind::Macro(mac_placeholder()),\n             tokens: None,\n         })),\n-        ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n+        AstFragmentKind::ImplItems => AstFragment::ImplItems(SmallVector::one(ast::ImplItem {\n             id, span, ident, vis, attrs, generics,\n             node: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n         })),\n-        ExpansionKind::ForeignItems => Expansion::ForeignItems(SmallVector::one(ast::ForeignItem {\n-            id, span, ident, vis, attrs,\n-            node: ast::ForeignItemKind::Macro(mac_placeholder()),\n-        })),\n-        ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n+        AstFragmentKind::ForeignItems =>\n+            AstFragment::ForeignItems(SmallVector::one(ast::ForeignItem {\n+                id, span, ident, vis, attrs,\n+                node: ast::ForeignItemKind::Macro(mac_placeholder()),\n+            })),\n+        AstFragmentKind::Pat => AstFragment::Pat(P(ast::Pat {\n             id, span, node: ast::PatKind::Mac(mac_placeholder()),\n         })),\n-        ExpansionKind::Ty => Expansion::Ty(P(ast::Ty {\n+        AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n             id, span, node: ast::TyKind::Mac(mac_placeholder()),\n         })),\n-        ExpansionKind::Stmts => Expansion::Stmts(SmallVector::one({\n+        AstFragmentKind::Stmts => AstFragment::Stmts(SmallVector::one({\n             let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::ThinVec::new()));\n             ast::Stmt { id, span, node: ast::StmtKind::Mac(mac) }\n         })),\n     }\n }\n \n pub struct PlaceholderExpander<'a, 'b: 'a> {\n-    expansions: HashMap<ast::NodeId, Expansion>,\n+    expanded_fragments: HashMap<ast::NodeId, AstFragment>,\n     cx: &'a mut ExtCtxt<'b>,\n     monotonic: bool,\n }\n@@ -88,27 +89,27 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         PlaceholderExpander {\n             cx,\n-            expansions: HashMap::new(),\n+            expanded_fragments: HashMap::new(),\n             monotonic,\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion, derives: Vec<Mark>) {\n-        let mut expansion = expansion.fold_with(self);\n-        if let Expansion::Items(mut items) = expansion {\n+    pub fn add(&mut self, id: ast::NodeId, fragment: AstFragment, derives: Vec<Mark>) {\n+        let mut fragment = fragment.fold_with(self);\n+        if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {\n                 match self.remove(NodeId::placeholder_from_mark(derive)) {\n-                    Expansion::Items(derived_items) => items.extend(derived_items),\n+                    AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }\n             }\n-            expansion = Expansion::Items(items);\n+            fragment = AstFragment::Items(items);\n         }\n-        self.expansions.insert(id, expansion);\n+        self.expanded_fragments.insert(id, fragment);\n     }\n \n-    fn remove(&mut self, id: ast::NodeId) -> Expansion {\n-        self.expansions.remove(&id).unwrap()\n+    fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n+        self.expanded_fragments.remove(&id).unwrap()\n     }\n }\n \n@@ -159,18 +160,18 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        let (style, mut expansion) = match stmt.node {\n+        let (style, mut stmts) = match stmt.node {\n             ast::StmtKind::Mac(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n             _ => return noop_fold_stmt(stmt, self),\n         };\n \n         if style == ast::MacStmtStyle::Semicolon {\n-            if let Some(stmt) = expansion.pop() {\n-                expansion.push(stmt.add_trailing_semicolon());\n+            if let Some(stmt) = stmts.pop() {\n+                stmts.push(stmt.add_trailing_semicolon());\n             }\n         }\n \n-        expansion\n+        stmts\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "4ee5357f4766cc1186d36299a0e78f19e2d47d5e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12726460ee2b36fe97ed5751c0d93758ed7cee5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a12726460ee2b36fe97ed5751c0d93758ed7cee5", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use edition::Edition;\n use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{Expansion, ExpansionKind};\n+use ext::expand::{AstFragment, AstFragmentKind};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -43,21 +43,21 @@ pub struct ParserAnyMacro<'a> {\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n+    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n-        let expansion = panictry!(parser.parse_expansion(kind, true));\n+        let fragment = panictry!(parser.parse_ast_fragment(kind, true));\n \n         // We allow semicolons at the end of expressions -- e.g. the semicolon in\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n         // but `m!()` is allowed in expression positions (c.f. issue #34706).\n-        if kind == ExpansionKind::Expr && parser.token == token::Semi {\n+        if kind == AstFragmentKind::Expr && parser.token == token::Semi {\n             parser.bump();\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n         let path = ast::Path::from_ident(macro_ident.with_span_pos(site_span));\n         parser.ensure_complete_parse(&path, kind.name(), site_span);\n-        expansion\n+        fragment\n     }\n }\n "}]}