{"sha": "50c98a8c46e7b6aa7740448645905bfac024f191", "node_id": "C_kwDOAAsO6NoAKDUwYzk4YThjNDZlN2I2YWE3NzQwNDQ4NjQ1OTA1YmZhYzAyNGYxOTE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-03-27T18:02:06Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-06-05T10:28:25Z"}, "message": "Add vec::Drain{,Filter}::keep_rest\n\nThese methods allow to cancel draining of unyielded elements.", "tree": {"sha": "796fcbbbd0650f6f127a7665f4e9b29cdf334b4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/796fcbbbd0650f6f127a7665f4e9b29cdf334b4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50c98a8c46e7b6aa7740448645905bfac024f191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50c98a8c46e7b6aa7740448645905bfac024f191", "html_url": "https://github.com/rust-lang/rust/commit/50c98a8c46e7b6aa7740448645905bfac024f191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50c98a8c46e7b6aa7740448645905bfac024f191/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2da4af33c5e6a22fff0a223f99d53cba4a5aa52", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2da4af33c5e6a22fff0a223f99d53cba4a5aa52", "html_url": "https://github.com/rust-lang/rust/commit/a2da4af33c5e6a22fff0a223f99d53cba4a5aa52"}], "stats": {"total": 156, "additions": 153, "deletions": 3}, "files": [{"sha": "3e350c2b38e3e6448658000324a6e9f917e28db8", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=50c98a8c46e7b6aa7740448645905bfac024f191", "patch": "@@ -1,7 +1,7 @@\n use crate::alloc::{Allocator, Global};\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n-use core::mem;\n+use core::mem::{self, ManuallyDrop};\n use core::ptr::{self, NonNull};\n use core::slice::{self};\n \n@@ -65,6 +65,59 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     pub fn allocator(&self) -> &A {\n         unsafe { self.vec.as_ref().allocator() }\n     }\n+\n+    /// Keep unyielded elements in the source `Vec`.\n+    #[unstable(feature = \"drain_keep_rest\", issue = \"none\")]\n+    pub fn keep_rest(self) {\n+        // At this moment layout looks like this:\n+        //\n+        // [head] [yielded by next] [unyielded] [yielded by next_back] [tail]\n+        //        ^-- start         \\_________/-- unyielded_len        \\____/-- self.tail_len\n+        //                          ^-- unyielded_ptr                  ^-- tail\n+        //\n+        // Normally `Drop` impl would drop [unyielded] and then move [tail] to the `start`.\n+        // Here we want to\n+        // 1. Move [unyielded] to `start`\n+        // 2. Move [tail] to a new start at `start + len(unyielded)`\n+        // 3. Update length of the original vec to `len(head) + len(unyielded) + len(tail)`\n+        //    a. In case of ZST, this is the only thing we want to do\n+        // 4. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n+        let mut this = ManuallyDrop::new(self);\n+\n+        unsafe {\n+            let source_vec = this.vec.as_mut();\n+\n+            let start = source_vec.len();\n+            let tail = this.tail_start;\n+\n+            let unyielded_len = this.iter.len();\n+            let unyielded_ptr = this.iter.as_slice().as_ptr();\n+\n+            // ZSTs have no identity, so we don't need to move them around.\n+            let needs_move = mem::size_of::<T>() != 0;\n+\n+            if needs_move {\n+                let start_ptr = source_vec.as_mut_ptr().add(start);\n+\n+                // memmove back unyielded elements\n+                if unyielded_ptr != start_ptr {\n+                    let src = unyielded_ptr;\n+                    let dst = start_ptr;\n+\n+                    ptr::copy(src, dst, unyielded_len);\n+                }\n+\n+                // memmove back untouched tail\n+                if tail != (start + unyielded_len) {\n+                    let src = source_vec.as_ptr().add(tail);\n+                    let dst = start_ptr.add(unyielded_len);\n+                    ptr::copy(src, dst, this.tail_len);\n+                }\n+            }\n+\n+            source_vec.set_len(start + unyielded_len + this.tail_len);\n+        }\n+    }\n }\n \n #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]"}, {"sha": "a5c1eab94eef98fb1788cac12f4ec963bf5b0926", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=50c98a8c46e7b6aa7740448645905bfac024f191", "patch": "@@ -1,6 +1,7 @@\n use crate::alloc::{Allocator, Global};\n-use core::ptr::{self};\n-use core::slice::{self};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr;\n+use core::slice;\n \n use super::Vec;\n \n@@ -54,6 +55,42 @@ where\n     pub fn allocator(&self) -> &A {\n         self.vec.allocator()\n     }\n+\n+    /// Keep unyielded elements in the source `Vec`.\n+    #[unstable(feature = \"drain_keep_rest\", issue = \"none\")]\n+    pub fn keep_rest(self) {\n+        // At this moment layout looks like this:\n+        //\n+        //  _____________________/-- old_len\n+        // /                     \\\n+        // [kept] [yielded] [tail]\n+        //        \\_______/ ^-- idx\n+        //                \\-- del\n+        //\n+        // Normally `Drop` impl would drop [tail] (via .for_each(drop), ie still calling `pred`)\n+        //\n+        // 1. Move [tail] after [kept]\n+        // 2. Update length of the original vec to `old_len - del`\n+        //    a. In case of ZST, this is the only thing we want to do\n+        // 3. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n+        let mut this = ManuallyDrop::new(self);\n+\n+        unsafe {\n+            // ZSTs have no identity, so we don't need to move them around.\n+            let needs_move = mem::size_of::<T>() != 0;\n+\n+            if needs_move && this.idx < this.old_len && this.del > 0 {\n+                let ptr = this.vec.as_mut_ptr();\n+                let src = ptr.add(this.idx);\n+                let dst = src.sub(this.del);\n+                let tail_len = this.old_len - this.idx;\n+                src.copy_to(dst, tail_len);\n+            }\n+\n+            let new_len = this.old_len - this.del;\n+            this.vec.set_len(new_len);\n+        }\n+    }\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]"}, {"sha": "455bd92361eeb8562f5d8b7eab445526178c3429", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=50c98a8c46e7b6aa7740448645905bfac024f191", "patch": "@@ -45,6 +45,7 @@\n #![feature(bench_black_box)]\n #![feature(strict_provenance)]\n #![feature(once_cell)]\n+#![feature(drain_keep_rest)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "946380162e7d83941a83eac342d4f3e47fd88df1", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c98a8c46e7b6aa7740448645905bfac024f191/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=50c98a8c46e7b6aa7740448645905bfac024f191", "patch": "@@ -793,6 +793,36 @@ fn test_drain_leak() {\n     assert_eq!(v, vec![D(0, false), D(1, false), D(6, false),]);\n }\n \n+#[test]\n+fn test_drain_keep_rest() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain(1..6);\n+    assert_eq!(drain.next(), Some(1));\n+    assert_eq!(drain.next_back(), Some(5));\n+    assert_eq!(drain.next(), Some(2));\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[0, 3, 4, 6]);\n+}\n+\n+#[test]\n+fn test_drain_keep_rest_all() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    v.drain(1..6).keep_rest();\n+    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_keep_rest_none() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain(1..6);\n+\n+    drain.by_ref().for_each(drop);\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[0, 6]);\n+}\n+\n #[test]\n fn test_splice() {\n     let mut v = vec![1, 2, 3, 4, 5];\n@@ -1478,6 +1508,35 @@ fn drain_filter_unconsumed() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_drain_filter_keep_rest() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain_filter(|&mut x| x % 2 == 0);\n+    assert_eq!(drain.next(), Some(0));\n+    assert_eq!(drain.next(), Some(2));\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[1, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_filter_keep_rest_all() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    v.drain_filter(|_| true).keep_rest();\n+    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn test_drain_filter_keep_rest_none() {\n+    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n+    let mut drain = v.drain_filter(|_| true);\n+\n+    drain.by_ref().for_each(drop);\n+\n+    drain.keep_rest();\n+    assert_eq!(v, &[]);\n+}\n+\n #[test]\n fn test_reserve_exact() {\n     // This is all the same as test_reserve"}]}