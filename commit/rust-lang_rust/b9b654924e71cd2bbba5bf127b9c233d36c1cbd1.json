{"sha": "b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YjY1NDkyNGU3MWNkMmJiYmE1YmYxMjdiOWMyMzNkMzZjMWNiZDE=", "commit": {"author": {"name": "Andy Gauge", "email": "andygauge@gmail.com", "date": "2017-08-29T17:17:33Z"}, "committer": {"name": "Andy Gauge", "email": "andygauge@gmail.com", "date": "2017-08-29T17:30:19Z"}, "message": "API docs: macros.  Part of #29329 Standard Library Documentation Checklist.", "tree": {"sha": "8e4bc41719958be88c897321c7f7c0741a59ffb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e4bc41719958be88c897321c7f7c0741a59ffb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "html_url": "https://github.com/rust-lang/rust/commit/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/comments", "author": {"login": "AndyGauge", "id": 6525150, "node_id": "MDQ6VXNlcjY1MjUxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6525150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndyGauge", "html_url": "https://github.com/AndyGauge", "followers_url": "https://api.github.com/users/AndyGauge/followers", "following_url": "https://api.github.com/users/AndyGauge/following{/other_user}", "gists_url": "https://api.github.com/users/AndyGauge/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndyGauge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndyGauge/subscriptions", "organizations_url": "https://api.github.com/users/AndyGauge/orgs", "repos_url": "https://api.github.com/users/AndyGauge/repos", "events_url": "https://api.github.com/users/AndyGauge/events{/privacy}", "received_events_url": "https://api.github.com/users/AndyGauge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AndyGauge", "id": 6525150, "node_id": "MDQ6VXNlcjY1MjUxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6525150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndyGauge", "html_url": "https://github.com/AndyGauge", "followers_url": "https://api.github.com/users/AndyGauge/followers", "following_url": "https://api.github.com/users/AndyGauge/following{/other_user}", "gists_url": "https://api.github.com/users/AndyGauge/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndyGauge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndyGauge/subscriptions", "organizations_url": "https://api.github.com/users/AndyGauge/orgs", "repos_url": "https://api.github.com/users/AndyGauge/repos", "events_url": "https://api.github.com/users/AndyGauge/events{/privacy}", "received_events_url": "https://api.github.com/users/AndyGauge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf477a8c232d0442d16a4025f49d3ae1519131e", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf477a8c232d0442d16a4025f49d3ae1519131e", "html_url": "https://github.com/rust-lang/rust/commit/faf477a8c232d0442d16a4025f49d3ae1519131e"}], "stats": {"total": 207, "additions": 165, "deletions": 42}, "files": [{"sha": "d489229e27caf85563a018e5a43006dc8591c2fe", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Creates a `Vec` containing the arguments.\n+/// Creates a [`Vec`] containing the arguments.\n ///\n /// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n /// There are two forms of this macro:\n ///\n-/// - Create a `Vec` containing a given list of elements:\n+/// - Create a [`Vec`] containing a given list of elements:\n ///\n /// ```\n /// let v = vec![1, 2, 3];\n@@ -22,22 +22,25 @@\n /// assert_eq!(v[2], 3);\n /// ```\n ///\n-/// - Create a `Vec` from a given element and size:\n+/// - Create a [`Vec`] from a given element and size:\n ///\n /// ```\n /// let v = vec![1; 3];\n /// assert_eq!(v, [1, 1, 1]);\n /// ```\n ///\n /// Note that unlike array expressions this syntax supports all elements\n-/// which implement `Clone` and the number of elements doesn't have to be\n+/// which implement [`Clone`] and the number of elements doesn't have to be\n /// a constant.\n ///\n-/// This will use `clone()` to duplicate an expression, so one should be careful\n+/// This will use `clone` to duplicate an expression, so one should be careful\n /// using this with types having a nonstandard `Clone` implementation. For\n /// example, `vec![Rc::new(1); 5]` will create a vector of five references\n /// to the same boxed integer value, not five references pointing to independently\n /// boxed integers.\n+///\n+/// [`Vec`]: ../std/vec/struct.Vec.html\n+/// [`Clone`]: ../std/clone/trait.Clone.html\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -67,10 +70,22 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See [`std::fmt`][fmt] for more information.\n+/// Creates a `String` using interpolation of runtime expressions.\n+///\n+/// The first argument `format!` recieves is a format string.  This must be a string\n+/// literal.  The power of the formatting string is in the `{}`s contained.\n+///\n+/// Additional parameters passed to `format!` replace the `{}`s within the\n+/// formatting string in the order given unless named or positional parameters\n+/// are used, see [`std::fmt`][fmt] for more information.\n+///\n+/// A common use for `format!` is concatenation and interpolation of strings.\n+/// The same convention is used with [`print!`] and [`write!`] macros,\n+/// depending on the intended destination of the string.\n ///\n /// [fmt]: ../std/fmt/index.html\n+/// [`print!`]: macro.print.html\n+/// [`write!`]: macro.write.html\n ///\n /// # Panics\n ///"}, {"sha": "6e652c8b898230a383384f6d14e03bb99f53c9f4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "patch": "@@ -62,11 +62,13 @@ macro_rules! panic {\n /// # Custom Messages\n ///\n /// This macro has a second form, where a custom panic message can\n-/// be provided with or without arguments for formatting.\n+/// be provided with or without arguments for formatting.  See [`std::fmt`]\n+/// for syntax for this form.\n ///\n /// [`panic!`]: macro.panic.html\n /// [`debug_assert!`]: macro.debug_assert.html\n-/// [testing]: ../book/first-edition/testing.html\n+/// [testing]: ../book/second-edition/ch11-01-writing-tests.html#checking-results-with-the-assert-macro\n+/// [`std::fmt`]: ../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -252,13 +254,15 @@ macro_rules! debug_assert {\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Unlike `assert_eq!`, `debug_assert_eq!` statements are only enabled in non\n+/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n /// compiler. This makes `debug_assert_eq!` useful for checks that are too\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// [`assert_eq!`]: ../std/macro.assert_eq.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -277,13 +281,15 @@ macro_rules! debug_assert_eq {\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Unlike `assert_ne!`, `debug_assert_ne!` statements are only enabled in non\n+/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n /// compiler. This makes `debug_assert_ne!` useful for checks that are too\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// [`assert_ne!`]: ../std/macro.assert_ne.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -300,10 +306,9 @@ macro_rules! debug_assert_ne {\n /// Helper macro for reducing boilerplate code for matching `Result` together\n /// with converting downstream errors.\n ///\n-/// Prefer using `?` syntax to `try!`. `?` is built in to the language and is\n-/// more succinct than `try!`. It is the standard method for error propagation.\n+/// The `?` operator was added to replace `try!` and should be used instead.\n ///\n-/// `try!` matches the given `Result`. In case of the `Ok` variant, the\n+/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n /// expression has the value of the wrapped value.\n ///\n /// In case of the `Err` variant, it retrieves the inner error. `try!` then\n@@ -312,7 +317,9 @@ macro_rules! debug_assert_ne {\n /// error is then immediately returned.\n ///\n /// Because of the early return, `try!` can only be used in functions that\n-/// return `Result`.\n+/// return [`Result`].\n+///\n+/// [`Result`]: ../std/result/enum.Result.html\n ///\n /// # Examples\n ///\n@@ -331,20 +338,26 @@ macro_rules! debug_assert_ne {\n ///     }\n /// }\n ///\n+/// // The prefered method of quick returning Errors\n+/// fn write_to_file_question() -> Result<(), MyError> {\n+///     let mut file = File::create(\"my_best_friends.txt\")?;\n+///     Ok(())\n+/// }\n+///\n+/// // The previous method of quick returning Errors\n /// fn write_to_file_using_try() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     try!(file.write_all(b\"This is a list of my best friends.\"));\n-///     println!(\"I wrote to the file\");\n ///     Ok(())\n /// }\n+///\n /// // This is equivalent to:\n /// fn write_to_file_using_match() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     match file.write_all(b\"This is a list of my best friends.\") {\n ///         Ok(v) => v,\n ///         Err(e) => return Err(From::from(e)),\n ///     }\n-///     println!(\"I wrote to the file\");\n ///     Ok(())\n /// }\n /// ```\n@@ -365,7 +378,7 @@ macro_rules! try {\n /// formatted according to the specified format string and the result will be passed to the writer.\n /// The writer may be any value with a `write_fmt` method; generally this comes from an\n /// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n-/// returns whatever the 'write_fmt' method returns; commonly a [`std::fmt::Result`], or an\n+/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n /// [`io::Result`].\n ///\n /// See [`std::fmt`] for more information on the format string syntax.\n@@ -470,10 +483,20 @@ macro_rules! writeln {\n /// * Loops that dynamically terminate.\n /// * Iterators that dynamically terminate.\n ///\n+/// If the determination that the code is unreachable proves incorrect, the\n+/// program immediately terminates with a [`panic!`].  The function [`unreachable`],\n+/// which belongs to the [`std::intrinsics`] module, informs the compilier to\n+/// optimize the code out of the release version entirely.\n+///\n+/// [`panic!`]:  ../std/macro.panic.html\n+/// [`unreachable`]: ../std/intrinsics/fn.unreachable.html\n+/// [`std::intrinsics`]: ../std/intrinsics/index.html\n+///\n /// # Panics\n ///\n-/// This will always [panic!](macro.panic.html)\n+/// This will always [`panic!`]\n ///\n+/// [`panic!`]: ../std/macro.panic.html\n /// # Examples\n ///\n /// Match arms:\n@@ -516,13 +539,18 @@ macro_rules! unreachable {\n     });\n }\n \n-/// A standardized placeholder for marking unfinished code. It panics with the\n-/// message `\"not yet implemented\"` when executed.\n+/// A standardized placeholder for marking unfinished code.\n+///\n+/// It panics with the message `\"not yet implemented\"` when executed.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n /// code typecheck, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n+/// # Panics\n+///\n+/// This macro always panics.\n+///\n /// # Examples\n ///\n /// Here's an example of some in-progress code. We have a trait `Foo`:"}, {"sha": "8c7f0fec92646d9a40e0940290df8e8b1ace8b40", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 101, "deletions": 21, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b654924e71cd2bbba5bf127b9c233d36c1cbd1/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b9b654924e71cd2bbba5bf127b9c233d36c1cbd1", "patch": "@@ -26,13 +26,33 @@ macro_rules! __rust_unstable_column {\n \n /// The entry point for panic of Rust threads.\n ///\n+/// This allows a program to to terminate immediately and provide feedback\n+/// to the caller of the program. `panic!` should be used when a program reaches\n+/// an unrecoverable problem.\n+///\n+/// This macro is the perfect way to assert conditions in example code and in\n+/// tests.  `panic!` is closely tied with the `unwrap` method of both [`Option`]\n+/// and [`Result`][runwrap] enums.  Both implementations call `panic!` when they are set\n+/// to None or Err variants.\n+///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n /// panic entirely. Each thread's panic can be reaped as the `Box<Any>` type,\n /// and the single-argument form of the `panic!` macro will be the value which\n /// is transmitted.\n ///\n+/// [`Result`] enum is often a better solution for recovering from errors than\n+/// using the `panic!` macro.  This macro should be used to avoid proceeding using\n+/// incorrect values, such as from external sources.  Detailed information about\n+/// error handling is found in the [book].\n+///\n /// The multi-argument form of this macro panics with a string and has the\n-/// `format!` syntax for building a string.\n+/// [`format!`] syntax for building a string.\n+///\n+/// [runwrap]: ../std/result/enum.Result.html#method.unwrap\n+/// [`Option`]: ../std/option/enum.Option.html#method.unwrap\n+/// [`Result`]: ../std/result/enum.Result.html\n+/// [`format!`]: ../std/macro.format.html\n+/// [book]: ../book/second-edition/ch09-01-unrecoverable-errors-with-panic.html\n ///\n /// # Current implementation\n ///\n@@ -78,15 +98,19 @@ macro_rules! panic {\n \n /// Macro for printing to the standard output.\n ///\n-/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// Equivalent to the [`println!`] macro except that a newline is not printed at\n /// the end of the message.\n ///\n /// Note that stdout is frequently line-buffered by default so it may be\n-/// necessary to use `io::stdout().flush()` to ensure the output is emitted\n+/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n /// immediately.\n ///\n /// Use `print!` only for the primary output of your program.  Use\n-/// `eprint!` instead to print error and progress messages.\n+/// [`eprint!`] instead to print error and progress messages.\n+///\n+/// [`println!`]: ../std/macro.println.html\n+/// [flush]: ../std/io/trait.Write.html#tymethod.flush\n+/// [`eprint!`]: ../std/macro.eprint.html\n ///\n /// # Panics\n ///\n@@ -118,16 +142,20 @@ macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard output, with a newline. On all\n-/// platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n+/// Macro for printing to the standard output, with a newline.\n+///\n+/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n /// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n-/// Use the `format!` syntax to write data to the standard output.\n-/// See `std::fmt` for more information.\n+/// Use the [`format!`] syntax to write data to the standard output.\n+/// See [`std::fmt`] for more information.\n ///\n /// Use `println!` only for the primary output of your program.  Use\n-/// `eprintln!` instead to print error and progress messages.\n+/// [`eprintln!`] instead to print error and progress messages.\n ///\n+/// [`format!`]: ../std/macro.format.html\n+/// [`std::fmt`]: ../std/fmt/index.html\n+/// [`eprintln!`]: ..std/macro.eprint.html\n /// # Panics\n ///\n /// Panics if writing to `io::stdout` fails.\n@@ -149,16 +177,25 @@ macro_rules! println {\n \n /// Macro for printing to the standard error.\n ///\n-/// Equivalent to the `print!` macro, except that output goes to\n-/// `io::stderr` instead of `io::stdout`.  See `print!` for\n+/// Equivalent to the [`print!`] macro, except that output goes to\n+/// [`io::stderr`] instead of `io::stdout`.  See [`print!`] for\n /// example usage.\n ///\n /// Use `eprint!` only for error and progress messages.  Use `print!`\n /// instead for the primary output of your program.\n ///\n+/// [`io::stderr`]: ../std/io/struct.Stderr.html\n+/// [`print!`]: ../std/macro.print.html\n+///\n /// # Panics\n ///\n /// Panics if writing to `io::stderr` fails.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// eprint(\"Error: Could not complete task\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n #[allow_internal_unstable]\n@@ -168,16 +205,25 @@ macro_rules! eprint {\n \n /// Macro for printing to the standard error, with a newline.\n ///\n-/// Equivalent to the `println!` macro, except that output goes to\n-/// `io::stderr` instead of `io::stdout`.  See `println!` for\n+/// Equivalent to the [`println!`] macro, except that output goes to\n+/// [`io::stderr`] instead of `io::stdout`.  See [`println!`] for\n /// example usage.\n ///\n /// Use `eprintln!` only for error and progress messages.  Use `println!`\n /// instead for the primary output of your program.\n ///\n+/// [`io::stderr`]: ../std/io/struct.Stderr.html\n+/// [`println!`]: ../std/macro.println.html\n+///\n /// # Panics\n ///\n /// Panics if writing to `io::stderr` fails.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// eprint(\"Error: Could not complete task\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n macro_rules! eprintln {\n@@ -267,13 +313,23 @@ pub mod builtin {\n \n     /// The core macro for formatted string creation & output.\n     ///\n+    /// This macro functions by taking a formatting string literal containing\n+    /// `{}` for each additional argument passed.  `format_args!` prepares the\n+    /// additional parameters to ensure the output can be interpreted as a string\n+    /// and canonicalizes the arguments into a single type.  Any value that implements\n+    /// the [`Display`] trait can be passed to `format_args!`, as can any\n+    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n+    ///\n     /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n-    /// passed to the functions in [`std::fmt`] for performing useful functions.\n+    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n     /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n-    /// proxied through this one.\n+    /// proxied through this one.  `format_args!`, unlike its derived macros, avoids\n+    /// heap allocations.\n     ///\n     /// For more information, see the documentation in [`std::fmt`].\n     ///\n+    /// [`Display`]: ../std/fmt/trait.Display.html\n+    /// [`Debug`]: ../std/fmt/trait.Debug.html\n     /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n     /// [`std::fmt`]: ../std/fmt/index.html\n     /// [`format!`]: ../std/macro.format.html\n@@ -301,9 +357,11 @@ pub mod builtin {\n     /// compile time, yielding an expression of type `&'static str`.\n     ///\n     /// If the environment variable is not defined, then a compilation error\n-    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// will be emitted.  To not emit a compile error, use the [`option_env!`]\n     /// macro instead.\n     ///\n+    /// [`option_env!`]: ../std/macro.option_env.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -319,11 +377,14 @@ pub mod builtin {\n     /// If the named environment variable is present at compile time, this will\n     /// expand into an expression of type `Option<&'static str>` whose value is\n     /// `Some` of the value of the environment variable. If the environment\n-    /// variable is not present, then this will expand to `None`.\n+    /// variable is not present, then this will expand to `None`.  See\n+    /// [`Option<T>`][option] for more information on this type.\n     ///\n     /// A compile time error is never emitted when using this macro regardless\n     /// of whether the environment variable is present or not.\n     ///\n+    /// [option]: ../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -385,10 +446,16 @@ pub mod builtin {\n \n     /// A macro which expands to the line number on which it was invoked.\n     ///\n+    /// With [`column!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     /// The expanded expression has type `u32`, and the returned line is not\n     /// the invocation of the `line!()` macro itself, but rather the first macro\n     /// invocation leading up to the invocation of the `line!()` macro.\n     ///\n+    /// [`column!`]: macro.column.html\n+    /// [`file!`]: macro.file.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -401,9 +468,15 @@ pub mod builtin {\n \n     /// A macro which expands to the column number on which it was invoked.\n     ///\n+    /// With [`line!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     /// The expanded expression has type `u32`, and the returned column is not\n-    /// the invocation of the `column!()` macro itself, but rather the first macro\n-    /// invocation leading up to the invocation of the `column!()` macro.\n+    /// the invocation of the `column!` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `column!` macro.\n+    ///\n+    /// [`line!`]: macro.line.html\n+    /// [`file!`]: macro.file.html\n     ///\n     /// # Examples\n     ///\n@@ -417,11 +490,18 @@ pub mod builtin {\n \n     /// A macro which expands to the file name from which it was invoked.\n     ///\n+    /// With [`line!`] and [`column!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    ///\n     /// The expanded expression has type `&'static str`, and the returned file\n-    /// is not the invocation of the `file!()` macro itself, but rather the\n-    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// is not the invocation of the `file!` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!`\n     /// macro.\n     ///\n+    /// [`line!`]: macro.line.html\n+    /// [`column!`]: macro.column.html\n+    ///\n     /// # Examples\n     ///\n     /// ```"}]}