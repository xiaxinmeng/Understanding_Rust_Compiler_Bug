{"sha": "2aa125251ebd74c0e2a119b351caec27a9e1da46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTEyNTI1MWViZDc0YzBlMmExMTliMzUxY2FlYzI3YTllMWRhNDY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-11T10:01:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-11T13:01:57Z"}, "message": "move nav to a separate file", "tree": {"sha": "c556663ffa90d7c8164d010666ece7fb0a7e2f55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c556663ffa90d7c8164d010666ece7fb0a7e2f55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa125251ebd74c0e2a119b351caec27a9e1da46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa125251ebd74c0e2a119b351caec27a9e1da46", "html_url": "https://github.com/rust-lang/rust/commit/2aa125251ebd74c0e2a119b351caec27a9e1da46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa125251ebd74c0e2a119b351caec27a9e1da46/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f848aa97ab9d9789f72828d28619dd4227c352b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f848aa97ab9d9789f72828d28619dd4227c352b9", "html_url": "https://github.com/rust-lang/rust/commit/f848aa97ab9d9789f72828d28619dd4227c352b9"}], "stats": {"total": 161, "additions": 88, "deletions": 73}, "files": [{"sha": "2e17689519b4d6d9e29485e03eb5a1664d2f7099", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2aa125251ebd74c0e2a119b351caec27a9e1da46/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa125251ebd74c0e2a119b351caec27a9e1da46/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=2aa125251ebd74c0e2a119b351caec27a9e1da46", "patch": "@@ -22,6 +22,7 @@ mod db;\n mod imp;\n pub mod mock_analysis;\n mod symbol_index;\n+mod navigation_target;\n \n mod completion;\n mod runnables;\n@@ -33,8 +34,7 @@ mod syntax_highlighting;\n \n use std::{fmt, sync::Arc};\n \n-use hir::{Def, ModuleSource, Name};\n-use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, SyntaxNode, TextRange, TextUnit, AstNode};\n+use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use ra_db::{SyntaxDatabase, FilesDatabase, LocalSyntaxPtr, BaseDatabase};\n use rayon::prelude::*;\n@@ -259,77 +259,6 @@ pub struct NavigationTarget {\n }\n \n impl NavigationTarget {\n-    fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id: symbol.file_id,\n-            name: symbol.name.clone(),\n-            kind: symbol.ptr.kind(),\n-            range: symbol.ptr.range(),\n-            ptr: Some(symbol.ptr.clone()),\n-        }\n-    }\n-\n-    fn from_syntax(name: Option<Name>, file_id: FileId, node: &SyntaxNode) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id,\n-            name: name.map(|n| n.to_string().into()).unwrap_or(\"\".into()),\n-            kind: node.kind(),\n-            range: node.range(),\n-            ptr: Some(LocalSyntaxPtr::new(node)),\n-        }\n-    }\n-    // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n-    fn from_def(db: &db::RootDatabase, def: Def) -> Cancelable<Option<NavigationTarget>> {\n-        Ok(match def {\n-            Def::Struct(s) => {\n-                let (file_id, node) = s.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    s.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Enum(e) => {\n-                let (file_id, node) = e.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    e.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::EnumVariant(ev) => {\n-                let (file_id, node) = ev.source(db)?;\n-                Some(NavigationTarget::from_syntax(\n-                    ev.name(db)?,\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Function(f) => {\n-                let (file_id, node) = f.source(db)?;\n-                let name = f.signature(db).name().clone();\n-                Some(NavigationTarget::from_syntax(\n-                    Some(name),\n-                    file_id.original_file(db),\n-                    node.syntax(),\n-                ))\n-            }\n-            Def::Module(m) => {\n-                let (file_id, source) = m.definition_source(db)?;\n-                let name = m.name(db)?;\n-                match source {\n-                    ModuleSource::SourceFile(node) => {\n-                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n-                    }\n-                    ModuleSource::Module(node) => {\n-                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n-                    }\n-                }\n-            }\n-            Def::Item => None,\n-        })\n-    }\n-\n     pub fn name(&self) -> &SmolStr {\n         &self.name\n     }"}, {"sha": "bacb7329fc514dd43d23c9d2251b83e257142663", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2aa125251ebd74c0e2a119b351caec27a9e1da46/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa125251ebd74c0e2a119b351caec27a9e1da46/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=2aa125251ebd74c0e2a119b351caec27a9e1da46", "patch": "@@ -0,0 +1,86 @@\n+use ra_db::{FileId, LocalSyntaxPtr, Cancelable};\n+use ra_syntax::{SyntaxNode, AstNode};\n+use hir::{Name, Def, ModuleSource};\n+\n+use crate::{\n+    NavigationTarget,\n+    FileSymbol,\n+    db::RootDatabase,\n+};\n+\n+impl NavigationTarget {\n+    pub(crate) fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id: symbol.file_id,\n+            name: symbol.name.clone(),\n+            kind: symbol.ptr.kind(),\n+            range: symbol.ptr.range(),\n+            ptr: Some(symbol.ptr.clone()),\n+        }\n+    }\n+\n+    pub(crate) fn from_syntax(\n+        name: Option<Name>,\n+        file_id: FileId,\n+        node: &SyntaxNode,\n+    ) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id,\n+            name: name.map(|n| n.to_string().into()).unwrap_or(\"\".into()),\n+            kind: node.kind(),\n+            range: node.range(),\n+            ptr: Some(LocalSyntaxPtr::new(node)),\n+        }\n+    }\n+    // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n+    pub(crate) fn from_def(db: &RootDatabase, def: Def) -> Cancelable<Option<NavigationTarget>> {\n+        Ok(match def {\n+            Def::Struct(s) => {\n+                let (file_id, node) = s.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    s.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Enum(e) => {\n+                let (file_id, node) = e.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    e.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::EnumVariant(ev) => {\n+                let (file_id, node) = ev.source(db)?;\n+                Some(NavigationTarget::from_syntax(\n+                    ev.name(db)?,\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Function(f) => {\n+                let (file_id, node) = f.source(db)?;\n+                let name = f.signature(db).name().clone();\n+                Some(NavigationTarget::from_syntax(\n+                    Some(name),\n+                    file_id.original_file(db),\n+                    node.syntax(),\n+                ))\n+            }\n+            Def::Module(m) => {\n+                let (file_id, source) = m.definition_source(db)?;\n+                let name = m.name(db)?;\n+                match source {\n+                    ModuleSource::SourceFile(node) => {\n+                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n+                    }\n+                    ModuleSource::Module(node) => {\n+                        Some(NavigationTarget::from_syntax(name, file_id, node.syntax()))\n+                    }\n+                }\n+            }\n+            Def::Item => None,\n+        })\n+    }\n+}"}]}