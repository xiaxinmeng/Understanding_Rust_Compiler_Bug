{"sha": "d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWQ0ZjU1ZjdmN2NmMzVkZmJmMzk5NzlhNzIwNjJmNDE4MWY5ZWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T14:11:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:08:14Z"}, "message": "Include @ in crate_ctxt and fn_ctxt type definitions\n\nSo that code using them doesn't have to spell it out constantly.", "tree": {"sha": "4206e3a6ff2c328652770373834f569c67040147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4206e3a6ff2c328652770373834f569c67040147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "html_url": "https://github.com/rust-lang/rust/commit/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1d7f252a9fce3881f48df25197e6d03f94ea8da", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d7f252a9fce3881f48df25197e6d03f94ea8da", "html_url": "https://github.com/rust-lang/rust/commit/b1d7f252a9fce3881f48df25197e6d03f94ea8da"}], "stats": {"total": 320, "additions": 160, "deletions": 160}, "files": [{"sha": "5b7d7a35c537179c6f900d0a6c2e9dd302f0079b", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -501,7 +501,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: link_meta) ->\n     ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n+fn get_symbol_hash(ccx: crate_ctxt, t: ty::t) -> str {\n     let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n@@ -533,28 +533,28 @@ fn exported_name(path: path, hash: str, _vers: str) -> str {\n \n }\n \n-fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n+fn mangle_exported_name(ccx: crate_ctxt, path: path, t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n+fn mangle_internal_name_by_type_only(ccx: crate_ctxt, t: ty::t, name: str) ->\n    str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     ret mangle([path_name(name), path_name(s), path_name(hash)]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n+fn mangle_internal_name_by_path_and_seq(ccx: crate_ctxt, path: path,\n                                         flav: str) -> str {\n     ret mangle(path + [path_name(ccx.names(flav))]);\n }\n \n-fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n+fn mangle_internal_name_by_path(_ccx: crate_ctxt, path: path) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: str) -> str {\n+fn mangle_internal_name_by_seq(ccx: crate_ctxt, flav: str) -> str {\n     ret ccx.names(flav);\n }\n "}, {"sha": "9eb0a34dbcc47b6cf85c69ca21e73f7f0cf78b17", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -19,7 +19,7 @@ export encoded_ty;\n \n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n-type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n+type encode_ctxt = {ccx: crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n fn encode_name(ebml_w: ebml::writer, name: str) {\n@@ -702,7 +702,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n+fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n \n     let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};"}, {"sha": "19966559dccaf8c9a08c26a3418ceadc24f15878", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -63,7 +63,7 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n+fn variant_opt(ccx: crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(ccx.tcx, vdef.enm);\n     for v: ty::variant_info in *variants {\n@@ -155,10 +155,10 @@ fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n     ret enter_match(m, col, val, e);\n }\n \n-fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, enum_size: uint,\n+fn enter_opt(ccx: crate_ctxt, m: match, opt: opt, col: uint, enum_size: uint,\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(ccx: @crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n+    fn e(ccx: crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n          p: @ast::pat) -> option<[@ast::pat]> {\n         alt p.node {\n           ast::pat_enum(ctor, subpats) {\n@@ -235,7 +235,7 @@ fn enter_uniq(m: match, col: uint, val: ValueRef) -> match {\n     ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n-fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n+fn get_options(ccx: crate_ctxt, m: match, col: uint) -> [opt] {\n     fn add_to_set(&set: [opt], val: opt) {\n         for l: opt in set { if opt_eq(l, val) { ret; } }\n         set += [val];"}, {"sha": "b426e193efb2bc378c06226dbde0b5d300c730cb", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -46,7 +46,7 @@ import build::*;\n import shape::*;\n import ast_map::{path, path_mod, path_name};\n \n-fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n+fn type_of_explicit_args(cx: crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n@@ -64,7 +64,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n+fn type_of_fn(cx: crate_ctxt, inputs: [ty::arg],\n               output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n@@ -90,12 +90,12 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n+fn type_of_fn_from_ty(cx: crate_ctxt, fty: ty::t,\n                       param_bounds: [ty::param_bounds]) -> TypeRef {\n     type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n }\n \n-fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+fn type_of(cx: crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_has_vars(t);\n     // Check the cache.\n \n@@ -159,7 +159,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+fn type_of_enum(cx: crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n     let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n     if check type_has_static_size(cx, t) {\n@@ -175,7 +175,7 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn type_of_ty_param_bounds_and_ty\n-    (ccx: @crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n+    (ccx: crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let t = tpt.ty;\n     alt ty::get(t).struct {\n       ty::ty_fn(_) {\n@@ -188,7 +188,7 @@ fn type_of_ty_param_bounds_and_ty\n     type_of(ccx, t)\n }\n \n-fn type_of_or_i8(ccx: @crate_ctxt, typ: ty::t) -> TypeRef {\n+fn type_of_or_i8(ccx: crate_ctxt, typ: ty::t) -> TypeRef {\n     if check type_has_static_size(ccx, typ) {\n         type_of(ccx, typ)\n     } else { T_i8() }\n@@ -223,7 +223,7 @@ fn sanitize(s: str) -> str {\n }\n \n \n-fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timeval,\n+fn log_fn_time(ccx: crate_ctxt, name: str, start: time::timeval,\n                end: time::timeval) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.usec as int) - (start.usec as int)) / 1000;\n@@ -343,7 +343,7 @@ fn dynastack_alloca(cx: block, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     ret PointerCast(dy_cx, llresult, T_ptr(t));\n }\n \n-fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n+fn mk_obstack_token(ccx: crate_ctxt, fcx: fn_ctxt) ->\n    ValueRef {\n     let cx = raw_block(fcx, fcx.lldynamicallocas);\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n@@ -686,7 +686,7 @@ fn get_tydesc(cx: block, t: ty::t, escapes: bool,\n     ret rslt(cx, info.tydesc);\n }\n \n-fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n+fn get_static_tydesc(ccx: crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     alt ccx.tydescs.find(t) {\n       some(info) { ret info; }\n@@ -729,7 +729,7 @@ fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n+fn declare_tydesc(ccx: crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llsize;\n@@ -768,7 +768,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n \n type glue_helper = fn@(block, ValueRef, ty::t);\n \n-fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n+fn declare_generic_glue(ccx: crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: str) -> ValueRef {\n     let name = name;\n     let fn_nm;\n@@ -781,7 +781,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     ret llfn;\n }\n \n-fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n+fn make_generic_glue_inner(ccx: crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n     let fcx = new_fn_ctxt(ccx, [], llfn, none);\n@@ -819,7 +819,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     ret llfn;\n }\n \n-fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n+fn make_generic_glue(ccx: crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, ty_params: [uint], name: str)\n     -> ValueRef {\n     if !ccx.sess.opts.stats {\n@@ -834,7 +834,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n     ret llval;\n }\n \n-fn emit_tydescs(ccx: @crate_ctxt) {\n+fn emit_tydescs(ccx: crate_ctxt) {\n     ccx.tydescs.items {|key, val|\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n@@ -1076,7 +1076,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n }\n \n // Structural comparison: a rather involved form of glue.\n-fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n+fn maybe_name_value(cx: crate_ctxt, v: ValueRef, s: str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_buf(s, {|buf| llvm::LLVMSetValueName(v, buf) });\n     }\n@@ -1279,21 +1279,21 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     ret cx;\n }\n \n-fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n+fn lazily_emit_all_tydesc_glue(ccx: crate_ctxt,\n                                static_ti: option<@tydesc_info>) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n }\n \n-fn lazily_emit_all_generic_info_tydesc_glues(ccx: @crate_ctxt,\n+fn lazily_emit_all_generic_info_tydesc_glues(ccx: crate_ctxt,\n                                              gi: generic_info) {\n     for ti: option<@tydesc_info> in gi.static_tis {\n         lazily_emit_all_tydesc_glue(ccx, ti);\n     }\n }\n \n-fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n+fn lazily_emit_tydesc_glue(ccx: crate_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n     alt static_ti {\n       none { }\n@@ -1612,7 +1612,7 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n+fn trans_crate_lit(cx: crate_ctxt, lit: ast::lit) -> ValueRef {\n     alt lit.node {\n       ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n@@ -2147,7 +2147,7 @@ fn trans_external_path(cx: block, did: ast::def_id,\n                          type_of_ty_param_bounds_and_ty(ccx, tpt));\n }\n \n-fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n+fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n                   dicts: option<typeck::dict_res>)\n     -> option<{llfn: ValueRef, fty: ty::t}> {\n     let substs = vec::map(substs, {|t|\n@@ -2290,7 +2290,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n \n-fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n+fn lookup_discriminant(ccx: crate_ctxt, vid: ast::def_id) -> ValueRef {\n     alt ccx.discrims.find(vid) {\n       none {\n         // It's an external discriminant that we haven't seen yet.\n@@ -3603,7 +3603,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n+fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n              name: str, block_span: option<span>) -> block {\n     let s = \"\";\n     if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -3634,7 +3634,7 @@ fn simple_block_scope() -> block_kind {\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn top_scope_block(fcx: @fn_ctxt, sp: option<span>) -> block {\n+fn top_scope_block(fcx: fn_ctxt, sp: option<span>) -> block {\n     ret new_block(fcx, parent_none, simple_block_scope(),\n                   \"function top level\", sp);\n }\n@@ -3661,7 +3661,7 @@ fn sub_block(bcx: block, n: str) -> block {\n     ret new_block(bcx.fcx, parent_some(bcx), block_non_scope, n, none);\n }\n \n-fn raw_block(fcx: @fn_ctxt, llbb: BasicBlockRef) -> block {\n+fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n     ret @{llbb: llbb,\n           mutable terminated: false,\n           mutable unreachable: false,\n@@ -3764,7 +3764,7 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n     next_cx\n }\n \n-fn trans_fn_cleanups(fcx: @fn_ctxt, cx: block) {\n+fn trans_fn_cleanups(fcx: fn_ctxt, cx: block) {\n     option::may(fcx.llobstacktoken) {|lltoken|\n         Call(cx, fcx.ccx.upcalls.dynastack_free, [lltoken]);\n     }\n@@ -3889,10 +3889,10 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n+fn new_fn_ctxt_w_id(ccx: crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n                     param_substs: option<param_substs>,\n-                    sp: option<span>) -> @fn_ctxt {\n+                    sp: option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n@@ -3918,8 +3918,8 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           ccx: ccx};\n }\n \n-fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n-               sp: option<span>) -> @fn_ctxt {\n+fn new_fn_ctxt(ccx: crate_ctxt, path: path, llfndecl: ValueRef,\n+               sp: option<span>) -> fn_ctxt {\n     ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, sp);\n }\n \n@@ -3937,7 +3937,7 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n+fn create_llargs_for_fn_args(cx: fn_ctxt, ty_self: self_arg,\n                              args: [ast::arg], ty_params: [ast::ty_param]) {\n     // Skip the implicit arguments 0, and 1.\n     let arg_n = first_tp_arg;\n@@ -3980,7 +3980,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: block, args: [ast::arg],\n+fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> block {\n     let tcx = bcx.tcx();\n     let arg_n: uint = 0u, bcx = bcx;\n@@ -4017,14 +4017,14 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: block, args: [ast::arg],\n \n // Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n-fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n+fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, fcx.llreturn);\n     trans_fn_cleanups(fcx, ret_cx);\n     RetVoid(ret_cx);\n }\n \n-fn tie_up_header_blocks(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n+fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     Br(raw_block(fcx, fcx.llstaticallocas), fcx.llloadenv);\n     Br(raw_block(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n     Br(raw_block(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n@@ -4036,11 +4036,11 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n+fn trans_closure(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  param_substs: option<param_substs>,\n-                 id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n+                 id: ast::node_id, maybe_load_env: fn(fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -4078,7 +4078,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n+fn trans_fn(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n             body: ast::blk, llfndecl: ValueRef, ty_self: self_arg,\n             ty_params: [ast::ty_param], param_substs: option<param_substs>,\n             id: ast::node_id) {\n@@ -4097,7 +4097,7 @@ fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     }\n }\n \n-fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n+fn trans_res_ctor(ccx: crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param],\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n@@ -4131,7 +4131,7 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n }\n \n \n-fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n+fn trans_enum_variant(ccx: crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n                       ty_params: [ast::ty_param],\n                       param_substs: option<param_substs>,\n@@ -4200,7 +4200,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n // FIXME: this should do some structural hash-consing to avoid\n // duplicate constants. I think. Maybe LLVM has a magical mode\n // that does so later on?\n-fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n+fn trans_const_expr(cx: crate_ctxt, e: @ast::expr) -> ValueRef {\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n       ast::expr_binary(b, e1, e2) {\n@@ -4271,7 +4271,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n+fn trans_const(cx: crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     let v = trans_const_expr(cx, e);\n \n     // The scalars come back as 1st class LLVM vals\n@@ -4286,7 +4286,7 @@ fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     }\n }\n \n-fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n+fn trans_item(ccx: crate_ctxt, item: ast::item) {\n     let path = alt check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) { p }\n     };\n@@ -4358,7 +4358,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n+fn trans_mod(ccx: crate_ctxt, m: ast::_mod) {\n     for item in m.items { trans_item(ccx, *item); }\n }\n \n@@ -4367,17 +4367,17 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n+fn register_fn(ccx: crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id) {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n-fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n+fn param_bounds(ccx: crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n     ccx.tcx.ty_param_bounds.get(tp.id)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n+fn register_fn_full(ccx: crate_ctxt, sp: span, path: path, flav: str,\n                     tps: [ast::ty_param], node_id: ast::node_id,\n                     node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, node_type,\n@@ -4386,7 +4386,7 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                        lib::llvm::CCallConv, llfty);\n }\n \n-fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n+fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n                       node_id: ast::node_id, node_type: ty::t,\n                       cc: lib::llvm::CallConv, llfty: TypeRef) {\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n@@ -4400,7 +4400,7 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n \n // Create a _rust_main(args: [str]) function which will be called from the\n // runtime rust_start function\n-fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n+fn create_main_wrapper(ccx: crate_ctxt, sp: span, main_llfn: ValueRef,\n                        main_node_type: ty::t) {\n \n     if ccx.main_fn != none::<ValueRef> {\n@@ -4418,7 +4418,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n     ccx.main_fn = some(llfn);\n     create_entry_fn(ccx, llfn);\n \n-    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef,\n+    fn create_main(ccx: crate_ctxt, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n@@ -4446,7 +4446,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         ret llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @crate_ctxt, rust_main: ValueRef) {\n+    fn create_entry_fn(ccx: crate_ctxt, rust_main: ValueRef) {\n         #[cfg(target_os = \"win32\")]\n         fn main_name() -> str { ret \"WinMain@16\"; }\n         #[cfg(target_os = \"macos\")]\n@@ -4498,7 +4498,7 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-fn collect_native_item(ccx: @crate_ctxt,\n+fn collect_native_item(ccx: crate_ctxt,\n                        abi: @mutable option<ast::native_abi>,\n                        i: @ast::native_item) {\n     alt i.node {\n@@ -4549,13 +4549,13 @@ fn collect_native_item(ccx: @crate_ctxt,\n     }\n }\n \n-fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n+fn item_path(ccx: crate_ctxt, i: @ast::item) -> path {\n     *alt check ccx.tcx.items.get(i.id) {\n       ast_map::node_item(_, p) { p }\n     } + [path_name(i.ident)]\n }\n \n-fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n+fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n                 i: @ast::item) {\n     let my_path = item_path(ccx, i);\n     alt i.node {\n@@ -4614,7 +4614,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n     }\n }\n \n-fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n+fn collect_items(ccx: crate_ctxt, crate: @ast::crate) {\n     let abi = @mutable none::<ast::native_abi>;\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_native_item: bind collect_native_item(ccx, abi, _),\n@@ -4624,7 +4624,7 @@ fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n }\n \n // The constant translation pass.\n-fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n+fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n@@ -4660,7 +4660,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n+fn trans_constants(ccx: crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_item: bind trans_constant(ccx, _)\n         with *visit::default_simple_visitor()\n@@ -4672,7 +4672,7 @@ fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     ret PtrToInt(cx, v, ccx.int_type);\n }\n \n-fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+fn p2i(ccx: crate_ctxt, v: ValueRef) -> ValueRef {\n     ret llvm::LLVMConstPtrToInt(v, ccx.int_type);\n }\n \n@@ -4736,7 +4736,7 @@ fn trap(bcx: block) {\n     }\n }\n \n-fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n+fn create_module_map(ccx: crate_ctxt) -> ValueRef {\n     let elttype = T_struct([ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map = str::as_buf(\"_rust_mod_map\", {|buf|\n@@ -4775,7 +4775,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n }\n \n // FIXME use hashed metadata instead of crate names once we have that\n-fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n+fn fill_crate_map(ccx: crate_ctxt, map: ValueRef) {\n     let subcrates: [ValueRef] = [];\n     let i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -4793,7 +4793,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n          C_array(ccx.int_type, subcrates)]));\n }\n \n-fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n+fn write_metadata(cx: crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n@@ -4816,7 +4816,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n }\n \n // Writes the current ABI version into the crate.\n-fn write_abi_version(ccx: @crate_ctxt) {\n+fn write_abi_version(ccx: crate_ctxt) {\n     mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }"}, {"sha": "4e915bc9b54d5de31669f63f99fd890ab9c896ee", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -101,7 +101,7 @@ enum environment_value {\n     env_ref(ValueRef, ty::t, lval_kind),\n }\n \n-fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n+fn ev_to_str(ccx: crate_ctxt, ev: environment_value) -> str {\n     alt ev {\n       env_expr(ex, _) { expr_to_str(ex) }\n       env_copy(v, t, lk) { #fmt(\"copy(%s,%s)\", val_str(ccx.tn, v),\n@@ -385,7 +385,7 @@ fn build_closure(bcx0: block,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: block,\n-                    fcx: @fn_ctxt,\n+                    fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n@@ -709,7 +709,7 @@ enum target_info {\n }\n \n // pth is cx.path\n-fn trans_bind_thunk(ccx: @crate_ctxt,\n+fn trans_bind_thunk(ccx: crate_ctxt,\n                     path: path,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,"}, {"sha": "c6b5f4f9c17c521232911a958753390e779fdc42", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -67,8 +67,8 @@ type stats =\n resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n // Crate context.  Every crate we compile has one of these.\n-type crate_ctxt =\n-    {sess: session::session,\n+type crate_ctxt = @{\n+     sess: session::session,\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n@@ -126,7 +126,7 @@ type param_substs = {tys: [ty::t],\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-type fn_ctxt = {\n+type fn_ctxt = @{\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -203,10 +203,10 @@ type fn_ctxt = {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @crate_ctxt\n+    ccx: crate_ctxt\n };\n \n-fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n+fn warn_not_to_commit(ccx: crate_ctxt, msg: str) {\n     if !ccx.do_not_commit_warning_issued {\n         ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg + \" -- do not commit like this!\");\n@@ -289,7 +289,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n     }\n }\n \n-fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n+fn get_res_dtor(ccx: crate_ctxt, did: ast::def_id, inner_t: ty::t)\n    -> ValueRef {\n     if did.crate == ast::local_crate {\n         alt ccx.item_ids.find(did.node) {\n@@ -358,7 +358,7 @@ type block = @{\n     mutable block_span: option<span>,\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: @fn_ctxt\n+    fcx: fn_ctxt\n };\n \n // First two args are retptr, env\n@@ -410,7 +410,7 @@ fn block_parent(cx: block) -> block {\n // Accessors\n \n impl bxc_cxs for block {\n-    fn ccx() -> @crate_ctxt { self.fcx.ccx }\n+    fn ccx() -> crate_ctxt { self.fcx.ccx }\n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     fn sess() -> session { self.fcx.ccx.sess }\n }\n@@ -463,7 +463,7 @@ fn T_int(targ_cfg: @session::config) -> TypeRef {\n     };\n }\n \n-fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n+fn T_int_ty(cx: crate_ctxt, t: ast::int_ty) -> TypeRef {\n     alt t {\n       ast::ty_i { cx.int_type }\n       ast::ty_char { T_char() }\n@@ -474,7 +474,7 @@ fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     }\n }\n \n-fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n+fn T_uint_ty(cx: crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     alt t {\n       ast::ty_u { cx.int_type }\n       ast::ty_u8 { T_i8() }\n@@ -484,7 +484,7 @@ fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     }\n }\n \n-fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n+fn T_float_ty(cx: crate_ctxt, t: ast::float_ty) -> TypeRef {\n     alt t {\n       ast::ty_f { cx.float_type }\n       ast::ty_f32 { T_f32() }\n@@ -512,7 +512,7 @@ fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n                                False);\n }\n \n-fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n+fn T_fn_pair(cx: crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n@@ -564,7 +564,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n+fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n@@ -576,7 +576,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n     ret t;\n }\n \n-fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n+fn T_glue_fn(cx: crate_ctxt) -> TypeRef {\n     let s = \"glue_fn\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n@@ -615,7 +615,7 @@ fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n                   T_array(t, 0u)]); // elements\n }\n \n-fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+fn T_vec(ccx: crate_ctxt, t: TypeRef) -> TypeRef {\n     ret T_vec2(ccx.sess.targ_cfg, t);\n }\n \n@@ -641,38 +641,38 @@ fn tuplify_cbox_ty(tcx: ty::ctxt, t: ty::t, tydesc_t: ty::t) -> ty::t {\n                          t]);\n }\n \n-fn T_box_header_fields(cx: @crate_ctxt) -> [TypeRef] {\n+fn T_box_header_fields(cx: crate_ctxt) -> [TypeRef] {\n     let ptr = T_ptr(T_i8());\n     ret [cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n-fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n+fn T_box_header(cx: crate_ctxt) -> TypeRef {\n     ret T_struct(T_box_header_fields(cx));\n }\n \n-fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+fn T_box(cx: crate_ctxt, t: TypeRef) -> TypeRef {\n     ret T_struct(T_box_header_fields(cx) + [t]);\n }\n \n-fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_box(cx: crate_ctxt) -> TypeRef {\n     ret T_box(cx, T_i8());\n }\n \n-fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_box_ptr(cx: crate_ctxt) -> TypeRef {\n     ret T_ptr(T_opaque_box(cx));\n }\n \n-fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+fn T_port(cx: crate_ctxt, _t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type]); // Refcount\n \n }\n \n-fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+fn T_chan(cx: crate_ctxt, _t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type]); // Refcount\n \n }\n \n-fn T_taskptr(cx: @crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n@@ -686,17 +686,17 @@ fn T_typaram(tn: type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_cbox_ptr(cx: crate_ctxt) -> TypeRef {\n     // closures look like boxes (even when they are fn~ or fn&)\n     // see trans_closure.rs\n     ret T_opaque_box_ptr(cx);\n }\n \n-fn T_enum_variant(cx: @crate_ctxt) -> TypeRef {\n+fn T_enum_variant(cx: crate_ctxt) -> TypeRef {\n     ret cx.int_type;\n }\n \n-fn T_enum(cx: @crate_ctxt, size: uint) -> TypeRef {\n+fn T_enum(cx: crate_ctxt, size: uint) -> TypeRef {\n     let s = \"enum_\" + uint::to_str(size, 10u);\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t =\n@@ -707,23 +707,23 @@ fn T_enum(cx: @crate_ctxt, size: uint) -> TypeRef {\n     ret t;\n }\n \n-fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_enum(cx: crate_ctxt) -> TypeRef {\n     let s = \"opaque_enum\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_struct([T_enum_variant(cx), T_i8()]);\n     associate_type(cx.tn, s, t);\n     ret t;\n }\n \n-fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_enum_ptr(cx: crate_ctxt) -> TypeRef {\n     ret T_ptr(T_opaque_enum(cx));\n }\n \n-fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n+fn T_captured_tydescs(cx: crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(vec::init_elt::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_iface(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_iface(cx: crate_ctxt) -> TypeRef {\n     T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n }\n \n@@ -765,11 +765,11 @@ fn C_i64(i: i64) -> ValueRef {\n     ret C_integral(T_i64(), i as u64, True);\n }\n \n-fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n+fn C_int(cx: crate_ctxt, i: int) -> ValueRef {\n     ret C_integral(cx.int_type, i as u64, True);\n }\n \n-fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n+fn C_uint(cx: crate_ctxt, i: uint) -> ValueRef {\n     ret C_integral(cx.int_type, i as u64, False);\n }\n \n@@ -778,7 +778,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n+fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n     let sc = str::as_buf(s) {|buf|\n         llvm::LLVMConstString(buf, str::len_bytes(s) as unsigned, False)\n     };\n@@ -827,7 +827,7 @@ fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n         bytes.len() as unsigned, False);\n }\n \n-fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n+fn C_shape(ccx: crate_ctxt, bytes: [u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n     let llglobal = str::as_buf(ccx.names(\"shape\"), {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n@@ -852,7 +852,7 @@ pure fn valid_variant_index(ix: uint, cx: block, enum_id: ast::def_id,\n     }\n }\n \n-pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n+pure fn type_has_static_size(cx: crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }\n "}, {"sha": "9ef099297732cf3bd2b8e89818048935b6b42ccf", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -74,7 +74,7 @@ fn llnull() -> ValueRef unsafe {\n     unsafe::reinterpret_cast(ptr::null::<ValueRef>())\n }\n \n-fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n+fn add_named_metadata(cx: crate_ctxt, name: str, val: ValueRef) {\n     str::as_buf(name, {|sbuf|\n         llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf,\n                                           val)\n@@ -155,7 +155,7 @@ fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n     ret option::none;\n }\n \n-fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n+fn create_compile_unit(cx: crate_ctxt, full_path: str)\n     -> @metadata<compile_unit_md> unsafe {\n     let cache = get_cache(cx);\n     let tg = CompileUnitTag;\n@@ -194,11 +194,11 @@ fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n     ret mdval;\n }\n \n-fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n+fn get_cache(cx: crate_ctxt) -> metadata_cache {\n     option::get(cx.dbg_cx).llmetadata\n }\n \n-fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n+fn create_file(cx: crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n     alt cached_metadata::<@metadata<file_md>>(\n@@ -274,7 +274,7 @@ fn size_and_align_of<T>() -> (int, int) {\n     (sys::size_of::<T>() as int, sys::align_of::<T>() as int)\n }\n \n-fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n+fn create_basic_type(cx: crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     -> @metadata<tydesc_md> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n@@ -328,7 +328,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     ret mdval;\n }\n \n-fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n+fn create_pointer_type(cx: crate_ctxt, t: ty::t, span: span,\n                        pointee: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     let tg = PointerTypeTag;\n@@ -401,7 +401,7 @@ fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n+fn create_record(cx: crate_ctxt, t: ty::t, fields: [ast::ty_field],\n                  span: span) -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -421,7 +421,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n     ret mdval;\n }\n \n-fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n+fn create_boxed_type(cx: crate_ctxt, outer: ty::t, _inner: ty::t,\n                      span: span, boxed: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     //let tg = StructureTypeTag;\n@@ -480,7 +480,7 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n     ret llmdnode(lldata);\n }\n \n-fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n+fn create_vec(cx: crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n               vec_ty_span: codemap::span, elem_ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, vec_ty_span);\n@@ -554,7 +554,7 @@ fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n     }\n }\n \n-fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n+fn create_ty(_cx: crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<tydesc_md>>(\n@@ -576,7 +576,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n \n     fail;\n     /*\n-    fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n+    fn t_to_ty(cx: crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n         let ty = alt ty::get(t).struct {\n           ty::ty_nil { ast::ty_nil }\n           ty::ty_bot { ast::ty_bot }\n@@ -658,7 +658,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     */\n }\n \n-fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {\n+fn filename_from_span(cx: crate_ctxt, sp: codemap::span) -> str {\n     codemap::lookup_char_pos(cx.sess.codemap, sp.lo).file.name\n }\n \n@@ -772,7 +772,7 @@ fn update_source_pos(cx: block, s: span) {\n     llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n }\n \n-fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n+fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n     let dbg_cx = option::get(cx.dbg_cx);\n "}, {"sha": "9cb686c5defdeaa65b82d754c44d02c460212abf", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -41,7 +41,7 @@ import ast_map::{path, path_mod, path_name};\n // annotates nodes with information about the methods and dicts that\n // are referenced (ccx.method_map and ccx.dict_map).\n \n-fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n+fn trans_impl(ccx: crate_ctxt, path: path, name: ast::ident,\n               methods: [@ast::method], id: ast::node_id,\n               tps: [ast::ty_param]) {\n     let sub_path = path + [path_name(name)];\n@@ -100,7 +100,7 @@ fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n      with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n-fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n+fn wrapper_fn_ty(ccx: crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n                  tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n     let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *tps);\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n@@ -203,7 +203,7 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     {inputs: args, output: out_ty}\n }\n \n-fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n+fn trans_vtable(ccx: crate_ctxt, id: ast::node_id, name: str,\n                 ptrs: [ValueRef]) {\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_buf(name, {|buf|\n@@ -230,7 +230,7 @@ fn find_dict_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     option::get(ps.dicts)[dict_off]\n }\n \n-fn resolve_dicts_in_fn_ctxt(fcx: @fn_ctxt, dicts: typeck::dict_res)\n+fn resolve_dicts_in_fn_ctxt(fcx: fn_ctxt, dicts: typeck::dict_res)\n     -> option<typeck::dict_res> {\n     let result = [];\n     for dict in *dicts {\n@@ -265,7 +265,7 @@ fn resolve_dicts_in_fn_ctxt(fcx: @fn_ctxt, dicts: typeck::dict_res)\n     some(@result)\n }\n \n-fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n+fn trans_wrapper(ccx: crate_ctxt, pt: path, llfty: TypeRef,\n                  fill: fn(ValueRef, block) -> block)\n     -> ValueRef {\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n@@ -278,7 +278,7 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n     ret llfn;\n }\n \n-fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n+fn trans_impl_wrapper(ccx: crate_ctxt, pt: path,\n                       extra_tps: [ty::param_bounds], real_fn: ValueRef)\n     -> ValueRef {\n     let {inputs: real_args, output: real_ret} =\n@@ -323,7 +323,7 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n     })\n }\n \n-fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n+fn trans_impl_vtable(ccx: crate_ctxt, pt: path,\n                      iface_id: ast::def_id, ms: [@ast::method],\n                      tps: [ast::ty_param], it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n@@ -347,7 +347,7 @@ fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n     trans_vtable(ccx, it.id, s, ptrs);\n }\n \n-fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n+fn trans_iface_wrapper(ccx: crate_ctxt, pt: path, m: ty::method,\n                        n: uint) -> ValueRef {\n     let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()),\n                                          ty::mk_fn(ccx.tcx, m.fty), m.tps);\n@@ -373,7 +373,7 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n     })\n }\n \n-fn trans_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n+fn trans_iface_vtable(ccx: crate_ctxt, pt: path, it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id))];\n     let i_did = ast_util::local_def(it.id), i = 0u;\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n@@ -478,7 +478,7 @@ fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n     -> {bcx: block, ptrs: [ValueRef]} {\n     let ccx = bcx.ccx();\n-    fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n+    fn get_vtable(ccx: crate_ctxt, did: ast::def_id) -> ValueRef {\n         if did.crate == ast::local_crate {\n             ccx.item_ids.get(did.node)\n         } else {"}, {"sha": "e2ab63302b7987a80db3c66cbe19d016bedabdff", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -26,7 +26,7 @@ type c_stack_tys = {\n     shim_fn_ty: TypeRef\n };\n \n-fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n+fn c_arg_and_ret_lltys(ccx: crate_ctxt,\n                        id: ast::node_id) -> ([TypeRef], TypeRef, ty::t) {\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n@@ -38,7 +38,7 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n     }\n }\n \n-fn c_stack_tys(ccx: @crate_ctxt,\n+fn c_stack_tys(ccx: crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n     let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n@@ -57,7 +57,7 @@ type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n \n-fn build_shim_fn_(ccx: @crate_ctxt,\n+fn build_shim_fn_(ccx: crate_ctxt,\n                   shim_name: str,\n                   llbasefn: ValueRef,\n                   tys: @c_stack_tys,\n@@ -94,7 +94,7 @@ type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type wrap_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef);\n \n-fn build_wrap_fn_(ccx: @crate_ctxt,\n+fn build_wrap_fn_(ccx: crate_ctxt,\n                   tys: @c_stack_tys,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n@@ -158,9 +158,9 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-fn trans_native_mod(ccx: @crate_ctxt,\n+fn trans_native_mod(ccx: crate_ctxt,\n                     native_mod: ast::native_mod, abi: ast::native_abi) {\n-    fn build_shim_fn(ccx: @crate_ctxt,\n+    fn build_shim_fn(ccx: crate_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n@@ -201,7 +201,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                            build_args, build_ret);\n     }\n \n-    fn build_wrap_fn(ccx: @crate_ctxt,\n+    fn build_wrap_fn(ccx: crate_ctxt,\n                      tys: @c_stack_tys,\n                      num_tps: uint,\n                      llshimfn: ValueRef,\n@@ -262,10 +262,10 @@ fn trans_native_mod(ccx: @crate_ctxt,\n     }\n }\n \n-fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n+fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n-    fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n+    fn build_rust_fn(ccx: crate_ctxt, path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let t = ty::node_id_to_type(ccx.tcx, id);\n@@ -277,7 +277,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         ret llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n+    fn build_shim_fn(ccx: crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n@@ -310,7 +310,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                            build_args, build_ret);\n     }\n \n-    fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n+    fn build_wrap_fn(ccx: crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n@@ -348,7 +348,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n }\n \n-fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n+fn register_crust_fn(ccx: crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id) {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, _) = c_arg_and_ret_lltys(ccx, node_id);"}, {"sha": "8bdb6d63a4f957f51612cbff790141ab325eb207", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "patch": "@@ -75,7 +75,7 @@ fn eq_res_info(a: res_info, b: res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n+fn mk_global(ccx: crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n     let llglobal =\n         str::as_buf(name,\n@@ -100,7 +100,7 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n //\n // FIXME: Use this in dynamic_size_of() as well.\n \n-fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n+fn largest_variants(ccx: crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n     // FIXME: We could do better here; e.g. we know that any variant that\n@@ -179,7 +179,7 @@ fn round_up(size: u16, align: u8) -> u16 {\n \n type size_align = {size: u16, align: u8};\n \n-fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n+fn compute_static_enum_size(ccx: crate_ctxt, largest_variants: [uint],\n                            did: ast::def_id) -> size_align {\n     let max_size = 0u16;\n     let max_align = 1u8;\n@@ -219,7 +219,7 @@ enum enum_kind {\n     tk_complex  // N variants, no data\n }\n \n-fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n+fn enum_kind(ccx: crate_ctxt, did: ast::def_id) -> enum_kind {\n     let variants = ty::enum_variants(ccx.tcx, did);\n     if vec::any(*variants) {|v| vec::len(v.args) > 0u} {\n         if vec::len(*variants) == 1u { tk_newtype }\n@@ -293,7 +293,7 @@ fn add_substr(&dest: [u8], src: [u8]) {\n     dest += src;\n }\n \n-fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n+fn shape_of(ccx: crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n     alt ty::get(t).struct {\n@@ -433,7 +433,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n+fn shape_of_variant(ccx: crate_ctxt, v: ty::variant_info,\n                     ty_param_count: uint) -> [u8] {\n     let ty_param_map = [];\n     let i = 0u;\n@@ -444,7 +444,7 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n     ret s;\n }\n \n-fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n+fn gen_enum_shapes(ccx: crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover\n     // new enums, so we must do this first.\n@@ -542,7 +542,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n }\n \n-fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n+fn gen_resource_shapes(ccx: crate_ctxt) -> ValueRef {\n     let dtors = [];\n     let i = 0u;\n     let len = interner::len(ccx.shape_cx.resources);\n@@ -555,7 +555,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n \n-fn gen_shape_tables(ccx: @crate_ctxt) {\n+fn gen_shape_tables(ccx: crate_ctxt) {\n     let lltagstable = gen_enum_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans::common::set_struct_body(ccx.shape_cx.llshapetablesty,\n@@ -618,21 +618,21 @@ fn metrics(bcx: block, t: ty::t) -> metrics {\n }\n \n // Returns the real size of the given type for the current target.\n-fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+fn llsize_of_real(cx: crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the real alignment of the given type for the current target.\n-fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+fn llalign_of_real(cx: crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n-fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+fn llsize_of(cx: crate_ctxt, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n                                False);\n }\n \n-fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+fn llalign_of(cx: crate_ctxt, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n                                False);\n }\n@@ -643,7 +643,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // FIXME: Migrate trans over to use this.\n \n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n+fn static_size_of_enum(cx: crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n       ty::ty_enum(tid, subtys) {"}]}