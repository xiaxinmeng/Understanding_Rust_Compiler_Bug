{"sha": "b22231c820807f451b37810468b66ab1643b757e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjIzMWM4MjA4MDdmNDUxYjM3ODEwNDY4YjY2YWIxNjQzYjc1N2U=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-27T20:20:49Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-06T01:25:30Z"}, "message": "rustfmt librustc_trans/save", "tree": {"sha": "f9847a7d1f86aef58dd1468d341c6decb4fd979f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9847a7d1f86aef58dd1468d341c6decb4fd979f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b22231c820807f451b37810468b66ab1643b757e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b22231c820807f451b37810468b66ab1643b757e", "html_url": "https://github.com/rust-lang/rust/commit/b22231c820807f451b37810468b66ab1643b757e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b22231c820807f451b37810468b66ab1643b757e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7843404d294c51186dfb4876b899d48013aabd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/7843404d294c51186dfb4876b899d48013aabd26", "html_url": "https://github.com/rust-lang/rust/commit/7843404d294c51186dfb4876b899d48013aabd26"}], "stats": {"total": 510, "additions": 260, "deletions": 250}, "files": [{"sha": "7f7b9e0ed7616261d5a626c8546b1bbc58ac2f3f", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b22231c820807f451b37810468b66ab1643b757e", "patch": "@@ -28,6 +28,8 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(const_fn)]\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n #![feature(iter_cmp)]\n #![feature(iter_arith)]\n #![feature(libc)]"}, {"sha": "ae85730a8760fd7fd7537f4d3f543ace112965bc", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 68, "deletions": 111, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=b22231c820807f451b37810468b66ab1643b757e", "patch": "@@ -86,7 +86,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             save_ctxt: SaveContext::from_span_utils(tcx, span_utils.clone()),\n             analysis: analysis,\n             span: span_utils.clone(),\n-            fmt: FmtStrs::new(box Recorder { out: output_file, dump_spans: false },\n+            fmt: FmtStrs::new(box Recorder {\n+                                  out: output_file,\n+                                  dump_spans: false,\n+                              },\n                               span_utils),\n             cur_scope: 0,\n         }\n@@ -123,13 +126,16 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // always using the first ones. So, only error out if we don't have enough spans.\n         // What could go wrong...?\n         if spans.len() < path.segments.len() {\n-            error!(\"Mis-calculated spans for path '{}'. \\\n-                    Found {} spans, expected {}. Found spans:\",\n-                   path_to_string(path), spans.len(), path.segments.len());\n+            error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n+                   path_to_string(path),\n+                   spans.len(),\n+                   path.segments.len());\n             for s in &spans {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n-                       self.span.snippet(*s), loc.file.name, loc.line);\n+                       self.span.snippet(*s),\n+                       loc.file.name,\n+                       loc.line);\n             }\n             return vec!();\n         }\n@@ -168,10 +174,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 qualname.clone()\n             };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname,\n-                                     self.cur_scope);\n+            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n         }\n     }\n \n@@ -191,10 +194,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 qualname.clone()\n             };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname,\n-                                     self.cur_scope);\n+            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n         }\n     }\n \n@@ -210,28 +210,23 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n-        self.fmt.sub_type_ref_str(path.span,\n-                                  *span,\n-                                  &qualname);\n+        self.fmt.sub_type_ref_str(path.span, *span, &qualname);\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n         let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths {\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname,\n-                                     self.cur_scope);\n+            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n         }\n     }\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id));\n+                                   ref_id));\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n@@ -244,8 +239,9 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id));\n+            self.sess.span_bug(span,\n+                               &format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                        ref_id));\n         }\n         let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n@@ -270,8 +266,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def));\n+                self.sess.span_bug(span,\n+                                   &format!(\"lookup_def_kind for unexpected item: {:?}\", def));\n             }\n         }\n     }\n@@ -340,10 +336,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             self.nest(id, |v| v.visit_block(body));\n         }\n \n-        self.process_generic_params(&sig.generics,\n-                                    span,\n-                                    &method_data.qualname,\n-                                    id);\n+        self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n     }\n \n     fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n@@ -382,18 +375,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // However full span is the entire enum/fn/struct block, so we only want\n         // the first few to match the number of generics we're looking for.\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                           (generics.ty_params.len() as isize));\n+                                                            (generics.ty_params.len() as isize));\n         for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n             // Append $id to name to make sure each one is unique\n             let name = format!(\"{}::{}${}\",\n                                prefix,\n                                escape(self.span.snippet(param_ss)),\n                                id);\n-            self.fmt.typedef_str(full_span,\n-                                 Some(param_ss),\n-                                 param.id,\n-                                 &name,\n-                                 \"\");\n+            self.fmt.typedef_str(full_span, Some(param_ss), param.id, &name, \"\");\n         }\n         self.visit_generics(generics);\n     }\n@@ -450,8 +439,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                      expr: &ast::Expr) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(span,\n-                                                        keywords::Const);\n+        let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n \n         self.fmt.static_str(span,\n                             sub_span,\n@@ -631,10 +619,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                      sub_span,\n                                      id,\n                                      self.cur_scope);\n-                    self.fmt.inherit_str(trait_ref.path.span,\n-                                         sub_span,\n-                                         id,\n-                                         item.id);\n+                    self.fmt.inherit_str(trait_ref.path.span, sub_span, id, item.id);\n                 }\n                 None => (),\n             }\n@@ -669,18 +654,18 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             Some(pd) => pd,\n             None => {\n                 self.tcx.sess.span_bug(path.span,\n-                                       &format!(\"Unexpected def kind while looking \\\n-                                                 up path in `{}`\",\n+                                       &format!(\"Unexpected def kind while looking up path in \\\n+                                                 `{}`\",\n                                                 self.span.snippet(path.span)))\n             }\n         };\n         match path_data {\n             Data::VariableRefData(ref vrd) => {\n                 self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n-                                                    path.span,\n-                                                    Some(vrd.span),\n-                                                    vrd.ref_id,\n-                                                    vrd.scope);\n+                                 path.span,\n+                                 Some(vrd.span),\n+                                 vrd.ref_id,\n+                                 vrd.scope);\n \n             }\n             Data::TypeRefData(ref trd) => {\n@@ -698,10 +683,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                        mcd.scope);\n             }\n             Data::FunctionCallData(fcd) => {\n-                self.fmt.fn_call_str(path.span,\n-                                     Some(fcd.span),\n-                                     fcd.ref_id,\n-                                     fcd.scope);\n+                self.fmt.fn_call_str(path.span, Some(fcd.span), fcd.ref_id, fcd.scope);\n             }\n             _ => {\n                 self.sess.span_bug(path.span,\n@@ -758,9 +740,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     continue;\n                 }\n \n-                let field_data = self.save_ctxt.get_field_ref_data(field,\n-                                                                   variant,\n-                                                                   scope);\n+                let field_data = self.save_ctxt.get_field_ref_data(field, variant, scope);\n                 self.fmt.ref_str(recorder::VarRef,\n                                  field.ident.span,\n                                  Some(field_data.span),\n@@ -807,11 +787,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n-                        self.fmt.ref_str(recorder::VarRef,\n-                                         span,\n-                                         sub_span,\n-                                         f.did,\n-                                         self.cur_scope);\n+                        self.fmt.ref_str(recorder::VarRef, span, sub_span, f.did, self.cur_scope);\n                     }\n                     self.visit_pat(&field.pat);\n                 }\n@@ -849,11 +825,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                         // 'use' always introduces an alias, if there is not an explicit\n                         // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n+                        let sub_span = match self.span.sub_span_after_keyword(use_item.span,\n+                                                                              keywords::As) {\n+                            Some(sub_span) => Some(sub_span),\n+                            None => sub_span,\n+                        };\n \n                         self.fmt.use_alias_str(path.span,\n                                                sub_span,\n@@ -877,8 +853,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             }\n                         }\n \n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n+                        let sub_span = self.span\n+                                           .sub_span_of_token(path.span, token::BinOp(token::Star));\n                         self.fmt.use_glob_str(path.span,\n                                               sub_span,\n                                               item.id,\n@@ -893,10 +869,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                     match self.lookup_type_ref(id) {\n                                         Some(def_id) => match self.lookup_def_kind(id, plid.span) {\n                                             Some(kind) => {\n-                                                self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n+                                                self.fmt.ref_str(kind,\n+                                                                 plid.span,\n+                                                                 Some(plid.span),\n+                                                                 def_id,\n+                                                                 self.cur_scope);\n                                             }\n                                             None => (),\n                                         },\n@@ -942,11 +919,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                           ref trait_ref,\n                           ref typ,\n                           ref impl_items) => {\n-                self.process_impl(item,\n-                                  ty_params,\n-                                  trait_ref,\n-                                  &typ,\n-                                  impl_items)\n+                self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n             }\n             ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n@@ -958,11 +931,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                self.fmt.typedef_str(item.span,\n-                                     sub_span,\n-                                     item.id,\n-                                     &qualname,\n-                                     &value);\n+                self.fmt.typedef_str(item.span, sub_span, item.id, &qualname, &value);\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n@@ -988,8 +957,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n             ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id, trait_item.ident.name,\n-                                   trait_item.span, &*ty, &*expr);\n+                self.process_const(trait_item.id,\n+                                   trait_item.ident.name,\n+                                   trait_item.span,\n+                                   &*ty,\n+                                   &*expr);\n             }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig,\n@@ -1006,8 +978,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n             ast::ConstImplItem(ref ty, ref expr) => {\n-                self.process_const(impl_item.id, impl_item.ident.name,\n-                                   impl_item.span, &ty, &expr);\n+                self.process_const(impl_item.id,\n+                                   impl_item.ident.name,\n+                                   impl_item.span,\n+                                   &ty,\n+                                   &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig,\n@@ -1031,11 +1006,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 match self.lookup_type_ref(t.id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(t.span);\n-                        self.fmt.ref_str(recorder::TypeRef,\n-                                         t.span,\n-                                         sub_span,\n-                                         id,\n-                                         self.cur_scope);\n+                        self.fmt.ref_str(recorder::TypeRef, t.span, sub_span, id, self.cur_scope);\n                     }\n                     None => (),\n                 }\n@@ -1067,11 +1038,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 let hir_expr = lower_expr(ex);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.resolve_expr(&hir_expr);\n-                self.process_struct_lit(ex,\n-                                        path,\n-                                        fields,\n-                                        adt.variant_of_def(def),\n-                                        base)\n+                self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n             ast::ExprField(ref sub_ex, _) => {\n@@ -1110,8 +1077,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     }\n                     ty::TyTuple(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct or tuple \\\n-                                                      type, found {:?}\", ty)),\n+                                            &format!(\"Expected struct or tuple type, found {:?}\",\n+                                                     ty)),\n                 }\n             }\n             ast::ExprClosure(_, ref decl, ref body) => {\n@@ -1165,8 +1132,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             let def_map = self.tcx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   &format!(\"def_map has no key for {} in visit_arm\",\n-                                           id));\n+                                   &format!(\"def_map has no key for {} in visit_arm\", id));\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n@@ -1177,13 +1143,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                         \"<mutable>\".to_string()\n                     };\n \n-                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n-                    self.fmt.variable_str(p.span,\n-                                          Some(p.span),\n-                                          id,\n-                                          &path_to_string(p),\n-                                          &value,\n-                                          \"\")\n+                    assert!(p.segments.len() == 1,\n+                            \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span, Some(p.span), id, &path_to_string(p), &value, \"\")\n                 }\n                 def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n@@ -1237,12 +1199,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            self.fmt.variable_str(p.span,\n-                                  sub_span,\n-                                  id,\n-                                  &path_to_string(p),\n-                                  &value,\n-                                  &typ);\n+            self.fmt.variable_str(p.span, sub_span, id, &path_to_string(p), &value, &typ);\n         }\n \n         // Just walk the initialiser and type (don't want to walk the pattern again)."}, {"sha": "e7a3739cb3f1391a74a522e2ed9f7aa346671524", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b22231c820807f451b37810468b66ab1643b757e", "patch": "@@ -184,15 +184,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn from_span_utils(tcx: &'l ty::ctxt<'tcx>,\n                            span_utils: SpanUtils<'l>)\n                            -> SaveContext<'l, 'tcx> {\n-        SaveContext { tcx: tcx, span_utils: span_utils }\n+        SaveContext {\n+            tcx: tcx,\n+            span_utils: span_utils,\n+        }\n     }\n \n     // List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n \n         self.tcx.sess.cstore.iter_crate_data(|n, cmd| {\n-            result.push(CrateData { name: cmd.name.clone(), number: n });\n+            result.push(CrateData {\n+                name: cmd.name.clone(),\n+                number: n,\n+            });\n         });\n \n         result\n@@ -289,10 +295,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     // Common case impl for a struct or something basic.\n                     ast::TyPath(None, ref path) => {\n                         sub_span = self.span_utils.sub_span_for_type_name(path.span).unwrap();\n-                        type_data = self.lookup_ref_id(typ.id).map(|id| TypeRefData {\n-                            span: sub_span,\n-                            scope: parent,\n-                            ref_id: id,\n+                        type_data = self.lookup_ref_id(typ.id).map(|id| {\n+                            TypeRefData {\n+                                span: sub_span,\n+                                scope: parent,\n+                                ref_id: id,\n+                            }\n                         });\n                     }\n                     _ => {\n@@ -302,8 +310,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n \n-                let trait_data =\n-                    trait_ref.as_ref().and_then(|tr| self.get_trait_ref_data(tr, parent));\n+                let trait_data = trait_ref.as_ref()\n+                                          .and_then(|tr| self.get_trait_ref_data(tr, parent));\n \n                 Data::ImplData(ImplData {\n                     id: item.id,\n@@ -323,11 +331,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n-                let qualname = format!(\"::{}::{}\",\n-                                       self.tcx.map.path_to_string(scope),\n-                                       ident);\n-                let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n-                                               .to_string();\n+                let qualname = format!(\"::{}::{}\", self.tcx.map.path_to_string(scope), ident);\n+                let typ = self.tcx.node_types().get(&field.node.id).unwrap().to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(VariableData {\n                     id: field.node.id,\n@@ -359,8 +364,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n-                                    result.push_str(\n-                                        &self.tcx.item_path_str(def_id));\n+                                    result.push_str(&self.tcx.item_path_str(def_id));\n                                 }\n                                 None => {}\n                             }\n@@ -369,16 +373,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Container {:?} for method {} not an impl?\",\n-                                         impl_id, id));\n+                                                   &format!(\"Container {:?} for method {} not \\\n+                                                             an impl?\",\n+                                                            impl_id,\n+                                                            id));\n                         }\n                     }\n                 }\n                 r => {\n                     self.tcx.sess.span_bug(span,\n-                        &format!(\"Container {:?} for method {} is not a node item {:?}\",\n-                                 impl_id, id, r));\n-                },\n+                                           &format!(\"Container {:?} for method {} is not a node \\\n+                                                     item {:?}\",\n+                                                    impl_id,\n+                                                    id,\n+                                                    r));\n+                }\n             },\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n@@ -388,31 +397,32 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n                         r => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Could not find container {:?} for method {}, got {:?}\",\n-                                         def_id, id, r));\n+                                                   &format!(\"Could not find container {:?} for \\\n+                                                             method {}, got {:?}\",\n+                                                            def_id,\n+                                                            id,\n+                                                            r));\n                         }\n                     }\n                 }\n                 None => {\n                     self.tcx.sess.span_bug(span,\n-                        &format!(\"Could not find container for method {}\", id));\n+                                           &format!(\"Could not find container for method {}\", id));\n                 }\n             },\n         };\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n         let def_id = self.tcx.map.local_def_id(id);\n-        let decl_id =\n-            self.tcx.trait_item_of_item(def_id)\n-            .and_then(|new_id| {\n-                let new_def_id = new_id.def_id();\n-                if new_def_id != def_id {\n-                    Some(new_def_id)\n-                } else {\n-                    None\n-                }\n-            });\n+        let decl_id = self.tcx.trait_item_of_item(def_id).and_then(|new_id| {\n+            let new_def_id = new_id.def_id();\n+            if new_def_id != def_id {\n+                Some(new_def_id)\n+            } else {\n+                None\n+            }\n+        });\n \n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n \n@@ -547,11 +557,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n                     match ti.container() {\n                         ty::TraitContainer(def_id) => {\n-                            self.tcx.trait_items(def_id)\n+                            self.tcx\n+                                .trait_items(def_id)\n                                 .iter()\n-                                .find(|mr| {\n-                                    mr.name() == ti.name() && self.trait_method_has_body(mr)\n-                                })\n+                                .find(|mr| mr.name() == ti.name() && self.trait_method_has_body(mr))\n                                 .map(|mr| mr.def_id())\n                         }\n                         ty::ImplContainer(def_id) => {\n@@ -560,9 +569,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                            .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n-                                                self.tcx.impl_or_trait_item(mr.def_id()).name()\n-                                                    == ti.name()\n-                                            })\n+                                               self.tcx.impl_or_trait_item(mr.def_id()).name() ==\n+                                               ti.name()\n+                                           })\n                                            .unwrap()\n                                            .def_id())\n                         }\n@@ -668,10 +677,7 @@ impl<'v> Visitor<'v> for PathCollector {\n \n         match p.node {\n             ast::PatStruct(ref path, _, _) => {\n-                self.collected_paths.push((p.id,\n-                                           path.clone(),\n-                                           ast::MutMutable,\n-                                           recorder::TypeRef));\n+                self.collected_paths.push((p.id, path.clone(), ast::MutMutable, recorder::TypeRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {\n@@ -729,7 +735,8 @@ pub fn process_crate(tcx: &ty::ctxt,\n \n     if let Err(e) = fs::create_dir_all(&root_path) {\n         tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n-                              root_path.display(), e));\n+                              root_path.display(),\n+                              e));\n     }\n \n     {"}, {"sha": "ade7f95f40bca720b17ca0dd5ab4b7fe4e467df1", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 112, "deletions": 83, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=b22231c820807f451b37810468b66ab1643b757e", "patch": "@@ -22,7 +22,10 @@ use syntax::ast;\n use syntax::ast::NodeId;\n use syntax::codemap::*;\n \n-const CRATE_ROOT_DEF_ID: DefId = DefId { krate: LOCAL_CRATE, index: CRATE_DEF_INDEX };\n+const CRATE_ROOT_DEF_ID: DefId = DefId {\n+    krate: LOCAL_CRATE,\n+    index: CRATE_DEF_INDEX,\n+};\n \n pub struct Recorder {\n     // output file\n@@ -41,7 +44,9 @@ impl Recorder {\n     pub fn dump_span(&mut self, su: SpanUtils, kind: &str, span: Span, _sub_span: Option<Span>) {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n-                             kind, su.extent_str(span), escape(su.snippet(span)));\n+                             kind,\n+                             su.extent_str(span),\n+                             escape(su.snippet(span)));\n         self.record(&result[..]);\n     }\n }\n@@ -93,7 +98,10 @@ pub enum Row {\n \n impl<'a> FmtStrs<'a> {\n     pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>) -> FmtStrs<'a> {\n-        FmtStrs { recorder: rec, span: span }\n+        FmtStrs {\n+            recorder: rec,\n+            span: span,\n+        }\n     }\n \n     // A map from kind of item to a tuple of\n@@ -104,52 +112,93 @@ impl<'a> FmtStrs<'a> {\n     fn lookup_row(r: Row) -> (&'static str, Vec<&'static str>, bool, bool) {\n         match r {\n             Variable => (\"variable\",\n-                         vec!(\"id\",\"name\",\"qualname\",\"value\",\"type\",\"scopeid\"),\n+                         vec!(\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"),\n                          true,\n                          true),\n-            Enum => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n+            Enum => (\"enum\",\n+                     vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n+                     true,\n+                     true),\n             Variant => (\"variant\",\n-                        vec!(\"id\",\"name\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n+                        vec!(\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"),\n                         true,\n                         true),\n             VariantStruct => (\"variant_struct\",\n-                              vec!(\"id\",\"ctor_id\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n+                              vec!(\"id\", \"ctor_id\", \"qualname\", \"type\", \"value\", \"scopeid\"),\n                               true,\n                               true),\n             Function => (\"function\",\n-                         vec!(\"id\",\"qualname\",\"declid\",\"declidcrate\",\"scopeid\"),\n+                         vec!(\"id\", \"qualname\", \"declid\", \"declidcrate\", \"scopeid\"),\n                          true,\n                          true),\n-            MethodDecl => (\"method_decl\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n-            Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n-            Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n+            MethodDecl => (\"method_decl\",\n+                           vec!(\"id\", \"qualname\", \"scopeid\"),\n+                           true,\n+                           true),\n+            Struct => (\"struct\",\n+                       vec!(\"id\", \"ctor_id\", \"qualname\", \"scopeid\", \"value\"),\n+                       true,\n+                       true),\n+            Trait => (\"trait\",\n+                      vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n+                      true,\n+                      true),\n             Impl => (\"impl\",\n-                     vec!(\"id\",\"refid\",\"refidcrate\",\"traitid\",\"traitidcrate\",\"scopeid\"),\n+                     vec!(\"id\",\n+                          \"refid\",\n+                          \"refidcrate\",\n+                          \"traitid\",\n+                          \"traitidcrate\",\n+                          \"scopeid\"),\n                      true,\n                      true),\n-            Module => (\"module\", vec!(\"id\",\"qualname\",\"scopeid\",\"def_file\"), true, false),\n-            UseAlias => (\"use_alias\", vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"), true, true),\n-            UseGlob => (\"use_glob\", vec!(\"id\",\"value\",\"scopeid\"), true, true),\n+            Module => (\"module\",\n+                       vec!(\"id\", \"qualname\", \"scopeid\", \"def_file\"),\n+                       true,\n+                       false),\n+            UseAlias => (\"use_alias\",\n+                         vec!(\"id\", \"refid\", \"refidcrate\", \"name\", \"scopeid\"),\n+                         true,\n+                         true),\n+            UseGlob => (\"use_glob\", vec!(\"id\", \"value\", \"scopeid\"), true, true),\n             ExternCrate => (\"extern_crate\",\n-                            vec!(\"id\",\"name\",\"location\",\"crate\",\"scopeid\"),\n+                            vec!(\"id\", \"name\", \"location\", \"crate\", \"scopeid\"),\n                             true,\n                             true),\n             Inheritance => (\"inheritance\",\n-                            vec!(\"base\",\"basecrate\",\"derived\",\"derivedcrate\"),\n+                            vec!(\"base\", \"basecrate\", \"derived\", \"derivedcrate\"),\n                             true,\n                             false),\n             MethodCall => (\"method_call\",\n-                           vec!(\"refid\",\"refidcrate\",\"declid\",\"declidcrate\",\"scopeid\"),\n+                           vec!(\"refid\", \"refidcrate\", \"declid\", \"declidcrate\", \"scopeid\"),\n                            true,\n                            true),\n-            Typedef => (\"typedef\", vec!(\"id\",\"qualname\",\"value\"), true, true),\n-            ExternalCrate => (\"external_crate\", vec!(\"name\",\"crate\",\"file_name\"), false, false),\n+            Typedef => (\"typedef\", vec!(\"id\", \"qualname\", \"value\"), true, true),\n+            ExternalCrate => (\"external_crate\",\n+                              vec!(\"name\", \"crate\", \"file_name\"),\n+                              false,\n+                              false),\n             Crate => (\"crate\", vec!(\"name\"), true, false),\n-            FnCall => (\"fn_call\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n-            ModRef => (\"mod_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n-            VarRef => (\"var_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n-            TypeRef => (\"type_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n-            FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n+            FnCall => (\"fn_call\",\n+                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n+                       true,\n+                       true),\n+            ModRef => (\"mod_ref\",\n+                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n+                       true,\n+                       true),\n+            VarRef => (\"var_ref\",\n+                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n+                       true,\n+                       true),\n+            TypeRef => (\"type_ref\",\n+                        vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n+                        true,\n+                        true),\n+            FnRef => (\"fn_ref\",\n+                      vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n+                      true,\n+                      true),\n         }\n     }\n \n@@ -160,9 +209,12 @@ impl<'a> FmtStrs<'a> {\n                            span: Span)\n                            -> Option<String> {\n         if values.len() != fields.len() {\n-            self.span.sess.span_bug(span, &format!(\n-                \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len()));\n+            self.span.sess.span_bug(span,\n+                                    &format!(\"Mismatch between length of fields for '{}', \\\n+                                              expected '{}', found '{}'\",\n+                                             kind,\n+                                             fields.len(),\n+                                             values.len()));\n         }\n \n         let values = values.iter().map(|s| {\n@@ -176,19 +228,21 @@ impl<'a> FmtStrs<'a> {\n \n         let pairs = fields.iter().zip(values);\n         let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n-        Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(&ss[..]);\n-            s\n-        }))\n+        Some(strs.fold(String::new(),\n+                       |mut s, ss| {\n+                           s.push_str(&ss[..]);\n+                           s\n+                       }))\n     }\n \n     pub fn record_without_span(&mut self, kind: Row, values: Vec<String>, span: Span) {\n         let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n \n         if needs_span {\n-            self.span.sess.span_bug(span, &format!(\n-                \"Called record_without_span for '{}' which does requires a span\",\n-                label));\n+            self.span.sess.span_bug(span,\n+                                    &format!(\"Called record_without_span for '{}' which does \\\n+                                              requires a span\",\n+                                             label));\n         }\n         assert!(!dump_spans);\n \n@@ -216,25 +270,26 @@ impl<'a> FmtStrs<'a> {\n \n         if self.recorder.dump_spans {\n             if dump_spans {\n-                self.recorder.dump_span(self.span.clone(),\n-                                        label,\n-                                        span,\n-                                        Some(sub_span));\n+                self.recorder.dump_span(self.span.clone(), label, span, Some(sub_span));\n             }\n             return;\n         }\n \n         if !needs_span {\n             self.span.sess.span_bug(span,\n-                                    &format!(\"Called record_with_span for '{}' \\\n-                                              which does not require a span\", label));\n+                                    &format!(\"Called record_with_span for '{}' which does not \\\n+                                              require a span\",\n+                                             label));\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {\n             Some(vs) => vs,\n             None => return,\n         };\n-        let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n+        let result = format!(\"{},{}{}\\n\",\n+                             label,\n+                             self.span.extent_str(sub_span),\n+                             values_str);\n         self.recorder.record(&result[..]);\n     }\n \n@@ -326,10 +381,7 @@ impl<'a> FmtStrs<'a> {\n                     name: &str,\n                     scope_id: NodeId,\n                     value: &str) {\n-        self.check_and_record(Enum,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, scope_id, value));\n+        self.check_and_record(Enum, span, sub_span, svec!(id, name, scope_id, value));\n     }\n \n     pub fn tuple_variant_str(&mut self,\n@@ -382,13 +434,14 @@ impl<'a> FmtStrs<'a> {\n                       decl_id: Option<DefId>,\n                       scope_id: NodeId) {\n         let values = match decl_id {\n-            Some(decl_id) => svec!(id, name, decl_id.index.as_usize(), decl_id.krate, scope_id),\n+            Some(decl_id) => svec!(id,\n+                                   name,\n+                                   decl_id.index.as_usize(),\n+                                   decl_id.krate,\n+                                   scope_id),\n             None => svec!(id, name, \"\", \"\", scope_id),\n         };\n-        self.check_and_record(Function,\n-                              span,\n-                              sub_span,\n-                              values);\n+        self.check_and_record(Function, span, sub_span, values);\n     }\n \n     pub fn method_decl_str(&mut self,\n@@ -397,10 +450,7 @@ impl<'a> FmtStrs<'a> {\n                            id: NodeId,\n                            name: &str,\n                            scope_id: NodeId) {\n-        self.check_and_record(MethodDecl,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, scope_id));\n+        self.check_and_record(MethodDecl, span, sub_span, svec!(id, name, scope_id));\n     }\n \n     pub fn struct_str(&mut self,\n@@ -424,10 +474,7 @@ impl<'a> FmtStrs<'a> {\n                      name: &str,\n                      scope_id: NodeId,\n                      value: &str) {\n-        self.check_and_record(Trait,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, scope_id, value));\n+        self.check_and_record(Trait, span, sub_span, svec!(id, name, scope_id, value));\n     }\n \n     pub fn impl_str(&mut self,\n@@ -483,10 +530,7 @@ impl<'a> FmtStrs<'a> {\n                         id: NodeId,\n                         values: &str,\n                         parent: NodeId) {\n-        self.check_and_record(UseGlob,\n-                              span,\n-                              sub_span,\n-                              svec!(id, values, parent));\n+        self.check_and_record(UseGlob, span, sub_span, svec!(id, values, parent));\n     }\n \n     pub fn extern_crate_str(&mut self,\n@@ -511,10 +555,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Inheritance,\n                               span,\n                               sub_span,\n-                              svec!(base_id.index.as_usize(),\n-                                    base_id.krate,\n-                                    deriv_id,\n-                                    0));\n+                              svec!(base_id.index.as_usize(), base_id.krate, deriv_id, 0));\n     }\n \n     pub fn fn_call_str(&mut self,\n@@ -546,10 +587,7 @@ impl<'a> FmtStrs<'a> {\n     }\n \n     pub fn sub_mod_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str, parent: NodeId) {\n-        self.record_with_span(ModRef,\n-                              span,\n-                              sub_span,\n-                              svec!(0, 0, qualname, parent));\n+        self.record_with_span(ModRef, span, sub_span, svec!(0, 0, qualname, parent));\n     }\n \n     pub fn typedef_str(&mut self,\n@@ -558,17 +596,11 @@ impl<'a> FmtStrs<'a> {\n                        id: NodeId,\n                        qualname: &str,\n                        value: &str) {\n-        self.check_and_record(Typedef,\n-                              span,\n-                              sub_span,\n-                              svec!(id, qualname, value));\n+        self.check_and_record(Typedef, span, sub_span, svec!(id, qualname, value));\n     }\n \n     pub fn crate_str(&mut self, span: Span, name: &str) {\n-        self.record_with_span(Crate,\n-                              span,\n-                              span,\n-                              svec!(name));\n+        self.record_with_span(Crate, span, span, svec!(name));\n     }\n \n     pub fn external_crate_str(&mut self, span: Span, name: &str, num: ast::CrateNum) {\n@@ -579,10 +611,7 @@ impl<'a> FmtStrs<'a> {\n     }\n \n     pub fn sub_type_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str) {\n-        self.record_with_span(TypeRef,\n-                              span,\n-                              sub_span,\n-                              svec!(0, 0, qualname, 0));\n+        self.record_with_span(TypeRef, span, sub_span, svec!(0, 0, qualname, 0));\n     }\n \n     // A slightly generic function for a reference to an item of any kind."}, {"sha": "aa1976804382d69635a8e6d4b784b3312681276e", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22231c820807f451b37810468b66ab1643b757e/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=b22231c820807f451b37810468b66ab1643b757e", "patch": "@@ -29,7 +29,10 @@ pub struct SpanUtils<'a> {\n \n impl<'a> SpanUtils<'a> {\n     pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n-        SpanUtils { sess: sess, err_count: Cell::new(0) }\n+        SpanUtils {\n+            sess: sess,\n+            err_count: Cell::new(0),\n+        }\n     }\n \n     // Standard string for extents/location.\n@@ -55,7 +58,9 @@ impl<'a> SpanUtils<'a> {\n         let loc = self.sess.codemap().lookup_char_pos(span.lo);\n         assert!(!generated_code(span),\n                 \"generated code; we should not be processing this `{}` in {}, line {}\",\n-                 self.snippet(span), loc.file.name, loc.line);\n+                self.snippet(span),\n+                loc.file.name,\n+                loc.line);\n \n         match sub_span {\n             None => None,\n@@ -87,8 +92,9 @@ impl<'a> SpanUtils<'a> {\n         // the codemap as a new filemap. This is mostly OK, but means we should\n         // not iterate over the codemap. Also, any spans over the new filemap\n         // are incompatible with spans over other filemaps.\n-        let filemap = self.sess.codemap().new_filemap(String::from(\"<anon-dxr>\"),\n-                                                      self.snippet(span));\n+        let filemap = self.sess\n+                          .codemap()\n+                          .new_filemap(String::from(\"<anon-dxr>\"), self.snippet(span));\n         let s = self.sess;\n         lexer::StringReader::new(s.diagnostic(), filemap)\n     }\n@@ -214,8 +220,11 @@ impl<'a> SpanUtils<'a> {\n         if bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n-                &format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line));\n+                               &format!(\"Mis-counted brackets when breaking path? Parsing '{}' \\\n+                                         in {}, line {}\",\n+                                        self.snippet(span),\n+                                        loc.file.name,\n+                                        loc.line));\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -240,9 +249,12 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    self.sess.span_bug(span, &format!(\n-                        \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line));\n+                    self.sess.span_bug(span,\n+                                       &format!(\"Mis-counted brackets when breaking path? \\\n+                                                 Parsing '{}' in {}, line {}\",\n+                                                self.snippet(span),\n+                                                loc.file.name,\n+                                                loc.line));\n                 }\n                 return result\n             }\n@@ -356,8 +368,11 @@ impl<'a> SpanUtils<'a> {\n     pub fn report_span_err(&self, kind: &str, span: Span) {\n         let loc = self.sess.codemap().lookup_char_pos(span.lo);\n         info!(\"({}) Could not find sub_span in `{}` in {}, line {}\",\n-              kind, self.snippet(span), loc.file.name, loc.line);\n-        self.err_count.set(self.err_count.get()+1);\n+              kind,\n+              self.snippet(span),\n+              loc.file.name,\n+              loc.line);\n+        self.err_count.set(self.err_count.get() + 1);\n         if self.err_count.get() > 1000 {\n             self.sess.bug(\"span errors reached 1000, giving up\");\n         }"}]}