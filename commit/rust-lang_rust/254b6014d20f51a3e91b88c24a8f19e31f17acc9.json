{"sha": "254b6014d20f51a3e91b88c24a8f19e31f17acc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NGI2MDE0ZDIwZjUxYTNlOTFiODhjMjRhOGYxOWUzMWYxN2FjYzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-05-09T15:33:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-05-09T16:09:29Z"}, "message": "std: Avoid `ptr::copy` if unnecessary in `vec::Drain`\n\nThis commit is spawned out of a performance regression investigation in #50496.\nIn tracking down this regression it turned out that the `expand_statements`\nfunction in the compiler was taking quite a long time. Further investigation\nshowed two key properties:\n\n* The function was \"fast\" on glibc 2.24 and slow on glibc 2.23\n* The hottest function was memmove from glibc\n\nCombined together it looked like glibc gained an optimization to the memmove\nfunction in 2.24. Ideally we don't want to rely on this optimization, so I\nwanted to dig further to see what was happening.\n\nThe hottest part of `expand_statements` was `Drop for Drain` in the call to\n`splice` where we insert new statements into the original vector. This *should*\nbe a cheap operation because we're draining and replacing iterators of the exact\nsame length, but under the hood memmove was being called a lot, causing a\nslowdown on glibc 2.23.\n\nIt turns out that at least one of the optimizations in glibc 2.24 was that\n`memmove` where the src/dst are equal becomes much faster. [This program][prog]\nexecutes in ~2.5s against glibc 2.23 and ~0.3s against glibc 2.24, exhibiting\nhow glibc 2.24 is optimizing `memmove` if the src/dst are equal.\n\nAnd all that brings us to what this commit itself is doing. The change here is\npurely to `Drop for Drain` to avoid the call to `ptr::copy` if the region being\ncopied doesn't actually need to be copied. For normal usage of just `Drain`\nitself this check isn't really necessary, but because `Splice` internally\ncontains `Drain` this provides a nice speed boost on glibc 2.23. Overall this\nshould fix the regression seen in #50496 on glibc 2.23 and also fix the\nregression on Windows where `memmove` looks to not have this optimization.\n\nNote that the way `splice` was called in `expand_statements` would cause a\nquadratic number of elements to be copied via `memmove` which is likely why the\ntuple-stress benchmark showed such a severe regression.\n\nCloses #50496\n\n[prog]: https://gist.github.com/alexcrichton/c05bc51c6771bba5ae5b57561a6c1cd3", "tree": {"sha": "7ec63b8a386e2e502eba5a9159dde8022a8b7e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ec63b8a386e2e502eba5a9159dde8022a8b7e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/254b6014d20f51a3e91b88c24a8f19e31f17acc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/254b6014d20f51a3e91b88c24a8f19e31f17acc9", "html_url": "https://github.com/rust-lang/rust/commit/254b6014d20f51a3e91b88c24a8f19e31f17acc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/254b6014d20f51a3e91b88c24a8f19e31f17acc9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff4b42064b374bb62043f7729f84b6d979c7667", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff4b42064b374bb62043f7729f84b6d979c7667", "html_url": "https://github.com/rust-lang/rust/commit/8ff4b42064b374bb62043f7729f84b6d979c7667"}], "stats": {"total": 8, "additions": 5, "deletions": 3}, "files": [{"sha": "690cbcb559bbf6099f4e67b0907bebf9e01051c6", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/254b6014d20f51a3e91b88c24a8f19e31f17acc9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254b6014d20f51a3e91b88c24a8f19e31f17acc9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=254b6014d20f51a3e91b88c24a8f19e31f17acc9", "patch": "@@ -2533,9 +2533,11 @@ impl<'a, T> Drop for Drain<'a, T> {\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n-                let src = source_vec.as_ptr().offset(tail as isize);\n-                let dst = source_vec.as_mut_ptr().offset(start as isize);\n-                ptr::copy(src, dst, self.tail_len);\n+                if tail != start {\n+                    let src = source_vec.as_ptr().offset(tail as isize);\n+                    let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                    ptr::copy(src, dst, self.tail_len);\n+                }\n                 source_vec.set_len(start + self.tail_len);\n             }\n         }"}]}