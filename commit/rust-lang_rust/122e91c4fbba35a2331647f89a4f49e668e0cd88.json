{"sha": "122e91c4fbba35a2331647f89a4f49e668e0cd88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMmU5MWM0ZmJiYTM1YTIzMzE2NDdmODlhNGY0OWU2NjhlMGNkODg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-28T18:35:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-28T21:09:08Z"}, "message": "promotion: factor some common code into validate_ref", "tree": {"sha": "a635c024b5373a589a25f36f02cdb8786aa91964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a635c024b5373a589a25f36f02cdb8786aa91964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/122e91c4fbba35a2331647f89a4f49e668e0cd88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/122e91c4fbba35a2331647f89a4f49e668e0cd88", "html_url": "https://github.com/rust-lang/rust/commit/122e91c4fbba35a2331647f89a4f49e668e0cd88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/122e91c4fbba35a2331647f89a4f49e668e0cd88/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "html_url": "https://github.com/rust-lang/rust/commit/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8"}], "stats": {"total": 107, "additions": 50, "deletions": 57}, "files": [{"sha": "6791d7b1ba0c73aa78ece4c945cb909b2d0cd4f5", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 50, "deletions": 57, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/122e91c4fbba35a2331647f89a4f49e668e0cd88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122e91c4fbba35a2331647f89a4f49e668e0cd88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=122e91c4fbba35a2331647f89a4f49e668e0cd88", "patch": "@@ -309,49 +309,26 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        match kind {\n-                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n-\n-                            // FIXME(eddyb) these aren't promoted here but *could*\n-                            // be promoted as part of a larger value because\n-                            // `validate_rvalue`  doesn't check them, need to\n-                            // figure out what is the intended behavior.\n-                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n-                        }\n-\n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n                         self.validate_local(place.local)?;\n \n+                        // The reference operation itself must be promotable.\n+                        // (Needs to come after `validate_local` to avoid ICEs.)\n+                        self.validate_ref(*kind, place)?;\n+\n+                        // We do not check all the projections (they do not get promoted anyway),\n+                        // but we do stay away from promoting anything involving a dereference.\n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n \n-                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n-                        let has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                        if has_mut_interior {\n+                        // We cannot promote things that need dropping, since the promoted value\n+                        // would not get dropped.\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n-\n-                            // In theory, any zero-sized value could be borrowed\n-                            // mutably without consequences. However, only &mut []\n-                            // is allowed right now.\n-                            if let ty::Array(_, len) = ty.kind() {\n-                                match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) => {}\n-                                    _ => return Err(Unpromotable),\n-                                }\n-                            } else {\n-                                return Err(Unpromotable);\n-                            }\n-                        }\n \n                         Ok(())\n                     }\n@@ -572,6 +549,39 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n+    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+        match kind {\n+            // Reject these borrow types just to be safe.\n+            // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n+            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+\n+            BorrowKind::Shared => {\n+                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n+                if has_mut_interior {\n+                    return Err(Unpromotable);\n+                }\n+            }\n+\n+            BorrowKind::Mut { .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n+\n+                // In theory, any zero-sized value could be borrowed\n+                // mutably without consequences. However, only &mut []\n+                // is allowed right now.\n+                if let ty::Array(_, len) = ty.kind() {\n+                    match len.try_eval_usize(self.tcx, self.param_env) {\n+                        Some(0) => {}\n+                        _ => return Err(Unpromotable),\n+                    }\n+                } else {\n+                    return Err(Unpromotable);\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n@@ -640,37 +650,20 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::Ref(_, kind, place) => {\n-                if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now.\n-                    if let ty::Array(_, len) = ty.kind() {\n-                        match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) => {}\n-                            _ => return Err(Unpromotable),\n-                        }\n-                    } else {\n-                        return Err(Unpromotable);\n-                    }\n-                }\n-\n                 // Special-case reborrows to be more like a copy of the reference.\n-                let mut place = place.as_ref();\n-                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                let mut place_simplified = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n+                    let base_ty = Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place = PlaceRef { local: place.local, projection: proj_base };\n+                        place_simplified = PlaceRef { local: place_simplified.local, projection: proj_base };\n                     }\n                 }\n \n-                self.validate_place(place)?;\n+                self.validate_place(place_simplified)?;\n \n-                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                if has_mut_interior {\n-                    return Err(Unpromotable);\n-                }\n+                // Check that the reference is fine (using the original place!).\n+                // (Needs to come after `validate_local` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n \n                 Ok(())\n             }"}]}