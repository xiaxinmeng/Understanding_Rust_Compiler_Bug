{"sha": "086a5ca7d25307325912cab2a67384867daa04c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NmE1Y2E3ZDI1MzA3MzI1OTEyY2FiMmE2NzM4NDg2N2RhYTA0YzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-12T00:12:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-17T08:39:10Z"}, "message": "librustc: Allow trait bounds on structures and enumerations, and check\nthem during kind checking.\n\nThis implements RFC #11.\n\nCloses #15759.", "tree": {"sha": "758037316d3dfcc83fe79017e777dbef44c02072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/758037316d3dfcc83fe79017e777dbef44c02072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/086a5ca7d25307325912cab2a67384867daa04c5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/086a5ca7d25307325912cab2a67384867daa04c5", "html_url": "https://github.com/rust-lang/rust/commit/086a5ca7d25307325912cab2a67384867daa04c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/086a5ca7d25307325912cab2a67384867daa04c5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "html_url": "https://github.com/rust-lang/rust/commit/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06"}], "stats": {"total": 665, "additions": 622, "deletions": 43}, "files": [{"sha": "0051d9a89c2befae2a39fec2b8082557b8f1f093", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -1456,13 +1456,24 @@ pub mod types {\n                     pub Data4: [BYTE, ..8],\n                 }\n \n+                // NOTE(pcwalton, stage0): Remove after snapshot (typeck bug\n+                // workaround).\n+                #[cfg(stage0)]\n                 pub struct WSAPROTOCOLCHAIN {\n                     pub ChainLen: c_int,\n                     pub ChainEntries: [DWORD, ..MAX_PROTOCOL_CHAIN],\n                 }\n+                #[cfg(not(stage0))]\n+                pub struct WSAPROTOCOLCHAIN {\n+                    pub ChainLen: c_int,\n+                    pub ChainEntries: [DWORD, ..MAX_PROTOCOL_CHAIN as uint],\n+                }\n \n                 pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n \n+                // NOTE(pcwalton, stage0): Remove after snapshot (typeck bug\n+                // workaround).\n+                #[cfg(stage0)]\n                 pub struct WSAPROTOCOL_INFO {\n                     pub dwServiceFlags1: DWORD,\n                     pub dwServiceFlags2: DWORD,\n@@ -1485,6 +1496,29 @@ pub mod types {\n                     pub dwProviderReserved: DWORD,\n                     pub szProtocol: [u8, ..WSAPROTOCOL_LEN+1],\n                 }\n+                #[cfg(not(stage0))]\n+                pub struct WSAPROTOCOL_INFO {\n+                    pub dwServiceFlags1: DWORD,\n+                    pub dwServiceFlags2: DWORD,\n+                    pub dwServiceFlags3: DWORD,\n+                    pub dwServiceFlags4: DWORD,\n+                    pub dwProviderFlags: DWORD,\n+                    pub ProviderId: GUID,\n+                    pub dwCatalogEntryId: DWORD,\n+                    pub ProtocolChain: WSAPROTOCOLCHAIN,\n+                    pub iVersion: c_int,\n+                    pub iAddressFamily: c_int,\n+                    pub iMaxSockAddr: c_int,\n+                    pub iMinSockAddr: c_int,\n+                    pub iSocketType: c_int,\n+                    pub iProtocol: c_int,\n+                    pub iProtocolMaxOffset: c_int,\n+                    pub iNetworkByteOrder: c_int,\n+                    pub iSecurityScheme: c_int,\n+                    pub dwMessageSize: DWORD,\n+                    pub dwProviderReserved: DWORD,\n+                    pub szProtocol: [u8, ..(WSAPROTOCOL_LEN as uint) + 1u],\n+                }\n \n                 pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n "}, {"sha": "3c9fb1f76240cb617a0b1313d807fe624427f500", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -17,6 +17,7 @@ use middle::def;\n use middle::pat_util::def_to_path;\n use middle::ty;\n use middle::typeck::astconv;\n+use middle::typeck::check;\n use util::nodemap::{DefIdMap};\n \n use syntax::ast::*;\n@@ -274,6 +275,17 @@ impl<'a> ConstEvalVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for ConstEvalVisitor<'a> {\n+    fn visit_ty(&mut self, t: &Ty, _: ()) {\n+        match t.node {\n+            TyFixedLengthVec(_, expr) => {\n+                check::check_const_in_type(self.tcx, &*expr, ty::mk_uint());\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_ty(self, t, ());\n+    }\n+\n     fn visit_expr_post(&mut self, e: &Expr, _: ()) {\n         self.classify(e);\n     }"}, {"sha": "dbd7d6a5d6ac482522097ffa7f90cf89d283dd2e", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 191, "deletions": 7, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -12,20 +12,24 @@\n use middle::freevars::freevar_entry;\n use middle::freevars;\n use middle::subst;\n+use middle::ty::ParameterEnvironment;\n use middle::ty;\n-use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n-use middle::typeck;\n+use middle::ty_fold;\n+use middle::typeck::check::vtable;\n use middle::typeck::{MethodCall, NoAdjustment};\n+use middle::typeck;\n use util::ppaux::{Repr, ty_to_string};\n use util::ppaux::UserString;\n \n+use std::collections::HashSet;\n use syntax::ast::*;\n+use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::print::pprust::{expr_to_string, ident_to_string};\n-use syntax::{visit};\n use syntax::visit::Visitor;\n+use syntax::visit;\n \n // Kind analysis pass.\n //\n@@ -47,13 +51,13 @@ use syntax::visit::Visitor;\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-#[deriving(Clone)]\n pub struct Context<'a> {\n     tcx: &'a ty::ctxt,\n+    struct_and_enum_bounds_checked: HashSet<ty::t>,\n+    parameter_environments: Vec<ParameterEnvironment>,\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n-\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n@@ -74,12 +78,18 @@ impl<'a> Visitor<()> for Context<'a> {\n     fn visit_pat(&mut self, p: &Pat, _: ()) {\n         check_pat(self, p);\n     }\n+\n+    fn visit_local(&mut self, l: &Local, _: ()) {\n+        check_local(self, l);\n+    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &Crate) {\n     let mut ctx = Context {\n         tcx: tcx,\n+        struct_and_enum_bounds_checked: HashSet::new(),\n+        parameter_environments: Vec::new(),\n     };\n     visit::walk_crate(&mut ctx, krate, ());\n     tcx.sess.abort_if_errors();\n@@ -165,12 +175,90 @@ fn check_item(cx: &mut Context, item: &Item) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n                 check_impl_of_trait(cx, item, trait_ref, &**self_type);\n+\n+                let parameter_environment =\n+                    ParameterEnvironment::for_item(cx.tcx, item.id);\n+                cx.parameter_environments.push(parameter_environment);\n+\n+                // Check bounds on the `self` type.\n+                check_bounds_on_structs_or_enums_in_type_if_possible(\n+                    cx,\n+                    item.span,\n+                    ty::node_id_to_type(cx.tcx, item.id));\n+\n+                // Check bounds on the trait ref.\n+                match ty::impl_trait_ref(cx.tcx,\n+                                         ast_util::local_def(item.id)) {\n+                    None => {}\n+                    Some(trait_ref) => {\n+                        check_bounds_on_structs_or_enums_in_trait_ref(\n+                            cx,\n+                            item.span,\n+                            &*trait_ref);\n+                    }\n+                }\n+\n+                drop(cx.parameter_environments.pop());\n+            }\n+            ItemEnum(..) => {\n+                let parameter_environment =\n+                    ParameterEnvironment::for_item(cx.tcx, item.id);\n+                cx.parameter_environments.push(parameter_environment);\n+\n+                let def_id = ast_util::local_def(item.id);\n+                for variant in ty::enum_variants(cx.tcx, def_id).iter() {\n+                    for arg in variant.args.iter() {\n+                        check_bounds_on_structs_or_enums_in_type_if_possible(\n+                            cx,\n+                            item.span,\n+                            *arg)\n+                    }\n+                }\n+\n+                drop(cx.parameter_environments.pop());\n+            }\n+            ItemStruct(..) => {\n+                let parameter_environment =\n+                    ParameterEnvironment::for_item(cx.tcx, item.id);\n+                cx.parameter_environments.push(parameter_environment);\n+\n+                let def_id = ast_util::local_def(item.id);\n+                for field in ty::lookup_struct_fields(cx.tcx, def_id).iter() {\n+                    check_bounds_on_structs_or_enums_in_type_if_possible(\n+                        cx,\n+                        item.span,\n+                        ty::node_id_to_type(cx.tcx, field.id.node))\n+                }\n+\n+                drop(cx.parameter_environments.pop());\n+\n+            }\n+            ItemStatic(..) => {\n+                let parameter_environment =\n+                    ParameterEnvironment::for_item(cx.tcx, item.id);\n+                cx.parameter_environments.push(parameter_environment);\n+\n+                check_bounds_on_structs_or_enums_in_type_if_possible(\n+                    cx,\n+                    item.span,\n+                    ty::node_id_to_type(cx.tcx, item.id));\n+\n+                drop(cx.parameter_environments.pop());\n             }\n             _ => {}\n         }\n     }\n \n-    visit::walk_item(cx, item, ());\n+    visit::walk_item(cx, item, ())\n+}\n+\n+fn check_local(cx: &mut Context, local: &Local) {\n+    check_bounds_on_structs_or_enums_in_type_if_possible(\n+        cx,\n+        local.span,\n+        ty::node_id_to_type(cx.tcx, local.id));\n+\n+    visit::walk_local(cx, local, ())\n }\n \n // Yields the appropriate function to check the kind of closed over\n@@ -254,7 +342,25 @@ fn check_fn(\n         });\n     });\n \n-    visit::walk_fn(cx, fk, decl, body, sp, ());\n+    match *fk {\n+        visit::FkFnBlock(..) => {\n+            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n+            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n+\n+            visit::walk_fn(cx, fk, decl, body, sp, ())\n+        }\n+        visit::FkItemFn(..) | visit::FkMethod(..) => {\n+            let parameter_environment = ParameterEnvironment::for_item(cx.tcx,\n+                                                                       fn_id);\n+            cx.parameter_environments.push(parameter_environment);\n+\n+            let ty = ty::node_id_to_type(cx.tcx, fn_id);\n+            check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n+\n+            visit::walk_fn(cx, fk, decl, body, sp, ());\n+            drop(cx.parameter_environments.pop());\n+        }\n+    }\n }\n \n pub fn check_expr(cx: &mut Context, e: &Expr) {\n@@ -263,6 +369,13 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Handle any kind bounds on type parameters\n     check_bounds_on_type_parameters(cx, e);\n \n+    // Check bounds on structures or enumerations in the type of the\n+    // expression.\n+    let expression_type = ty::expr_ty(cx.tcx, e);\n+    check_bounds_on_structs_or_enums_in_type_if_possible(cx,\n+                                                         e.span,\n+                                                         expression_type);\n+\n     match e.node {\n         ExprBox(ref loc, ref interior) => {\n             let def = ty::resolve_expr(cx.tcx, &**loc);\n@@ -483,6 +596,7 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n         }\n         _ => {}\n     }\n+\n     visit::walk_ty(cx, aty, ());\n }\n \n@@ -519,6 +633,76 @@ pub fn check_typaram_bounds(cx: &Context,\n     });\n }\n \n+fn check_bounds_on_structs_or_enums_in_type_if_possible(cx: &mut Context,\n+                                                        span: Span,\n+                                                        ty: ty::t) {\n+    // If we aren't in a function, structure, or enumeration context, we don't\n+    // have enough information to ensure that bounds on structures or\n+    // enumerations are satisfied. So we don't perform the check.\n+    if cx.parameter_environments.len() == 0 {\n+        return\n+    }\n+\n+    // If we've already checked for this type, don't do it again. This\n+    // massively speeds up kind checking.\n+    if cx.struct_and_enum_bounds_checked.contains(&ty) {\n+        return\n+    }\n+    cx.struct_and_enum_bounds_checked.insert(ty);\n+\n+    ty::walk_ty(ty, |ty| {\n+        match ty::get(ty).sty {\n+            ty::ty_struct(type_id, ref substs) |\n+            ty::ty_enum(type_id, ref substs) => {\n+                let polytype = ty::lookup_item_type(cx.tcx, type_id);\n+\n+                // Check builtin bounds.\n+                for (ty, type_param_def) in substs.types\n+                                                  .iter()\n+                                                  .zip(polytype.generics\n+                                                               .types\n+                                                               .iter()) {\n+                    check_typaram_bounds(cx, span, *ty, type_param_def)\n+                }\n+\n+                // Check trait bounds.\n+                let parameter_environment =\n+                    cx.parameter_environments.get(cx.parameter_environments\n+                                                    .len() - 1);\n+                debug!(\n+                    \"check_bounds_on_structs_or_enums_in_type_if_possible(): \\\n+                     checking {}\",\n+                    ty.repr(cx.tcx));\n+                vtable::check_param_bounds(cx.tcx,\n+                                           span,\n+                                           parameter_environment,\n+                                           &polytype.generics.types,\n+                                           substs,\n+                                           |missing| {\n+                    cx.tcx\n+                      .sess\n+                      .span_err(span,\n+                                format!(\"instantiating a type parameter with \\\n+                                         an incompatible type `{}`, which \\\n+                                         does not fulfill `{}`\",\n+                                        ty_to_string(cx.tcx, ty),\n+                                        missing.user_string(\n+                                            cx.tcx)).as_slice());\n+                })\n+            }\n+            _ => {}\n+        }\n+    });\n+}\n+\n+fn check_bounds_on_structs_or_enums_in_trait_ref(cx: &mut Context,\n+                                                 span: Span,\n+                                                 trait_ref: &ty::TraitRef) {\n+    for ty in trait_ref.substs.types.iter() {\n+        check_bounds_on_structs_or_enums_in_type_if_possible(cx, span, *ty)\n+    }\n+}\n+\n pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {"}, {"sha": "ce3256650fd257bb0ecf175180b3a806c8840d3b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -55,7 +55,7 @@ use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n-use syntax::ast_util::{is_local, lit_is_str};\n+use syntax::ast_util::{PostExpansionMethod, is_local, lit_is_str};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -1083,6 +1083,84 @@ pub struct ParameterEnvironment {\n     pub bounds: VecPerParamSpace<ParamBounds>,\n }\n \n+impl ParameterEnvironment {\n+    pub fn for_item(cx: &ctxt, id: NodeId) -> ParameterEnvironment {\n+        match cx.map.find(id) {\n+            Some(ast_map::NodeImplItem(ref impl_item)) => {\n+                match **impl_item {\n+                    ast::MethodImplItem(ref method) => {\n+                        let method_def_id = ast_util::local_def(id);\n+                        match ty::impl_or_trait_item(cx, method_def_id) {\n+                            MethodTraitItem(ref method_ty) => {\n+                                let method_generics = &method_ty.generics;\n+                                construct_parameter_environment(\n+                                    cx,\n+                                    method_generics,\n+                                    method.pe_body().id)\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeTraitItem(trait_method)) => {\n+                match *trait_method {\n+                    ast::RequiredMethod(ref required) => {\n+                        cx.sess.span_bug(required.span,\n+                                         \"ParameterEnvironment::from_item():\n+                                          can't create a parameter \\\n+                                          environment for required trait \\\n+                                          methods\")\n+                    }\n+                    ast::ProvidedMethod(ref method) => {\n+                        let method_def_id = ast_util::local_def(id);\n+                        match ty::impl_or_trait_item(cx, method_def_id) {\n+                            MethodTraitItem(ref method_ty) => {\n+                                let method_generics = &method_ty.generics;\n+                                construct_parameter_environment(\n+                                    cx,\n+                                    method_generics,\n+                                    method.pe_body().id)\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    ast::ItemFn(_, _, _, _, ref body) => {\n+                        // We assume this is a function.\n+                        let fn_def_id = ast_util::local_def(id);\n+                        let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n+\n+                        construct_parameter_environment(cx,\n+                                                        &fn_pty.generics,\n+                                                        body.id)\n+                    }\n+                    ast::ItemEnum(..) |\n+                    ast::ItemStruct(..) |\n+                    ast::ItemImpl(..) |\n+                    ast::ItemStatic(..) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let pty = ty::lookup_item_type(cx, def_id);\n+                        construct_parameter_environment(cx, &pty.generics, id)\n+                    }\n+                    _ => {\n+                        cx.sess.span_bug(item.span,\n+                                         \"ParameterEnvironment::from_item():\n+                                          can't create a parameter \\\n+                                          environment for this kind of item\")\n+                    }\n+                }\n+            }\n+            _ => {\n+                cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n+                                     `{}` is not an item\",\n+                                    cx.map.node_to_string(id)).as_slice())\n+            }\n+        }\n+    }\n+}\n+\n /// A polytype.\n ///\n /// - `generics`: the set of type parameters and their bounds"}, {"sha": "24aee72e00e653ddb6bfc18ddc9c0239594e8531", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -879,7 +879,6 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n             }\n             ast::TyFixedLengthVec(ty, e) => {\n-                typeck::write_ty_to_tcx(tcx, e.id, ty::mk_uint());\n                 match const_eval::eval_const_expr_partial(tcx, &*e) {\n                     Ok(ref r) => {\n                         match *r {"}, {"sha": "7896316a4722947d35aae2f68426740ad8d1fb4a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -86,7 +86,7 @@ use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n-use middle::ty::{ParamTy, Disr, ExprTyProvider};\n+use middle::ty::{Disr, ExprTyProvider, ParamTy, ParameterEnvironment};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -281,7 +281,8 @@ impl<'a> Inherited<'a> {\n }\n \n // Used by check_const and check_enum_variants\n-fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n+pub fn blank_fn_ctxt<'a>(\n+                     ccx: &'a CrateCtxt<'a>,\n                      inh: &'a Inherited<'a>,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n@@ -673,11 +674,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-\n-        let param_env = ty::construct_parameter_environment(ccx.tcx,\n-                                                            &fn_pty.generics,\n-                                                            body.id);\n-\n+        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref impl_items) => {\n@@ -773,15 +770,7 @@ fn check_method_body(ccx: &CrateCtxt,\n     debug!(\"check_method_body(item_generics={}, method.id={})\",\n             item_generics.repr(ccx.tcx),\n             method.id);\n-    let method_def_id = local_def(method.id);\n-    let method_ty = match ty::impl_or_trait_item(ccx.tcx, method_def_id) {\n-        ty::MethodTraitItem(ref method_ty) => (*method_ty).clone(),\n-    };\n-    let method_generics = &method_ty.generics;\n-\n-    let param_env = ty::construct_parameter_environment(ccx.tcx,\n-                                                        method_generics,\n-                                                        method.pe_body().id);\n+    let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n@@ -3971,6 +3960,24 @@ fn check_block_with_expected(fcx: &FnCtxt,\n     *fcx.ps.borrow_mut() = prev;\n }\n \n+/// Checks a constant appearing in a type. At the moment this is just the\n+/// length expression in a fixed-length vector, but someday it might be\n+/// extended to type-level numeric literals.\n+pub fn check_const_in_type(tcx: &ty::ctxt,\n+                           expr: &ast::Expr,\n+                           expected_type: ty::t) {\n+    // Synthesize a crate context. The trait map is not needed here (though I\n+    // imagine it will be if we have associated statics --pcwalton), so we\n+    // leave it blank.\n+    let ccx = CrateCtxt {\n+        trait_map: NodeMap::new(),\n+        tcx: tcx,\n+    };\n+    let inh = blank_inherited_fields(&ccx);\n+    let fcx = blank_fn_ctxt(&ccx, &inh, expected_type, expr.id);\n+    check_const_with_ty(&fcx, expr.span, expr, expected_type);\n+}\n+\n pub fn check_const(ccx: &CrateCtxt,\n                    sp: Span,\n                    e: &ast::Expr,"}, {"sha": "1aa469b15ba153db5dd28ed84b287e87ac6c224c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -66,8 +66,8 @@ use syntax::visit::Visitor;\n // It may be better to do something more clever, like processing fully\n // resolved types first.\n \n-/// A vtable context includes an inference context, a crate context, and a\n-/// callback function to call in case of type error.\n+/// A vtable context includes an inference context, a parameter environment,\n+/// and a list of unboxed closure types.\n pub struct VtableContext<'a> {\n     pub infcx: &'a infer::InferCtxt<'a>,\n     pub param_env: &'a ty::ParameterEnvironment,\n@@ -83,8 +83,7 @@ fn lookup_vtables(vcx: &VtableContext,\n                   type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n                   substs: &subst::Substs,\n                   is_early: bool)\n-                  -> VecPerParamSpace<vtable_param_res>\n-{\n+                  -> VecPerParamSpace<vtable_param_res> {\n     debug!(\"lookup_vtables(\\\n            type_param_defs={}, \\\n            substs={}\",\n@@ -154,11 +153,12 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n-                vcx.tcx().sess.span_fatal(span,\n+                vcx.tcx().sess.span_err(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n                          vcx.infcx.trait_ref_to_string(&*trait_ref),\n                          vcx.infcx.ty_to_string(ty)).as_slice());\n+                param_result.push(vtable_error)\n             }\n         }\n         true\n@@ -583,10 +583,11 @@ fn fixup_ty(vcx: &VtableContext,\n     match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n-            tcx.sess.span_fatal(span,\n+            tcx.sess.span_err(span,\n                 format!(\"cannot determine a type for this bounded type \\\n                          parameter: {}\",\n-                        fixup_err_to_string(e)).as_slice())\n+                        fixup_err_to_string(e)).as_slice());\n+            Some(ty::mk_err())\n         }\n         Err(_) => {\n             None\n@@ -974,3 +975,38 @@ impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {\n pub fn resolve_in_block(mut fcx: &FnCtxt, bl: &ast::Block) {\n     visit::walk_block(&mut fcx, bl, ());\n }\n+\n+/// Used in the kind checker after typechecking has finished. Calls\n+/// `any_missing` if any bounds were missing.\n+pub fn check_param_bounds(tcx: &ty::ctxt,\n+                          span: Span,\n+                          parameter_environment: &ty::ParameterEnvironment,\n+                          type_param_defs:\n+                            &VecPerParamSpace<ty::TypeParameterDef>,\n+                          substs: &subst::Substs,\n+                          any_missing: |&ty::TraitRef|) {\n+    let unboxed_closures = RefCell::new(DefIdMap::new());\n+    let vcx = VtableContext {\n+        infcx: &infer::new_infer_ctxt(tcx),\n+        param_env: parameter_environment,\n+        unboxed_closures: &unboxed_closures,\n+    };\n+    let vtable_param_results =\n+        lookup_vtables(&vcx, span, type_param_defs, substs, false);\n+    for (vtable_param_result, type_param_def) in\n+            vtable_param_results.iter().zip(type_param_defs.iter()) {\n+        for (vtable_result, trait_ref) in\n+                vtable_param_result.iter()\n+                                   .zip(type_param_def.bounds\n+                                                      .trait_bounds\n+                                                      .iter()) {\n+            match *vtable_result {\n+                vtable_error => any_missing(&**trait_ref),\n+                vtable_static(..) |\n+                vtable_param(..) |\n+                vtable_unboxed_closure(..) => {}\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "5c3317972cd37da68184f70981471fbad2de3826", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -462,7 +462,6 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         // These don't define types.\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n-            ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n             let pty = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, pty.ty);\n             get_enum_variant_types(ccx,\n@@ -559,9 +558,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // static trait methods. This is somewhat unfortunate.\n             ensure_trait_methods(ccx, it.id, &*trait_def);\n         },\n-        ast::ItemStruct(struct_def, ref generics) => {\n-            ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n-\n+        ast::ItemStruct(struct_def, _) => {\n             // Write the class type.\n             let pty = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, pty.ty);"}, {"sha": "1695e474de9998c07dfda2d0b5c6849d4c29c7e0", "filename": "src/test/auxiliary/trait_bounds_on_structs_and_enums_xc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Trait {}\n+\n+pub struct Foo<T:Trait> {\n+    pub x: T,\n+}\n+\n+pub enum Bar<T:Trait> {\n+    ABar(int),\n+    BBar(T),\n+    CBar(uint),\n+}\n+"}, {"sha": "fec1b3ed492f6c5f7ab200a6e01796650e8cdc88", "filename": "src/test/compile-fail/deriving-span-Zero-struct.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -16,9 +16,11 @@ extern crate rand;\n \n struct Error;\n \n-#[deriving(Zero)]\n+#[deriving(Zero)]   //~ ERROR failed to find an implementation\n struct Struct {\n-    x: Error //~ ERROR\n+    x: Error //~ ERROR failed to find an implementation\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR type `Error` does not implement any method in scope\n }\n \n fn main() {}"}, {"sha": "0661e5ee8b28553a6857fa90fe80259d3b67da46", "filename": "src/test/compile-fail/deriving-span-Zero-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -16,9 +16,11 @@ extern crate rand;\n \n struct Error;\n \n-#[deriving(Zero)]\n+#[deriving(Zero)]   //~ ERROR failed to find an implementation\n struct Struct(\n     Error //~ ERROR\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR type `Error` does not implement any method in scope\n );\n \n fn main() {}"}, {"sha": "3754d669be6a2970f6274a8f59766a5a0ed9698b", "filename": "src/test/compile-fail/issue-14915.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -18,4 +18,5 @@ fn main() {\n     //~^ ERROR cannot determine a type for this bounded type parameter: unconstrained type\n     println!(\"{}\", y + 1);\n     //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n+    //~^^ ERROR cannot determine a type for this bounded type parameter: unconstrained type\n }"}, {"sha": "9a974e595d3c1f195eaa740315c42bd0de72a725", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     let x: Box<Map<int, int>> = x;\n     let y: Box<Map<uint, int>> = box x;\n     //~^ ERROR failed to find an implementation of trait collections::Map<uint,int>\n-    //         for ~collections::Map<int,int>:Send\n+    //~^^ ERROR failed to find an implementation of trait core::collections::Collection\n }"}, {"sha": "3ecff26f628d9ef33c51bde3ffcfb8b81cb93212", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test\n+//\n+// Ignored because of an ICE at the moment.\n+\n // Check that non-constant exprs do fail as count in fixed length vec type\n \n fn main() {"}, {"sha": "0cbdb87d56c54413ac227628062789b1237a4a88", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -15,4 +15,5 @@\n trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n fn take_object(f: Box<Foo>) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n+//~^ ERROR failed to find an implementation\n fn main() {}"}, {"sha": "e62f5fe1a4daf64811e2d9c491908e304a467599", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -44,6 +44,7 @@ fn main() {\n         // Can't do this copy\n         let x = box box box A {y: r(i)};\n         let _z = x.clone(); //~ ERROR failed to find an implementation\n+        //~^ ERROR failed to find an implementation\n         println!(\"{:?}\", x);\n     }\n     println!(\"{:?}\", *i);"}, {"sha": "226556dc78fcb6e943f1554c1ff2d01e846f32d3", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+struct Foo<T:Trait> {\n+    x: T,\n+}\n+\n+fn main() {\n+    let foo = Foo {\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR instantiating a type parameter with an incompatible type\n+        x: 3i\n+    };\n+    let baz: Foo<uint> = fail!();\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR instantiating a type parameter with an incompatible type\n+}\n+"}, {"sha": "142ead75bcf1971d814e8c36b3ba09692b1cfaba", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-static.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+struct Foo<T:Trait> {\n+    x: T,\n+}\n+\n+static X: Foo<uint> = Foo {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    x: 1,\n+};\n+\n+fn main() {\n+}\n+"}, {"sha": "9be519960b81fd6c850574ccb76bee1186a864f8", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-xc.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:trait_bounds_on_structs_and_enums_xc.rs\n+\n+extern crate trait_bounds_on_structs_and_enums_xc;\n+\n+use trait_bounds_on_structs_and_enums_xc::{Bar, Foo, Trait};\n+\n+fn explode(x: Foo<uint>) {}\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+\n+fn kaboom(y: Bar<f32>) {}\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+\n+fn main() {\n+    let foo = Foo {\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR instantiating a type parameter with an incompatible type\n+        x: 3i\n+    };\n+    let bar: Bar<f64> = return;\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR instantiating a type parameter with an incompatible type\n+    let _ = bar;\n+}\n+"}, {"sha": "537656d1479e6c7fbd15ede07d5db4d0dbfe2060", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+struct Foo<T:Trait> {\n+    x: T,\n+}\n+\n+enum Bar<T:Trait> {\n+    ABar(int),\n+    BBar(T),\n+    CBar(uint),\n+}\n+\n+fn explode(x: Foo<uint>) {}\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+\n+fn kaboom(y: Bar<f32>) {}\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+\n+impl<T> Foo<T> {\n+    fn uhoh() {}\n+}\n+\n+struct Baz {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    a: Foo<int>,\n+}\n+\n+enum Boo {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    Quux(Bar<uint>),\n+}\n+\n+struct Badness<T> {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    b: Foo<T>,\n+}\n+\n+enum MoreBadness<T> {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    EvenMoreBadness(Bar<T>),\n+}\n+\n+trait PolyTrait<T> {\n+    fn whatever() {}\n+}\n+\n+struct Struct;\n+\n+impl PolyTrait<Foo<uint>> for Struct {\n+//~^ ERROR failed to find an implementation\n+//~^^ ERROR instantiating a type parameter with an incompatible type\n+    fn whatever() {}\n+}\n+\n+fn main() {\n+    let bar: Bar<f64> = return;\n+    //~^ ERROR failed to find an implementation\n+    //~^^ ERROR instantiating a type parameter with an incompatible type\n+    let _ = bar;\n+}\n+"}, {"sha": "e5b7bf08715b0d00ee358f4da0ae1a8af7f49cea", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -21,5 +21,6 @@ impl Drop for r {\n fn main() {\n     let i = box r { b: true };\n     let _j = i.clone(); //~ ERROR failed to find an implementation\n+    //~^ ERROR failed to find an implementation\n     println!(\"{:?}\", i);\n }"}, {"sha": "dfb04323005f3e2426296d591e33049d0672aca5", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -37,6 +37,9 @@ fn main() {\n     let r2 = vec!(box r { i: i2 });\n     f(r1.clone(), r2.clone());\n     //~^ ERROR failed to find an implementation of\n+    //~^^ ERROR failed to find an implementation of\n+    //~^^^ ERROR failed to find an implementation of\n+    //~^^^^ ERROR failed to find an implementation of\n     println!(\"{:?}\", (r2, i1.get()));\n     println!(\"{:?}\", (r1, i2.get()));\n }"}, {"sha": "2baa89d52f28b935c5b358c7d09277ccf0a669dd", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -25,6 +25,7 @@ impl TraitB for int {\n fn call_it<B:TraitB>(b: B)  -> int {\n     let y = 4u;\n     b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait TraitA\n+    //~^ ERROR failed to find an implementation of trait TraitA\n }\n \n fn main() {"}, {"sha": "2324da6b8f422ab7b94f302bc35fa432c66281ba", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -14,7 +14,10 @@ fn equal<T>(_: &T, _: &T) -> bool where T : Eq {\n struct Struct;\n \n fn main() {\n-    equal(&Struct, &Struct)\n-    //~^ ERROR failed to find an implementation of trait\n+    drop(equal(&Struct, &Struct))\n+    //~^ ERROR failed to find an implementation of trait core::cmp::Eq\n+    //~^^ ERROR failed to find an implementation of trait core::cmp::PartialEq\n+    //~^^^ ERROR failed to find an implementation of trait core::cmp::Eq\n+    //~^^^^ ERROR failed to find an implementation of trait core::cmp::PartialEq\n }\n "}, {"sha": "0440a771e98f865fef8f15f7e3080ad66801cfd9", "filename": "src/test/run-pass/const-expr-in-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -13,7 +13,7 @@\n \n pub fn main() {\n \n-    static FOO: int = 2;\n+    static FOO: uint = 2;\n     let _v: [int, ..FOO*3];\n \n }"}, {"sha": "ebcaf772db453de7081f5def4708f006d5e64242", "filename": "src/test/run-pass/trait-bounds-on-structs-and-enums.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086a5ca7d25307325912cab2a67384867daa04c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs?ref=086a5ca7d25307325912cab2a67384867daa04c5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait U {}\n+trait T<X: U> {}\n+\n+trait S2<Y: U> {\n+    fn m(x: Box<T<Y>>) {}\n+}\n+\n+struct St<X: U> {\n+    f: Box<T<X>>,\n+}\n+\n+impl<X: U> St<X> {\n+    fn blah() {}\n+}\n+\n+fn main() {}"}]}