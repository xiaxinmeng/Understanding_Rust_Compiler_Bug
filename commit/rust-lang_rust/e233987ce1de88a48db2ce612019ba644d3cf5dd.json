{"sha": "e233987ce1de88a48db2ce612019ba644d3cf5dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMzM5ODdjZTFkZTg4YTQ4ZGIyY2U2MTIwMTliYTY0NGQzY2Y1ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-27T23:15:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-27T23:15:17Z"}, "message": "Auto merge of #22860 - Manishearth:rollup, r=alexcrichton\n\nPasses check-stage1, check-stage2", "tree": {"sha": "f776ae018199c9ff2350a29dc569630f64455f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f776ae018199c9ff2350a29dc569630f64455f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e233987ce1de88a48db2ce612019ba644d3cf5dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e233987ce1de88a48db2ce612019ba644d3cf5dd", "html_url": "https://github.com/rust-lang/rust/commit/e233987ce1de88a48db2ce612019ba644d3cf5dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e233987ce1de88a48db2ce612019ba644d3cf5dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0d8e47e53f25bbd50418a0f117973c366c1b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0d8e47e53f25bbd50418a0f117973c366c1b08", "html_url": "https://github.com/rust-lang/rust/commit/bd0d8e47e53f25bbd50418a0f117973c366c1b08"}, {"sha": "bde4c1d6fbefcd914a06b5eab6ef6f9a6f26f271", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde4c1d6fbefcd914a06b5eab6ef6f9a6f26f271", "html_url": "https://github.com/rust-lang/rust/commit/bde4c1d6fbefcd914a06b5eab6ef6f9a6f26f271"}], "stats": {"total": 1083, "additions": 952, "deletions": 131}, "files": [{"sha": "87130c08991c02625246014e04d53063b19b6b41", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -302,7 +302,7 @@ nonzero_dec: '1' | '2' | '3' | '4'\n \n A _character literal_ is a single Unicode character enclosed within two\n `U+0027` (single-quote) characters, with the exception of `U+0027` itself,\n-which must be _escaped_ by a preceding U+005C character (`\\`).\n+which must be _escaped_ by a preceding `U+005C` character (`\\`).\n \n ##### String literals\n \n@@ -311,6 +311,19 @@ A _string literal_ is a sequence of any Unicode characters enclosed within two\n which must be _escaped_ by a preceding `U+005C` character (`\\`), or a _raw\n string literal_.\n \n+A multi-line string literal may be defined by terminating each line with a\n+`U+005C` character (`\\`) immediately before the newline. This causes the\n+`U+005C` character, the newline, and all whitespace at the beginning of the\n+next line to be ignored.\n+\n+```rust\n+let a = \"foobar\";\n+let b = \"foo\\\n+         bar\";\n+\n+assert_eq!(a,b);\n+```\n+\n ##### Character escapes\n \n Some additional _escapes_ are available in either character or non-raw string"}, {"sha": "587da69d4a6f7a0fc8c8fb6c5d16cb9606ac31e4", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -18,13 +18,15 @@ the Cargo\n README](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies)\n for specific instructions about installing it.\n \n+## Converting to Cargo\n+\n Let's convert Hello World to Cargo.\n \n To Cargo-ify our project, we need to do two things: Make a `Cargo.toml`\n configuration file, and put our source file in the right place. Let's\n do that part first:\n \n-```{bash}\n+```bash\n $ mkdir src\n $ mv main.rs src/main.rs\n ```\n@@ -36,7 +38,7 @@ place for everything, and everything in its place.\n \n Next, our configuration file:\n \n-```{bash}\n+```bash\n $ editor Cargo.toml\n ```\n \n@@ -73,7 +75,7 @@ well as what it is named.\n \n Once you have this file in place, we should be ready to build! Try this:\n \n-```{bash}\n+```bash\n $ cargo build\n    Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n $ ./target/hello_world\n@@ -103,6 +105,62 @@ That's it! We've successfully built `hello_world` with Cargo. Even though our\n program is simple, it's using much of the real tooling that you'll use for the\n rest of your Rust career.\n \n+## A New Project\n+\n+You don't have to go through this whole process every time you want to start a new\n+project! Cargo has the ability to make a bare-bones project directory in which you\n+can start developing right away.\n+\n+To start a new project with Cargo, use `cargo new`:\n+\n+```bash\n+$ cargo new hello_world --bin\n+```\n+\n+We're passing `--bin` because we're making a binary program: if we\n+were making a library, we'd leave it off.\n+\n+Let's check out what Cargo has generated for us:\n+\n+```bash\n+$ cd hello_world\n+$ tree .\n+.\n+\u251c\u2500\u2500 Cargo.toml\n+\u2514\u2500\u2500 src\n+    \u2514\u2500\u2500 main.rs\n+\n+1 directory, 2 files\n+```\n+\n+If you don't have the `tree` command, you can probably get it from your distro's package\n+manager. It's not necessary, but it's certainly useful.\n+\n+This is all we need to get started. First, let's check out `Cargo.toml`:\n+\n+```toml\n+[package]\n+\n+name = \"hello_world\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+Cargo has populated this file with reasonable defaults based off the arguments you gave\n+it and your `git` global configuration. You may notice that Cargo has also initialized\n+the `hello_world` directory as a `git` repository.\n+\n+Here's what's in `src/main.rs`:\n+\n+```rust\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+Cargo has generated a \"Hello World!\" for us, and you're ready to start coding! A\n+much more in-depth guide to Cargo can be found [here](http://doc.crates.io/guide.html).\n+\n Now that you've got the tools down, let's actually learn more about the Rust\n language itself. These are the basics that will serve you well through the rest\n-of your time with Rust.\n+of your time with Rust.\n\\ No newline at end of file"}, {"sha": "726d5c8a23b739c179c22701b9628a4a450ae11a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -300,7 +300,7 @@ mod imp {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n             let new_ptr = allocate(size, align);\n-            ptr::copy_memory(new_ptr, ptr, cmp::min(size, old_size));\n+            ptr::copy(new_ptr, ptr, cmp::min(size, old_size));\n             deallocate(ptr, old_size, align);\n             new_ptr\n         }"}, {"sha": "a2924f8fe53082bb2b6ff4843f20abd07a61c57a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -2663,15 +2663,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[..left.len()] == [1, 2][]);\n+                assert!(left[..left.len()] == [1, 2]);\n             }\n             for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[..right.len()] == [3, 4, 5][]);\n+                assert!(right[..right.len()] == [3, 4, 5]);\n             }\n             for p in right {\n                 *p += 2;"}, {"sha": "78ab9b6ab9bad15d8cce464a09cc6b0d45926fe4", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -2093,15 +2093,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(&left[..left.len()] == &[1, 2][]);\n+                assert!(&left[..left.len()] == &[1, 2]);\n             }\n             for p in left {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(&right[..right.len()] == &[3, 4, 5][]);\n+                assert!(&right[..right.len()] == &[3, 4, 5]);\n             }\n             for p in right {\n                 *p += 2;"}, {"sha": "1ca243134cc6c6d985ca7f6b107c935c2d9ace58", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -241,7 +241,12 @@ extern \"rust-intrinsic\" {\n     /// will trigger a compiler error.\n     pub fn return_address() -> *const u8;\n \n-    /// Returns `true` if a type requires drop glue.\n+    /// Returns `true` if the actual type given as `T` requires drop\n+    /// glue; returns `false` if the actual type provided for `T`\n+    /// implements `Copy`.\n+    ///\n+    /// If the actual type neither requires drop glue nor implements\n+    /// `Copy`, then may return `true` or `false`.\n     pub fn needs_drop<T>() -> bool;\n \n     /// Returns `true` if a type is managed (will be allocated on the local heap)"}, {"sha": "94cc933d844f370b6bbf5b8f9ac41b5b24352968", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -171,8 +171,7 @@ pub trait IteratorExt: Iterator + Sized {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n \n-    /// Loops through the entire iterator, returning the last element of the\n-    /// iterator.\n+    /// Loops through the entire iterator, returning the last element.\n     ///\n     /// # Examples\n     ///\n@@ -637,8 +636,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n-        for x in self { if !f(x) { return false; } }\n+    fn all<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n+        for x in self.by_ref() { if !f(x) { return false; } }\n         true\n     }\n \n@@ -1637,8 +1636,6 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         for x in self.iter.by_ref() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n-            } else {\n-                continue\n             }\n         }\n         None"}, {"sha": "868a671b9560e2985188874f3b333463af95143d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -275,7 +275,13 @@ macro_rules! impls{\n /// any methods, but instead is used to gate access to data.\n ///\n /// FIXME. Better documentation needed here!\n-pub trait MarkerTrait : PhantomFn<Self> { }\n+pub trait MarkerTrait : PhantomFn<Self,Self> { }\n+//                                    ~~~~~ <-- FIXME(#22806)?\n+//\n+// Marker trait has been made invariant so as to avoid inf recursion,\n+// but we should ideally solve the underlying problem. That's a bit\n+// complicated.\n+\n impl<T:?Sized> MarkerTrait for T { }\n \n /// `PhantomFn` is a marker trait for use with traits that contain"}, {"sha": "b8271562d2e670c22677a86ce61964f51325a053", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -641,9 +641,9 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n+    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n         match self {\n-            Ok(_) => self,\n+            Ok(v) => Ok(v),\n             Err(_) => res,\n         }\n     }"}, {"sha": "b354116993c23a1e750be1fa8c900dc95261ab85", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -939,6 +939,7 @@ impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n+    #[allow(deprecated)]\n     fn next(&mut self) -> Option<&'a str> {\n         Iterator::next(&mut self.0)\n     }"}, {"sha": "10cc3ad64242720e59c2d5e9682a09d8f6aab45d", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -36,10 +36,10 @@ pub fn test_and_then() {\n \n #[test]\n pub fn test_or() {\n-    assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+    assert_eq!(op1().or(Ok::<_, &'static str>(667)).unwrap(), 666);\n     assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n \n-    assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+    assert_eq!(op2().or(Ok::<_, &'static str>(667)).unwrap(), 667);\n     assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n }\n "}, {"sha": "fe73b3b44079503544c6dead2a334b86f0877f99", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -59,16 +59,16 @@ fn iterator_to_slice() {\n                 let mut iter = data.iter_mut();\n                 assert_eq!(&iter[..], &other_data[..]);\n                 // mutability:\n-                assert!(&mut iter[] == other_data);\n+                assert!(&mut iter[..] == other_data);\n \n                 iter.next();\n                 assert_eq!(&iter[..], &other_data[1..]);\n-                assert!(&mut iter[] == &mut other_data[1..]);\n+                assert!(&mut iter[..] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n                 assert_eq!(&iter[..], &other_data[1..2]);\n-                assert!(&mut iter[] == &mut other_data[1..2]);\n+                assert!(&mut iter[..] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();\n                 assert!(s == &mut other_data[1..2]);"}, {"sha": "06828911471466d2e1e3eb58786eb04567aacf1a", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -134,11 +134,7 @@ pub trait Reseeder<R> {\n /// Reseed an RNG using a `Default` instance. This reseeds by\n /// replacing the RNG with the result of a `Default::default` call.\n #[derive(Copy)]\n-pub struct ReseedWithDefault { __hack: [u8; 0] }\n-// FIXME(#21721) used to be an unit struct but that can cause\n-// certain LLVM versions to abort during optimizations.\n-#[allow(non_upper_case_globals)]\n-pub const ReseedWithDefault: ReseedWithDefault = ReseedWithDefault { __hack: [] };\n+pub struct ReseedWithDefault;\n \n impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n     fn reseed(&mut self, rng: &mut R) {"}, {"sha": "0bd7f83b9595e003956a173bd7dd2b2009ac7255", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -1771,6 +1771,11 @@ impl LintPass for Stability {\n         stability::check_path(cx.tcx, path, id,\n                               &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n+\n+    fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n+        stability::check_pat(cx.tcx, pat,\n+                             &mut |id, sp, stab| self.lint(cx, id, sp, stab))\n+    }\n }\n \n declare_lint! {"}, {"sha": "0f98b3c33fb8d61dc1bf055cd6c44e6a2bcbf83a", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -68,12 +68,11 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             Some(d) => d.full_def()\n         };\n         if let def::DefPrimTy(nty) = def {\n-            Some(prim_ty_to_ty(tcx, &path.segments[], nty))\n+            Some(prim_ty_to_ty(tcx, &path.segments, nty))\n         } else {\n             None\n         }\n     } else {\n         None\n     }\n }\n-"}, {"sha": "ddac6cc75143ba85ab176ab3a5d89b013f2884c0", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -58,8 +58,10 @@ impl<'a> Annotator<'a> {\n                    attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n         F: FnOnce(&mut Annotator),\n     {\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n         match attr::find_stability(self.sess.diagnostic(), attrs, item_sp) {\n             Some(stab) => {\n+                debug!(\"annotate: found {:?}\", stab);\n                 self.index.local.insert(id, stab.clone());\n \n                 // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -72,6 +74,8 @@ impl<'a> Annotator<'a> {\n                 }\n             }\n             None => {\n+                debug!(\"annotate: not found, use_parent = {:?}, parent = {:?}\",\n+                       use_parent, self.parent);\n                 if use_parent {\n                     if let Some(stab) = self.parent.clone() {\n                         self.index.local.insert(id, stab);\n@@ -299,6 +303,12 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_path(self, path)\n     }\n+\n+    fn visit_pat(&mut self, pat: &ast::Pat) {\n+        check_pat(self.tcx, pat,\n+                  &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_pat(self, pat)\n+    }\n }\n \n /// Helper for discovering nodes to check for stability\n@@ -385,6 +395,76 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                 None => return\n             }\n         }\n+        ast::ExprField(ref base_e, ref field) => {\n+            span = field.span;\n+            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+                ty::ty_struct(did, _) => {\n+                    ty::lookup_struct_fields(tcx, did)\n+                        .iter()\n+                        .find(|f| f.name == field.node.name)\n+                        .unwrap_or_else(|| {\n+                            tcx.sess.span_bug(field.span,\n+                                              \"stability::check_expr: unknown named field access\")\n+                        })\n+                        .id\n+                }\n+                _ => tcx.sess.span_bug(e.span,\n+                                       \"stability::check_expr: named field access on non-struct\")\n+            }\n+        }\n+        ast::ExprTupField(ref base_e, ref field) => {\n+            span = field.span;\n+            match ty::expr_ty_adjusted(tcx, base_e).sty {\n+                ty::ty_struct(did, _) => {\n+                    ty::lookup_struct_fields(tcx, did)\n+                        .get(field.node)\n+                        .unwrap_or_else(|| {\n+                            tcx.sess.span_bug(field.span,\n+                                              \"stability::check_expr: unknown unnamed field access\")\n+                        })\n+                        .id\n+                }\n+                ty::ty_tup(..) => return,\n+                _ => tcx.sess.span_bug(e.span,\n+                                       \"stability::check_expr: unnamed field access on \\\n+                                        something other than a tuple or struct\")\n+            }\n+        }\n+        ast::ExprStruct(_, ref expr_fields, _) => {\n+            let type_ = ty::expr_ty(tcx, e);\n+            match type_.sty {\n+                ty::ty_struct(did, _) => {\n+                    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                    // check the stability of each field that appears\n+                    // in the construction expression.\n+                    for field in expr_fields {\n+                        let did = struct_fields\n+                            .iter()\n+                            .find(|f| f.name == field.ident.node.name)\n+                            .unwrap_or_else(|| {\n+                                tcx.sess.span_bug(field.span,\n+                                                  \"stability::check_expr: unknown named \\\n+                                                   field access\")\n+                            })\n+                            .id;\n+                        maybe_do_stability_check(tcx, did, field.span, cb);\n+                    }\n+\n+                    // we're done.\n+                    return\n+                }\n+                // we don't look at stability attributes on\n+                // struct-like enums (yet...), but it's definitely not\n+                // a bug to have construct one.\n+                ty::ty_enum(..) => return,\n+                _ => {\n+                    tcx.sess.span_bug(e.span,\n+                                      &format!(\"stability::check_expr: struct construction \\\n+                                                of non-struct, type {:?}\",\n+                                               type_.repr(tcx)));\n+                }\n+            }\n+        }\n         _ => return\n     };\n \n@@ -403,6 +483,47 @@ pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n \n }\n \n+pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n+                 cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    debug!(\"check_pat(pat = {:?})\", pat);\n+    if is_internal(tcx, pat.span) { return; }\n+\n+    let did = match ty::pat_ty_opt(tcx, pat) {\n+        Some(&ty::TyS { sty: ty::ty_struct(did, _), .. }) => did,\n+        Some(_) | None => return,\n+    };\n+    let struct_fields = ty::lookup_struct_fields(tcx, did);\n+    match pat.node {\n+        // Foo(a, b, c)\n+        ast::PatEnum(_, Some(ref pat_fields)) => {\n+            for (field, struct_field) in pat_fields.iter().zip(struct_fields.iter()) {\n+                // a .. pattern is fine, but anything positional is\n+                // not.\n+                if let ast::PatWild(ast::PatWildMulti) = field.node {\n+                    continue\n+                }\n+                maybe_do_stability_check(tcx, struct_field.id, field.span, cb)\n+            }\n+        }\n+        // Foo { a, b, c }\n+        ast::PatStruct(_, ref pat_fields, _) => {\n+            for field in pat_fields {\n+                let did = struct_fields\n+                    .iter()\n+                    .find(|f| f.name == field.node.ident.name)\n+                    .unwrap_or_else(|| {\n+                        tcx.sess.span_bug(field.span,\n+                                          \"stability::check_pat: unknown named field access\")\n+                    })\n+                    .id;\n+                maybe_do_stability_check(tcx, did, field.span, cb);\n+            }\n+        }\n+        // everything else is fine.\n+        _ => {}\n+    }\n+}\n+\n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n                             cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if !is_staged_api(tcx, id) { return  }"}, {"sha": "635ec09d3394cd52039a4ebba05b6bf026b45e86", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -3896,7 +3896,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                 let types_a = substs_a.types.get_slice(subst::TypeSpace);\n                 let types_b = substs_b.types.get_slice(subst::TypeSpace);\n \n-                let pairs = types_a.iter().zip(types_b.iter());\n+                let mut pairs = types_a.iter().zip(types_b.iter());\n \n                 pairs.all(|(&a, &b)| same_type(a, b))\n             }\n@@ -4298,6 +4298,9 @@ pub fn free_region_from_def(outlives_extent: region::DestructionScopeData,\n pub fn pat_ty<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Ty<'tcx> {\n     return node_id_to_type(cx, pat.id);\n }\n+pub fn pat_ty_opt<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Option<Ty<'tcx>> {\n+    return node_id_to_type_opt(cx, pat.id);\n+}\n \n \n // Returns the type of an expression as a monotype."}, {"sha": "46729988bb6bd976c658bb1c23e4be691c0e8c38", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -233,6 +233,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemEnum(ref def, _) if public_first => {\n                 for variant in &def.variants {\n                     self.exported_items.insert(variant.node.id);\n+                    self.public_items.insert(variant.node.id);\n                 }\n             }\n \n@@ -321,6 +322,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     Some(id) => { self.exported_items.insert(id); }\n                     None => {}\n                 }\n+                // fields can be public or private, so lets check\n+                for field in &def.fields {\n+                    let vis = match field.node.kind {\n+                        ast::NamedField(_, vis) | ast::UnnamedField(vis) => vis\n+                    };\n+                    if vis == ast::Public {\n+                        self.public_items.insert(field.node.id);\n+                    }\n+                }\n             }\n \n             ast::ItemTy(ref ty, _) if public_first => {"}, {"sha": "78ce9abe07d92495d9e646a2ae0122845b24231f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -2985,7 +2985,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } else {\n             let msg = format!(\"use of undeclared trait name `{}`\",\n                               self.path_names_to_string(trait_path, path_depth));\n-            self.resolve_error(trait_path.span, &msg[]);\n+            self.resolve_error(trait_path.span, &msg);\n             Err(())\n         }\n     }"}, {"sha": "48ff4c8332022aac0972c153eade715fbbe7be42", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -1499,6 +1499,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        pat: &ast::Pat)\n                                        -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"create_dummy_locals\");\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();"}, {"sha": "4f234fac9a4a0e65dba0040513c2e2d83a08c8fb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -734,7 +734,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n-              common::type_needs_drop(bcx.tcx(), ret_ty) {\n+              bcx.fcx.type_needs_drop(ret_ty) {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n                 if common::type_is_zero_size(ccx, ret_ty) {"}, {"sha": "ad07f3953ccc5176b8d54a3376617e6016d7a95f", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -386,7 +386,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>) {\n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: false,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -408,7 +408,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n+\n         let drop = box DropValue {\n             is_immediate: false,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -432,7 +433,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                val: ValueRef,\n                                ty: Ty<'tcx>) {\n \n-        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !self.type_needs_drop(ty) { return; }\n         let drop = box DropValue {\n             is_immediate: true,\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n@@ -1007,6 +1008,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n+        let _icx = base::push_ctxt(\"<DropValue as Cleanup>::trans\");\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n         } else {"}, {"sha": "ec7ed2fe89017476a9ed7290c906128365b92a82", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -213,8 +213,43 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n     }\n }\n \n+/// If `type_needs_drop` returns true, then `ty` is definitely\n+/// non-copy and *might* have a destructor attached; if it returns\n+/// false, then `ty` definitely has no destructor (i.e. no drop glue).\n+///\n+/// (Note that this implies that if `ty` has a destructor attached,\n+/// then `type_needs_drop` will definitely return `true` for `ty`.)\n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty::type_contents(cx, ty).needs_drop(cx)\n+    type_needs_drop_given_env(cx, ty, &ty::empty_parameter_environment(cx))\n+}\n+\n+/// Core implementation of type_needs_drop, potentially making use of\n+/// and/or updating caches held in the `param_env`.\n+fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n+    // Issue #22536: We first query type_moves_by_default.  It sees a\n+    // normalized version of the type, and therefore will definitely\n+    // know whether the type implements Copy (and thus needs no\n+    // cleanup/drop/zeroing) ...\n+    let implements_copy = !ty::type_moves_by_default(&param_env, DUMMY_SP, ty);\n+\n+    if implements_copy { return false; }\n+\n+    // ... (issue #22536 continued) but as an optimization, still use\n+    // prior logic of asking if the `needs_drop` bit is set; we need\n+    // not zero non-Copy types if they have no destructor.\n+\n+    // FIXME(#22815): Note that calling `ty::type_contents` is a\n+    // conservative heuristic; it may report that `needs_drop` is set\n+    // when actual type does not actually have a destructor associated\n+    // with it. But since `ty` absolutely did not have the `Copy`\n+    // bound attached (see above), it is sound to treat it as having a\n+    // destructor (e.g. zero its memory on move).\n+\n+    let contents = ty::type_contents(cx, ty);\n+    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(cx), contents);\n+    contents.needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -534,6 +569,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                                          self.param_substs,\n                                          value)\n     }\n+\n+    /// This is the same as `common::type_needs_drop`, except that it\n+    /// may use or update caches within this `FunctionContext`.\n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        type_needs_drop_given_env(self.ccx.tcx(), ty, &self.param_env)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block"}, {"sha": "85d0bc0319f308d93998463b3c2c410d5af30e53", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -77,7 +77,7 @@ pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n     let ty = expr_ty(cx, e);\n-    if type_needs_drop(cx.tcx(), ty) {\n+    if cx.fcx.type_needs_drop(ty) {\n         expr::trans_to_lvalue(cx, e, \"stmt\").bcx\n     } else {\n         expr::trans_into(cx, e, expr::Ignore)"}, {"sha": "6ca71254868f3f62d339852a4276319acf9d7f45", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -311,7 +311,8 @@ impl KindOps for Lvalue {\n                               val: ValueRef,\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-        if type_needs_drop(bcx.tcx(), ty) {\n+        let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n+        if bcx.fcx.type_needs_drop(ty) {\n             // cancel cleanup of affine values by zeroing out\n             let () = zero_mem(bcx, val, ty);\n             bcx\n@@ -656,7 +657,7 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     /// scalar-ish (like an int or a pointer) which (1) does not require drop glue and (2) is\n     /// naturally passed around by value, and not by reference.\n     pub fn to_llscalarish<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(!type_needs_drop(bcx.tcx(), self.ty));\n+        assert!(!bcx.fcx.type_needs_drop(self.ty));\n         assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n         if self.kind.is_by_ref() {\n             load_ty(bcx, self.val, self.ty)"}, {"sha": "27f9b9506a58a12e7848f441b98fbda733f22877", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -974,7 +974,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n             let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n-            if type_needs_drop(bcx.tcx(), dst_datum.ty) {\n+            if bcx.fcx.type_needs_drop(dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n                 // are copying from an rvalue, since that cannot possible\n                 // alias an lvalue. We are concerned about code like:\n@@ -1498,7 +1498,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n-            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !type_needs_drop(bcx.tcx(), ty) => {\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !bcx.fcx.type_needs_drop(ty) => {\n                 bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n             },\n             ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n@@ -2116,7 +2116,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n-    assert!(!type_needs_drop(bcx.tcx(), dst_datum.ty));\n+    assert!(!bcx.fcx.type_needs_drop(dst_datum.ty));\n     let dst_ty = dst_datum.ty;\n     let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n "}, {"sha": "9491c8377a655fdbe10eee9e63cc2200f29092f2", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -99,6 +99,16 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !type_is_sized(tcx, t) {\n         return t\n     }\n+\n+    // FIXME (#22815): note that type_needs_drop conservatively\n+    // approximates in some cases and may say a type expression\n+    // requires drop glue when it actually does not.\n+    //\n+    // (In this case it is not clear whether any harm is done, i.e.\n+    // erroneously returning `t` in some cases where we could have\n+    // returned `tcx.types.i8` does not appear unsound. The impact on\n+    // code quality is unknown at this time.)\n+\n     if !type_needs_drop(tcx, t) {\n         return tcx.types.i8;\n     }\n@@ -125,7 +135,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n-    if type_needs_drop(bcx.tcx(), t) {\n+    if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let glue = get_drop_glue(ccx, t);\n         let glue_type = get_drop_glue_type(ccx, t);\n@@ -480,7 +490,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n-            if type_needs_drop(bcx.tcx(), t) && ty::type_is_structural(t) {\n+            if bcx.fcx.type_needs_drop(t) && ty::type_is_structural(t) {\n                 iter_structural_ty(bcx,\n                                    v0,\n                                    t,"}, {"sha": "54644c92869cfe0ea83c7c6d780545e1a2dd32d1", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -156,6 +156,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n+    let _icx = push_ctxt(\"trans_intrinsic_call\");\n+\n     let ret_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n             ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n@@ -376,7 +378,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"needs_drop\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_bool(ccx, type_needs_drop(ccx.tcx(), tp_ty))\n+\n+            C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n         (_, \"owns_managed\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);"}, {"sha": "4423cd2774446a8df5dea1bb2aa5ebabc706f485", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -454,7 +454,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let self_datum = unpack_datum!(\n         bcx, expr::trans(bcx, self_expr));\n \n-    let llval = if type_needs_drop(bcx.tcx(), self_datum.ty) {\n+    let llval = if bcx.fcx.type_needs_drop(self_datum.ty) {\n         let self_datum = unpack_datum!(\n             bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n "}, {"sha": "a5c3923336ae8a99b06f48b121962ea97e87478a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -53,11 +53,10 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n         let ccx = bcx.ccx();\n-        let tcx = bcx.tcx();\n         let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n \n         let dataptr = get_dataptr(bcx, vptr);\n-        let bcx = if type_needs_drop(tcx, unit_ty) {\n+        let bcx = if bcx.fcx.type_needs_drop(unit_ty) {\n             let len = get_len(bcx, vptr);\n             iter_vec_raw(bcx,\n                          dataptr,"}, {"sha": "d9dc050aebf10d13e251f192e9f9113187b9af79", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -991,6 +991,17 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n     result\n }\n \n+fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n+                                    span: Span,\n+                                    type_str: &str,\n+                                    trait_str: &str,\n+                                    name: &str) {\n+    span_err!(tcx.sess, span, E0223,\n+              \"ambiguous associated type; specify the type using the syntax \\\n+               `<{} as {}>::{}`\",\n+              type_str, trait_str, name);\n+}\n+\n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>,\n@@ -1011,10 +1022,8 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let ty_param_node_id = if is_param {\n         ty_path_def.local_node_id()\n     } else {\n-        span_err!(tcx.sess, span, E0223,\n-                \"ambiguous associated type; specify the type using the syntax \\\n-                `<{} as Trait>::{}`\",\n-                ty.user_string(tcx), token::get_name(assoc_name));\n+        report_ambiguous_associated_type(\n+            tcx, span, &ty.user_string(tcx), \"Trait\", &token::get_name(assoc_name));\n         return (tcx.types.err, ty_path_def);\n     };\n \n@@ -1109,10 +1118,8 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         ty\n     } else {\n         let path_str = ty::item_path_str(tcx, trait_def_id);\n-        span_err!(tcx.sess, span, E0223,\n-                  \"ambiguous associated type; specify the type using the syntax \\\n-                   `<Type as {}>::{}`\",\n-                   path_str, &token::get_ident(item_segment.identifier));\n+        report_ambiguous_associated_type(\n+            tcx, span, \"Type\", &path_str, &token::get_ident(item_segment.identifier));\n         return tcx.types.err;\n     };\n "}, {"sha": "14930f91c9152f02335e731e2ab3bdbdcbd01b39", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -3945,9 +3945,7 @@ mod tests {\n \n     #[test]\n     fn test_encode_hashmap_with_arbitrary_key() {\n-        use std::old_io::Writer;\n         use std::collections::HashMap;\n-        use std::fmt;\n         #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n         struct ArbitraryType(uint);\n         let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();"}, {"sha": "b1779587528c26b20ca9635cca37e48bbdc851ba", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -173,7 +173,7 @@ mod tests {\n         assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n         assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n     }\n \n     #[test]\n@@ -369,28 +369,28 @@ mod tests {\n         assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n         assert_eq!(writer.position(), 8);\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         assert_eq!(writer.seek(SeekFrom::Start(0)), Ok(0));\n         assert_eq!(writer.position(), 0);\n         assert_eq!(writer.write(&[3, 4]), Ok(2));\n         let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         assert_eq!(writer.seek(SeekFrom::Current(1)), Ok(3));\n         assert_eq!(writer.write(&[0, 1]), Ok(2));\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n         assert_eq!(writer.write(&[1, 2]), Ok(2));\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         assert_eq!(writer.seek(SeekFrom::End(1)), Ok(10));\n         assert_eq!(writer.write(&[1]), Ok(1));\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n     }\n \n     #[test]"}, {"sha": "e6a8b90ea333401388a98e3ae17bd5f890f5dc54", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -102,6 +102,7 @@ impl MemWriter {\n \n impl Writer for MemWriter {\n     #[inline]\n+    #[allow(deprecated)]\n     fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.buf.push_all(buf);\n         Ok(())"}, {"sha": "1310d476f8ee20f15540b6bc75f7df4a64eb7acc", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -384,7 +384,7 @@ impl<T> !Sync for SyncSender<T> {}\n /// contains the data being sent as a payload so it can be recovered.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n-pub struct SendError<T>(pub T);\n+pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n ///"}, {"sha": "71b6214460f4b9550926f95e1488fe2dd73519a1", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -291,29 +291,14 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n     // FileStat times are in milliseconds\n     fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n \n-    #[cfg(target_os = \"bitrig\")]\n-    fn ctime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_ctim.tv_sec as u64, stat.st_ctim.tv_nsec as u64)\n-    }\n-    #[cfg(not(target_os = \"bitrig\"))]\n     fn ctime(stat: &libc::stat) -> u64 {\n       mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64)\n     }\n \n-    #[cfg(target_os = \"bitrig\")]\n-    fn atime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_atim.tv_sec as u64, stat.st_atim.tv_nsec as u64)\n-    }\n-    #[cfg(not(target_os = \"bitrig\"))]\n     fn atime(stat: &libc::stat) -> u64 {\n       mktime(stat.st_atime as u64, stat.st_atime_nsec as u64)\n     }\n \n-    #[cfg(target_os = \"bitrig\")]\n-    fn mtime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_mtim.tv_sec as u64, stat.st_mtim.tv_nsec as u64)\n-    }\n-    #[cfg(not(target_os = \"bitrig\"))]\n     fn mtime(stat: &libc::stat) -> u64 {\n       mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64)\n     }"}, {"sha": "a7d0a864a08aa0a31e38e3f85601721d432e6e0b", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -439,6 +439,7 @@ fn translate_status(status: c_int) -> ExitStatus {\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n+              target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n     mod imp {\n         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }"}, {"sha": "209460df10b7ceb118f53669dafc0257e2a6ae88", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -12,6 +12,8 @@ use ops::Sub;\n use time::Duration;\n use sync::{Once, ONCE_INIT};\n \n+const NANOS_PER_SEC: i64 = 1_000_000_000;\n+\n pub struct SteadyTime {\n     t: libc::LARGE_INTEGER,\n }\n@@ -24,7 +26,7 @@ impl SteadyTime {\n     }\n \n     pub fn ns(&self) -> u64 {\n-        self.t as u64 * 1_000_000_000 / frequency() as u64\n+        mul_div_i64(self.t as i64, NANOS_PER_SEC, frequency() as i64) as u64\n     }\n }\n \n@@ -45,6 +47,27 @@ impl<'a> Sub for &'a SteadyTime {\n \n     fn sub(self, other: &SteadyTime) -> Duration {\n         let diff = self.t as i64 - other.t as i64;\n-        Duration::microseconds(diff * 1_000_000 / frequency() as i64)\n+        Duration::nanoseconds(mul_div_i64(diff, NANOS_PER_SEC, frequency() as i64))\n     }\n }\n+\n+// Computes (value*numer)/denom without overflow, as long as both\n+// (numer*denom) and the overall result fit into i64 (which is the case\n+// for our time conversions).\n+fn mul_div_i64(value: i64, numer: i64, denom: i64) -> i64 {\n+    let q = value / denom;\n+    let r = value % denom;\n+    // Decompose value as (value/denom*denom + value%denom),\n+    // substitute into (value*numer)/denom and simplify.\n+    // r < denom, so (denom*numer) is the upper bound of (r*numer)\n+    q * numer + r * numer / denom\n+}\n+\n+#[test]\n+fn test_muldiv() {\n+    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n+    assert_eq!(mul_div_i64(-1_000_000_000_001, 1_000_000_000, 1_000_000), -1_000_000_000_001_000);\n+    assert_eq!(mul_div_i64(-1_000_000_000_001,-1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n+    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000,-1_000_000), -1_000_000_000_001_000);\n+    assert_eq!(mul_div_i64( 1_000_000_000_001,-1_000_000_000,-1_000_000),  1_000_000_000_001_000);\n+}"}, {"sha": "764c7d730cb0e448d4c20c390c08769e3624fa49", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -105,10 +105,12 @@ pub struct Key<T> {\n     // This is trivially devirtualizable by LLVM because we never store anything\n     // to this field and rustc can declare the `static` as constant as well.\n     #[doc(hidden)]\n+    #[unstable(feature = \"thread_local_internals\")]\n     pub inner: fn() -> &'static __impl::KeyInner<UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     #[doc(hidden)]\n+    #[unstable(feature = \"thread_local_internals\")]\n     pub init: fn() -> T,\n }\n "}, {"sha": "264e05f5c8d31ec1229b01ff6f6c39c0316b97ab", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -760,13 +760,13 @@ mod test {\n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n             &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n             &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n         assert!(!segments_name_eq(\n             &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n             &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n     }\n }"}, {"sha": "67011ad21a6dd8eec7111f7c07929e9664a0f7ce", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -334,6 +334,10 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                 let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n                 // If T' is in the set FOLLOW(NT), continue. Else, reject.\n                 match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n+                    (_, Err(msg)) => {\n+                        cx.span_err(sp, &msg);\n+                        continue\n+                    }\n                     (&Eof, _) => return Some((sp, tok.clone())),\n                     (_, Ok(true)) => continue,\n                     (next, Ok(false)) => {\n@@ -343,10 +347,6 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                                                  token_to_string(next)));\n                         continue\n                     },\n-                    (_, Err(msg)) => {\n-                        cx.span_err(sp, &msg);\n-                        continue\n-                    }\n                 }\n             },\n             TtSequence(sp, ref seq) => {"}, {"sha": "7c7f1fd478aa9e8b7016d8f6a1279fd38644a90f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -506,16 +506,25 @@ impl<T: Writer> ConsoleTestState<T> {\n                 if self.use_color {\n                     try!(term.reset());\n                 }\n-                Ok(())\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                try!(stdout.write_all(word.as_bytes()));\n+                stdout.flush()\n             }\n-            Raw(ref mut stdout) => stdout.write_all(word.as_bytes())\n         }\n     }\n \n     pub fn write_plain(&mut self, s: &str) -> old_io::IoResult<()> {\n         match self.out {\n-            Pretty(ref mut term) => term.write_all(s.as_bytes()),\n-            Raw(ref mut stdout) => stdout.write_all(s.as_bytes())\n+            Pretty(ref mut term) => {\n+                try!(term.write_all(s.as_bytes()));\n+                term.flush()\n+            },\n+            Raw(ref mut stdout) => {\n+                try!(stdout.write_all(s.as_bytes()));\n+                stdout.flush()\n+            },\n         }\n     }\n "}, {"sha": "8900b60d1913a2eb533702a630fda0cb4f0b9063", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -114,12 +114,12 @@ pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String\n             }\n         };\n \n-        let star_idx = match line.find_str(\"*\") { Some(i) => i, None => continue };\n+        let star_idx = match line.find(\"*\") { Some(i) => i, None => continue };\n \n-        let start_bracket = star_idx + line[star_idx..].find_str(\"[\").unwrap();\n-        let end_bracket = start_bracket + line[start_bracket..].find_str(\"](\").unwrap();\n+        let start_bracket = star_idx + line[star_idx..].find(\"[\").unwrap();\n+        let end_bracket = start_bracket + line[start_bracket..].find(\"](\").unwrap();\n         let start_paren = end_bracket + 1;\n-        let end_paren = start_paren + line[start_paren..].find_str(\")\").unwrap();\n+        let end_paren = start_paren + line[start_paren..].find(\")\").unwrap();\n \n         let given_path = &line[start_paren + 1 .. end_paren];\n         let title = line[start_bracket + 1..end_bracket].to_string();"}, {"sha": "d47575403e171729b4dd4c579eaa85a9e0dcfbc9", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -100,14 +100,22 @@ pub trait UnstableTrait { fn dummy(&self) { } }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedStruct { pub i: int }\n+pub struct DeprecatedStruct {\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+}\n #[unstable(feature = \"test_feature\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedUnstableStruct { pub i: int }\n+pub struct DeprecatedUnstableStruct {\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+}\n #[unstable(feature = \"test_feature\")]\n-pub struct UnstableStruct { pub i: int }\n+pub struct UnstableStruct {\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct StableStruct { pub i: int }\n+pub struct StableStruct {\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+}\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n@@ -137,14 +145,14 @@ pub enum Enum {\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedTupleStruct(pub int);\n+pub struct DeprecatedTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n #[unstable(feature = \"test_feature\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedUnstableTupleStruct(pub int);\n+pub struct DeprecatedUnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n #[unstable(feature = \"test_feature\")]\n-pub struct UnstableTupleStruct(pub int);\n+pub struct UnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct StableTupleStruct(pub int);\n+pub struct StableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n \n #[macro_export]\n macro_rules! macro_test {"}, {"sha": "66940ee0081b49a9a1d9952d4d55b75a83868005", "filename": "src/test/auxiliary/lint_stability_fields.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(staged_api)]\n+#![staged_api]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Stable {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub inherit: u8, // it's a lie (stable doesn't inherit)\n+    #[unstable(feature = \"test_feature\")]\n+    pub override1: u8,\n+    #[deprecated(since = \"1.0.0\")]\n+    #[unstable(feature = \"test_feature\")]\n+    pub override2: u8,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Stable2(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n+                   #[unstable(feature = \"test_feature\")] pub u8,\n+                   #[unstable(feature = \"test_feature\")] #[deprecated(since = \"1.0.0\")] pub u8);\n+\n+#[unstable(feature = \"test_feature\")]\n+pub struct Unstable {\n+    pub inherit: u8,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub override1: u8,\n+    #[deprecated(since = \"1.0.0\")]\n+    #[unstable(feature = \"test_feature\")]\n+    pub override2: u8,\n+}\n+\n+#[unstable(feature = \"test_feature\")]\n+pub struct Unstable2(pub u8,\n+                     #[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n+                     #[unstable(feature = \"test_feature\")] #[deprecated(since = \"1.0.0\")] pub u8);\n+\n+#[unstable(feature = \"test_feature\")]\n+#[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Deprecated {\n+    pub inherit: u8,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub override1: u8,\n+    #[unstable(feature = \"test_feature\")]\n+    pub override2: u8,\n+}\n+\n+#[unstable(feature = \"test_feature\")]\n+#[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Deprecated2(pub u8,\n+                       #[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n+                       #[unstable(feature = \"test_feature\")] pub u8);"}, {"sha": "e61fb49add5b1e7aa5f53082113d483488178d3c", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -11,14 +11,12 @@\n #![crate_name=\"static_methods_crate\"]\n #![crate_type = \"lib\"]\n \n-use std::int;\n-\n pub trait read {\n     fn readMaybe(s: String) -> Option<Self>;\n }\n \n-impl read for int {\n-    fn readMaybe(s: String) -> Option<int> {\n+impl read for isize {\n+    fn readMaybe(s: String) -> Option<isize> {\n         s.parse().ok()\n     }\n }"}, {"sha": "896b0ee57a04cb47186e29aaafd7b5a634d2fed6", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -40,9 +40,7 @@ fn run(repeat: int, depth: int) {\n     }\n }\n \n-// FIXME(#21721) used to be `List<()>` but that can cause\n-// certain LLVM versions to abort during optimizations.\n-type nillist = List<[u8; 0]>;\n+type nillist = List<()>;\n \n // Filled with things that have to be unwound\n \n@@ -83,11 +81,11 @@ fn recurse_or_panic(depth: int, st: Option<State>) {\n             }\n             Some(st) => {\n                 let mut v = st.vec.clone();\n-                v.push_all(&[box List::Cons([], st.vec.last().unwrap().clone())]);\n+                v.push_all(&[box List::Cons((), st.vec.last().unwrap().clone())]);\n                 State {\n-                    unique: box List::Cons([], box *st.unique),\n+                    unique: box List::Cons((), box *st.unique),\n                     vec: v,\n-                    res: r(box List::Cons([], st.res._l.clone())),\n+                    res: r(box List::Cons((), st.res._l.clone())),\n                 }\n             }\n         };"}, {"sha": "c43ff198925034cec0622db9d4b9b0da7789c2c0", "filename": "src/test/compile-fail/lint-stability-fields.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,346 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability_fields.rs\n+#![deny(deprecated)]\n+#![allow(dead_code)]\n+#![feature(staged_api)]\n+#![staged_api]\n+\n+mod cross_crate {\n+    extern crate lint_stability_fields;\n+\n+    use self::lint_stability_fields::*;\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            inherit: 1,\n+            override1: 2, //~ WARN use of unstable\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1; //~ WARN use of unstable\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+\n+        let Stable {\n+            inherit: _,\n+            override1: _, //~ WARN use of unstable\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1; //~ WARN use of unstable\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+\n+        let Stable2(_,\n+                   _, //~ WARN use of unstable\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+\n+        let x = Unstable { //~ WARN use of unstable\n+            inherit: 1, //~ WARN use of unstable\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+        };\n+\n+        let _ = x.inherit; //~ WARN use of unstable\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+\n+        let Unstable { //~ WARN use of unstable\n+            inherit: _, //~ WARN use of unstable\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+        } = x;\n+\n+        let Unstable  //~ WARN use of unstable\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+\n+        let x = Unstable2(1, 2, 3); //~ WARN use of unstable\n+\n+        let _ = x.0; //~ WARN use of unstable\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+\n+        let Unstable2  //~ WARN use of unstable\n+            (_, //~ WARN use of unstable\n+             _,\n+             _)\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            = x;\n+        let Unstable2 //~ WARN use of unstable\n+            // the patterns are all fine:\n+            (..) = x;\n+\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            override1: 2,\n+            override2: 3, //~ WARN use of unstable\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+        let _ = x.override1;\n+        let _ = x.override2; //~ WARN use of unstable\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            override1: _,\n+            override2: _ //~ WARN use of unstable\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            //~^^ WARN use of unstable\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+        let _ = x.1;\n+        let _ = x.2; //~ WARN use of unstable\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             //~^^ WARN use of unstable\n+             _,\n+             _) //~ WARN use of unstable\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+        //~^^ WARN use of unstable\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+mod this_crate {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Stable {\n+        inherit: u8,\n+        #[unstable(feature = \"test_feature\")]\n+        override1: u8,\n+        #[deprecated(since = \"1.0.0\")]\n+        #[unstable(feature = \"test_feature\")]\n+        override2: u8,\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Stable2(u8,\n+                   #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                   #[unstable(feature = \"test_feature\")] #[deprecated(since = \"1.0.0\")] u8);\n+\n+    #[unstable(feature = \"test_feature\")]\n+    struct Unstable {\n+        inherit: u8,\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        override1: u8,\n+        #[deprecated(since = \"1.0.0\")]\n+        #[unstable(feature = \"test_feature\")]\n+        override2: u8,\n+    }\n+\n+    #[unstable(feature = \"test_feature\")]\n+    struct Unstable2(u8,\n+                     #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                     #[unstable(feature = \"test_feature\")] #[deprecated(since = \"1.0.0\")] u8);\n+\n+    #[unstable(feature = \"test_feature\")]\n+    #[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Deprecated {\n+        inherit: u8,\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        override1: u8,\n+        #[unstable(feature = \"test_feature\")]\n+        override2: u8,\n+    }\n+\n+    #[unstable(feature = \"test_feature\")]\n+    #[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+    struct Deprecated2(u8,\n+                       #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n+                       #[unstable(feature = \"test_feature\")] u8);\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+\n+        let x = Unstable {\n+            inherit: 1,\n+            override1: 2,\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        let _ = x.override1;\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable {\n+            inherit: _,\n+            override1: _,\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Unstable\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+\n+        let x = Unstable2(1, 2, 3);\n+\n+        let _ = x.0;\n+        let _ = x.1;\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Unstable2\n+            (_,\n+             _,\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Unstable2\n+            // the patterns are all fine:\n+            (..) = x;\n+\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+            override1: 2,\n+            override2: 3,\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.override1;\n+        let _ = x.override2;\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+            override1: _,\n+            override2: _\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        let _ = x.2;\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             _)\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "12548c4539618d73173b3a4b6d50c37faacc079d", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -317,11 +317,17 @@ mod this_crate {\n \n     #[unstable(feature = \"test_feature\")]\n     #[deprecated(since = \"1.0.0\")]\n-    pub struct DeprecatedStruct { i: isize }\n+    pub struct DeprecatedStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n     #[unstable(feature = \"test_feature\")]\n-    pub struct UnstableStruct { i: isize }\n+    pub struct UnstableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub struct StableStruct { i: isize }\n+    pub struct StableStruct {\n+        #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n+    }\n \n     #[unstable(feature = \"test_feature\")]\n     #[deprecated(since = \"1.0.0\")]"}, {"sha": "b868b79365d9f683755398adf8b5dc2d496d7292", "filename": "src/test/compile-fail/unused-macro-with-bad-frag-spec.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #21370\n+\n+macro_rules! test {\n+    ($wrong:t_ty) => () //~ ERROR invalid fragment specifier `t_ty`\n+}\n+\n+fn main() { }"}, {"sha": "e9d09bb6ad9cd739a7a4a700e9063a5e0ef4165f", "filename": "src/test/compile-fail/unused-macro-with-follow-violation.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! test {\n+    ($e:expr +) => () //~ ERROR not allowed for `expr` fragments\n+}\n+\n+fn main() { }"}, {"sha": "6b365c348f782b52f26c1d6e1e57500a312ee3a5", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n use std::num::FromPrimitive;\n-use std::int;\n+use std::isize;\n \n #[derive(PartialEq, FromPrimitive, Debug)]\n enum A {\n-    Foo = int::MAX,\n+    Foo = isize::MAX,\n     Bar = 1,\n     Baz = 3,\n     Qux,\n }\n \n pub fn main() {\n-    let x: Option<A> = FromPrimitive::from_int(int::MAX);\n+    let x: Option<A> = FromPrimitive::from_int(isize::MAX);\n     assert_eq!(x, Some(A::Foo));\n \n     let x: Option<A> = FromPrimitive::from_int(1);"}, {"sha": "aa53a7658e1291fd5985ac06abeb89ac5d765516", "filename": "src/test/run-pass/issue-17216.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17216.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -25,9 +25,7 @@ fn main() {\n     let mut dropped = false;\n     {\n         let leak = Leak { dropped: &mut dropped };\n-        // FIXME(#21721) \"hack\" used to be () but that can cause\n-        // certain LLVM versions to abort during optimizations.\n-        for (_, leaked) in Some((\"hack\", leak)).into_iter() {}\n+        for ((), leaked) in Some(((), leak)).into_iter() {}\n     }\n \n     assert!(dropped);"}, {"sha": "fee14061c566ab5e6feba90476b636f053fd5619", "filename": "src/test/run-pass/issue-21721.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-21721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-21721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21721.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    static NONE: Option<((), &'static u8)> = None;\n+    let ptr = unsafe {\n+        *(&NONE as *const _ as *const *const u8)\n+    };\n+    assert!(ptr.is_null());\n+}"}, {"sha": "b3492180a5829322f3fb49376eab4bf31fe8b761", "filename": "src/test/run-pass/issue-22536-copy-mustnt-zero.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22536-copy-mustnt-zero.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #22536: If a type implements Copy, then\n+// moving it must not zero the original memory.\n+\n+trait Resources {\n+    type Buffer: Copy;\n+    fn foo(&self) {}\n+}\n+\n+struct BufferHandle<R: Resources> {\n+    raw: <R as Resources>::Buffer,\n+}\n+impl<R: Resources> Copy for BufferHandle<R> {}\n+\n+enum Res {}\n+impl Resources for Res {\n+    type Buffer = u32;\n+}\n+impl Copy for Res { }\n+\n+fn main() {\n+    let b: BufferHandle<Res> = BufferHandle { raw: 1 };\n+    let c = b;\n+    assert_eq!(c.raw, b.raw)\n+}"}, {"sha": "d2e27fc822eebe8323a641772db87038842e2e8c", "filename": "src/test/run-pass/match-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::uint;\n-\n pub fn main() {\n     // sometimes we have had trouble finding\n     // the right type for f, as we unified\n     // bot and u32 here\n-    let f = match \"1234\".parse::<uint>().ok() {\n+    let f = match \"1234\".parse::<usize>().ok() {\n         None => return (),\n         Some(num) => num as u32\n     };"}, {"sha": "18c7cfb0850ceace40ecdb59a275d76c3e9be5eb", "filename": "src/test/run-pass/traits-issue-22655.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Ftraits-issue-22655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e233987ce1de88a48db2ce612019ba644d3cf5dd/src%2Ftest%2Frun-pass%2Ftraits-issue-22655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-22655.rs?ref=e233987ce1de88a48db2ce612019ba644d3cf5dd", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #22655: This test should not lead to\n+// infinite recursion.\n+\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+\n+pub struct Unique<T:?Sized> {\n+    pointer: *const T,\n+}\n+\n+pub struct Node<V> {\n+    vals: V,\n+    edges: Unique<Node<V>>,\n+}\n+\n+fn is_send<T: Send>() {}\n+\n+fn main() {\n+    is_send::<Node<&'static ()>>();\n+}"}]}