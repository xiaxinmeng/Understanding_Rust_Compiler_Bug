{"sha": "ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZDJhMGI5ZDc4MTkxYjhhM2Q5N2Y2ODcwNzc4NTJkMTVjOWI3YWE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-31T19:39:50Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-02-14T20:30:23Z"}, "message": "Add some simple error recovery to the parser and fix tests\n\nSome tests just add the extra errors, others I fix by doing some simple error recovery. I've tried to avoid doing too much in the hope of doing something more principled later.\n\nIn general error messages are getting worse at this stage, but I think in the long run they will get better.", "tree": {"sha": "e42abe4c33ac32d668304dff9a024d2d0ad8aa5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e42abe4c33ac32d668304dff9a024d2d0ad8aa5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "html_url": "https://github.com/rust-lang/rust/commit/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef9c5f5853ce35db142e4e2793984148df3d5f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef9c5f5853ce35db142e4e2793984148df3d5f8", "html_url": "https://github.com/rust-lang/rust/commit/0ef9c5f5853ce35db142e4e2793984148df3d5f8"}], "stats": {"total": 118, "additions": 69, "deletions": 49}, "files": [{"sha": "14c663b698c23e285245d04e78d56169c05db21a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "patch": "@@ -598,7 +598,7 @@ impl<'a> Parser<'a> {\n \n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n-    /// This method is will automatically add `tok` to `expected_tokens` if `tok` is not\n+    /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n     /// encountered.\n     pub fn check(&mut self, tok: &token::Token) -> bool {\n         let is_present = self.token == *tok;\n@@ -840,6 +840,12 @@ impl<'a> Parser<'a> {\n         return Ok((v, returned));\n     }\n \n+    /// Eat and discard tokens until one of `kets` is encountered. Respects token trees,\n+    /// passes through any errors encountered. Used for error recovery.\n+    pub fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n+        self.parse_seq_to_before_tokens(kets, seq_sep_none(), |p| p.parse_token_tree());\n+    }\n+\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -861,13 +867,23 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_end<T, F>(&mut self,\n                                          ket: &token::Token,\n                                          sep: SeqSep,\n-                                         mut f: F)\n+                                         f: F)\n                                          -> Vec<T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+    {\n+        self.parse_seq_to_before_tokens(&[ket], sep, f)\n+    }\n+\n+    pub fn parse_seq_to_before_tokens<T, F>(&mut self,\n+                                            kets: &[&token::Token],\n+                                            sep: SeqSep,\n+                                            mut f: F)\n+                                            -> Vec<T>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         let mut first: bool = true;\n         let mut v = vec!();\n-        while self.token != *ket {\n+        while !kets.contains(&&self.token) {\n             match sep.sep {\n                 Some(ref t) => {\n                     if first {\n@@ -881,7 +897,9 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => ()\n             }\n-            if sep.trailing_sep_allowed && self.check(ket) { break; }\n+            if sep.trailing_sep_allowed && kets.iter().any(|k| self.check(k)) {\n+                break;\n+            }\n \n             match f(self) {\n                 Ok(t) => v.push(t),\n@@ -1230,7 +1248,25 @@ impl<'a> Parser<'a> {\n                 };\n                 (ident, TraitItemKind::Const(ty, default))\n             } else {\n-                let (constness, unsafety, abi) = try!(p.parse_fn_front_matter());\n+                let (constness, unsafety, abi) = match p.parse_fn_front_matter() {\n+                    Ok(cua) => cua,\n+                    Err(e) => {\n+                        loop {\n+                            p.bump();\n+                            if p.token == token::Semi {\n+                                p.bump();\n+                                break;\n+                            }\n+\n+                            if p.token == token::OpenDelim(token::DelimToken::Brace) {\n+                                try!(p.parse_token_tree());\n+                                break;\n+                            }\n+                        }\n+                        \n+                        return Err(e);\n+                    }\n+                };\n \n                 let ident = try!(p.parse_ident());\n                 let mut generics = try!(p.parse_generics());\n@@ -4181,8 +4217,8 @@ impl<'a> Parser<'a> {\n     fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n         if self.token.is_lifetime() {\n             let span = self.span;\n-            return Err(self.span_fatal(span, \"lifetime parameters must be declared \\\n-                                        prior to type parameters\"))\n+            return Err(self.diagnostic().struct_span_err(span, \"lifetime parameters must be \\\n+                                                                declared prior to type parameters\"))\n         }\n         Ok(())\n     }\n@@ -4310,7 +4346,8 @@ impl<'a> Parser<'a> {\n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n         let sp = self.span;\n-        let mut args: Vec<Option<Arg>> =\n+        let mut variadic = false;\n+        let args: Vec<Option<Arg>> =\n             try!(self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Paren),\n                 &token::CloseDelim(token::Paren),\n@@ -4321,37 +4358,35 @@ impl<'a> Parser<'a> {\n                         if allow_variadic {\n                             if p.token != token::CloseDelim(token::Paren) {\n                                 let span = p.span;\n-                                return Err(p.span_fatal(span,\n-                                    \"`...` must be last in argument list for variadic function\"))\n+                                p.span_err(span,\n+                                    \"`...` must be last in argument list for variadic function\");\n                             }\n                         } else {\n                             let span = p.span;\n-                            return Err(p.span_fatal(span,\n-                                         \"only foreign functions are allowed to be variadic\"))\n+                            p.span_err(span,\n+                                       \"only foreign functions are allowed to be variadic\");\n                         }\n+                        variadic = true;\n                         Ok(None)\n                     } else {\n-                        Ok(Some(try!(p.parse_arg_general(named_args))))\n+                        match p.parse_arg_general(named_args) {\n+                            Ok(arg) => Ok(Some(arg)),\n+                            Err(mut e) => {\n+                                e.emit();\n+                                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                                Ok(None)\n+                            }\n+                        }\n                     }\n                 }\n             ));\n \n-        let variadic = match args.pop() {\n-            Some(None) => true,\n-            Some(x) => {\n-                // Need to put back that last arg\n-                args.push(x);\n-                false\n-            }\n-            None => false\n-        };\n-\n         if variadic && args.is_empty() {\n             self.span_err(sp,\n                           \"variadic function must be declared with at least one named argument\");\n         }\n \n-        let args = args.into_iter().map(|x| x.unwrap()).collect();\n+        let args = args.into_iter().filter_map(|x| x).collect();\n \n         Ok((args, variadic))\n     }\n@@ -4749,8 +4784,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = try!(self.expect_open_delim());\n             let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            seq_sep_none(),\n-                                            |p| p.parse_token_tree()));\n+                                                 seq_sep_none(),\n+                                                 |p| p.parse_token_tree()));\n             let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n                                                 span: mk_sp(lo,\n@@ -5809,8 +5844,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = try!(self.expect_open_delim());\n             let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            seq_sep_none(),\n-                                            |p| p.parse_token_tree()));\n+                                                 seq_sep_none(),\n+                                                 |p| p.parse_token_tree()));\n             // single-variant-enum... :\n             let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m,"}, {"sha": "7c30b5f26296ba0ef0583de657fc0b95742f08f4", "filename": "src/test/parse-fail/issue-14303-path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs?ref=ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "patch": "@@ -12,3 +12,4 @@\n \n fn bar<'a, T>(x: mymodule::X<'a, T, 'b, 'c>) {}\n //~^ ERROR lifetime parameters must be declared prior to type parameters\n+//~^^ ERROR unexpected token"}, {"sha": "2e799a72c81af7b6b1a3bba5c65a8149cb7b48e6", "filename": "src/test/parse-fail/issue-2354.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fissue-2354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fissue-2354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-2354.rs?ref=ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "patch": "@@ -12,8 +12,8 @@\n \n fn foo() { //~ HELP did you mean to close this delimiter?\n   match Some(x) {\n-      Some(y) { panic!(); }\n-      None    { panic!(); }\n+      Some(y) => { panic!(); }\n+      None => { panic!(); }\n }\n \n fn bar() {"}, {"sha": "bc27aedb627ee5fe7c784b6b7c920df0bb88e0f5", "filename": "src/test/parse-fail/pat-lt-bracket-6.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs?ref=ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let Test(&desc[..]) = x; //~ error: expected one of `,` or `@`, found `[`\n+    //~^ ERROR expected one of `:`, `;`, or `=`, found `..`\n }"}, {"sha": "3e9478da44de596853501b9c5a90cceec4c5efe9", "filename": "src/test/parse-fail/pat-lt-bracket-7.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs?ref=ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    for thing(x[]) {} //~ error: expected one of `,` or `@`, found `[`\n+    for thing(x[]) in foo {} //~ error: expected one of `,` or `@`, found `[`\n+    //~^ ERROR: expected `in`, found `]`\n }"}, {"sha": "63a36e984399d95fee67c15b27d891905bd4d1b0", "filename": "src/test/parse-fail/variadic-ffi-1.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ef9c5f5853ce35db142e4e2793984148df3d5f8/src%2Ftest%2Fparse-fail%2Fvariadic-ffi-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef9c5f5853ce35db142e4e2793984148df3d5f8/src%2Ftest%2Fparse-fail%2Fvariadic-ffi-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fvariadic-ffi-1.rs?ref=0ef9c5f5853ce35db142e4e2793984148df3d5f8", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-extern {\n-    fn printf(...); //~ ERROR: variadic function must be declared with at least one named argument\n-    fn printf(..., foo: isize); //~ ERROR: `...` must be last in argument list for variadic function\n-}\n-\n-fn main() {}"}]}