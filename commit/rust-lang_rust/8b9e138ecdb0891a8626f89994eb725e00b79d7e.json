{"sha": "8b9e138ecdb0891a8626f89994eb725e00b79d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOWUxMzhlY2RiMDg5MWE4NjI2Zjg5OTk0ZWI3MjVlMDBiNzlkN2U=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-21T00:42:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-21T00:42:19Z"}, "message": "Rollup merge of #86491 - petrochenkov:derefact, r=Aaron1011\n\nexpand: Move some more derive logic to rustc_builtin_macros\n\nAnd cleanup some `unwrap`s in `cfg_eval`.\n\nRefactorings extracted from https://github.com/rust-lang/rust/pull/83354 and https://github.com/rust-lang/rust/pull/86057.\nr? ``@Aaron1011``", "tree": {"sha": "e4654f8351bbce4d433d960c9d7ca4f8fd19a70e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4654f8351bbce4d433d960c9d7ca4f8fd19a70e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b9e138ecdb0891a8626f89994eb725e00b79d7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgz+BsCRBK7hj4Ov3rIwAABEwIAKGk9g628GzPvXLB9h2wmu26\n1g9L+ef+SAmHuhUB1U/cQmI5ju9rH016QWC/tLabiQ8Qwz4eotkVa+OMwC6uyP67\nBlef5bVBnqkzOzf3LE7XFl2+LA08DyR14lNDzIByRqpGwlb1K0YFEGZ+4FJB+NCP\n7jbzZAi2QLypSPU2ML+LcxALo0XaOZCS2cV9dCUpMq68SFCyhqLdbVgABOc3UBxf\nd1Z6tvRpEHrHVHHGwkKRqEfyu50j0vTY83EVLXNVGf1w+GX/M36XFSO0VneZJkyT\nRy31AWEsLR8A90hwBCPjz4FeUm4I4ATsZs/jLokZ+VNokX8kYYTpx5hAzquN8hM=\n=LAIU\n-----END PGP SIGNATURE-----\n", "payload": "tree e4654f8351bbce4d433d960c9d7ca4f8fd19a70e\nparent e5ecded392916860dfc9bad840a115572610f1fb\nparent d9fd5eaae86fe9b21ec38da6acda296e64f4e93d\nauthor Yuki Okushi <jtitor@2k36.org> 1624236139 +0900\ncommitter GitHub <noreply@github.com> 1624236139 +0900\n\nRollup merge of #86491 - petrochenkov:derefact, r=Aaron1011\n\nexpand: Move some more derive logic to rustc_builtin_macros\n\nAnd cleanup some `unwrap`s in `cfg_eval`.\n\nRefactorings extracted from https://github.com/rust-lang/rust/pull/83354 and https://github.com/rust-lang/rust/pull/86057.\nr? ``@Aaron1011``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e138ecdb0891a8626f89994eb725e00b79d7e", "html_url": "https://github.com/rust-lang/rust/commit/8b9e138ecdb0891a8626f89994eb725e00b79d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e138ecdb0891a8626f89994eb725e00b79d7e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5ecded392916860dfc9bad840a115572610f1fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ecded392916860dfc9bad840a115572610f1fb", "html_url": "https://github.com/rust-lang/rust/commit/e5ecded392916860dfc9bad840a115572610f1fb"}, {"sha": "d9fd5eaae86fe9b21ec38da6acda296e64f4e93d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9fd5eaae86fe9b21ec38da6acda296e64f4e93d", "html_url": "https://github.com/rust-lang/rust/commit/d9fd5eaae86fe9b21ec38da6acda296e64f4e93d"}], "stats": {"total": 99, "additions": 37, "deletions": 62}, "files": [{"sha": "d7b46f282151fe32ac11e8dc1432d98f0ba58bb6", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=8b9e138ecdb0891a8626f89994eb725e00b79d7e", "patch": "@@ -24,61 +24,60 @@ crate fn expand(\n     annotatable: Annotatable,\n ) -> Vec<Annotatable> {\n     check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n-    cfg_eval(ecx, annotatable)\n+    vec![cfg_eval(ecx, annotatable)]\n }\n \n-crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n-    let mut visitor = CfgEval {\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Annotatable {\n+    CfgEval {\n         cfg: &mut StripUnconfigured {\n             sess: ecx.sess,\n             features: ecx.ecfg.features,\n             config_tokens: true,\n         },\n-    };\n-    let annotatable = visitor.configure_annotatable(annotatable);\n-    vec![annotatable]\n+    }\n+    .configure_annotatable(annotatable)\n+    // Since the item itself has already been configured by the `InvocationCollector`,\n+    // we know that fold result vector will contain exactly one element.\n+    .unwrap()\n }\n \n struct CfgEval<'a, 'b> {\n     cfg: &'a mut StripUnconfigured<'b>,\n }\n \n-fn flat_map_annotatable(vis: &mut impl MutVisitor, annotatable: Annotatable) -> Annotatable {\n-    // Since the item itself has already been configured by the InvocationCollector,\n-    // we know that fold result vector will contain exactly one element\n+fn flat_map_annotatable(\n+    vis: &mut impl MutVisitor,\n+    annotatable: Annotatable,\n+) -> Option<Annotatable> {\n     match annotatable {\n-        Annotatable::Item(item) => Annotatable::Item(vis.flat_map_item(item).pop().unwrap()),\n+        Annotatable::Item(item) => vis.flat_map_item(item).pop().map(Annotatable::Item),\n         Annotatable::TraitItem(item) => {\n-            Annotatable::TraitItem(vis.flat_map_trait_item(item).pop().unwrap())\n+            vis.flat_map_trait_item(item).pop().map(Annotatable::TraitItem)\n         }\n         Annotatable::ImplItem(item) => {\n-            Annotatable::ImplItem(vis.flat_map_impl_item(item).pop().unwrap())\n+            vis.flat_map_impl_item(item).pop().map(Annotatable::ImplItem)\n         }\n         Annotatable::ForeignItem(item) => {\n-            Annotatable::ForeignItem(vis.flat_map_foreign_item(item).pop().unwrap())\n+            vis.flat_map_foreign_item(item).pop().map(Annotatable::ForeignItem)\n         }\n         Annotatable::Stmt(stmt) => {\n-            Annotatable::Stmt(stmt.map(|stmt| vis.flat_map_stmt(stmt).pop().unwrap()))\n+            vis.flat_map_stmt(stmt.into_inner()).pop().map(P).map(Annotatable::Stmt)\n         }\n-        Annotatable::Expr(mut expr) => Annotatable::Expr({\n+        Annotatable::Expr(mut expr) => {\n             vis.visit_expr(&mut expr);\n-            expr\n-        }),\n-        Annotatable::Arm(arm) => Annotatable::Arm(vis.flat_map_arm(arm).pop().unwrap()),\n-        Annotatable::ExprField(field) => {\n-            Annotatable::ExprField(vis.flat_map_expr_field(field).pop().unwrap())\n+            Some(Annotatable::Expr(expr))\n         }\n-        Annotatable::PatField(fp) => {\n-            Annotatable::PatField(vis.flat_map_pat_field(fp).pop().unwrap())\n+        Annotatable::Arm(arm) => vis.flat_map_arm(arm).pop().map(Annotatable::Arm),\n+        Annotatable::ExprField(field) => {\n+            vis.flat_map_expr_field(field).pop().map(Annotatable::ExprField)\n         }\n+        Annotatable::PatField(fp) => vis.flat_map_pat_field(fp).pop().map(Annotatable::PatField),\n         Annotatable::GenericParam(param) => {\n-            Annotatable::GenericParam(vis.flat_map_generic_param(param).pop().unwrap())\n-        }\n-        Annotatable::Param(param) => Annotatable::Param(vis.flat_map_param(param).pop().unwrap()),\n-        Annotatable::FieldDef(sf) => {\n-            Annotatable::FieldDef(vis.flat_map_field_def(sf).pop().unwrap())\n+            vis.flat_map_generic_param(param).pop().map(Annotatable::GenericParam)\n         }\n-        Annotatable::Variant(v) => Annotatable::Variant(vis.flat_map_variant(v).pop().unwrap()),\n+        Annotatable::Param(param) => vis.flat_map_param(param).pop().map(Annotatable::Param),\n+        Annotatable::FieldDef(sf) => vis.flat_map_field_def(sf).pop().map(Annotatable::FieldDef),\n+        Annotatable::Variant(v) => vis.flat_map_variant(v).pop().map(Annotatable::Variant),\n     }\n }\n \n@@ -123,11 +122,11 @@ impl CfgEval<'_, '_> {\n         self.cfg.configure(node)\n     }\n \n-    pub fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Annotatable {\n+    fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Option<Annotatable> {\n         // Tokenizing and re-parsing the `Annotatable` can have a significant\n         // performance impact, so try to avoid it if possible\n         if !CfgFinder::has_cfg_or_cfg_attr(&annotatable) {\n-            return annotatable;\n+            return Some(annotatable);\n         }\n \n         // The majority of parsed attribute targets will never need to have early cfg-expansion"}, {"sha": "60d6bae38b56c89c251913fd2eea4235611d87b6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=8b9e138ecdb0891a8626f89994eb725e00b79d7e", "patch": "@@ -26,6 +26,8 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n+        let item = cfg_eval(ecx, item);\n+\n         let result =\n             ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n                 let template =\n@@ -54,12 +56,12 @@ impl MultiItemModifier for Expander {\n                         report_path_args(sess, &meta);\n                         meta.path\n                     })\n-                    .map(|path| (path, None))\n+                    .map(|path| (path, item.clone(), None))\n                     .collect()\n             });\n \n         match result {\n-            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n+            Ok(()) => ExpandResult::Ready(vec![item]),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "96fd6cb68e8b93419cc6d9a40b9d02327fc9cba3", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8b9e138ecdb0891a8626f89994eb725e00b79d7e", "patch": "@@ -835,7 +835,7 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n-pub type DeriveResolutions = Vec<(ast::Path, Option<Lrc<SyntaxExtension>>)>;\n+pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>)>;\n \n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;"}, {"sha": "f8a12ef8a208197d381fc8c1d5989ad26c49f4e0", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8b9e138ecdb0891a8626f89994eb725e00b79d7e", "patch": "@@ -500,42 +500,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         .resolver\n                         .take_derive_resolutions(expn_id)\n                         .map(|derives| {\n-                            enum AnnotatableRef<'a> {\n-                                Item(&'a P<ast::Item>),\n-                                Stmt(&'a ast::Stmt),\n-                            }\n-                            let item = match &fragment {\n-                                AstFragment::Items(items) => match &items[..] {\n-                                    [item] => AnnotatableRef::Item(item),\n-                                    _ => unreachable!(),\n-                                },\n-                                AstFragment::Stmts(stmts) => match &stmts[..] {\n-                                    [stmt] => AnnotatableRef::Stmt(stmt),\n-                                    _ => unreachable!(),\n-                                },\n-                                _ => unreachable!(),\n-                            };\n-\n                             derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(path, _exts)| {\n+                                .map(|(path, item, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = ExpnId::fresh(None);\n                                     derive_invocations.push((\n                                         Invocation {\n-                                            kind: InvocationKind::Derive {\n-                                                path,\n-                                                item: match item {\n-                                                    AnnotatableRef::Item(item) => {\n-                                                        Annotatable::Item(item.clone())\n-                                                    }\n-                                                    AnnotatableRef::Stmt(stmt) => {\n-                                                        Annotatable::Stmt(P(stmt.clone()))\n-                                                    }\n-                                                },\n-                                            },\n+                                            kind: InvocationKind::Derive { path, item },\n                                             fragment_kind,\n                                             expansion_data: ExpansionData {\n                                                 id: expn_id,"}, {"sha": "38d052f988c63fefa192da601a8ef0507bf09d2c", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e138ecdb0891a8626f89994eb725e00b79d7e/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=8b9e138ecdb0891a8626f89994eb725e00b79d7e", "patch": "@@ -380,7 +380,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             has_derive_copy: false,\n         });\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n-        for (i, (path, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n+        for (i, (path, _, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n             if opt_ext.is_none() {\n                 *opt_ext = Some(\n                     match self.resolve_macro_path("}]}