{"sha": "a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYmFlYjUxNmNkMjRjNzhiZGVkYjhhNmRkY2JmYjlkODJhNzliNTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-06-19T21:32:53Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-20T12:28:18Z"}, "message": "Run the tls destructors in the correct order", "tree": {"sha": "9983d19767a97ea59c9c3b2604b796e1d8b9facc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9983d19767a97ea59c9c3b2604b796e1d8b9facc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAllJFOIACgkQpp+NIls6\n19m9JA/8C2mQiTCoIxYL5Am0RNdrt5NNqsCcxKx3Rd7BOopqsKxQV0ZafPS37CtR\nMi+/mgZnoiSBUR7vSXduxHqfhSkiKYU1HxyPfvvxERG9tjMC37MPGmSMmE3mN0LO\nsPR7nIXLFocPRMqh2GH86NKD633jCzfZueAIvw1IWvvG6I4I5eNeTbrD1Nc3y9AO\n1unnDBHTa9zv2zd4rOda+pIDijlmBIZzLUiJx1/OlWnSxjmPGnn4oRSBs9Wt7J/A\nCWfWSdxGbqMmJylhMgQBUc5c48y/V0Ae+F5rah8crYh32ZVzX9ofljrBV0BBytxC\nTgVh5J5wlkjhTHA0zvx+AwHlTUe2ItyQzERM+cnuXpoDyfjefQn6M4qA8H62WQIo\niz5ndFYVYMW1fJ7AGZnoJyMCQ7aP8TACBGgW/JkrlskfRJOJh/K78msLh75DgmJy\nrhrwljysVW/nbp6t3KNsprjWISgfMcisoDjoU/T6iTG89y6McmYz9Kl2+hlJKgm0\nMInawiPU9jTa7zut601HEb4ImMKocPpXmRw5AEEZ2MenOGSR3E7dSnaZBEbsEcvZ\nSaI4zR1UIKrq41RPZsKEiAMXF4/6b+AsyIRW1HN95jYc/pMmHtvcAIHQ2bmrOXQK\n+3zCR4r11mEfptpbCqy8XMaDHTGvNmQISZqvo65sbHz7gklRq7A=\n=Ixp4\n-----END PGP SIGNATURE-----", "payload": "tree 9983d19767a97ea59c9c3b2604b796e1d8b9facc\nparent 43afa20dc7d91421e5e20ab92c75cc139bfc5795\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1497907973 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1497961698 +0200\n\nRun the tls destructors in the correct order\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "html_url": "https://github.com/rust-lang/rust/commit/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43afa20dc7d91421e5e20ab92c75cc139bfc5795", "url": "https://api.github.com/repos/rust-lang/rust/commits/43afa20dc7d91421e5e20ab92c75cc139bfc5795", "html_url": "https://github.com/rust-lang/rust/commit/43afa20dc7d91421e5e20ab92c75cc139bfc5795"}], "stats": {"total": 69, "additions": 40, "deletions": 29}, "files": [{"sha": "69469c30e4815f719172cf93cc9429ac2fdf7a13", "filename": "src/eval_context.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "patch": "@@ -17,7 +17,7 @@ use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, TlsKey};\n use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n@@ -100,6 +100,11 @@ pub enum StackPopCleanup {\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n+    /// After finishing a tls destructor, find the next one instead of starting from the beginning\n+    /// and thus just rerunning the first one until its `data` argument is null\n+    ///\n+    /// The index is the current tls destructor's index\n+    Tls(Option<TlsKey>),\n     /// The main function and diverging functions have nowhere to return to\n     None,\n }\n@@ -351,6 +356,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n+            StackPopCleanup::Tls(key) => {\n+                // either fetch the next dtor or start new from the beginning, if any are left with a non-null data\n+                if let Some((instance, ptr, key)) = self.memory.fetch_tls_dtor(key).or_else(|| self.memory.fetch_tls_dtor(None)) {\n+                    trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+                    // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+                    let mir = self.load_mir(instance.def)?;\n+                    self.push_stack_frame(\n+                        instance,\n+                        mir.span,\n+                        mir,\n+                        Lvalue::zst(),\n+                        StackPopCleanup::Tls(Some(key)),\n+                    )?;\n+                    let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                    self.write_primval(dest, ptr, ty)?;\n+                }\n+            }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -1630,8 +1654,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 start_instance,\n                 start_mir.span,\n                 start_mir,\n-                Some(Lvalue::from_ptr(ret_ptr)),\n-                StackPopCleanup::None,\n+                Lvalue::from_ptr(ret_ptr),\n+                StackPopCleanup::Tls(None),\n             )?;\n \n             let mut args = ecx.frame().mir.args_iter();\n@@ -1657,8 +1681,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Some(Lvalue::zst()),\n-                StackPopCleanup::None,\n+                Lvalue::zst(),\n+                StackPopCleanup::Tls(None),\n             )?;\n         }\n "}, {"sha": "ea1d8695d59883b86aaf0904ae345287e86f2375", "filename": "src/memory.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "patch": "@@ -141,7 +141,7 @@ pub struct Memory<'a, 'tcx> {\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n \n     /// pthreads-style thread-local storage.\n-    thread_local: HashMap<TlsKey, TlsEntry<'tcx>>,\n+    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n \n     /// The Key to use for the next thread-local allocation.\n     next_thread_local: TlsKey,\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             packed: BTreeSet::new(),\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n-            thread_local: HashMap::new(),\n+            thread_local: BTreeMap::new(),\n             next_thread_local: 0,\n         }\n     }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n     \n-    /// Returns a dtor and its argument, if one is supposed to run\n+    /// Returns a dtor, its argument and its index, if one is supposed to run\n     ///\n     /// An optional destructor function may be associated with each key value.\n     /// At thread exit, if a key value has a non-NULL destructor pointer,\n@@ -409,12 +409,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// with associated destructors, implementations may stop calling destructors,\n     /// or they may continue calling destructors until no non-NULL values with\n     /// associated destructors exist, even though this might result in an infinite loop.\n-\n-    pub(crate) fn fetch_tls_dtor(&mut self) -> Option<(ty::Instance<'tcx>, PrimVal)> {\n-        for (_, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.iter_mut() {\n+    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> Option<(ty::Instance<'tcx>, PrimVal, TlsKey)> {\n+        use std::collections::Bound::*;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.range_mut((start, Unbounded)) {\n             if *data != PrimVal::Bytes(0) {\n                 if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data));\n+                    let ret = Some((dtor, *data, key));\n                     *data = PrimVal::Bytes(0);\n                     return ret;\n                 }"}, {"sha": "a1a9409e2e6a72714b5b02530374514cdde72045", "filename": "src/step.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=a2baeb516cd24c78bdedb8a6ddcbfb9d82a79b50", "patch": "@@ -32,23 +32,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.clear_packed();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n-            if let Some((instance, ptr)) = self.memory.fetch_tls_dtor() {\n-                trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-                // TODO: Potientially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n-                let mir = self.load_mir(instance.def)?;\n-                self.push_stack_frame(\n-                    instance,\n-                    mir.span,\n-                    mir,\n-                    Some(Lvalue::zst()),\n-                    StackPopCleanup::None,\n-                )?;\n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n-                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                self.write_primval(dest, ptr, ty)?;\n-                return Ok(true);\n-            }\n             return Ok(false);\n         }\n "}]}