{"sha": "8cf521d80e9057211629e92aff059dc9770c20bd", "node_id": "C_kwDOAAsO6NoAKDhjZjUyMWQ4MGU5MDU3MjExNjI5ZTkyYWZmMDU5ZGM5NzcwYzIwYmQ", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-20T07:50:32Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-12-03T22:32:08Z"}, "message": "Remove drop order twist of && and || and make them associative\n\nPreviously a short circuiting && chain would drop the\nfirst element after all the other elements, and otherwise\nfollow evaluation order, so code like:\n\nf(1).g() && f(2).g() && f(3).g() && f(4).g()\n\nwould drop the temporaries in the order 2,3,4,1. This made\n&& and || non-associative regarding drop order, so\nadding ()'s to the expression would change drop order:\n\nf(1).g() && (f(2).g() && f(3).g()) && f(4).g()\n\nfor example would drop in the order 3,2,4,1.\n\nAs, except for the bool result, there is no data returned\nby the sub-expressions of the short circuiting binops,\nwe can safely discard of any temporaries created by the\nsub-expr. Previously, code was already putting the rhs's\ninto terminating scopes, but missed it for the lhs's.\n\nThis commit addresses this \"twist\". In the expression,\nwe now also put the lhs into a terminating scope.\nThe drop order for the above expressions is 1,2,3,4\nnow.", "tree": {"sha": "f05da93100e7ff26c9140770b159b34b7efbff10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f05da93100e7ff26c9140770b159b34b7efbff10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf521d80e9057211629e92aff059dc9770c20bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf521d80e9057211629e92aff059dc9770c20bd", "html_url": "https://github.com/rust-lang/rust/commit/8cf521d80e9057211629e92aff059dc9770c20bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf521d80e9057211629e92aff059dc9770c20bd/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab4fd678c5b148a330f2bf255bf28a67dfea0fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab4fd678c5b148a330f2bf255bf28a67dfea0fc", "html_url": "https://github.com/rust-lang/rust/commit/cab4fd678c5b148a330f2bf255bf28a67dfea0fc"}], "stats": {"total": 140, "additions": 129, "deletions": 11}, "files": [{"sha": "8c2557464782e3baed9fd63a28ae50f123076f72", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8cf521d80e9057211629e92aff059dc9770c20bd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf521d80e9057211629e92aff059dc9770c20bd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=8cf521d80e9057211629e92aff059dc9770c20bd", "patch": "@@ -241,18 +241,35 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::And, .. },\n-                _,\n+                source_map::Spanned { node: outer @ hir::BinOpKind::And, .. },\n+                ref l,\n                 ref r,\n             )\n             | hir::ExprKind::Binary(\n-                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n-                _,\n+                source_map::Spanned { node: outer @ hir::BinOpKind::Or, .. },\n+                ref l,\n                 ref r,\n             ) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n \n+                // If the LHS is not another binop itself of the same kind as ours,\n+                // we also mark it as terminating, so that in && or || chains,\n+                // the temporaries are dropped in order instead of the very first\n+                // being dropped last. For the Let exception, see below.\n+                let terminate_lhs = match l.kind {\n+                    hir::ExprKind::Let(_) => false,\n+                    hir::ExprKind::Binary(source_map::Spanned { node, .. }, ..)\n+                        if node == outer =>\n+                    {\n+                        false\n+                    }\n+                    _ => true,\n+                };\n+                if terminate_lhs {\n+                    terminating(l.hir_id.local_id);\n+                }\n+\n                 // `Let` expressions (in a let-chain) shouldn't be terminating, as their temporaries\n                 // should live beyond the immediate expression\n                 if !matches!(r.kind, hir::ExprKind::Let(_)) {"}, {"sha": "4e5c1205bb9c305137f009d3b8b5b02709123445", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 71, "deletions": 7, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8cf521d80e9057211629e92aff059dc9770c20bd/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf521d80e9057211629e92aff059dc9770c20bd/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=8cf521d80e9057211629e92aff059dc9770c20bd", "patch": "@@ -43,7 +43,7 @@ impl DropOrderCollector {\n         }\n \n         if {\n-            if self.option_loud_drop(7).is_some() && self.option_loud_drop(6).is_some() {\n+            if self.option_loud_drop(6).is_some() && self.option_loud_drop(7).is_some() {\n                 self.loud_drop(8);\n                 true\n             } else {\n@@ -118,17 +118,71 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn and_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(3).is_some() // 3\n+            && self.option_loud_drop(4).is_some() // 4\n+            && self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_some() // 1\n+            && self.option_loud_drop(8).is_some() // 2\n+            && self.option_loud_drop(9).is_some(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_some() // 1\n+            && (self.option_loud_drop(12).is_some() // 2\n+            && self.option_loud_drop(13).is_some() // 3\n+            && self.option_loud_drop(14).is_some()) // 4\n+            && self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n+    fn or_chain(&self) {\n+        // issue-103107\n+        if self.option_loud_drop(1).is_none() // 1\n+            || self.option_loud_drop(2).is_none() // 2\n+            || self.option_loud_drop(3).is_none() // 3\n+            || self.option_loud_drop(4).is_none() // 4\n+            || self.option_loud_drop(5).is_some() // 5\n+        {\n+            self.print(6); // 6\n+        }\n+\n+        let _ = self.option_loud_drop(7).is_none() // 1\n+            || self.option_loud_drop(8).is_none() // 2\n+            || self.option_loud_drop(9).is_none(); // 3\n+        self.print(10); // 4\n+\n+        // Test associativity\n+        if self.option_loud_drop(11).is_none() // 1\n+            || (self.option_loud_drop(12).is_none() // 2\n+            || self.option_loud_drop(13).is_none() // 3\n+            || self.option_loud_drop(14).is_none()) // 4\n+            || self.option_loud_drop(15).is_some() // 5\n+        {\n+            self.print(16); // 6\n+        }\n+    }\n+\n     fn let_chain(&self) {\n         // take the \"then\" branch\n-        if self.option_loud_drop(2).is_some() // 2\n-            && self.option_loud_drop(1).is_some() // 1\n+        if self.option_loud_drop(1).is_some() // 1\n+            && self.option_loud_drop(2).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(4) { // 4\n             self.print(3); // 3\n         }\n \n         // take the \"else\" branch\n-        if self.option_loud_drop(6).is_some() // 2\n-            && self.option_loud_drop(5).is_some() // 1\n+        if self.option_loud_drop(5).is_some() // 1\n+            && self.option_loud_drop(6).is_some() // 2\n             && let None = self.option_loud_drop(8) { // 4\n             unreachable!();\n         } else {\n@@ -152,8 +206,8 @@ impl DropOrderCollector {\n             }\n \n         // let exprs last\n-        if self.option_loud_drop(20).is_some() // 2\n-            && self.option_loud_drop(19).is_some() // 1\n+        if self.option_loud_drop(19).is_some() // 1\n+            && self.option_loud_drop(20).is_some() // 2\n             && let Some(_d) = self.option_loud_drop(23) // 5\n             && let Some(_e) = self.option_loud_drop(22) { // 4\n                 self.print(21); // 3\n@@ -187,6 +241,16 @@ fn main() {\n     collector.if_();\n     collector.assert_sorted();\n \n+    println!(\"-- and chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.and_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- or chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.or_chain();\n+    collector.assert_sorted();\n+\n     println!(\"-- if let --\");\n     let collector = DropOrderCollector::default();\n     collector.if_let();"}, {"sha": "5f447595662edd74aa749b1f5c44c73eebb139b2", "filename": "src/test/ui/drop/issue-103107.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8cf521d80e9057211629e92aff059dc9770c20bd/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf521d80e9057211629e92aff059dc9770c20bd/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-103107.rs?ref=8cf521d80e9057211629e92aff059dc9770c20bd", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// compile-flags: -Z validate-mir\n+\n+struct Foo<'a>(&'a mut u32);\n+\n+impl<'a> Drop for Foo<'a> {\n+    fn drop(&mut self) {\n+        *self.0 = 0;\n+    }\n+}\n+\n+fn and() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if true && *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 0 && ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn or() {\n+    let mut foo = 0;\n+    // This used to compile also before the fix\n+    if false || *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    // This used to fail before the fix\n+    if *Foo(&mut foo).0 == 1 || ({ foo = 0; true}) {}\n+\n+    println!(\"{foo}\");\n+}\n+\n+fn main() {\n+    and();\n+    or();\n+}"}]}