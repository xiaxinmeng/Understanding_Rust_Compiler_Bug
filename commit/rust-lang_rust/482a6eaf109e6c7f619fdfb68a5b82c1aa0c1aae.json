{"sha": "482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "node_id": "C_kwDOAAsO6NoAKDQ4MmE2ZWFmMTA5ZTZjN2Y2MTlmZGZiNjhhNWI4MmMxYWEwYzFhYWU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-14T11:39:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-14T11:39:14Z"}, "message": "Rollup merge of #100026 - WaffleLapkin:array-chunks, r=scottmcm\n\nAdd `Iterator::array_chunks` (take N+1)\n\nA revival of https://github.com/rust-lang/rust/pull/92393.\n\nr? `@Mark-Simulacrum`\ncc `@rossmacarthur` `@scottmcm` `@the8472`\n\nI've tried to address most of the review comments on the previous attempt. The only thing I didn't address is `try_fold` implementation, I've left the \"custom\" one for now, not sure what exactly should it use.", "tree": {"sha": "3fcb35867f11273c11c1c87b149171b637bc6e89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fcb35867f11273c11c1c87b149171b637bc6e89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi+N7iCRBK7hj4Ov3rIwAAZoMIAIG7o8guoNvgb/OnhJ6NQjp2\nrztv6ck/Cbb+eJ8swM84USAgMJVf0XXWMrbWPGSvVyFgo1C5EXeUnTakRojpWuR6\n1n6NlC/9+SC0xmk4lHI/9W3oNwWQ3gB3Ft0wAqhnSV2UXf/z1XXgVWP5YWGuRYCl\n2P9ZrFkkRJj6p0lx+yTQTu8Uh+KmMA6RwJfGk4wukoj/mwf9xHQfsVoBGgtzOEc+\nOUU/U9f3AC9jADTUliTI1+ZsmWNIglQ+iymQ1oQeczp4TsHTzLm9UAlsc19Y5foY\nBcSVMPWGH+qyia3QImL+8EJTFVSoUxz+lPw2bH2l5Cd18bz3ENjn0CaGeGPxqi8=\n=GjjY\n-----END PGP SIGNATURE-----\n", "payload": "tree 3fcb35867f11273c11c1c87b149171b637bc6e89\nparent 92344e369ba068536e9b8a08fc8c7c5c652c8998\nparent 5fbcde1b55c09421f43a7d6cfe09103d064ed2db\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1660477154 +0530\ncommitter GitHub <noreply@github.com> 1660477154 +0530\n\nRollup merge of #100026 - WaffleLapkin:array-chunks, r=scottmcm\n\nAdd `Iterator::array_chunks` (take N+1)\n\nA revival of https://github.com/rust-lang/rust/pull/92393.\n\nr? `@Mark-Simulacrum`\ncc `@rossmacarthur` `@scottmcm` `@the8472`\n\nI've tried to address most of the review comments on the previous attempt. The only thing I didn't address is `try_fold` implementation, I've left the \"custom\" one for now, not sure what exactly should it use.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "html_url": "https://github.com/rust-lang/rust/commit/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92344e369ba068536e9b8a08fc8c7c5c652c8998", "url": "https://api.github.com/repos/rust-lang/rust/commits/92344e369ba068536e9b8a08fc8c7c5c652c8998", "html_url": "https://github.com/rust-lang/rust/commit/92344e369ba068536e9b8a08fc8c7c5c652c8998"}, {"sha": "5fbcde1b55c09421f43a7d6cfe09103d064ed2db", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbcde1b55c09421f43a7d6cfe09103d064ed2db", "html_url": "https://github.com/rust-lang/rust/commit/5fbcde1b55c09421f43a7d6cfe09103d064ed2db"}], "stats": {"total": 436, "additions": 435, "deletions": 1}, "files": [{"sha": "9b479a9f8adfb9d478610e7ca03cfa7b045d10c5", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -0,0 +1,182 @@\n+use crate::array;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n+\n+/// An iterator over `N` elements of the iterator at a time.\n+///\n+/// The chunks do not overlap. If `N` does not divide the length of the\n+/// iterator, then the last up to `N-1` elements will be omitted.\n+///\n+/// This `struct` is created by the [`array_chunks`][Iterator::array_chunks]\n+/// method on [`Iterator`]. See its documentation for more.\n+#[derive(Debug, Clone)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub struct ArrayChunks<I: Iterator, const N: usize> {\n+    iter: I,\n+    remainder: Option<array::IntoIter<I::Item, N>>,\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[track_caller]\n+    pub(in crate::iter) fn new(iter: I) -> Self {\n+        assert!(N != 0, \"chunk size must be non-zero\");\n+        Self { iter, remainder: None }\n+    }\n+\n+    /// Returns an iterator over the remaining elements of the original iterator\n+    /// that are not going to be returned by this iterator. The returned\n+    /// iterator will yield at most `N-1` elements.\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+    #[inline]\n+    pub fn into_remainder(self) -> Option<array::IntoIter<I::Item, N>> {\n+        self.remainder\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> Iterator for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    type Item = [I::Item; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.try_for_each(ControlFlow::Break).break_value()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        (lower / N, upper.map(|n| n / N))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count() / N\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let mut acc = init;\n+        loop {\n+            match self.iter.next_chunk() {\n+                Ok(chunk) => acc = f(acc, chunk)?,\n+                Err(remainder) => {\n+                    // Make sure to not override `self.remainder` with an empty array\n+                    // when `next` is called after `ArrayChunks` exhaustion.\n+                    self.remainder.get_or_insert(remainder);\n+\n+                    break try { acc };\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_fold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> DoubleEndedIterator for ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.try_rfold((), |(), x| ControlFlow::Break(x)).break_value()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        // We are iterating from the back we need to first handle the remainder.\n+        self.next_back_remainder();\n+\n+        let mut acc = init;\n+        let mut iter = ByRefSized(&mut self.iter).rev();\n+\n+        // NB remainder is handled by `next_back_remainder`, so\n+        // `next_chunk` can't return `Err` with non-empty remainder\n+        // (assuming correct `I as ExactSizeIterator` impl).\n+        while let Ok(mut chunk) = iter.next_chunk() {\n+            // FIXME: do not do double reverse\n+            //        (we could instead add `next_chunk_back` for example)\n+            chunk.reverse();\n+            acc = f(acc, chunk)?\n+        }\n+\n+        try { acc }\n+    }\n+\n+    fn rfold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_rfold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+    }\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    /// Updates `self.remainder` such that `self.iter.len` is divisible by `N`.\n+    fn next_back_remainder(&mut self) {\n+        // Make sure to not override `self.remainder` with an empty array\n+        // when `next_back` is called after `ArrayChunks` exhaustion.\n+        if self.remainder.is_some() {\n+            return;\n+        }\n+\n+        // We use the `ExactSizeIterator` implementation of the underlying\n+        // iterator to know how many remaining elements there are.\n+        let rem = self.iter.len() % N;\n+\n+        // Take the last `rem` elements out of `self.iter`.\n+        let mut remainder =\n+            // SAFETY: `unwrap_err` always succeeds because x % N < N for all x.\n+            unsafe { self.iter.by_ref().rev().take(rem).next_chunk().unwrap_err_unchecked() };\n+\n+        // We used `.rev()` above, so we need to re-reverse the reminder\n+        remainder.as_mut_slice().reverse();\n+        self.remainder = Some(remainder);\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> FusedIterator for ArrayChunks<I, N> where I: FusedIterator {}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+impl<I, const N: usize> ExactSizeIterator for ArrayChunks<I, N>\n+where\n+    I: ExactSizeIterator,\n+{\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.iter.len() / N\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.iter.len() < N\n+    }\n+}"}, {"sha": "bf4fabad32a373e333c4f06443a3df6f0d5f0c1c", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -1,6 +1,7 @@\n use crate::iter::{InPlaceIterable, Iterator};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, NeverShortCircuit, Residual, Try};\n \n+mod array_chunks;\n mod by_ref_sized;\n mod chain;\n mod cloned;\n@@ -32,6 +33,9 @@ pub use self::{\n     scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n };\n \n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub use self::array_chunks::ArrayChunks;\n+\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::by_ref_sized::ByRefSized;\n "}, {"sha": "9514466bd0c050d9969a64a6d161fdd9310fd498", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -398,6 +398,8 @@ pub use self::traits::{\n \n #[stable(feature = \"iter_zip\", since = \"1.59.0\")]\n pub use self::adapters::zip;\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+pub use self::adapters::ArrayChunks;\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::adapters::ByRefSized;\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]"}, {"sha": "b2d08f4b0f67bf456692e0c34fdf954ef357c1c0", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -5,7 +5,7 @@ use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n use super::super::try_process;\n use super::super::ByRefSized;\n use super::super::TrustedRandomAccessNoCoerce;\n-use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n+use super::super::{ArrayChunks, Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n use super::super::{\n@@ -3316,6 +3316,49 @@ pub trait Iterator {\n         Cycle::new(self)\n     }\n \n+    /// Returns an iterator over `N` elements of the iterator at a time.\n+    ///\n+    /// The chunks do not overlap. If `N` does not divide the length of the\n+    /// iterator, then the last up to `N-1` elements will be omitted and can be\n+    /// retrieved from the [`.into_remainder()`][ArrayChunks::into_remainder]\n+    /// function of the iterator.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let mut iter = \"lorem\".chars().array_chunks();\n+    /// assert_eq!(iter.next(), Some(['l', 'o']));\n+    /// assert_eq!(iter.next(), Some(['r', 'e']));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.into_remainder().unwrap().as_slice(), &['m']);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let data = [1, 1, 2, -2, 6, 0, 3, 1];\n+    /// //          ^-----^  ^------^\n+    /// for [x, y, z] in data.iter().array_chunks() {\n+    ///     assert_eq!(x + y + z, 4);\n+    /// }\n+    /// ```\n+    #[track_caller]\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n+    fn array_chunks<const N: usize>(self) -> ArrayChunks<Self, N>\n+    where\n+        Self: Sized,\n+    {\n+        ArrayChunks::new(self)\n+    }\n+\n     /// Sums the elements of an iterator.\n     ///\n     /// Takes each element, adds them together, and returns the result."}, {"sha": "4e9d89e1e580f688c0d1d95afe636c8cf48a1bff", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -0,0 +1,179 @@\n+use core::cell::Cell;\n+use core::iter::{self, Iterator};\n+\n+use super::*;\n+\n+#[test]\n+fn test_iterator_array_chunks_infer() {\n+    let xs = [1, 1, 2, -2, 6, 0, 3, 1];\n+    for [a, b, c] in xs.iter().copied().array_chunks() {\n+        assert_eq!(a + b + c, 4);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_clone_and_drop() {\n+    let count = Cell::new(0);\n+    let mut it = (0..5).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    assert_eq!(it.by_ref().count(), 1);\n+    assert_eq!(count.get(), 3);\n+    let mut it2 = it.clone();\n+    assert_eq!(count.get(), 3);\n+    assert_eq!(it.into_remainder().unwrap().len(), 2);\n+    assert_eq!(count.get(), 5);\n+    assert!(it2.next().is_none());\n+    assert_eq!(it2.into_remainder().unwrap().len(), 2);\n+    assert_eq!(count.get(), 7);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+    assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_size_hint() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.size_hint(), (6, Some(6)));\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+\n+    let it = (1..).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (usize::MAX / 2, None));\n+\n+    let it = (1..).filter(|x| x % 2 != 0).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (0, None));\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_count() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.count(), 6);\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.count(), 2);\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = (0..6).filter(|x| x % 2 == 0).array_chunks::<2>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = iter::empty::<i32>().array_chunks::<2>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = [(); usize::MAX].iter().array_chunks::<2>();\n+    assert_eq!(it.count(), usize::MAX / 2);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_next_and_next_back() {\n+    let mut it = (0..11).array_chunks::<3>();\n+    assert_eq!(it.next(), Some([0, 1, 2]));\n+    assert_eq!(it.next_back(), Some([6, 7, 8]));\n+    assert_eq!(it.next(), Some([3, 4, 5]));\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rev_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    {\n+        let mut it = it.by_ref().rev();\n+        assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+        assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+        assert_eq!(it.next(), None);\n+        assert_eq!(it.next(), None);\n+    }\n+    assert_eq!(it.into_remainder().unwrap().as_slice(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_fold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.by_ref().try_fold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.by_ref().try_fold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 9);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_fold() {\n+    let result = (1..11).array_chunks::<3>().fold(0, |acc, [a, b, c]| {\n+        assert_eq!(acc + 1, a);\n+        assert_eq!(acc + 2, b);\n+        assert_eq!(acc + 3, c);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_rfold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.try_rfold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.try_rfold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rfold() {\n+    let result = (1..11).array_chunks::<3>().rfold(0, |acc, [a, b, c]| {\n+        assert_eq!(10 - (acc + 1), c);\n+        assert_eq!(10 - (acc + 2), b);\n+        assert_eq!(10 - (acc + 3), a);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().rfold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}"}, {"sha": "96539c0c394e2e683720fc0d8b44aa5e688e40b0", "filename": "library/core/tests/iter/adapters/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -1,3 +1,4 @@\n+mod array_chunks;\n mod chain;\n mod cloned;\n mod copied;\n@@ -183,3 +184,25 @@ impl Clone for CountClone {\n         ret\n     }\n }\n+\n+#[derive(Debug, Clone)]\n+struct CountDrop<'a> {\n+    dropped: bool,\n+    count: &'a Cell<usize>,\n+}\n+\n+impl<'a> CountDrop<'a> {\n+    pub fn new(count: &'a Cell<usize>) -> Self {\n+        Self { dropped: false, count }\n+    }\n+}\n+\n+impl Drop for CountDrop<'_> {\n+    fn drop(&mut self) {\n+        if self.dropped {\n+            panic!(\"double drop\");\n+        }\n+        self.dropped = true;\n+        self.count.set(self.count.get() + 1);\n+    }\n+}"}, {"sha": "09f1500f564cf6ce1fb9e3c54b85e2788c39c939", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=482a6eaf109e6c7f619fdfb68a5b82c1aa0c1aae", "patch": "@@ -62,6 +62,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_log)]\n #![feature(iter_advance_by)]\n+#![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]"}]}