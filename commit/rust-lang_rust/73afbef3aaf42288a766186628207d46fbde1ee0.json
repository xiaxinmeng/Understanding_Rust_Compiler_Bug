{"sha": "73afbef3aaf42288a766186628207d46fbde1ee0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYWZiZWYzYWFmNDIyODhhNzY2MTg2NjI4MjA3ZDQ2ZmJkZTFlZTA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-15T05:46:44Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-15T22:03:54Z"}, "message": "Misc tidy ups in resolve", "tree": {"sha": "caea65492e72d89476241a9db7dcb6183c88509e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caea65492e72d89476241a9db7dcb6183c88509e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73afbef3aaf42288a766186628207d46fbde1ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73afbef3aaf42288a766186628207d46fbde1ee0", "html_url": "https://github.com/rust-lang/rust/commit/73afbef3aaf42288a766186628207d46fbde1ee0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73afbef3aaf42288a766186628207d46fbde1ee0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "542e2bb3910f8860d49b4b40bcd78d9c74e733ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/542e2bb3910f8860d49b4b40bcd78d9c74e733ff", "html_url": "https://github.com/rust-lang/rust/commit/542e2bb3910f8860d49b4b40bcd78d9c74e733ff"}], "stats": {"total": 119, "additions": 56, "deletions": 63}, "files": [{"sha": "5f7a0e63337f476ec46bbaf53411c506395871ca", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=73afbef3aaf42288a766186628207d46fbde1ee0", "patch": "@@ -371,8 +371,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                for &crate_id in self.session.cstore.find_extern_mod_stmt_cnum(item.id).iter() {\n                     let def_id = DefId { krate: crate_id, node: 0 };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent.downgrade(), name);\n@@ -400,7 +399,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(def_id),\n                                             NormalModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n \n                 name_bindings.get_module()\n@@ -432,8 +431,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules,\n-                                   sp);\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n                 name_bindings.define_type(DefTy(local_def(item.id), false), sp,\n                                           modifiers);\n@@ -517,7 +515,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n@@ -636,8 +634,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {:?}\",\n-               vis);\n+                external crate) building external def {}, priv {:?}\",\n+               final_ident, vis);\n         let is_public = vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n@@ -667,7 +665,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n               Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n-                        {}\", final_ident);\n+                        {} {}\", final_ident, is_public);\n                 let parent_link = self.get_parent_link(new_parent, name);\n \n                 child_name_bindings.define_module(parent_link,\n@@ -904,18 +902,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         match subclass {\n             SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: {}::{}\",\n-                       self.names_to_string(&module_.imports.borrow().last().unwrap().\n-                                                             module_path),\n+                debug!(\"(building import directive) building import directive: {}::{}\",\n+                       self.names_to_string(&module_.imports.borrow().last().unwrap().module_path),\n                        token::get_name(target));\n \n-                let mut import_resolutions = module_.import_resolutions\n-                                                    .borrow_mut();\n+                let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {\n                     Some(resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n-                                reference\");\n+                        debug!(\"(building import directive) bumping reference\");\n                         resolution.outstanding_references += 1;\n \n                         // the source of this name is different now"}, {"sha": "605385754044d45f0a0b7ceac39798af7eaa76d2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=73afbef3aaf42288a766186628207d46fbde1ee0", "patch": "@@ -428,14 +428,16 @@ impl Target {\n #[derive(Debug)]\n struct ImportResolution {\n     /// Whether this resolution came from a `use` or a `pub use`. Note that this\n-    /// should *not* be used whenever resolution is being performed, this is\n-    /// only looked at for glob imports statements currently. Privacy testing\n-    /// occurs during a later phase of compilation.\n+    /// should *not* be used whenever resolution is being performed. Privacy\n+    /// testing occurs during a later phase of compilation.\n     is_public: bool,\n \n     // The number of outstanding references to this name. When this reaches\n     // zero, outside modules can count on the targets being correct. Before\n     // then, all bets are off; future imports could override this name.\n+    // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n+    // way outstanding_references is > 1 in a legal program is if the name is\n+    // used in both namespaces.\n     outstanding_references: uint,\n \n     /// The value that this `use` directive names, if there is one.\n@@ -1144,8 +1146,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n-                                        subclass: ImportDirectiveSubclass)\n-                                        -> String {\n+                                           subclass: ImportDirectiveSubclass)\n+                                           -> String {\n         match subclass {\n             SingleImport(_, source) => {\n                 token::get_name(source).to_string()\n@@ -1155,9 +1157,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn import_path_to_string(&mut self,\n-                          names: &[Name],\n-                          subclass: ImportDirectiveSubclass)\n-                          -> String {\n+                             names: &[Name],\n+                             subclass: ImportDirectiveSubclass)\n+                             -> String {\n         if names.is_empty() {\n             self.import_directive_subclass_to_string(subclass)\n         } else {\n@@ -1238,7 +1240,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match import_directive.subclass {\n                     SingleImport(target, source) => {\n                         resolution_result =\n-                            self.resolve_single_import(&*module_,\n+                            self.resolve_single_import(&module_,\n                                                        containing_module,\n                                                        target,\n                                                        source,\n@@ -1247,7 +1249,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     GlobImport => {\n                         resolution_result =\n-                            self.resolve_glob_import(&*module_,\n+                            self.resolve_glob_import(&module_,\n                                                      containing_module,\n                                                      import_directive,\n                                                      lp);\n@@ -1270,7 +1272,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Decrement the count of unresolved globs if necessary. But only if\n         // the resolution result is indeterminate -- otherwise we'll stop\n         // processing imports here. (See the loop in\n-        // resolve_imports_for_module.)\n+        // resolve_imports_for_module).\n \n         if !resolution_result.indeterminate() {\n             match import_directive.subclass {\n@@ -1301,16 +1303,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_single_import(&mut self,\n                              module_: &Module,\n-                             containing_module: Rc<Module>,\n+                             target_module: Rc<Module>,\n                              target: Name,\n                              source: Name,\n                              directive: &ImportDirective,\n                              lp: LastPrivate)\n-                                 -> ResolveResult<()> {\n+                             -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n                token::get_name(target),\n-               self.module_to_string(&*containing_module),\n+               self.module_to_string(&*target_module),\n                token::get_name(source),\n                self.module_to_string(module_),\n                directive.id,\n@@ -1363,14 +1365,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // containing module, bail out. We don't know enough to be\n                 // able to resolve this import.\n \n-                if containing_module.glob_count.get() > 0 {\n+                if target_module.glob_count.get() > 0 {\n                     debug!(\"(resolving single import) unresolved glob; \\\n                             bailing out\");\n                     return Indeterminate;\n                 }\n \n                 // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().get(&source) {\n+                match target_module.import_resolutions.borrow().get(&source) {\n                     None => {\n                         debug!(\"(resolving single import) no import\");\n                         // The containing module definitely doesn't have an\n@@ -1400,8 +1402,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return UnboundResult;\n                             }\n \n-                            match import_resolution.\n-                                    target_for_namespace(namespace) {\n+                            match import_resolution.target_for_namespace(namespace) {\n                                 None => {\n                                     return UnboundResult;\n                                 }\n@@ -1446,7 +1447,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     }\n                     Some(_) => {\n-                        // If containing_module is the same module whose import we are resolving\n+                        // If target_module is the same module whose import we are resolving\n                         // and there it has an unresolved import with the same name as `source`,\n                         // then the user is actually trying to import an item that is declared\n                         // in the same scope\n@@ -1458,7 +1459,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // In this case we continue as if we resolved the import and let the\n                         // check_for_conflicts_between_imports_and_items call below handle\n                         // the conflict\n-                        match (module_.def_id.get(),  containing_module.def_id.get()) {\n+                        match (module_.def_id.get(),  target_module.def_id.get()) {\n                             (Some(id1), Some(id2)) if id1 == id2  => {\n                                 if value_result.is_unknown() {\n                                     value_result = UnboundResult;\n@@ -1479,29 +1480,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        // If we didn't find a result in the type namespace, search the\n-        // external modules.\n         let mut value_used_public = false;\n         let mut type_used_public = false;\n+\n+        // If we didn't find a result in the type namespace, search the\n+        // external modules.\n         match type_result {\n             BoundResult(..) => {}\n             _ => {\n-                match containing_module.external_module_children.borrow_mut()\n-                                       .get(&source).cloned() {\n+                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n                     None => {} // Continue.\n                     Some(module) => {\n-                        debug!(\"(resolving single import) found external \\\n-                                module\");\n+                        debug!(\"(resolving single import) found external module\");\n                         // track the module as used.\n                         match module.def_id.get() {\n                             Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n                             _ => {}\n                         }\n                         let name_bindings =\n-                            Rc::new(Resolver::create_name_bindings_from_module(\n-                                module));\n-                        type_result = BoundResult(containing_module.clone(),\n-                                                  name_bindings);\n+                            Rc::new(Resolver::create_name_bindings_from_module(module));\n+                        type_result = BoundResult(target_module.clone(), name_bindings);\n                         type_used_public = true;\n                     }\n                 }\n@@ -1511,6 +1509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let import_resolution = &mut (*import_resolutions)[target];\n+\n         {\n             let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n                 let namespace_name = match namespace {\n@@ -1561,7 +1560,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n                               token::get_name(source),\n-                              self.module_to_string(&*containing_module));\n+                              self.module_to_string(&target_module));\n             return Failed(Some((directive.span, msg)));\n         }\n         let value_used_public = value_used_reexport || value_used_public;\n@@ -1570,7 +1569,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n-        // record what this import resolves to for later uses in documentation,\n+        // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n@@ -1610,11 +1609,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid). containing_module is the module we are\n+    // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n                            module_: &Module,\n-                           containing_module: Rc<Module>,\n+                           target_module: Rc<Module>,\n                            import_directive: &ImportDirective,\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n@@ -1628,16 +1627,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n-        if !(*containing_module).all_imports_resolved() {\n+        if !(*target_module).all_imports_resolved() {\n             debug!(\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\");\n             return Indeterminate;\n         }\n \n-        assert_eq!(containing_module.glob_count.get(), 0);\n+        assert_eq!(target_module.glob_count.get(), 0);\n \n         // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions.borrow();\n+        let import_resolutions = target_module.import_resolutions.borrow();\n         for (ident, target_import_resolution) in &*import_resolutions {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n@@ -1697,30 +1696,30 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add all children from the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &target_module);\n \n-        for (&name, name_bindings) in &*containing_module.children.borrow() {\n+        for (&name, name_bindings) in &*target_module.children.borrow() {\n             self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n+                                         target_module.clone(),\n                                          import_directive,\n                                          name,\n                                          name_bindings.clone());\n \n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in &*containing_module.external_module_children.borrow() {\n+        for (&name, module) in &*target_module.external_module_children.borrow() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n+                                         target_module.clone(),\n                                          import_directive,\n                                          name,\n                                          name_bindings);\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = containing_module.def_id.get() {\n+        if let Some(did) = target_module.def_id.get() {\n             self.def_map.borrow_mut().insert(id, PathResolution {\n                 base_def: DefMod(did),\n                 last_private: lp,"}, {"sha": "c634035bbf4c4c0dbdbcd9d152bd9ba8f373267e", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73afbef3aaf42288a766186628207d46fbde1ee0/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=73afbef3aaf42288a766186628207d46fbde1ee0", "patch": "@@ -133,13 +133,13 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn add_exports_for_module(&mut self,\n                               exports: &mut Vec<Export>,\n                               module_: &Module) {\n-        for (name, importresolution) in &*module_.import_resolutions.borrow() {\n-            if !importresolution.is_public {\n+        for (name, import_resolution) in &*module_.import_resolutions.borrow() {\n+            if !import_resolution.is_public {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n-                match importresolution.target_for_namespace(ns) {\n+                match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n                                token::get_name(*name));"}]}