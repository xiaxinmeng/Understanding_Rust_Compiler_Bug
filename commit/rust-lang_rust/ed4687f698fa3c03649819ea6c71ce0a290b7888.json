{"sha": "ed4687f698fa3c03649819ea6c71ce0a290b7888", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDY4N2Y2OThmYTNjMDM2NDk4MTllYTZjNzFjZTBhMjkwYjc4ODg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-05T22:07:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-05T22:07:35Z"}, "message": "Merge #5639\n\n5639: SSR: Allow `self` in patterns. r=jonas-schievink a=davidlattimore\n\nIt's now consistent with other variables in that if the pattern references self, only the `self` in scope where the rule is invoked will be accepted. Since `self` doesn't work the same as other paths, this is implemented by restricting the search to just the current function. Prior to this change (since path resolution was implemented), having self in a pattern would just result in no matches.\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "31d97b4bb7faf5bbc03c5e41d6314bd353e7704e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d97b4bb7faf5bbc03c5e41d6314bd353e7704e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed4687f698fa3c03649819ea6c71ce0a290b7888", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfKy2nCRBK7hj4Ov3rIwAAdHIIACSUvXrJMul2Y0PFk6Z12nPo\neCg61YsSgDS7i1vTSopgP34s8IeJ2oM5/5I4jSEajXd1JzpY1hctQv5odwANqLGs\n3+0wOwQJENcrI18gflu42qoLWlnmPJVnNH2uO5n1luuu+3zmksQOH1otY2pgVA/I\nRjBbbFt0SzpFUV+e6w+IzaUdBkutBTjvUPg7l8np7IFGdLK7kVqBUC8CN9fatUGj\ng1QOvUmQ8SpdxGvYvogO8DjwSW1jdO+c27iVjZeVTDkilP44IdJHBXv91P2VeCbU\nd2/C/ljGTvPRveJd20rA6B7UXdKIYt9gKupN1Z5W16vDHisKNpzHU0TiC7/IGYo=\n=spIL\n-----END PGP SIGNATURE-----\n", "payload": "tree 31d97b4bb7faf5bbc03c5e41d6314bd353e7704e\nparent 5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf\nparent 3eea41a68ca2de28dca35b6e713cbb36aa09f0c8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596665255 +0000\ncommitter GitHub <noreply@github.com> 1596665255 +0000\n\nMerge #5639\n\n5639: SSR: Allow `self` in patterns. r=jonas-schievink a=davidlattimore\n\nIt's now consistent with other variables in that if the pattern references self, only the `self` in scope where the rule is invoked will be accepted. Since `self` doesn't work the same as other paths, this is implemented by restricting the search to just the current function. Prior to this change (since path resolution was implemented), having self in a pattern would just result in no matches.\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed4687f698fa3c03649819ea6c71ce0a290b7888", "html_url": "https://github.com/rust-lang/rust/commit/ed4687f698fa3c03649819ea6c71ce0a290b7888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed4687f698fa3c03649819ea6c71ce0a290b7888/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "html_url": "https://github.com/rust-lang/rust/commit/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf"}, {"sha": "3eea41a68ca2de28dca35b6e713cbb36aa09f0c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eea41a68ca2de28dca35b6e713cbb36aa09f0c8", "html_url": "https://github.com/rust-lang/rust/commit/3eea41a68ca2de28dca35b6e713cbb36aa09f0c8"}], "stats": {"total": 74, "additions": 68, "deletions": 6}, "files": [{"sha": "c780b460a72ffffe7c006392f79ff80d331cca49", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=ed4687f698fa3c03649819ea6c71ce0a290b7888", "patch": "@@ -66,12 +66,7 @@ impl<'db> MatchFinder<'db> {\n         restrict_ranges.retain(|range| !range.range.is_empty());\n         let sema = Semantics::new(db);\n         let resolution_scope = resolving::ResolutionScope::new(&sema, lookup_context);\n-        MatchFinder {\n-            sema: Semantics::new(db),\n-            rules: Vec::new(),\n-            resolution_scope,\n-            restrict_ranges,\n-        }\n+        MatchFinder { sema, rules: Vec::new(), resolution_scope, restrict_ranges }\n     }\n \n     /// Constructs an instance using the start of the first file in `db` as the lookup context."}, {"sha": "df60048eb2e6e0a41acb8cee0d83fd42aad47d55", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=ed4687f698fa3c03649819ea6c71ce0a290b7888", "patch": "@@ -11,6 +11,7 @@ use test_utils::mark;\n pub(crate) struct ResolutionScope<'db> {\n     scope: hir::SemanticsScope<'db>,\n     hygiene: hir::Hygiene,\n+    node: SyntaxNode,\n }\n \n pub(crate) struct ResolvedRule {\n@@ -25,6 +26,7 @@ pub(crate) struct ResolvedPattern {\n     // Paths in `node` that we've resolved.\n     pub(crate) resolved_paths: FxHashMap<SyntaxNode, ResolvedPath>,\n     pub(crate) ufcs_function_calls: FxHashMap<SyntaxNode, hir::Function>,\n+    pub(crate) contains_self: bool,\n }\n \n pub(crate) struct ResolvedPath {\n@@ -68,6 +70,7 @@ struct Resolver<'a, 'db> {\n \n impl Resolver<'_, '_> {\n     fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n+        use ra_syntax::{SyntaxElement, T};\n         let mut resolved_paths = FxHashMap::default();\n         self.resolve(pattern.clone(), 0, &mut resolved_paths)?;\n         let ufcs_function_calls = resolved_paths\n@@ -85,11 +88,17 @@ impl Resolver<'_, '_> {\n                 None\n             })\n             .collect();\n+        let contains_self =\n+            pattern.descendants_with_tokens().any(|node_or_token| match node_or_token {\n+                SyntaxElement::Token(t) => t.kind() == T![self],\n+                _ => false,\n+            });\n         Ok(ResolvedPattern {\n             node: pattern,\n             resolved_paths,\n             placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n             ufcs_function_calls,\n+            contains_self,\n         })\n     }\n \n@@ -101,6 +110,10 @@ impl Resolver<'_, '_> {\n     ) -> Result<(), SsrError> {\n         use ra_syntax::ast::AstNode;\n         if let Some(path) = ast::Path::cast(node.clone()) {\n+            if is_self(&path) {\n+                // Self cannot be resolved like other paths.\n+                return Ok(());\n+            }\n             // Check if this is an appropriate place in the path to resolve. If the path is\n             // something like `a::B::<i32>::c` then we want to resolve `a::B`. If the path contains\n             // a placeholder. e.g. `a::$b::c` then we want to resolve `a`.\n@@ -157,9 +170,15 @@ impl<'db> ResolutionScope<'db> {\n         ResolutionScope {\n             scope,\n             hygiene: hir::Hygiene::new(sema.db, resolve_context.file_id.into()),\n+            node,\n         }\n     }\n \n+    /// Returns the function in which SSR was invoked, if any.\n+    pub(crate) fn current_function(&self) -> Option<SyntaxNode> {\n+        self.node.ancestors().find(|node| node.kind() == SyntaxKind::FN).map(|node| node.clone())\n+    }\n+\n     fn resolve_path(&self, path: &ast::Path) -> Option<hir::PathResolution> {\n         let hir_path = hir::Path::from_src(path.clone(), &self.hygiene)?;\n         // First try resolving the whole path. This will work for things like\n@@ -186,6 +205,10 @@ impl<'db> ResolutionScope<'db> {\n     }\n }\n \n+fn is_self(path: &ast::Path) -> bool {\n+    path.segment().map(|segment| segment.self_token().is_some()).unwrap_or(false)\n+}\n+\n /// Returns a suitable node for resolving paths in the current scope. If we create a scope based on\n /// a statement node, then we can't resolve local variables that were defined in the current scope\n /// (only in parent scopes). So we find another node, ideally a child of the statement where local"}, {"sha": "85ffa2ac23fc101b311b19c5d8ea86ce61f698fb", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=ed4687f698fa3c03649819ea6c71ce0a290b7888", "patch": "@@ -33,6 +33,15 @@ impl<'db> MatchFinder<'db> {\n         usage_cache: &mut UsageCache,\n         matches_out: &mut Vec<Match>,\n     ) {\n+        if rule.pattern.contains_self {\n+            // If the pattern contains `self` we restrict the scope of the search to just the\n+            // current method. No other method can reference the same `self`. This makes the\n+            // behavior of `self` consistent with other variables.\n+            if let Some(current_function) = self.resolution_scope.current_function() {\n+                self.slow_scan_node(&current_function, rule, &None, matches_out);\n+            }\n+            return;\n+        }\n         if pick_path_for_usages(&rule.pattern).is_none() {\n             self.slow_scan(rule, matches_out);\n             return;"}, {"sha": "d483640df1c4572dfb7ed80eb0617e40605d8102", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed4687f698fa3c03649819ea6c71ce0a290b7888/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=ed4687f698fa3c03649819ea6c71ce0a290b7888", "patch": "@@ -1044,3 +1044,38 @@ fn replace_nonpath_within_selection() {\n             }\"#]],\n     );\n }\n+\n+#[test]\n+fn replace_self() {\n+    // `foo(self)` occurs twice in the code, however only the first occurrence is the `self` that's\n+    // in scope where the rule is invoked.\n+    assert_ssr_transform(\n+        \"foo(self) ==>> bar(self)\",\n+        r#\"\n+        struct S1 {}\n+        fn foo(_: &S1) {}\n+        fn bar(_: &S1) {}\n+        impl S1 {\n+            fn f1(&self) {\n+                foo(self)<|>\n+            }\n+            fn f2(&self) {\n+                foo(self)\n+            }\n+        }\n+        \"#,\n+        expect![[r#\"\n+            struct S1 {}\n+            fn foo(_: &S1) {}\n+            fn bar(_: &S1) {}\n+            impl S1 {\n+                fn f1(&self) {\n+                    bar(self)\n+                }\n+                fn f2(&self) {\n+                    foo(self)\n+                }\n+            }\n+        \"#]],\n+    );\n+}"}]}