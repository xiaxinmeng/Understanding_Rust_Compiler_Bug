{"sha": "3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMWQzZTViZjhlMmYyODgxNDdmZDg3OWIzN2JjNWU2ZjhjNTUyOGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-19T01:18:45Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:23Z"}, "message": "librustc: Fix merge fallout.", "tree": {"sha": "691cc50bfb90eee27fcfa553d998a0fbddfc8115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691cc50bfb90eee27fcfa553d998a0fbddfc8115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "html_url": "https://github.com/rust-lang/rust/commit/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90d3da971148a471c5766b544dc4ba50a15e5b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/90d3da971148a471c5766b544dc4ba50a15e5b96", "html_url": "https://github.com/rust-lang/rust/commit/90d3da971148a471c5766b544dc4ba50a15e5b96"}], "stats": {"total": 412, "additions": 244, "deletions": 168}, "files": [{"sha": "7662a159ba49a3943e3c4ded2855a20896fc9018", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -30,46 +30,59 @@ pub mod rustrt {\n \n macro_rules! locked {\n     ($expr:expr) => {\n-        // FIXME #9105: can't use a static mutex in pure Rust yet.\n-        rustrt::rust_take_linenoise_lock();\n-        let x = $expr;\n-        rustrt::rust_drop_linenoise_lock();\n-        x\n+        {\n+            // FIXME #9105: can't use a static mutex in pure Rust yet.\n+            rustrt::rust_take_linenoise_lock();\n+            let x = $expr;\n+            rustrt::rust_drop_linenoise_lock();\n+            x\n+        }\n     }\n }\n \n /// Add a line to history\n pub fn add_history(line: &str) -> bool {\n     do line.with_c_str |buf| {\n-        (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n+        }\n     }\n }\n \n /// Set the maximum amount of lines stored\n pub fn set_history_max_len(len: int) -> bool {\n-    (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1 as c_int\n+    unsafe {\n+        (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1\n+            as c_int\n+    }\n }\n \n /// Save line history to a file\n pub fn save_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n         // 0 on success, -1 on failure\n-        (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n+        }\n     }\n }\n \n /// Load line history from a file\n pub fn load_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n         // 0 on success, -1 on failure\n-        (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n+        }\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n pub fn read(prompt: &str) -> Option<~str> {\n     do prompt.with_c_str |buf| {\n-        let line = locked!(rustrt::linenoise(buf));\n+        let line = unsafe {\n+            locked!(rustrt::linenoise(buf))\n+        };\n \n         if line.is_null() { None }\n         else {"}, {"sha": "91f6169b419f92e50cbfc2a3c362b4070f113c8e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 199, "deletions": 131, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -1086,6 +1086,36 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     return ptr_metadata;\n }\n \n+trait MemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription];\n+}\n+\n+struct StructMemberDescriptionFactory {\n+    fields: ~[ty::field],\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.fields.map |field| {\n+            let name = if field.ident.name == special_idents::unnamed_field.name {\n+                @\"\"\n+            } else {\n+                token::ident_to_str(&field.ident)\n+            };\n+\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, field.mt.ty),\n+                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                offset: ComputedMemberOffset,\n+            }\n+        }\n+    }\n+}\n+\n fn prepare_struct_metadata(cx: &mut CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n@@ -1114,22 +1144,10 @@ fn prepare_struct_metadata(cx: &mut CrateContext,\n         metadata_stub: struct_metadata_stub,\n         llvm_type: struct_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: |cx| {\n-            do fields.map |field| {\n-                let name = if field.ident.name == special_idents::unnamed_field.name {\n-                    @\"\"\n-                } else {\n-                    token::ident_to_str(&field.ident)\n-                };\n-\n-                MemberDescription {\n-                    name: name,\n-                    llvm_type: type_of::type_of(cx, field.mt.ty),\n-                    type_metadata: type_metadata(cx, field.mt.ty, span),\n-                    offset: ComputedMemberOffset,\n-                }\n-            }\n-        }\n+        member_description_factory: @StructMemberDescriptionFactory {\n+            fields: fields,\n+            span: span,\n+        } as @MemberDescriptionFactory,\n     }\n }\n \n@@ -1139,7 +1157,7 @@ enum RecursiveTypeDescription {\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n         file_metadata: DIFile,\n-        member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription],\n+        member_description_factory: @MemberDescriptionFactory,\n     },\n     FinalMetadata(DICompositeType)\n }\n@@ -1167,7 +1185,8 @@ impl RecursiveTypeDescription {\n                 debug_context(cx).created_types.insert(cache_id, metadata_stub);\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory(cx);\n+                let member_descriptions = member_description_factory.\n+                    create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n@@ -1182,6 +1201,25 @@ impl RecursiveTypeDescription {\n     }\n }\n \n+struct TupleMemberDescriptionFactory {\n+    component_types: ~[ty::t],\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.component_types.map |&component_type| {\n+            MemberDescription {\n+                name: @\"\",\n+                llvm_type: type_of::type_of(cx, component_type),\n+                type_metadata: type_metadata(cx, component_type, self.span),\n+                offset: ComputedMemberOffset,\n+            }\n+        }\n+    }\n+}\n+\n fn prepare_tuple_metadata(cx: &mut CrateContext,\n                           tuple_type: ty::t,\n                           component_types: &[ty::t],\n@@ -1192,8 +1230,6 @@ fn prepare_tuple_metadata(cx: &mut CrateContext,\n \n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n-    // Needs to be copied for closure below :(\n-    let component_types = component_types.to_owned();\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(tuple_type),\n@@ -1205,17 +1241,147 @@ fn prepare_tuple_metadata(cx: &mut CrateContext,\n                                           span),\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: |cx| {\n-            do component_types.map |&component_type| {\n+        member_description_factory: @TupleMemberDescriptionFactory {\n+            component_types: component_types.to_owned(),\n+            span: span,\n+        } as @MemberDescriptionFactory\n+    }\n+}\n+\n+struct GeneralMemberDescriptionFactory {\n+    type_rep: @adt::Repr,\n+    variants: @~[@ty::VariantInfo],\n+    discriminant_type_metadata: ValueRef,\n+    containing_scope: DIScope,\n+    file_metadata: DIFile,\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        // Capture type_rep, so we don't have to copy the struct_defs array\n+        let struct_defs = match *self.type_rep {\n+            adt::General(ref struct_defs) => struct_defs,\n+            _ => cx.sess.bug(\"unreachable\")\n+        };\n+\n+        do struct_defs\n+            .iter()\n+            .enumerate()\n+            .map |(i, struct_def)| {\n+                let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                    describe_variant(cx,\n+                                     struct_def,\n+                                     self.variants[i],\n+                                     Some(self.discriminant_type_metadata),\n+                                     self.containing_scope,\n+                                     self.file_metadata,\n+                                     self.span);\n+\n+                let member_descriptions =\n+                    member_desc_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              variant_llvm_type,\n+                                              member_descriptions,\n+                                              self.file_metadata,\n+                                              codemap::dummy_sp());\n                 MemberDescription {\n                     name: @\"\",\n-                    llvm_type: type_of::type_of(cx, component_type),\n-                    type_metadata: type_metadata(cx, component_type, span),\n-                    offset: ComputedMemberOffset,\n+                    llvm_type: variant_llvm_type,\n+                    type_metadata: variant_type_metadata,\n+                    offset: FixedMemberOffset { bytes: 0 },\n                 }\n+        }.collect()\n+    }\n+}\n+\n+struct EnumVariantMemberDescriptionFactory {\n+    args: ~[(@str, ty::t)],\n+    discriminant_type_metadata: Option<DIType>,\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.args.iter().enumerate().map |(i, &(name, ty))| {\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, ty),\n+                type_metadata: match self.discriminant_type_metadata {\n+                    Some(metadata) if i == 0 => metadata,\n+                    _ => type_metadata(cx, ty, self.span)\n+                },\n+                offset: ComputedMemberOffset,\n+            }\n+        }.collect()\n+    }\n+}\n+\n+fn describe_variant(cx: &mut CrateContext,\n+                    struct_def: &adt::Struct,\n+                    variant_info: &ty::VariantInfo,\n+                    discriminant_type_metadata: Option<DIType>,\n+                    containing_scope: DIScope,\n+                    file_metadata: DIFile,\n+                    span: Span)\n+                 -> (DICompositeType, Type, @MemberDescriptionFactory) {\n+    let variant_name = token::ident_to_str(&variant_info.name);\n+    let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n+                                          struct_def.packed);\n+    // Could some consistency checks here: size, align, field count, discr type\n+\n+    // Find the source code location of the variant's definition\n+    let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n+        match cx.tcx.items.find(&variant_info.id.node) {\n+            Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+            ref node => {\n+                cx.sess.span_warn(span,\n+                    fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n+                          type: %?. This is a bug.\", node));\n+                codemap::dummy_sp()\n             }\n         }\n+    } else {\n+        // For definitions from other crates we have no location information available.\n+        codemap::dummy_sp()\n+    };\n+\n+    let metadata_stub = create_struct_stub(cx,\n+                                           variant_llvm_type,\n+                                           variant_name,\n+                                           containing_scope,\n+                                           file_metadata,\n+                                           variant_definition_span);\n+\n+    // Get the argument names from the enum variant info\n+    let mut arg_names = match variant_info.arg_names {\n+        Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n+        None => do variant_info.args.map |_| { @\"\" }\n+    };\n+\n+    // If this is not a univariant enum, there is also the (unnamed) discriminant field\n+    if discriminant_type_metadata.is_some() {\n+        arg_names.insert(0, @\"\");\n     }\n+\n+    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+    let args: ~[(@str, ty::t)] = arg_names.iter()\n+        .zip(struct_def.fields.iter())\n+        .map(|(&s, &t)| (s, t))\n+        .collect();\n+\n+    let member_description_factory =\n+        @EnumVariantMemberDescriptionFactory {\n+            args: args,\n+            discriminant_type_metadata: discriminant_type_metadata,\n+            span: span,\n+        } as @MemberDescriptionFactory;\n+\n+    (metadata_stub, variant_llvm_type, member_description_factory)\n }\n \n fn prepare_enum_metadata(cx: &mut CrateContext,\n@@ -1336,42 +1502,14 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                 metadata_stub: enum_metadata,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n-                member_description_factory: |cx| {\n-                    // Capture type_rep, so we don't have to copy the struct_defs array\n-                    let struct_defs = match *type_rep {\n-                        adt::General(ref struct_defs) => struct_defs,\n-                        _ => cx.sess.bug(\"unreachable\")\n-                    };\n-\n-                    do struct_defs\n-                        .iter()\n-                        .enumerate()\n-                        .map |(i, struct_def)| {\n-                            let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n-                                describe_variant(cx,\n-                                                 struct_def,\n-                                                 variants[i],\n-                                                 Some(discriminant_type_metadata),\n-                                                 containing_scope,\n-                                                 file_metadata,\n-                                                 span);\n-\n-                            let member_descriptions = member_desc_factory(cx);\n-\n-                            set_members_of_composite_type(cx,\n-                                                          variant_type_metadata,\n-                                                          variant_llvm_type,\n-                                                          member_descriptions,\n-                                                          file_metadata,\n-                                                          codemap::dummy_sp());\n-                            MemberDescription {\n-                                name: @\"\",\n-                                llvm_type: variant_llvm_type,\n-                                type_metadata: variant_type_metadata,\n-                                offset: FixedMemberOffset { bytes: 0 },\n-                            }\n-                    }.collect()\n-                }\n+                member_description_factory: @GeneralMemberDescriptionFactory {\n+                    type_rep: type_rep,\n+                    variants: variants,\n+                    discriminant_type_metadata: discriminant_type_metadata,\n+                    containing_scope: containing_scope,\n+                    file_metadata: file_metadata,\n+                    span: span,\n+                } as @MemberDescriptionFactory,\n             }\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n@@ -1393,76 +1531,6 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             }\n         }\n     };\n-\n-    fn describe_variant(cx: &mut CrateContext,\n-                        struct_def: &adt::Struct,\n-                        variant_info: &ty::VariantInfo,\n-                        discriminant_type_metadata: Option<DIType>,\n-                        containing_scope: DIScope,\n-                        file_metadata: DIFile,\n-                        span: Span)\n-                     -> (DICompositeType, Type, @fn(&mut CrateContext) -> ~[MemberDescription]) {\n-        let variant_name = token::ident_to_str(&variant_info.name);\n-        let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n-                                              struct_def.packed);\n-        // Could some consistency checks here: size, align, field count, discr type\n-\n-        // Find the source code location of the variant's definition\n-        let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n-            match cx.tcx.items.find(&variant_info.id.node) {\n-                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n-                ref node => {\n-                    cx.sess.span_warn(span,\n-                        fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                              type: %?. This is a bug.\", node));\n-                    codemap::dummy_sp()\n-                }\n-            }\n-        } else {\n-            // For definitions from other crates we have no location information available.\n-            codemap::dummy_sp()\n-        };\n-\n-        let metadata_stub = create_struct_stub(cx,\n-                                               variant_llvm_type,\n-                                               variant_name,\n-                                               containing_scope,\n-                                               file_metadata,\n-                                               variant_definition_span);\n-\n-        // Get the argument names from the enum variant info\n-        let mut arg_names = match variant_info.arg_names {\n-            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-            None => do variant_info.args.map |_| { @\"\" }\n-        };\n-\n-        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n-        if discriminant_type_metadata.is_some() {\n-            arg_names.insert(0, @\"\");\n-        }\n-\n-        // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-        let args: ~[(@str, ty::t)] = arg_names.iter()\n-            .zip(struct_def.fields.iter())\n-            .map(|(&s, &t)| (s, t))\n-            .collect();\n-\n-        let member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription] = |cx| {\n-            do args.iter().enumerate().map |(i, &(name, ty))| {\n-                MemberDescription {\n-                    name: name,\n-                    llvm_type: type_of::type_of(cx, ty),\n-                    type_metadata: match discriminant_type_metadata {\n-                        Some(metadata) if i == 0 => metadata,\n-                        _ => type_metadata(cx, ty, span)\n-                    },\n-                    offset: ComputedMemberOffset,\n-                }\n-            }.collect()\n-        };\n-\n-        (metadata_stub, variant_llvm_type, member_description_factory)\n-    }\n }\n \n enum MemberOffset {"}, {"sha": "b8ccc49e904fa741d1780de3d6b5739df9dd27cd", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -1565,8 +1565,11 @@ fn test_linker_build() {\n     let matches = getopts([], optgroups());\n     let options = build_session_options(@\"rustpkg\",\n                                         matches.get_ref(),\n-                                        diagnostic::emit);\n-    let sess = build_session(options, diagnostic::emit);\n+                                        @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter);\n+    let sess = build_session(options,\n+                             @diagnostic::DefaultEmitter as\n+                                @diagnostic::Emitter);\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--linker\","}, {"sha": "ba2342d78279edab38d59b71aaced149787833d3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -869,7 +869,7 @@ struct Duplicator {\n }\n \n impl fold::ast_fold for Duplicator {\n-    fn new_id(&self, _: NodeId) -> NodeId { \n+    fn new_id(&self, _: NodeId) -> NodeId {\n         ast::DUMMY_NODE_ID\n     }\n }"}, {"sha": "919b4b59dca8e5a9abe5563a3f5046c65fe2cb6f", "filename": "src/test/run-pass/nested-enum-same-names.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -30,20 +30,4 @@ impl Foo {\n     }\n }\n \n-/*\n-#2074 duplicate symbols with enum in boxed closure\n-*/\n-\n-fn foo() {\n-    let one: @fn() -> uint = || {\n-        enum r { a }\n-        a as uint\n-    };\n-    let two: @fn() -> uint = || {\n-        enum r { a }\n-        a as uint\n-    };\n-    one(); two();\n-}\n-\n fn main() {}"}, {"sha": "6a87a6502d211f37b90d32201f5410dd476442d0", "filename": "src/test/run-pass/rl-human-test.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frl-human-test.rs?ref=3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "patch": "@@ -22,6 +22,20 @@ use extra::rl;\n \n static HISTORY_FILE: &'static str = \"rl-human-test-history.txt\";\n \n+struct TestCompleter;\n+\n+impl rl::CompletionCb for TestCompleter {\n+    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n+        if line.is_empty() {\n+            suggest(~\"empty\")\n+        } else {\n+            for c in line.rev_iter().take(3) {\n+                suggest(format!(\"{0}{1}{1}{1}\", line, c))\n+            }\n+        }\n+    }\n+}\n+\n fn main() {\n     // don't run this in robot mode, but still typecheck it.\n     if !cfg!(robot_mode) {\n@@ -42,14 +56,8 @@ The bool return values of each step are printed.\",\n \n         println!(\"restricting history length: {}\", rl::set_history_max_len(3));\n \n-        do rl::complete |line, suggest| {\n-            if line.is_empty() {\n-                suggest(~\"empty\")\n-            } else {\n-                for c in line.rev_iter().take(3) {\n-                    suggest(format!(\"{0}{1}{1}{1}\", line, c))\n-                }\n-            }\n+        unsafe {\n+            rl::complete(@TestCompleter as @rl::CompletionCb);\n         }\n \n         println!(\"adding 'one': {}\", rl::add_history(\"one\"));"}]}