{"sha": "0d1331f4a0cade66349a4c22315899210ad9b6a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMTMzMWY0YTBjYWRlNjYzNDlhNGMyMjMxNTg5OTIxMGFkOWI2YTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:09:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:09:15Z"}, "message": "Merge remote-tracking branch 'brson/io' into incoming", "tree": {"sha": "5164bf68c09c8be5c7f2406c208b24c73fbe5711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5164bf68c09c8be5c7f2406c208b24c73fbe5711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1331f4a0cade66349a4c22315899210ad9b6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1331f4a0cade66349a4c22315899210ad9b6a7", "html_url": "https://github.com/rust-lang/rust/commit/0d1331f4a0cade66349a4c22315899210ad9b6a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1331f4a0cade66349a4c22315899210ad9b6a7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcec83aaee0a44639a4b231834140dcb1d9adc7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcec83aaee0a44639a4b231834140dcb1d9adc7b", "html_url": "https://github.com/rust-lang/rust/commit/bcec83aaee0a44639a4b231834140dcb1d9adc7b"}, {"sha": "d951da82768685cacba7444dae10ede2a71efedb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d951da82768685cacba7444dae10ede2a71efedb", "html_url": "https://github.com/rust-lang/rust/commit/d951da82768685cacba7444dae10ede2a71efedb"}], "stats": {"total": 4161, "additions": 3004, "deletions": 1157}, "files": [{"sha": "eb94e9ca0286962293d31861eb7930c5158fb04c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -205,8 +205,11 @@ mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n mod stackwalk;\n+\n+// XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n+// but name resolution doesn't work without it being pub.\n #[path = \"rt/mod.rs\"]\n-mod rt;\n+pub mod rt;\n \n // A curious inner-module that's not exported that contains the binding\n // 'core' so that macro-expanded references to core::error and such"}, {"sha": "b192333999ac46be29cead81ec737d6108771a89", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -10,17 +10,16 @@\n \n //! Logging\n \n-pub mod rustrt {\n-    use libc;\n-\n-    pub extern {\n-        unsafe fn rust_log_console_on();\n-        unsafe fn rust_log_console_off();\n-        unsafe fn rust_log_str(level: u32,\n-                               string: *libc::c_char,\n-                               size: libc::size_t);\n-    }\n-}\n+use option::*;\n+use either::*;\n+use rt;\n+use rt::logging::{Logger, StdErrLogger};\n+use io;\n+use libc;\n+use repr;\n+use vec;\n+use cast;\n+use str;\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -55,8 +54,46 @@ pub fn log_type<T>(level: u32, object: &T) {\n     let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n+\n+    match rt::context() {\n+        rt::OldTaskContext => {\n+            unsafe {\n+                let len = bytes.len() as libc::size_t;\n+                rustrt::rust_log_str(level, cast::transmute(vec::raw::to_ptr(bytes)), len);\n+            }\n+        }\n+        _ => {\n+            // XXX: Bad allocation\n+            let msg = str::from_bytes(bytes);\n+            newsched_log_str(msg);\n+        }\n+    }\n+}\n+\n+fn newsched_log_str(msg: ~str) {\n     unsafe {\n-        let len = bytes.len() as libc::size_t;\n-        rustrt::rust_log_str(level, transmute(vec::raw::to_ptr(bytes)), len);\n+        match rt::local_services::unsafe_try_borrow_local_services() {\n+            Some(local) => {\n+                // Use the available logger\n+                (*local).logger.log(Left(msg));\n+            }\n+            None => {\n+                // There is no logger anywhere, just write to stderr\n+                let mut logger = StdErrLogger;\n+                logger.log(Left(msg));\n+            }\n+        }\n+    }\n+}\n+\n+pub mod rustrt {\n+    use libc;\n+\n+    pub extern {\n+        unsafe fn rust_log_console_on();\n+        unsafe fn rust_log_console_off();\n+        unsafe fn rust_log_str(level: u32,\n+                               string: *libc::c_char,\n+                               size: libc::size_t);\n     }\n }"}, {"sha": "fda48b6ffb7d9140c845846ab0b90fefb5d26651", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -30,10 +30,24 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+macro_rules! rtassert (\n+    ( $arg:expr ) => ( {\n+        if !$arg {\n+            abort!(\"assertion failed: %s\", stringify!($arg));\n+        }\n+    } )\n+)\n+\n macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);\n \n-        unsafe { ::libc::abort(); }\n+        do_abort();\n+\n+        // NB: This is in a fn to avoid putting the `unsafe` block in a macro,\n+        // which causes spurious 'unnecessary unsafe block' warnings.\n+        fn do_abort() -> ! {\n+            unsafe { ::libc::abort(); }\n+        }\n     } )\n )"}, {"sha": "61c80c8989416ac870fa3dda9c121fcf3b5bd0cf", "filename": "src/libcore/os.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -147,23 +147,25 @@ pub mod win32 {\n \n /*\n Accessing environment variables is not generally threadsafe.\n-This uses a per-runtime lock to serialize access.\n-FIXME #4726: It would probably be appropriate to make this a real global\n+Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n-    use unstable::global::global_data_clone_create;\n-    use unstable::sync::{Exclusive, exclusive};\n-\n-    struct SharedValue(());\n-    type ValueMutex = Exclusive<SharedValue>;\n-    fn key(_: ValueMutex) { }\n+    use unstable::finally::Finally;\n \n     unsafe {\n-        let lock: ValueMutex = global_data_clone_create(key, || {\n-            ~exclusive(SharedValue(()))\n-        });\n+        return do (|| {\n+            rust_take_env_lock();\n+            f()\n+        }).finally {\n+            rust_drop_env_lock();\n+        };\n+    }\n \n-        lock.with_imm(|_| f() )\n+    extern {\n+        #[fast_ffi]\n+        fn rust_take_env_lock();\n+        #[fast_ffi]\n+        fn rust_drop_env_lock();\n     }\n }\n \n@@ -722,7 +724,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             use os::win32::{\n                 as_utf16_p\n             };\n-            use unstable::exchange_alloc::{malloc_raw, free_raw};\n+            use rt::global_heap::{malloc_raw, free_raw};\n             #[nolink]\n             extern {\n                 unsafe fn rust_list_dir_wfd_size() -> libc::size_t;"}, {"sha": "2add314fd1196df4b50ac3e16717fc80e482e20c", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -84,6 +84,7 @@ pub impl Context {\n }\n \n extern {\n+    #[rust_stack]\n     fn swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n \n@@ -111,9 +112,9 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint; }\n+    unsafe { *sp = arg as uint };\n     let sp = mut_offset(sp, -1);\n-    unsafe { *sp = 0; } // The final return address\n+    unsafe { *sp = 0 }; // The final return address\n \n     regs.esp = sp as u32;\n     regs.eip = fptr as u32;\n@@ -195,7 +196,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n \n fn align_down(sp: *mut uint) -> *mut uint {\n     unsafe {\n-        let sp = transmute::<*mut uint, uint>(sp);\n+        let sp: uint = transmute(sp);\n         let sp = sp & !(16 - 1);\n         transmute::<uint, *mut uint>(sp)\n     }"}, {"sha": "ce7ff87b44580c37fc22423cda6de3790a9813d4", "filename": "src/libcore/rt/global_heap.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fglobal_heap.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use sys::{TypeDesc, size_of};\n-use libc::{c_void, size_t};\n+use libc::{c_void, size_t, uintptr_t};\n use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n@@ -34,7 +34,7 @@ pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     box.header.prev = null();\n     box.header.next = null();\n \n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    let exchange_count = &mut *exchange_count_ptr();\n     atomic_xadd(exchange_count, 1);\n \n     return transmute(box);\n@@ -52,7 +52,7 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n }\n \n pub unsafe fn free(ptr: *c_void) {\n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    let exchange_count = &mut *exchange_count_ptr();\n     atomic_xsub(exchange_count, 1);\n \n     assert!(ptr.is_not_null());\n@@ -77,7 +77,11 @@ fn align_to(size: uint, align: uint) -> uint {\n     (size + align - 1) & !(align - 1)\n }\n \n+fn exchange_count_ptr() -> *mut int {\n+    // XXX: Need mutable globals\n+    unsafe { transmute(&rust_exchange_count) }\n+}\n+\n extern {\n-    #[rust_stack]\n-    fn rust_get_exchange_count_ptr() -> *mut int;\n+    static rust_exchange_count: uintptr_t;\n }", "previous_filename": "src/libcore/unstable/exchange_alloc.rs"}, {"sha": "a3804d2d6ef1ac361e5d5f2f03cceed27d5b1f62", "filename": "src/libcore/rt/io/extensions.rs", "status": "modified", "additions": 667, "deletions": 233, "changes": 900, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -13,22 +13,53 @@\n // XXX: Not sure how this should be structured\n // XXX: Iteration should probably be considered separately\n \n+use uint;\n+use int;\n+use vec;\n+use rt::io::{Reader, Writer};\n+use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n+use option::{Option, Some, None};\n+use unstable::finally::Finally;\n+use util;\n+use cast;\n+use io::{u64_to_le_bytes, u64_to_be_bytes};\n+\n pub trait ReaderUtil {\n \n-    /// Reads `len` bytes and gives you back a new vector\n+    /// Reads a single byte. Returns `None` on EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method. Returns\n+    /// `None` if the condition is handled.\n+    fn read_byte(&mut self) -> Option<u8>;\n+\n+    /// Reads `len` bytes and appends them to a vector.\n+    ///\n+    /// May push fewer than the requested number of bytes on error\n+    /// or EOF. Returns true on success, false on EOF or error.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error. Returns an empty\n-    /// vector if the condition is handled.\n+    /// Raises the same conditions as `read`. Additionally raises `read_error`\n+    /// on EOF. If `read_error` is handled then `push_bytes` may push less\n+    /// than the requested number of bytes.\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint);\n+\n+    /// Reads `len` bytes and gives you back a new vector of length `len`\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as `read`. Additionally raises `read_error`\n+    /// on EOF. If `read_error` is handled then the returned vector may\n+    /// contain less than the requested number of bytes.\n     fn read_bytes(&mut self, len: uint) -> ~[u8];\n \n     /// Reads all remaining bytes from the stream.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error. Returns an empty\n-    /// vector if the condition is handled.\n+    /// Raises the same conditions as the `read` method.\n     fn read_to_end(&mut self) -> ~[u8];\n \n }\n@@ -37,433 +68,836 @@ pub trait ReaderByteConversions {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint(&mut self) -> uint;\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int(&mut self) -> int;\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint(&mut self) -> uint;\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int(&mut self) -> int;\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u64(&mut self) -> u64;\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u32(&mut self) -> u32;\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u16(&mut self) -> u16;\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i64(&mut self) -> i64;\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i32(&mut self) -> i32;\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i16(&mut self) -> i16;\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f64(&mut self) -> f64;\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f32(&mut self) -> f32;\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u64(&mut self) -> u64;\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u32(&mut self) -> u32;\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u16(&mut self) -> u16;\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i64(&mut self) -> i64;\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i32(&mut self) -> i32;\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i16(&mut self) -> i16;\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f64(&mut self) -> f64;\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f32(&mut self) -> f32;\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_u8(&mut self) -> u8;\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_i8(&mut self) -> i8;\n \n }\n \n pub trait WriterByteConversions {\n     /// Write the result of passing n through `int::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_int(&mut self, n: int);\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_uint(&mut self, n: uint);\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_uint(&mut self, n: uint);\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_int(&mut self, n: int);\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_uint(&mut self, n: uint);\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_int(&mut self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n-    fn write_be_u64(&mut self, n: u64);\n+    fn write_be_u64_(&mut self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u32(&mut self, n: u32);\n \n     /// Write a big-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u16(&mut self, n: u16);\n \n     /// Write a big-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i64(&mut self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i32(&mut self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i16(&mut self, n: i16);\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f64(&mut self, f: f64);\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f32(&mut self, f: f32);\n \n     /// Write a little-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n-    fn write_le_u64(&mut self, n: u64);\n+    fn write_le_u64_(&mut self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u32(&mut self, n: u32);\n \n     /// Write a little-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u16(&mut self, n: u16);\n \n     /// Write a little-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i64(&mut self, n: i64);\n \n     /// Write a little-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i32(&mut self, n: i32);\n \n     /// Write a little-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i16(&mut self, n: i16);\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f64(&mut self, f: f64);\n \n     /// Write a litten-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f32(&mut self, f: f32);\n \n     /// Write a u8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_u8(&mut self, n: u8);\n \n     /// Write a i8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_i8(&mut self, n: i8);\n }\n+\n+impl<T: Reader> ReaderUtil for T {\n+    fn read_byte(&mut self) -> Option<u8> {\n+        let mut buf = [0];\n+        match self.read(buf) {\n+            Some(0) => {\n+                debug!(\"read 0 bytes. trying again\");\n+                self.read_byte()\n+            }\n+            Some(1) => Some(buf[0]),\n+            Some(_) => util::unreachable(),\n+            None => None\n+        }\n+    }\n+\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n+        unsafe {\n+            let start_len = buf.len();\n+            let mut total_read = 0;\n+\n+            vec::reserve_at_least(buf, start_len + len);\n+            vec::raw::set_len(buf, start_len + len);\n+\n+            do (|| {\n+                while total_read < len {\n+                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n+                    match self.read(slice) {\n+                        Some(nread) => {\n+                            total_read += nread;\n+                        }\n+                        None => {\n+                            read_error::cond.raise(standard_error(EndOfFile));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }).finally {\n+                vec::raw::set_len(buf, start_len + total_read);\n+            }\n+        }\n+    }\n+\n+    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+        let mut buf = vec::with_capacity(len);\n+        self.push_bytes(&mut buf, len);\n+        return buf;\n+    }\n+\n+    fn read_to_end(&mut self) -> ~[u8] {\n+        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n+        let mut keep_reading = true;\n+        do read_error::cond.trap(|e| {\n+            if e.kind == EndOfFile {\n+                keep_reading = false;\n+            } else {\n+                read_error::cond.raise(e)\n+            }\n+        }).in {\n+            while keep_reading {\n+                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n+            }\n+        }\n+        return buf;\n+    }\n+}\n+\n+impl<T: Reader> ReaderByteConversions for T {\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, pos = 0, i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_le_uint(&mut self) -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_le_int(&mut self) -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_uint(&mut self) -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_be_int(&mut self) -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_u64(&mut self) -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    fn read_be_u32(&mut self) -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    fn read_be_u16(&mut self) -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    fn read_be_i64(&mut self) -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    fn read_be_i32(&mut self) -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    fn read_be_i16(&mut self) -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    fn read_be_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_be_u64())\n+        }\n+    }\n+\n+    fn read_be_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_be_u32())\n+        }\n+    }\n+\n+    fn read_le_u64(&mut self) -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    fn read_le_u32(&mut self) -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    fn read_le_u16(&mut self) -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    fn read_le_i64(&mut self) -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    fn read_le_i32(&mut self) -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    fn read_le_i16(&mut self) -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    fn read_le_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_le_u64())\n+        }\n+    }\n+\n+    fn read_le_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_le_u32())\n+        }\n+    }\n+\n+    fn read_u8(&mut self) -> u8 {\n+        match self.read_byte() {\n+            Some(b) => b as u8,\n+            None => 0\n+        }\n+    }\n+\n+    fn read_i8(&mut self) -> i8 {\n+        match self.read_byte() {\n+            Some(b) => b as i8,\n+            None => 0\n+        }\n+    }\n+\n+}\n+\n+impl<T: Writer> WriterByteConversions for T {\n+    fn write_int(&mut self, n: int) {\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_uint(&mut self, n: uint) {\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_le_uint(&mut self, n: uint) {\n+        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_le_int(&mut self, n: int) {\n+        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_uint(&mut self, n: uint) {\n+        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_int(&mut self, n: int) {\n+        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_u64_(&mut self, n: u64) {\n+        u64_to_be_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u32(&mut self, n: u32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u16(&mut self, n: u16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i64(&mut self, n: i64) {\n+        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i32(&mut self, n: i32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i16(&mut self, n: i16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_be_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_be_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_be_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_u64_(&mut self, n: u64) {\n+        u64_to_le_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u32(&mut self, n: u32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u16(&mut self, n: u16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i64(&mut self, n: i64) {\n+        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i32(&mut self, n: i32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i16(&mut self, n: i16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_le_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_le_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_u8(&mut self, n: u8) {\n+        self.write([n]) \n+    }\n+\n+    fn write_i8(&mut self, n: i8) {\n+        self.write([n as u8]) \n+    }\n+}\n+\n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{ReaderUtil, ReaderByteConversions, WriterByteConversions};\n+    use u64;\n+    use i32;\n+    use option::{Some, None};\n+    use cell::Cell;\n+    use rt::io::mem::{MemReader, MemWriter};\n+    use rt::io::mock::MockReader;\n+    use rt::io::{read_error, placeholder_error};\n+\n+    #[test]\n+    fn read_byte() {\n+        let mut reader = MemReader::new(~[10]);\n+        let byte = reader.read_byte();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn read_byte_0_bytes() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    Some(0)\n+                } else {\n+                    buf[0] = 10;\n+                    Some(1)\n+                }\n+            }\n+        };\n+        let byte = reader.read_byte();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn read_byte_eof() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| None;\n+        let byte = reader.read_byte();\n+        assert!(byte == None);\n+    }\n+\n+    #[test]\n+    fn read_byte_error() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| {\n+            read_error::cond.raise(placeholder_error());\n+            None\n+        };\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            let byte = reader.read_byte();\n+            assert!(byte == None);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_bytes() {\n+        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let bytes = reader.read_bytes(4);\n+        assert!(bytes == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn read_bytes_partial() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                }\n+            }\n+        };\n+        let bytes = reader.read_bytes(4);\n+        assert!(bytes == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn read_bytes_eof() {\n+        let mut reader = MemReader::new(~[10, 11]);\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            assert!(reader.read_bytes(4) == ~[10, 11]);\n+        }\n+    }\n+\n+    #[test]\n+    fn push_bytes() {\n+        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let mut buf = ~[8, 9];\n+        reader.push_bytes(&mut buf, 4);\n+        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn push_bytes_partial() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                }\n+            }\n+        };\n+        let mut buf = ~[8, 9];\n+        reader.push_bytes(&mut buf, 4);\n+        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn push_bytes_eof() {\n+        let mut reader = MemReader::new(~[10, 11]);\n+        let mut buf = ~[8, 9];\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            reader.push_bytes(&mut buf, 4);\n+            assert!(buf == ~[8, 9, 10, 11]);\n+        }\n+    }\n+\n+    #[test]\n+    fn push_bytes_error() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    Some(1)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let mut buf = ~[8, 9];\n+        do read_error::cond.trap(|_| { } ).in {\n+            reader.push_bytes(&mut buf, 4);\n+        }\n+        assert!(buf == ~[8, 9, 10]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn push_bytes_fail_reset_len() {\n+        use unstable::finally::Finally;\n+\n+        // push_bytes unsafely sets the vector length. This is testing that\n+        // upon failure the length is reset correctly.\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    Some(1)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let buf = @mut ~[8, 9];\n+        do (|| {\n+            reader.push_bytes(&mut *buf, 4);\n+        }).finally {\n+            // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n+            rtassert!(*buf == ~[8, 9, 10]);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else if *count == 1 {\n+                    *count = 2;\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn read_to_end_error() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11]);\n+    }\n+\n+    // XXX: Some problem with resolve here\n+    /*#[test]\n+    fn test_read_write_le() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_le_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_le_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_write_be() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_be_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_be_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_be_int_n() {\n+        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for ints.each |i| {\n+            writer.write_be_i32(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for ints.each |i| {\n+            // this tests that the sign extension is working\n+            // (comparing the values as i32 would not test this)\n+            assert!(reader.read_be_int_n(4) == *i as i64);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_f32() {\n+        //big-endian floating-point 8.1250\n+        let buf = ~[0x41, 0x02, 0x00, 0x00];\n+\n+        let mut writer = MemWriter::new();\n+        writer.write(buf);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        let f = reader.read_be_f32();\n+        assert!(f == 8.1250);\n+    }\n+\n+    #[test]\n+    fn test_read_write_f32() {\n+        let f:f32 = 8.1250;\n+\n+        let mut writer = MemWriter::new();\n+        writer.write_be_f32(f);\n+        writer.write_le_f32(f);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        assert!(reader.read_be_f32() == 8.1250);\n+        assert!(reader.read_le_f32() == 8.1250);\n+    }*/\n+\n+}"}, {"sha": "1f61cf25fbdd4dc52596aea401a6071e2ed648fe", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n use super::support::PathLike;\n-use super::{Reader, Writer, Seek, Close};\n+use super::{Reader, Writer, Seek};\n use super::SeekStyle;\n \n /// # XXX\n@@ -69,10 +69,6 @@ impl Seek for FileStream {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl Close for FileStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n #[test]\n #[ignore]\n fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {"}, {"sha": "b580b752bd985c8242eba880ed6c6d32344a6f7b", "filename": "src/libcore/rt/io/mock.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmock.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::{Option, None};\n+use rt::io::{Reader, Writer};\n+\n+pub struct MockReader {\n+    read: ~fn(buf: &mut [u8]) -> Option<uint>,\n+    eof: ~fn() -> bool\n+}\n+\n+impl MockReader {\n+    pub fn new() -> MockReader {\n+        MockReader {\n+            read: |_| None,\n+            eof: || false\n+        }\n+    }\n+}\n+\n+impl Reader for MockReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { (self.read)(buf) }\n+    fn eof(&mut self) -> bool { (self.eof)() }\n+}\n+\n+pub struct MockWriter {\n+    write: ~fn(buf: &[u8]),\n+    flush: ~fn()\n+}\n+\n+impl MockWriter {\n+    pub fn new() -> MockWriter {\n+        MockWriter {\n+            write: |_| (),\n+            flush: || ()\n+        }\n+    }\n+}\n+\n+impl Writer for MockWriter {\n+    fn write(&mut self, buf: &[u8]) { (self.write)(buf) }\n+    fn flush(&mut self) { (self.flush)() }\n+}\n\\ No newline at end of file"}, {"sha": "802e069a738f000dfc1ad4a21f6044bd3ebb62aa", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -187,7 +187,7 @@ In particular code written to ignore errors and expect conditions to be unhandle\n will start passing around null or zero objects when wrapped in a condition handler.\n \n * XXX: How should we use condition handlers that return values?\n-\n+* XXX: Should EOF raise default conditions when EOF is not an error?\n \n # Issues withi/o scheduler affinity, work stealing, task pinning\n \n@@ -238,6 +238,7 @@ Out of scope\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n * Using conditions is a big unknown since we don't have much experience with them\n+* Too many uses of OtherIoError\n \n */\n \n@@ -252,20 +253,26 @@ pub use self::stdio::println;\n \n pub use self::file::FileStream;\n pub use self::net::ip::IpAddr;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpListener;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n // Some extension traits that all Readers and Writers get.\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderUtil;\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderByteConversions;\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::WriterByteConversions;\n \n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n pub mod net {\n+    #[cfg(not(stage0))]\n     pub mod tcp;\n     pub mod udp;\n     pub mod ip;\n@@ -291,6 +298,7 @@ pub mod flate;\n pub mod comm_adapters;\n \n /// Extension traits\n+#[cfg(not(stage0))] // Requires condition! fixes\n mod extensions;\n \n /// Non-I/O things needed by the I/O module\n@@ -312,6 +320,12 @@ pub mod native {\n     }\n }\n \n+/// Mock implementations for testing\n+mod mock;\n+\n+/// The default buffer size for various I/O operations\n+/// XXX: Not pub\n+pub static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n /// The type passed to I/O condition handlers to indicate error\n ///\n@@ -326,12 +340,16 @@ pub struct IoError {\n \n #[deriving(Eq)]\n pub enum IoErrorKind {\n+    PreviousIoError,\n+    OtherIoError,\n+    EndOfFile,\n     FileNotFound,\n-    FilePermission,\n+    PermissionDenied,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError,\n-    PreviousIoError\n+    ConnectionRefused,\n+    ConnectionReset,\n+    BrokenPipe\n }\n \n // XXX: Can't put doc comments on macros\n@@ -341,19 +359,36 @@ condition! {\n     /*pub*/ io_error: super::IoError -> ();\n }\n \n+// XXX: Can't put doc comments on macros\n+// Raised by `read` on error\n+condition! {\n+    // FIXME (#6009): uncomment `pub` after expansion support lands.\n+    /*pub*/ read_error: super::IoError -> ();\n+}\n+\n pub trait Reader {\n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read, or `None` on EOF.\n+    /// Returns the number of bytes read. The number of bytes read my\n+    /// be less than the number requested, even 0. Returns `None` on EOF.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error, then returns `None`.\n+    /// Raises the `read_error` condition on error. If the condition\n+    /// is handled then no guarantee is made about the number of bytes\n+    /// read and the contents of `buf`. If the condition is handled\n+    /// returns `None` (XXX see below).\n     ///\n     /// # XXX\n     ///\n+    /// * Should raise_default error on eof?\n+    /// * If the condition is handled it should still return the bytes read,\n+    ///   in which case there's no need to return Option - but then you *have*\n+    ///   to install a handler to detect eof.\n+    ///\n     /// This doesn't take a `len` argument like the old `read`.\n     /// Will people often need to slice their vectors to call this\n     /// and will that be annoying?\n+    /// Is it actually possible for 0 bytes to be read successfully?\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n \n     /// Return whether the Reader has reached the end of the stream.\n@@ -383,16 +418,7 @@ pub trait Writer {\n     fn flush(&mut self);\n }\n \n-/// I/O types that may be closed\n-///\n-/// Any further operations performed on a closed resource will raise\n-/// on `io_error`\n-pub trait Close {\n-    /// Close the I/O resource\n-    fn close(&mut self);\n-}\n-\n-pub trait Stream: Reader + Writer + Close { }\n+pub trait Stream: Reader + Writer { }\n \n pub enum SeekStyle {\n     /// Seek from the beginning of the stream\n@@ -466,6 +492,21 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n                 detail: None\n             }\n         }\n+        EndOfFile => {\n+            IoError {\n+                kind: EndOfFile,\n+                desc: \"End of file\",\n+                detail: None\n+            }\n+        }\n         _ => fail!()\n     }\n }\n+\n+pub fn placeholder_error() -> IoError {\n+    IoError {\n+        kind: OtherIoError,\n+        desc: \"Placeholder error. You shouldn't be seeing this\",\n+        detail: None\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "31c90336a24c28abe506d86dffd6a13d2cd40765", "filename": "src/libcore/rt/io/native/file.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -40,10 +40,6 @@ impl Writer for FileDesc {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for FileDesc {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for FileDesc {\n     fn tell(&self) -> u64 { fail!() }\n \n@@ -72,10 +68,6 @@ impl Writer for CFile {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for CFile {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for CFile {\n     fn tell(&self) -> u64 { fail!() }\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }"}, {"sha": "eec3614d12978eb9856c6a8d5d823cc2727e8bb9", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 306, "deletions": 24, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -8,67 +8,349 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::super::*;\n-use super::ip::IpAddr;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::sched::local_sched::unsafe_borrow_io;\n+use rt::io::net::ip::IpAddr;\n+use rt::io::{Reader, Writer, Listener};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::rtio::{IoFactory,\n+               RtioTcpListener, RtioTcpListenerObject,\n+               RtioTcpStream, RtioTcpStreamObject};\n \n-pub struct TcpStream;\n+pub struct TcpStream {\n+    rtstream: ~RtioTcpStreamObject\n+}\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n-        fail!()\n+    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n+        TcpStream {\n+            rtstream: s\n+        }\n+    }\n+\n+    pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n+        let stream = unsafe {\n+            rtdebug!(\"borrowing io to connect\");\n+            let io = unsafe_borrow_io();\n+            rtdebug!(\"about to connect\");\n+            (*io).tcp_connect(addr)\n+        };\n+\n+        match stream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to connect: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let bytes_read = self.rtstream.read(buf);\n+        match bytes_read {\n+            Ok(read) => Some(read),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        let res = self.rtstream.write(buf);\n+        match res {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for TcpStream {\n-    fn close(&mut self) { fail!() }\n+pub struct TcpListener {\n+    rtlistener: ~RtioTcpListenerObject,\n }\n \n-pub struct TcpListener;\n-\n impl TcpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n-        fail!()\n+    pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n+        let listener = unsafe { (*unsafe_borrow_io()).tcp_bind(addr) };\n+        match listener {\n+            Ok(l) => {\n+                Some(TcpListener {\n+                    rtlistener: l\n+                })\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n-    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+    fn accept(&mut self) -> Option<TcpStream> {\n+        let rtstream = self.rtlistener.accept();\n+        match rtstream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n+    }\n }\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n+    use int;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::io::net::ip::Ipv4;\n+    use rt::io::*;\n \n     #[test] #[ignore]\n+    fn bind_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let listener = TcpListener::bind(addr);\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == ConnectionRefused);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let stream = TcpStream::connect(addr);\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n     fn smoke_test() {\n-        /*do run_in_newsched_task {\n+        do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawn_immediately {\n-                let listener = TcpListener::bind(addr);\n-                do listener.accept() {\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n+            }\n+\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_twice() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn write_close() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let buf = [0];\n+                loop {\n+                    let mut stop = false;\n+                    do io_error::cond.trap(|e| {\n+                        // NB: ECONNRESET on linux, EPIPE on mac\n+                        assert!(e.kind == ConnectionReset || e.kind == BrokenPipe);\n+                        stop = true;\n+                    }).in {\n+                        stream.write(buf);\n+                    }\n+                    if stop { break }\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            let max = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for max.times {\n+                    let mut stream = listener.accept();\n                     let mut buf = [0];\n-                    listener.read(buf);\n+                    stream.read(buf);\n                     assert!(buf[0] == 99);\n                 }\n             }\n \n-            do spawn_immediately {\n-                let stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+            do spawntask_immediately {\n+                for max.times {\n+                    let mut stream = TcpStream::connect(addr);\n+                    stream.write([99]);\n+                }\n             }\n-        }*/\n+        }\n     }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test] #[ignore(reason = \"hangs on mac\")]\n+    fn multiple_connect_interleaved_lazy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "bb5457e334ddaf3303ce07ba65f4121e6765db44", "filename": "src/libcore/rt/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -32,10 +32,6 @@ impl Writer for UdpStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UdpStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UdpListener;\n \n impl UdpListener {"}, {"sha": "b85b7dd059d82f7f1cefd6cae9ac2636d2031858", "filename": "src/libcore/rt/io/net/unix.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -32,10 +32,6 @@ impl Writer for UnixStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UnixStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UnixListener;\n \n impl UnixListener {"}, {"sha": "6ae747f8b4b4c2da517b5c9bdaa6050d4004135e", "filename": "src/libcore/rt/io/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -18,7 +18,7 @@\n \n use option::*;\n use super::{Reader, Writer, Listener};\n-use super::{standard_error, PreviousIoError, io_error, IoError};\n+use super::{standard_error, PreviousIoError, io_error, read_error, IoError};\n \n fn prev_io_error() -> IoError {\n     standard_error(PreviousIoError)\n@@ -45,7 +45,7 @@ impl<R: Reader> Reader for Option<R> {\n         match *self {\n             Some(ref mut reader) => reader.read(buf),\n             None => {\n-                io_error::cond.raise(prev_io_error());\n+                read_error::cond.raise(prev_io_error());\n                 None\n             }\n         }\n@@ -79,7 +79,7 @@ mod test {\n     use option::*;\n     use super::super::mem::*;\n     use rt::test::*;\n-    use super::super::{PreviousIoError, io_error};\n+    use super::super::{PreviousIoError, io_error, read_error};\n \n     #[test]\n     fn test_option_writer() {\n@@ -133,7 +133,7 @@ mod test {\n         let mut buf = [];\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        do read_error::cond.trap(|err| {\n             assert!(err.kind == PreviousIoError);\n             called = true;\n         }).in {"}, {"sha": "247fe9544088bfa54984725fed476bf9a83d95f4", "filename": "src/libcore/rt/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::{Reader, Writer, Close};\n+use super::{Reader, Writer};\n \n pub fn stdin() -> StdReader { fail!() }\n \n@@ -39,10 +39,6 @@ impl Reader for StdReader {\n     fn eof(&mut self) -> bool { fail!() }\n }\n \n-impl Close for StdReader {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct StdWriter;\n \n impl StdWriter {\n@@ -55,6 +51,3 @@ impl Writer for StdWriter {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for StdWriter {\n-    fn close(&mut self) { fail!() }\n-}"}, {"sha": "895354d2218e568bb5da409088d1815c0a9c0c4e", "filename": "src/libcore/rt/local_sched.rs", "status": "renamed", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -13,18 +13,21 @@\n use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n-use cast::transmute;\n+use cast;\n+use cell::Cell;\n \n-use super::Scheduler;\n-use super::super::rtio::IoFactoryObject;\n-use tls = super::super::thread_local_storage;\n-#[cfg(test)] use super::super::uvio::UvEventLoop;\n+use rt::sched::Scheduler;\n+use rt::rtio::{EventLoop, IoFactoryObject};\n+use tls = rt::thread_local_storage;\n+use unstable::finally::Finally;\n+\n+#[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n /// Give the Scheduler to thread-local storage\n pub fn put(sched: ~Scheduler) {\n     unsafe {\n         let key = tls_key();\n-        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        let void_sched: *mut c_void = cast::transmute(sched);\n         tls::set(key, void_sched);\n     }\n }\n@@ -34,8 +37,8 @@ pub fn take() -> ~Scheduler {\n     unsafe {\n         let key = tls_key();\n         let void_sched: *mut c_void = tls::get(key);\n-        assert!(void_sched.is_not_null());\n-        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        rtassert!(void_sched.is_not_null());\n+        let sched: ~Scheduler = cast::transmute(void_sched);\n         tls::set(key, mut_null());\n         return sched;\n     }\n@@ -55,8 +58,18 @@ pub fn exists() -> bool {\n /// While the scheduler is borrowed it is not available in TLS.\n pub fn borrow(f: &fn(&mut Scheduler)) {\n     let mut sched = take();\n-    f(sched);\n-    put(sched);\n+\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    unsafe {\n+        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n+        let sched = Cell(sched);\n+\n+        do (|| {\n+            f(unsafe_sched);\n+        }).finally {\n+            put(sched.take());\n+        }\n+    }\n }\n \n /// Borrow a mutable reference to the thread-local Scheduler\n@@ -65,33 +78,35 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n+pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n-    assert!(void_sched.is_not_null());\n+    rtassert!(void_sched.is_not_null());\n     {\n-        let void_sched_ptr = &mut void_sched;\n-        let sched: &mut ~Scheduler = {\n-            transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-        };\n-        let sched: &mut Scheduler = &mut **sched;\n+        let sched: *mut *mut c_void = &mut void_sched;\n+        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n+        let sched: *mut Scheduler = &mut **sched;\n         return sched;\n     }\n }\n \n-pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n+pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n     let sched = unsafe_borrow();\n-    return sched.event_loop.io().unwrap();\n+    let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+    return io;\n }\n \n fn tls_key() -> tls::Key {\n-    maybe_tls_key().get()\n+    match maybe_tls_key() {\n+        Some(key) => key,\n+        None => abort!(\"runtime tls key not initialized\")\n+    }\n }\n \n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n-        let key: *mut c_void = rust_get_sched_tls_key();\n-        let key: &mut tls::Key = transmute(key);\n+        let key: *mut c_void = rust_get_rt_tls_key();\n+        let key: &mut tls::Key = cast::transmute(key);\n         let key = *key;\n         // Check that the key has been initialized.\n \n@@ -105,7 +120,7 @@ fn maybe_tls_key() -> Option<tls::Key> {\n         // another thread. I think this is fine since the only action\n         // they could take if it was initialized would be to check the\n         // thread-local value and see that it's not set.\n-        if key != 0 {\n+        if key != -1 {\n             return Some(key);\n         } else {\n             return None;\n@@ -114,7 +129,8 @@ fn maybe_tls_key() -> Option<tls::Key> {\n }\n \n extern {\n-    fn rust_get_sched_tls_key() -> *mut c_void;\n+    #[fast_ffi]\n+    fn rust_get_rt_tls_key() -> *mut c_void;\n }\n \n #[test]", "previous_filename": "src/libcore/rt/sched/local_sched.rs"}, {"sha": "98bfc2fa1686fabd0056db01b81531d471724ac8", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -23,19 +23,19 @@ use libc::{c_void, uintptr_t};\n use cast::transmute;\n use super::sched::local_sched;\n use super::local_heap::LocalHeap;\n+use rt::logging::StdErrLogger;\n \n pub struct LocalServices {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n-    logger: Logger,\n+    logger: StdErrLogger,\n     unwinder: Option<Unwinder>,\n     destroyed: bool\n }\n \n pub struct GarbageCollector;\n pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n-pub struct Logger;\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -47,7 +47,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: Some(Unwinder { unwinding: false }),\n             destroyed: false\n         }\n@@ -58,7 +58,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: None,\n             destroyed: false\n         }\n@@ -169,19 +169,27 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n-pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n-    use cast::transmute_mut_region;\n-\n-    match local_sched::unsafe_borrow().current_task {\n+pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n+    match (*local_sched::unsafe_borrow()).current_task {\n         Some(~ref mut task) => {\n-            transmute_mut_region(&mut task.local_services)\n+            let s: *mut LocalServices = &mut task.local_services;\n+            return s;\n         }\n         None => {\n-            fail!(\"no local services for schedulers yet\")\n+            // Don't fail. Infinite recursion\n+            abort!(\"no local services for schedulers yet\")\n         }\n     }\n }\n \n+pub unsafe fn unsafe_try_borrow_local_services() -> Option<*mut LocalServices> {\n+    if local_sched::exists() {\n+        Some(unsafe_borrow_local_services())\n+    } else {\n+        None\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use rt::test::*;\n@@ -229,4 +237,12 @@ mod test {\n             let _ = r.next();\n         }\n     }\n+\n+    #[test]\n+    fn logging() {\n+        do run_in_newsched_task() {\n+            info!(\"here i am. logging in a newsched task\");\n+        }\n+    }\n }\n+"}, {"sha": "a0d0539768912b1a0c36f7ce23f61a054018bb94", "filename": "src/libcore/rt/logging.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flogging.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use either::*;\n+\n+pub trait Logger {\n+    fn log(&mut self, msg: Either<~str, &'static str>);\n+}\n+\n+pub struct StdErrLogger;\n+\n+impl Logger for StdErrLogger {\n+    fn log(&mut self, msg: Either<~str, &'static str>) {\n+        use io::{Writer, WriterUtil};\n+\n+        let s: &str = match msg {\n+            Left(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+            Right(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+        };\n+        let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+        dbg.write_str(s);\n+        dbg.write_str(\"\\n\");\n+        dbg.flush();\n+    }\n+}\n+\n+/// Configure logging by traversing the crate map and setting the\n+/// per-module global logging flags based on the logging spec\n+pub fn init(crate_map: *u8) {\n+    use os;\n+    use str;\n+    use ptr;\n+    use option::{Some, None};\n+    use libc::c_char;\n+\n+    let log_spec = os::getenv(\"RUST_LOG\");\n+    match log_spec {\n+        Some(spec) => {\n+            do str::as_c_str(spec) |s| {\n+                unsafe {\n+                    rust_update_log_settings(crate_map, s);\n+                }\n+            }\n+        }\n+        None => {\n+            unsafe {\n+                rust_update_log_settings(crate_map, ptr::null());\n+            }\n+        }\n+    }\n+\n+    extern {\n+        fn rust_update_log_settings(crate_map: *u8, settings: *c_char);\n+    }\n+}"}, {"sha": "7a772ff0f3b96adf119f6e5707ed7d1005d80dbf", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 130, "deletions": 38, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -8,70 +8,161 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! The Rust runtime, including the scheduler and I/O interface */\n+/*! The Rust Runtime, including the task scheduler and I/O\n+\n+The `rt` module provides the private runtime infrastructure necessary\n+to support core language features like the exchange and local heap,\n+the garbage collector, logging, local data and unwinding. It also\n+implements the default task scheduler and task model. Initialization\n+routines are provided for setting up runtime resources in common\n+configurations, including that used by `rustc` when generating\n+executables.\n+\n+It is intended that the features provided by `rt` can be factored in a\n+way such that the core library can be built with different 'profiles'\n+for different use cases, e.g. excluding the task scheduler. A number\n+of runtime features though are critical to the functioning of the\n+language and an implementation must be provided regardless of the\n+execution environment.\n+\n+Of foremost importance is the global exchange heap, in the module\n+`global_heap`. Very little practical Rust code can be written without\n+access to the global heap. Unlike most of `rt` the global heap is\n+truly a global resource and generally operates independently of the\n+rest of the runtime.\n+\n+All other runtime features are 'local', either thread-local or\n+task-local.  Those critical to the functioning of the language are\n+defined in the module `local_services`. Local services are those which\n+are expected to be available to Rust code generally but rely on\n+thread- or task-local state. These currently include the local heap,\n+the garbage collector, local storage, logging and the stack unwinder.\n+Local services are primarily implemented for tasks, but may also\n+be implemented for use outside of tasks.\n+\n+The relationship between `rt` and the rest of the core library is\n+not entirely clear yet and some modules will be moving into or\n+out of `rt` as development proceeds.\n+\n+Several modules in `core` are clients of `rt`:\n+\n+* `core::task` - The user-facing interface to the Rust task model.\n+* `core::task::local_data` - The interface to local data.\n+* `core::gc` - The garbage collector.\n+* `core::unstable::lang` - Miscellaneous lang items, some of which rely on `core::rt`.\n+* `core::condition` - Uses local data.\n+* `core::cleanup` - Local heap destruction.\n+* `core::io` - In the future `core::io` will use an `rt` implementation.\n+* `core::logging`\n+* `core::pipes`\n+* `core::comm`\n+* `core::stackwalk`\n+\n+*/\n \n #[doc(hidden)];\n \n-use libc::c_char;\n use ptr::Ptr;\n \n-#[path = \"sched/mod.rs\"]\n+/// The global (exchange) heap.\n+pub mod global_heap;\n+\n+/// The Scheduler and Coroutine types.\n mod sched;\n+\n+/// Thread-local access to the current Scheduler.\n+pub mod local_sched;\n+\n+/// Synchronous I/O.\n+#[path = \"io/mod.rs\"]\n+pub mod io;\n+\n+/// Thread-local implementations of language-critical runtime features like @.\n+pub mod local_services;\n+\n+/// The EventLoop and internal synchronous I/O interface.\n mod rtio;\n-pub mod uvll;\n-mod uvio;\n+\n+/// libuv and default rtio implementation.\n #[path = \"uv/mod.rs\"]\n-mod uv;\n-#[path = \"io/mod.rs\"]\n-mod io;\n+pub mod uv;\n+\n // FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+/// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n+\n+/// A parallel work-stealing dequeue.\n mod work_queue;\n+\n+/// Stack segments and caching.\n mod stack;\n+\n+/// CPU context swapping.\n mod context;\n+\n+/// Bindings to system threading libraries.\n mod thread;\n+\n+/// The runtime configuration, read from environment variables\n pub mod env;\n-pub mod local_services;\n+\n+/// The local, managed heap\n mod local_heap;\n \n+/// The Logger trait and implementations\n+pub mod logging;\n+\n /// Tools for testing the runtime\n-#[cfg(test)]\n pub mod test;\n \n-pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n-\n-    use self::sched::{Scheduler, Task};\n-    use self::uvio::UvEventLoop;\n-    use sys::Closure;\n-    use ptr;\n-    use cast;\n+/// Reference counting\n+pub mod rc;\n+\n+/// A simple single-threaded channel type for passing buffered data between\n+/// scheduler and task context\n+pub mod tube;\n+\n+/// Set up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This is invoked by the `start` _language item_ (unstable::lang) to\n+/// run a Rust executable.\n+///\n+/// # Arguments\n+///\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///   by os::args.\n+/// * `crate_map` - Runtime information about the executing crate, mostly for logging\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on error.\n+pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n+\n+    use self::sched::{Scheduler, Coroutine};\n+    use self::uv::uvio::UvEventLoop;\n+\n+    init(crate_map);\n \n     let loop_ = ~UvEventLoop::new();\n     let mut sched = ~Scheduler::new(loop_);\n+    let main_task = ~Coroutine::new(&mut sched.stack_pool, main);\n \n-    let main_task = ~do Task::new(&mut sched.stack_pool) {\n-\n-        unsafe {\n-            // `main` is an `fn() -> ()` that doesn't take an environment\n-            // XXX: Could also call this as an `extern \"Rust\" fn` once they work\n-            let main = Closure {\n-                code: main as *(),\n-                env: ptr::null(),\n-            };\n-            let mainfn: &fn() = cast::transmute(main);\n-\n-            mainfn();\n-        }\n-    };\n-\n-    sched.task_queue.push_back(main_task);\n+    sched.enqueue_task(main_task);\n     sched.run();\n \n     return 0;\n }\n \n+/// One-time runtime initialization. Currently all this does is set up logging\n+/// based on the RUST_LOG environment variable.\n+pub fn init(crate_map: *u8) {\n+    logging::init(crate_map);\n+}\n+\n /// Possible contexts in which Rust code may be executing.\n /// Different runtime services are available depending on context.\n+/// Mostly used for determining if we're using the new scheduler\n+/// or the old scheduler.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n     // Only the exchange heap is available\n@@ -84,6 +175,7 @@ pub enum RuntimeContext {\n     OldTaskContext\n }\n \n+/// Determine the current RuntimeContext\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n@@ -118,26 +210,26 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{local_sched, Task};\n-    use self::uvio::UvEventLoop;\n+    use self::sched::{local_sched, Coroutine};\n+    use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n \n     assert!(context() == OldTaskContext);\n     do run_in_bare_thread {\n         assert!(context() == GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n+        let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert!(context() == TaskContext);\n             let sched = local_sched::take();\n             do sched.deschedule_running_task_and_then() |task| {\n                 assert!(context() == SchedulerContext);\n                 let task = Cell(task);\n                 do local_sched::borrow |sched| {\n-                    sched.task_queue.push_back(task.take());\n+                    sched.enqueue_task(task.take());\n                 }\n             }\n         };\n-        sched.task_queue.push_back(task);\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }"}, {"sha": "1c0c8c14fdfa6404fa2be80abf552c6a55b26ef8", "filename": "src/libcore/rt/rc.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frc.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An owned, task-local, reference counted type\n+//!\n+//! # Safety note\n+//!\n+//! XXX There is currently no type-system mechanism for enforcing that\n+//! reference counted types are both allocated on the exchange heap\n+//! and also non-sendable\n+//!\n+//! This doesn't prevent borrowing multiple aliasable mutable pointers\n+\n+use ops::Drop;\n+use clone::Clone;\n+use libc::c_void;\n+use cast;\n+\n+pub struct RC<T> {\n+    p: *c_void // ~(uint, T)\n+}\n+\n+impl<T> RC<T> {\n+    pub fn new(val: T) -> RC<T> {\n+        unsafe {\n+            let v = ~(1, val);\n+            let p: *c_void = cast::transmute(v);\n+            RC { p: p }\n+        }\n+    }\n+\n+    fn get_mut_state(&mut self) -> *mut (uint, T) {\n+        unsafe {\n+            let p: &mut ~(uint, T) = cast::transmute(&mut self.p);\n+            let p: *mut (uint, T) = &mut **p;\n+            return p;\n+        }\n+    }\n+\n+    fn get_state(&self) -> *(uint, T) {\n+        unsafe {\n+            let p: &~(uint, T) = cast::transmute(&self.p);\n+            let p: *(uint, T) = &**p;\n+            return p;\n+        }\n+    }\n+\n+    pub fn unsafe_borrow_mut(&mut self) -> *mut T {\n+        unsafe {\n+            match *self.get_mut_state() {\n+                (_, ref mut p) => {\n+                    let p: *mut T = p;\n+                    return p;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn refcount(&self) -> uint {\n+        unsafe {\n+            match *self.get_state() {\n+                (count, _) => count\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RC<T> {\n+    fn finalize(&self) {\n+        assert!(self.refcount() > 0);\n+\n+        unsafe {\n+            // XXX: Mutable finalizer\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count - 1\n+                }\n+            }\n+\n+            if this.refcount() == 0 {\n+                let _: ~(uint, T) = cast::transmute(this.p);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for RC<T> {\n+    fn clone(&self) -> RC<T> {\n+        unsafe {\n+            // XXX: Mutable clone\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count + 1;\n+                }\n+            }\n+        }\n+\n+        RC { p: self.p }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::RC;\n+\n+    #[test]\n+    fn smoke_test() {\n+        unsafe {\n+            let mut v1 = RC::new(100);\n+            assert!(*v1.unsafe_borrow_mut() == 100);\n+            assert!(v1.refcount() == 1);\n+\n+            let mut v2 = v1.clone();\n+            assert!(*v2.unsafe_borrow_mut() == 100);\n+            assert!(v2.refcount() == 2);\n+\n+            *v2.unsafe_borrow_mut() = 200;\n+            assert!(*v2.unsafe_borrow_mut() == 200);\n+            assert!(*v1.unsafe_borrow_mut() == 200);\n+\n+            let v3 = v2.clone();\n+            assert!(v3.refcount() == 3);\n+            {\n+                let _v1 = v1;\n+                let _v2 = v2;\n+            }\n+            assert!(v3.refcount() == 1);\n+        }\n+    }\n+}"}, {"sha": "4b5eda22ff5de7999534237995f56ab875405dab", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -11,32 +11,35 @@\n use option::*;\n use result::*;\n \n+use rt::io::IoError;\n use super::io::net::ip::IpAddr;\n+use rt::uv::uvio;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n-pub type EventLoopObject = super::uvio::UvEventLoop;\n-pub type IoFactoryObject = super::uvio::UvIoFactory;\n-pub type StreamObject = super::uvio::UvStream;\n-pub type TcpListenerObject = super::uvio::UvTcpListener;\n+pub type EventLoopObject = uvio::UvEventLoop;\n+pub type IoFactoryObject = uvio::UvIoFactory;\n+pub type RtioTcpStreamObject = uvio::UvTcpStream;\n+pub type RtioTcpListenerObject = uvio::UvTcpListener;\n \n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n+    fn callback_ms(&mut self, ms: u64, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait IoFactory {\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject>;\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject>;\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n }\n \n-pub trait TcpListener {\n-    fn listen(&mut self) -> Option<~StreamObject>;\n+pub trait RtioTcpListener {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n }\n \n-pub trait Stream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n+pub trait RtioTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }"}, {"sha": "5c1a3410087c4d024e14a43c4b210e09398c16a3", "filename": "src/libcore/rt/sched.rs", "status": "renamed", "additions": 209, "deletions": 161, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -19,27 +19,23 @@ use super::context::Context;\n use super::local_services::LocalServices;\n use cell::Cell;\n \n-#[cfg(test)] use super::uvio::UvEventLoop;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use int;\n-\n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n \n-/// The Scheduler is responsible for coordinating execution of Tasks\n+/// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n /// thread local storage and the running task is owned by the\n /// scheduler.\n pub struct Scheduler {\n-    task_queue: WorkQueue<~Task>,\n+    priv work_queue: WorkQueue<~Coroutine>,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n     /// The scheduler's saved context.\n     /// Always valid when a task is executing, otherwise not\n     priv saved_context: Context,\n     /// The currently executing task\n-    current_task: Option<~Task>,\n+    current_task: Option<~Coroutine>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>\n@@ -49,17 +45,17 @@ pub struct Scheduler {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(~Task)) -> Self;\n-    fn to_fn(self) -> &fn(~Task);\n+    fn from_fn(&fn(~Coroutine)) -> Self;\n+    fn to_fn(self) -> &fn(~Coroutine);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(~Task)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n-    fn to_fn(self) -> &fn(~Task) { unsafe { transmute(self) } }\n+    fn from_fn(f: &fn(~Coroutine)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n+    fn to_fn(self) -> &fn(~Coroutine) { unsafe { transmute(self) } }\n }\n \n enum CleanupJob {\n     DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n+    GiveTask(~Coroutine, UnsafeTaskReceiver)\n }\n \n pub impl Scheduler {\n@@ -76,7 +72,7 @@ pub impl Scheduler {\n \n         Scheduler {\n             event_loop: event_loop,\n-            task_queue: WorkQueue::new(),\n+            work_queue: WorkQueue::new(),\n             stack_pool: StackPool::new(),\n             saved_context: Context::empty(),\n             current_task: None,\n@@ -91,43 +87,56 @@ pub impl Scheduler {\n     fn run(~self) -> ~Scheduler {\n         assert!(!self.in_task_context());\n \n-        // Give ownership of the scheduler (self) to the thread\n-        local_sched::put(self);\n+        let mut self_sched = self;\n \n         unsafe {\n-            let scheduler = local_sched::unsafe_borrow();\n-            fn run_scheduler_once() {\n-                let scheduler = local_sched::take();\n-                if scheduler.resume_task_from_queue() {\n-                    // Ok, a task ran. Nice! We'll do it again later\n-                    do local_sched::borrow |scheduler| {\n-                        scheduler.event_loop.callback(run_scheduler_once);\n-                    }\n-                }\n-            }\n+            let event_loop: *mut ~EventLoopObject = {\n+                let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n+                event_loop\n+            };\n+\n+            // Give ownership of the scheduler (self) to the thread\n+            local_sched::put(self_sched);\n \n-            scheduler.event_loop.callback(run_scheduler_once);\n-            scheduler.event_loop.run();\n+            (*event_loop).run();\n         }\n \n-        return local_sched::take();\n+        let sched = local_sched::take();\n+        assert!(sched.work_queue.is_empty());\n+        return sched;\n+    }\n+\n+    /// Schedule a task to be executed later.\n+    ///\n+    /// Pushes the task onto the work stealing queue and tells the event loop\n+    /// to run it later. Always use this instead of pushing to the work queue\n+    /// directly.\n+    fn enqueue_task(&mut self, task: ~Coroutine) {\n+        self.work_queue.push_front(task);\n+        self.event_loop.callback(resume_task_from_queue);\n+\n+        fn resume_task_from_queue() {\n+            let scheduler = local_sched::take();\n+            scheduler.resume_task_from_queue();\n+        }\n     }\n \n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(~self) -> bool {\n+    fn resume_task_from_queue(~self) {\n         assert!(!self.in_task_context());\n \n+        rtdebug!(\"looking in work queue for task to schedule\");\n+\n         let mut this = self;\n-        match this.task_queue.pop_front() {\n+        match this.work_queue.pop_front() {\n             Some(task) => {\n+                rtdebug!(\"resuming task from work queue\");\n                 this.resume_task_immediately(task);\n-                return true;\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n                 local_sched::put(this);\n-                return false;\n             }\n         }\n     }\n@@ -151,20 +160,20 @@ pub impl Scheduler {\n         abort!(\"control reached end of task\");\n     }\n \n-    fn schedule_new_task(~self, task: ~Task) {\n+    fn schedule_new_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n             do local_sched::borrow |sched| {\n-                sched.task_queue.push_front(last_task.take());\n+                sched.enqueue_task(last_task.take());\n             }\n         }\n     }\n \n     // Core scheduling ops\n \n-    fn resume_task_immediately(~self, task: ~Task) {\n+    fn resume_task_immediately(~self, task: ~Coroutine) {\n         let mut this = self;\n         assert!(!this.in_task_context());\n \n@@ -179,18 +188,18 @@ pub impl Scheduler {\n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (sched_context, _, next_task_context) = sched.get_contexts();\n+            let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n             let sched = local_sched::unsafe_borrow();\n             // The running task should have passed ownership elsewhere\n-            assert!(sched.current_task.is_none());\n+            assert!((*sched).current_task.is_none());\n \n             // Running tasks may have asked us to do some cleanup\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -202,40 +211,44 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n+    fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n-        let blocked_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        unsafe {\n+            let blocked_task = this.current_task.swap_unwrap();\n+            let f_fake_region = transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f);\n+            let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+            this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        }\n \n         local_sched::put(this);\n \n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (sched_context, last_task_context, _) = (*sched).get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n \n-        // We could be executing in a different thread now\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        sched.run_cleanup_job();\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            (*sched).run_cleanup_job();\n+        }\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_fake_region = unsafe { transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f) };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n@@ -244,14 +257,14 @@ pub impl Scheduler {\n \n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n             let sched = local_sched::unsafe_borrow();\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -301,7 +314,7 @@ pub impl Scheduler {\n         // because borrowck thinks the three patterns are conflicting\n         // borrows\n         unsafe {\n-            let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n+            let last_task = transmute::<Option<&Coroutine>, Option<&mut Coroutine>>(last_task);\n             let last_task_context = match last_task {\n                 Some(t) => Some(&mut t.saved_context), None => None\n             };\n@@ -316,9 +329,9 @@ pub impl Scheduler {\n     }\n }\n \n-static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n+static MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n \n-pub struct Task {\n+pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or,\n     /// if the task is blocked, on which the task will resume execution\n     priv current_stack_segment: StackSegment,\n@@ -329,19 +342,19 @@ pub struct Task {\n     local_services: LocalServices\n }\n \n-pub impl Task {\n-    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n-        Task::with_local(stack_pool, LocalServices::new(), start)\n+pub impl Coroutine {\n+    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n+        Coroutine::with_local(stack_pool, LocalServices::new(), start)\n     }\n \n     fn with_local(stack_pool: &mut StackPool,\n                   local_services: LocalServices,\n-                  start: ~fn()) -> Task {\n-        let start = Task::build_start_wrapper(start);\n-        let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n+                  start: ~fn()) -> Coroutine {\n+        let start = Coroutine::build_start_wrapper(start);\n+        let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n-        return Task {\n+        return Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n             local_services: local_services\n@@ -356,10 +369,10 @@ pub impl Task {\n             // have asked us to do some cleanup.\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n-                sched.run_cleanup_job();\n+                (*sched).run_cleanup_job();\n \n                 let sched = local_sched::unsafe_borrow();\n-                let task = sched.current_task.get_mut_ref();\n+                let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n                 task.local_services.run(||start());\n             }\n@@ -373,125 +386,160 @@ pub impl Task {\n     /// Destroy the task and try to reuse its components\n     fn recycle(~self, stack_pool: &mut StackPool) {\n         match self {\n-            ~Task {current_stack_segment, _} => {\n+            ~Coroutine {current_stack_segment, _} => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }\n     }\n }\n \n-#[test]\n-fn test_simple_scheduling() {\n-    do run_in_bare_thread {\n-        let mut task_ran = false;\n-        let task_ran_ptr: *mut bool = &mut task_ran;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *task_ran_ptr = true; }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n-        assert!(task_ran);\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::uv::uvio::UvEventLoop;\n+    use unstable::run_in_bare_thread;\n+    use task::spawn;\n+    use rt::test::*;\n+    use super::*;\n+\n+    #[test]\n+    fn test_simple_scheduling() {\n+        do run_in_bare_thread {\n+            let mut task_ran = false;\n+            let task_ran_ptr: *mut bool = &mut task_ran;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                unsafe { *task_ran_ptr = true; }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+            assert!(task_ran);\n+        }\n     }\n-}\n \n-#[test]\n-fn test_several_tasks() {\n-    do run_in_bare_thread {\n-        let total = 10;\n-        let mut task_count = 0;\n-        let task_count_ptr: *mut int = &mut task_count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        for int::range(0, total) |_| {\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe { *task_count_ptr = *task_count_ptr + 1; }\n-            };\n-            sched.task_queue.push_back(task);\n+    #[test]\n+    fn test_several_tasks() {\n+        do run_in_bare_thread {\n+            let total = 10;\n+            let mut task_count = 0;\n+            let task_count_ptr: *mut int = &mut task_count;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            for int::range(0, total) |_| {\n+                let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                    unsafe { *task_count_ptr = *task_count_ptr + 1; }\n+                };\n+                sched.enqueue_task(task);\n+            }\n+            sched.run();\n+            assert!(task_count == total);\n         }\n-        sched.run();\n-        assert!(task_count == total);\n     }\n-}\n \n-#[test]\n-fn test_swap_tasks_then() {\n-    do run_in_bare_thread {\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task1 = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-            let mut sched = local_sched::take();\n-            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+    #[test]\n+    fn test_swap_tasks_then() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n-            };\n-            // Context switch directly to the new task\n-            do sched.switch_running_tasks_and_then(task2) |task1| {\n-                let task1 = Cell(task1);\n-                do local_sched::borrow |sched| {\n-                    sched.task_queue.push_front(task1.take());\n+                let mut sched = local_sched::take();\n+                let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n+                    unsafe { *count_ptr = *count_ptr + 1; }\n+                };\n+                // Context switch directly to the new task\n+                do sched.switch_running_tasks_and_then(task2) |task1| {\n+                    let task1 = Cell(task1);\n+                    do local_sched::borrow |sched| {\n+                        sched.enqueue_task(task1.take());\n+                    }\n                 }\n-            }\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-        };\n-        sched.task_queue.push_back(task1);\n-        sched.run();\n-        assert!(count == 3);\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            sched.enqueue_task(task1);\n+            sched.run();\n+            assert!(count == 3);\n+        }\n     }\n-}\n \n-#[bench] #[test] #[ignore(reason = \"long test\")]\n-fn test_run_a_lot_of_tasks_queued() {\n-    do run_in_bare_thread {\n-        static MAX: int = 1000000;\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n+    #[bench] #[test] #[ignore(reason = \"long test\")]\n+    fn test_run_a_lot_of_tasks_queued() {\n+        do run_in_bare_thread {\n+            static MAX: int = 1000000;\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n \n-        let mut sched = ~UvEventLoop::new_scheduler();\n+            let mut sched = ~UvEventLoop::new_scheduler();\n \n-        let start_task = ~do Task::new(&mut sched.stack_pool) {\n-            run_task(count_ptr);\n-        };\n-        sched.task_queue.push_back(start_task);\n-        sched.run();\n+            let start_task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                run_task(count_ptr);\n+            };\n+            sched.enqueue_task(start_task);\n+            sched.run();\n \n-        assert!(count == MAX);\n+            assert!(count == MAX);\n \n-        fn run_task(count_ptr: *mut int) {\n-            do local_sched::borrow |sched| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe {\n-                        *count_ptr = *count_ptr + 1;\n-                        if *count_ptr != MAX {\n-                            run_task(count_ptr);\n+            fn run_task(count_ptr: *mut int) {\n+                do local_sched::borrow |sched| {\n+                    let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                        unsafe {\n+                            *count_ptr = *count_ptr + 1;\n+                            if *count_ptr != MAX {\n+                                run_task(count_ptr);\n+                            }\n                         }\n+                    };\n+                    sched.enqueue_task(task);\n+                }\n+            };\n+        }\n+    }\n+\n+    #[test]\n+    fn test_block_task() {\n+        do run_in_bare_thread {\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                let sched = local_sched::take();\n+                assert!(sched.in_task_context());\n+                do sched.deschedule_running_task_and_then() |task| {\n+                    let task = Cell(task);\n+                    do local_sched::borrow |sched| {\n+                        assert!(!sched.in_task_context());\n+                        sched.enqueue_task(task.take());\n                     }\n-                };\n-                sched.task_queue.push_back(task);\n-            }\n-        };\n+                }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+        }\n     }\n-}\n \n-#[test]\n-fn test_block_task() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let sched = local_sched::take();\n-            assert!(sched.in_task_context());\n-            do sched.deschedule_running_task_and_then() |task| {\n-                let task = Cell(task);\n-                do local_sched::borrow |sched| {\n-                    assert!(!sched.in_task_context());\n-                    sched.task_queue.push_back(task.take());\n+    #[test]\n+    fn test_io_callback() {\n+        // This is a regression test that when there are no schedulable tasks\n+        // in the work queue, but we are performing I/O, that once we do put\n+        // something in the work queue again the scheduler picks it up and doesn't\n+        // exit before emptying the work queue\n+        do run_in_newsched_task {\n+            do spawn {\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    let mut sched = local_sched::take();\n+                    let task = Cell(task);\n+                    do sched.event_loop.callback_ms(10) {\n+                        rtdebug!(\"in callback\");\n+                        let mut sched = local_sched::take();\n+                        sched.enqueue_task(task.take());\n+                        local_sched::put(sched);\n+                    }\n+                    local_sched::put(sched);\n                 }\n             }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+        }\n     }\n }", "previous_filename": "src/libcore/rt/sched/mod.rs"}, {"sha": "019540ce76b3fda2c9ccb35e7735e10cd97395f0", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -11,21 +11,36 @@\n use container::Container;\n use ptr::Ptr;\n use vec;\n+use ops::Drop;\n+use libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n-    buf: ~[u8]\n+    buf: ~[u8],\n+    valgrind_id: c_uint\n }\n \n pub impl StackSegment {\n     fn new(size: uint) -> StackSegment {\n-        // Crate a block of uninitialized values\n-        let mut stack = vec::with_capacity(size);\n         unsafe {\n+            // Crate a block of uninitialized values\n+            let mut stack = vec::with_capacity(size);\n             vec::raw::set_len(&mut stack, size);\n+\n+            let mut stk = StackSegment {\n+                buf: stack,\n+                valgrind_id: 0\n+            };\n+\n+            // XXX: Using the FFI to call a C macro. Slow\n+            stk.valgrind_id = rust_valgrind_stack_register(stk.start(), stk.end());\n+            return stk;\n         }\n+    }\n \n-        StackSegment {\n-            buf: stack\n+    /// Point to the low end of the allocated stack\n+    fn start(&self) -> *uint {\n+        unsafe {\n+            vec::raw::to_ptr(self.buf) as *uint\n         }\n     }\n \n@@ -37,6 +52,15 @@ pub impl StackSegment {\n     }\n }\n \n+impl Drop for StackSegment {\n+    fn finalize(&self) {\n+        unsafe {\n+            // XXX: Using the FFI to call a C macro. Slow\n+            rust_valgrind_stack_deregister(self.valgrind_id);\n+        }\n+    }\n+}\n+\n pub struct StackPool(());\n \n impl StackPool {\n@@ -49,3 +73,8 @@ impl StackPool {\n     fn give_segment(&self, _stack: StackSegment) {\n     }\n }\n+\n+extern {\n+    fn rust_valgrind_stack_register(start: *uintptr_t, end: *uintptr_t) -> c_uint;\n+    fn rust_valgrind_stack_deregister(id: c_uint);\n+}"}, {"sha": "1294b9bcf476573add0d39d15c97f30184f6e7b1", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -18,17 +18,17 @@ use rt::local_services::LocalServices;\n /// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n     use unstable::run_in_bare_thread;\n-    use super::sched::Task;\n-    use super::uvio::UvEventLoop;\n+    use super::sched::Coroutine;\n+    use rt::uv::uvio::UvEventLoop;\n \n     let f = Cell(f);\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Task::with_local(&mut sched.stack_pool,\n-                                     LocalServices::without_unwinding(),\n-                                     f.take());\n-        sched.task_queue.push_back(task);\n+        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                          LocalServices::without_unwinding(),\n+                                          f.take());\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }\n@@ -38,9 +38,9 @@ pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         let sched = local_sched::take();\n@@ -53,17 +53,57 @@ pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n-            sched.task_queue.push_front(task.take());\n+            sched.enqueue_task(task.take());\n         }\n     }\n }\n \n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_later(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n+\n+    sched.enqueue_task(task);\n+    local_sched::put(sched);\n+}\n+\n+/// Spawn a task and either run it immediately or run it later\n+pub fn spawntask_random(f: ~fn()) {\n+    use super::sched::*;\n+    use rand::{Rand, rng};\n+\n+    let mut rng = rng();\n+    let run_now: bool = Rand::rand(&mut rng);\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n+\n+    if run_now {\n+        do sched.switch_running_tasks_and_then(task) |task| {\n+            let task = Cell(task);\n+            do local_sched::borrow |sched| {\n+                sched.enqueue_task(task.take());\n+            }\n+        }\n+    } else {\n+        sched.enqueue_task(task);\n+        local_sched::put(sched);\n+    }\n+}\n+\n+\n /// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;\n@@ -82,7 +122,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n         let old_task = Cell(old_task);\n         let f = f.take();\n         let mut sched = local_sched::take();\n-        let new_task = ~do Task::new(&mut sched.stack_pool) {\n+        let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {\n@@ -92,7 +132,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n                 do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n                     let new_task = Cell(new_task);\n                     do local_sched::borrow |sched| {\n-                        sched.task_queue.push_front(new_task.take());\n+                        sched.enqueue_task(new_task.take());\n                     }\n                 }\n             }"}, {"sha": "6a08c0f59b18359d91dcb65c94991a8f8d3bd6a0", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -46,8 +46,11 @@ type pthread_key_t = ::libc::c_uint;\n \n #[cfg(unix)]\n extern {\n+    #[fast_ffi]\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    #[fast_ffi]\n     fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n+    #[fast_ffi]\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n }\n "}, {"sha": "bc9269f08faa938a268d66d0d7e587280bf46f55", "filename": "src/libcore/rt/tube.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A very simple unsynchronized channel type for sending buffered data from\n+//! scheduler context to task context.\n+//!\n+//! XXX: This would be safer to use if split into two types like Port/Chan\n+\n+use option::*;\n+use clone::Clone;\n+use super::rc::RC;\n+use rt::sched::Coroutine;\n+use rt::{context, TaskContext, SchedulerContext};\n+use rt::local_sched;\n+use vec::OwnedVector;\n+use container::Container;\n+\n+struct TubeState<T> {\n+    blocked_task: Option<~Coroutine>,\n+    buf: ~[T]\n+}\n+\n+pub struct Tube<T> {\n+    p: RC<TubeState<T>>\n+}\n+\n+impl<T> Tube<T> {\n+    pub fn new() -> Tube<T> {\n+        Tube {\n+            p: RC::new(TubeState {\n+                blocked_task: None,\n+                buf: ~[]\n+            })\n+        }\n+    }\n+\n+    pub fn send(&mut self, val: T) {\n+        rtdebug!(\"tube send\");\n+        assert!(context() == SchedulerContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            (*state).buf.push(val);\n+\n+            if (*state).blocked_task.is_some() {\n+                // There's a waiting task. Wake it up\n+                rtdebug!(\"waking blocked tube\");\n+                let task = (*state).blocked_task.swap_unwrap();\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+        }\n+    }\n+\n+    pub fn recv(&mut self) -> T {\n+        assert!(context() == TaskContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            if !(*state).buf.is_empty() {\n+                return (*state).buf.shift();\n+            } else {\n+                // Block and wait for the next message\n+                rtdebug!(\"blocking on tube recv\");\n+                assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n+                assert!((*state).blocked_task.is_none());\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    (*state).blocked_task = Some(task);\n+                }\n+                rtdebug!(\"waking after tube recv\");\n+                let buf = &mut (*state).buf;\n+                assert!(!buf.is_empty());\n+                return buf.shift();\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Tube<T> {\n+    fn clone(&self) -> Tube<T> {\n+        Tube { p: self.p.clone() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::local_sched;\n+    use rt::test::*;\n+    use rt::rtio::EventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn simple_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone_cell = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let mut tube_clone = tube_clone_cell.take();\n+                tube_clone.send(1);\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn blocking_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(Cell(Cell(tube_clone)));\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let tube_clone = tube_clone.take();\n+                do local_sched::borrow |sched| {\n+                    let tube_clone = tube_clone.take();\n+                    do sched.event_loop.callback {\n+                        let mut tube_clone = tube_clone.take();\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube_clone.send(1);\n+                    }\n+                }\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn many_blocking_test() {\n+        static MAX: int = 100;\n+\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                callback_send(tube_clone.take(), 0);\n+\n+                fn callback_send(tube: Tube<int>, i: int) {\n+                    if i == 100 { return; }\n+\n+                    let tube = Cell(Cell(tube));\n+                    do local_sched::borrow |sched| {\n+                        let tube = tube.take();\n+                        do sched.event_loop.callback {\n+                            let mut tube = tube.take();\n+                            // The task should be blocked on this now and\n+                            // sending will wake it up.\n+                            tube.send(i);\n+                            callback_send(tube, i + 1);\n+                        }\n+                    }\n+                }\n+\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            for int::range(0, MAX) |i| {\n+                let j = tube.recv();\n+                assert!(j == i);\n+            }\n+        }\n+    }\n+}"}, {"sha": "2d14505509759b70e8409c4f36afd9657240268e", "filename": "src/libcore/rt/uv/file.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -11,15 +11,11 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use super::{UvError, Callback, Request, NativeHandle, Loop};\n-use super::super::uvll;\n-use super::super::uvll::*;\n-\n-pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n-impl Callback for FsCallback { }\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback};\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n \n pub struct FsRequest(*uvll::uv_fs_t);\n-\n impl Request for FsRequest;\n \n impl FsRequest {"}, {"sha": "2cf0b5c4872889d94e61e82dd1579b6eaeec1d68", "filename": "src/libcore/rt/uv/idle.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fidle.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_int;\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+impl Watcher for IdleWatcher { }\n+\n+pub impl IdleWatcher {\n+    fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.idle_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        // NB: Not resetting the Rust idle_cb to None here because `stop` is likely\n+        // called from *within* the idle callback, causing a use after free\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_stop(self.native_handle()));\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            unsafe {\n+                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+                {\n+                    let data = idle_watcher.get_watcher_data();\n+                    data.close_cb.swap_unwrap()();\n+                }\n+                idle_watcher.drop_watcher_data();\n+                uvll::idle_delete(handle);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "93cafb835884aa36af2872c081581021316db552", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 159, "deletions": 194, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n \n-Bindings to libuv.\n+Bindings to libuv, along with the default implementation of `core::rt::rtio`.\n \n UV types consist of the event loop (Loop), Watchers, Requests and\n Callbacks.\n@@ -38,56 +38,63 @@ use container::Container;\n use option::*;\n use str::raw::from_c_str;\n use to_str::ToStr;\n+use ptr::Ptr;\n+use libc;\n use vec;\n use ptr;\n-use ptr::Ptr;\n+use cast;\n+use str;\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n-use super::uvll;\n use unstable::finally::Finally;\n \n+use rt::io::IoError;\n+\n #[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::{FsRequest, FsCallback};\n+pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher};\n-pub use self::net::{ReadCallback, AllocCallback, ConnectionCallback, ConnectCallback};\n+pub use self::idle::IdleWatcher;\n+pub use self::timer::TimerWatcher;\n+\n+/// The implementation of `rtio` for libuv\n+pub mod uvio;\n+\n+/// C bindings to libuv\n+pub mod uvll;\n \n pub mod file;\n pub mod net;\n+pub mod idle;\n+pub mod timer;\n \n-/// A trait for callbacks to implement. Provides a little extra type safety\n-/// for generic, unsafe interop functions like `set_watcher_callback`.\n-pub trait Callback { }\n-\n-pub trait Request { }\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n \n /// The trait implemented by uv 'watchers' (handles). Watchers are\n /// non-owning wrappers around the uv handles and are not completely\n /// safe - there may be multiple instances for a single underlying\n /// handle.  Watchers are generally created, then `start`ed, `stop`ed\n /// and `close`ed, but due to their complex life cycle may not be\n /// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n+pub trait Watcher { }\n \n-pub type NullCallback = ~fn();\n-impl Callback for NullCallback { }\n+pub trait Request { }\n \n /// A type that wraps a native handle\n pub trait NativeHandle<T> {\n     pub fn from_native_handle(T) -> Self;\n     pub fn native_handle(&self) -> T;\n }\n \n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *uvll::uv_loop_t\n-}\n-\n pub impl Loop {\n     fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n@@ -113,64 +120,74 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n     }\n }\n \n-pub struct IdleWatcher(*uvll::uv_idle_t);\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+pub type NullCallback = ~fn();\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n \n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>,\n+    idle_cb: Option<IdleCallback>,\n+    timer_cb: Option<TimerCallback>\n }\n \n-pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-impl Callback for IdleCallback { }\n+pub trait WatcherInterop {\n+    fn event_loop(&self) -> Loop;\n+    fn install_watcher_data(&mut self);\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n+    fn drop_watcher_data(&mut self);\n+}\n \n-pub impl IdleWatcher {\n-    fn new(loop_: &mut Loop) -> IdleWatcher {\n+impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n+    /// Get the uv event loop from a Watcher\n+    pub fn event_loop(&self) -> Loop {\n         unsafe {\n-            let handle = uvll::idle_new();\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n+            let handle = self.native_handle();\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            NativeHandle::from_native_handle(loop_)\n         }\n     }\n \n-    fn start(&mut self, cb: IdleCallback) {\n-\n-        set_watcher_callback(self, cb);\n+    pub fn install_watcher_data(&mut self) {\n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n-            let status = status_to_maybe_uv_error(handle, status);\n-            (*cb)(idle_watcher, status);\n+            let data = ~WatcherData {\n+                read_cb: None,\n+                write_cb: None,\n+                connect_cb: None,\n+                close_cb: None,\n+                alloc_cb: None,\n+                idle_cb: None,\n+                timer_cb: None\n+            };\n+            let data = transmute::<~WatcherData, *c_void>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n         }\n     }\n \n-    fn stop(&mut self) {\n-        unsafe { assert!(0 == uvll::idle_stop(self.native_handle())); }\n-    }\n-\n-    fn close(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n+    pub fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+            return &mut **data;\n         }\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n+    pub fn drop_watcher_data(&mut self) {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~WatcherData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+        }\n     }\n }\n \n@@ -198,6 +215,10 @@ pub impl UvError {\n             from_c_str(desc_str)\n         }\n     }\n+\n+    fn is_eof(&self) -> bool {\n+        self.code == uvll::EOF\n+    }\n }\n \n impl ToStr for UvError {\n@@ -213,148 +234,74 @@ fn error_smoke_test() {\n     assert!(err.to_str() == ~\"EOF: end of file\");\n }\n \n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n-}\n-\n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n-}\n-\n-/// Delete a callback from a handle's custom data\n-pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n     unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-        }\n+        let loop_ = watcher.event_loop();\n+        UvError(uvll::last_error(loop_.native_handle()))\n     }\n }\n \n-/// Take a pointer to the callback installed as custom data\n-pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n-    }\n-}\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n \n-/// Take ownership of the callback installed as custom data\n-pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n+    // XXX: Could go in str::raw\n+    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s, len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len);\n+        }\n \n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n+        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n     }\n-}\n \n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-    buf: Option<Buf>\n-}\n \n-pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n     unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None,\n-            buf: None\n+        // Importing error constants\n+        use rt::uv::uvll::*;\n+        use rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(&*uverr);\n+        let desc = c_str_to_static_slice(c_desc);\n+\n+        let kind = match uverr.code {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            ECONNRESET => ConnectionReset,\n+            EPIPE => BrokenPipe,\n+            e => {\n+                rtdebug!(\"e %u\", e as uint);\n+                // XXX: Need to map remaining uv error types\n+                OtherIoError\n+            }\n         };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n-    }\n-}\n \n-pub fn get_watcher_data<'r, H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &'r mut W) -> &'r mut WatcherData {\n-\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n-    }\n-}\n-\n-pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n     }\n }\n \n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    assert!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n     }\n-\n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n }\n \n /// The uv buffer type\n@@ -394,6 +341,24 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n     }\n }\n \n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    assert!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n+}\n+\n+\n #[test]\n fn loop_smoke_test() {\n     do run_in_bare_thread {\n@@ -409,7 +374,7 @@ fn idle_new_then_close() {\n     do run_in_bare_thread {\n         let mut loop_ = Loop::new();\n         let idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        idle_watcher.close();\n+        idle_watcher.close(||());\n     }\n }\n \n@@ -425,7 +390,7 @@ fn idle_smoke_test() {\n             assert!(status.is_none());\n             if unsafe { *count_ptr == 10 } {\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             } else {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             }\n@@ -449,7 +414,7 @@ fn idle_start_stop_start() {\n                 assert!(status.is_none());\n                 let mut idle_watcher = idle_watcher;\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             }\n         }\n         loop_.run();"}, {"sha": "bdd5588014c01436aa4934abfe064b4115746107", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 145, "deletions": 156, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -10,21 +10,15 @@\n \n use prelude::*;\n use libc::{size_t, ssize_t, c_int, c_void};\n-use cast::transmute_mut_region;\n-use super::super::uvll;\n-use super::super::uvll::*;\n-use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n-            loop_from_watcher, status_to_maybe_uv_error,\n-            install_watcher_data, get_watcher_data, drop_watcher_data,\n-            vec_to_uv_buf, vec_from_uv_buf};\n-use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n-\n-#[cfg(test)] use cell::Cell;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::super::thread::Thread;\n-#[cfg(test)] use super::super::test::*;\n-\n-fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n+use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n+             status_to_maybe_uv_error};\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::uv::last_uv_error;\n+\n+fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n             unsafe {\n@@ -34,7 +28,7 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n                                                 c as uint,\n                                                 d as uint), p as int);\n                 do (|| {\n-                    f(addr);\n+                    f(addr)\n                 }).finally {\n                     free_ip4_addr(addr);\n                 }\n@@ -47,34 +41,23 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n-\n-impl Watcher for StreamWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-impl Callback for ReadCallback { }\n-\n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-impl Callback for AllocCallback { }\n+impl Watcher for StreamWatcher { }\n \n pub impl StreamWatcher {\n \n     fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        // XXX: Borrowchk problems\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        data.alloc_cb = Some(alloc);\n-        data.read_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.read_cb = Some(cb);\n+        }\n \n         let handle = self.native_handle();\n         unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let alloc_cb = data.alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n@@ -83,7 +66,7 @@ pub impl StreamWatcher {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let cb = data.read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n@@ -98,31 +81,27 @@ pub impl StreamWatcher {\n         unsafe { uvll::read_stop(handle); }\n     }\n \n-    // XXX: Needs to take &[u8], not ~[u8]\n-    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.write_cb.is_none());\n-        data.write_cb = Some(cb);\n+    fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.write_cb.is_none());\n+            data.write_cb = Some(cb);\n+        }\n \n         let req = WriteRequest::new();\n-        let buf = vec_to_uv_buf(msg);\n-        assert!(data.buf.is_none());\n-        data.buf = Some(buf);\n         let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n-                                          self.native_handle(),\n-                                          bufs, write_cb));\n+                                     self.native_handle(),\n+                                     bufs, write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = {\n-                let data = get_watcher_data(&mut stream_watcher);\n-                let _vec = vec_from_uv_buf(data.buf.swap_unwrap());\n+                let data = stream_watcher.get_watcher_data();\n                 let cb = data.write_cb.swap_unwrap();\n                 cb\n             };\n@@ -142,7 +121,7 @@ pub impl StreamWatcher {\n     fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n-            let data = get_watcher_data(&mut this);\n+            let data = this.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n@@ -152,9 +131,10 @@ pub impl StreamWatcher {\n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             {\n-                get_watcher_data(&mut stream_watcher).close_cb.swap_unwrap()();\n+                let data = stream_watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n             }\n-            drop_watcher_data(&mut stream_watcher);\n+            stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n@@ -171,37 +151,32 @@ impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n }\n \n pub struct TcpWatcher(*uvll::uv_tcp_t);\n-\n-impl Watcher for TcpWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-impl Callback for ConnectionCallback { }\n+impl Watcher for TcpWatcher { }\n \n pub impl TcpWatcher {\n     fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n             assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher = NativeHandle::from_native_handle(handle);\n-            install_watcher_data(&mut watcher);\n+            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n             return watcher;\n         }\n     }\n \n-    fn bind(&mut self, address: IpAddr) {\n+    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n                     let result = unsafe {\n                         uvll::tcp_bind(self.native_handle(), addr)\n                     };\n-                    // XXX: bind is likely to fail. need real error handling\n-                    assert!(result == 0);\n+                    if result == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(last_uv_error(self))\n+                    }\n                 }\n             }\n             _ => fail!()\n@@ -210,8 +185,8 @@ pub impl TcpWatcher {\n \n     fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n-            assert!(get_watcher_data(self).connect_cb.is_none());\n-            get_watcher_data(self).connect_cb = Some(cb);\n+            assert!(self.get_watcher_data().connect_cb.is_none());\n+            self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n             match address {\n@@ -232,7 +207,7 @@ pub impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb: ConnectionCallback = {\n-                    let data = get_watcher_data(&mut stream_watcher);\n+                    let data = stream_watcher.get_watcher_data();\n                     data.connect_cb.swap_unwrap()\n                 };\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n@@ -242,10 +217,11 @@ pub impl TcpWatcher {\n     }\n \n     fn listen(&mut self, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.connect_cb.is_none());\n-        data.connect_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n \n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n@@ -257,9 +233,10 @@ pub impl TcpWatcher {\n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = get_watcher_data(&mut stream_watcher).connect_cb.swap_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n-            cb(stream_watcher, status);\n+            let data = stream_watcher.get_watcher_data();\n+            let cb = data.connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(stream_watcher, status);\n         }\n     }\n \n@@ -277,12 +254,8 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n-pub type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n-impl Callback for ConnectCallback { }\n-\n // uv_connect_t is a subclass of uv_req_t\n struct ConnectRequest(*uvll::uv_connect_t);\n-\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n@@ -355,93 +328,109 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n }\n \n \n-#[test]\n-fn connect_close() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        // Connect to a port where nobody is listening\n-        let addr = next_test_ip4();\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_some());\n-            assert!(status.get().name() == ~\"ECONNREFUSED\");\n-            stream_watcher.close(||());\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::ignore;\n+    use cell::Cell;\n+    use vec;\n+    use unstable::run_in_bare_thread;\n+    use rt::thread::Thread;\n+    use rt::test::*;\n+    use rt::uv::{Loop, AllocCallback};\n+    use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+\n+    #[test]\n+    fn connect_close() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert!(status.get().name() == ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n         }\n-        loop_.run();\n-        loop_.close();\n     }\n-}\n \n-#[test]\n-fn listen() {\n-    do run_in_bare_thread() {\n-        static MAX: int = 10;\n-        let mut loop_ = Loop::new();\n-        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = next_test_ip4();\n-        server_tcp_watcher.bind(addr);\n-        let loop_ = loop_;\n-        rtdebug!(\"listening\");\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n-            rtdebug!(\"listened!\");\n-            assert!(status.is_none());\n-            let mut server_stream_watcher = server_stream_watcher;\n-            let mut loop_ = loop_;\n-            let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-            server_stream_watcher.accept(client_tcp_watcher);\n-            let count_cell = Cell(0);\n-            let server_stream_watcher = server_stream_watcher;\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do client_tcp_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                rtdebug!(\"i'm reading!\");\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = count_cell.take();\n-                if status.is_none() {\n-                    rtdebug!(\"got %d bytes\", nread);\n-                    let buf = buf.unwrap();\n-                    for buf.slice(0, nread as uint).each |byte| {\n-                        assert!(*byte == count as u8);\n-                        rtdebug!(\"%u\", *byte as uint);\n-                        count += 1;\n-                    }\n-                } else {\n-                    assert!(count == MAX);\n-                    do stream_watcher.close {\n-                        server_stream_watcher.close(||());\n+    #[test]\n+    fn listen() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc)\n+                    |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).each |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert!(count == MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n                     }\n+                    count_cell.put_back(count);\n                 }\n-                count_cell.put_back(count);\n             }\n-        }\n \n-        let _client_thread = do Thread::start {\n-            rtdebug!(\"starting client thread\");\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connecting\");\n-                assert!(status.is_none());\n-                let mut stream_watcher = stream_watcher;\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                do stream_watcher.write(msg) |stream_watcher, status| {\n-                    rtdebug!(\"writing\");\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    stream_watcher.close(||());\n+                    let mut stream_watcher = stream_watcher;\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n                 }\n-            }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n             loop_.run();\n             loop_.close();\n-        };\n-\n-        let mut loop_ = loop_;\n-        loop_.run();\n-        loop_.close();\n+        }\n     }\n }"}, {"sha": "5557a58098751bceab944e81df1c2e6e6ff709cd", "filename": "src/libcore/rt/uv/timer.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{c_void, c_int};\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct TimerWatcher(*uvll::uv_timer_t);\n+impl Watcher for TimerWatcher { }\n+\n+impl TimerWatcher {\n+    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.timer_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+        }\n+\n+        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.timer_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::timer_stop(self.native_handle());\n+        }\n+    }\n+\n+    pub fn close(self, cb: NullCallback) {\n+        let mut watcher = self;\n+        {\n+            let data = watcher.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::close(watcher.native_handle(), close_cb);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_timer_t) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let data = watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n+            }\n+            watcher.drop_watcher_data();\n+            unsafe {\n+                uvll::free_handle(handle as *c_void);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n+    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n+        TimerWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &TimerWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::uv::Loop;\n+    use unstable::run_in_bare_thread;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                timer.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn start_twice() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                let mut timer = timer;\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                do timer.start(10, 0) |timer, status| {\n+                    assert!(status.is_none());\n+                    unsafe { *count_ptr += 1 };\n+                    timer.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn repeat_stop() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 20) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe {\n+                    *count_ptr += 1;\n+\n+                    if *count_ptr == 10 {\n+\n+                        // Stop the timer and do something else\n+                        let mut timer = timer;\n+                        timer.stop();\n+                        // Freeze timer so it can be captured\n+                        let timer = timer;\n+\n+                        let mut loop_ = timer.event_loop();\n+                        let mut timer2 = TimerWatcher::new(&mut loop_);\n+                        do timer2.start(10, 0) |timer2, _| {\n+\n+                            unsafe { *count_ptr += 1; }\n+\n+                            timer2.close(||());\n+\n+                            // Restart the original timer\n+                            let mut timer = timer;\n+                            do timer.start(10, 0) |timer, _| {\n+                                unsafe { *count_ptr += 1; }\n+                                timer.close(||());\n+                            }\n+                        }\n+                    }\n+                };\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 12);\n+        }\n+    }\n+\n+}"}, {"sha": "ce4eb6aff870126c0ae1fc7390e5484ec414e4e3", "filename": "src/libcore/rt/uv/uvio.rs", "status": "renamed", "additions": 162, "deletions": 129, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -10,20 +10,24 @@\n \n use option::*;\n use result::*;\n-\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n use ops::Drop;\n use old_iter::CopyableIter;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n+use clone::Clone;\n+use rt::io::IoError;\n+use rt::io::net::ip::IpAddr;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::rtio::*;\n+use rt::sched::{Scheduler, local_sched};\n+use rt::io::{standard_error, OtherIoError};\n+use rt::tube::Tube;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n+#[cfg(test)] use rt::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -64,7 +68,16 @@ impl EventLoop for UvEventLoop {\n             assert!(status.is_none());\n             let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n-            idle_watcher.close();\n+            idle_watcher.close(||());\n+            f();\n+        }\n+    }\n+\n+    fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n+        let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n+        do timer.start(ms, 0) |timer, status| {\n+            assert!(status.is_none());\n+            timer.close(||());\n             f();\n         }\n     }\n@@ -100,11 +113,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -122,125 +135,151 @@ impl IoFactory for UvIoFactory {\n             // Wait for a connection\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"connect: in connect callback\");\n-                let maybe_stream = if status.is_none() {\n+                if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n+                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+\n+                    // Store the stream in the task's stack\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                    // Context switch\n+                    let scheduler = local_sched::take();\n+                    scheduler.resume_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n-                    stream_watcher.close(||());\n-                    None\n+                    let task_cell = Cell(task_cell.take());\n+                    do stream_watcher.close {\n+                        let res = Err(uv_error_to_io_error(status.get()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n                 };\n-\n-                // Store the stream in the task's stack\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Err(uverr) => {\n+                let scheduler = local_sched::take();\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task_cell = Cell(task);\n+                    do watcher.as_stream().close {\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n     }\n }\n \n-pub struct UvTcpListener(TcpWatcher);\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpListener {\n+    watcher: TcpWatcher,\n+    listening: bool,\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+}\n \n impl UvTcpListener {\n-    fn watcher(&self) -> TcpWatcher {\n-        match self { &UvTcpListener(w) => w }\n+    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+        UvTcpListener {\n+            watcher: watcher,\n+            listening: false,\n+            incoming_streams: Tube::new()\n+        }\n     }\n \n-    fn close(&self) {\n-        // XXX: Need to wait until close finishes before returning\n-        self.watcher().as_stream().close(||());\n-    }\n+    fn watcher(&self) -> TcpWatcher { self.watcher }\n }\n \n impl Drop for UvTcpListener {\n     fn finalize(&self) {\n-        // XXX: Again, this never gets called. Use .close() instead\n-        //self.watcher().as_stream().close(||());\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.as_stream().close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl TcpListener for UvTcpListener {\n+impl RtioTcpListener for UvTcpListener {\n \n-    fn listen(&mut self) -> Option<~StreamObject> {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         rtdebug!(\"entering listen\");\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let server_tcp_watcher = self.watcher();\n \n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n+        if self.listening {\n+            return self.incoming_streams.recv();\n+        }\n \n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n-                } else {\n-                    None\n-                };\n+        self.listening = true;\n \n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+        let server_tcp_watcher = self.watcher();\n+        let incoming_streams_cell = Cell(self.incoming_streams.clone());\n+\n+        let incoming_streams_cell = Cell(incoming_streams_cell.take());\n+        let mut server_tcp_watcher = server_tcp_watcher;\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            let maybe_stream = if status.is_none() {\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = server_stream_watcher.event_loop();\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                // XXX: Need's to be surfaced in interface\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+            } else {\n+                Err(standard_error(OtherIoError))\n+            };\n \n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n+            let mut incoming_streams = incoming_streams_cell.take();\n+            incoming_streams.send(maybe_stream);\n+            incoming_streams_cell.put_back(incoming_streams);\n         }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+        return self.incoming_streams.recv();\n     }\n }\n \n-pub struct UvStream(StreamWatcher);\n-\n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n-    }\n-\n-    fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n-    }\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream {\n+    watcher: StreamWatcher\n+}\n \n-    // XXX: finalize isn't working for ~UvStream???\n-    fn close(&self) {\n-        // XXX: Need to wait until this finishes before returning\n-        self.watcher().close(||());\n-    }\n+impl UvTcpStream {\n+    fn watcher(&self) -> StreamWatcher { self.watcher }\n }\n \n-impl Drop for UvStream {\n+impl Drop for UvTcpStream {\n     fn finalize(&self) {\n-        rtdebug!(\"closing stream\");\n-        //self.watcher().close(||());\n+        rtdebug!(\"closing tcp stream\");\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -271,7 +310,7 @@ impl Stream for UvStream {\n                     assert!(nread >= 0);\n                     Ok(nread as uint)\n                 } else {\n-                    Err(())\n+                    Err(uv_error_to_io_error(status.unwrap()))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -285,24 +324,22 @@ impl Stream for UvStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n-            let buf = unsafe { &*buf_ptr };\n-            // XXX: OMGCOPIES\n-            let buf = buf.to_vec();\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n                 } else {\n-                    Err(())\n+                    Err(uv_error_to_io_error(status.unwrap()))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -320,10 +357,12 @@ impl Stream for UvStream {\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n+        unsafe {\n+            let io = local_sched::unsafe_borrow_io();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n     }\n }\n \n@@ -336,26 +375,23 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert!(nread == 8);\n                 for uint::range(0, nread) |i| {\n                     rtdebug!(\"%u\", buf[i] as uint);\n                     assert!(buf[i] == i as u8);\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n             }\n         }\n     }\n@@ -368,8 +404,8 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n+            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -392,26 +428,24 @@ fn test_read_and_block() {\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n                     do local_sched::borrow |scheduler| {\n-                        scheduler.task_queue.push_back(task.take());\n+                        scheduler.enqueue_task(task.take());\n                     }\n                 }\n             }\n \n             // Make sure we had multiple reads\n             assert!(reads > 1);\n-\n-            stream.close();\n-            listener.close();\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n         }\n \n     }\n@@ -426,34 +460,33 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n                     stream.write(buf);\n                     total_bytes_written += buf.len();\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert!(buf[i] == 1);\n+                    }\n                 }\n+                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n             }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n         }\n     }\n }", "previous_filename": "src/libcore/rt/uvio.rs"}, {"sha": "94e1703b263de45fa4c5ac86f5c76ac02a6b115b", "filename": "src/libcore/rt/uv/uvll.rs", "status": "renamed", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -33,6 +33,15 @@ use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use prelude::*;\n \n+pub static UNKNOWN: c_int = -1;\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+pub static ECONNRESET: c_int = 13;\n+pub static EPIPE: c_int = 36;\n+\n pub struct uv_err_t {\n     code: c_int,\n     sys_errno_: c_int\n@@ -260,9 +269,9 @@ pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                          repeat: uint) -> c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint, repeat as c_uint);\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n+                          repeat: u64) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_stop(timer_ptr);\n@@ -423,8 +432,8 @@ extern {\n                           timer_handle: *uv_timer_t) -> c_int;\n     fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n                            cb: *u8,\n-                           timeout: c_uint,\n-                           repeat: c_uint) -> c_int;\n+                           timeout: libc::uint64_t,\n+                           repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n \n     fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;", "previous_filename": "src/libcore/rt/uvll.rs"}, {"sha": "f82b5847ef2b8a7562588357d39f2eee252721f6", "filename": "src/libcore/rt/work_queue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -46,4 +46,8 @@ pub impl<T> WorkQueue<T> {\n             None\n         }\n     }\n+\n+    fn is_empty(&self) -> bool {\n+        return self.queue.is_empty();\n+    }\n }"}, {"sha": "50a739ec67df7616268578fb6c0f5fca7a2542e4", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -202,10 +202,12 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use rt::{context, OldTaskContext};\n-    use rt::local_services::unsafe_borrow_local_services;\n+    use option::Option;\n+    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n \n-    match context() {\n+    let context = context();\n+    match context {\n         OldTaskContext => {\n             unsafe {\n                 gc::cleanup_stack_for_failure();\n@@ -214,11 +216,26 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             }\n         }\n         _ => {\n-            // XXX: Need to print the failure message\n-            gc::cleanup_stack_for_failure();\n             unsafe {\n+                // XXX: Bad re-allocations. fail! needs some refactoring\n+                let msg = str::raw::from_c_str(msg);\n+                let file = str::raw::from_c_str(file);\n+\n+                let outmsg = fmt!(\"%s at line %i of file %s\", msg, line as int, file);\n+\n+                // XXX: Logging doesn't work correctly in non-task context because it\n+                // invokes the local heap\n+                if context == TaskContext {\n+                    error!(outmsg);\n+                } else {\n+                    rtdebug!(\"%s\", outmsg);\n+                }\n+\n+                gc::cleanup_stack_for_failure();\n+\n                 let local_services = unsafe_borrow_local_services();\n-                match local_services.unwinder {\n+                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")\n                 }"}, {"sha": "be4e639e94c32e2e1f9cb8568e195a686ac0f0b3", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -36,7 +36,7 @@ impl Handle {\n                 }\n                 _ => {\n                     let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut local_services.storage)\n+                    NewHandle(&mut (*local_services).storage)\n                 }\n             }\n         }"}, {"sha": "a6edee38e188a6668d0b5fdd6c76e9a63ca9de88", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -43,6 +43,7 @@ use task::rt::{task_id, sched_id};\n use util;\n use util::replace;\n use unstable::finally::Finally;\n+use rt::{context, OldTaskContext};\n \n #[cfg(test)] use comm::SharedChan;\n \n@@ -558,23 +559,33 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_inhibit_kill(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_inhibit_kill(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_allow_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_allow_kill(t);\n     }\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_allow_kill(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_allow_kill(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_inhibit_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_inhibit_kill(t);\n     }\n }\n \n@@ -583,14 +594,19 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_inhibit_kill(t);\n-        rt::rust_task_inhibit_yield(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_inhibit_kill(t);\n+            rt::rust_task_inhibit_yield(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_allow_yield(t);\n+            rt::rust_task_allow_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_allow_yield(t);\n-        rt::rust_task_allow_kill(t);\n     }\n }\n "}, {"sha": "5f9642604d0c14c761c9310d101d1f55eb859a2f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -581,7 +581,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::new(&mut sched.stack_pool, f);\n+    let task = ~Coroutine::new(&mut sched.stack_pool, f);\n     sched.schedule_new_task(task);\n }\n "}, {"sha": "1249392484d235e98176bfc3f406154d3ea03f9f", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -16,12 +16,12 @@ use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n-use unstable::exchange_alloc;\n use cast::transmute;\n use rt::{context, OldTaskContext};\n use rt::local_services::borrow_local_services;\n use option::{Option, Some, None};\n use io;\n+use rt::global_heap;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -153,7 +153,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n #[lang=\"exchange_malloc\"]\n #[inline(always)]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n+    transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n \n /// Because this code is so perf. sensitive, use a static constant so that\n@@ -233,7 +233,7 @@ impl DebugPrints for io::fd_t {\n #[lang=\"exchange_free\"]\n #[inline(always)]\n pub unsafe fn exchange_free(ptr: *c_char) {\n-    exchange_alloc::free(transmute(ptr))\n+    global_heap::free(transmute(ptr))\n }\n \n #[lang=\"malloc\"]\n@@ -423,18 +423,31 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n #[lang=\"start\"]\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n-    use libc::getenv;\n-    use rt::start;\n+    use rt;\n+    use sys::Closure;\n+    use ptr;\n+    use cast;\n+    use os;\n \n     unsafe {\n-        let use_old_rt = do str::as_c_str(\"RUST_NEWRT\") |s| {\n-            getenv(s).is_null()\n-        };\n+        let use_old_rt = os::getenv(\"RUST_NEWRT\").is_none();\n         if use_old_rt {\n             return rust_start(main as *c_void, argc as c_int, argv,\n                               crate_map as *c_void) as int;\n         } else {\n-            return start(main, argc, argv, crate_map);\n+            return do rt::start(argc, argv as **u8, crate_map) {\n+                unsafe {\n+                    // `main` is an `fn() -> ()` that doesn't take an environment\n+                    // XXX: Could also call this as an `extern \"Rust\" fn` once they work\n+                    let main = Closure {\n+                        code: main as *(),\n+                        env: ptr::null(),\n+                    };\n+                    let mainfn: &fn() = cast::transmute(main);\n+\n+                    mainfn();\n+                }\n+            };\n         }\n     }\n "}, {"sha": "18a6262f17de99b2b78ccef78a120b8a8e1d57c0", "filename": "src/libcore/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -19,7 +19,6 @@ pub mod at_exit;\n pub mod global;\n pub mod finally;\n pub mod weak_task;\n-pub mod exchange_alloc;\n pub mod intrinsics;\n pub mod simd;\n pub mod extfmt;"}, {"sha": "bc7703ec30a1c69ebc60aab43545aa2690fe5732", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -819,8 +819,8 @@ extern {\n     unsafe fn rust_uv_timer_start(\n         timer_handle: *uv_timer_t,\n         cb: *u8,\n-        timeout: libc::c_uint,\n-        repeat: libc::c_uint) -> libc::c_int;\n+        timeout: libc::uint64_t,\n+        repeat: libc::uint64_t) -> libc::c_int;\n     unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n \n     unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n@@ -1084,8 +1084,8 @@ pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n                       repeat: uint) -> libc::c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n-                                    repeat as libc::c_uint);\n+    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::uint64_t,\n+                               repeat as libc::uint64_t);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n     return rust_uv_timer_stop(timer_ptr);"}, {"sha": "218ab86721eefd7b7e97fa6d9f95a80a1fa8686c", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -1 +1 @@\n-Subproject commit 97ac7c087a0caf6b0f611b80e14f7fe3cb18bb27\n+Subproject commit 218ab86721eefd7b7e97fa6d9f95a80a1fa8686c"}, {"sha": "1a64066b5a946468505d7dcede48ba8b4cc4ab2a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -830,14 +830,14 @@ rust_get_rt_env() {\n }\n \n #ifndef _WIN32\n-pthread_key_t sched_key;\n+pthread_key_t rt_key = -1;\n #else\n-DWORD sched_key;\n+DWORD rt_key = -1;\n #endif\n \n extern \"C\" void*\n-rust_get_sched_tls_key() {\n-    return &sched_key;\n+rust_get_rt_tls_key() {\n+    return &rt_key;\n }\n \n // Initialize the global state required by the new scheduler\n@@ -852,10 +852,10 @@ rust_initialize_global_state() {\n     if (!initialized) {\n \n #ifndef _WIN32\n-        assert(!pthread_key_create(&sched_key, NULL));\n+        assert(!pthread_key_create(&rt_key, NULL));\n #else\n-        sched_key = TlsAlloc();\n-        assert(sched_key != TLS_OUT_OF_INDEXES);\n+        rt_key = TlsAlloc();\n+        assert(rt_key != TLS_OUT_OF_INDEXES);\n #endif\n \n         initialized = true;"}, {"sha": "ed38be3550f74f1ab6ce1d2a0654e2e316e39200", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -13,6 +13,7 @@\n // that might come from the environment is loaded here, once, during\n // init.\n \n+#include \"sync/lock_and_signal.h\"\n #include \"rust_env.h\"\n \n // The environment variables that the runtime knows about\n@@ -26,6 +27,18 @@\n #define RUST_DEBUG_MEM \"RUST_DEBUG_MEM\"\n #define RUST_DEBUG_BORROW \"RUST_DEBUG_BORROW\"\n \n+static lock_and_signal env_lock;\n+\n+extern \"C\" CDECL void\n+rust_take_env_lock() {\n+    env_lock.lock();\n+}\n+\n+extern \"C\" CDECL void\n+rust_drop_env_lock() {\n+    env_lock.unlock();\n+}\n+\n #if defined(__WIN32__)\n static int\n get_num_cpus() {\n@@ -119,6 +132,8 @@ copyenv(const char* name) {\n \n rust_env*\n load_env(int argc, char **argv) {\n+    scoped_lock with(env_lock);\n+\n     rust_env *env = (rust_env*)malloc(sizeof(rust_env));\n \n     env->num_sched_threads = (size_t)get_num_threads();\n@@ -141,3 +156,4 @@ free_env(rust_env *env) {\n     free(env->rust_seed);\n     free(env);\n }\n+"}, {"sha": "89257dc9f6e432172d4cb5729b89cc851cecfbdf", "filename": "src/rt/rust_exchange_alloc.cpp", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_exchange_alloc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_exchange_alloc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -15,14 +15,15 @@\n #include <string.h>\n #include <stdio.h>\n \n-uintptr_t exchange_count = 0;\n+extern uintptr_t rust_exchange_count;\n+uintptr_t rust_exchange_count = 0;\n \n void *\n rust_exchange_alloc::malloc(size_t size) {\n   void *value = ::malloc(size);\n   assert(value);\n \n-  sync::increment(exchange_count);\n+  sync::increment(rust_exchange_count);\n \n   return value;\n }\n@@ -36,20 +37,15 @@ rust_exchange_alloc::realloc(void *ptr, size_t size) {\n \n void\n rust_exchange_alloc::free(void *ptr) {\n-  sync::decrement(exchange_count);\n+  sync::decrement(rust_exchange_count);\n   ::free(ptr);\n }\n \n-extern \"C\" uintptr_t *\n-rust_get_exchange_count_ptr() {\n-  return &exchange_count;\n-}\n-\n void\n rust_check_exchange_count_on_exit() {\n-  if (exchange_count != 0) {\n+  if (rust_exchange_count != 0) {\n     printf(\"exchange heap not empty on exit\\n\");\n-    printf(\"%d dangling allocations\\n\", (int)exchange_count);\n+    printf(\"%d dangling allocations\\n\", (int)rust_exchange_count);\n     abort();\n   }\n }"}, {"sha": "df24f569495b49314c751e81e7df3d714c3817fb", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -324,6 +324,10 @@ void update_log_settings(void* crate_map, char* settings) {\n     free(buffer);\n }\n \n+extern \"C\" CDECL void\n+rust_update_log_settings(void* crate_map, char* settings) {\n+    update_log_settings(crate_map, settings);\n+}\n \n //\n // Local Variables:"}, {"sha": "a609ac573245d625e9831404ec8b821edb275fe0", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -92,3 +92,14 @@ destroy_exchange_stack(rust_exchange_alloc *exchange, stk_seg *stk) {\n     deregister_valgrind_stack(stk);\n     exchange->free(stk);\n }\n+\n+\n+extern \"C\" CDECL unsigned int\n+rust_valgrind_stack_register(void *start, void *end) {\n+  return VALGRIND_STACK_REGISTER(start, end);\n+}\n+\n+extern \"C\" CDECL void\n+rust_valgrind_stack_deregister(unsigned int id) {\n+  VALGRIND_STACK_DEREGISTER(id);\n+}"}, {"sha": "fefcbbcacf7d499fdc0dc7ed53b350c096549969", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -229,7 +229,7 @@ rust_uv_timer_init(uv_loop_t* loop, uv_timer_t* timer) {\n \n extern \"C\" int\n rust_uv_timer_start(uv_timer_t* the_timer, uv_timer_cb cb,\n-                        uint32_t timeout, uint32_t repeat) {\n+                    int64_t timeout, int64_t repeat) {\n     return uv_timer_start(the_timer, cb, timeout, repeat);\n }\n "}, {"sha": "cdc282440b830cae3574488909cad94bcdd412af", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -195,8 +195,8 @@ rust_register_exit_function\n rust_get_global_data_ptr\n rust_inc_kernel_live_count\n rust_dec_kernel_live_count\n-rust_get_exchange_count_ptr\n-rust_get_sched_tls_key\n+rust_exchange_count\n+rust_get_rt_tls_key\n swap_registers\n rust_readdir\n rust_opendir\n@@ -234,3 +234,8 @@ rust_try\n rust_begin_unwind\n rust_take_task_borrow_list\n rust_set_task_borrow_list\n+rust_valgrind_stack_register\n+rust_valgrind_stack_deregister\n+rust_take_env_lock\n+rust_drop_env_lock\n+rust_update_log_settings"}, {"sha": "fb08cda3b2577adae7db35058dbede475b96cde7", "filename": "src/test/run-pass/core-rt-smoke.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1331f4a0cade66349a4c22315899210ad9b6a7/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs?ref=0d1331f4a0cade66349a4c22315899210ad9b6a7", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simple test of starting the runtime manually\n+\n+#[start]\n+fn start(argc: int, argv: **u8, crate_map: *u8) -> int {\n+    do core::rt::start(argc, argv, crate_map) {\n+        debug!(\"creating my own runtime is joy\");\n+    }\n+}\n\\ No newline at end of file"}]}