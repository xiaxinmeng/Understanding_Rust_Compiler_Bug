{"sha": "d6db9506f421ebc6a48cc101307c1f5dca92c53e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGI5NTA2ZjQyMWViYzZhNDhjYzEwMTMwN2MxZjVkY2E5MmM1M2U=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-30T02:02:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-30T02:02:39Z"}, "message": "Purge some obsolete and/or not-implemented stuff from docs.", "tree": {"sha": "71029f5b93e96c5b15bb78d4f77baea890791980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71029f5b93e96c5b15bb78d4f77baea890791980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6db9506f421ebc6a48cc101307c1f5dca92c53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6db9506f421ebc6a48cc101307c1f5dca92c53e", "html_url": "https://github.com/rust-lang/rust/commit/d6db9506f421ebc6a48cc101307c1f5dca92c53e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6db9506f421ebc6a48cc101307c1f5dca92c53e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca7d389e1db3ef9a94467e0c05b92acea06e7f1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7d389e1db3ef9a94467e0c05b92acea06e7f1f", "html_url": "https://github.com/rust-lang/rust/commit/ca7d389e1db3ef9a94467e0c05b92acea06e7f1f"}], "stats": {"total": 352, "additions": 93, "deletions": 259}, "files": [{"sha": "afefe5c6e6d64147853330dd55c86e207b9687c1", "filename": "doc/rust.texi", "status": "modified", "additions": 93, "deletions": 259, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/d6db9506f421ebc6a48cc101307c1f5dca92c53e/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/d6db9506f421ebc6a48cc101307c1f5dca92c53e/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=d6db9506f421ebc6a48cc101307c1f5dca92c53e", "patch": "@@ -218,12 +218,11 @@ profilers, dynamic loaders). The compiled units include custom metadata that\n carries full type and version information.\n \n The Rust runtime library is a small collection of support code for scheduling,\n-memory management, inter-task communication, reflection and runtime\n-linkage. This library is written in standard C++ and is quite\n-straightforward. It presents a simple interface to embeddings. No\n-research-level virtual machine, JIT or garbage collection technology is\n-required. It should be relatively easy to adapt a Rust front-end on to many\n-existing native toolchains.\n+memory management, inter-task communication and logging. This library is\n+written in standard C++ and is quite straightforward. It presents a simple\n+interface to embeddings. No research-level virtual machine, JIT or garbage\n+collection technology is required. It should be relatively easy to adapt a\n+Rust front-end on to many existing native toolchains.\n \n @sp 1\n @item Integrated system-construction facility\n@@ -296,11 +295,12 @@ there can never be sharing of data between tasks, while keeping the costs of\n transferring data between tasks as cheap as moving a pointer.\n \n @sp 1\n-@item Stack-based iterators\n+@item Efficient closures\n \n-Rust provides a type of function-like multiple-invocation iterator that is\n-very efficient: the iterator state lives only on the stack and is tightly\n-coupled to the loop that invoked it.\n+Rust provides a variety of closure types, including a type that is guaranteed\n+not to escape to the heap. This is represented as just a stack-frame pointer\n+and a code pointer. Passing such ``downward'' closures into library code makes\n+for very efficient iteration and accessor-function patterns.\n \n @sp 1\n @item Direct interface to C code\n@@ -322,8 +322,8 @@ an @code{alt} expression.\n @sp 1\n @item Generic code\n \n-Rust supports a simple form of parametric polymorphism: functions, iterators,\n-types and objects can be parametrized by other types.\n+Rust supports a simple form of parametric polymorphism: functions, types and\n+objects can be parametrized by other types.\n \n @sp 1\n @item Argument binding\n@@ -337,9 +337,9 @@ features of currying, in a smaller and simpler package.\n @item Local type inference\n \n To save some quantity of programmer key-pressing, Rust supports local type\n-inference: signatures of functions, objects and iterators always require type\n-annotation, but within the body of a function or iterator many slots can be\n-declared without a type, and Rust will infer the slot's type from its uses.\n+inference: signatures of functions and objects always require type annotation,\n+but within the body of a function many slots can be declared without a type,\n+and Rust will infer the slot's type from its uses.\n \n @sp 1\n @item Structural object system\n@@ -362,10 +362,11 @@ the surrounding text by skipping over the bracketed ``extension text''.\n @sp 1\n @item Idempotent failure\n \n-If a task fails due to a signal, or if it evaluates the special @code{fail}\n-expression, it enters the @emph{failing} state. A failing task unwinds its\n-control stack, frees all of its owned resources (executing destructors) and\n-enters the @emph{dead} state. Failure is idempotent and non-recoverable.\n+If a task is killed by some external event, or if it evaluates the special\n+@code{fail} expression, it enters the @emph{failing} state. A failing task\n+unwinds its control stack, frees all of its owned resources (executing\n+destructors) and enters the @emph{dead} state. Failure is idempotent and\n+non-recoverable.\n \n @sp 1\n @item Supervision hierarchy\n@@ -685,7 +686,6 @@ suffix:\n \n @enumerate\n @item The @code{u} suffix gives the literal type @code{uint}.\n-@item The @code{g} suffix gives the literal type @code{big}.\n @item Each of the signed and unsigned machine types @code{u8}, @code{i8},\n @code{u16}, @code{i16}, @code{u32}, @code{i32}, @code{u64} and @code{i64}\n give the literal the corresponding machine type.\n@@ -734,7 +734,6 @@ Examples of integer literals of various forms:\n 0xff00;                            // type int\n 0xffu8;                            // type u8\n 0b1111_1111_1001_0000_i32;         // type i32\n-0xffff_ffff_ffff_ffff_ffff_ffffg;  // type big\n @end example\n \n \n@@ -999,7 +998,6 @@ The compiled form of a crate is a loadable and executable object file full of\n machine code, in a standard loadable operating-system format such as ELF, PE\n or Mach-O. The loadable object contains metadata, describing:\n @itemize\n-@item Metadata required for type reflection.\n @item The publicly exported module structure of the crate.\n @item Any metadata about the crate, defined by attributes.\n @item The crates to dynamically link with at run-time, with matching criteria\n@@ -1202,10 +1200,10 @@ consist of @emph{boxes}.\n @cindex Shared box\n @cindex Task-local box\n \n-The @dfn{items} of a program are those functions, iterators, objects, modules\n-and types that have their value calculated at compile-time and stored uniquely\n-in the memory image of the rust process. Items are neither dynamically\n-allocated nor freed.\n+The @dfn{items} of a program are those functions, objects, modules and types\n+that have their value calculated at compile-time and stored uniquely in the\n+memory image of the rust process. Items are neither dynamically allocated nor\n+freed.\n \n A task's @dfn{stack} consists of activation frames automatically allocated on\n entry to each function as the task executes. A stack allocation is reclaimed\n@@ -1479,25 +1477,24 @@ completed -- when a message arrives at a sender, or a queue drains\n sufficiently to complete a semi-synchronous send -- then the blocked task will\n unblock and transition back to @emph{running}.\n \n-A task may transition to the @emph{failing} state at any time, due to an\n-un-trapped signal or the evaluation of a @code{fail} expression. Once\n-@emph{failing}, a task unwinds its stack and transitions to the @emph{dead}\n-state. Unwinding the stack of a task is done by the task itself, on its own\n-control stack. If a value with a destructor is freed during unwinding, the\n-code for the destructor is run, also on the task's control\n-stack. Running the destructor code causes a temporary transition to a\n-@emph{running} state, and allows the destructor code to cause any\n-subsequent state transitions.  The original task of unwinding and\n-failing thereby may suspend temporarily, and may involve (recursive)\n-unwinding of the stack of a failed destructor. Nonetheless, the\n-outermost unwinding activity will continue until the stack is unwound\n-and the task transitions to the @emph{dead} state. There is no way to\n-``recover'' from task failure.  Once a task has temporarily suspended\n-its unwinding in the @emph{failing} state, failure occurring from\n-within this destructor results in @emph{hard} failure.  The unwinding\n-procedure of hard failure frees resources but does not execute\n-destructors.  The original (soft) failure is still resumed at the\n-point where it was temporarily suspended.\n+A task may transition to the @emph{failing} state at any time, due being\n+killed by some external event or internally, from the evaluation of a\n+@code{fail} expression. Once @emph{failing}, a task unwinds its stack and\n+transitions to the @emph{dead} state. Unwinding the stack of a task is done by\n+the task itself, on its own control stack. If a value with a destructor is\n+freed during unwinding, the code for the destructor is run, also on the task's\n+control stack. Running the destructor code causes a temporary transition to a\n+@emph{running} state, and allows the destructor code to cause any subsequent\n+state transitions.  The original task of unwinding and failing thereby may\n+suspend temporarily, and may involve (recursive) unwinding of the stack of a\n+failed destructor. Nonetheless, the outermost unwinding activity will continue\n+until the stack is unwound and the task transitions to the @emph{dead}\n+state. There is no way to ``recover'' from task failure.  Once a task has\n+temporarily suspended its unwinding in the @emph{failing} state, failure\n+occurring from within this destructor results in @emph{hard} failure.  The\n+unwinding procedure of hard failure frees resources but does not execute\n+destructors.  The original (soft) failure is still resumed at the point where\n+it was temporarily suspended.\n \n A task in the @emph{dead} state cannot transition to other states; it exists\n only to have its termination status inspected by other tasks, and/or to await\n@@ -1608,20 +1605,20 @@ An @dfn{item} is a component of a module. Items are entirely determined at\n compile-time, remain constant during execution, and may reside in read-only\n memory.\n \n-There are five primary kinds of item: modules, functions, iterators, objects and\n-type definitions.\n+There are five primary kinds of item: modules, functions, objects and type\n+definitions.\n \n All items form an implicit scope for the declaration of sub-items. In other\n-words, within a function, object or iterator, declarations of items can (in\n-many cases) be mixed with the statements, control blocks, and similar\n-artifacts that otherwise compose the item body. The meaning of these scoped\n-items is the same as if the item was declared outside the scope, except that\n-the item's @emph{path name} within the module namespace is qualified by the\n-name of the enclosing item. The exact locations in which sub-items may be\n-declared is given by the grammar.  @xref{Ref.Gram}.\n-\n-Functions, iterators, objects and type definitions may be @emph{parametrized}\n-by type. Type parameters are given as a comma-separated list of identifiers\n+words, within a function or object, declarations of items can (in many cases)\n+be mixed with the statements, control blocks, and similar artifacts that\n+otherwise compose the item body. The meaning of these scoped items is the same\n+as if the item was declared outside the scope, except that the item's\n+@emph{path name} within the module namespace is qualified by the name of the\n+enclosing item. The exact locations in which sub-items may be declared is\n+given by the grammar.  @xref{Ref.Gram}.\n+\n+Functions, objects and type definitions may be @emph{parametrized} by\n+type. Type parameters are given as a comma-separated list of identifiers\n enclosed in angle brackets (@code{<>}), after the name of the item and before\n its definition.  The type parameters of an item are part of the name, not the\n type of the item; in order to refer to the type-parametrized item, a\n@@ -1787,11 +1784,11 @@ the value has the corresponding @emph{function type}, and can be used\n otherwise exactly as a function item (with a minor additional cost of calling\n the function, as such a call is indirect). @xref{Ref.Type.Fn}.\n \n-Every control path in a function ends with a @code{ret} or @code{be}\n-expression or with a diverging expression (described later in this\n-section). If a control path lacks a @code{ret} expression in source code, an\n-implicit @code{ret} expression is appended to the end of the control path\n-during compilation, returning the implicit @code{()} value.\n+Every control path in a function ends with a @code{ret} expression or with a\n+diverging expression (described later in this section). If a control path\n+lacks a @code{ret} expression in source code, an implicit @code{ret}\n+expression is appended to the end of the control path during compilation,\n+returning the implicit @code{()} value.\n \n An example of a function:\n @example\n@@ -1818,9 +1815,8 @@ unifies with any type. Rust has no syntax for @math{\\bot}.\n \n It might be necessary to declare a diverging function because as mentioned\n previously, the typechecker checks that every control path in a function ends\n-with a @code{ret}, @code{be}, or diverging expression. So, if @code{my_err}\n-were declared without the @code{!} annotation, the following code would not\n-typecheck:\n+with a @code{ret} or diverging expression. So, if @code{my_err} were declared\n+without the @code{!} annotation, the following code would not typecheck:\n @example\n fn f(i: int) -> int @{\n    if i == 42 @{\n@@ -1850,7 +1846,7 @@ is declared with the additional keyword @code{pure}. In addition,\n the typechecker checks the body of a predicate with a restricted set of\n typechecking rules. A predicate\n @itemize\n-@item may not contain a @code{put}, @code{send}, @code{recv}, assignment, or\n+@item may not contain an assignment or\n self-call expression; and\n @item may only call other predicates, not general functions.\n @end itemize\n@@ -2056,12 +2052,10 @@ built-in type or type-constructor name is reserved as a @emph{keyword} in\n Rust; they cannot be used as user-defined identifiers in any context.\n \n @menu\n-* Ref.Type.Any::                An open union of every possible type.\n * Ref.Type.Mach::               Machine-level types.\n * Ref.Type.Int::                The machine-dependent integer types.\n * Ref.Type.Float::              The machine-dependent floating-point types.\n * Ref.Type.Prim::               Primitive types.\n-* Ref.Type.Big::                The arbitrary-precision integer type.\n * Ref.Type.Text::               Strings and characters.\n * Ref.Type.Rec::                Labeled products of heterogeneous types.\n * Ref.Type.Tup::                Unlabeled products of heterogeneous types.\n@@ -2073,20 +2067,6 @@ Rust; they cannot be used as user-defined identifiers in any context.\n * Ref.Type.Type::               Types describing types.\n @end menu\n \n-@node       Ref.Type.Any\n-@subsection Ref.Type.Any\n-@cindex Any type\n-@cindex Dynamic type, see @i{Any type}\n-@cindex Alt type expression\n-\n-The type @code{any} is the union of all possible Rust types. A value of type\n-@code{any} is represented in memory as a pair consisting of a boxed value of\n-some non-@code{any} type @var{T} and a reflection of the type @var{T}.\n-\n-Values of type @code{any} can be used in an @code{alt type} expression, in\n-which the reflection is used to select a block corresponding to a particular\n-type extraction. @xref{Ref.Expr.Alt}.\n-\n @node       Ref.Type.Mach\n @subsection Ref.Type.Mach\n @cindex Machine types\n@@ -2198,22 +2178,6 @@ The machine types.\n The machine-dependent integer and floating-point types.\n @end itemize\n \n-\n-@node       Ref.Type.Big\n-@subsection Ref.Type.Big\n-@cindex Integer types\n-@cindex Big integer type\n-\n-The Rust type @code{big}@footnote{A Rust @code{big} is analogous to a Lisp\n-bignum or a Python long integer.} is an arbitrary precision integer type that\n-fits in a machine word @emph{when possible} and transparently expands to a\n-boxed ``big integer'' allocated in the run-time heap when it overflows or\n-underflows outside of the range of a machine word.\n-\n-A Rust @code{big} grows to accommodate extra binary digits as they are needed,\n-by taking extra memory from the memory budget available to each Rust task, and\n-should only exhaust its range due to memory exhaustion.\n-\n @node       Ref.Type.Text\n @subsection Ref.Type.Text\n @cindex Text types\n@@ -2697,10 +2661,10 @@ to hold in order to execute properly.\n @cindex Statements\n \n A @dfn{statement} is a component of a block, which is in turn a component of\n-an outer block-expression, a function or an iterator. When a function is\n-spawned into a task, the task @emph{executes} statements in an order\n-determined by the body of the enclosing structure. Each statement causes the\n-task to perform certain actions.\n+an outer block-expression or function. When a function is spawned into a task,\n+the task @emph{executes} statements in an order determined by the body of the\n+enclosing structure. Each statement causes the task to perform certain\n+actions.\n \n Rust has two kinds of statement: declarations and expressions.\n \n@@ -2748,11 +2712,10 @@ before and after the declaration.\n @c * Ref.Stmt.Decl.Item::                Statement declaring an item.\n \n An @dfn{item declaration statement} has a syntactic form identical to an item\n-declaration within a module. Declaring an item -- a function, iterator,\n-object, type or module -- locally within a statement block is simply a way of\n-restricting its scope to a narrow region containing all of its uses; it is\n-otherwise identical in meaning to declaring the item outside the statement\n-block.\n+declaration within a module. Declaring an item -- a function, object, type or\n+module -- locally within a statement block is simply a way of restricting its\n+scope to a narrow region containing all of its uses; it is otherwise identical\n+in meaning to declaring the item outside the statement block.\n \n Note: there is no implicit capture of the function's dynamic environment when\n declaring a function-local item.\n@@ -2783,9 +2746,8 @@ following the declaration statement.\n The former form, with no type annotation, causes the compiler to infer the\n static type of the slot through unification with the types of values assigned\n to the slot in the remaining code in the block scope. Inference only occurs on\n-frame-local slots, not argument slots. Function, iterator and object\n-signatures must always declared types for all argument slots.\n-@xref{Ref.Mem.Slot}.\n+frame-local slots, not argument slots. Function and object signatures must\n+always declared types for all argument slots.  @xref{Ref.Mem.Slot}.\n \n @node       Ref.Stmt.Expr\n @subsection Ref.Stmt.Expr\n@@ -2808,8 +2770,6 @@ effects of the expression's evaluation.\n * Ref.Expr.Call::               Expression for calling a function.\n * Ref.Expr.Bind::               Expression for binding arguments to functions.\n * Ref.Expr.Ret::                Expression for stopping and producing a value.\n-@c * Ref.Expr.Be::                 Expression for stopping and executing a tail call.\n-* Ref.Expr.Put::                Expression for pausing and producing a value.\n * Ref.Expr.As::                 Expression for casting a value to a different type.\n * Ref.Expr.Fail::               Expression for causing task failure.\n * Ref.Expr.Log::                Expression for logging values to diagnostic buffers.\n@@ -2819,7 +2779,7 @@ effects of the expression's evaluation.\n * Ref.Expr.Cont::               Expression for terminating a single loop iteration.\n * Ref.Expr.For::                Expression for looping over strings and vectors.\n * Ref.Expr.If::                 Expression for simple conditional branching.\n-* Ref.Expr.Alt::                Expression for complex conditional branching.\n+* Ref.Expr.Alt::                Expression for branching on patterh matches.\n * Ref.Expr.Prove::              Expression for static assertion of typestate.\n * Ref.Expr.Check::              Expression for dynamic assertion of typestate.\n * Ref.Expr.Claim::              Expression for static (unsafe) or dynamic assertion of typestate.\n@@ -2943,58 +2903,6 @@ fn max(a: int, b: int) -> int @{\n @}\n @end example\n \n-@ignore\n-@node       Ref.Expr.Be\n-@subsection Ref.Expr.Be\n-@c * Ref.Expr.Be::                 Expression for stopping and executing a tail call.\n-@cindex Be expression\n-@cindex Tail calls\n-\n-Executing a @code{be} expression @footnote{A @code{be} expression in is\n-analogous to a @code{become} expression in Newsqueak or Alef.}  destroys the\n-current function activation frame and replaces it with an activation frame for\n-the called function. In other words, @code{be} executes a tail-call. The\n-syntactic form of a @code{be} expression is therefore limited to @emph{tail\n-position}: its argument must be a @emph{call expression} or a @{trivial cast}\n-of a @emph{call expression}, and it must be the last expression in a block.\n-An example of a @code{be} expression:\n-@example\n-fn print_loop(n: int) @{\n-  if n <= 0 @{\n-    ret;\n-  @} else @{\n-    print_int(n);\n-    be print_loop(n-1);\n-  @}\n-@}\n-@end example\n-\n-The above example executes in constant space, replacing each frame with a new\n-copy of itself.\n-\n-@end ignore\n-\n-\n-@node       Ref.Expr.Put\n-@subsection Ref.Expr.Put\n-@c * Ref.Expr.Put::                Expression for pausing and producing a value.\n-@cindex Put expression\n-@cindex Iterators\n-\n-Executing a @code{put} expression copies a value into the output slot of the\n-current iterator, suspends execution of the current iterator, and transfers\n-control to the current put-recipient frame.\n-\n-A @code{put} expression is only valid within an iterator.  @footnote{A\n-@code{put} expression is analogous to a @code{yield} expression in the CLU, and\n-Sather languages, or in more recent languages providing a ``generator''\n-facility, such as Python, Javascript or C#. Like the generators of CLU and\n-Sather but @emph{unlike} these later languages, Rust's iterators reside on the\n-stack and obey a strict stack discipline.} The current put-recipient will\n-eventually resume the suspended iterator containing the @code{put} expression,\n-either continuing execution after the @code{put} expression, or terminating its\n-execution and destroying the iterator frame.\n-\n \n @node       Ref.Expr.As\n @subsection Ref.Expr.As\n@@ -3198,12 +3106,11 @@ enclosing it. It is only permitted in the body of a loop.\n @cindex Loops\n @cindex Control-flow\n \n-Executing a @code{cont} expression immediately terminates the current iteration\n-of the innermost loop enclosing it, returning control to the loop\n+Executing a @code{cont} expression immediately terminates the current\n+iteration of the innermost loop enclosing it, returning control to the loop\n @emph{head}. In the case of a @code{while} loop, the head is the conditional\n-expression controlling the loop. In the case of a @code{for} or @code{for\n-each} loop, the head is the iterator or vector-element increment controlling the\n-loop.\n+expression controlling the loop. In the case of a @code{for} loop, the head is\n+the vector-element increment controlling the loop.\n \n A @code{cont} expression is only permitted in the body of a loop.\n \n@@ -3247,50 +3154,26 @@ consequent block is skipped and any subsequent @code{else if} condition is\n evaluated. If all @code{if} and @code{else if} conditions evaluate to @code{false}\n then any @code{else} block is executed.\n \n-@node       Ref.Expr.Alt\n-@subsection Ref.Expr.Alt\n-@c * Ref.Expr.Alt::                Expression for complex conditional branching.\n-@cindex Alt expression\n-@cindex Control-flow\n-@cindex Switch expression, see @i{Alt expression}\n-\n-An @code{alt} expression is a multi-directional branch in program control.\n-There are two kinds of @code{alt} expression: pattern @code{alt} expressions\n-and @code{alt type} expressions.\n-\n-The form of each kind of @code{alt} is similar: an initial @emph{head} that\n-describes the criteria for branching, followed by a sequence of zero or more\n-@emph{arms}, each of which describes a @emph{case} and provides a @emph{block}\n-of expressions associated with the case. When an @code{alt} is executed,\n-control enters the head, determines which of the cases to branch to, branches\n-to the block associated with the chosen case, and then proceeds to the\n-expression following the @code{alt} when the case block completes.\n-\n-@menu\n-* Ref.Expr.Alt.Pat::          Expression for branching on pattern matches.\n-* Ref.Expr.Alt.Type::         Expression for branching on types.\n-@end menu\n-\n-@node          Ref.Expr.Alt.Pat\n-@subsubsection Ref.Expr.Alt.Pat\n-@c * Ref.Expr.Alt.Pat::            Expression for branching on pattern matches.\n+@node          Ref.Expr.Alt\n+@subsection    Ref.Expr.Alt\n+@c * Ref.Expr.Pat::            Expression for branching on pattern matches.\n @cindex Pattern alt expression\n @cindex Control-flow\n \n-A pattern @code{alt} expression branches on a @emph{pattern}. The exact form\n-of matching that occurs depends on the pattern. Patterns consist of some\n+An @code{alt} expression branches on a @emph{pattern}. The exact form of\n+matching that occurs depends on the pattern. Patterns consist of some\n combination of literals, destructured tag constructors, records and tuples,\n-variable binding specifications and placeholders (@code{_}). A pattern\n-@code{alt} has a @emph{head expression}, which is the value to compare to the\n+variable binding specifications and placeholders (@code{_}). An @code{alt}\n+expression has a @emph{head expression}, which is the value to compare to the\n patterns. The type of the patterns must equal the type of the head expression.\n \n-To execute a pattern @code{alt} expression, first the head expression is\n-evaluated, then its value is sequentially compared to the patterns in the arms\n-until a match is found. The first arm with a matching pattern is chosen as the\n-branch target of the @code{alt}, any variables bound by the pattern are\n-assigned to local slots in the arm's block, and control enters the block.\n+To execute an @code{alt} expression, first the head expression is evaluated,\n+then its value is sequentially compared to the patterns in the arms until a\n+match is found. The first arm with a matching pattern is chosen as the branch\n+target of the @code{alt}, any variables bound by the pattern are assigned to\n+local slots in the arm's block, and control enters the block.\n \n-An example of a pattern @code{alt} expression:\n+An example of an @code{alt} expression:\n \n @example\n tag list<X> @{ nil; cons(X, @@list<X>); @}\n@@ -3371,42 +3254,6 @@ let message = alt maybe_digit @{\n @}\n @end example\n \n-\n-@node          Ref.Expr.Alt.Type\n-@subsubsection Ref.Expr.Alt.Type\n-@c * Ref.Expr.Alt.Type::           Expression for branching on type.\n-@cindex Type alt expression\n-@cindex Control-flow\n-\n-An @code{alt type} expression is similar to a pattern @code{alt}, but branches\n-on the @emph{type} of its head expression, rather than the value. The head\n-expression of an @code{alt type} expression must be of type @code{any}, and the\n-arms of the expression are slot patterns rather than value patterns. Control\n-branches to the arm with a @code{case} that matches the @emph{actual type} of\n-the value in the @code{any}.\n-\n-An example of an @code{alt type} expression:\n-\n-@example\n-let x: any = foo();\n-\n-alt type (x) @{\n-    case (int i) @{\n-        ret i;\n-    @}\n-    case (list<int> li) @{\n-        ret int_list_sum(li);\n-    @}\n-    case (list<X> lx) @{\n-        ret list_len(lx);\n-    @}\n-    case (_) @{\n-        ret 0;\n-    @}\n-@}\n-@end example\n-\n-\n @node       Ref.Expr.Prove\n @subsection Ref.Expr.Prove\n @c * Ref.Expr.Prove::              Expression for static assertion of typestate.\n@@ -3538,14 +3385,13 @@ The Rust @dfn{runtime} is a relatively compact collection of C and Rust code\n that provides fundamental services and datatypes to all Rust tasks at\n run-time. It is smaller and simpler than many modern language runtimes. It is\n tightly integrated into the language's execution model of memory, tasks,\n-communication, reflection, logging and signal handling.\n+communication and logging.\n \n @menu\n * Ref.Run.Mem::                 Runtime memory management service.\n * Ref.Run.Type::                Runtime built-in type services.\n * Ref.Run.Comm::                Runtime communication service.\n * Ref.Run.Log::                 Runtime logging system.\n-* Ref.Run.Sig::                 Runtime signal handler.\n @end menu\n \n @node       Ref.Run.Mem\n@@ -3569,8 +3415,8 @@ allocating and freeing boxed values.\n @cindex Built-in types\n \n The runtime provides C and Rust code to assist with various built-in types,\n-such as vectors, strings, bignums, and the low level communication system\n-(ports, channels, tasks).\n+such as vectors, strings, and the low level communication system (ports,\n+channels, tasks).\n \n Support for other built-in types such as simple types, tuples, records, and\n tags is open-coded by the Rust compiler.\n@@ -3640,18 +3486,6 @@ of runtime logging modules follows.\n @item @code{::rt::callback} Unused\n @end itemize\n \n-@node       Ref.Run.Sig\n-@subsection Ref.Run.Sig\n-@c * Ref.Run.Sig::               Runtime signal handler.\n-@cindex Signals\n-\n-The runtime signal-handling system is driven by a signal-dispatch table and a\n-signal queue associated with each task. Sending a signal to a task inserts the\n-signal into the task's signal queue and marks the task as having a pending\n-signal. At the next scheduling opportunity, the runtime processes signals in\n-the task's queue using its dispatch table. The signal queue memory is charged\n-to the task; if the queue grows too big, the task will fail.\n-\n @c ############################################################\n @c end main body of nodes\n @c ############################################################"}]}