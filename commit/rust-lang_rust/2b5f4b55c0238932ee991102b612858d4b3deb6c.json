{"sha": "2b5f4b55c0238932ee991102b612858d4b3deb6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNWY0YjU1YzAyMzg5MzJlZTk5MTEwMmI2MTI4NThkNGIzZGViNmM=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-09-09T22:04:29Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-09-12T22:47:30Z"}, "message": "Convert rust_crate_map.cpp to Rust\n\nConflicts:\n\tsrc/libstd/rt/logging.rs", "tree": {"sha": "88dc41b1bac43ac174ea23fa233bfdd36855e29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88dc41b1bac43ac174ea23fa233bfdd36855e29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b5f4b55c0238932ee991102b612858d4b3deb6c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5f4b55c0238932ee991102b612858d4b3deb6c", "html_url": "https://github.com/rust-lang/rust/commit/2b5f4b55c0238932ee991102b612858d4b3deb6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b5f4b55c0238932ee991102b612858d4b3deb6c/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0e13e0d0e61b4147c8c62856c50cf727f7c918f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e13e0d0e61b4147c8c62856c50cf727f7c918f", "html_url": "https://github.com/rust-lang/rust/commit/b0e13e0d0e61b4147c8c62856c50cf727f7c918f"}], "stats": {"total": 443, "additions": 213, "deletions": 230}, "files": [{"sha": "e31f2228e3f774b45f40033c55dfe3f795103bc0", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b5f4b55c0238932ee991102b612858d4b3deb6c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2b5f4b55c0238932ee991102b612858d4b3deb6c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=2b5f4b55c0238932ee991102b612858d4b3deb6c", "patch": "@@ -75,7 +75,6 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_rng.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n-              rt/rust_crate_map.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n               rt/memory_region.cpp \\"}, {"sha": "270b5e5b1372e556a8de29f0774709419fc583f7", "filename": "src/libstd/rt/crate_map.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=2b5f4b55c0238932ee991102b612858d4b3deb6c", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use libc::{c_void, c_char};\n+use ptr;\n+use ptr::RawPtr;\n+use vec;\n+use hashmap::HashSet;\n+use container::MutableSet;\n+\n+pub struct ModEntry{\n+    name: *c_char,\n+    log_level: *mut u32\n+}\n+struct CrateMapV0 {\n+    entries: *ModEntry,\n+    children: [*CrateMap, ..1]\n+}\n+\n+struct CrateMap {\n+    version: i32,\n+    annihilate_fn: *c_void,\n+    entries: *ModEntry,\n+    /// a dynamically sized struct, where all pointers to children are listed adjacent\n+    /// to the struct, terminated with NULL\n+    children: [*CrateMap, ..1]\n+}\n+\n+unsafe fn version(crate_map: *CrateMap) -> i32 {\n+    match (*crate_map).version {\n+        1 => return 1,\n+        _ => return 0\n+    }\n+}\n+\n+/// Returns a pointer to the annihilate function of the CrateMap\n+pub unsafe fn annihilate_fn(crate_map: *CrateMap) -> *c_void {\n+    match version(crate_map) {\n+        0 => return ptr::null(),\n+        1 => return (*crate_map).annihilate_fn,\n+        _ => fail!(\"Unknown crate map version!\")\n+    }\n+}\n+\n+unsafe fn entries(crate_map: *CrateMap) -> *ModEntry {\n+    match version(crate_map) {\n+        0 => {\n+            let v0 = crate_map as (*CrateMapV0);\n+            return (*v0).entries;\n+        }\n+        1 => return (*crate_map).entries,\n+        _ => fail!(\"Unknown crate map version!\")\n+    }\n+}\n+\n+unsafe fn iterator(crate_map: *CrateMap) -> **CrateMap {\n+    match version(crate_map) {\n+        0 => {\n+            let v0 = crate_map as (*CrateMapV0);\n+            return vec::raw::to_ptr((*v0).children);\n+        }\n+        1 => return vec::raw::to_ptr((*crate_map).children),\n+        _ => fail!(\"Unknown crate map version!\")\n+    }\n+}\n+\n+unsafe fn iter_module_map(mod_entries: *ModEntry, f: &fn(*mut ModEntry)) {\n+    let mut curr = mod_entries;\n+\n+    while !(*curr).name.is_null() {\n+        f(curr as *mut ModEntry);\n+        curr = curr.offset(1);\n+    }\n+}\n+\n+unsafe fn do_iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry),\n+                            visited: &mut HashSet<*CrateMap>) {\n+    if visited.insert(crate_map) {\n+        iter_module_map(entries(crate_map), |x| f(x));\n+        let child_crates = iterator(crate_map);\n+        do ptr::array_each(child_crates) |child| {\n+            do_iter_crate_map(child, |x| f(x), visited);\n+        }\n+    }\n+}\n+\n+/// Iterates recursively over `crate_map` and all child crate maps\n+pub unsafe fn iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry)) {\n+    // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n+    //        way to do this\n+    let mut v: HashSet<*CrateMap> = HashSet::with_capacity_and_keys(0, 0, 32);\n+    do_iter_crate_map(crate_map, f, &mut v);\n+}\n+\n+#[test]\n+fn iter_crate_map_duplicates() {\n+    use c_str::ToCStr;\n+    use cast::transmute;\n+\n+    struct CrateMapT3 {\n+        version: i32,\n+        annihilate_fn: *c_void,\n+        entries: *ModEntry,\n+        children: [*CrateMap, ..3]\n+    }\n+\n+    unsafe {\n+        let mod_name1 = \"c::m1\".to_c_str();\n+        let mut level3: u32 = 3;\n+\n+        let entries: ~[ModEntry] = ~[\n+            ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n+            ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+        ];\n+        let child_crate = CrateMap {\n+            version: 1,\n+            annihilate_fn: ptr::null(),\n+            entries: vec::raw::to_ptr(entries),\n+            children: [ptr::null()]\n+        };\n+\n+        let root_crate = CrateMapT3 {\n+            version: 1, annihilate_fn: ptr::null(),\n+            entries: vec::raw::to_ptr([ModEntry { name: ptr::null(), log_level: ptr::mut_null()}]),\n+            children: [&child_crate as *CrateMap, &child_crate as *CrateMap, ptr::null()]\n+        };\n+\n+        let mut cnt = 0;\n+        do iter_crate_map(transmute(&root_crate)) |entry| {\n+            assert!(*(*entry).log_level == 3);\n+            cnt += 1;\n+        }\n+        assert!(cnt == 1);\n+    }\n+}\n+\n+#[test]\n+fn iter_crate_map_follow_children() {\n+    use c_str::ToCStr;\n+    use cast::transmute;\n+\n+    struct CrateMapT2 {\n+        version: i32,\n+        annihilate_fn: *c_void,\n+        entries: *ModEntry,\n+        children: [*CrateMap, ..2]\n+    }\n+\n+    unsafe {\n+        let mod_name1 = \"c::m1\".to_c_str();\n+        let mod_name2 = \"c::m2\".to_c_str();\n+        let mut level2: u32 = 2;\n+        let mut level3: u32 = 3;\n+        let child_crate2 = CrateMap {\n+            version: 1,\n+            annihilate_fn: ptr::null(),\n+            entries: vec::raw::to_ptr([\n+                ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n+                ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n+                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+            ]),\n+            children: [ptr::null()]\n+        };\n+\n+        let child_crate1 = CrateMapT2 {\n+            version: 1,\n+            annihilate_fn: ptr::null(),\n+            entries: vec::raw::to_ptr([\n+                ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 1},\n+                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+            ]),\n+            children: [&child_crate2 as *CrateMap, ptr::null()]\n+        };\n+\n+        let child_crate1_ptr: *CrateMap = transmute(&child_crate1);\n+        let root_crate = CrateMapT2 {\n+            version: 1, annihilate_fn: ptr::null(),\n+            entries: vec::raw::to_ptr([\n+                ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 0},\n+                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+            ]),\n+            children: [child_crate1_ptr, ptr::null()]\n+        };\n+\n+        let mut cnt = 0;\n+        do iter_crate_map(transmute(&root_crate)) |entry| {\n+            assert!(*(*entry).log_level == cnt);\n+            cnt += 1;\n+        }\n+        assert!(cnt == 4);\n+    }\n+}"}, {"sha": "0dd096b5bf352b27c6533b0fc20923b4169a7c51", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 10, "deletions": 54, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=2b5f4b55c0238932ee991102b612858d4b3deb6c", "patch": "@@ -7,66 +7,24 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use cast::transmute;\n use either::*;\n-use libc::{c_void, uintptr_t, c_char, exit, STDERR_FILENO};\n+use libc::{uintptr_t, exit, STDERR_FILENO};\n use option::{Some, None, Option};\n use rt::util::dumb_println;\n+use rt::crate_map::{ModEntry, iter_crate_map};\n use str::StrSlice;\n use str::raw::from_c_str;\n use u32;\n-use unstable::raw::Closure;\n use vec::ImmutableVector;\n-\n+use cast::transmute;\n \n struct LogDirective {\n     name: Option<~str>,\n     level: u32\n }\n \n-// This is the Rust representation of the mod_entry struct in src/rt/rust_crate_map.h\n-struct ModEntry{\n-    name: *c_char,\n-    log_level: *mut u32\n-}\n-\n static MAX_LOG_LEVEL: u32 = 255;\n static DEFAULT_LOG_LEVEL: u32 = 1;\n-\n-fn iter_crate_map(map: *u8, f: &fn(*mut ModEntry)) {\n-    unsafe {\n-        let closure : Closure = transmute(f);\n-        let code = transmute(closure.code);\n-        let env = transmute(closure.env);\n-        rust_iter_crate_map(transmute(map), iter_cb, code, env);\n-    }\n-\n-    extern fn iter_cb(code: *c_void, env: *c_void, entry: *ModEntry){\n-         unsafe {\n-            let closure: Closure = Closure {\n-                code: transmute(code),\n-                env: transmute(env),\n-            };\n-            let closure: &fn(*ModEntry) = transmute(closure);\n-            return closure(entry);\n-        }\n-    }\n-    extern {\n-        #[cfg(not(stage0))]\n-        #[rust_stack]\n-        fn rust_iter_crate_map(map: *c_void,\n-                    f: extern \"C\" fn(*c_void, *c_void, entry: *ModEntry),\n-                    code: *c_void,\n-                    data: *c_void);\n-\n-        #[cfg(stage0)]\n-        #[rust_stack]\n-        fn rust_iter_crate_map(map: *c_void,\n-                    f: *u8,\n-                    code: *c_void,\n-                    data: *c_void);\n-    }\n-}\n static log_level_names : &'static[&'static str] = &'static[\"error\", \"warn\", \"info\", \"debug\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n@@ -96,12 +54,10 @@ fn parse_log_level(level: &str) -> Option<u32> {\n     log_level\n }\n \n-\n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1\")\n /// and return a vector with log directives.\n /// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in std::).\n /// Also supports string log levels of error, warn, info, and debug\n-\n fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n     let mut dirs = ~[];\n     for s in spec.split_iter(',') {\n@@ -186,22 +142,22 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n             dumb_println(\"\\nCrate log map:\\n\");\n-            do iter_crate_map(crate_map) |entry: *mut ModEntry| {\n-                unsafe {\n+            unsafe {\n+                do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n                     dumb_println(\" \"+from_c_str((*entry).name));\n                 }\n-            }\n-            unsafe {\n                 exit(1);\n             }\n         }\n         dirs = parse_logging_spec(settings);\n     }\n \n     let mut n_matches: u32 = 0;\n-    do iter_crate_map(crate_map) |entry: *mut ModEntry| {\n-        let m = update_entry(dirs, entry);\n-        n_matches += m;\n+    unsafe {\n+        do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n+            let m = update_entry(dirs, entry);\n+            n_matches += m;\n+        }\n     }\n \n     if n_matches < (dirs.len() as u32) {"}, {"sha": "53f62786b629dc17cfe714e538fd77f30b6046ad", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=2b5f4b55c0238932ee991102b612858d4b3deb6c", "patch": "@@ -126,6 +126,9 @@ pub mod local_heap;\n /// The Logger trait and implementations\n pub mod logging;\n \n+/// Crate map\n+pub mod crate_map;\n+\n /// Tools for testing the runtime\n pub mod test;\n "}, {"sha": "e6206fd7bcb311674188100cd9cde06298b7001f", "filename": "src/rt/rust_crate_map.cpp", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b0e13e0d0e61b4147c8c62856c50cf727f7c918f/src%2Frt%2Frust_crate_map.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b0e13e0d0e61b4147c8c62856c50cf727f7c918f/src%2Frt%2Frust_crate_map.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_map.cpp?ref=b0e13e0d0e61b4147c8c62856c50cf727f7c918f", "patch": "@@ -1,69 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"rust_crate_map.h\"\n-#include <set>\n-\n-void iter_module_map(const mod_entry* map,\n-                    void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                    void* fptr,\n-                    void* env\n-                    ) {\n-    for (const mod_entry* cur = map; cur->name; cur++) {\n-        fn(fptr, env, cur);\n-    }\n-}\n-\n-void iter_crate_map(const cratemap* map,\n-                    void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                    void *fptr,\n-                    void *env,\n-                    std::set<const cratemap*>& visited) {\n-    if (visited.find(map) == visited.end()) {\n-        // Mark this crate visited\n-        visited.insert(map);\n-        // First iterate this crate\n-        iter_module_map(map->entries(), fn, fptr, env);\n-        // Then recurse on linked crates\n-        for (cratemap::iterator i = map->begin(),\n-                e = map->end(); i != e; ++i) {\n-            iter_crate_map(*i, fn, fptr, env, visited);\n-        }\n-    }\n-}\n-\n-void iter_crate_map(const cratemap* map,\n-                    void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                    void *fptr,\n-                    void *env\n-                    ) {\n-    std::set<const cratemap*> visited;\n-    iter_crate_map(map, fn, fptr, env, visited);\n-}\n-\n-extern \"C\" CDECL void\n-rust_iter_crate_map(const cratemap* map,\n-                    void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                    void *fptr,\n-                    void *env\n-                    ) {\n-    return iter_crate_map(map, fn, fptr, env);\n-}\n-\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "1bcb2aa8f7e4d3ce403d73dc4d78818ff35d1d8d", "filename": "src/rt/rust_crate_map.h", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b0e13e0d0e61b4147c8c62856c50cf727f7c918f/src%2Frt%2Frust_crate_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/b0e13e0d0e61b4147c8c62856c50cf727f7c918f/src%2Frt%2Frust_crate_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_map.h?ref=b0e13e0d0e61b4147c8c62856c50cf727f7c918f", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_CRATE_MAP_H\n-#define RUST_CRATE_MAP_H\n-\n-#include \"rust_globals.h\"\n-#include <stdint.h>\n-\n-struct mod_entry {\n-    const char* name;\n-    uint32_t* log_level;\n-};\n-\n-class cratemap;\n-\n-class cratemap_v0 {\n-    friend class cratemap;\n-    const mod_entry *m_entries;\n-    const cratemap* m_children[1];\n-};\n-\n-class cratemap {\n-private:\n-    int32_t m_version;\n-    const void *m_annihilate_fn;\n-    const mod_entry* m_entries;\n-    const cratemap* m_children[1];\n-\n-    inline int32_t version() const {\n-        switch (m_version) {\n-        case 1:     return 1;\n-        default:    return 0;\n-        }\n-    }\n-\n-public:\n-    typedef const cratemap *const *iterator;\n-\n-    inline const void *annihilate_fn() const {\n-        switch (version()) {\n-        case 0: return NULL;\n-        case 1: return m_annihilate_fn;\n-        default: assert(false && \"Unknown crate map version!\");\n-            return NULL; // Appease -Werror=return-type\n-        }\n-    }\n-\n-    inline const mod_entry *entries() const {\n-        switch (version()) {\n-        case 0: return reinterpret_cast<const cratemap_v0 *>(this)->m_entries;\n-        case 1: return m_entries;\n-        default: assert(false && \"Unknown crate map version!\");\n-            return NULL; // Appease -Werror=return-type\n-        }\n-    }\n-\n-    inline const iterator begin() const {\n-        switch (version()) {\n-        case 0:\n-            return &reinterpret_cast<const cratemap_v0 *>(this)->\n-                m_children[0];\n-        case 1:\n-            return &m_children[0];\n-        default: assert(false && \"Unknown crate map version!\");\n-            return NULL; // Appease -Werror=return-type\n-        }\n-    }\n-\n-    inline const iterator end() const {\n-        iterator i = begin();\n-        while (*i)\n-            i++;\n-        return i;\n-    }\n-};\n-\n-void iter_module_map(const mod_entry* map,\n-                     void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                     void *fptr,\n-                     void *env);\n-\n-void iter_crate_map(const cratemap* map,\n-                    void (*fn)(void* fptr, void* env, const mod_entry *entry),\n-                    void *fptr,\n-                    void *env);\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-\n-#endif /* RUST_CRATE_MAP_H */"}, {"sha": "af6daed1a3ebbc91fe2b64c492327ecfafbc5286", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/2b5f4b55c0238932ee991102b612858d4b3deb6c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=2b5f4b55c0238932ee991102b612858d4b3deb6c", "patch": "@@ -181,7 +181,6 @@ rust_valgrind_stack_register\n rust_valgrind_stack_deregister\n rust_take_env_lock\n rust_drop_env_lock\n-rust_iter_crate_map\n rust_running_on_valgrind\n rust_get_num_cpus\n rust_get_global_args_ptr"}]}