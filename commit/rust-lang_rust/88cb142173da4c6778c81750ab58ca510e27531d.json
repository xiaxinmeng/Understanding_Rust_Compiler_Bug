{"sha": "88cb142173da4c6778c81750ab58ca510e27531d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Y2IxNDIxNzNkYTRjNjc3OGM4MTc1MGFiNThjYTUxMGUyNzUzMWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-20T21:30:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-20T21:30:34Z"}, "message": "Merge pull request #1895 from topecongiro/configs-match_pattern_separator_break_point\n\nAdd mach_pattern_separator_break_point config option", "tree": {"sha": "49087c9404058bef10609bb6355544ea793841d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49087c9404058bef10609bb6355544ea793841d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88cb142173da4c6778c81750ab58ca510e27531d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88cb142173da4c6778c81750ab58ca510e27531d", "html_url": "https://github.com/rust-lang/rust/commit/88cb142173da4c6778c81750ab58ca510e27531d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88cb142173da4c6778c81750ab58ca510e27531d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fcbf7f48916aa52247c7d667b5af9978fdc69d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fcbf7f48916aa52247c7d667b5af9978fdc69d1", "html_url": "https://github.com/rust-lang/rust/commit/4fcbf7f48916aa52247c7d667b5af9978fdc69d1"}, {"sha": "5cf05a29922eea5b2ef0bd1d9465214107cec2fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf05a29922eea5b2ef0bd1d9465214107cec2fd", "html_url": "https://github.com/rust-lang/rust/commit/5cf05a29922eea5b2ef0bd1d9465214107cec2fd"}], "stats": {"total": 470, "additions": 294, "deletions": 176}, "files": [{"sha": "99740cb4b48f4f37dc611ce1a0c5eda3e4c19629", "filename": "Configurations.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -1163,6 +1163,39 @@ match lorem {\n \n See also: [`indent_match_arms`](#indent_match_arms), [`trailing_comma`](#trailing_comma), [`wrap_match_arms`](#wrap_match_arms).\n \n+## `match_pattern_separator_break_point`\n+\n+Put a match sub-patterns' separator (`|`) in front or back.\n+\n+- **Default value**: `\"Back\"`\n+- **Possible values**: `\"Back\"`, `\"Front\"`\n+\n+#### `\"Back\"`\n+\n+```rust\n+match m {\n+    Variant::Tag |\n+    Variant::Tag2 |\n+    Variant::Tag3 |\n+    Variant::Tag4 |\n+    Variant::Tag5 |\n+    Variant::Tag6 => {}\n+}\n+```\n+\n+#### `Front`\n+\n+```rust\n+match m {\n+    Variant::Tag\n+    | Variant::Tag2\n+    | Variant::Tag3\n+    | Variant::Tag4\n+    | Variant::Tag5\n+    | Variant::Tag6 => {}\n+}\n+```\n+\n ## `max_width`\n \n Maximum width of each line"}, {"sha": "3c1afe8ddfa082e1a1583ddd82983bbacbb907a1", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -17,7 +17,7 @@ use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n \n use file_lines::FileLines;\n-use lists::{ListTactic, SeparatorTactic};\n+use lists::{ListTactic, SeparatorPlace, SeparatorTactic};\n \n macro_rules! configuration_option_enum{\n     ($e:ident: $( $x:ident ),+ $(,)*) => {\n@@ -581,6 +581,8 @@ create_config! {\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     indent_match_arms: bool, true, \"Indent match arms instead of keeping them at the same \\\n                                     indentation level as the match keyword\";\n+    match_pattern_separator_break_point: SeparatorPlace, SeparatorPlace::Back,\n+        \"Put a match sub-patterns' separator in front or back.\";\n     closure_block_indent_threshold: isize, 7, \"How many lines a closure must have before it is \\\n                                                block indented. -1 means never use block indent.\";\n     space_before_type_annotation: bool, false,"}, {"sha": "5e8c66663c45a96ac290b23631f416240b15f190", "filename": "src/expr.rs", "status": "modified", "additions": 122, "deletions": 116, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp::{min, Ordering};\n use std::fmt::Write;\n-use std::iter::ExactSizeIterator;\n+use std::iter::{repeat, ExactSizeIterator};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, CodeMap, Span};\n@@ -25,7 +25,7 @@ use config::{Config, ControlBraceStyle, IndentStyle, MultilineStyle, Style};\n use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, DefinitiveListTactic, ListFormatting,\n-            ListItem, ListTactic, Separator, SeparatorTactic};\n+            ListItem, ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n use macros::{rewrite_macro, MacroPosition};\n use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n@@ -473,6 +473,7 @@ where\n         } else {\n             SeparatorTactic::Vertical\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: nested_shape,\n         ends_with_newline: ends_with_newline,\n         preserve_newline: false,\n@@ -555,6 +556,7 @@ fn rewrite_closure_fn_decl(\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n         shape: arg_shape,\n         ends_with_newline: false,\n         preserve_newline: true,\n@@ -1425,44 +1427,24 @@ fn is_unsafe_block(block: &ast::Block) -> bool {\n     }\n }\n \n-// inter-match-arm-comment-rules:\n-//  - all comments following a match arm before the start of the next arm\n-//    are about the second arm\n-fn rewrite_match_arm_comment(\n-    context: &RewriteContext,\n-    missed_str: &str,\n-    shape: Shape,\n-    arm_indent_str: &str,\n-) -> Option<String> {\n-    // The leading \",\" is not part of the arm-comment\n-    let missed_str = match missed_str.find_uncommented(\",\") {\n-        Some(n) => &missed_str[n + 1..],\n-        None => &missed_str[..],\n-    };\n-\n-    let mut result = String::new();\n-    // any text not preceeded by a newline is pushed unmodified to the block\n-    let first_brk = missed_str.find(|c: char| c == '\\n').unwrap_or(0);\n-    result.push_str(&missed_str[..first_brk]);\n-    let missed_str = &missed_str[first_brk..]; // If missed_str had one newline, it starts with it\n+// A simple wrapper type against ast::Arm. Used inside write_list().\n+struct ArmWrapper<'a> {\n+    pub arm: &'a ast::Arm,\n+    // True if the arm is the last one in match expression. Used to decide on whether we should add\n+    // trailing comma to the match arm when `config.trailing_comma() == Never`.\n+    pub is_last: bool,\n+}\n \n-    let first = missed_str\n-        .find(|c: char| !c.is_whitespace())\n-        .unwrap_or(missed_str.len());\n-    if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n-        // Excessive vertical whitespace before comment should be preserved\n-        // FIXME handle vertical whitespace better\n-        result.push('\\n');\n-    }\n-    let missed_str = missed_str[first..].trim();\n-    if !missed_str.is_empty() {\n-        let comment = try_opt!(rewrite_comment(&missed_str, false, shape, context.config));\n-        result.push('\\n');\n-        result.push_str(arm_indent_str);\n-        result.push_str(&comment);\n+impl<'a> ArmWrapper<'a> {\n+    pub fn new(arm: &'a ast::Arm, is_last: bool) -> ArmWrapper<'a> {\n+        ArmWrapper { arm, is_last }\n     }\n+}\n \n-    Some(result)\n+impl<'a> Rewrite for ArmWrapper<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_match_arm(context, self.arm, shape, self.is_last)\n+    }\n }\n \n fn rewrite_match(\n@@ -1511,7 +1493,7 @@ fn rewrite_match(\n         try_opt!(\n             inner_attrs\n                 .rewrite(context, shape)\n-                .map(|s| format!(\"\\n{}{}\", nested_indent_str, s))\n+                .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))\n         )\n     };\n \n@@ -1523,11 +1505,18 @@ fn rewrite_match(\n         inner_attrs[inner_attrs.len() - 1].span().hi\n     };\n \n+    let arm_indent_str = if context.config.indent_match_arms() {\n+        nested_indent_str\n+    } else {\n+        shape.indent.to_string(context.config)\n+    };\n+\n     Some(format!(\n-        \"match {}{}{{{}{}\\n{}}}\",\n+        \"match {}{}{{\\n{}{}{}\\n{}}}\",\n         cond_str,\n         block_sep,\n         inner_attrs_str,\n+        arm_indent_str,\n         try_opt!(rewrite_match_arms(\n             context,\n             arms,\n@@ -1539,8 +1528,10 @@ fn rewrite_match(\n     ))\n }\n \n-fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma() {\n+fn arm_comma(config: &Config, body: &ast::Expr, is_last: bool) -> &'static str {\n+    if is_last && config.trailing_comma() == SeparatorTactic::Never {\n+        \"\"\n+    } else if config.match_block_trailing_comma() {\n         \",\"\n     } else if let ast::ExprKind::Block(ref block) = body.node {\n         if let ast::BlockCheckMode::Default = block.rules {\n@@ -1560,84 +1551,88 @@ fn rewrite_match_arms(\n     span: Span,\n     open_brace_pos: BytePos,\n ) -> Option<String> {\n-    let mut result = String::new();\n-\n     let arm_shape = if context.config.indent_match_arms() {\n         shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n     }.with_max_width(context.config);\n-    let arm_indent_str = arm_shape.indent.to_string(context.config);\n-\n-    let arm_num = arms.len();\n-    for (i, arm) in arms.iter().enumerate() {\n-        // Make sure we get the stuff between arms.\n-        let missed_str = if i == 0 {\n-            context.snippet(mk_sp(open_brace_pos, arm.span().lo))\n-        } else {\n-            context.snippet(mk_sp(arms[i - 1].span().hi, arm.span().lo))\n-        };\n-        let comment = try_opt!(rewrite_match_arm_comment(\n-            context,\n-            &missed_str,\n-            arm_shape,\n-            &arm_indent_str,\n-        ));\n-        if !comment.chars().all(|c| c == ' ') {\n-            result.push_str(&comment);\n-        }\n-        result.push('\\n');\n-        result.push_str(&arm_indent_str);\n \n-        let arm_str = rewrite_match_arm(context, arm, arm_shape);\n-        if let Some(ref arm_str) = arm_str {\n-            // Trim the trailing comma if necessary.\n-            if i == arm_num - 1 && context.config.trailing_comma() == SeparatorTactic::Never &&\n-                arm_str.ends_with(',')\n-            {\n-                result.push_str(&arm_str[0..arm_str.len() - 1])\n-            } else {\n-                result.push_str(arm_str)\n-            }\n-        } else {\n-            // We couldn't format the arm, just reproduce the source.\n-            let snippet = context.snippet(arm.span());\n-            result.push_str(&snippet);\n-            if context.config.trailing_comma() != SeparatorTactic::Never {\n-                result.push_str(arm_comma(context.config, &arm.body))\n-            }\n-        }\n-    }\n-    // BytePos(1) = closing match brace.\n-    let last_span = mk_sp(arms[arms.len() - 1].span().hi, span.hi - BytePos(1));\n-    let last_comment = context.snippet(last_span);\n-    let comment = try_opt!(rewrite_match_arm_comment(\n-        context,\n-        &last_comment,\n-        arm_shape,\n-        &arm_indent_str,\n-    ));\n-    result.push_str(&comment);\n+    let arm_len = arms.len();\n+    let is_last_iter = repeat(false)\n+        .take(arm_len.checked_sub(1).unwrap_or(0))\n+        .chain(repeat(true));\n+    let items = itemize_list(\n+        context.codemap,\n+        arms.iter()\n+            .zip(is_last_iter)\n+            .map(|(arm, is_last)| ArmWrapper::new(arm, is_last)),\n+        \"}\",\n+        |arm| arm.arm.span().lo,\n+        |arm| arm.arm.span().hi,\n+        |arm| arm.rewrite(context, arm_shape),\n+        open_brace_pos,\n+        span.hi,\n+        false,\n+    );\n+    let arms_vec: Vec<_> = items.collect();\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        // We will add/remove commas inside `arm.rewrite()`, and hence no separator here.\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: arm_shape,\n+        ends_with_newline: true,\n+        preserve_newline: true,\n+        config: context.config,\n+    };\n \n-    Some(result)\n+    write_list(&arms_vec, &fmt)\n }\n \n-fn rewrite_match_arm(context: &RewriteContext, arm: &ast::Arm, shape: Shape) -> Option<String> {\n-    let attr_str = if !arm.attrs.is_empty() {\n+fn rewrite_match_arm(\n+    context: &RewriteContext,\n+    arm: &ast::Arm,\n+    shape: Shape,\n+    is_last: bool,\n+) -> Option<String> {\n+    let (missing_span, attrs_str) = if !arm.attrs.is_empty() {\n         if contains_skip(&arm.attrs) {\n-            return None;\n+            let (_, body) = flatten_arm_body(context, &arm.body);\n+            // `arm.span()` does not include trailing comma, add it manually.\n+            return Some(format!(\n+                \"{}{}\",\n+                context.snippet(arm.span()),\n+                arm_comma(context.config, body, is_last),\n+            ));\n         }\n-        format!(\n-            \"{}\\n{}\",\n+        (\n+            mk_sp(arm.attrs[arm.attrs.len() - 1].span.hi, arm.pats[0].span.lo),\n             try_opt!(arm.attrs.rewrite(context, shape)),\n-            shape.indent.to_string(context.config)\n         )\n     } else {\n-        String::new()\n+        (mk_sp(arm.span().lo, arm.span().lo), String::new())\n     };\n-    let pats_str = try_opt!(rewrite_match_pattern(context, &arm.pats, &arm.guard, shape));\n-    let pats_str = attr_str + &pats_str;\n-    rewrite_match_body(context, &arm.body, &pats_str, shape, arm.guard.is_some())\n+    let pats_str = try_opt!(\n+        rewrite_match_pattern(context, &arm.pats, &arm.guard, shape).and_then(|pats_str| {\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &pats_str,\n+                missing_span,\n+                shape,\n+                false,\n+            )\n+        })\n+    );\n+    rewrite_match_body(\n+        context,\n+        &arm.body,\n+        &pats_str,\n+        shape,\n+        arm.guard.is_some(),\n+        is_last,\n+    )\n }\n \n fn rewrite_match_pattern(\n@@ -1667,6 +1662,7 @@ fn rewrite_match_pattern(\n         tactic: tactic,\n         separator: \" |\",\n         trailing_separator: SeparatorTactic::Never,\n+        separator_place: context.config.match_pattern_separator_break_point(),\n         shape: pat_shape,\n         ends_with_newline: false,\n         preserve_newline: false,\n@@ -1685,27 +1681,35 @@ fn rewrite_match_pattern(\n     Some(format!(\"{}{}\", pats_str, guard_str))\n }\n \n-fn rewrite_match_body(\n-    context: &RewriteContext,\n-    body: &ptr::P<ast::Expr>,\n-    pats_str: &str,\n-    shape: Shape,\n-    has_guard: bool,\n-) -> Option<String> {\n-    let (extend, body) = match body.node {\n+// (extend, body)\n+// @extend: true if the arm body can be put next to `=>`\n+// @body: flattened body, if the body is block with a single expression\n+fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n+    match body.node {\n         ast::ExprKind::Block(ref block)\n             if !is_unsafe_block(block) && is_simple_block(block, context.codemap) =>\n         {\n             if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                 (expr.can_be_overflowed(context, 1), &**expr)\n             } else {\n-                (false, &**body)\n+                (false, &*body)\n             }\n         }\n-        _ => (body.can_be_overflowed(context, 1), &**body),\n-    };\n+        _ => (body.can_be_overflowed(context, 1), &*body),\n+    }\n+}\n+\n+fn rewrite_match_body(\n+    context: &RewriteContext,\n+    body: &ptr::P<ast::Expr>,\n+    pats_str: &str,\n+    shape: Shape,\n+    has_guard: bool,\n+    is_last: bool,\n+) -> Option<String> {\n+    let (extend, body) = flatten_arm_body(context, &body);\n \n-    let comma = arm_comma(&context.config, body);\n+    let comma = arm_comma(&context.config, body, is_last);\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let alt_block_sep = alt_block_sep.as_str();\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n@@ -2161,6 +2165,7 @@ where\n         } else {\n             context.config.trailing_comma()\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: shape,\n         ends_with_newline: context.use_block_indent() && tactic == DefinitiveListTactic::Vertical,\n         preserve_newline: false,\n@@ -2761,6 +2766,7 @@ where\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n         shape: shape,\n         ends_with_newline: false,\n         preserve_newline: false,"}, {"sha": "e5dfb12f4c491a778a2872aaddf5bf94fd7486c5", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -17,7 +17,7 @@ use Shape;\n use codemap::SpanUtils;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n-            ListItem, Separator, SeparatorTactic};\n+            ListItem, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::{rewrite_path, PathContext};\n use utils;\n@@ -496,6 +496,7 @@ fn rewrite_use_list(\n         } else {\n             SeparatorTactic::Never\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: nested_shape,\n         ends_with_newline: ends_with_newline,\n         preserve_newline: true,"}, {"sha": "4d0375ee75762f5d69a27e65ce1597bc40c8fb85", "filename": "src/items.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -24,7 +24,7 @@ use config::{BraceStyle, Config, Density, IndentStyle, ReturnIndent, Style};\n use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n            rewrite_call_inner, ExprType};\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n-            ListItem, ListTactic, Separator, SeparatorTactic};\n+            ListItem, ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::join_bounds;\n use utils::{colon_spaces, contains_skip, end_typaram, first_line_width, format_abi,\n@@ -481,6 +481,7 @@ impl<'a> FmtVisitor<'a> {\n             tactic: DefinitiveListTactic::Vertical,\n             separator: \",\",\n             trailing_separator: self.config.trailing_comma(),\n+            separator_place: SeparatorPlace::Back,\n             shape: shape,\n             ends_with_newline: true,\n             preserve_newline: true,\n@@ -2268,6 +2269,7 @@ fn rewrite_args(\n         } else {\n             trailing_comma\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: Shape::legacy(budget, indent),\n         ends_with_newline: tactic.ends_with_newline(context.config.fn_args_layout()),\n         preserve_newline: true,\n@@ -2463,6 +2465,7 @@ where\n         } else {\n             context.config.trailing_comma()\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: shape,\n         ends_with_newline: tactic.ends_with_newline(context.config.generics_indent()),\n         preserve_newline: true,\n@@ -2575,6 +2578,7 @@ fn rewrite_where_clause_rfc_style(\n         tactic: DefinitiveListTactic::Vertical,\n         separator: \",\",\n         trailing_separator: comma_tactic,\n+        separator_place: SeparatorPlace::Back,\n         shape: clause_shape,\n         ends_with_newline: true,\n         preserve_newline: true,\n@@ -2686,6 +2690,7 @@ fn rewrite_where_clause(\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: comma_tactic,\n+        separator_place: SeparatorPlace::Back,\n         shape: Shape::legacy(budget, offset),\n         ends_with_newline: tactic.ends_with_newline(context.config.where_pred_indent()),\n         preserve_newline: true,"}, {"sha": "ea34cdfc4801f403cccfa791b15b7e99b6517d31", "filename": "src/lists.rs", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -61,6 +61,7 @@ pub struct ListFormatting<'a> {\n     pub tactic: DefinitiveListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n+    pub separator_place: SeparatorPlace,\n     pub shape: Shape,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n@@ -70,6 +71,19 @@ pub struct ListFormatting<'a> {\n     pub config: &'a Config,\n }\n \n+impl<'a> ListFormatting<'a> {\n+    pub fn needs_trailing_separator(&self) -> bool {\n+        match self.trailing_separator {\n+            // We always put separator in front.\n+            SeparatorTactic::Always => true,\n+            SeparatorTactic::Vertical => self.tactic == DefinitiveListTactic::Vertical,\n+            SeparatorTactic::Never => {\n+                self.tactic == DefinitiveListTactic::Vertical && self.separator_place.is_front()\n+            }\n+        }\n+    }\n+}\n+\n impl AsRef<ListItem> for ListItem {\n     fn as_ref(&self) -> &ListItem {\n         self\n@@ -165,6 +179,32 @@ impl Separator {\n     }\n }\n \n+/// Where to put separator.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorPlace {\n+    Front,\n+    Back,\n+}\n+\n+impl_enum_serialize_and_deserialize!(SeparatorPlace, Front, Back);\n+\n+impl SeparatorPlace {\n+    pub fn is_front(&self) -> bool {\n+        *self == SeparatorPlace::Front\n+    }\n+\n+    pub fn is_back(&self) -> bool {\n+        *self == SeparatorPlace::Back\n+    }\n+\n+    pub fn from_tactic(default: SeparatorPlace, tactic: DefinitiveListTactic) -> SeparatorPlace {\n+        match tactic {\n+            DefinitiveListTactic::Vertical => default,\n+            _ => SeparatorPlace::Back,\n+        }\n+    }\n+}\n+\n pub fn definitive_tactic<I, T>(\n     items: I,\n     tactic: ListTactic,\n@@ -214,11 +254,12 @@ where\n \n     // Now that we know how we will layout, we can decide for sure if there\n     // will be a trailing separator.\n-    let mut trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n+    let mut trailing_separator = formatting.needs_trailing_separator();\n     let mut result = String::new();\n     let cloned_items = items.clone();\n     let mut iter = items.into_iter().enumerate().peekable();\n     let mut item_max_width: Option<usize> = None;\n+    let mut sep_place = SeparatorPlace::from_tactic(formatting.separator_place, tactic);\n \n     let mut line_len = 0;\n     let indent_str = &formatting.shape.indent.to_string(formatting.config);\n@@ -258,13 +299,16 @@ where\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n-                    if tactic == DefinitiveListTactic::Mixed && formatting.ends_with_newline {\n+                    if formatting.ends_with_newline {\n                         if last {\n                             separate = true;\n                         } else {\n                             trailing_separator = true;\n                         }\n                     }\n+                    sep_place = formatting.separator_place;\n+                } else {\n+                    sep_place = SeparatorPlace::Back;\n                 }\n \n                 if line_len > 0 {\n@@ -314,6 +358,10 @@ where\n             item_max_width = None;\n         }\n \n+        if separate && sep_place.is_front() && !first {\n+            result.push_str(formatting.separator.trim());\n+            result.push(' ');\n+        }\n         result.push_str(&inner_item[..]);\n \n         // Post-comments\n@@ -330,7 +378,7 @@ where\n             result.push_str(&formatted_comment);\n         }\n \n-        if separate {\n+        if separate && sep_place.is_back() {\n             result.push_str(formatting.separator);\n         }\n \n@@ -380,8 +428,9 @@ where\n                 for _ in 0..(comment_alignment + 1) {\n                     result.push(' ');\n                 }\n-                // An additional space for the missing trailing comma\n-                if last && item_max_width.is_some() && !separate {\n+                // An additional space for the missing trailing separator.\n+                if last && item_max_width.is_some() && !separate && !formatting.separator.is_empty()\n+                {\n                     result.push(' ');\n                 }\n             }\n@@ -525,25 +574,30 @@ where\n                         }\n                     }\n                     let newline_index = post_snippet.find('\\n');\n-                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                    match (block_open_index, newline_index) {\n-                        // Separator before comment, with the next item on same line.\n-                        // Comment belongs to next item.\n-                        (Some(i), None) if i > separator_index => separator_index + 1,\n-                        // Block-style post-comment before the separator.\n-                        (Some(i), None) => cmp::max(\n-                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                            separator_index + 1,\n-                        ),\n-                        // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => cmp::max(\n-                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                            separator_index + 1,\n-                        ),\n-                        // Potential *single* line comment.\n-                        (_, Some(j)) if j > separator_index => j + 1,\n-                        _ => post_snippet.len(),\n+                    if let Some(separator_index) = post_snippet.find_uncommented(\",\") {\n+                        match (block_open_index, newline_index) {\n+                            // Separator before comment, with the next item on same line.\n+                            // Comment belongs to next item.\n+                            (Some(i), None) if i > separator_index => separator_index + 1,\n+                            // Block-style post-comment before the separator.\n+                            (Some(i), None) => cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            ),\n+                            // Block-style post-comment. Either before or after the separator.\n+                            (Some(i), Some(j)) if i < j => cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            ),\n+                            // Potential *single* line comment.\n+                            (_, Some(j)) if j > separator_index => j + 1,\n+                            _ => post_snippet.len(),\n+                        }\n+                    } else {\n+                        // Match arms may not have trailing comma. In any case, for match arms,\n+                        // we will assume that the post comment belongs to the next arm if they\n+                        // do not end with trailing comma.\n+                        1\n                     }\n                 }\n                 None => post_snippet\n@@ -636,17 +690,6 @@ where\n     }\n }\n \n-fn needs_trailing_separator(\n-    separator_tactic: SeparatorTactic,\n-    list_tactic: DefinitiveListTactic,\n-) -> bool {\n-    match separator_tactic {\n-        SeparatorTactic::Always => true,\n-        SeparatorTactic::Vertical => list_tactic == DefinitiveListTactic::Vertical,\n-        SeparatorTactic::Never => false,\n-    }\n-}\n-\n /// Returns the count and total width of the list items.\n fn calculate_width<I, T>(items: I) -> (usize, usize)\n where\n@@ -756,6 +799,7 @@ pub fn struct_lit_formatting<'a>(\n         } else {\n             context.config.trailing_comma()\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: shape,\n         ends_with_newline: ends_with_newline,\n         preserve_newline: true,"}, {"sha": "455c4ad5ae41ad849cf1ec53f4733bb125239b78", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -23,7 +23,7 @@ use config::{IndentStyle, Style, TypeDensity};\n use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, wrap_args_with_parens};\n use items::{format_generics_item_list, generics_shape_from_config};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator,\n-            SeparatorTactic};\n+            SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{colon_spaces, extra_offset, format_mutability, last_line_width, mk_sp, wrap_str};\n \n@@ -365,6 +365,7 @@ where\n         } else {\n             context.config.trailing_comma()\n         },\n+        separator_place: SeparatorPlace::Back,\n         shape: list_shape,\n         ends_with_newline: tactic.ends_with_newline(context.config.fn_call_style()),\n         preserve_newline: true,"}, {"sha": "5c48acbb9d0e58cbdfe7e2ca31b6bb97e2c2a591", "filename": "src/vertical.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -20,7 +20,8 @@ use codemap::SpanUtils;\n use comment::{combine_strs_with_missing_comments, contains_comment};\n use expr::rewrite_field;\n use items::{rewrite_struct_field, rewrite_struct_field_prefix};\n-use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator};\n+use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic, Separator,\n+            SeparatorPlace};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{contains_skip, is_attributes_extendable, mk_sp};\n \n@@ -257,6 +258,7 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: context.config.trailing_comma(),\n+        separator_place: SeparatorPlace::Back,\n         shape: item_shape,\n         ends_with_newline: true,\n         preserve_newline: true,"}, {"sha": "5777a871d050b1fe3c74a061887b65b1c83151ec", "filename": "src/visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -24,7 +24,8 @@ use config::{BraceStyle, Config};\n use expr::{format_expr, ExprType};\n use items::{format_impl, format_trait, rewrite_associated_impl_type, rewrite_associated_type,\n             rewrite_static, rewrite_type_alias};\n-use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorTactic};\n+use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace,\n+            SeparatorTactic};\n use macros::{rewrite_macro, MacroPosition};\n use regex::Regex;\n use rewrite::{Rewrite, RewriteContext};\n@@ -917,6 +918,7 @@ impl Rewrite for ast::MetaItem {\n                     tactic: DefinitiveListTactic::Mixed,\n                     separator: \",\",\n                     trailing_separator: SeparatorTactic::Never,\n+                    separator_place: SeparatorPlace::Back,\n                     shape: item_shape,\n                     ends_with_newline: false,\n                     preserve_newline: false,"}, {"sha": "68a79bb0ab0ac5f9a864047d3bfc415eeb93cc72", "filename": "tests/source/configs-match_pattern_separator_break_point-Front.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Fsource%2Fconfigs-match_pattern_separator_break_point-Front.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Fsource%2Fconfigs-match_pattern_separator_break_point-Front.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-match_pattern_separator_break_point-Front.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -0,0 +1,9 @@\n+// rustfmt-match_pattern_separator_break_point: Front\n+// Whether `|` goes to front or to back.\n+\n+fn main() {\n+    match lorem {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb | cccccccccccccccccccccccccccccccccccccccc | dddddddddddddddddddddddddddddddddddddddd => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "527ceea06ef64f88e33da359e6fd2518d2ea4f84", "filename": "tests/source/match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -159,10 +159,9 @@ fn issue339() {\n         // t comment\n         t => 1,\n         u => 2,\n-        // TODO uncomment when block-support exists\n-        // v => {\n-        // } /* funky block\n-        //    * comment */\n+        v => {\n+        } /* funky block\n+           * comment */\n         // final comment\n     }\n }"}, {"sha": "d6cb87e012128bab531758b1e2868e644daae709", "filename": "tests/target/configs-match_pattern_separator_break_point-Front.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fconfigs-match_pattern_separator_break_point-Front.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fconfigs-match_pattern_separator_break_point-Front.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-match_pattern_separator_break_point-Front.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -0,0 +1,12 @@\n+// rustfmt-match_pattern_separator_break_point: Front\n+// Whether `|` goes to front or to back.\n+\n+fn main() {\n+    match lorem {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+        | cccccccccccccccccccccccccccccccccccccccc\n+        | dddddddddddddddddddddddddddddddddddddddd => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "5b368fd08dbdfe2efbd747052e39edb09c207355", "filename": "tests/target/control-brace-style-always-next-line.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -41,7 +41,8 @@ fn main() {\n     }\n \n     match some_var\n-    { // match comment\n+    {\n+        // match comment\n         pattern0 => val0,\n         pattern1 => val1,\n         pattern2 | pattern3 =>"}, {"sha": "46b74b95d825d9c42bf2a069e3050ed4cd359bf9", "filename": "tests/target/control-brace-style-always-same-line.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -34,7 +34,8 @@ fn main() {\n         }\n     }\n \n-    match some_var { // match comment\n+    match some_var {\n+        // match comment\n         pattern0 => val0,\n         pattern1 => val1,\n         pattern2 | pattern3 => {"}, {"sha": "314c05962e5c41be3d55225e53ed5dd4b699713d", "filename": "tests/target/match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cb142173da4c6778c81750ab58ca510e27531d/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=88cb142173da4c6778c81750ab58ca510e27531d", "patch": "@@ -128,13 +128,15 @@ fn issue339() {\n         h => {\n             // comment above block\n         }\n-        i => {} // comment below block\n+        i => {}\n+        // comment below block\n         j => {\n             // comment inside block\n         }\n         j2 => {\n             // comments inside...\n-        } // ... and after\n+        }\n+        // ... and after\n         // TODO uncomment when vertical whitespace is handled better\n         // k => {\n         //\n@@ -156,11 +158,9 @@ fn issue339() {\n         // t comment\n         t => 1,\n         u => 2,\n-        // TODO uncomment when block-support exists\n-        // v => {\n-        // } /* funky block\n-        //    * comment */\n-        // final comment\n+        v => {} /* funky block\n+                 * comment */\n+                /* final comment */\n     }\n }\n \n@@ -173,8 +173,8 @@ fn issue355() {\n         e => vec![1, 2],\n         f => vec![3; 4],\n         h => println!(\"a\", b), // h comment\n-        i => vec![1, 2], // i comment\n-        j => vec![3; 4], // j comment\n+        i => vec![1, 2],       // i comment\n+        j => vec![3; 4],       // j comment\n         // k comment\n         k => println!(\"a\", b),\n         // l comment\n@@ -213,11 +213,11 @@ fn issue355() {\n         y => vec![3; 4],\n         // Brackets with comments\n         tc => println!{\"a\", b}, // comment\n-        uc => vec![1, 2], // comment\n-        vc => vec![3; 4], // comment\n+        uc => vec![1, 2],       // comment\n+        vc => vec![3; 4],       // comment\n         wc => println![\"a\", b], // comment\n-        xc => vec![1, 2], // comment\n-        yc => vec![3; 4], // comment\n+        xc => vec![1, 2],       // comment\n+        yc => vec![3; 4],       // comment\n         yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(\n             aaaaaaaaaa,\n             bbbbbbbbbb,"}]}