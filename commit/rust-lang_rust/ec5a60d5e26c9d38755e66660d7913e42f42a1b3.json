{"sha": "ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNWE2MGQ1ZTI2YzlkMzg3NTVlNjY2NjBkNzkxM2U0MmY0MmExYjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-08T21:53:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-14T18:24:25Z"}, "message": "rustc: Use union-find for variable substitution", "tree": {"sha": "b92bcdc595978064468667b7110457d8176e3fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b92bcdc595978064468667b7110457d8176e3fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "html_url": "https://github.com/rust-lang/rust/commit/ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a60d5e26c9d38755e66660d7913e42f42a1b3/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99a697b56abba8e4ab94fc14b5b4769bee9702f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/99a697b56abba8e4ab94fc14b5b4769bee9702f0", "html_url": "https://github.com/rust-lang/rust/commit/99a697b56abba8e4ab94fc14b5b4769bee9702f0"}], "stats": {"total": 179, "additions": 115, "deletions": 64}, "files": [{"sha": "347be329fc919955fc62246203aadab490070406", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 103, "deletions": 48, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a60d5e26c9d38755e66660d7913e42f42a1b3/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a60d5e26c9d38755e66660d7913e42f42a1b3/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "patch": "@@ -1,6 +1,7 @@\n import std._str;\n import std._uint;\n import std._vec;\n+import std.UFind;\n import std.map;\n import std.map.hashmap;\n import std.option;\n@@ -879,6 +880,10 @@ fn is_lval(@ast.expr expr) -> bool {\n //\n //     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n \n+type var_bindings = rec(UFind.ufind sets,\n+                        hashmap[int,uint] var_ids,\n+                        mutable vec[mutable vec[@t]] types);\n+\n fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         -> unify_result {\n     // Wraps the given type in an appropriate cname.\n@@ -917,7 +922,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         fn_common_res_ok(vec[arg], @t);\n     }\n \n-    fn unify_fn_common(@hashmap[int,@ty.t] bindings,\n+    fn unify_fn_common(&var_bindings bindings,\n                        @ty.t expected,\n                        @ty.t actual,\n                        &unify_handler handler,\n@@ -982,7 +987,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         }\n     }\n \n-    fn unify_fn(@hashmap[int,@ty.t] bindings,\n+    fn unify_fn(&var_bindings bindings,\n                 ast.proto e_proto,\n                 ast.proto a_proto,\n                 @ty.t expected,\n@@ -1009,7 +1014,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         }\n     }\n \n-    fn unify_native_fn(@hashmap[int,@ty.t] bindings,\n+    fn unify_native_fn(&var_bindings bindings,\n                        ast.native_abi e_abi,\n                        ast.native_abi a_abi,\n                        @ty.t expected,\n@@ -1037,7 +1042,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         }\n     }\n \n-    fn unify_obj(@hashmap[int,@ty.t] bindings,\n+    fn unify_obj(&var_bindings bindings,\n                  @ty.t expected,\n                  @ty.t actual,\n                  &unify_handler handler,\n@@ -1084,32 +1089,20 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n       ret ures_ok(t);\n     }\n \n-    fn resolve(@hashmap[int,@t] bindings, @t typ) -> @t {\n-        alt (typ.struct) {\n-            case (ty_var(?id)) {\n-                alt (bindings.find(id)) {\n-                    case (some[@t](?typ2)) {\n-                        ret resolve(bindings, typ2);\n-                    }\n-                    case (none[@t]) {\n-                        // fall through\n-                    }\n-                }\n-            }\n-            case (_) {\n-                // fall through\n-            }\n+    fn get_or_create_set(&var_bindings bindings, int id) -> uint {\n+        auto set_num;\n+        alt (bindings.var_ids.find(id)) {\n+        case (none[uint]) {\n+            set_num = UFind.make_set(bindings.sets);\n+            bindings.var_ids.insert(id, set_num);\n+        }\n+        case (some[uint](?n)) { set_num = n; }\n         }\n-        ret typ;\n+        ret set_num;\n     }\n \n-    fn unify_step(@hashmap[int,@ty.t] bindings, @ty.t in_expected,\n-                  @ty.t in_actual, &unify_handler handler) -> unify_result {\n-\n-        // Resolve any bindings.\n-        auto expected = resolve(bindings, in_expected);\n-        auto actual = resolve(bindings, in_actual);\n-\n+    fn unify_step(&var_bindings bindings, @ty.t expected, @ty.t actual,\n+                  &unify_handler handler) -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -1120,8 +1113,26 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n-                bindings.insert(actual_id, expected);\n-                ret ures_ok(expected);\n+                auto actual_n = get_or_create_set(bindings, actual_id);\n+                alt (expected.struct) {\n+                    case (ty.ty_var(?expected_id)) {\n+                        auto expected_n = get_or_create_set(bindings,\n+                                                            expected_id);\n+                        UFind.union(bindings.sets, expected_n, actual_n);\n+                    }\n+\n+                    case (_) {\n+                        // Just bind the type variable to the expected type.\n+                        auto vlen = _vec.len[mutable vec[@t]](bindings.types);\n+                        if (actual_n < vlen) {\n+                            bindings.types.(actual_n) += vec(expected);\n+                        } else {\n+                            check (actual_n == vlen);\n+                            bindings.types += vec(mutable vec(expected));\n+                        }\n+                    }\n+                }\n+                ret ures_ok(actual);\n             }\n             case (ty.ty_local(?actual_id)) {\n                 auto actual_ty = handler.resolve_local(actual_id);\n@@ -1487,8 +1498,15 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n             case (ty.ty_var(?expected_id)) {\n                 // Add a binding.\n-                bindings.insert(expected_id, actual);\n-                ret ures_ok(actual);\n+                auto expected_n = get_or_create_set(bindings, expected_id);\n+                auto vlen = _vec.len[mutable vec[@t]](bindings.types);\n+                if (expected_n < vlen) {\n+                    bindings.types.(expected_n) += vec(actual);\n+                } else {\n+                    check (expected_n == vlen);\n+                    bindings.types += vec(mutable vec(actual));\n+                }\n+                ret ures_ok(expected);\n             }\n \n             case (ty.ty_local(?expected_id)) {\n@@ -1517,36 +1535,73 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     }\n \n     // Performs type binding substitution.\n-    fn substitute(@hashmap[int,@t] bindings, @t typ) -> @t {\n-        state obj folder(@hashmap[int,@t] bindings) {\n+    fn substitute(var_bindings bindings, vec[@t] set_types, @t typ) -> @t {\n+        state obj folder(tup(var_bindings, vec[@t]) env) {\n             fn fold_simple_ty(@t typ) -> @t {\n+                auto bindings = env._0;\n+                auto types = env._1;\n                 alt (typ.struct) {\n-                    case (ty_var(?id)) {\n-                        alt (bindings.find(id)) {\n-                            case (some[@t](?typ2)) {\n-                                ret substitute(bindings, typ2);\n-                            }\n-                            case (none[@t]) {\n-                                ret typ;\n-                            }\n-                        }\n+                case (ty_var(?id)) {\n+                    alt (bindings.var_ids.find(id)) {\n+                    case (some[uint](?n)) {\n+                        auto root = UFind.find(bindings.sets, n);\n+                        ret types.(root);\n                     }\n-                    case (_) {\n-                        ret typ;\n+                    case (none[uint]) { ret typ; }\n                     }\n                 }\n+                case (_) { ret typ; }\n+                }\n             }\n         }\n \n-        ret ty.fold_ty(folder(bindings), typ);\n+        ret ty.fold_ty(folder(tup(bindings, set_types)), typ);\n     }\n \n-    auto bindings = @common.new_int_hash[@ty.t]();\n+    fn unify_sets(&var_bindings bindings) -> vec[@t] {\n+        let vec[@t] throwaway = vec();\n+        let vec[mutable vec[@t]] set_types = vec(mutable throwaway);\n+        _vec.pop[mutable vec[@t]](set_types);   // FIXME: botch\n+\n+        for (UFind.node node in bindings.sets.nodes) {\n+            let vec[@t] v = vec();\n+            set_types += vec(mutable v);\n+        }\n+\n+        auto i = 0u;\n+        while (i < _vec.len[mutable vec[@t]](set_types)) {\n+            auto root = UFind.find(bindings.sets, i);\n+            set_types.(root) += bindings.types.(i);\n+            i += 1u;\n+        }\n+\n+        let vec[@t] result = vec();\n+        for (vec[@t] types in set_types) {\n+            if (_vec.len[@t](types) > 1u) {\n+                log \"unification of > 1 types in a type set is unimplemented\";\n+                fail;\n+            }\n+            result += vec(types.(0));\n+        }\n+\n+        ret result;\n+    }\n+\n+    let vec[@t] throwaway = vec();\n+    let vec[mutable vec[@t]] types = vec(mutable throwaway);\n+    _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n+\n+    auto bindings = rec(sets=UFind.make(),\n+                        var_ids=common.new_int_hash[uint](),\n+                        mutable types=types);\n \n     auto ures = unify_step(bindings, expected, actual, handler);\n     alt (ures) {\n-        case (ures_ok(?t))  { ret ures_ok(substitute(bindings, t)); }\n-        case (_)            { ret ures;                             }\n+    case (ures_ok(?t)) {\n+        auto set_types = unify_sets(bindings);\n+        ret ures_ok(substitute(bindings, set_types, t));\n+    }\n+    case (_) { ret ures; }\n     }\n     fail;   // not reached\n }"}, {"sha": "64cd56b0ab2072c303d9ad80b3e3dcc37a98bcb9", "filename": "src/lib/UFind.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a60d5e26c9d38755e66660d7913e42f42a1b3/src%2Flib%2FUFind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a60d5e26c9d38755e66660d7913e42f42a1b3/src%2Flib%2FUFind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FUFind.rs?ref=ec5a60d5e26c9d38755e66660d7913e42f42a1b3", "patch": "@@ -3,39 +3,35 @@ import option.some;\n \n // A very naive implementation of union-find with unsigned integer nodes.\n \n-tag node {\n-    elem(uint, option.t[uint]);\n-}\n+type node = option.t[uint];\n type ufind = rec(mutable vec[mutable node] nodes);\n \n fn make() -> ufind {\n-    let vec[mutable node] v = vec(mutable elem(0u, none[uint]));\n+    let vec[mutable node] v = vec(mutable none[uint]);\n     _vec.pop[mutable node](v);  // FIXME: botch\n     ret rec(mutable nodes=v);\n }\n \n-fn make_set(&ufind ufnd, uint n) {\n-    ufnd.nodes += vec(mutable elem(n, none[uint]));\n+fn make_set(&ufind ufnd) -> uint {\n+    auto idx = _vec.len[mutable node](ufnd.nodes);\n+    ufnd.nodes += vec(mutable none[uint]);\n+    ret idx;\n }\n \n fn find(&ufind ufnd, uint n) -> uint {\n     alt (ufnd.nodes.(n)) {\n-        case (elem(_, ?parent_opt)) {\n-            alt (parent_opt) {\n-                case (none[uint]) { ret n; }\n-                case (some[uint](?m)) {\n-                    // TODO: \"be\"\n-                    ret find(ufnd, m);\n-                }\n-            }\n-        }\n+    case (none[uint]) { ret n; }\n+    case (some[uint](?m)) {\n+        // TODO: \"be\"\n+        ret find(ufnd, m);\n+    }\n     }\n }\n \n fn union(&ufind ufnd, uint m, uint n) {\n     auto m_root = find(ufnd, m);\n     auto n_root = find(ufnd, n);\n     auto ptr = some[uint](n_root);\n-    ufnd.nodes.(m_root) = elem(m_root, ptr);\n+    ufnd.nodes.(m_root) = ptr;\n }\n "}]}