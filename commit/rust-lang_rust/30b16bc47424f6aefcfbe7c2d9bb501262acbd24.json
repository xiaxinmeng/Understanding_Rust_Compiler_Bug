{"sha": "30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYjE2YmM0NzQyNGY2YWVmY2ZiZTdjMmQ5YmI1MDEyNjJhY2JkMjQ=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-07-17T13:58:47Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-07-25T17:00:38Z"}, "message": "Move 'use' to Rewrite\n\nImplements Rewrite for ViewPath\n\nBehavior change: always use max_width instead of ideal_width for use\nlist rewrite. I think it looks better, was also suggested by @nrc in\nhttps://github.com/nrc/rustfmt/issues/82#issuecomment-105314265", "tree": {"sha": "37fcfcc464345f1e0b6d54f955c2e19373d44372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37fcfcc464345f1e0b6d54f955c2e19373d44372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "html_url": "https://github.com/rust-lang/rust/commit/30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff301efa4e0f433dccaa9de920da19b5492e24e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff301efa4e0f433dccaa9de920da19b5492e24e8", "html_url": "https://github.com/rust-lang/rust/commit/ff301efa4e0f433dccaa9de920da19b5492e24e8"}], "stats": {"total": 264, "additions": 136, "deletions": 128}, "files": [{"sha": "722c6a87012ed432c6f2cc6d65c315493fb0bad7", "filename": "src/imports.rs", "status": "modified", "additions": 112, "deletions": 93, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "patch": "@@ -8,126 +8,145 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use visitor::FmtVisitor;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n-use utils::{span_after, format_visibility};\n+use utils::span_after;\n+use rewrite::{Rewrite, RewriteContext};\n+use config::Config;\n \n use syntax::ast;\n use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::codemap::Span;\n+use syntax::codemap::{CodeMap, Span};\n \n // TODO (some day) remove unused imports, expand globs, compress many single imports into a list import\n \n-fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem, vis: &str) -> String {\n+impl Rewrite for ast::ViewPath {\n+    // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match self.node {\n+            ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n+                Some(rewrite_use_list(width,\n+                                 offset,\n+                                 path,\n+                                 path_list,\n+                                 self.span,\n+                                 context.codemap,\n+                                 context.config).unwrap_or(\"\".to_owned()))\n+            }\n+            ast::ViewPath_::ViewPathGlob(_) => {\n+                // FIXME convert to list?\n+                None\n+            }\n+            ast::ViewPath_::ViewPathSimple(_,_) => {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem) -> String {\n     if let ast::PathListItem_::PathListIdent{ name, .. } = vpi.node {\n         let name_str = token::get_ident(name).to_string();\n         if path_str.len() == 0 {\n-            format!(\"{}use {};\", vis, name_str)\n+            name_str\n         } else {\n-            format!(\"{}use {}::{};\", vis, path_str, name_str)\n+            format!(\"{}::{}\", path_str, name_str)\n         }\n     } else {\n         if path_str.len() != 0 {\n-            format!(\"{}use {};\", vis, path_str)\n+            path_str\n         } else {\n             // This catches the import: use {self}, which is a compiler error, so we just\n             // leave it alone.\n-            format!(\"{}use {{self}};\", vis)\n+            \"{self}\".to_owned()\n         }\n     }\n }\n \n-impl<'a> FmtVisitor<'a> {\n-    // Basically just pretty prints a multi-item import.\n-    // Returns None when the import can be removed.\n-    pub fn rewrite_use_list(&self,\n-                            block_indent: usize,\n-                            one_line_budget: usize, // excluding indentation\n-                            multi_line_budget: usize,\n-                            path: &ast::Path,\n-                            path_list: &[ast::PathListItem],\n-                            visibility: ast::Visibility,\n-                            span: Span)\n-                            -> Option<String> {\n-        let path_str = pprust::path_to_string(path);\n-        let vis = format_visibility(visibility);\n-\n-        match path_list.len() {\n-            0 => return None,\n-            1 => return Some(rewrite_single_use_list(path_str, path_list[0], vis)),\n-            _ => ()\n-        }\n-\n-        // 2 = ::\n-        let path_separation_w = if path_str.len() > 0 {\n-            2\n-        } else {\n-            0\n-        };\n-        // 5 = \"use \" + {\n-        let indent = path_str.len() + 5 + path_separation_w + vis.len();\n-\n-        // 2 = } + ;\n-        let used_width = indent + 2;\n+// Basically just pretty prints a multi-item import.\n+// Returns None when the import can be removed.\n+pub fn rewrite_use_list(width: usize,\n+                        offset: usize,\n+                        path: &ast::Path,\n+                        path_list: &[ast::PathListItem],\n+                        span: Span,\n+                        codemap: &CodeMap,\n+                        config: &Config)\n+                        -> Option<String> {\n+    let path_str = pprust::path_to_string(path);\n+\n+    match path_list.len() {\n+        0 => return None,\n+        1 => return Some(rewrite_single_use_list(path_str, path_list[0])),\n+        _ => ()\n+    }\n \n-        // Break as early as possible when we've blown our budget.\n-        let remaining_line_budget = one_line_budget.checked_sub(used_width).unwrap_or(0);\n-        let remaining_multi_budget = multi_line_budget.checked_sub(used_width).unwrap_or(0);\n+    // 2 = ::\n+    let path_separation_w = if path_str.len() > 0 {\n+        2\n+    } else {\n+        0\n+    };\n+    // 1 = {\n+    let supp_indent = path_str.len() + path_separation_w + 1;\n+    // 1 = }\n+    let remaining_width = width.checked_sub(supp_indent + 1).unwrap_or(0);\n+\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::Mixed,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset + supp_indent,\n+        h_width: remaining_width,\n+        // FIXME This is too conservative, and will not use all width\n+        // available\n+        // (loose 1 column (\";\"))\n+        v_width: remaining_width,\n+        ends_with_newline: true,\n+    };\n+\n+    let mut items = itemize_list(codemap,\n+                                 vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n+                                                                * below */\n+                                 path_list.iter(),\n+                                 \",\",\n+                                 \"}\",\n+                                 |vpi| vpi.span.lo,\n+                                 |vpi| vpi.span.hi,\n+                                 |vpi| match vpi.node {\n+                                     ast::PathListItem_::PathListIdent{ name, .. } => {\n+                                         token::get_ident(name).to_string()\n+                                     }\n+                                     ast::PathListItem_::PathListMod{ .. } => {\n+                                         \"self\".to_owned()\n+                                     }\n+                                 },\n+                                 span_after(span, \"{\", codemap),\n+                                 span.hi);\n+\n+    // We prefixed the item list with a dummy value so that we can\n+    // potentially move \"self\" to the front of the vector without touching\n+    // the rest of the items.\n+    // FIXME: Make more efficient by using a linked list? That would\n+    // require changes to the signatures of itemize_list and write_list.\n+    let has_self = move_self_to_front(&mut items);\n+    let first_index = if has_self {\n+        0\n+    } else {\n+        1\n+    };\n \n-        let fmt = ListFormatting {\n-            tactic: ListTactic::Mixed,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: block_indent + indent,\n-            h_width: remaining_line_budget,\n-            v_width: remaining_multi_budget,\n-            ends_with_newline: true,\n-        };\n+    if config.reorder_imports {\n+        items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n+    }\n \n-        let mut items = itemize_list(self.codemap,\n-                                     vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n-                                                                    * below */\n-                                     path_list.iter(),\n-                                     \",\",\n-                                     \"}\",\n-                                     |vpi| vpi.span.lo,\n-                                     |vpi| vpi.span.hi,\n-                                     |vpi| match vpi.node {\n-                                         ast::PathListItem_::PathListIdent{ name, .. } => {\n-                                             token::get_ident(name).to_string()\n-                                         }\n-                                         ast::PathListItem_::PathListMod{ .. } => {\n-                                             \"self\".to_owned()\n-                                         }\n-                                     },\n-                                     span_after(span, \"{\", self.codemap),\n-                                     span.hi);\n+    let list = write_list(&items[first_index..], &fmt);\n \n-        // We prefixed the item list with a dummy value so that we can\n-        // potentially move \"self\" to the front of the vector without touching\n-        // the rest of the items.\n-        // FIXME: Make more efficient by using a linked list? That would\n-        // require changes to the signatures of itemize_list and write_list.\n-        let has_self = move_self_to_front(&mut items);\n-        let first_index = if has_self {\n-            0\n+    Some(if path_str.len() == 0 {\n+            format!(\"{{{}}}\", list)\n         } else {\n-            1\n-        };\n-\n-        if self.config.reorder_imports {\n-            items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n-        }\n-\n-        let list = write_list(&items[first_index..], &fmt);\n-\n-        Some(if path_str.len() == 0 {\n-                format!(\"{}use {{{}}};\", vis, list)\n-            } else {\n-                format!(\"{}use {}::{{{}}};\", vis, path_str, list)\n-            })\n-    }\n+            format!(\"{}::{{{}}}\", path_str, list)\n+        })\n }\n \n // Returns true when self item was found."}, {"sha": "375107c00ea9f1971648f291129684e5049080b2", "filename": "src/visitor.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "patch": "@@ -164,39 +164,29 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         match item.node {\n             ast::Item_::ItemUse(ref vp) => {\n-                match vp.node {\n-                    ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                        let block_indent = self.block_indent;\n-                        let one_line_budget = self.config.max_width - block_indent;\n-                        let multi_line_budget = self.config.ideal_width - block_indent;\n-                        let formatted = self.rewrite_use_list(block_indent,\n-                                                              one_line_budget,\n-                                                              multi_line_budget,\n-                                                              path,\n-                                                              path_list,\n-                                                              item.vis,\n-                                                              item.span);\n-\n-                        if let Some(new_str) = formatted {\n-                            self.format_missing_with_indent(item.span.lo);\n-                            self.changes.push_str_span(item.span, &new_str);\n-                        } else {\n-                            // Format up to last newline\n-                            let span = codemap::mk_sp(self.last_pos, item.span.lo);\n-                            let span_end = match self.snippet(span).rfind('\\n') {\n-                                Some(offset) => self.last_pos + BytePos(offset as u32),\n-                                None => item.span.lo\n-                            };\n-                            self.format_missing(span_end);\n-                        }\n-\n+                let vis = utils::format_visibility(item.vis);\n+                let offset = self.block_indent + vis.len() + \"use \".len();\n+                let context = RewriteContext {\n+                    codemap: self.codemap, config: self.config, block_indent: self.block_indent };\n+                // 1 = \";\"\n+                match vp.rewrite(&context, self.config.max_width - offset - 1, offset) {\n+                    Some(ref s) if s.len() == 0 => {\n+                        // Format up to last newline\n+                        let span = codemap::mk_sp(self.last_pos, item.span.lo);\n+                        let span_end = match self.snippet(span).rfind('\\n') {\n+                            Some(offset) => self.last_pos + BytePos(offset as u32),\n+                            None => item.span.lo\n+                        };\n+                        self.format_missing(span_end);\n                         self.last_pos = item.span.hi;\n                     }\n-                    ast::ViewPath_::ViewPathGlob(_) => {\n+                    Some(ref s) => {\n+                        let s = format!(\"{}use {};\", vis, s);\n                         self.format_missing_with_indent(item.span.lo);\n-                        // FIXME convert to list?\n+                        self.changes.push_str_span(item.span, &s);\n+                        self.last_pos = item.span.hi;\n                     }\n-                    ast::ViewPath_::ViewPathSimple(_,_) => {\n+                    None => {\n                         self.format_missing_with_indent(item.span.lo);\n                     }\n                 }"}, {"sha": "a799c09621000907a45d86840bb6db45ef58731c", "filename": "tests/target/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "patch": "@@ -23,8 +23,8 @@ mod Foo {\n     pub use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n \n     mod Foo2 {\n-        pub use syntax::ast::{self, ItemForeignMod, ItemImpl, ItemMac, ItemMod,\n-                              ItemStatic, ItemDefaultImpl};\n+        pub use syntax::ast::{self, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic,\n+                              ItemDefaultImpl};\n     }\n }\n "}, {"sha": "5573ea7e96e74d7f5ed19196a9ef0de9ac52fe2e", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b16bc47424f6aefcfbe7c2d9bb501262acbd24/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=30b16bc47424f6aefcfbe7c2d9bb501262acbd24", "patch": "@@ -14,10 +14,9 @@ extern crate foo;\n extern crate foo;\n \n use std::cell::*;\n-use std::{self, any, ascii, borrow, boxed, char, borrow, boxed, char, borrow,\n-          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n-          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n-          borrow, boxed, char, borrow, boxed, char};\n+use std::{self, any, ascii, borrow, boxed, char, borrow, boxed, char, borrow, borrow, boxed, char,\n+          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n+          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char};\n \n mod doc;\n mod other;"}]}