{"sha": "6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NTlhMzY3NWUwMjFjOWU4YTQxNmZjMGQ5ZWY0MTZkZGZkYTJmMTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-10T01:45:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-12T18:28:57Z"}, "message": "librustc: Remove all uses of `~str` from librustc.", "tree": {"sha": "9c4b58b67b27dfc286e56e2bd2f67bf38d599ead", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c4b58b67b27dfc286e56e2bd2f67bf38d599ead"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "html_url": "https://github.com/rust-lang/rust/commit/6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b", "html_url": "https://github.com/rust-lang/rust/commit/e8053b9a7ff91b6a69238c1d7dea99be34bb7a3b"}], "stats": {"total": 3455, "additions": 2015, "deletions": 1440}, "files": [{"sha": "67140ac1920e3ae92a9368e45399351ac280c3f3", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -129,12 +129,12 @@ impl<'a> Archive<'a> {\n     }\n \n     /// Lists all files in an archive\n-    pub fn files(&self) -> Vec<~str> {\n+    pub fn files(&self) -> Vec<StrBuf> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n-        output.lines_any().map(|s| s.to_owned()).collect()\n+        output.lines_any().map(|s| s.to_strbuf()).collect()\n     }\n \n     fn add_archive(&mut self, archive: &Path, name: &str,"}, {"sha": "0acee6dd1dfaeb369188ced777782e2eb2183aa3", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -13,56 +13,57 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n-    let cc_args = if target_triple.contains(\"thumb\") {\n-        vec!(\"-mthumb\".to_owned())\n+pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n+    let cc_args = if target_triple.as_slice().contains(\"thumb\") {\n+        vec!(\"-mthumb\".to_strbuf())\n     } else {\n-        vec!(\"-marm\".to_owned())\n+        vec!(\"-marm\".to_strbuf())\n     };\n     return target_strs::t {\n-        module_asm: \"\".to_owned(),\n+        module_asm: \"\".to_strbuf(),\n \n-        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name:\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            \"e-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsWin32 => {\n-            \"e-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsLinux => {\n-            \"e-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsAndroid => {\n-            \"e-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsFreebsd => {\n-            \"e-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n         },\n "}, {"sha": "588d30ee4af010757b05e50c5194a64c94977882", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 112, "deletions": 94, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -54,15 +54,15 @@ pub enum OutputType {\n     OutputTypeExe,\n }\n \n-pub fn llvm_err(sess: &Session, msg: ~str) -> ! {\n+pub fn llvm_err(sess: &Session, msg: StrBuf) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            sess.fatal(msg);\n+            sess.fatal(msg.as_slice());\n         } else {\n             let err = CString::new(cstr, true);\n             let err = str::from_utf8_lossy(err.as_bytes());\n-            sess.fatal(msg + \": \" + err.as_slice());\n+            sess.fatal((msg.as_slice() + \": \" + err.as_slice()));\n         }\n     }\n }\n@@ -79,7 +79,7 @@ pub fn WriteOutputFile(\n             let result = llvm::LLVMRustWriteOutputFile(\n                     target, pm, m, output, file_type);\n             if !result {\n-                llvm_err(sess, \"could not write output\".to_owned());\n+                llvm_err(sess, \"could not write output\".to_strbuf());\n             }\n         })\n     }\n@@ -115,7 +115,7 @@ pub mod write {\n     fn target_feature<'a>(sess: &'a Session) -> &'a str {\n         match sess.targ_cfg.os {\n             abi::OsAndroid => {\n-                if \"\" == sess.opts.cg.target_feature {\n+                if \"\" == sess.opts.cg.target_feature.as_slice() {\n                     \"+v7\"\n                 } else {\n                     sess.opts.cg.target_feature.as_slice()\n@@ -173,8 +173,12 @@ pub mod write {\n                 }\n             };\n \n-            let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|t| {\n-                sess.opts.cg.target_cpu.with_c_str(|cpu| {\n+            let tm = sess.targ_cfg\n+                         .target_strs\n+                         .target_triple\n+                         .as_slice()\n+                         .with_c_str(|t| {\n+                sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n                     target_feature(sess).with_c_str(|features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             t, cpu, features,\n@@ -201,7 +205,7 @@ pub mod write {\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !sess.no_verify() { assert!(addpass(\"verify\")); }\n \n@@ -212,7 +216,7 @@ pub mod write {\n             }\n \n             for pass in sess.opts.cg.passes.iter() {\n-                pass.with_c_str(|s| {\n+                pass.as_slice().with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         sess.warn(format!(\"unknown pass {}, ignoring\", *pass));\n                     }\n@@ -355,7 +359,7 @@ pub mod write {\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        match Process::output(cc, args) {\n+        match Process::output(cc.as_slice(), args) {\n             Ok(prog) => {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n@@ -400,7 +404,7 @@ pub mod write {\n             if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n             for arg in sess.opts.cg.llvm_args.iter() {\n-                add(*arg);\n+                add((*arg).as_slice());\n             }\n         }\n \n@@ -527,19 +531,20 @@ pub fn find_crate_id(attrs: &[ast::Attribute], out_filestem: &str) -> CrateId {\n     match attr::find_crateid(attrs) {\n         None => from_str(out_filestem).unwrap_or_else(|| {\n             let mut s = out_filestem.chars().filter(|c| c.is_XID_continue());\n-            from_str(s.collect::<~str>()).or(from_str(\"rust-out\")).unwrap()\n+            from_str(s.collect::<StrBuf>()\n+                      .to_owned()).or(from_str(\"rust-out\")).unwrap()\n         }),\n         Some(s) => s,\n     }\n }\n \n-pub fn crate_id_hash(crate_id: &CrateId) -> ~str {\n+pub fn crate_id_hash(crate_id: &CrateId) -> StrBuf {\n     // This calculates CMH as defined above. Note that we don't use the path of\n     // the crate id in the hash because lookups are only done by (name/vers),\n     // not by path.\n     let mut s = Sha256::new();\n     s.input_str(crate_id.short_name_with_version().as_slice());\n-    truncated_hash_result(&mut s).slice_to(8).to_owned()\n+    truncated_hash_result(&mut s).as_slice().slice_to(8).to_strbuf()\n }\n \n pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n@@ -551,10 +556,10 @@ pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n     return r;\n }\n \n-fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n+fn truncated_hash_result(symbol_hasher: &mut Sha256) -> StrBuf {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n-    output.slice_to(8).to_hex()\n+    output.slice_to(8).to_hex().to_strbuf()\n }\n \n \n@@ -563,7 +568,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n                symbol_hasher: &mut Sha256,\n                t: ty::t,\n                link_meta: &LinkMeta)\n-               -> ~str {\n+               -> StrBuf {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -572,16 +577,16 @@ fn symbol_hash(tcx: &ty::ctxt,\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).as_slice());\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = StrBuf::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher));\n-    hash.into_owned()\n+    hash.push_str(truncated_hash_result(symbol_hasher).as_slice());\n+    hash\n }\n \n-fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n+fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> StrBuf {\n     match ccx.type_hashcodes.borrow().find(&t) {\n-        Some(h) => return h.to_str(),\n+        Some(h) => return h.to_strbuf(),\n         None => {}\n     }\n \n@@ -595,7 +600,7 @@ fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> ~str {\n+pub fn sanitize(s: &str) -> StrBuf {\n     let mut result = StrBuf::new();\n     for c in s.chars() {\n         match c {\n@@ -630,19 +635,18 @@ pub fn sanitize(s: &str) -> ~str {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    let result = result.into_owned();\n     if result.len() > 0u &&\n-        result[0] != '_' as u8 &&\n-        ! char::is_XID_start(result[0] as char) {\n-        return \"_\".to_owned() + result;\n+        result.as_slice()[0] != '_' as u8 &&\n+        ! char::is_XID_start(result.as_slice()[0] as char) {\n+        return (\"_\" + result.as_slice()).to_strbuf();\n     }\n \n     return result;\n }\n \n pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n                                       hash: Option<&str>,\n-                                      vers: Option<&str>) -> ~str {\n+                                      vers: Option<&str>) -> StrBuf {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -679,10 +683,10 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n     }\n \n     n.push_char('E'); // End name-sequence.\n-    n.into_owned()\n+    n\n }\n \n-pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> ~str {\n+pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> StrBuf {\n     // The version will get mangled to have a leading '_', but it makes more\n     // sense to lead with a 'v' b/c this is a version...\n     let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n@@ -695,8 +699,8 @@ pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> ~str {\n }\n \n pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n-                            t: ty::t, id: ast::NodeId) -> ~str {\n-    let mut hash = StrBuf::from_owned_str(get_symbol_hash(ccx, t));\n+                            t: ty::t, id: ast::NodeId) -> StrBuf {\n+    let mut hash = get_symbol_hash(ccx, t);\n \n     // Paths can be completely identical for different nodes,\n     // e.g. `fn foo() { { fn a() {} } { fn a() {} } }`, so we\n@@ -723,25 +727,28 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n-                                            name: &str) -> ~str {\n+                                            name: &str) -> StrBuf {\n     let s = ppaux::ty_to_str(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s)),\n+    let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> ~str {\n+pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> StrBuf {\n     mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n }\n \n-pub fn output_lib_filename(id: &CrateId) -> ~str {\n-    format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n+pub fn output_lib_filename(id: &CrateId) -> StrBuf {\n+    format_strbuf!(\"{}-{}-{}\",\n+                   id.name,\n+                   crate_id_hash(id),\n+                   id.version_or_default())\n }\n \n-pub fn get_cc_prog(sess: &Session) -> ~str {\n+pub fn get_cc_prog(sess: &Session) -> StrBuf {\n     match sess.opts.cg.linker {\n-        Some(ref linker) => return linker.to_owned(),\n+        Some(ref linker) => return linker.to_strbuf(),\n         None => {}\n     }\n \n@@ -750,38 +757,40 @@ pub fn get_cc_prog(sess: &Session) -> ~str {\n     // instead of hard-coded gcc.\n     // For win32, there is no cc command, so we add a condition to make it use gcc.\n     match sess.targ_cfg.os {\n-        abi::OsWin32 => return \"gcc\".to_owned(),\n+        abi::OsWin32 => return \"gcc\".to_strbuf(),\n         _ => {},\n     }\n \n     get_system_tool(sess, \"cc\")\n }\n \n-pub fn get_ar_prog(sess: &Session) -> ~str {\n+pub fn get_ar_prog(sess: &Session) -> StrBuf {\n     match sess.opts.cg.ar {\n-        Some(ref ar) => return ar.to_owned(),\n+        Some(ref ar) => return (*ar).clone(),\n         None => {}\n     }\n \n     get_system_tool(sess, \"ar\")\n }\n \n-fn get_system_tool(sess: &Session, tool: &str) -> ~str {\n+fn get_system_tool(sess: &Session, tool: &str) -> StrBuf {\n     match sess.targ_cfg.os {\n         abi::OsAndroid => match sess.opts.cg.android_cross_path {\n             Some(ref path) => {\n                 let tool_str = match tool {\n                     \"cc\" => \"gcc\",\n                     _ => tool\n                 };\n-                format!(\"{}/bin/arm-linux-androideabi-{}\", *path, tool_str)\n+                format_strbuf!(\"{}/bin/arm-linux-androideabi-{}\",\n+                               *path,\n+                               tool_str)\n             }\n             None => {\n                 sess.fatal(format!(\"need Android NDK path for the '{}' tool \\\n                                     (-C android-cross-path)\", tool))\n             }\n         },\n-        _ => tool.to_owned(),\n+        _ => tool.to_strbuf(),\n     }\n }\n \n@@ -1022,7 +1031,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        a.add_rlib(&p, name, sess.lto()).unwrap();\n+        a.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n@@ -1057,7 +1066,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n     let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    Process::output(cc_prog, cc_args.as_slice()));\n+                    Process::output(cc_prog.as_slice(),\n+                                    cc_args.iter()\n+                                           .map(|x| (*x).to_owned())\n+                                           .collect::<Vec<_>>()\n+                                           .as_slice()));\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -1096,20 +1109,20 @@ fn link_args(sess: &Session,\n              tmpdir: &Path,\n              trans: &CrateTranslation,\n              obj_filename: &Path,\n-             out_filename: &Path) -> Vec<~str> {\n+             out_filename: &Path) -> Vec<StrBuf> {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let lib_path = sess.target_filesearch().get_lib_path();\n-    let stage: ~str = \"-L\".to_owned() + lib_path.as_str().unwrap();\n+    let stage = (\"-L\".to_owned() + lib_path.as_str().unwrap()).to_strbuf();\n \n     let mut args = vec!(stage);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push_all([\n-        \"-o\".to_owned(), out_filename.as_str().unwrap().to_owned(),\n-        obj_filename.as_str().unwrap().to_owned()]);\n+        \"-o\".to_strbuf(), out_filename.as_str().unwrap().to_strbuf(),\n+        obj_filename.as_str().unwrap().to_strbuf()]);\n \n     // Stack growth requires statically linking a __morestack function. Note\n     // that this is listed *before* all other libraries, even though it may be\n@@ -1126,14 +1139,14 @@ fn link_args(sess: &Session,\n     // line, but inserting this farther to the left makes the\n     // \"rust_stack_exhausted\" symbol an outstanding undefined symbol, which\n     // flags libstd as a required library (or whatever provides the symbol).\n-    args.push(\"-lmorestack\".to_owned());\n+    args.push(\"-lmorestack\".to_strbuf());\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n         let metadata = obj_filename.with_extension(\"metadata.o\");\n-        args.push(metadata.as_str().unwrap().to_owned());\n+        args.push(metadata.as_str().unwrap().to_strbuf());\n     }\n \n     // We want to prevent the compiler from accidentally leaking in any system\n@@ -1144,28 +1157,28 @@ fn link_args(sess: &Session,\n     //\n     // FIXME(#11937) we should invoke the system linker directly\n     if sess.targ_cfg.os != abi::OsWin32 {\n-        args.push(\"-nodefaultlibs\".to_owned());\n+        args.push(\"-nodefaultlibs\".to_strbuf());\n     }\n \n     // If we're building a dylib, we don't use --gc-sections because LLVM has\n     // already done the best it can do, and we also don't want to eliminate the\n     // metadata. If we're building an executable, however, --gc-sections drops\n     // the size of hello world from 1.8MB to 597K, a 67% reduction.\n     if !dylib && sess.targ_cfg.os != abi::OsMacos {\n-        args.push(\"-Wl,--gc-sections\".to_owned());\n+        args.push(\"-Wl,--gc-sections\".to_strbuf());\n     }\n \n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n         // follow this flag. Thus, use it before specifying libraries to link to.\n-        args.push(\"-Wl,--as-needed\".to_owned());\n+        args.push(\"-Wl,--as-needed\".to_strbuf());\n \n         // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n         // numeric argument, but other linkers do.\n         if sess.opts.optimize == config::Default ||\n            sess.opts.optimize == config::Aggressive {\n-            args.push(\"-Wl,-O1\".to_owned());\n+            args.push(\"-Wl,-O1\".to_strbuf());\n         }\n     } else if sess.targ_cfg.os == abi::OsMacos {\n         // The dead_strip option to the linker specifies that functions and data\n@@ -1178,14 +1191,14 @@ fn link_args(sess: &Session,\n         // won't get much benefit from dylibs because LLVM will have already\n         // stripped away as much as it could. This has not been seen to impact\n         // link times negatively.\n-        args.push(\"-Wl,-dead_strip\".to_owned());\n+        args.push(\"-Wl,-dead_strip\".to_strbuf());\n     }\n \n     if sess.targ_cfg.os == abi::OsWin32 {\n         // Make sure that we link to the dynamic libgcc, otherwise cross-module\n         // DWARF stack unwinding will not work.\n         // This behavior may be overridden by --link-args \"-static-libgcc\"\n-        args.push(\"-shared-libgcc\".to_owned());\n+        args.push(\"-shared-libgcc\".to_strbuf());\n \n         // And here, we see obscure linker flags #45. On windows, it has been\n         // found to be necessary to have this flag to compile liblibc.\n@@ -1212,13 +1225,13 @@ fn link_args(sess: &Session,\n         //\n         // [1] - https://sourceware.org/bugzilla/show_bug.cgi?id=13130\n         // [2] - https://code.google.com/p/go/issues/detail?id=2139\n-        args.push(\"-Wl,--enable-long-section-names\".to_owned());\n+        args.push(\"-Wl,--enable-long-section-names\".to_strbuf());\n     }\n \n     if sess.targ_cfg.os == abi::OsAndroid {\n         // Many of the symbols defined in compiler-rt are also defined in libgcc.\n         // Android linker doesn't like that by default.\n-        args.push(\"-Wl,--allow-multiple-definition\".to_owned());\n+        args.push(\"-Wl,--allow-multiple-definition\".to_strbuf());\n     }\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n@@ -1263,22 +1276,23 @@ fn link_args(sess: &Session,\n     if dylib {\n         // On mac we need to tell the linker to let this library be rpathed\n         if sess.targ_cfg.os == abi::OsMacos {\n-            args.push(\"-dynamiclib\".to_owned());\n-            args.push(\"-Wl,-dylib\".to_owned());\n+            args.push(\"-dynamiclib\".to_strbuf());\n+            args.push(\"-Wl,-dylib\".to_strbuf());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             if !sess.opts.cg.no_rpath {\n-                args.push(\"-Wl,-install_name,@rpath/\".to_owned() +\n-                          out_filename.filename_str().unwrap());\n+                args.push(format_strbuf!(\"-Wl,-install_name,@rpath/{}\",\n+                                         out_filename.filename_str()\n+                                                     .unwrap()));\n             }\n         } else {\n-            args.push(\"-shared\".to_owned())\n+            args.push(\"-shared\".to_strbuf())\n         }\n     }\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        args.push_all([\"-L/usr/local/lib\".to_owned(),\n-                       \"-L/usr/local/lib/gcc46\".to_owned(),\n-                       \"-L/usr/local/lib/gcc44\".to_owned()]);\n+        args.push_all([\"-L/usr/local/lib\".to_strbuf(),\n+                       \"-L/usr/local/lib/gcc46\".to_strbuf(),\n+                       \"-L/usr/local/lib/gcc44\".to_strbuf()]);\n     }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n@@ -1295,7 +1309,7 @@ fn link_args(sess: &Session,\n     //\n     // This is the end of the command line, so this library is used to resolve\n     // *all* undefined symbols in all other libraries, and this is intentional.\n-    args.push(\"-lcompiler-rt\".to_owned());\n+    args.push(\"-lcompiler-rt\".to_strbuf());\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n@@ -1317,16 +1331,16 @@ fn link_args(sess: &Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n+fn add_local_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n     for path in sess.opts.addl_lib_search_paths.borrow().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+        args.push((\"-L\" + path.as_str().unwrap().to_owned()).to_strbuf());\n     }\n \n     let rustpath = filesearch::rust_path();\n     for path in rustpath.iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+        args.push((\"-L\" + path.as_str().unwrap().to_owned()).to_strbuf());\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -1340,21 +1354,21 @@ fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n             cstore::NativeUnknown | cstore::NativeStatic => {\n                 if takes_hints {\n                     if kind == cstore::NativeStatic {\n-                        args.push(\"-Wl,-Bstatic\".to_owned());\n+                        args.push(\"-Wl,-Bstatic\".to_strbuf());\n                     } else {\n-                        args.push(\"-Wl,-Bdynamic\".to_owned());\n+                        args.push(\"-Wl,-Bdynamic\".to_strbuf());\n                     }\n                 }\n-                args.push(\"-l\" + *l);\n+                args.push(format_strbuf!(\"-l{}\", *l));\n             }\n             cstore::NativeFramework => {\n-                args.push(\"-framework\".to_owned());\n-                args.push(l.to_owned());\n+                args.push(\"-framework\".to_strbuf());\n+                args.push(l.to_strbuf());\n             }\n         }\n     }\n     if takes_hints {\n-        args.push(\"-Wl,-Bdynamic\".to_owned());\n+        args.push(\"-Wl,-Bdynamic\".to_strbuf());\n     }\n }\n \n@@ -1363,7 +1377,7 @@ fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n+fn add_upstream_rust_crates(args: &mut Vec<StrBuf>, sess: &Session,\n                             dylib: bool, tmpdir: &Path,\n                             trans: &CrateTranslation) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1405,16 +1419,16 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: &config::Config, stem: &str) -> ~str {\n+    fn unlib(config: &config::Config, stem: &str) -> StrBuf {\n         if stem.starts_with(\"lib\") && config.os != abi::OsWin32 {\n-            stem.slice(3, stem.len()).to_owned()\n+            stem.slice(3, stem.len()).to_strbuf()\n         } else {\n-            stem.to_owned()\n+            stem.to_strbuf()\n         }\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crate(args: &mut Vec<~str>, sess: &Session, tmpdir: &Path,\n+    fn add_static_crate(args: &mut Vec<StrBuf>, sess: &Session, tmpdir: &Path,\n                         cnum: ast::CrateNum, cratepath: Path) {\n         // When performing LTO on an executable output, all of the\n         // bytecode from the upstream libraries has already been\n@@ -1445,21 +1459,21 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n                         sess.abort_if_errors();\n                     }\n                 }\n-                let dst_str = dst.as_str().unwrap().to_owned();\n+                let dst_str = dst.as_str().unwrap().to_strbuf();\n                 let mut archive = Archive::open(sess, dst);\n                 archive.remove_file(format!(\"{}.o\", name));\n                 let files = archive.files();\n-                if files.iter().any(|s| s.ends_with(\".o\")) {\n+                if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {\n                     args.push(dst_str);\n                 }\n             });\n         } else {\n-            args.push(cratepath.as_str().unwrap().to_owned());\n+            args.push(cratepath.as_str().unwrap().to_strbuf());\n         }\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(args: &mut Vec<~str>, sess: &Session,\n+    fn add_dynamic_crate(args: &mut Vec<StrBuf>, sess: &Session,\n                          cratepath: Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n@@ -1468,9 +1482,11 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         let dir = cratepath.dirname_str().unwrap();\n-        if !dir.is_empty() { args.push(\"-L\" + dir); }\n+        if !dir.is_empty() {\n+            args.push(format_strbuf!(\"-L{}\", dir));\n+        }\n         let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n-        args.push(\"-l\" + libarg);\n+        args.push(format_strbuf!(\"-l{}\", libarg));\n     }\n }\n \n@@ -1492,7 +1508,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n+fn add_upstream_native_libraries(args: &mut Vec<StrBuf>, sess: &Session) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1507,10 +1523,12 @@ fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in libs.iter() {\n             match kind {\n-                cstore::NativeUnknown => args.push(\"-l\" + *lib),\n+                cstore::NativeUnknown => {\n+                    args.push(format_strbuf!(\"-l{}\", *lib))\n+                }\n                 cstore::NativeFramework => {\n-                    args.push(\"-framework\".to_owned());\n-                    args.push(lib.to_owned());\n+                    args.push(\"-framework\".to_strbuf());\n+                    args.push(lib.to_strbuf());\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "74ac972e5c4b2c05ebac6b6fa1b43c9acc3ad843", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -20,7 +20,7 @@ use libc;\n use flate;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n-           tm: TargetMachineRef, reachable: &[~str]) {\n+           tm: TargetMachineRef, reachable: &[StrBuf]) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.err(\"cannot prefer dynamic linking when performing LTO\");\n         sess.note(\"only 'staticlib' and 'bin' outputs are supported with LTO\");\n@@ -67,13 +67,16 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *libc::c_char,\n                                                     bc.len() as libc::size_t) {\n-                link::llvm_err(sess, format!(\"failed to load bc of `{}`\", name));\n+                link::llvm_err(sess,\n+                               (format_strbuf!(\"failed to load bc of `{}`\",\n+                                               name)));\n             }\n         });\n     }\n \n     // Internalize everything but the reachable symbols of the current module\n-    let cstrs: Vec<::std::c_str::CString> = reachable.iter().map(|s| s.to_c_str()).collect();\n+    let cstrs: Vec<::std::c_str::CString> =\n+        reachable.iter().map(|s| s.as_slice().to_c_str()).collect();\n     let arr: Vec<*i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n     let ptr = arr.as_ptr();\n     unsafe {"}, {"sha": "d044d75ee7743cdb9af9dd26b7802396e20d773b", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -13,51 +13,52 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_owned(),\n+        module_asm: \"\".to_strbuf(),\n \n-        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name:\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            \"E-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsWin32 => {\n-            \"E-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsLinux => {\n-            \"E-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsAndroid => {\n-            \"E-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n \n           abi::OsFreebsd => {\n-            \"E-p:32:32:32\".to_owned() +\n-                \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n-                \"-f32:32:32-f64:64:64\" +\n-                \"-v64:64:64-v128:64:128\" +\n-                \"-a0:0:64-n32\"\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_strbuf()\n           }\n         },\n "}, {"sha": "8557cfc0bc2bbaa2db2520d0339476e91993f3ee", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 54, "deletions": 26, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -22,7 +22,7 @@ fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n+pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<StrBuf> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -33,9 +33,9 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let mut flags = Vec::new();\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n-        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_owned(),\n-                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_owned(),\n-                        \"-Wl,-z,origin\".to_owned()]);\n+        flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_strbuf(),\n+                        \"-Wl,-rpath,/usr/local/lib/gcc44\".to_strbuf(),\n+                        \"-Wl,-z,origin\".to_strbuf()]);\n     }\n \n     debug!(\"preparing the RPATH!\");\n@@ -47,16 +47,19 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(os, sysroot, output, libs.as_slice(),\n-                            sess.opts.target_triple);\n+    let rpaths = get_rpaths(os,\n+                            sysroot,\n+                            output,\n+                            libs.as_slice(),\n+                            sess.opts.target_triple.as_slice());\n     flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n-pub fn rpaths_to_flags(rpaths: &[~str]) -> Vec<~str> {\n+pub fn rpaths_to_flags(rpaths: &[StrBuf]) -> Vec<StrBuf> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(\"-Wl,-rpath,\" + *rpath);\n+        ret.push((\"-Wl,-rpath,\" + (*rpath).as_slice()).to_strbuf());\n     }\n     return ret;\n }\n@@ -65,7 +68,7 @@ fn get_rpaths(os: abi::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n-              target_triple: &str) -> Vec<~str> {\n+              target_triple: &str) -> Vec<StrBuf> {\n     debug!(\"sysroot: {}\", sysroot.display());\n     debug!(\"output: {}\", output.display());\n     debug!(\"libs:\");\n@@ -82,7 +85,7 @@ fn get_rpaths(os: abi::Os,\n     // And a final backup rpath to the global library location.\n     let fallback_rpaths = vec!(get_install_prefix_rpath(sysroot, target_triple));\n \n-    fn log_rpaths(desc: &str, rpaths: &[~str]) {\n+    fn log_rpaths(desc: &str, rpaths: &[StrBuf]) {\n         debug!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n             debug!(\"    {}\", *rpath);\n@@ -102,14 +105,14 @@ fn get_rpaths(os: abi::Os,\n \n fn get_rpaths_relative_to_output(os: abi::Os,\n                                  output: &Path,\n-                                 libs: &[Path]) -> Vec<~str> {\n+                                 libs: &[Path]) -> Vec<StrBuf> {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: abi::Os,\n                                     output: &Path,\n                                     lib: &Path)\n-                                 -> ~str {\n+                                 -> StrBuf {\n     use std::os;\n \n     assert!(not_win32(os));\n@@ -129,21 +132,22 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    prefix+\"/\"+relative.as_str().expect(\"non-utf8 component in path\")\n+    (prefix + \"/\" + relative.as_str()\n+                            .expect(\"non-utf8 component in path\")).to_strbuf()\n }\n \n-pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> ~str {\n+pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> StrBuf {\n     let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n \n     let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n     let mut path = Path::new(install_prefix);\n     path.push(&tlib);\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n+    path.as_str().expect(\"non-utf8 component in rpath\").to_strbuf()\n }\n \n-pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n+pub fn minimize_rpaths(rpaths: &[StrBuf]) -> Vec<StrBuf> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n@@ -163,8 +167,13 @@ mod test {\n \n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags([\"path1\".to_owned(), \"path2\".to_owned()]);\n-        assert_eq!(flags, vec!(\"-Wl,-rpath,path1\".to_owned(), \"-Wl,-rpath,path2\".to_owned()));\n+        let flags = rpaths_to_flags([\n+            \"path1\".to_strbuf(),\n+            \"path2\".to_strbuf()\n+        ]);\n+        assert_eq!(flags,\n+                   vec!(\"-Wl,-rpath,path1\".to_strbuf(),\n+                        \"-Wl,-rpath,path2\".to_strbuf()));\n     }\n \n     #[test]\n@@ -190,18 +199,37 @@ mod test {\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths([\"rpath1\".to_owned(), \"rpath2\".to_owned(), \"rpath1\".to_owned()]);\n-        assert!(res.as_slice() == [\"rpath1\".to_owned(), \"rpath2\".to_owned()]);\n+        let res = minimize_rpaths([\n+            \"rpath1\".to_strbuf(),\n+            \"rpath2\".to_strbuf(),\n+            \"rpath1\".to_strbuf()\n+        ]);\n+        assert!(res.as_slice() == [\n+            \"rpath1\".to_strbuf(),\n+            \"rpath2\".to_strbuf()\n+        ]);\n     }\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths([\"1a\".to_owned(), \"2\".to_owned(),  \"2\".to_owned(),\n-                                   \"1a\".to_owned(), \"4a\".to_owned(), \"1a\".to_owned(),\n-                                   \"2\".to_owned(),  \"3\".to_owned(),  \"4a\".to_owned(),\n-                                   \"3\".to_owned()]);\n-        assert!(res.as_slice() == [\"1a\".to_owned(), \"2\".to_owned(), \"4a\".to_owned(),\n-                                   \"3\".to_owned()]);\n+        let res = minimize_rpaths([\n+            \"1a\".to_strbuf(),\n+            \"2\".to_strbuf(),\n+            \"2\".to_strbuf(),\n+            \"1a\".to_strbuf(),\n+            \"4a\".to_strbuf(),\n+            \"1a\".to_strbuf(),\n+            \"2\".to_strbuf(),\n+            \"3\".to_strbuf(),\n+            \"4a\".to_strbuf(),\n+            \"3\".to_strbuf()\n+        ]);\n+        assert!(res.as_slice() == [\n+            \"1a\".to_strbuf(),\n+            \"2\".to_strbuf(),\n+            \"4a\".to_strbuf(),\n+            \"3\".to_strbuf()\n+        ]);\n     }\n \n     #[test]"}, {"sha": "8a2f7ff1976507a34dbd0b83b23757b11117bdbd", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -54,13 +54,13 @@ use syntax::ast;\n \n #[deriving(Clone, Eq)]\n pub struct Svh {\n-    hash: ~str,\n+    hash: StrBuf,\n }\n \n impl Svh {\n     pub fn new(hash: &str) -> Svh {\n         assert!(hash.len() == 16);\n-        Svh { hash: hash.to_owned() }\n+        Svh { hash: hash.to_strbuf() }\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {"}, {"sha": "9dc85dfe3966712b768ac6ba61ac9000aeb83fad", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -11,9 +11,9 @@\n #![allow(non_camel_case_types)]\n \n pub struct t {\n-    pub module_asm: ~str,\n-    pub meta_sect_name: ~str,\n-    pub data_layout: ~str,\n-    pub target_triple: ~str,\n-    pub cc_args: Vec<~str> ,\n+    pub module_asm: StrBuf,\n+    pub meta_sect_name: StrBuf,\n+    pub data_layout: StrBuf,\n+    pub target_triple: StrBuf,\n+    pub cc_args: Vec<StrBuf> ,\n }"}, {"sha": "68a5d4d2ce2c28bb682d4ef6f6efe3576f08b531", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -14,38 +14,41 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os)\n+                       -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_owned(),\n+        module_asm: \"\".to_strbuf(),\n \n-        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name:\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\".to_owned() +\n-                \"-i32:32:32-i64:32:64\" +\n-                \"-f32:32:32-f64:32:64-v64:64:64\" +\n-                \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\"\n+            \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n+                -i32:32:32-i64:32:64\\\n+                -f32:32:32-f64:32:64-v64:64:64\\\n+                -v128:128:128-a0:0:64-f80:128:128\\\n+                -n8:16:32\".to_strbuf()\n           }\n \n           abi::OsWin32 => {\n-            \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_owned()\n+            \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_strbuf()\n           }\n \n           abi::OsLinux => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n           }\n           abi::OsAndroid => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n           }\n \n           abi::OsFreebsd => {\n-            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_owned()\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_strbuf()\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(\"-m32\".to_owned()),\n+        cc_args: vec!(\"-m32\".to_strbuf()),\n     };\n }"}, {"sha": "d0c72fe46d2a391ab3522016737f539d54e3b244", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -14,46 +14,47 @@ use driver::config::cfg_os_to_meta_os;\n use metadata::loader::meta_section_name;\n use syntax::abi;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: StrBuf, target_os: abi::Os) -> target_strs::t {\n     return target_strs::t {\n-        module_asm: \"\".to_owned(),\n+        module_asm: \"\".to_strbuf(),\n \n-        meta_sect_name: meta_section_name(cfg_os_to_meta_os(target_os)).to_owned(),\n+        meta_sect_name:\n+            meta_section_name(cfg_os_to_meta_os(target_os)).to_strbuf(),\n \n         data_layout: match target_os {\n           abi::OsMacos => {\n-            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n-                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n-                \"s0:64:64-f80:128:128-n8:16:32:64\"\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64\".to_strbuf()\n           }\n \n           abi::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n-            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n-                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n-                \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n           }\n \n           abi::OsLinux => {\n-            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n-                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n-                \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n           }\n           abi::OsAndroid => {\n-            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n-                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n-                \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n           }\n \n           abi::OsFreebsd => {\n-            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\".to_owned()+\n-                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n-                \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64-S128\".to_strbuf()\n           }\n         },\n \n         target_triple: target_triple,\n \n-        cc_args: vec!(\"-m64\".to_owned()),\n+        cc_args: vec!(\"-m64\".to_strbuf()),\n     };\n }"}, {"sha": "e9c8d4a58cdefd6a624e306fab25c2f0a96384fd", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -76,7 +76,7 @@ pub struct Options {\n     // this.\n     pub addl_lib_search_paths: RefCell<HashSet<Path>>,\n     pub maybe_sysroot: Option<Path>,\n-    pub target_triple: ~str,\n+    pub target_triple: StrBuf,\n     // User-specified cfg meta items. The compiler itself will add additional\n     // items to the crate config, and during parsing the entire crate config\n     // will be added to the crate AST node.  This should not be used for\n@@ -105,7 +105,7 @@ pub fn basic_options() -> Options {\n         output_types: Vec::new(),\n         addl_lib_search_paths: RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n-        target_triple: driver::host_triple().to_owned(),\n+        target_triple: driver::host_triple().to_strbuf(),\n         cfg: Vec::new(),\n         test: false,\n         parse_only: false,\n@@ -247,26 +247,26 @@ macro_rules! cgoptions(\n             }\n         }\n \n-        fn parse_opt_string(slot: &mut Option<~str>, v: Option<&str>) -> bool {\n+        fn parse_opt_string(slot: &mut Option<StrBuf>, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = Some(s.to_owned()); true },\n+                Some(s) => { *slot = Some(s.to_strbuf()); true },\n                 None => false,\n             }\n         }\n \n-        fn parse_string(slot: &mut ~str, v: Option<&str>) -> bool {\n+        fn parse_string(slot: &mut StrBuf, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = s.to_owned(); true },\n+                Some(s) => { *slot = s.to_strbuf(); true },\n                 None => false,\n             }\n         }\n \n-        fn parse_list(slot: &mut Vec<~str>, v: Option<&str>)\n+        fn parse_list(slot: &mut Vec<StrBuf>, v: Option<&str>)\n                       -> bool {\n             match v {\n                 Some(s) => {\n                     for s in s.words() {\n-                        slot.push(s.to_owned());\n+                        slot.push(s.to_strbuf());\n                     }\n                     true\n                 },\n@@ -278,23 +278,23 @@ macro_rules! cgoptions(\n ) )\n \n cgoptions!(\n-    ar: Option<~str> = (None, parse_opt_string,\n+    ar: Option<StrBuf> = (None, parse_opt_string,\n         \"tool to assemble archives with\"),\n-    linker: Option<~str> = (None, parse_opt_string,\n+    linker: Option<StrBuf> = (None, parse_opt_string,\n         \"system linker to link outputs with\"),\n-    link_args: Vec<~str> = (Vec::new(), parse_list,\n+    link_args: Vec<StrBuf> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n-    target_cpu: ~str = (\"generic\".to_owned(), parse_string,\n+    target_cpu: StrBuf = (\"generic\".to_strbuf(), parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n-    target_feature: ~str = (\"\".to_owned(), parse_string,\n+    target_feature: StrBuf = (\"\".to_strbuf(), parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n-    passes: Vec<~str> = (Vec::new(), parse_list,\n+    passes: Vec<StrBuf> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<~str> = (Vec::new(), parse_list,\n+    llvm_args: Vec<StrBuf> = (Vec::new(), parse_list,\n         \"a list of arguments to pass to llvm (space separated)\"),\n     save_temps: bool = (false, parse_bool,\n         \"save all temporary output files during compilation\"),\n-    android_cross_path: Option<~str> = (None, parse_opt_string,\n+    android_cross_path: Option<StrBuf> = (None, parse_opt_string,\n         \"the path to the Android NDK\"),\n     no_rpath: bool = (false, parse_bool,\n         \"disables setting the rpath in libs/exes\"),\n@@ -310,7 +310,7 @@ cgoptions!(\n         \"prefer dynamic linking to static linking\"),\n     no_integrated_as: bool = (false, parse_bool,\n         \"use an external assembler rather than LLVM's integrated one\"),\n-    relocation_model: ~str = (\"pic\".to_owned(), parse_string,\n+    relocation_model: StrBuf = (\"pic\".to_strbuf(), parse_string,\n          \"choose the relocation model to use (llc -relocation-model for details)\"),\n )\n \n@@ -456,13 +456,16 @@ static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'stat\n     (\"mips\",   abi::Mips)];\n \n pub fn build_target_config(sopts: &Options) -> Config {\n-    let os = match get_os(sopts.target_triple) {\n+    let os = match get_os(sopts.target_triple.as_slice()) {\n       Some(os) => os,\n       None => early_error(\"unknown operating system\")\n     };\n-    let arch = match get_arch(sopts.target_triple) {\n+    let arch = match get_arch(sopts.target_triple.as_slice()) {\n       Some(arch) => arch,\n-      None => early_error(\"unknown architecture: \" + sopts.target_triple)\n+      None => {\n+          early_error(\"unknown architecture: \" +\n+                      sopts.target_triple.as_slice())\n+      }\n     };\n     let (int_type, uint_type) = match arch {\n       abi::X86 => (ast::TyI32, ast::TyU32),\n@@ -541,7 +544,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n \n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: Vec<~str> ) -> ast::CrateConfig {\n+fn parse_cfgspecs(cfgspecs: Vec<StrBuf> ) -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         parse::parse_meta_from_source_str(\"cfgspec\".to_strbuf(),\n                                           s.to_strbuf(),\n@@ -639,7 +642,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n-    let target = matches.opt_str(\"target\").unwrap_or(driver::host_triple().to_owned());\n+    let target = match matches.opt_str(\"target\") {\n+        Some(supplied_target) => supplied_target.to_strbuf(),\n+        None => driver::host_triple().to_strbuf(),\n+    };\n     let opt_level = {\n         if (debugging_opts & NO_OPT) != 0 {\n             No\n@@ -689,10 +695,14 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Path::new(s.as_slice())\n     }).collect();\n \n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\")\n+                                    .move_iter()\n+                                    .map(|x| x.to_strbuf())\n+                                    .collect());\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n-                                 matches.opt_str(\"dep-info\").map(|p| Path::new(p)));\n+                                 matches.opt_str(\"dep-info\")\n+                                        .map(|p| Path::new(p)));\n \n     let print_metas = (matches.opt_present(\"crate-id\"),\n                        matches.opt_present(\"crate-name\"),"}, {"sha": "f5f85d748bb27767bfa2a9d628b32ec90e285fd2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -71,9 +71,9 @@ pub fn compile_input(sess: Session,\n                                                  &sess);\n             let loader = &mut Loader::new(&sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n-                                         outputs.out_filestem);\n-            let (expanded_crate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n-                                                                         krate, &id);\n+                                         outputs.out_filestem.as_slice());\n+            let (expanded_crate, ast_map) =\n+                phase_2_configure_and_expand(&sess, loader, krate, &id);\n             (outputs, expanded_crate, ast_map)\n         };\n         write_out_deps(&sess, input, &outputs, &expanded_crate);\n@@ -99,14 +99,14 @@ pub fn compile_input(sess: Session,\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-pub fn anon_src() -> ~str {\n-    \"<anon>\".to_str()\n+pub fn anon_src() -> StrBuf {\n+    \"<anon>\".to_strbuf()\n }\n \n-pub fn source_name(input: &Input) -> ~str {\n+pub fn source_name(input: &Input) -> StrBuf {\n     match *input {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n+        FileInput(ref ifile) => ifile.as_str().unwrap().to_strbuf(),\n         StrInput(_) => anon_src()\n     }\n }\n@@ -115,14 +115,14 @@ pub enum Input {\n     /// Load source from file\n     FileInput(Path),\n     /// The string is the source\n-    StrInput(~str)\n+    StrInput(StrBuf)\n }\n \n impl Input {\n-    fn filestem(&self) -> ~str {\n+    fn filestem(&self) -> StrBuf {\n         match *self {\n-            FileInput(ref ifile) => ifile.filestem_str().unwrap().to_str(),\n-            StrInput(_) => \"rust_out\".to_owned(),\n+            FileInput(ref ifile) => ifile.filestem_str().unwrap().to_strbuf(),\n+            StrInput(_) => \"rust_out\".to_strbuf(),\n         }\n     }\n }\n@@ -354,7 +354,7 @@ pub struct CrateTranslation {\n     pub metadata_module: ModuleRef,\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n-    pub reachable: Vec<~str>,\n+    pub reachable: Vec<StrBuf>,\n     pub crate_formats: dependency_format::Dependencies,\n }\n \n@@ -450,7 +450,8 @@ fn write_out_deps(sess: &Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) {\n-    let id = link::find_crate_id(krate.attrs.as_slice(), outputs.out_filestem);\n+    let id = link::find_crate_id(krate.attrs.as_slice(),\n+                                 outputs.out_filestem.as_slice());\n \n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.iter() {\n@@ -487,9 +488,9 @@ fn write_out_deps(sess: &Session,\n     let result = (|| {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n-        let files: Vec<~str> = sess.codemap().files.borrow()\n+        let files: Vec<StrBuf> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| fmap.name.to_owned())\n+                                   .map(|fmap| fmap.name.to_strbuf())\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -567,7 +568,9 @@ impl pprust::PpAnn for TypedAnnotation {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                                ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n+                              ppaux::ty_to_str(\n+                                  tcx,\n+                                  ty::expr_ty(tcx, expr)).as_slice()));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -581,20 +584,26 @@ pub fn pretty_print_input(sess: Session,\n                           ppm: ::driver::PpMode,\n                           ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n-    let id = link::find_crate_id(krate.attrs.as_slice(), input.filestem());\n+    let id = link::find_crate_id(krate.attrs.as_slice(),\n+                                 input.filestem().as_slice());\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n             let loader = &mut Loader::new(&sess);\n-            let (krate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n-                                                                krate, &id);\n+            let (krate, ast_map) = phase_2_configure_and_expand(&sess,\n+                                                                loader,\n+                                                                krate,\n+                                                                &id);\n             (krate, Some(ast_map), true)\n         }\n         _ => (krate, None, false)\n     };\n \n     let src_name = source_name(input);\n-    let src = Vec::from_slice(sess.codemap().get_filemap(src_name).src.as_bytes());\n+    let src = Vec::from_slice(sess.codemap()\n+                                  .get_filemap(src_name.as_slice())\n+                                  .src\n+                                  .as_bytes());\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {\n@@ -666,8 +675,12 @@ pub fn collect_crate_types(session: &Session,\n         let iter = attrs.iter().filter_map(|a| {\n             if a.name().equiv(&(\"crate_type\")) {\n                 match a.value_str() {\n-                    Some(ref n) if n.equiv(&(\"rlib\")) => Some(config::CrateTypeRlib),\n-                    Some(ref n) if n.equiv(&(\"dylib\")) => Some(config::CrateTypeDylib),\n+                    Some(ref n) if n.equiv(&(\"rlib\")) => {\n+                        Some(config::CrateTypeRlib)\n+                    }\n+                    Some(ref n) if n.equiv(&(\"dylib\")) => {\n+                        Some(config::CrateTypeDylib)\n+                    }\n                     Some(ref n) if n.equiv(&(\"lib\")) => {\n                         Some(config::default_lib_output())\n                     }\n@@ -679,12 +692,16 @@ pub fn collect_crate_types(session: &Session,\n                         session.add_lint(lint::UnknownCrateType,\n                                          ast::CRATE_NODE_ID,\n                                          a.span,\n-                                         \"invalid `crate_type` value\".to_owned());\n+                                         \"invalid `crate_type` \\\n+                                          value\".to_strbuf());\n                         None\n                     }\n                     _ => {\n-                        session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n-                                        a.span, \"`crate_type` requires a value\".to_owned());\n+                        session.add_lint(lint::UnknownCrateType,\n+                                         ast::CRATE_NODE_ID,\n+                                         a.span,\n+                                         \"`crate_type` requires a \\\n+                                          value\".to_strbuf());\n                         None\n                     }\n                 }\n@@ -704,7 +721,7 @@ pub fn collect_crate_types(session: &Session,\n \n pub struct OutputFilenames {\n     pub out_directory: Path,\n-    pub out_filestem: ~str,\n+    pub out_filestem: StrBuf,\n     pub single_output_file: Option<Path>,\n }\n \n@@ -756,7 +773,7 @@ pub fn build_output_filenames(input: &Input,\n             let crateid = attr::find_crateid(attrs);\n             match crateid {\n                 None => {}\n-                Some(crateid) => stem = crateid.name.to_str(),\n+                Some(crateid) => stem = crateid.name.to_strbuf(),\n             }\n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -778,7 +795,7 @@ pub fn build_output_filenames(input: &Input,\n             }\n             OutputFilenames {\n                 out_directory: out_file.dir_path(),\n-                out_filestem: out_file.filestem_str().unwrap().to_str(),\n+                out_filestem: out_file.filestem_str().unwrap().to_strbuf(),\n                 single_output_file: ofile,\n             }\n         }"}, {"sha": "db91303b5331699b071d72eca140edb819cfb046", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -56,7 +56,8 @@ fn run_compiler(args: &[~str]) {\n             let ifile = matches.free.get(0).as_slice();\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n-                let src = str::from_utf8(contents.as_slice()).unwrap().to_owned();\n+                let src = str::from_utf8(contents.as_slice()).unwrap()\n+                                                             .to_strbuf();\n                 (StrInput(src), None)\n             } else {\n                 (FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n@@ -249,9 +250,13 @@ fn print_crate_info(sess: &Session,\n     // these nasty nested conditions are to avoid doing extra work\n     if crate_id || crate_name || crate_file_name {\n         let attrs = parse_crate_attrs(sess, input);\n-        let t_outputs = driver::build_output_filenames(input, odir, ofile,\n-                                                       attrs.as_slice(), sess);\n-        let id = link::find_crate_id(attrs.as_slice(), t_outputs.out_filestem);\n+        let t_outputs = driver::build_output_filenames(input,\n+                                                       odir,\n+                                                       ofile,\n+                                                       attrs.as_slice(),\n+                                                       sess);\n+        let id = link::find_crate_id(attrs.as_slice(),\n+                                     t_outputs.out_filestem.as_slice());\n \n         if crate_id {\n             println!(\"{}\", id.to_str());"}, {"sha": "b5176d3f4a8ddd0e130f898f7a474e6b7d065819", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -28,7 +28,6 @@ use syntax::{ast, codemap};\n use std::os;\n use std::cell::{Cell, RefCell};\n \n-\n pub struct Session {\n     pub targ_cfg: config::Config,\n     pub opts: config::Options,\n@@ -43,7 +42,7 @@ pub struct Session {\n     // expected to be absolute. `None` means that there is no source file.\n     pub local_crate_source_file: Option<Path>,\n     pub working_dir: Path,\n-    pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, ~str)>>>,\n+    pub lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, StrBuf)>>>,\n     pub node_id: Cell<ast::NodeId>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub features: front::feature_gate::Features,\n@@ -109,7 +108,7 @@ impl Session {\n                     lint: lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n-                    msg: ~str) {\n+                    msg: StrBuf) {\n         let mut lints = self.lints.borrow_mut();\n         match lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n@@ -180,10 +179,9 @@ impl Session {\n         }\n     }\n     pub fn target_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n-        filesearch::FileSearch::new(\n-            self.sysroot(),\n-            self.opts.target_triple,\n-            &self.opts.addl_lib_search_paths)\n+        filesearch::FileSearch::new(self.sysroot(),\n+                                    self.opts.target_triple.as_slice(),\n+                                    &self.opts.addl_lib_search_paths)\n     }\n     pub fn host_filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n         filesearch::FileSearch::new(\n@@ -245,7 +243,6 @@ pub fn build_session_(sopts: config::Options,\n     }\n }\n \n-\n // Seems out of place, but it uses session, so I'm putting it here\n pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> StrBuf)\n               -> T {"}, {"sha": "b6022f5675926edbad249800eeeb141e840588e7", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -359,7 +359,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                             sess.add_lint(lint::UnknownFeatures,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n-                                          \"unknown feature\".to_owned());\n+                                          \"unknown feature\".to_strbuf());\n                         }\n                     }\n                 }"}, {"sha": "d11c8898ad4cd8c9fa7787278f303342e82d3544", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -119,7 +119,6 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n-\n pub fn main() {\n     std::os::set_exit_status(driver::main_args(std::os::args().as_slice()));\n }"}, {"sha": "e3d0e78e93873e335c18db29f8dbc6136d4e3ee6", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1840,7 +1840,7 @@ pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    named_types: RefCell<HashMap<~str, TypeRef>>,\n+    named_types: RefCell<HashMap<StrBuf, TypeRef>>,\n }\n \n impl TypeNames {\n@@ -1851,33 +1851,34 @@ impl TypeNames {\n     }\n \n     pub fn associate_type(&self, s: &str, t: &Type) {\n-        assert!(self.named_types.borrow_mut().insert(s.to_owned(), t.to_ref()));\n+        assert!(self.named_types.borrow_mut().insert(s.to_strbuf(),\n+                                                     t.to_ref()));\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n         self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n-    pub fn type_to_str(&self, ty: Type) -> ~str {\n+    pub fn type_to_str(&self, ty: Type) -> StrBuf {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n             let ret = from_c_str(s);\n             free(s as *mut c_void);\n-            ret\n+            ret.to_strbuf()\n         }\n     }\n \n-    pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n-        let strs: Vec<~str> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n-        format!(\"[{}]\", strs.connect(\",\"))\n+    pub fn types_to_str(&self, tys: &[Type]) -> StrBuf {\n+        let strs: Vec<StrBuf> = tys.iter().map(|t| self.type_to_str(*t)).collect();\n+        format_strbuf!(\"[{}]\", strs.connect(\",\").to_strbuf())\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+    pub fn val_to_str(&self, val: ValueRef) -> StrBuf {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n             let ret = from_c_str(s);\n             free(s as *mut c_void);\n-            ret\n+            ret.to_strbuf()\n         }\n     }\n }"}, {"sha": "eabd316b7c5053135a6a4487fbb69567ce7c6914", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -120,8 +120,11 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let (cnum, _, _) = resolve_crate(e, &None, info.ident,\n-                                             &info.crate_id, None,\n+            let (cnum, _, _) = resolve_crate(e,\n+                                             &None,\n+                                             info.ident.as_slice(),\n+                                             &info.crate_id,\n+                                             None,\n                                              i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -130,7 +133,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n }\n \n struct CrateInfo {\n-    ident: ~str,\n+    ident: StrBuf,\n     crate_id: CrateId,\n     id: ast::NodeId,\n     should_link: bool,\n@@ -156,7 +159,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                 None => from_str(ident.get().to_str()).unwrap()\n             };\n             Some(CrateInfo {\n-                ident: ident.get().to_str(),\n+                ident: ident.get().to_strbuf(),\n                 crate_id: crate_id,\n                 id: id,\n                 should_link: should_link(i),\n@@ -237,7 +240,9 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                         if n.get().is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            e.sess.cstore.add_used_library(n.get().to_owned(), kind);\n+                            e.sess\n+                             .cstore\n+                             .add_used_library(n.get().to_strbuf(), kind);\n                         }\n                     }\n                     None => {}\n@@ -279,7 +284,7 @@ fn register_crate<'a>(e: &mut Env,\n     // Stash paths for top-most crate locally if necessary.\n     let crate_paths = if root.is_none() {\n         Some(CratePaths {\n-            ident: ident.to_owned(),\n+            ident: ident.to_strbuf(),\n             dylib: lib.dylib.clone(),\n             rlib:  lib.rlib.clone(),\n         })\n@@ -294,7 +299,7 @@ fn register_crate<'a>(e: &mut Env,\n     let loader::Library{ dylib, rlib, metadata } = lib;\n \n     let cmeta = Rc::new( cstore::crate_metadata {\n-        name: crate_id.name.to_owned(),\n+        name: crate_id.name.to_strbuf(),\n         data: metadata,\n         cnum_map: cnum_map,\n         cnum: cnum,\n@@ -328,7 +333,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 span: span,\n                 ident: ident,\n                 crate_id: crate_id,\n-                id_hash: id_hash,\n+                id_hash: id_hash.as_slice(),\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n                 os: config::cfg_os_to_meta_os(e.sess.targ_cfg.os),\n@@ -391,9 +396,9 @@ impl<'a> CrateLoader for Loader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n-            ident: info.ident,\n+            ident: info.ident.as_slice(),\n             crate_id: &info.crate_id,\n-            id_hash: id_hash,\n+            id_hash: id_hash.as_slice(),\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: driver::host_triple(),"}, {"sha": "fc5c01d4d8dbf0ae2fdfe524cae76ca17586bcfe", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -32,7 +32,7 @@ pub struct StaticMethodInfo {\n     pub vis: ast::Visibility,\n }\n \n-pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n+pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> StrBuf {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_symbol(cdata.data(), def.node)\n }\n@@ -86,7 +86,8 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    (vec!(ast_map::PathMod(token::intern(cdata.name)))).append(path.as_slice())\n+    (vec!(ast_map::PathMod(token::intern(cdata.name.as_slice())))).append(\n+        path.as_slice())\n }\n \n pub enum found_ast {\n@@ -245,7 +246,7 @@ pub fn get_impl_vtables(tcx: &ty::ctxt,\n \n pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n-                                -> Vec<(cstore::NativeLibaryKind, ~str)> {\n+                                -> Vec<(cstore::NativeLibaryKind, StrBuf)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(&*cdata)\n }"}, {"sha": "ede70c94ecb02e68c85813db583bd095340de43e", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -38,7 +38,7 @@ pub enum MetadataBlob {\n }\n \n pub struct crate_metadata {\n-    pub name: ~str,\n+    pub name: StrBuf,\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n@@ -71,8 +71,8 @@ pub struct CStore {\n     metas: RefCell<HashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n-    used_libraries: RefCell<Vec<(~str, NativeLibaryKind)>>,\n-    used_link_args: RefCell<Vec<~str>>,\n+    used_libraries: RefCell<Vec<(StrBuf, NativeLibaryKind)>>,\n+    used_link_args: RefCell<Vec<StrBuf>>,\n     pub intr: Rc<IdentInterner>,\n }\n \n@@ -178,23 +178,23 @@ impl CStore {\n         libs\n     }\n \n-    pub fn add_used_library(&self, lib: ~str, kind: NativeLibaryKind) {\n+    pub fn add_used_library(&self, lib: StrBuf, kind: NativeLibaryKind) {\n         assert!(!lib.is_empty());\n         self.used_libraries.borrow_mut().push((lib, kind));\n     }\n \n     pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<Vec<(~str, NativeLibaryKind)> > {\n+                              -> &'a RefCell<Vec<(StrBuf, NativeLibaryKind)> > {\n         &self.used_libraries\n     }\n \n     pub fn add_used_link_args(&self, args: &str) {\n         for s in args.split(' ') {\n-            self.used_link_args.borrow_mut().push(s.to_owned());\n+            self.used_link_args.borrow_mut().push(s.to_strbuf());\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<~str> > {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<StrBuf> > {\n         &self.used_link_args\n     }\n "}, {"sha": "da21cde3d6cc1c99b392451b5a225ee66e50eb70", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -184,8 +184,8 @@ fn item_method_sort(item: ebml::Doc) -> char {\n     ret\n }\n \n-fn item_symbol(item: ebml::Doc) -> ~str {\n-    reader::get_doc(item, tag_items_data_item_symbol).as_str()\n+fn item_symbol(item: ebml::Doc) -> StrBuf {\n+    reader::get_doc(item, tag_items_data_item_symbol).as_str().to_strbuf()\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n@@ -451,7 +451,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n }\n \n \n-pub fn get_symbol(data: &[u8], id: ast::NodeId) -> ~str {\n+pub fn get_symbol(data: &[u8], id: ast::NodeId) -> StrBuf {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -1097,13 +1097,15 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> StrBuf {\n         let d = reader::get_doc(doc, tag_);\n-        d.as_str_slice().to_str()\n+        d.as_str_slice().to_strbuf()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n-        let crate_id = from_str(docstr(depdoc, tag_crate_dep_crateid)).unwrap();\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n+        let crate_id =\n+            from_str(docstr(depdoc,\n+                            tag_crate_dep_crateid).as_slice()).unwrap();\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).as_slice());\n         deps.push(CrateDep {\n             cnum: crate_num,\n             crate_id: crate_id,\n@@ -1144,10 +1146,10 @@ pub fn maybe_get_crate_id(data: &[u8]) -> Option<CrateId> {\n     })\n }\n \n-pub fn get_crate_triple(data: &[u8]) -> ~str {\n+pub fn get_crate_triple(data: &[u8]) -> StrBuf {\n     let cratedoc = reader::Doc(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n-    triple_doc.expect(\"No triple in crate\").as_str()\n+    triple_doc.expect(\"No triple in crate\").as_str().to_strbuf()\n }\n \n pub fn get_crate_id(data: &[u8]) -> CrateId {\n@@ -1239,7 +1241,8 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n }\n \n \n-pub fn get_native_libraries(cdata: Cmd) -> Vec<(cstore::NativeLibaryKind, ~str)> {\n+pub fn get_native_libraries(cdata: Cmd)\n+                            -> Vec<(cstore::NativeLibaryKind, StrBuf)> {\n     let libraries = reader::get_doc(reader::Doc(cdata.data()),\n                                     tag_native_libraries);\n     let mut result = Vec::new();\n@@ -1248,7 +1251,7 @@ pub fn get_native_libraries(cdata: Cmd) -> Vec<(cstore::NativeLibaryKind, ~str)>\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibaryKind =\n             FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n-        let name = name_doc.as_str();\n+        let name = name_doc.as_str().to_strbuf();\n         result.push((kind, name));\n         true\n     });\n@@ -1260,12 +1263,12 @@ pub fn get_macro_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n-pub fn get_exported_macros(data: &[u8]) -> Vec<~str> {\n+pub fn get_exported_macros(data: &[u8]) -> Vec<StrBuf> {\n     let macros = reader::get_doc(reader::Doc(data),\n                                  tag_exported_macros);\n     let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n-        result.push(macro_doc.as_str());\n+        result.push(macro_doc.as_str().to_strbuf());\n         true\n     });\n     result"}, {"sha": "a7ba8300aed685fd50268810963e881f9750c33f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -70,7 +70,7 @@ pub struct EncodeParams<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n-    pub item_symbols: &'a RefCell<NodeMap<~str>>,\n+    pub item_symbols: &'a RefCell<NodeMap<StrBuf>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -81,7 +81,7 @@ pub struct EncodeContext<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n-    pub item_symbols: &'a RefCell<NodeMap<~str>>,\n+    pub item_symbols: &'a RefCell<NodeMap<StrBuf>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n@@ -98,7 +98,7 @@ fn encode_impl_type_basename(ebml_w: &mut Encoder, name: Ident) {\n }\n \n pub fn encode_def_id(ebml_w: &mut Encoder, id: DefId) {\n-    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n+    ebml_w.wr_tagged_str(tag_def_id, def_to_str(id).as_slice());\n }\n \n #[deriving(Clone)]\n@@ -139,8 +139,8 @@ fn encode_family(ebml_w: &mut Encoder, c: char) {\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: DefId) -> ~str {\n-    format!(\"{}:{}\", did.krate, did.node)\n+pub fn def_to_str(did: DefId) -> StrBuf {\n+    format_strbuf!(\"{}:{}\", did.krate, did.node)\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n@@ -170,7 +170,7 @@ fn encode_region_param_defs(ebml_w: &mut Encoder,\n         ebml_w.end_tag();\n \n         ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_str(param.def_id));\n+                             def_to_str(param.def_id).as_slice());\n \n         ebml_w.end_tag();\n     }\n@@ -370,10 +370,12 @@ fn encode_reexported_static_method(ebml_w: &mut Encoder,\n             exp.name, token::get_ident(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_str(method_def_id));\n+    ebml_w.wr_str(def_to_str(method_def_id).as_slice());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(format!(\"{}::{}\", exp.name, token::get_ident(method_ident)));\n+    ebml_w.wr_str(format!(\"{}::{}\",\n+                          exp.name,\n+                          token::get_ident(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -447,7 +449,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // encoded metadata for static methods relative to Bar,\n             // but not yet for Foo.\n             //\n-            if path_differs || original_name.get() != exp.name {\n+            if path_differs || original_name.get() != exp.name.as_slice() {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\\n@@ -515,10 +517,10 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.wr_str(def_to_str(exp.def_id).as_slice());\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n+                ebml_w.wr_str(exp.name.as_slice());\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n                 encode_reexported_static_methods(ecx, ebml_w, path.clone(), exp);\n@@ -547,12 +549,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.wr_str(def_to_str(local_def(item.id)).as_slice());\n         ebml_w.end_tag();\n \n         each_auxiliary_node_id(*item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.wr_str(def_to_str(local_def(\n+                        auxiliary_node_id)).as_slice());\n             ebml_w.end_tag();\n             true\n         });\n@@ -566,7 +569,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                         did, ecx.tcx.map.node_to_str(did));\n \n                 ebml_w.start_tag(tag_mod_impl);\n-                ebml_w.wr_str(def_to_str(local_def(did)));\n+                ebml_w.wr_str(def_to_str(local_def(did)).as_slice());\n                 ebml_w.end_tag();\n             }\n             _ => {}\n@@ -931,7 +934,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n+            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)).as_slice());\n             ebml_w.end_tag();\n         }\n         encode_visibility(ebml_w, vis);\n@@ -1111,7 +1114,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n \n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(method_def_id));\n+            ebml_w.wr_str(def_to_str(method_def_id).as_slice());\n             ebml_w.end_tag();\n         }\n         encode_path(ebml_w, path.clone());\n@@ -1647,12 +1650,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_misc_info_crate_items);\n     for &item in krate.module.items.iter() {\n         ebml_w.start_tag(tag_mod_child);\n-        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.wr_str(def_to_str(local_def(item.id)).as_slice());\n         ebml_w.end_tag();\n \n         each_auxiliary_node_id(item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n-            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.wr_str(def_to_str(local_def(\n+                        auxiliary_node_id)).as_slice());\n             ebml_w.end_tag();\n             true\n         });\n@@ -1700,11 +1704,11 @@ fn encode_dylib_dependency_formats(ebml_w: &mut Encoder, ecx: &EncodeContext) {\n     match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n-                slot.map(|kind| format!(\"{}:{}\", i + 1, match kind {\n+                slot.map(|kind| (format!(\"{}:{}\", i + 1, match kind {\n                     cstore::RequireDynamic => \"d\",\n                     cstore::RequireStatic => \"s\",\n-                }))\n-            }).collect::<Vec<~str>>();\n+                })).to_strbuf())\n+            }).collect::<Vec<StrBuf>>();\n             ebml_w.writer.write(s.connect(\",\").as_bytes());\n         }\n         None => {}\n@@ -1781,7 +1785,12 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     let mut ebml_w = writer::Encoder(wr);\n \n     encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n-    encode_crate_triple(&mut ebml_w, tcx.sess.targ_cfg.target_strs.target_triple);\n+    encode_crate_triple(&mut ebml_w,\n+                        tcx.sess\n+                           .targ_cfg\n+                           .target_strs\n+                           .target_triple\n+                           .as_slice());\n     encode_hash(&mut ebml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut ebml_w, &ecx);\n \n@@ -1861,13 +1870,13 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n+pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> StrBuf {\n     let mut wr = MemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: &RefCell::new(HashMap::new())\n     }, t);\n-    str::from_utf8_owned(wr.get_ref().to_owned()).unwrap()\n+    str::from_utf8_owned(wr.get_ref().to_owned()).unwrap().to_strbuf()\n }"}, {"sha": "f339c6c8f7410d84a4d8a085d47757312608c627", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -186,8 +186,8 @@ static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n \n /// Returns RUST_PATH as a string, without default paths added\n-pub fn get_rust_path() -> Option<~str> {\n-    os::getenv(\"RUST_PATH\")\n+pub fn get_rust_path() -> Option<StrBuf> {\n+    os::getenv(\"RUST_PATH\").map(|x| x.to_strbuf())\n }\n \n /// Returns the value of RUST_PATH, as a list\n@@ -199,7 +199,7 @@ pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n-                env_path.split_str(PATH_ENTRY_SEPARATOR);\n+                env_path.as_slice().split_str(PATH_ENTRY_SEPARATOR);\n             env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()\n@@ -236,7 +236,7 @@ pub fn rust_path() -> Vec<Path> {\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n #[cfg(unix)]\n-fn find_libdir(sysroot: &Path) -> ~str {\n+fn find_libdir(sysroot: &Path) -> StrBuf {\n     // FIXME: This is a quick hack to make the rustc binary able to locate\n     // Rust libraries in Linux environments where libraries might be installed\n     // to lib64/lib32. This would be more foolproof by basing the sysroot off\n@@ -250,21 +250,27 @@ fn find_libdir(sysroot: &Path) -> ~str {\n     }\n \n     #[cfg(target_word_size = \"64\")]\n-    fn primary_libdir_name() -> ~str { \"lib64\".to_owned() }\n+    fn primary_libdir_name() -> StrBuf {\n+        \"lib64\".to_strbuf()\n+    }\n \n     #[cfg(target_word_size = \"32\")]\n-    fn primary_libdir_name() -> ~str { \"lib32\".to_owned() }\n+    fn primary_libdir_name() -> StrBuf {\n+        \"lib32\".to_strbuf()\n+    }\n \n-    fn secondary_libdir_name() -> ~str { \"lib\".to_owned() }\n+    fn secondary_libdir_name() -> StrBuf {\n+        \"lib\".to_strbuf()\n+    }\n }\n \n #[cfg(windows)]\n-fn find_libdir(_sysroot: &Path) -> ~str {\n-    \"bin\".to_owned()\n+fn find_libdir(_sysroot: &Path) -> StrBuf {\n+    \"bin\".to_strbuf()\n }\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n-pub fn rustlibdir() -> ~str {\n-    \"rustlib\".to_owned()\n+pub fn rustlibdir() -> StrBuf {\n+    \"rustlib\".to_strbuf()\n }"}, {"sha": "456259d1a5d0440131ee70a0b9de4a0acc8ba845", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -61,7 +61,7 @@ pub enum Os {\n \n pub struct CrateMismatch {\n     path: Path,\n-    got: ~str,\n+    got: StrBuf,\n }\n \n pub struct Context<'a> {\n@@ -92,7 +92,7 @@ pub struct ArchiveMetadata {\n }\n \n pub struct CratePaths {\n-    pub ident: ~str,\n+    pub ident: StrBuf,\n     pub dylib: Option<Path>,\n     pub rlib: Option<Path>\n }\n@@ -305,7 +305,7 @@ impl<'a> Context<'a> {\n     //\n     // If everything checks out, then `Some(hash)` is returned where `hash` is\n     // the listed hash in the filename itself.\n-    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<~str>{\n+    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<StrBuf>{\n         let middle = file.slice(prefix.len(), file.len() - suffix.len());\n         debug!(\"matching -- {}, middle: {}\", file, middle);\n         let mut parts = middle.splitn('-', 1);\n@@ -319,13 +319,13 @@ impl<'a> Context<'a> {\n             Some(..) => {} // check the hash\n \n             // hash is irrelevant, no version specified\n-            None => return Some(hash.to_owned())\n+            None => return Some(hash.to_strbuf())\n         }\n         debug!(\"matching -- {}, vers ok\", file);\n         // hashes in filenames are prefixes of the \"true hash\"\n         if self.id_hash == hash.as_slice() {\n             debug!(\"matching -- {}, hash ok\", file);\n-            Some(hash.to_owned())\n+            Some(hash.to_strbuf())\n         } else {\n             None\n         }\n@@ -410,8 +410,10 @@ impl<'a> Context<'a> {\n         let triple = decoder::get_crate_triple(crate_data);\n         if triple.as_slice() != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n-            self.rejected_via_triple.push(CrateMismatch{ path: libpath.clone(),\n-                                                         got: triple.to_owned() });\n+            self.rejected_via_triple.push(CrateMismatch {\n+                path: libpath.clone(),\n+                got: triple.to_strbuf()\n+            });\n             return false;\n         }\n \n@@ -420,8 +422,10 @@ impl<'a> Context<'a> {\n             Some(myhash) => {\n                 if *myhash != hash {\n                     info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n-                    self.rejected_via_hash.push(CrateMismatch{ path: libpath.clone(),\n-                                                               got: myhash.as_str().to_owned() });\n+                    self.rejected_via_hash.push(CrateMismatch {\n+                        path: libpath.clone(),\n+                        got: myhash.as_str().to_strbuf()\n+                    });\n                     false\n                 } else {\n                     true\n@@ -481,17 +485,17 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n+fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, StrBuf> {\n     let start = time::precise_time_ns();\n     let ret = get_metadata_section_imp(os, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n+fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, StrBuf> {\n     if !filename.exists() {\n-        return Err(format!(\"no such file: '{}'\", filename.display()));\n+        return Err(format_strbuf!(\"no such file: '{}'\", filename.display()));\n     }\n     if filename.filename_str().unwrap().ends_with(\".rlib\") {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n@@ -501,13 +505,17 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n             Some(ar) => ar,\n             None => {\n                 debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                   filename.display()));\n+                return Err(format_strbuf!(\"failed to read rlib metadata: \\\n+                                           '{}'\",\n+                                          filename.display()));\n             }\n         };\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n-            None => return Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                       filename.display())),\n+            None => {\n+                return Err((format_strbuf!(\"failed to read rlib metadata: \\\n+                                            '{}'\",\n+                                           filename.display())))\n+            }\n             Some(blob) => return Ok(blob)\n         }\n     }\n@@ -516,11 +524,16 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         });\n         if mb as int == 0 {\n-            return Err(format!(\"error reading library: '{}'\",filename.display()))\n+            return Err(format_strbuf!(\"error reading library: '{}'\",\n+                                      filename.display()))\n         }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n-            _ => return Err(format!(\"provided path not an object file: '{}'\", filename.display()))\n+            _ => {\n+                return Err((format_strbuf!(\"provided path not an object \\\n+                                            file: '{}'\",\n+                                           filename.display())))\n+            }\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -531,25 +544,34 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-                let mut found = Err(format!(\"metadata not found: '{}'\", filename.display()));\n+                let mut found =\n+                    Err(format_strbuf!(\"metadata not found: '{}'\",\n+                                       filename.display()));\n                 let cvbuf: *u8 = mem::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let version_ok = slice::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n-                if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n-                                                    filename.display())); }\n+                if !version_ok {\n+                    return Err((format_strbuf!(\"incompatible metadata \\\n+                                                version found: '{}'\",\n+                                        filename.display())));\n+                }\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 slice::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     match flate::inflate_bytes(bytes) {\n                         Some(inflated) => found = Ok(MetadataVec(inflated)),\n-                        None => found = Err(format!(\"failed to decompress metadata for: '{}'\",\n-                                                    filename.display()))\n+                        None => {\n+                            found =\n+                                Err(format_strbuf!(\"failed to decompress \\\n+                                                    metadata for: '{}'\",\n+                                                   filename.display()))\n+                        }\n                     }\n                 });\n                 if found.is_ok() {\n@@ -558,7 +580,8 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return Err(format!(\"metadata not found: '{}'\", filename.display()));\n+        return Err(format_strbuf!(\"metadata not found: '{}'\",\n+                                  filename.display()));\n     }\n }\n "}, {"sha": "0ccb44d2f8caed3c72e76d6f7677af915e7fc1a5", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -201,7 +201,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n         }\n         '[' => {\n             let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n-            let ident = token::str_to_ident(parse_str(st, ']'));\n+            let ident = token::str_to_ident(parse_str(st, ']').as_slice());\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -229,7 +229,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']'));\n+        let nm = token::str_to_ident(parse_str(st, ']').as_slice());\n         ty::ReEarlyBound(node_id, index, nm.name)\n       }\n       'f' => {\n@@ -264,15 +264,15 @@ fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n     }\n }\n \n-fn parse_str(st: &mut PState, term: char) -> ~str {\n+fn parse_str(st: &mut PState, term: char) -> StrBuf {\n     let mut result = StrBuf::new();\n     while peek(st) != term {\n         unsafe {\n             result.push_bytes([next_byte(st)])\n         }\n     }\n     next(st);\n-    return result.into_owned();\n+    result\n }\n \n fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {"}, {"sha": "49b5d7b28640c80730d9986bcfe5197f519bbd22", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -35,7 +35,7 @@ macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n pub struct ctxt<'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    pub ds: fn(DefId) -> ~str,\n+    pub ds: fn(DefId) -> StrBuf,\n     // The type context.\n     pub tcx: &'a ty::ctxt,\n     pub abbrevs: &'a abbrev_map\n@@ -47,7 +47,7 @@ pub struct ctxt<'a> {\n pub struct ty_abbrev {\n     pos: uint,\n     len: uint,\n-    s: ~str\n+    s: StrBuf\n }\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n@@ -77,7 +77,7 @@ pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n         cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n             pos: pos as uint,\n             len: len as uint,\n-            s: format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len)\n+            s: format_strbuf!(\"\\\\#{:x}:{:x}\\\\#\", pos, len)\n         });\n     }\n }"}, {"sha": "f46fe9a8b249196f1aa4d8b1af8770059c54ae29", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1152,12 +1152,12 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             Ok(ty)\n         }).unwrap();\n \n-        fn type_string(doc: ebml::Doc) -> ~str {\n+        fn type_string(doc: ebml::Doc) -> StrBuf {\n             let mut str = StrBuf::new();\n             for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n             }\n-            str.into_owned()\n+            str\n         }\n     }\n "}, {"sha": "ad0ee143735652c704a4c8f54573de29f3ec4153", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -98,10 +98,10 @@ pub fn check_crate(tcx: &ty::ctxt,\n                  make_stat(&bccx, bccx.stats.stable_paths.get()));\n     }\n \n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> StrBuf {\n         let stat_f = stat as f64;\n         let total = bccx.stats.guaranteed_paths.get() as f64;\n-        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n+        format_strbuf!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n     }\n }\n \n@@ -303,8 +303,8 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n }\n \n impl Repr for RestrictionSet {\n-    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n-        format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n+    fn repr(&self, _tcx: &ty::ctxt) -> StrBuf {\n+        format_strbuf!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n     }\n }\n \n@@ -447,7 +447,7 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_str(&err));\n+            self.bckerr_to_str(&err).as_slice());\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -572,28 +572,32 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn bckerr_to_str(&self, err: &BckError) -> ~str {\n+    pub fn bckerr_to_str(&self, err: &BckError) -> StrBuf {\n         match err.code {\n             err_mutbl => {\n                 let descr = match opt_loan_path(&err.cmt) {\n-                    None => format!(\"{} {}\",\n-                                    err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_str(&*err.cmt)),\n-                    Some(lp) => format!(\"{} {} `{}`\",\n-                                        err.cmt.mutbl.to_user_str(),\n-                                        self.cmt_to_str(&*err.cmt),\n-                                        self.loan_path_to_str(&*lp)),\n+                    None => {\n+                        format_strbuf!(\"{} {}\",\n+                                       err.cmt.mutbl.to_user_str(),\n+                                       self.cmt_to_str(&*err.cmt))\n+                    }\n+                    Some(lp) => {\n+                        format_strbuf!(\"{} {} `{}`\",\n+                                       err.cmt.mutbl.to_user_str(),\n+                                       self.cmt_to_str(&*err.cmt),\n+                                       self.loan_path_to_str(&*lp))\n+                    }\n                 };\n \n                 match err.cause {\n                     euv::ClosureCapture(_) => {\n-                        format!(\"closure cannot assign to {}\", descr)\n+                        format_strbuf!(\"closure cannot assign to {}\", descr)\n                     }\n                     euv::OverloadedOperator |\n                     euv::AddrOf |\n                     euv::RefBinding |\n                     euv::AutoRef => {\n-                        format!(\"cannot borrow {} as mutable\", descr)\n+                        format_strbuf!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     euv::ClosureInvocation => {\n                         self.tcx.sess.span_bug(err.span,\n@@ -603,20 +607,24 @@ impl<'a> BorrowckCtxt<'a> {\n             }\n             err_out_of_scope(..) => {\n                 let msg = match opt_loan_path(&err.cmt) {\n-                    None => format!(\"borrowed value\"),\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n+                    None => \"borrowed value\".to_strbuf(),\n+                    Some(lp) => {\n+                        format_strbuf!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                    }\n                 };\n-                format!(\"{} does not live long enough\", msg)\n+                format_strbuf!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n+                    Some(lp) => {\n+                        format_strbuf!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                    }\n                     None => self.cmt_to_str(&*err.cmt),\n                 };\n \n-                format!(\"lifetime of {} is too short to guarantee \\\n-                        its contents can be safely reborrowed\",\n-                        descr)\n+                format_strbuf!(\"lifetime of {} is too short to guarantee \\\n+                                its contents can be safely reborrowed\",\n+                               descr)\n             }\n         }\n     }\n@@ -655,7 +663,8 @@ impl<'a> BorrowckCtxt<'a> {\n             mc::AliasableOther => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in an aliasable location\", prefix));\n+                    format!(\"{} in an aliasable location\",\n+                             prefix));\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n@@ -696,7 +705,9 @@ impl<'a> BorrowckCtxt<'a> {\n \n             err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n+                    Some(lp) => {\n+                        format_strbuf!(\"`{}`\", self.loan_path_to_str(&*lp))\n+                    }\n                     None => self.cmt_to_str(&*err.cmt),\n                 };\n                 note_and_explain_region(\n@@ -764,13 +775,13 @@ impl<'a> BorrowckCtxt<'a> {\n         }\n     }\n \n-    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n+    pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> StrBuf {\n         let mut result = StrBuf::new();\n         self.append_loan_path_to_str(loan_path, &mut result);\n-        result.into_owned()\n+        result\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> StrBuf {\n         self.mc().cmt_to_str(cmt)\n     }\n }\n@@ -788,38 +799,40 @@ impl DataFlowOperator for LoanDataFlowOperator {\n }\n \n impl Repr for Loan {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n-             self.index,\n-             self.loan_path.repr(tcx),\n-             self.kind,\n-             self.gen_scope,\n-             self.kill_scope,\n-             self.restrictions.repr(tcx))\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        (format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n+                 self.index,\n+                 self.loan_path.repr(tcx),\n+                 self.kind,\n+                 self.gen_scope,\n+                 self.kill_scope,\n+                 self.restrictions.repr(tcx))).to_strbuf()\n     }\n }\n \n impl Repr for Restriction {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"Restriction({}, {:x})\",\n-             self.loan_path.repr(tcx),\n-             self.set.bits as uint)\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        (format!(\"Restriction({}, {:x})\",\n+                 self.loan_path.repr(tcx),\n+                 self.set.bits as uint)).to_strbuf()\n     }\n }\n \n impl Repr for LoanPath {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match self {\n             &LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_str(id))\n+                (format!(\"$({})\", tcx.map.node_to_str(id))).to_strbuf()\n             }\n \n             &LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.repr(tcx))\n+                (format!(\"{}.*\", lp.repr(tcx))).to_strbuf()\n             }\n \n             &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n+                (format!(\"{}.{}\",\n+                         lp.repr(tcx),\n+                         interior.repr(tcx))).to_strbuf()\n             }\n         }\n     }"}, {"sha": "f5f551e36f7ba1febd4c700e86174d341aa49a33", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -102,9 +102,12 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprCast(_, _) => {\n             let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n-                v.tcx.sess.span_err(e.span, \"can not cast to `\".to_owned() +\n-                                              ppaux::ty_to_str(v.tcx, ety) +\n-                                             \"` in a constant expression\");\n+                v.tcx\n+                 .sess\n+                 .span_err(e.span,\n+                           format!(\"can not cast to `{}` in a constant \\\n+                                    expression\",\n+                                   ppaux::ty_to_str(v.tcx, ety).as_slice()))\n             }\n           }\n           ExprPath(ref pth) => {"}, {"sha": "b24933a8c01a0fc35114e5108ceb64795b3a7476", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -33,7 +33,7 @@ use syntax::visit;\n use syntax::print::pprust;\n \n \n-fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<~str> {\n+fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<StrBuf> {\n     let node_ty = ty::node_id_to_type(cx, e.id);\n     let tcontents = ty::type_contents(cx, node_ty);\n     debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n@@ -49,7 +49,8 @@ fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<~str> {\n         return None;\n     };\n \n-    Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n+    Some(format_strbuf!(\"mutable static items are not allowed to have {}\",\n+                        suffix))\n }\n \n struct CheckStaticVisitor<'a> {\n@@ -61,11 +62,11 @@ pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n }\n \n impl<'a> CheckStaticVisitor<'a> {\n-    fn report_error(&self, span: Span, result: Option<~str>) -> bool {\n+    fn report_error(&self, span: Span, result: Option<StrBuf>) -> bool {\n         match result {\n             None => { false }\n             Some(msg) => {\n-                self.tcx.sess.span_err(span, msg);\n+                self.tcx.sess.span_err(span, msg.as_slice());\n                 true\n             }\n         }\n@@ -132,7 +133,8 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                     ty::ty_enum(did, _) => {\n                         if ty::has_dtor(self.tcx, did) {\n                             self.report_error(e.span,\n-                             Some(\"static items are not allowed to have destructors\".to_owned()));\n+                             Some(\"static items are not allowed to have \\\n+                                   destructors\".to_strbuf()));\n                             return;\n                         }\n                     }"}, {"sha": "34f36363b92bf605e61ff4e7b10a4fc826813615", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -295,21 +295,21 @@ pub enum const_val {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s)\n+        Err(s) => tcx.sess.span_fatal(e.span, s.as_slice())\n     }\n }\n \n pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n-                            -> Result<const_val, ~str> {\n-    fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n+                            -> Result<const_val, StrBuf> {\n+    fn fromb(b: bool) -> Result<const_val, StrBuf> { Ok(const_int(b as i64)) }\n     match e.node {\n       ExprUnary(UnNeg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(\"negate on string\".to_owned()),\n-          Ok(const_bool(_)) => Err(\"negate on boolean\".to_owned()),\n+          Ok(const_str(_)) => Err(\"negate on string\".to_strbuf()),\n+          Ok(const_bool(_)) => Err(\"negate on boolean\".to_strbuf()),\n           ref err => ((*err).clone())\n         }\n       }\n@@ -318,7 +318,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          _ => Err(\"not on float or string\".to_owned())\n+          _ => Err(\"not on float or string\".to_strbuf())\n         }\n       }\n       ExprBinary(op, a, b) => {\n@@ -337,17 +337,22 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiNe => fromb(a != b),\n               BiGe => fromb(a >= b),\n               BiGt => fromb(a > b),\n-              _ => Err(\"can't do this op on floats\".to_owned())\n+              _ => Err(\"can't do this op on floats\".to_strbuf())\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n               BiAdd => Ok(const_int(a + b)),\n               BiSub => Ok(const_int(a - b)),\n               BiMul => Ok(const_int(a * b)),\n-              BiDiv if b == 0 => Err(\"attempted to divide by zero\".to_owned()),\n+              BiDiv if b == 0 => {\n+                  Err(\"attempted to divide by zero\".to_strbuf())\n+              }\n               BiDiv => Ok(const_int(a / b)),\n-              BiRem if b == 0 => Err(\"attempted remainder with a divisor of zero\".to_owned()),\n+              BiRem if b == 0 => {\n+                  Err(\"attempted remainder with a divisor of \\\n+                       zero\".to_strbuf())\n+              }\n               BiRem => Ok(const_int(a % b)),\n               BiAnd | BiBitAnd => Ok(const_int(a & b)),\n               BiOr | BiBitOr => Ok(const_int(a | b)),\n@@ -367,9 +372,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiAdd => Ok(const_uint(a + b)),\n               BiSub => Ok(const_uint(a - b)),\n               BiMul => Ok(const_uint(a * b)),\n-              BiDiv if b == 0 => Err(\"attempted to divide by zero\".to_owned()),\n+              BiDiv if b == 0 => {\n+                  Err(\"attempted to divide by zero\".to_strbuf())\n+              }\n               BiDiv => Ok(const_uint(a / b)),\n-              BiRem if b == 0 => Err(\"attempted remainder with a divisor of zero\".to_owned()),\n+              BiRem if b == 0 => {\n+                  Err(\"attempted remainder with a divisor of \\\n+                       zero\".to_strbuf())\n+              }\n               BiRem => Ok(const_uint(a % b)),\n               BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n               BiOr | BiBitOr => Ok(const_uint(a | b)),\n@@ -389,14 +399,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n             match op {\n               BiShl => Ok(const_int(a << b)),\n               BiShr => Ok(const_int(a >> b)),\n-              _ => Err(\"can't do this op on an int and uint\".to_owned())\n+              _ => Err(\"can't do this op on an int and uint\".to_strbuf())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n               BiShl => Ok(const_uint(a << b)),\n               BiShr => Ok(const_uint(a >> b)),\n-              _ => Err(\"can't do this op on a uint and int\".to_owned())\n+              _ => Err(\"can't do this op on a uint and int\".to_strbuf())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n@@ -408,10 +418,10 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n               BiBitOr => a | b,\n               BiEq => a == b,\n               BiNe => a != b,\n-              _ => return Err(\"can't do this op on bools\".to_owned())\n+              _ => return Err(\"can't do this op on bools\".to_strbuf())\n              }))\n           }\n-          _ => Err(\"bad operands for binary\".to_owned())\n+          _ => Err(\"bad operands for binary\".to_strbuf())\n         }\n       }\n       ExprCast(base, target_ty) => {\n@@ -435,41 +445,41 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             const_uint(u) => Ok(const_float(u as f64)),\n                             const_int(i) => Ok(const_float(i as f64)),\n                             const_float(f) => Ok(const_float(f)),\n-                            _ => Err(\"can't cast float to str\".to_owned()),\n+                            _ => Err(\"can't cast float to str\".to_strbuf()),\n                         }\n                     }\n                     ty::ty_uint(_) => {\n                         match val {\n                             const_uint(u) => Ok(const_uint(u)),\n                             const_int(i) => Ok(const_uint(i as u64)),\n                             const_float(f) => Ok(const_uint(f as u64)),\n-                            _ => Err(\"can't cast str to uint\".to_owned()),\n+                            _ => Err(\"can't cast str to uint\".to_strbuf()),\n                         }\n                     }\n                     ty::ty_int(_) | ty::ty_bool => {\n                         match val {\n                             const_uint(u) => Ok(const_int(u as i64)),\n                             const_int(i) => Ok(const_int(i)),\n                             const_float(f) => Ok(const_int(f as i64)),\n-                            _ => Err(\"can't cast str to int\".to_owned()),\n+                            _ => Err(\"can't cast str to int\".to_strbuf()),\n                         }\n                     }\n-                    _ => Err(\"can't cast this type\".to_owned())\n+                    _ => Err(\"can't cast this type\".to_strbuf())\n                 }\n             }\n         }\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n               Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n-              None => Err(\"non-constant path in constant expr\".to_owned())\n+              None => Err(\"non-constant path in constant expr\".to_strbuf())\n           }\n       }\n       ExprLit(lit) => Ok(lit_to_const(lit)),\n       // If we have a vstore, just keep going; it has to be a string\n       ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n       ExprParen(e)     => eval_const_expr_partial(tcx, e),\n-      _ => Err(\"unsupported constant expr\".to_owned())\n+      _ => Err(\"unsupported constant expr\".to_strbuf())\n     }\n }\n "}, {"sha": "34a97c15f5c457d09be8354008e4a07856502368", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -112,8 +112,11 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n                 \"\".to_owned()\n             };\n \n-            try!(ps.synth_comment((format!(\"id {}: {}{}{}\", id, entry_str,\n-                                          gens_str, kills_str)).to_strbuf()));\n+            try!(ps.synth_comment(format_strbuf!(\"id {}: {}{}{}\",\n+                                                 id,\n+                                                 entry_str,\n+                                                 gens_str,\n+                                                 kills_str)));\n             try!(pp::space(&mut ps.s));\n         }\n         Ok(())\n@@ -824,11 +827,11 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n }\n \n-fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n+fn mut_bits_to_str(words: &mut [uint]) -> StrBuf {\n     bits_to_str(words)\n }\n \n-fn bits_to_str(words: &[uint]) -> ~str {\n+fn bits_to_str(words: &[uint]) -> StrBuf {\n     let mut result = StrBuf::new();\n     let mut sep = '[';\n \n@@ -844,7 +847,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n         }\n     }\n     result.push_char(']');\n-    return result.into_owned();\n+    return result\n }\n \n fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {\n@@ -884,8 +887,8 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     oldv != newv\n }\n \n-fn bit_str(bit: uint) -> ~str {\n+fn bit_str(bit: uint) -> StrBuf {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n-    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n+    format_strbuf!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }"}, {"sha": "407228cb6ede813e02b062115aaf508a55d72fc6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -352,11 +352,17 @@ impl<'a> DeadVisitor<'a> {\n         false\n     }\n \n-    fn warn_dead_code(&mut self, id: ast::NodeId,\n-                      span: codemap::Span, ident: ast::Ident) {\n-        self.tcx.sess.add_lint(DeadCode, id, span,\n-                               format!(\"code is never used: `{}`\",\n-                                       token::get_ident(ident)));\n+    fn warn_dead_code(&mut self,\n+                      id: ast::NodeId,\n+                      span: codemap::Span,\n+                      ident: ast::Ident) {\n+        self.tcx\n+            .sess\n+            .add_lint(DeadCode,\n+                      id,\n+                      span,\n+                      format_strbuf!(\"code is never used: `{}`\",\n+                                     token::get_ident(ident)));\n     }\n }\n "}, {"sha": "2604884350b90d443138f4643e583dad8a917eeb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -562,7 +562,7 @@ pub fn check_cast_for_escaping_regions(\n }\n \n // Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n-fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: ~str, sp: Span) {\n+fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: StrBuf, sp: Span) {\n     if !ty::type_is_sized(tcx, ty) {\n         tcx.sess.span_err(sp, format!(\"variable `{}` has dynamically sized type `{}`\",\n                                       name, ty_to_str(tcx, ty)));\n@@ -572,8 +572,8 @@ fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: ~str, sp: Span) {\n // Check that any variables in a pattern have types with statically known size.\n fn check_pat(cx: &mut Context, pat: &Pat) {\n     let var_name = match pat.node {\n-        PatWild => Some(\"_\".to_owned()),\n-        PatIdent(_, ref path, _) => Some(path_to_str(path).to_owned()),\n+        PatWild => Some(\"_\".to_strbuf()),\n+        PatIdent(_, ref path, _) => Some(path_to_str(path).to_strbuf()),\n         _ => None\n     };\n "}, {"sha": "ed8b27a866026212f8666c4206ac9f8a7fccf96e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -71,12 +71,12 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn require(&self, it: LangItem) -> Result<ast::DefId, ~str> {\n+    pub fn require(&self, it: LangItem) -> Result<ast::DefId, StrBuf> {\n         match self.items.get(it as uint) {\n             &Some(id) => Ok(id),\n             &None => {\n-                Err(format!(\"requires `{}` lang_item\",\n-                            LanguageItems::item_name(it as uint)))\n+                Err(format_strbuf!(\"requires `{}` lang_item\",\n+                                   LanguageItems::item_name(it as uint)))\n             }\n         }\n     }"}, {"sha": "cc0697ce527693813d09b88e6d4f1555c30601db", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1830,7 +1830,7 @@ impl<'a> IdVisitingOperation for Context<'a> {\n             None => {}\n             Some(l) => {\n                 for (lint, span, msg) in l.move_iter() {\n-                    self.span_lint(lint, span, msg)\n+                    self.span_lint(lint, span, msg.as_slice())\n                 }\n             }\n         }"}, {"sha": "f80940a17e2382b9e596bf776e55e506eeb9607f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -150,13 +150,19 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n+fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> StrBuf {\n     let cm = cx.sess.codemap();\n     match lnk {\n-        FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n-        ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),\n-        VarDefNode(s)  => format!(\"Var def node [{}]\", cm.span_to_str(s)),\n-        ExitNode       => \"Exit node\".to_owned()\n+        FreeVarNode(s) => {\n+            format_strbuf!(\"Free var node [{}]\", cm.span_to_str(s))\n+        }\n+        ExprNode(s) => {\n+            format_strbuf!(\"Expr node [{}]\", cm.span_to_str(s))\n+        }\n+        VarDefNode(s) => {\n+            format_strbuf!(\"Var def node [{}]\", cm.span_to_str(s))\n+        }\n+        ExitNode => \"Exit node\".to_strbuf(),\n     }\n }\n \n@@ -308,18 +314,20 @@ impl<'a> IrMaps<'a> {\n         match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n-            self.tcx.sess.span_bug(\n-                span, format!(\"no variable registered for id {}\", node_id));\n+            self.tcx\n+                .sess\n+                .span_bug(span, format!(\"no variable registered for id {}\",\n+                                        node_id));\n           }\n         }\n     }\n \n-    fn variable_name(&self, var: Variable) -> ~str {\n+    fn variable_name(&self, var: Variable) -> StrBuf {\n         match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n-                token::get_ident(nm).get().to_str()\n+                token::get_ident(nm).get().to_str().to_strbuf()\n             },\n-            &ImplicitRet => \"<implicit-ret>\".to_owned()\n+            &ImplicitRet => \"<implicit-ret>\".to_strbuf()\n         }\n     }\n \n@@ -741,7 +749,7 @@ impl<'a> Liveness<'a> {\n     }\n \n     #[allow(unused_must_use)]\n-    fn ln_str(&self, ln: LiveNode) -> ~str {\n+    fn ln_str(&self, ln: LiveNode) -> StrBuf {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n@@ -751,7 +759,7 @@ impl<'a> Liveness<'a> {\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n             write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n-        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n@@ -1532,9 +1540,13 @@ impl<'a> Liveness<'a> {\n        }\n     }\n \n-    fn should_warn(&self, var: Variable) -> Option<~str> {\n+    fn should_warn(&self, var: Variable) -> Option<StrBuf> {\n         let name = self.ir.variable_name(var);\n-        if name.len() == 0 || name[0] == ('_' as u8) { None } else { Some(name) }\n+        if name.len() == 0 || name.as_slice()[0] == ('_' as u8) {\n+            None\n+        } else {\n+            Some(name)\n+        }\n     }\n \n     fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n@@ -1581,11 +1593,12 @@ impl<'a> Liveness<'a> {\n \n                 if is_assigned {\n                     self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n-                        format!(\"variable `{}` is assigned to, \\\n-                                  but never used\", *name));\n+                        format_strbuf!(\"variable `{}` is assigned to, \\\n+                                        but never used\",\n+                                       *name));\n                 } else {\n                     self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n-                        format!(\"unused variable: `{}`\", *name));\n+                        format_strbuf!(\"unused variable: `{}`\", *name));\n                 }\n             }\n             true\n@@ -1603,7 +1616,8 @@ impl<'a> Liveness<'a> {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n                 self.ir.tcx.sess.add_lint(DeadAssignment, id, sp,\n-                    format!(\"value assigned to `{}` is never read\", *name));\n+                    format_strbuf!(\"value assigned to `{}` is never read\",\n+                                   *name));\n             }\n         }\n     }"}, {"sha": "bd29398e5225daa73171a043a94196cc0da3415b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1093,50 +1093,51 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_str(&self, cmt: &cmt_) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &cmt_) -> StrBuf {\n         match cmt.cat {\n           cat_static_item => {\n-              \"static item\".to_owned()\n+              \"static item\".to_strbuf()\n           }\n           cat_copied_upvar(_) => {\n-              \"captured outer variable in a proc\".to_owned()\n+              \"captured outer variable in a proc\".to_strbuf()\n           }\n           cat_rvalue(..) => {\n-              \"non-lvalue\".to_owned()\n+              \"non-lvalue\".to_strbuf()\n           }\n           cat_local(_) => {\n-              \"local variable\".to_owned()\n+              \"local variable\".to_strbuf()\n           }\n           cat_arg(..) => {\n-              \"argument\".to_owned()\n+              \"argument\".to_strbuf()\n           }\n           cat_deref(ref base, _, pk) => {\n               match base.cat {\n                   cat_upvar(..) => {\n-                      format!(\"captured outer variable\")\n+                      \"captured outer variable\".to_strbuf()\n                   }\n                   _ => {\n-                      format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n+                      format_strbuf!(\"dereference of `{}`-pointer\",\n+                                     ptr_sigil(pk))\n                   }\n               }\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n-              \"field\".to_owned()\n+              \"field\".to_strbuf()\n           }\n           cat_interior(_, InteriorField(PositionalField(_))) => {\n-              \"anonymous field\".to_owned()\n+              \"anonymous field\".to_strbuf()\n           }\n           cat_interior(_, InteriorElement(VecElement)) => {\n-              \"vec content\".to_owned()\n+              \"vec content\".to_strbuf()\n           }\n           cat_interior(_, InteriorElement(StrElement)) => {\n-              \"str content\".to_owned()\n+              \"str content\".to_strbuf()\n           }\n           cat_interior(_, InteriorElement(OtherElement)) => {\n-              \"indexed content\".to_owned()\n+              \"indexed content\".to_strbuf()\n           }\n           cat_upvar(..) => {\n-              \"captured outer variable\".to_owned()\n+              \"captured outer variable\".to_strbuf()\n           }\n           cat_discr(ref cmt, _) => {\n             self.cmt_to_str(&**cmt)\n@@ -1248,39 +1249,37 @@ impl cmt_ {\n }\n \n impl Repr for cmt_ {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n-             self.cat.repr(tcx),\n-             self.id,\n-             self.mutbl,\n-             self.ty.repr(tcx))\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        format_strbuf!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n+                       self.cat.repr(tcx),\n+                       self.id,\n+                       self.mutbl,\n+                       self.ty.repr(tcx))\n     }\n }\n \n impl Repr for categorization {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n             cat_arg(..) => {\n-                format!(\"{:?}\", *self)\n+                format_strbuf!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\",\n-                        cmt.cat.repr(tcx),\n-                        ptr_sigil(ptr),\n-                        derefs)\n+                format_strbuf!(\"{}-{}{}->\",\n+                               cmt.cat.repr(tcx),\n+                               ptr_sigil(ptr),\n+                               derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n-                format!(\"{}.{}\",\n-                     cmt.cat.repr(tcx),\n-                     interior.repr(tcx))\n+                format_strbuf!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n             }\n             cat_downcast(ref cmt) => {\n-                format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n+                format_strbuf!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n             cat_discr(ref cmt, _) => {\n                 cmt.cat.repr(tcx)\n@@ -1301,13 +1300,13 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n }\n \n impl Repr for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).get().to_str()\n+                token::get_name(fld).get().to_str().to_strbuf()\n             }\n-            InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n-            InteriorElement(_) => \"[]\".to_owned(),\n+            InteriorField(PositionalField(i)) => format_strbuf!(\"\\\\#{:?}\", i),\n+            InteriorElement(_) => \"[]\".to_strbuf(),\n         }\n     }\n }"}, {"sha": "5be9226ef7408ecd5bf2f0b18166615442cb86ca", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -45,7 +45,7 @@ pub type PublicItems = NodeSet;\n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n /// optionally the same for a note about the error.\n-type CheckResult = Option<(Span, ~str, Option<(Span, ~str)>)>;\n+type CheckResult = Option<(Span, StrBuf, Option<(Span, StrBuf)>)>;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n@@ -356,8 +356,8 @@ enum FieldName {\n \n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n-    fn nodestr(&self, id: ast::NodeId) -> ~str {\n-        self.tcx.map.node_to_str(id).to_owned()\n+    fn nodestr(&self, id: ast::NodeId) -> StrBuf {\n+        self.tcx.map.node_to_str(id).to_strbuf()\n     }\n \n     // Determines whether the given definition is public from the point of view\n@@ -511,9 +511,11 @@ impl<'a> PrivacyVisitor<'a> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg);\n+                self.tcx.sess.span_err(span, msg.as_slice());\n                 match note {\n-                    Some((span, msg)) => self.tcx.sess.span_note(span, msg),\n+                    Some((span, msg)) => {\n+                        self.tcx.sess.span_note(span, msg.as_slice())\n+                    }\n                     None => {},\n                 }\n                 false\n@@ -528,7 +530,9 @@ impl<'a> PrivacyVisitor<'a> {\n                      source_did: Option<ast::DefId>, msg: &str) -> CheckResult {\n         let id = match self.def_privacy(to_check) {\n             ExternallyDenied => {\n-                return Some((span, format!(\"{} is private\", msg), None))\n+                return Some((span,\n+                             format_strbuf!(\"{} is private\", msg),\n+                             None))\n             }\n             Allowable => return None,\n             DisallowedBy(id) => id,\n@@ -539,9 +543,11 @@ impl<'a> PrivacyVisitor<'a> {\n         // because the item itself is private or because its parent is private\n         // and its parent isn't in our ancestry.\n         let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n-            return Some((span, format!(\"{} is private\", msg), None));\n+            return Some((span,\n+                         format_strbuf!(\"{} is private\", msg),\n+                         None));\n         } else {\n-            (span, format!(\"{} is inaccessible\", msg))\n+            (span, format_strbuf!(\"{} is inaccessible\", msg))\n         };\n         let item = match self.tcx.map.find(id) {\n             Some(ast_map::NodeItem(item)) => {\n@@ -577,8 +583,9 @@ impl<'a> PrivacyVisitor<'a> {\n             ast::ItemEnum(..) => \"enum\",\n             _ => return Some((err_span, err_msg, None))\n         };\n-        let msg = format!(\"{} `{}` is private\", desc,\n-                          token::get_ident(item.ident));\n+        let msg = format_strbuf!(\"{} `{}` is private\",\n+                                 desc,\n+                                 token::get_ident(item.ident));\n         Some((err_span, err_msg, Some((span, msg))))\n     }\n \n@@ -1364,9 +1371,11 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n         match t.node {\n             ast::TyPath(ref p, _, path_id) => {\n                 if self.path_is_private_type(path_id) {\n-                    self.tcx.sess.add_lint(lint::VisiblePrivateTypes,\n-                                           path_id, p.span,\n-                                           \"private type in exported type signature\".to_owned());\n+                    self.tcx.sess.add_lint(\n+                        lint::VisiblePrivateTypes,\n+                        path_id, p.span,\n+                        \"private type in exported type \\\n+                         signature\".to_strbuf());\n                 }\n             }\n             _ => {}"}, {"sha": "bce82002ecb20823eae8dc5ea8bf592f72a342d9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -57,7 +57,7 @@ pub type TraitMap = NodeMap<Vec<DefId> >;\n pub type ExportMap2 = RefCell<NodeMap<Vec<Export2> >>;\n \n pub struct Export2 {\n-    pub name: ~str,        // The name of the target.\n+    pub name: StrBuf,        // The name of the target.\n     pub def_id: DefId,     // The definition of the target.\n }\n \n@@ -2046,7 +2046,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn idents_to_str(&mut self, idents: &[Ident]) -> ~str {\n+    fn idents_to_str(&mut self, idents: &[Ident]) -> StrBuf {\n         let mut first = true;\n         let mut result = StrBuf::new();\n         for ident in idents.iter() {\n@@ -2057,10 +2057,10 @@ impl<'a> Resolver<'a> {\n             }\n             result.push_str(token::get_ident(*ident).get());\n         };\n-        result.into_owned()\n+        result\n     }\n \n-    fn path_idents_to_str(&mut self, path: &Path) -> ~str {\n+    fn path_idents_to_str(&mut self, path: &Path) -> StrBuf {\n         let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n@@ -2070,25 +2070,26 @@ impl<'a> Resolver<'a> {\n \n     fn import_directive_subclass_to_str(&mut self,\n                                         subclass: ImportDirectiveSubclass)\n-                                        -> ~str {\n+                                        -> StrBuf {\n         match subclass {\n             SingleImport(_, source) => {\n-                token::get_ident(source).get().to_str()\n+                token::get_ident(source).get().to_strbuf()\n             }\n-            GlobImport => \"*\".to_owned()\n+            GlobImport => \"*\".to_strbuf()\n         }\n     }\n \n     fn import_path_to_str(&mut self,\n                           idents: &[Ident],\n                           subclass: ImportDirectiveSubclass)\n-                          -> ~str {\n+                          -> StrBuf {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n             (format!(\"{}::{}\",\n                      self.idents_to_str(idents),\n-                     self.import_directive_subclass_to_str(subclass)))\n+                     self.import_directive_subclass_to_str(\n+                         subclass))).to_strbuf()\n         }\n     }\n \n@@ -2219,8 +2220,11 @@ impl<'a> Resolver<'a> {\n \n         let lp = match lp {\n             LastMod(lp) => lp,\n-            LastImport{..} => self.session.span_bug(directive.span,\n-                                                    \"Not expecting Import here, must be LastMod\"),\n+            LastImport {..} => {\n+                self.session\n+                    .span_bug(directive.span,\n+                              \"not expecting Import here, must be LastMod\")\n+            }\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n@@ -2614,7 +2618,7 @@ impl<'a> Resolver<'a> {\n                 Failed => {\n                     let segment_name = token::get_ident(name);\n                     let module_name = self.module_to_str(&*search_module);\n-                    if \"???\" == module_name {\n+                    if \"???\" == module_name.as_slice() {\n                         let span = Span {\n                             lo: span.lo,\n                             hi: span.lo + Pos::from_uint(segment_name.get().len()),\n@@ -2732,14 +2736,18 @@ impl<'a> Resolver<'a> {\n         match module_prefix_result {\n             Failed => {\n                 let mpath = self.idents_to_str(module_path);\n-                match mpath.rfind(':') {\n+                match mpath.as_slice().rfind(':') {\n                     Some(idx) => {\n-                        self.resolve_error(span, format!(\"unresolved import: could not find `{}` \\\n-                                                         in `{}`\",\n-                                                         // idx +- 1 to account for the colons\n-                                                         // on either side\n-                                                         mpath.slice_from(idx + 1),\n-                                                         mpath.slice_to(idx - 1)));\n+                        self.resolve_error(span,\n+                                           format!(\"unresolved import: could \\\n+                                                    not find `{}` in `{}`\",\n+                                                   // idx +- 1 to account for\n+                                                   // the colons on either\n+                                                   // side\n+                                                   mpath.as_slice()\n+                                                        .slice_from(idx + 1),\n+                                                   mpath.as_slice()\n+                                                        .slice_to(idx - 1)));\n                     },\n                     None => (),\n                 };\n@@ -3283,7 +3291,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name, def_id_of_def(d));\n                 exports2.push(Export2 {\n-                    name: name.get().to_str(),\n+                    name: name.get().to_strbuf(),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -4557,10 +4565,11 @@ impl<'a> Resolver<'a> {\n             let def = self.resolve_module_relative_path(path, namespace);\n             match (def, unqualified_def) {\n                 (Some((d, _)), Some((ud, _))) if d == ud => {\n-                    self.session.add_lint(UnnecessaryQualification,\n-                                          id,\n-                                          path.span,\n-                                          \"unnecessary qualification\".to_owned());\n+                    self.session\n+                        .add_lint(UnnecessaryQualification,\n+                                  id,\n+                                  path.span,\n+                                  \"unnecessary qualification\".to_strbuf());\n                 }\n                 _ => ()\n             }\n@@ -4875,7 +4884,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n-                                -> Option<~str> {\n+                                -> Option<StrBuf> {\n         let this = &mut *self;\n \n         let mut maybes: Vec<token::InternedString> = Vec::new();\n@@ -4907,7 +4916,7 @@ impl<'a> Resolver<'a> {\n             *values.get(smallest) <= max_distance &&\n             name != maybes.get(smallest).get() {\n \n-            Some(maybes.get(smallest).get().to_str())\n+            Some(maybes.get(smallest).get().to_strbuf())\n \n         } else {\n             None\n@@ -4977,17 +4986,20 @@ impl<'a> Resolver<'a> {\n                             _ =>\n                                // limit search to 5 to reduce the number\n                                // of stupid suggestions\n-                               match self.find_best_match_for_name(wrong_name, 5) {\n+                               match self.find_best_match_for_name(\n+                                        wrong_name.as_slice(),\n+                                        5) {\n                                    Some(m) => {\n                                        self.resolve_error(expr.span,\n                                            format!(\"unresolved name `{}`. \\\n                                                     Did you mean `{}`?\",\n-                                                    wrong_name, m));\n+                                                    wrong_name,\n+                                                    m));\n                                    }\n                                    None => {\n                                        self.resolve_error(expr.span,\n                                             format!(\"unresolved name `{}`.\",\n-                                                    wrong_name));\n+                                                    wrong_name.as_slice()));\n                                    }\n                                }\n                         }\n@@ -5240,8 +5252,11 @@ impl<'a> Resolver<'a> {\n                     ViewPathGlob(_, id) => {\n                         if !self.used_imports.contains(&(id, TypeNS)) &&\n                            !self.used_imports.contains(&(id, ValueNS)) {\n-                            self.session.add_lint(UnusedImports, id, p.span,\n-                                                  \"unused import\".to_owned());\n+                            self.session\n+                                .add_lint(UnusedImports,\n+                                          id,\n+                                          p.span,\n+                                          \"unused import\".to_strbuf());\n                         }\n                     },\n                 }\n@@ -5257,19 +5272,27 @@ impl<'a> Resolver<'a> {\n     // public or private item, we will check the correct thing, dependent on how the import\n     // is used.\n     fn finalize_import(&mut self, id: NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\", self.session.codemap().span_to_snippet(span));\n+        debug!(\"finalizing import uses for {}\",\n+               self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(UnusedImports, id, span, \"unused import\".to_owned());\n+            self.session.add_lint(UnusedImports,\n+                                  id,\n+                                  span,\n+                                  \"unused import\".to_strbuf());\n         }\n \n         let (v_priv, t_priv) = match self.last_private.find(&id) {\n-            Some(&LastImport{value_priv: v,\n-                             value_used: _,\n-                             type_priv: t,\n-                             type_used: _}) => (v, t),\n-            Some(_) => fail!(\"We should only have LastImport for `use` directives\"),\n+            Some(&LastImport {\n+                value_priv: v,\n+                value_used: _,\n+                type_priv: t,\n+                type_used: _\n+            }) => (v, t),\n+            Some(_) => {\n+                fail!(\"we should only have LastImport for `use` directives\")\n+            }\n             _ => return,\n         };\n \n@@ -5306,7 +5329,7 @@ impl<'a> Resolver<'a> {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(&mut self, module: &Module) -> ~str {\n+    fn module_to_str(&mut self, module: &Module) -> StrBuf {\n         let mut idents = Vec::new();\n \n         fn collect_mod(idents: &mut Vec<ast::Ident>, module: &Module) {\n@@ -5325,7 +5348,7 @@ impl<'a> Resolver<'a> {\n         collect_mod(&mut idents, module);\n \n         if idents.len() == 0 {\n-            return \"???\".to_owned();\n+            return \"???\".to_strbuf();\n         }\n         self.idents_to_str(idents.move_iter().rev()\n                                  .collect::<Vec<ast::Ident>>()"}, {"sha": "e609da6c33ddc14bcf2e47b88fbc6e5a806a676c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -400,12 +400,12 @@ struct Match<'a, 'b> {\n }\n \n impl<'a, 'b> Repr for Match<'a, 'b> {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)\n         } else {\n-            format!(\"{} pats\", self.pats.len())\n+            format_strbuf!(\"{} pats\", self.pats.len())\n         }\n     }\n }\n@@ -1851,11 +1851,14 @@ fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n-                trmode = TrByValue(alloca(bcx, llvariable_ty,\n-                                          bcx.ident(ident)));\n+                trmode = TrByValue(alloca(bcx,\n+                                          llvariable_ty,\n+                                          bcx.ident(ident).as_slice()));\n             }\n             ast::BindByRef(_) => {\n-                llmatch = alloca(bcx, llvariable_ty, bcx.ident(ident));\n+                llmatch = alloca(bcx,\n+                                 llvariable_ty,\n+                                 bcx.ident(ident).as_slice());\n                 trmode = TrByRef;\n             }\n         };\n@@ -2103,7 +2106,7 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n     let ident = ast_util::path_to_ident(path);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident).as_slice());\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup."}, {"sha": "e6004b4cb71f7d55fc5ff096b841a60193a6f9fe", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -65,15 +65,13 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     let mut constraints =\n         StrBuf::from_str(constraints.iter()\n-                                    .map(|s| s.get().to_str())\n-                                    .collect::<Vec<~str>>()\n+                                    .map(|s| s.get().to_strbuf())\n+                                    .collect::<Vec<StrBuf>>()\n                                     .connect(\",\"));\n \n-    let mut clobbers = StrBuf::from_str(getClobbers());\n+    let mut clobbers = getClobbers();\n     if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {\n-        clobbers = StrBuf::from_owned_str(format!(\"{},{}\",\n-                                                  ia.clobbers.get(),\n-                                                  clobbers));\n+        clobbers = format_strbuf!(\"{},{}\", ia.clobbers.get(), clobbers);\n     } else {\n         clobbers.push_str(ia.clobbers.get());\n     }\n@@ -136,12 +134,12 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"mips\")]\n-fn getClobbers() -> ~str {\n-    \"\".to_owned()\n+fn getClobbers() -> StrBuf {\n+    \"\".to_strbuf()\n }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]\n-fn getClobbers() -> ~str {\n-    \"~{dirflag},~{fpsr},~{flags}\".to_owned()\n+fn getClobbers() -> StrBuf {\n+    \"~{dirflag},~{fpsr},~{flags}\".to_strbuf()\n }"}, {"sha": "10f35255abb8626daa0c4f065c026004034f9cf9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 59, "deletions": 38, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -124,13 +124,13 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n \n pub struct StatRecorder<'a> {\n     ccx: &'a CrateContext,\n-    name: Option<~str>,\n+    name: Option<StrBuf>,\n     start: u64,\n     istart: uint,\n }\n \n impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: &'a CrateContext, name: ~str) -> StatRecorder<'a> {\n+    pub fn new(ccx: &'a CrateContext, name: StrBuf) -> StatRecorder<'a> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -206,15 +206,19 @@ pub fn decl_cdecl_fn(llmod: ModuleRef,\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n-pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef,\n-                     name: &str, cc: lib::llvm::CallConv,\n-                     ty: Type, output: ty::t) -> ValueRef {\n+pub fn get_extern_fn(externs: &mut ExternMap,\n+                     llmod: ModuleRef,\n+                     name: &str,\n+                     cc: lib::llvm::CallConv,\n+                     ty: Type,\n+                     output: ty::t)\n+                     -> ValueRef {\n     match externs.find_equiv(&name) {\n         Some(n) => return *n,\n         None => {}\n     }\n     let f = decl_fn(llmod, name, cc, ty, output);\n-    externs.insert(name.to_owned(), f);\n+    externs.insert(name.to_strbuf(), f);\n     f\n }\n \n@@ -231,7 +235,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                                     .collect::<Vec<_>>().as_slice(), f)\n     });\n \n-    ccx.externs.borrow_mut().insert(name.to_owned(), f);\n+    ccx.externs.borrow_mut().insert(name.to_strbuf(), f);\n     f\n }\n \n@@ -315,7 +319,7 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         let c = name.with_c_str(|buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         });\n-        externs.insert(name.to_owned(), c);\n+        externs.insert(name.to_strbuf(), c);\n         return c;\n     }\n }\n@@ -469,9 +473,9 @@ pub fn unset_split_stack(f: ValueRef) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n+pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: StrBuf) {\n     if ccx.all_llvm_symbols.borrow().contains(&sym) {\n-        ccx.sess().bug(\"duplicate LLVM symbol: \".to_owned() + sym);\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym));\n     }\n     ccx.all_llvm_symbols.borrow_mut().insert(sym);\n }\n@@ -505,8 +509,12 @@ pub fn get_res_dtor(ccx: &CrateContext,\n                                  ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n \n-        get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod, name,\n-                      lib::llvm::CCallConv, llty, ty::mk_nil())\n+        get_extern_fn(&mut *ccx.externs.borrow_mut(),\n+                      ccx.llmod,\n+                      name.as_slice(),\n+                      lib::llvm::CCallConv,\n+                      llty,\n+                      ty::mk_nil())\n     }\n }\n \n@@ -829,8 +837,8 @@ pub fn fail_if_zero<'a>(\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n-        cx.sess().bug(\"fail-if-zero on unexpected type: \".to_owned() +\n-                      ty_to_str(cx.tcx(), rhs_t));\n+        cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n+                              ty_to_str(cx.tcx(), rhs_t)));\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n@@ -848,28 +856,34 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                     get_extern_rust_fn(ccx,\n                                        fn_ty.sig.inputs.as_slice(),\n                                        fn_ty.sig.output,\n-                                       name,\n+                                       name.as_slice(),\n                                        did)\n                 }\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abi);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n-                    get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod,\n-                                  name, cconv, llty, fn_ty.sig.output)\n+                    get_extern_fn(&mut *ccx.externs.borrow_mut(),\n+                                  ccx.llmod,\n+                                  name.as_slice(),\n+                                  cconv,\n+                                  llty,\n+                                  fn_ty.sig.output)\n                 }\n             }\n         }\n         ty::ty_closure(ref f) => {\n             get_extern_rust_fn(ccx,\n                                f.sig.inputs.as_slice(),\n                                f.sig.output,\n-                               name,\n+                               name.as_slice(),\n                                did)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            get_extern_const(&mut *ccx.externs.borrow_mut(), ccx.llmod, name,\n+            get_extern_const(&mut *ccx.externs.borrow_mut(),\n+                             ccx.llmod,\n+                             name.as_slice(),\n                              llty)\n         }\n     }\n@@ -1443,7 +1457,7 @@ pub fn trans_fn(ccx: &CrateContext,\n                 param_substs: Option<&param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n-    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_owned());\n+    let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_strbuf());\n     debug!(\"trans_fn(param_substs={})\", param_substs.map(|s| s.repr(ccx.tcx())));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n@@ -1661,7 +1675,7 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     }\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n+fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: StrBuf, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     ccx.item_symbols.borrow_mut().insert(node_id, sym);\n \n@@ -1676,7 +1690,7 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: ~str, node_id: ast::Nod\n \n fn register_fn(ccx: &CrateContext,\n                sp: Span,\n-               sym: ~str,\n+               sym: StrBuf,\n                node_id: ast::NodeId,\n                node_type: ty::t)\n                -> ValueRef {\n@@ -1692,22 +1706,22 @@ fn register_fn(ccx: &CrateContext,\n                             false,\n                             f.sig.inputs.as_slice(),\n                             f.sig.output,\n-                            sym);\n+                            sym.as_slice());\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n \n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n-                          sym: ~str,\n+                          sym: StrBuf,\n                           node_id: ast::NodeId,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type,\n                           output: ty::t) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx.llmod, sym, cc, fn_ty, output);\n+    let llfn = decl_fn(ccx.llmod, sym.as_slice(), cc, fn_ty, output);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1752,7 +1766,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx.lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s); }\n+                    Err(s) => { ccx.sess().fatal(s.as_slice()); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -1796,15 +1810,15 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n }\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n-                 ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+                 ty: ty::t, attrs: &[ast::Attribute]) -> StrBuf {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.get().to_owned(),\n+        Some(name) => name.get().to_strbuf(),\n \n         _ => ccx.tcx.map.with_path(id, |mut path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().to_str()\n+                path.last().unwrap().to_str().to_strbuf()\n             } else {\n                 // Usual name mangling\n                 mangle_exported_name(ccx, path, ty, id)\n@@ -1854,7 +1868,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     unsafe {\n                         let llty = llvm::LLVMTypeOf(v);\n-                        let g = sym.with_c_str(|buf| {\n+                        let g = sym.as_slice().with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                         });\n \n@@ -2096,7 +2110,12 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        cx.sess().targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n+        cx.sess()\n+          .targ_cfg\n+          .target_strs\n+          .meta_sect_name\n+          .as_slice()\n+          .with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n     }\n@@ -2126,7 +2145,8 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&krate, output.out_filestem);\n+    let link_meta = link::build_link_meta(&krate,\n+                                          output.out_filestem.as_slice());\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n     //\n@@ -2186,8 +2206,8 @@ pub fn trans_crate(krate: ast::Crate,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable: Vec<~str> = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.borrow().find(id).map(|s| s.to_owned())\n+    let mut reachable: Vec<StrBuf> = ccx.reachable.iter().filter_map(|id| {\n+        ccx.item_symbols.borrow().find(id).map(|s| s.to_strbuf())\n     }).collect();\n \n     // Make sure that some other crucial symbols are not eliminated from the\n@@ -2196,12 +2216,13 @@ pub fn trans_crate(krate: ast::Crate,\n     // symbol. This symbol is required for use by the libmorestack library that\n     // we link in, so we must ensure that this symbol is not internalized (if\n     // defined in the crate).\n-    reachable.push(\"main\".to_owned());\n-    reachable.push(\"rust_stack_exhausted\".to_owned());\n+    reachable.push(\"main\".to_strbuf());\n+    reachable.push(\"rust_stack_exhausted\".to_strbuf());\n \n     // referenced from .eh_frame section on some platforms\n-    reachable.push(\"rust_eh_personality\".to_owned());\n-    reachable.push(\"rust_eh_personality_catch\".to_owned()); // referenced from rt/rust_try.ll\n+    reachable.push(\"rust_eh_personality\".to_strbuf());\n+    // referenced from rt/rust_try.ll\n+    reachable.push(\"rust_eh_personality_catch\".to_strbuf());\n \n     let metadata_module = ccx.metadata_llmod;\n     let formats = ccx.tcx.dependency_formats.borrow().clone();"}, {"sha": "bc4a2d9f96fb01435f57a6791cefbc27bdc6ce51", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -122,7 +122,7 @@ pub fn Invoke(cx: &Block,\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(fn_),\n-           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<~str>>().connect(\", \"));\n+           args.iter().map(|a| cx.val_to_str(*a)).collect::<Vec<StrBuf>>().connect(\", \"));\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n "}, {"sha": "17667003506b14b02f44b669a038a98f6196748c", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -81,8 +81,7 @@ impl<'a> Builder<'a> {\n                 s.push_char('/');\n                 s.push_str(category);\n \n-                let s = s.into_owned();\n-                let n = match h.find_equiv(&s) {\n+                let n = match h.find(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };\n@@ -805,7 +804,7 @@ impl<'a> Builder<'a> {\n                self.ccx.tn.val_to_str(llfn),\n                args.iter()\n                    .map(|&v| self.ccx.tn.val_to_str(v))\n-                   .collect::<Vec<~str>>()\n+                   .collect::<Vec<StrBuf>>()\n                    .connect(\", \"));\n \n         unsafe {"}, {"sha": "776de01614d6b5baf73bcc10830f83855ef0ca0e", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -599,7 +599,9 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n             {\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n-                let bcx_in = self.new_block(label.is_unwind(), name, None);\n+                let bcx_in = self.new_block(label.is_unwind(),\n+                                            name.as_slice(),\n+                                            None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n                     if cleanup_is_suitable_for(*cleanup, label) {\n@@ -649,7 +651,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name, None);\n+                    pad_bcx = self.new_block(true, name.as_slice(), None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -731,16 +733,16 @@ impl<'a> CleanupScope<'a> {\n             self.cleanups.iter().any(|c| c.clean_on_unwind())\n     }\n \n-    fn block_name(&self, prefix: &str) -> ~str {\n+    fn block_name(&self, prefix: &str) -> StrBuf {\n         /*!\n          * Returns a suitable name to use for the basic block that\n          * handles this cleanup scope\n          */\n \n         match self.kind {\n-            CustomScopeKind => format!(\"{}_custom_\", prefix),\n-            AstScopeKind(id) => format!(\"{}_ast_{}_\", prefix, id),\n-            LoopScopeKind(id, _) => format!(\"{}_loop_{}_\", prefix, id),\n+            CustomScopeKind => format_strbuf!(\"{}_custom_\", prefix),\n+            AstScopeKind(id) => format_strbuf!(\"{}_ast_{}_\", prefix, id),\n+            LoopScopeKind(id, _) => format_strbuf!(\"{}_loop_{}_\", prefix, id),\n         }\n     }\n }"}, {"sha": "80d35d88b2137b5e983e710d40e035c8e145c376", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -104,8 +104,8 @@ pub struct EnvValue {\n }\n \n impl EnvValue {\n-    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"{}({})\", self.action, self.datum.to_str(ccx))\n+    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+        format_strbuf!(\"{}({})\", self.action, self.datum.to_str(ccx))\n     }\n }\n \n@@ -354,7 +354,7 @@ pub fn trans_expr_fn<'a>(\n                                      true,\n                                      f.sig.inputs.as_slice(),\n                                      f.sig.output,\n-                                     s);\n+                                     s.as_slice());\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -417,9 +417,13 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                               true,\n                               f.sig.inputs.as_slice(),\n                               f.sig.output,\n-                              name)\n+                              name.as_slice())\n     } else {\n-        decl_rust_fn(ccx, true, f.sig.inputs.as_slice(), f.sig.output, name)\n+        decl_rust_fn(ccx,\n+                     true,\n+                     f.sig.inputs.as_slice(),\n+                     f.sig.output,\n+                     name.as_slice())\n     };\n \n     ccx.closure_bare_wrapper_cache.borrow_mut().insert(fn_ptr, llfn);"}, {"sha": "75015bd2d9d2b53f0d0fdaffa28baf6be98fbc10", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -173,7 +173,7 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<~str, ValueRef>;\n+pub type ExternMap = HashMap<StrBuf, ValueRef>;\n \n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n@@ -194,12 +194,12 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> ~str {\n-    format!(\"param_substs({})\", this.substs.repr(tcx))\n+fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> StrBuf {\n+    format_strbuf!(\"param_substs({})\", this.substs.repr(tcx))\n }\n \n impl Repr for param_substs {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         param_substs_to_str(self, tcx)\n     }\n }\n@@ -442,15 +442,15 @@ impl<'a> Block<'a> {\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n-    pub fn ident(&self, ident: Ident) -> ~str {\n-        token::get_ident(ident).get().to_str()\n+    pub fn ident(&self, ident: Ident) -> StrBuf {\n+        token::get_ident(ident).get().to_strbuf()\n     }\n \n-    pub fn node_id_to_str(&self, id: ast::NodeId) -> ~str {\n-        self.tcx().map.node_to_str(id).to_owned()\n+    pub fn node_id_to_str(&self, id: ast::NodeId) -> StrBuf {\n+        self.tcx().map.node_to_str(id).to_strbuf()\n     }\n \n-    pub fn expr_to_str(&self, e: &ast::Expr) -> ~str {\n+    pub fn expr_to_str(&self, e: &ast::Expr) -> StrBuf {\n         e.repr(self.tcx())\n     }\n \n@@ -464,21 +464,21 @@ impl<'a> Block<'a> {\n         }\n     }\n \n-    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+    pub fn val_to_str(&self, val: ValueRef) -> StrBuf {\n         self.ccx().tn.val_to_str(val)\n     }\n \n-    pub fn llty_str(&self, ty: Type) -> ~str {\n+    pub fn llty_str(&self, ty: Type) -> StrBuf {\n         self.ccx().tn.type_to_str(ty)\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, t: ty::t) -> StrBuf {\n         t.repr(self.tcx())\n     }\n \n-    pub fn to_str(&self) -> ~str {\n+    pub fn to_str(&self) -> StrBuf {\n         let blk: *Block = self;\n-        format!(\"[block {}]\", blk)\n+        format_strbuf!(\"[block {}]\", blk)\n     }\n }\n "}, {"sha": "71fcb0b4de559f924149a09dbf033cc184edb459", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -45,9 +45,9 @@ pub struct Stats {\n     pub n_inlines: Cell<uint>,\n     pub n_closures: Cell<uint>,\n     pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<HashMap<~str, uint>>,\n+    pub llvm_insns: RefCell<HashMap<StrBuf, uint>>,\n     // (ident, time-in-ms, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(~str, uint, uint)> >,\n+    pub fn_stats: RefCell<Vec<(StrBuf, uint, uint)> >,\n }\n \n pub struct CrateContext {\n@@ -60,7 +60,7 @@ pub struct CrateContext {\n     pub item_vals: RefCell<NodeMap<ValueRef>>,\n     pub exp_map2: resolve::ExportMap2,\n     pub reachable: NodeSet,\n-    pub item_symbols: RefCell<NodeMap<~str>>,\n+    pub item_symbols: RefCell<NodeMap<StrBuf>>,\n     pub link_meta: LinkMeta,\n     pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n     pub tydescs: RefCell<HashMap<ty::t, Rc<tydesc_info>>>,\n@@ -109,8 +109,8 @@ pub struct CrateContext {\n     pub llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n     pub adt_reprs: RefCell<HashMap<ty::t, Rc<adt::Repr>>>,\n     pub symbol_hasher: RefCell<Sha256>,\n-    pub type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n-    pub all_llvm_symbols: RefCell<HashSet<~str>>,\n+    pub type_hashcodes: RefCell<HashMap<ty::t, StrBuf>>,\n+    pub all_llvm_symbols: RefCell<HashSet<StrBuf>>,\n     pub tcx: ty::ctxt,\n     pub stats: Stats,\n     pub int_type: Type,\n@@ -141,16 +141,30 @@ impl CrateContext {\n             let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n-            tcx.sess.targ_cfg.target_strs.data_layout.with_c_str(|buf| {\n+            tcx.sess\n+               .targ_cfg\n+               .target_strs\n+               .data_layout\n+               .as_slice()\n+               .with_c_str(|buf| {\n                 llvm::LLVMSetDataLayout(llmod, buf);\n                 llvm::LLVMSetDataLayout(metadata_llmod, buf);\n             });\n-            tcx.sess.targ_cfg.target_strs.target_triple.with_c_str(|buf| {\n+            tcx.sess\n+               .targ_cfg\n+               .target_strs\n+               .target_triple\n+               .as_slice()\n+               .with_c_str(|buf| {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n                 llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n \n-            let td = mk_target_data(tcx.sess.targ_cfg.target_strs.data_layout);\n+            let td = mk_target_data(tcx.sess\n+                                       .targ_cfg\n+                                       .target_strs\n+                                       .data_layout\n+                                       .as_slice());\n \n             let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))"}, {"sha": "3b3852b3f45b12bbafe30b9976be2c06548f8c54", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -40,7 +40,7 @@ pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx()));\n+        add_span_comment(cx, s.span, s.repr(cx.tcx()).as_slice());\n     }\n \n     let mut bcx = cx;"}, {"sha": "6907237980202e76ed915dace3d5372a981d5b0b", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -624,11 +624,11 @@ impl<K:KindOps> Datum<K> {\n     }\n \n     #[allow(dead_code)] // useful for debugging\n-    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"Datum({}, {}, {:?})\",\n-             ccx.tn.val_to_str(self.val),\n-             ty_to_str(ccx.tcx(), self.ty),\n-             self.kind)\n+    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+        format_strbuf!(\"Datum({}, {}, {:?})\",\n+                       ccx.tn.val_to_str(self.val),\n+                       ty_to_str(ccx.tcx(), self.ty),\n+                       self.kind)\n     }\n \n     pub fn appropriate_rvalue_mode(&self, ccx: &CrateContext) -> RvalueMode {"}, {"sha": "e185d7702ff4d5d4789cb43654eb9b09ca51e4a4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 62, "deletions": 53, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -178,7 +178,7 @@ pub struct CrateDebugContext {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<DebugLocation>,\n-    created_files: RefCell<HashMap<~str, DIFile>>,\n+    created_files: RefCell<HashMap<StrBuf, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n     created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n@@ -343,8 +343,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let linkage_name = namespace_node.mangled_name_of_contained_item(var_name);\n     let var_scope = namespace_node.scope;\n \n-    var_name.with_c_str(|var_name| {\n-        linkage_name.with_c_str(|linkage_name| {\n+    var_name.as_slice().with_c_str(|var_name| {\n+        linkage_name.as_slice().with_c_str(|linkage_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n                                                         var_scope,\n@@ -725,7 +725,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n-        (function_name.as_slice().to_owned(), file_metadata)\n+        (function_name.as_slice().to_strbuf(), file_metadata)\n     };\n \n     // Clang sets this parameter to the opening brace of the function's block, so let's do this too.\n@@ -734,7 +734,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n     let fn_metadata = function_name.as_slice().with_c_str(|function_name| {\n-                          linkage_name.with_c_str(|linkage_name| {\n+                          linkage_name.as_slice().with_c_str(|linkage_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n                     DIB(cx),\n@@ -838,7 +838,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             let actual_self_type = self_type.unwrap();\n             // Add self type name to <...> clause of function name\n             let actual_self_type_name = ppaux::ty_to_str(cx.tcx(), actual_self_type);\n-            name_to_append_suffix_to.push_str(actual_self_type_name);\n+            name_to_append_suffix_to.push_str(\n+                actual_self_type_name.as_slice());\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -882,7 +883,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = ppaux::ty_to_str(cx.tcx(), actual_type);\n-            name_to_append_suffix_to.push_str(actual_type_name);\n+            name_to_append_suffix_to.push_str(actual_type_name.as_slice());\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1107,7 +1108,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n         });\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(full_path.to_owned(), file_metadata);\n+    created_files.insert(full_path.to_strbuf(), file_metadata);\n     return file_metadata;\n }\n \n@@ -1182,7 +1183,7 @@ fn pointer_type_metadata(cx: &CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ppaux::ty_to_str(cx.tcx(), pointer_type);\n-    let ptr_metadata = name.with_c_str(|name| {\n+    let ptr_metadata = name.as_slice().with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -1232,9 +1233,9 @@ impl StructMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.fields.iter().map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n-                \"\".to_owned()\n+                \"\".to_strbuf()\n             } else {\n-                token::get_ident(field.ident).get().to_str()\n+                token::get_ident(field.ident).get().to_strbuf()\n             };\n \n             MemberDescription {\n@@ -1263,7 +1264,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name,\n+                                                  struct_name.as_slice(),\n                                                   containing_scope,\n                                                   file_metadata,\n                                                   definition_span);\n@@ -1335,7 +1336,7 @@ impl TupleMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.component_types.iter().map(|&component_type| {\n             MemberDescription {\n-                name: \"\".to_owned(),\n+                name: \"\".to_strbuf(),\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n@@ -1359,7 +1360,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n         cache_id: cache_id_for_type(tuple_type),\n         metadata_stub: create_struct_stub(cx,\n                                           tuple_llvm_type,\n-                                          tuple_name,\n+                                          tuple_name.as_slice(),\n                                           file_metadata,\n                                           file_metadata,\n                                           span),\n@@ -1413,7 +1414,7 @@ impl GeneralMemberDescriptionFactory {\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n-                    name: \"\".to_owned(),\n+                    name: \"\".to_strbuf(),\n                     llvm_type: variant_llvm_type,\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n@@ -1423,7 +1424,7 @@ impl GeneralMemberDescriptionFactory {\n }\n \n struct EnumVariantMemberDescriptionFactory {\n-    args: Vec<(~str, ty::t)> ,\n+    args: Vec<(StrBuf, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n@@ -1433,7 +1434,7 @@ impl EnumVariantMemberDescriptionFactory {\n                                   -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n-                name: name.to_str(),\n+                name: name.to_strbuf(),\n                 llvm_type: type_of::type_of(cx, ty),\n                 type_metadata: match self.discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n@@ -1491,9 +1492,9 @@ fn describe_enum_variant(cx: &CrateContext,\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(~str, ty::t)> = arg_names.iter()\n+    let args: Vec<(StrBuf, ty::t)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n-        .map(|(s, &t)| (s.to_str(), t))\n+        .map(|(s, &t)| (s.to_strbuf(), t))\n         .collect();\n \n     let member_description_factory =\n@@ -1520,13 +1521,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx(), enum_type) {\n-        let empty_type_metadata = composite_type_metadata(cx,\n-                                                          Type::nil(cx),\n-                                                          enum_name,\n-                                                          [],\n-                                                          containing_scope,\n-                                                          file_metadata,\n-                                                          definition_span);\n+        let empty_type_metadata = composite_type_metadata(\n+            cx,\n+            Type::nil(cx),\n+            enum_name.as_slice(),\n+            [],\n+            containing_scope,\n+            file_metadata,\n+            definition_span);\n \n         return FinalMetadata(empty_type_metadata);\n     }\n@@ -1621,8 +1623,8 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n             let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n \n-            let enum_metadata = enum_name.with_c_str(|enum_name| {\n-                unique_id.with_c_str(|unique_id| {\n+            let enum_metadata = enum_name.as_slice().with_c_str(|enum_name| {\n+                unique_id.as_slice().with_c_str(|unique_id| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateUnionType(\n                         DIB(cx),\n@@ -1694,7 +1696,7 @@ enum MemberOffset {\n }\n \n struct MemberDescription {\n-    name: ~str,\n+    name: StrBuf,\n     llvm_type: Type,\n     type_metadata: DIType,\n     offset: MemberOffset,\n@@ -1764,7 +1766,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            member_description.name.with_c_str(|member_name| {\n+            member_description.name.as_slice().with_c_str(|member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -1806,7 +1808,7 @@ fn create_struct_stub(cx: &CrateContext,\n \n     return unsafe {\n         struct_type_name.with_c_str(|name| {\n-            unique_id.with_c_str(|unique_id| {\n+            unique_id.as_slice().with_c_str(|unique_id| {\n                 // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n                 // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n                 let empty_array = create_DIArray(DIB(cx), []);\n@@ -1853,31 +1855,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"refcnt\".to_owned(),\n+            name: \"refcnt\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"drop_glue\".to_owned(),\n+            name: \"drop_glue\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"prev\".to_owned(),\n+            name: \"prev\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"next\".to_owned(),\n+            name: \"next\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"val\".to_owned(),\n+            name: \"val\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1964,19 +1966,19 @@ fn vec_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"fill\".to_owned(),\n+            name: \"fill\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"alloc\".to_owned(),\n+            name: \"alloc\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"elements\".to_owned(),\n+            name: \"elements\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -2021,13 +2023,13 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     let member_descriptions = [\n         MemberDescription {\n-            name: \"data_ptr\".to_owned(),\n+            name: \"data_ptr\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: \"length\".to_owned(),\n+            name: \"length\".to_strbuf(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n@@ -2042,7 +2044,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n     return composite_type_metadata(\n         cx,\n         slice_llvm_type,\n-        slice_type_name,\n+        slice_type_name.as_slice(),\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n@@ -2099,11 +2101,15 @@ fn trait_metadata(cx: &CrateContext,\n     // the trait's methods.\n     let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n     let ident_string = token::get_name(last.name());\n-    let name = ppaux::trait_store_to_str(cx.tcx(), trait_store) +\n-               ident_string.get();\n+    let mut name = ppaux::trait_store_to_str(cx.tcx(), trait_store);\n+    name.push_str(ident_string.get());\n     // Add type and region parameters\n-    let name = ppaux::parameterized(cx.tcx(), name, &substs.regions,\n-                                    substs.tps.as_slice(), def_id, true);\n+    let name = ppaux::parameterized(cx.tcx(),\n+                                    name.as_slice(),\n+                                    &substs.regions,\n+                                    substs.tps.as_slice(),\n+                                    def_id,\n+                                    true);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n@@ -2114,7 +2120,7 @@ fn trait_metadata(cx: &CrateContext,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            name,\n+                            name.as_slice(),\n                             [],\n                             containing_scope,\n                             file_metadata,\n@@ -2136,7 +2142,8 @@ fn type_metadata(cx: &CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n-        let content_type_name: &str = ppaux::ty_to_str(cx.tcx(), type_in_box);\n+        let content_type_name = ppaux::ty_to_str(cx.tcx(), type_in_box);\n+        let content_type_name = content_type_name.as_slice();\n         let content_llvm_type = type_of::type_of(cx, type_in_box);\n         let content_type_metadata = type_metadata(\n             cx,\n@@ -2296,10 +2303,12 @@ fn cache_id_for_type(t: ty::t) -> uint {\n \n // Used to avoid LLVM metadata uniquing problems. See `create_struct_stub()` and\n // `prepare_enum_metadata()`.\n-fn generate_unique_type_id(prefix: &'static str) -> ~str {\n+fn generate_unique_type_id(prefix: &'static str) -> StrBuf {\n     unsafe {\n         static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-        format!(\"{}{}\", prefix, unique_id_counter.fetch_add(1, atomics::SeqCst))\n+        format_strbuf!(\"{}{}\",\n+                       prefix,\n+                       unique_id_counter.fetch_add(1, atomics::SeqCst))\n     }\n }\n \n@@ -2796,7 +2805,7 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n-                // inputs, outputs: ~[(~str, @expr)]\n+                // inputs, outputs: ~[(StrBuf, @expr)]\n                 for &(_, exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n@@ -2821,7 +2830,7 @@ struct NamespaceTreeNode {\n }\n \n impl NamespaceTreeNode {\n-    fn mangled_name_of_contained_item(&self, item_name: &str) -> ~str {\n+    fn mangled_name_of_contained_item(&self, item_name: &str) -> StrBuf {\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut StrBuf) {\n             match node.parent {\n                 Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n@@ -2837,7 +2846,7 @@ impl NamespaceTreeNode {\n         name.push_str(format!(\"{}\", item_name.len()));\n         name.push_str(item_name);\n         name.push_char('E');\n-        name.into_owned()\n+        name\n     }\n }\n "}, {"sha": "d3be50735be2aa024bfcb01aa5ef06fa87a9f809", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -86,10 +86,10 @@ pub enum Dest {\n }\n \n impl Dest {\n-    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n+    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n-            Ignore => \"Ignore\".to_owned()\n+            SaveIn(v) => format_strbuf!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n+            Ignore => \"Ignore\".to_strbuf()\n         }\n     }\n }\n@@ -545,7 +545,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                         let symbol = csearch::get_symbol(\n                             &bcx.ccx().sess().cstore,\n                             did);\n-                        let llval = symbol.with_c_str(|buf| {\n+                        let llval = symbol.as_slice().with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n                                                     llty.to_ref(),\n                                                     buf)"}, {"sha": "36f4eb1fd11dda97ced252afd319b8c0eb57bb5c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -445,7 +445,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n \n         let lname = link_name(foreign_item);\n         ccx.item_symbols.borrow_mut().insert(foreign_item.id,\n-                                             lname.get().to_owned());\n+                                             lname.get().to_strbuf());\n     }\n }\n \n@@ -476,7 +476,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n \n pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                                          sp: Span,\n-                                         sym: ~str,\n+                                         sym: StrBuf,\n                                          node_id: ast::NodeId)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n@@ -553,7 +553,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                                                false,\n                                                f.sig.inputs.as_slice(),\n                                                f.sig.output,\n-                                               ps);\n+                                               ps.as_slice());\n         base::set_llvm_fn_attrs(attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, None, id, []);\n         llfn"}, {"sha": "8869bd010b294ac58936c455eadbe687fc9db763", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -203,7 +203,7 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                                                                  ty::ReStatic) {\n         Ok(pair) => pair,\n         Err(s) => {\n-            bcx.tcx().sess.fatal(s);\n+            bcx.tcx().sess.fatal(s.as_slice());\n         }\n     };\n     let v = PointerCast(bcx, v, type_of(bcx.ccx(), object_ty).ptr_to());\n@@ -413,14 +413,15 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx(), t), name);\n-    let gvar = name.with_c_str(|buf| {\n+    let gvar = name.as_slice().with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n         }\n     });\n     note_unique_llvm_symbol(ccx, name);\n \n-    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx(), t));\n+    let ty_name = token::intern_and_get_ident(\n+        ppaux::ty_to_str(ccx.tcx(), t).as_slice());\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n@@ -439,7 +440,10 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"glue_\".to_owned() + name);\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n-    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty, ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx.llmod,\n+                             fn_nm.as_slice(),\n+                             llfnty,\n+                             ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }\n@@ -452,7 +456,9 @@ fn make_generic_glue(ccx: &CrateContext,\n                      name: &str)\n                      -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n+    let glue_name = format_strbuf!(\"glue {} {}\",\n+                                   name,\n+                                   ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let arena = TypedArena::new();"}, {"sha": "c5a4d136ab92fbb6dc678feb2c05744ed10bf025", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -13,24 +13,24 @@ use middle::trans::type_::Type;\n use lib::llvm::ValueRef;\n \n pub trait LlvmRepr {\n-    fn llrepr(&self, ccx: &CrateContext) -> ~str;\n+    fn llrepr(&self, ccx: &CrateContext) -> StrBuf;\n }\n \n impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n-    fn llrepr(&self, ccx: &CrateContext) -> ~str {\n-        let reprs: Vec<~str> = self.iter().map(|t| t.llrepr(ccx)).collect();\n-        format!(\"[{}]\", reprs.connect(\",\"))\n+    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n+        let reprs: Vec<StrBuf> = self.iter().map(|t| t.llrepr(ccx)).collect();\n+        format_strbuf!(\"[{}]\", reprs.connect(\",\"))\n     }\n }\n \n impl LlvmRepr for Type {\n-    fn llrepr(&self, ccx: &CrateContext) -> ~str {\n+    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n         ccx.tn.type_to_str(*self)\n     }\n }\n \n impl LlvmRepr for ValueRef {\n-    fn llrepr(&self, ccx: &CrateContext) -> ~str {\n+    fn llrepr(&self, ccx: &CrateContext) -> StrBuf {\n         ccx.tn.val_to_str(*self)\n     }\n }"}, {"sha": "bc3a0c0073f272b1d649dc39b5134990dfb94f54", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -109,9 +109,10 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ccx.sess(),\n         ccx.tcx.map.find(fn_id.node),\n         || {\n-            (format!(\"while monomorphizing {:?}, couldn't find it in the \\\n-                      item map (may have attempted to monomorphize an item \\\n-                      defined in a different crate?)\", fn_id)).to_strbuf()\n+            format_strbuf!(\"while monomorphizing {:?}, couldn't find it in \\\n+                            the item map (may have attempted to monomorphize \\\n+                            an item defined in a different crate?)\",\n+                           fn_id)\n         });\n \n     match map_node {\n@@ -212,9 +213,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     // This shouldn't need to option dance.\n     let mut hash_id = Some(hash_id);\n     let mk_lldecl = || {\n-        let lldecl = decl_internal_rust_fn(ccx, false,\n+        let lldecl = decl_internal_rust_fn(ccx,\n+                                           false,\n                                            f.sig.inputs.as_slice(),\n-                                           f.sig.output, s);\n+                                           f.sig.output,\n+                                           s.as_slice());\n         ccx.monomorphized.borrow_mut().insert(hash_id.take_unwrap(), lldecl);\n         lldecl\n     };"}, {"sha": "206fc07cd864ec5da95506b4ec52c6b3fe4ced89", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -254,8 +254,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               }\n \n               let extra = (vec!(\n-                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n-                                                                     t))),\n+                  self.c_slice(\n+                      token::intern_and_get_ident(ty_to_str(tcx,\n+                                                            t).as_slice())),\n                   self.c_bool(named_fields),\n                   self.c_uint(fields.len())\n               )).append(self.c_size_and_align(t).as_slice());\n@@ -288,7 +289,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                 let sym = mangle_internal_name_by_path_and_seq(\n                     ast_map::Values([].iter()).chain(None), \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, false, [opaqueptrty], ty::mk_u64(), sym);\n+                let llfdecl = decl_internal_rust_fn(ccx,\n+                                                    false,\n+                                                    [opaqueptrty],\n+                                                    ty::mk_u64(),\n+                                                    sym.as_slice());\n                 let arena = TypedArena::new();\n                 let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n                                       ty::mk_u64(), None, None, &arena);\n@@ -344,7 +349,8 @@ impl<'a, 'b> Reflector<'a, 'b> {\n \n           ty::ty_trait(..) => {\n               let extra = [\n-                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx, t)))\n+                  self.c_slice(token::intern_and_get_ident(\n+                          ty_to_str(tcx, t).as_slice()))\n               ];\n               self.visit(\"trait\", extra);\n           }"}, {"sha": "8ed3b76d6523d524da2af29259fd1c8ad9cd45e0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -73,13 +73,13 @@ pub struct VecTypes {\n }\n \n impl VecTypes {\n-    pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"VecTypes \\\\{unit_ty={}, llunit_ty={}, llunit_size={}, \\\n-                 llunit_alloc_size={}\\\\}\",\n-             ty_to_str(ccx.tcx(), self.unit_ty),\n-             ccx.tn.type_to_str(self.llunit_ty),\n-             ccx.tn.val_to_str(self.llunit_size),\n-             self.llunit_alloc_size)\n+    pub fn to_str(&self, ccx: &CrateContext) -> StrBuf {\n+        format_strbuf!(\"VecTypes \\\\{unit_ty={}, llunit_ty={}, \\\n+                        llunit_size={}, llunit_alloc_size={}\\\\}\",\n+                       ty_to_str(ccx.tcx(), self.unit_ty),\n+                       ccx.tn.type_to_str(self.llunit_ty),\n+                       ccx.tn.val_to_str(self.llunit_size),\n+                       self.llunit_alloc_size)\n     }\n }\n "}, {"sha": "9d13fa56e1e73a037303626c3452146c3e460531", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -206,7 +206,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n         let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n-        adt::incomplete_type_of(cx, &*repr, name)\n+        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n@@ -264,7 +264,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                         a_struct,\n                                         did,\n                                         substs.tps.as_slice());\n-              adt::incomplete_type_of(cx, &*repr, name)\n+              adt::incomplete_type_of(cx, &*repr, name.as_slice())\n           }\n       }\n \n@@ -301,18 +301,24 @@ pub enum named_ty { a_struct, an_enum }\n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::DefId,\n-                      tps: &[ty::t]) -> ~str {\n+                      tps: &[ty::t])\n+                      -> StrBuf {\n     let name = match what {\n         a_struct => { \"struct\" }\n         an_enum => { \"enum\" }\n     };\n-    let tstr = ppaux::parameterized(cx.tcx(), ty::item_path_str(cx.tcx(), did),\n-                                    &ty::NonerasedRegions(OwnedSlice::empty()),\n-                                    tps, did, false);\n+    let tstr = ppaux::parameterized(cx.tcx(),\n+                                    ty::item_path_str(cx.tcx(),\n+                                                      did).as_slice(),\n+                                    &ty::NonerasedRegions(\n+                                        OwnedSlice::empty()),\n+                                    tps,\n+                                    did,\n+                                    false);\n     if did.krate == 0 {\n-        format!(\"{}.{}\", name, tstr)\n+        format_strbuf!(\"{}.{}\", name, tstr)\n     } else {\n-        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.krate)\n+        format_strbuf!(\"{}.{}[\\\\#{}]\", name, tstr, did.krate)\n     }\n }\n "}, {"sha": "b6f8f33b719cc3d572ef758bd1f70bd5aa63cce9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 121, "deletions": 96, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -278,7 +278,7 @@ pub struct ctxt {\n     pub freevars: RefCell<freevars::freevar_map>,\n     pub tcache: type_cache,\n     pub rcache: creader_cache,\n-    pub short_names_cache: RefCell<HashMap<t, ~str>>,\n+    pub short_names_cache: RefCell<HashMap<t, StrBuf>>,\n     pub needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     pub tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n@@ -1538,7 +1538,7 @@ pub fn substs_is_noop(substs: &substs) -> bool {\n         substs.self_ty.is_none()\n }\n \n-pub fn substs_to_str(cx: &ctxt, substs: &substs) -> ~str {\n+pub fn substs_to_str(cx: &ctxt, substs: &substs) -> StrBuf {\n     substs.repr(cx)\n }\n \n@@ -3189,7 +3189,9 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     tcx.sess.bug(format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n-        fields.iter().map(|f| token::get_ident(f.ident).get().to_str()).collect::<Vec<~str>>()));\n+        fields.iter()\n+              .map(|f| token::get_ident(f.ident).get().to_strbuf())\n+              .collect::<Vec<StrBuf>>()));\n }\n \n pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n@@ -3212,34 +3214,38 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n+pub fn ty_sort_str(cx: &ctxt, t: t) -> StrBuf {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_str(cx, t)\n         }\n \n-        ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n-        ty_box(_) => \"@-ptr\".to_owned(),\n-        ty_uniq(_) => \"box\".to_owned(),\n-        ty_vec(_, _) => \"vector\".to_owned(),\n-        ty_ptr(_) => \"*-ptr\".to_owned(),\n-        ty_rptr(_, _) => \"&-ptr\".to_owned(),\n-        ty_bare_fn(_) => \"extern fn\".to_owned(),\n-        ty_closure(_) => \"fn\".to_owned(),\n-        ty_trait(ref inner) => format!(\"trait {}\", item_path_str(cx, inner.def_id)),\n-        ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n-        ty_tup(_) => \"tuple\".to_owned(),\n-        ty_infer(TyVar(_)) => \"inferred type\".to_owned(),\n-        ty_infer(IntVar(_)) => \"integral variable\".to_owned(),\n-        ty_infer(FloatVar(_)) => \"floating-point variable\".to_owned(),\n-        ty_param(_) => \"type parameter\".to_owned(),\n-        ty_self(_) => \"self\".to_owned(),\n-        ty_err => \"type error\".to_owned()\n+        ty_enum(id, _) => format_strbuf!(\"enum {}\", item_path_str(cx, id)),\n+        ty_box(_) => \"@-ptr\".to_strbuf(),\n+        ty_uniq(_) => \"box\".to_strbuf(),\n+        ty_vec(_, _) => \"vector\".to_strbuf(),\n+        ty_ptr(_) => \"*-ptr\".to_strbuf(),\n+        ty_rptr(_, _) => \"&-ptr\".to_strbuf(),\n+        ty_bare_fn(_) => \"extern fn\".to_strbuf(),\n+        ty_closure(_) => \"fn\".to_strbuf(),\n+        ty_trait(ref inner) => {\n+            format_strbuf!(\"trait {}\", item_path_str(cx, inner.def_id))\n+        }\n+        ty_struct(id, _) => {\n+            format_strbuf!(\"struct {}\", item_path_str(cx, id))\n+        }\n+        ty_tup(_) => \"tuple\".to_strbuf(),\n+        ty_infer(TyVar(_)) => \"inferred type\".to_strbuf(),\n+        ty_infer(IntVar(_)) => \"integral variable\".to_strbuf(),\n+        ty_infer(FloatVar(_)) => \"floating-point variable\".to_strbuf(),\n+        ty_param(_) => \"type parameter\".to_strbuf(),\n+        ty_self(_) => \"self\".to_strbuf(),\n+        ty_err => \"type error\".to_strbuf(),\n     }\n }\n \n-pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n+pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> StrBuf {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -3249,126 +3255,145 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n      * to present additional details, particularly when\n      * it comes to lifetime-related errors. */\n \n-    fn tstore_to_closure(s: &TraitStore) -> ~str {\n+    fn tstore_to_closure(s: &TraitStore) -> StrBuf {\n         match s {\n-            &UniqTraitStore => \"proc\".to_owned(),\n-            &RegionTraitStore(..) => \"closure\".to_owned()\n+            &UniqTraitStore => \"proc\".to_strbuf(),\n+            &RegionTraitStore(..) => \"closure\".to_strbuf()\n         }\n     }\n \n     match *err {\n-        terr_mismatch => \"types differ\".to_owned(),\n+        terr_mismatch => \"types differ\".to_strbuf(),\n         terr_fn_style_mismatch(values) => {\n-            format!(\"expected {} fn but found {} fn\",\n-                 values.expected.to_str(), values.found.to_str())\n+            format_strbuf!(\"expected {} fn but found {} fn\",\n+                           values.expected.to_str(),\n+                           values.found.to_str())\n         }\n         terr_abi_mismatch(values) => {\n-            format!(\"expected {} fn but found {} fn\",\n-                 values.expected.to_str(), values.found.to_str())\n+            format_strbuf!(\"expected {} fn but found {} fn\",\n+                           values.expected.to_str(),\n+                           values.found.to_str())\n         }\n         terr_onceness_mismatch(values) => {\n-            format!(\"expected {} fn but found {} fn\",\n-                 values.expected.to_str(), values.found.to_str())\n+            format_strbuf!(\"expected {} fn but found {} fn\",\n+                           values.expected.to_str(),\n+                           values.found.to_str())\n         }\n         terr_sigil_mismatch(values) => {\n-            format!(\"expected {}, found {}\",\n-                    tstore_to_closure(&values.expected),\n-                    tstore_to_closure(&values.found))\n-        }\n-        terr_mutability => \"values differ in mutability\".to_owned(),\n-        terr_box_mutability => \"boxed values differ in mutability\".to_owned(),\n-        terr_vec_mutability => \"vectors differ in mutability\".to_owned(),\n-        terr_ptr_mutability => \"pointers differ in mutability\".to_owned(),\n-        terr_ref_mutability => \"references differ in mutability\".to_owned(),\n+            format_strbuf!(\"expected {}, found {}\",\n+                           tstore_to_closure(&values.expected),\n+                           tstore_to_closure(&values.found))\n+        }\n+        terr_mutability => \"values differ in mutability\".to_strbuf(),\n+        terr_box_mutability => {\n+            \"boxed values differ in mutability\".to_strbuf()\n+        }\n+        terr_vec_mutability => \"vectors differ in mutability\".to_strbuf(),\n+        terr_ptr_mutability => \"pointers differ in mutability\".to_strbuf(),\n+        terr_ref_mutability => \"references differ in mutability\".to_strbuf(),\n         terr_ty_param_size(values) => {\n-            format!(\"expected a type with {} type params \\\n-                  but found one with {} type params\",\n-                 values.expected, values.found)\n+            format_strbuf!(\"expected a type with {} type params \\\n+                            but found one with {} type params\",\n+                           values.expected,\n+                           values.found)\n         }\n         terr_tuple_size(values) => {\n-            format!(\"expected a tuple with {} elements \\\n-                  but found one with {} elements\",\n-                 values.expected, values.found)\n+            format_strbuf!(\"expected a tuple with {} elements \\\n+                            but found one with {} elements\",\n+                           values.expected,\n+                           values.found)\n         }\n         terr_record_size(values) => {\n-            format!(\"expected a record with {} fields \\\n-                  but found one with {} fields\",\n-                 values.expected, values.found)\n+            format_strbuf!(\"expected a record with {} fields \\\n+                            but found one with {} fields\",\n+                           values.expected,\n+                           values.found)\n         }\n         terr_record_mutability => {\n-            \"record elements differ in mutability\".to_owned()\n+            \"record elements differ in mutability\".to_strbuf()\n         }\n         terr_record_fields(values) => {\n-            format!(\"expected a record with field `{}` but found one with field \\\n-                  `{}`\",\n-                 token::get_ident(values.expected),\n-                 token::get_ident(values.found))\n+            format_strbuf!(\"expected a record with field `{}` but found one \\\n+                            with field `{}`\",\n+                           token::get_ident(values.expected),\n+                           token::get_ident(values.found))\n+        }\n+        terr_arg_count => {\n+            \"incorrect number of function parameters\".to_strbuf()\n         }\n-        terr_arg_count => \"incorrect number of function parameters\".to_owned(),\n         terr_regions_does_not_outlive(..) => {\n-            format!(\"lifetime mismatch\")\n+            \"lifetime mismatch\".to_strbuf()\n         }\n         terr_regions_not_same(..) => {\n-            format!(\"lifetimes are not the same\")\n+            \"lifetimes are not the same\".to_strbuf()\n         }\n         terr_regions_no_overlap(..) => {\n-            format!(\"lifetimes do not intersect\")\n+            \"lifetimes do not intersect\".to_strbuf()\n         }\n         terr_regions_insufficiently_polymorphic(br, _) => {\n-            format!(\"expected bound lifetime parameter {}, \\\n-                  but found concrete lifetime\",\n-                 bound_region_ptr_to_str(cx, br))\n+            format_strbuf!(\"expected bound lifetime parameter {}, \\\n+                            but found concrete lifetime\",\n+                           bound_region_ptr_to_str(cx, br))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n-            format!(\"expected concrete lifetime, \\\n-                  but found bound lifetime parameter {}\",\n-                 bound_region_ptr_to_str(cx, br))\n+            format_strbuf!(\"expected concrete lifetime, \\\n+                            but found bound lifetime parameter {}\",\n+                           bound_region_ptr_to_str(cx, br))\n         }\n         terr_trait_stores_differ(_, ref values) => {\n-            format!(\"trait storage differs: expected `{}` but found `{}`\",\n-                 trait_store_to_str(cx, (*values).expected),\n-                 trait_store_to_str(cx, (*values).found))\n+            format_strbuf!(\"trait storage differs: expected `{}` but found \\\n+                            `{}`\",\n+                           trait_store_to_str(cx, (*values).expected),\n+                           trait_store_to_str(cx, (*values).found))\n         }\n         terr_sorts(values) => {\n-            format!(\"expected {} but found {}\",\n-                 ty_sort_str(cx, values.expected),\n-                 ty_sort_str(cx, values.found))\n+            format_strbuf!(\"expected {} but found {}\",\n+                           ty_sort_str(cx, values.expected),\n+                           ty_sort_str(cx, values.found))\n         }\n         terr_traits(values) => {\n-            format!(\"expected trait `{}` but found trait `{}`\",\n-                 item_path_str(cx, values.expected),\n-                 item_path_str(cx, values.found))\n+            format_strbuf!(\"expected trait `{}` but found trait `{}`\",\n+                           item_path_str(cx, values.expected),\n+                           item_path_str(cx, values.found))\n         }\n         terr_builtin_bounds(values) => {\n             if values.expected.is_empty() {\n-                format!(\"expected no bounds but found `{}`\",\n-                     values.found.user_string(cx))\n+                format_strbuf!(\"expected no bounds but found `{}`\",\n+                               values.found.user_string(cx))\n             } else if values.found.is_empty() {\n-                format!(\"expected bounds `{}` but found no bounds\",\n-                     values.expected.user_string(cx))\n+                format_strbuf!(\"expected bounds `{}` but found no bounds\",\n+                               values.expected.user_string(cx))\n             } else {\n-                format!(\"expected bounds `{}` but found bounds `{}`\",\n-                     values.expected.user_string(cx),\n-                     values.found.user_string(cx))\n+                format_strbuf!(\"expected bounds `{}` but found bounds `{}`\",\n+                               values.expected.user_string(cx),\n+                               values.found.user_string(cx))\n             }\n         }\n         terr_integer_as_char => {\n-            format!(\"expected an integral type but found `char`\")\n+            \"expected an integral type but found `char`\".to_strbuf()\n         }\n         terr_int_mismatch(ref values) => {\n-            format!(\"expected `{}` but found `{}`\",\n-                 values.expected.to_str(),\n-                 values.found.to_str())\n+            format_strbuf!(\"expected `{}` but found `{}`\",\n+                           values.expected.to_str(),\n+                           values.found.to_str())\n         }\n         terr_float_mismatch(ref values) => {\n-            format!(\"expected `{}` but found `{}`\",\n-                 values.expected.to_str(),\n-                 values.found.to_str())\n+            format_strbuf!(\"expected `{}` but found `{}`\",\n+                           values.expected.to_str(),\n+                           values.found.to_str())\n         }\n         terr_variadic_mismatch(ref values) => {\n-            format!(\"expected {} fn but found {} function\",\n-                    if values.expected { \"variadic\" } else { \"non-variadic\" },\n-                    if values.found { \"variadic\" } else { \"non-variadic\" })\n+            format_strbuf!(\"expected {} fn but found {} function\",\n+                           if values.expected {\n+                                \"variadic\"\n+                           } else {\n+                                \"non-variadic\"\n+                           },\n+                           if values.found {\n+                               \"variadic\"\n+                           } else {\n+                               \"non-variadic\"\n+                           })\n         }\n     }\n }\n@@ -3665,8 +3690,8 @@ pub fn substd_enum_variants(cx: &ctxt,\n     }).collect()\n }\n \n-pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> ~str {\n-    with_path(cx, id, |path| ast_map::path_to_str(path)).to_owned()\n+pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> StrBuf {\n+    with_path(cx, id, |path| ast_map::path_to_str(path)).to_strbuf()\n }\n \n pub enum DtorKind {\n@@ -4231,22 +4256,22 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n-pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n+pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, StrBuf> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n-pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n+pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, StrBuf> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n \n pub fn visitor_object_ty(tcx: &ctxt,\n-                         region: ty::Region) -> Result<(Rc<TraitRef>, t), ~str> {\n+                         region: ty::Region) -> Result<(Rc<TraitRef>, t), StrBuf> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }"}, {"sha": "740539cbddd7d17a0c87b7ea7fbb192c3314f8fb", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 74, "deletions": 35, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -166,11 +166,15 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_or(\"\".to_owned(), |e| {\n-                        format!(\"mismatched types: expected `{}` but found {}\",\n-                             e, actual)})},\n-                             Some(expected), \"a structure pattern\".to_owned(),\n-                             None);\n+                       expected.map_or(\"\".to_strbuf(), |e| {\n+                        format_strbuf!(\"mismatched types: expected `{}` but \\\n+                                        found {}\",\n+                                       e,\n+                                       actual)\n+                        })},\n+                        Some(expected),\n+                        \"a structure pattern\".to_strbuf(),\n+                        None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = subpats.clone()\n@@ -217,11 +221,17 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_or(\"\".to_owned(), |e| {\n-                    format!(\"mismatched types: expected `{}` but found {}\",\n-                         e, actual)})},\n-                    Some(expected), \"an enum or structure pattern\".to_owned(),\n-                    None);\n+                                               expected.map_or(\"\".to_strbuf(),\n+                                                              |e| {\n+                        format_strbuf!(\"mismatched types: expected `{}` but \\\n+                                        found {}\",\n+                                       e,\n+                                       actual)\n+                    })\n+                },\n+                Some(expected),\n+                \"an enum or structure pattern\".to_strbuf(),\n+                None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = subpats.clone()\n@@ -446,7 +456,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n-            || \"mismatched types in range\".to_owned())\n+            || \"mismatched types in range\".to_strbuf())\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) && !ty::type_is_char(b_ty) {\n@@ -540,11 +550,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n-                            expected.map_or(\"\".to_owned(), |e| {\n-                                    format!(\"mismatched types: expected `{}` but found {}\",\n-                                         e, actual)})},\n-                                         Some(expected), \"a structure pattern\".to_owned(),\n-                                         None);\n+                            expected.map_or(\"\".to_strbuf(),\n+                                            |e| {\n+                                format_strbuf!(\"mismatched types: expected \\\n+                                                `{}` but found {}\",\n+                                               e,\n+                                               actual)\n+                            })},\n+                            Some(expected),\n+                            \"a structure pattern\".to_strbuf(),\n+                            None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx,\n@@ -590,17 +605,28 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 }\n                 // use terr_tuple_size if both types are tuples\n                 let type_error = match *s {\n-                    ty::ty_tup(ref ex_elts) =>\n-                        ty::terr_tuple_size(ty::expected_found{expected: ex_elts.len(),\n-                                                           found: e_count}),\n+                    ty::ty_tup(ref ex_elts) => {\n+                        ty::terr_tuple_size(ty::expected_found {\n+                            expected: ex_elts.len(),\n+                            found: e_count\n+                        })\n+                    }\n                     _ => ty::terr_mismatch\n                 };\n                 // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-                fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                        expected.map_or(\"\".to_owned(), |e| {\n-                            format!(\"mismatched types: expected `{}` but found {}\",\n-                                             e, actual)})},\n-                    Some(expected), \"tuple\".to_owned(), Some(&type_error));\n+                fcx.infcx().type_error_message_str_with_expected(pat.span,\n+                                                                 |expected,\n+                                                                  actual| {\n+                        expected.map_or(\"\".to_strbuf(), |e| {\n+                            format_strbuf!(\"mismatched types: expected `{}` \\\n+                                            but found {}\",\n+                                           e,\n+                                           actual)\n+                        }\n+                    )},\n+                    Some(expected),\n+                    \"tuple\".to_strbuf(),\n+                    Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n         }\n@@ -630,11 +656,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().type_error_message_str_with_expected(\n                 pat.span,\n                 |expected, actual| {\n-                    expected.map_or(\"\".to_owned(), |e| {\n-                        format!(\"mismatched types: expected `{}` but found {}\",\n-                             e, actual)})},\n+                    expected.map_or(\"\".to_strbuf(),\n+                                    |e| {\n+                        format_strbuf!(\"mismatched types: expected `{}` but \\\n+                                        found {}\",\n+                                       e,\n+                                       actual)\n+                    })\n+                },\n                 Some(expected),\n-                \"a vector pattern\".to_owned(),\n+                \"a vector pattern\".to_strbuf(),\n                 None);\n             fcx.write_error(pat.id);\n         };\n@@ -648,7 +679,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                   fcx.type_error_message(pat.span,\n                                          |_| {\n                                             \"unique vector patterns are no \\\n-                                             longer supported\".to_owned()\n+                                             longer supported\".to_strbuf()\n                                          },\n                                          expected,\n                                          None);\n@@ -716,13 +747,17 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_or(\"\".to_owned(), |e| {\n-                        format!(\"mismatched types: expected `{}` but found {}\",\n-                             e, actual)})},\n+                    expected.map_or(\"\".to_strbuf(), |e| {\n+                        format_strbuf!(\"mismatched types: expected `{}` but \\\n+                                        found {}\",\n+                                       e,\n+                                       actual)\n+                    })\n+                },\n                 Some(expected),\n-                format!(\"{} pattern\", match pointer_kind {\n+                format_strbuf!(\"{} pattern\", match pointer_kind {\n                     Send => \"a box\",\n-                    Borrowed => \"an `&`-pointer\"\n+                    Borrowed => \"an `&`-pointer\",\n                 }),\n                 None);\n             fcx.write_error(pat_id);\n@@ -731,4 +766,8 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n }\n \n #[deriving(Eq)]\n-pub enum PointerKind { Send, Borrowed }\n+pub enum PointerKind {\n+    Send,\n+    Borrowed,\n+}\n+"}, {"sha": "839e3dd080a0a5ecf7b333664c0bc478a66329de", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1498,11 +1498,11 @@ impl<'a> LookupContext<'a> {\n         self.fcx.tcx()\n     }\n \n-    fn ty_to_str(&self, t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> StrBuf {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn did_to_str(&self, did: DefId) -> ~str {\n+    fn did_to_str(&self, did: DefId) -> StrBuf {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n@@ -1512,23 +1512,24 @@ impl<'a> LookupContext<'a> {\n }\n \n impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, origin={:?})\",\n-                self.rcvr_match_condition.repr(tcx),\n-                self.rcvr_substs.repr(tcx),\n-                self.method_ty.repr(tcx),\n-                self.origin)\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        format_strbuf!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n+                        origin={:?})\",\n+                       self.rcvr_match_condition.repr(tcx),\n+                       self.rcvr_substs.repr(tcx),\n+                       self.method_ty.repr(tcx),\n+                       self.origin)\n     }\n }\n \n impl Repr for RcvrMatchCondition {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n-                format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n+                format_strbuf!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n             }\n             RcvrMatchesIfSubtype(t) => {\n-                format!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n+                format_strbuf!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n             }\n         }\n     }"}, {"sha": "94f08b28fed2518934e9adb11f95ec13c1d8810e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 154, "deletions": 85, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -468,7 +468,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={:?}, ret_ty={:?})\",\n-           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<~str>>(),\n+           arg_tys.iter().map(|&a| ppaux::ty_to_str(tcx, a)).collect::<Vec<StrBuf>>(),\n            ppaux::ty_to_str(tcx, ret_ty));\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -1089,8 +1089,8 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n }\n \n impl<'a> FnCtxt<'a> {\n-    pub fn tag(&self) -> ~str {\n-        format!(\"{}\", self as *FnCtxt)\n+    pub fn tag(&self) -> StrBuf {\n+        format_strbuf!(\"{}\", self as *FnCtxt)\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n@@ -1164,7 +1164,7 @@ impl<'a> FnCtxt<'a> {\n         ast_ty_to_ty(self, self.infcx(), ast_t)\n     }\n \n-    pub fn pat_to_str(&self, pat: &ast::Pat) -> ~str {\n+    pub fn pat_to_str(&self, pat: &ast::Pat) -> StrBuf {\n         pat.repr(self.tcx())\n     }\n \n@@ -1271,7 +1271,7 @@ impl<'a> FnCtxt<'a> {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: |~str| -> ~str,\n+                              mk_msg: |StrBuf| -> StrBuf,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1787,7 +1787,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n-               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<~str>>());\n+               formal_tys.iter().map(|t| fcx.infcx().ty_to_str(*t)).collect::<Vec<StrBuf>>());\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1863,18 +1863,24 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 match ty::get(arg_ty).sty {\n                     ty::ty_float(ast::TyF32) => {\n                         fcx.type_error_message(arg.span,\n-                                |t| format!(\"can't pass an {} to variadic function, \\\n-                                             cast to c_double\", t), arg_ty, None);\n+                                               |t| {\n+                            format_strbuf!(\"can't pass an {} to variadic \\\n+                                            function, cast to c_double\", t)\n+                        }, arg_ty, None);\n                     }\n                     ty::ty_int(ast::TyI8) | ty::ty_int(ast::TyI16) | ty::ty_bool => {\n-                        fcx.type_error_message(arg.span,\n-                                |t| format!(\"can't pass {} to variadic function, cast to c_int\",\n-                                            t), arg_ty, None);\n+                        fcx.type_error_message(arg.span, |t| {\n+                            format_strbuf!(\"can't pass {} to variadic \\\n+                                            function, cast to c_int\",\n+                                           t)\n+                        }, arg_ty, None);\n                     }\n                     ty::ty_uint(ast::TyU8) | ty::ty_uint(ast::TyU16) => {\n-                        fcx.type_error_message(arg.span,\n-                                |t| format!(\"can't pass {} to variadic function, cast to c_uint\",\n-                                            t), arg_ty, None);\n+                        fcx.type_error_message(arg.span, |t| {\n+                            format_strbuf!(\"can't pass {} to variadic \\\n+                                            function, cast to c_uint\",\n+                                           t)\n+                        }, arg_ty, None);\n                     }\n                     _ => {}\n                 }\n@@ -1920,8 +1926,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ty::ty_closure(box ty::ClosureTy {sig: ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n-                    format!(\"expected function but \\\n-                          found `{}`\", actual) }, fn_ty, None);\n+                    format_strbuf!(\"expected function but found `{}`\", actual)\n+                }, fn_ty, None);\n                 &error_fn_sig\n             }\n         };\n@@ -1974,8 +1980,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n                 fcx.type_error_message(method_name.span,\n                   |actual| {\n-                      format!(\"type `{}` does not implement any method in scope named `{}`\",\n-                              actual, token::get_ident(method_name.node))\n+                      format_strbuf!(\"type `{}` does not implement any \\\n+                                      method in scope named `{}`\",\n+                                     actual,\n+                                     token::get_ident(method_name.node))\n                   },\n                   expr_t,\n                   None);\n@@ -1984,12 +1992,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 fcx.write_error(expr.id);\n \n                 // Check for potential static matches (missing self parameters)\n-                method::lookup(fcx, expr, rcvr,\n-                                    method_name.node.name,\n-                                    expr_t, tps.as_slice(),\n-                                    DontDerefArgs,\n-                                    CheckTraitsAndInherentMethods,\n-                                    DontAutoderefReceiver, ReportStaticMethods);\n+                method::lookup(fcx,\n+                               expr,\n+                               rcvr,\n+                               method_name.node.name,\n+                               expr_t,\n+                               tps.as_slice(),\n+                               DontDerefArgs,\n+                               CheckTraitsAndInherentMethods,\n+                               DontAutoderefReceiver,\n+                               ReportStaticMethods);\n \n                 ty::mk_err()\n             }\n@@ -2123,9 +2135,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         if ty::type_is_fp(ty::simd_type(tcx, lhs_t)) {\n                             fcx.type_error_message(expr.span,\n                                 |actual| {\n-                                    format!(\"binary comparison operation `{}` not supported \\\n-                                            for floating point SIMD vector `{}`\",\n-                                            ast_util::binop_to_str(op), actual)\n+                                    format_strbuf!(\"binary comparison \\\n+                                                    operation `{}` not \\\n+                                                    supported for floating \\\n+                                                    point SIMD vector `{}`\",\n+                                                   ast_util::binop_to_str(op),\n+                                                   actual)\n                                 },\n                                 lhs_t,\n                                 None\n@@ -2150,12 +2165,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             // type\n             fcx.write_error(expr.id);\n             fcx.write_error(rhs.id);\n-            fcx.type_error_message(expr.span, |actual| {\n-                format!(\"binary operation `{}` cannot be applied \\\n-                      to type `{}`\",\n-                     ast_util::binop_to_str(op), actual)},\n-                                   lhs_t, None)\n-\n+            fcx.type_error_message(expr.span,\n+                                   |actual| {\n+                    format_strbuf!(\"binary operation `{}` cannot be applied \\\n+                                   to type `{}`\",\n+                                   ast_util::binop_to_str(op),\n+                                   actual)\n+                },\n+                lhs_t,\n+                None)\n         }\n \n         // Check for overloaded operators if not an assignment.\n@@ -2164,10 +2182,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n-                                        format!(\"binary assignment operation \\\n-                                                `{}=` cannot be applied to type `{}`\",\n-                                                ast_util::binop_to_str(op),\n-                                                actual)\n+                                        format_strbuf!(\"binary assignment \\\n+                                                        operation `{}=` \\\n+                                                        cannot be applied to \\\n+                                                        type `{}`\",\n+                                                 ast_util::binop_to_str(op),\n+                                                 actual)\n                                    },\n                                    lhs_t,\n                                    None);\n@@ -2214,8 +2234,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n                          trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n-                format!(\"binary operation `{}` cannot be applied to type `{}`\",\n-                    ast_util::binop_to_str(op), actual)\n+                format_strbuf!(\"binary operation `{}` cannot be applied to \\\n+                                type `{}`\",\n+                               ast_util::binop_to_str(op),\n+                               actual)\n             }, lhs_resolved_t, None)\n         })\n     }\n@@ -2230,7 +2252,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, [rhs_expr], DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n-                format!(\"cannot apply unary operator `{}` to type `{}`\", op_str, actual)\n+                format_strbuf!(\"cannot apply unary operator `{}` to type \\\n+                                `{}`\",\n+                               op_str,\n+                               actual)\n             }, rhs_t, None);\n         })\n     }\n@@ -2389,8 +2414,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        format!(\"attempted to take value of method `{}` on type `{}`\",\n-                                token::get_name(field), actual)\n+                        format_strbuf!(\"attempted to take value of method \\\n+                                        `{}` on type `{}`\",\n+                                       token::get_name(field),\n+                                       actual)\n                     },\n                     expr_t, None);\n \n@@ -2402,9 +2429,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        format!(\"attempted access of field `{}` on type `{}`, \\\n-                                 but no field with that name was found\",\n-                                token::get_name(field), actual)\n+                        format_strbuf!(\"attempted access of field `{}` on \\\n+                                        type `{}`, but no field with that \\\n+                                        name was found\",\n+                                       token::get_name(field),\n+                                       actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2442,9 +2471,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     fcx.type_error_message(\n                       field.ident.span,\n                       |actual| {\n-                          format!(\"structure `{}` has no field named `{}`\",\n-                                  actual, token::get_ident(field.ident.node))\n-                    }, struct_ty, None);\n+                          format_strbuf!(\"structure `{}` has no field named \\\n+                                          `{}`\",\n+                                         actual,\n+                                         token::get_ident(field.ident.node))\n+                      },\n+                      struct_ty,\n+                      None);\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n@@ -2701,7 +2734,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                            .require(GcLangItem) {\n                                       Ok(id) => id,\n                                       Err(msg) => {\n-                                          tcx.sess.span_err(expr.span, msg);\n+                                          tcx.sess.span_err(expr.span,\n+                                                            msg.as_slice());\n                                           ast::DefId {\n                                               krate: ast::CRATE_NODE_ID,\n                                               node: ast::DUMMY_NODE_ID,\n@@ -2825,7 +2859,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                          no longer be dereferenced\");\n                                 } else {\n                                     fcx.type_error_message(expr.span, |actual| {\n-                                        format!(\"type `{}` cannot be dereferenced\", actual)\n+                                        format_strbuf!(\"type `{}` cannot be \\\n+                                                        dereferenced\",\n+                                                       actual)\n                                     }, oprnd_t, None);\n                                 }\n                                 ty::mk_err()\n@@ -3066,13 +3102,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 _ => {\n                     if ty::type_is_nil(t_e) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"cast from nil: `{}` as `{}`\", actual,\n-                                 fcx.infcx().ty_to_str(t_1))\n+                            format_strbuf!(\"cast from nil: `{}` as `{}`\",\n+                                           actual,\n+                                           fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     } else if ty::type_is_nil(t_1) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"cast to nil: `{}` as `{}`\", actual,\n-                                 fcx.infcx().ty_to_str(t_1))\n+                            format_strbuf!(\"cast to nil: `{}` as `{}`\",\n+                                           actual,\n+                                           fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n \n@@ -3092,12 +3130,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         let te = fcx.infcx().resolve_type_vars_if_possible(te);\n                         if ty::get(te).sty != ty::ty_uint(ast::TyU8) {\n                             fcx.type_error_message(expr.span, |actual| {\n-                                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+                                format_strbuf!(\"only `u8` can be cast as \\\n+                                                `char`, not `{}`\",\n+                                               actual)\n                             }, t_e, None);\n                         }\n                     } else if ty::get(t1).sty == ty::ty_bool {\n-                        fcx.tcx().sess.span_err(expr.span,\n-                                                \"cannot cast as `bool`, compare with zero instead\");\n+                        fcx.tcx()\n+                           .sess\n+                           .span_err(expr.span,\n+                                     \"cannot cast as `bool`, compare with \\\n+                                      zero instead\");\n                     } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n                         type_is_unsafe_ptr(fcx, expr.span, t_1) {\n \n@@ -3151,8 +3194,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         record the issue number in this comment.\n                         */\n                         fcx.type_error_message(expr.span, |actual| {\n-                            format!(\"non-scalar cast: `{}` as `{}`\", actual,\n-                                 fcx.infcx().ty_to_str(t_1))\n+                            format_strbuf!(\"non-scalar cast: `{}` as `{}`\",\n+                                           actual,\n+                                           fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n                 }\n@@ -3271,9 +3315,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                     || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n-                                                format!(\"cannot index a value \\\n-                                                      of type `{}`\",\n-                                                     actual)\n+                                                    format_strbuf!(\"cannot \\\n+                                                                    index a \\\n+                                                                    value of \\\n+                                                                    type \\\n+                                                                    `{}`\",\n+                                                                    actual)\n                                                },\n                                                base_t,\n                                                None);\n@@ -3291,7 +3338,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n-               _ => \"empty\".to_owned()\n+               _ => \"empty\".to_strbuf()\n            });\n \n     unifier();\n@@ -3300,17 +3347,19 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_uint(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected `uint` type but found `{}`\",\n-                 actual)\n+            format_strbuf!(\"mismatched types: expected `uint` type but found \\\n+                           `{}`\",\n+                           actual)\n         }, t, None);\n     }\n }\n \n pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected integral type but found `{}`\",\n-                 actual)\n+            format_strbuf!(\"mismatched types: expected integral type but \\\n+                            found `{}`\",\n+                           actual)\n         }, t, None);\n     }\n }\n@@ -3439,8 +3488,13 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                   ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n                   _ => false\n                 } {\n-                fcx.ccx.tcx.sess.add_lint(UnreachableCode, s_id, s.span,\n-                                          \"unreachable statement\".to_owned());\n+                fcx.ccx\n+                   .tcx\n+                   .sess\n+                   .add_lint(UnreachableCode,\n+                             s_id,\n+                             s.span,\n+                             \"unreachable statement\".to_strbuf());\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {\n@@ -3461,8 +3515,13 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n             },\n           Some(e) => {\n             if any_bot && !warned {\n-                fcx.ccx.tcx.sess.add_lint(UnreachableCode, e.id, e.span,\n-                                          \"unreachable expression\".to_owned());\n+                fcx.ccx\n+                   .tcx\n+                   .sess\n+                   .add_lint(UnreachableCode,\n+                             e.id,\n+                             e.span,\n+                             \"unreachable expression\".to_strbuf());\n             }\n             check_expr_with_opt_hint(fcx, e, expected);\n               let ety = fcx.expr_ty(e);\n@@ -3979,7 +4038,8 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n         _ => {\n             fcx.type_error_message(sp, |_actual| {\n-                \"the type of this value must be known in this context\".to_owned()\n+                \"the type of this value must be known in this \\\n+                 context\".to_strbuf()\n             }, tp, None);\n             demand::suptype(fcx, sp, ty::mk_err(), tp);\n             tp\n@@ -4183,7 +4243,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -4199,18 +4259,20 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                                  tps: Vec::new(),\n                                                  regions: ty::NonerasedRegions(OwnedSlice::empty())\n                                                  }) ),\n-                    Err(msg) => { tcx.sess.span_fatal(it.span, msg); }\n+                    Err(msg) => {\n+                        tcx.sess.span_fatal(it.span, msg.as_slice());\n+                    }\n                 }\n             },\n             \"visit_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n               };\n               let region = ty::ReLateBound(it.id, ty::BrAnon(0));\n               let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n                   Ok((_, vot)) => vot,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s.as_slice()); }\n               };\n \n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n@@ -4387,10 +4449,12 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         fn_style: ast::UnsafeFn,\n         abi: abi::RustIntrinsic,\n-        sig: FnSig {binder_id: it.id,\n-                    inputs: inputs,\n-                    output: output,\n-                    variadic: false}\n+        sig: FnSig {\n+            binder_id: it.id,\n+            inputs: inputs,\n+            output: output,\n+            variadic: false,\n+        }\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs().len();\n@@ -4399,10 +4463,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                          of type parameters: found {}, \\\n                                          expected {}\", i_n_tps, n_tps));\n     } else {\n-        require_same_types(\n-            tcx, None, false, it.span, i_ty.ty, fty,\n-            || format!(\"intrinsic has wrong type: \\\n-                      expected `{}`\",\n-                     ppaux::ty_to_str(ccx.tcx, fty)));\n+        require_same_types(tcx,\n+                           None,\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format_strbuf!(\"intrinsic has wrong type: expected `{}`\",\n+                               ppaux::ty_to_str(ccx.tcx, fty))\n+            });\n     }\n }"}, {"sha": "f93eb4550a94adf2c7bcb9e95899af61dd4140a8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -421,7 +421,9 @@ impl<'a> CoherenceChecker<'a> {\n                             let crate_store = &self.crate_context.tcx.sess.cstore;\n                             let cdata = crate_store.get_crate_data(impl_b.krate);\n                             session.note(\n-                                \"conflicting implementation in crate `\" + cdata.name + \"`\");\n+                                format!(\"conflicting implementation in crate \\\n+                                         `{}`\",\n+                                        cdata.name));\n                         }\n                     }\n                 }"}, {"sha": "c70204098e0a749e7f91cd84b366217fc608dd05", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -438,8 +438,10 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     }\n     if sized == ast::StaticSize {\n         match tcx.lang_items.require(SizedTraitLangItem) {\n-            Ok(def_id) => { ty::try_add_builtin_trait(tcx, def_id, &mut bounds); },\n-            Err(s) => tcx.sess.err(s),\n+            Ok(def_id) => {\n+                ty::try_add_builtin_trait(tcx, def_id, &mut bounds);\n+            }\n+            Err(s) => tcx.sess.err(s.as_slice()),\n         };\n     }\n "}, {"sha": "84df7230544e6568566a78cb06db91ff59ad1a9b", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -71,7 +71,7 @@ use syntax::abi;\n \n pub trait Combine {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n-    fn tag(&self) -> ~str;\n+    fn tag(&self) -> StrBuf;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n "}, {"sha": "6f99a0a5ffb2b7a4d53e6f47f3972cf84e665555", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -103,12 +103,12 @@ pub trait ErrorReporting {\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<~str>;\n+    fn values_str(&self, values: &ValuePairs) -> Option<StrBuf>;\n \n     fn expected_found_str<T:UserString+Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n-        -> Option<~str>;\n+        -> Option<StrBuf>;\n \n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin,\n@@ -365,7 +365,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<~str> {\n+    fn values_str(&self, values: &ValuePairs) -> Option<StrBuf> {\n         /*!\n          * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n@@ -383,7 +383,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n     fn expected_found_str<T:UserString+Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n-        -> Option<~str>\n+        -> Option<StrBuf>\n     {\n         let expected = exp_found.expected.resolve(self);\n         if expected.contains_error() {\n@@ -395,9 +395,9 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             return None;\n         }\n \n-        Some(format!(\"expected `{}` but found `{}`\",\n-                  expected.user_string(self.tcx),\n-                  found.user_string(self.tcx)))\n+        Some(format_strbuf!(\"expected `{}` but found `{}`\",\n+                            expected.user_string(self.tcx),\n+                            found.user_string(self.tcx)))\n     }\n \n     fn report_concrete_failure(&self,\n@@ -1449,7 +1449,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n \n // LifeGiver is responsible for generating fresh lifetime names\n struct LifeGiver {\n-    taken: HashSet<~str>,\n+    taken: HashSet<StrBuf>,\n     counter: Cell<uint>,\n     generated: RefCell<Vec<ast::Lifetime>>,\n }\n@@ -1458,7 +1458,7 @@ impl LifeGiver {\n     fn with_taken(taken: &[ast::Lifetime]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken.iter() {\n-            let lt_name = token::get_name(lt.name).get().to_owned();\n+            let lt_name = token::get_name(lt.name).get().to_strbuf();\n             taken_.insert(lt_name);\n         }\n         LifeGiver {\n@@ -1489,14 +1489,14 @@ impl LifeGiver {\n         return lifetime;\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_str(counter: uint) -> ~str {\n+        fn num_to_str(counter: uint) -> StrBuf {\n             let mut s = StrBuf::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n             for _ in range(0, n) {\n                 s.push_char(letter);\n             }\n-            s.into_owned()\n+            s\n         }\n     }\n "}, {"sha": "5ca5945a4f42f39460491e4e0997e65d685b11b5", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -36,7 +36,7 @@ impl<'f> Glb<'f> {\n \n impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { \"glb\".to_owned() }\n+    fn tag(&self) -> StrBuf { \"glb\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "174bdb4a82a3c447ed7460cef55b7a372628b975", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -35,7 +35,7 @@ impl<'f> Lub<'f> {\n \n impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { \"lub\".to_owned() }\n+    fn tag(&self) -> StrBuf { \"lub\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "53d1092ffd96c57db642f1948bd08e5ccd8d2980", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 122, "deletions": 70, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -246,15 +246,17 @@ pub enum fixup_err {\n     region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n \n-pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n+pub fn fixup_err_to_str(f: fixup_err) -> StrBuf {\n     match f {\n-      unresolved_int_ty(_) => \"unconstrained integral type\".to_owned(),\n-      unresolved_ty(_) => \"unconstrained type\".to_owned(),\n-      cyclic_ty(_) => \"cyclic type of infinite size\".to_owned(),\n-      unresolved_region(_) => \"unconstrained region\".to_owned(),\n+      unresolved_int_ty(_) => \"unconstrained integral type\".to_strbuf(),\n+      unresolved_ty(_) => \"unconstrained type\".to_strbuf(),\n+      cyclic_ty(_) => \"cyclic type of infinite size\".to_strbuf(),\n+      unresolved_region(_) => \"unconstrained region\".to_strbuf(),\n       region_var_bound_by_region_var(r1, r2) => {\n-        format!(\"region var {:?} bound by another region var {:?}; this is \\\n-              a bug in rustc\", r1, r2)\n+        format_strbuf!(\"region var {:?} bound by another region var {:?}; \\\n+                        this is a bug in rustc\",\n+                       r1,\n+                       r2)\n       }\n     }\n }\n@@ -649,17 +651,17 @@ impl<'a> InferCtxt<'a> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, t: ty::t) -> StrBuf {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(&self, ts: &[ty::t]) -> ~str {\n-        let tstrs: Vec<~str> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n-        format!(\"({})\", tstrs.connect(\", \"))\n+    pub fn tys_to_str(&self, ts: &[ty::t]) -> StrBuf {\n+        let tstrs: Vec<StrBuf> = ts.iter().map(|t| self.ty_to_str(*t)).collect();\n+        format_strbuf!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> ~str {\n+    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> StrBuf {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n@@ -712,19 +714,19 @@ impl<'a> InferCtxt<'a> {\n     // errors.\n     pub fn type_error_message_str(&self,\n                                   sp: Span,\n-                                  mk_msg: |Option<~str>, ~str| -> ~str,\n-                                  actual_ty: ~str,\n+                                  mk_msg: |Option<StrBuf>, StrBuf| -> StrBuf,\n+                                  actual_ty: StrBuf,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n     pub fn type_error_message_str_with_expected(&self,\n                                                 sp: Span,\n-                                                mk_msg: |Option<~str>,\n-                                                         ~str|\n-                                                         -> ~str,\n+                                                mk_msg: |Option<StrBuf>,\n+                                                         StrBuf|\n+                                                         -> StrBuf,\n                                                 expected_ty: Option<ty::t>,\n-                                                actual_ty: ~str,\n+                                                actual_ty: StrBuf,\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n@@ -751,7 +753,7 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: |~str| -> ~str,\n+                              mk_msg: |StrBuf| -> StrBuf,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n@@ -775,10 +777,12 @@ impl<'a> InferCtxt<'a> {\n             // Don't report an error if expected is ty_err\n             ty::ty_err => return,\n             _ => {\n-                // if I leave out : ~str, it infers &str and complains\n-                |actual: ~str| {\n-                    format!(\"mismatched types: expected `{}` but found `{}`\",\n-                         self.ty_to_str(resolved_expected), actual)\n+                // if I leave out : StrBuf, it infers &str and complains\n+                |actual: StrBuf| {\n+                    format_strbuf!(\"mismatched types: expected `{}` but \\\n+                                    found `{}`\",\n+                                   self.ty_to_str(resolved_expected),\n+                                   actual)\n                 }\n             }\n         };\n@@ -818,8 +822,8 @@ impl TypeTrace {\n }\n \n impl Repr for TypeTrace {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"TypeTrace({})\", self.origin.repr(tcx))\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        format_strbuf!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n \n@@ -838,15 +842,27 @@ impl TypeOrigin {\n }\n \n impl Repr for TypeOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n-            MethodCompatCheck(a) => format!(\"MethodCompatCheck({})\", a.repr(tcx)),\n-            ExprAssignable(a) => format!(\"ExprAssignable({})\", a.repr(tcx)),\n-            Misc(a) => format!(\"Misc({})\", a.repr(tcx)),\n-            RelateTraitRefs(a) => format!(\"RelateTraitRefs({})\", a.repr(tcx)),\n-            RelateSelfType(a) => format!(\"RelateSelfType({})\", a.repr(tcx)),\n-            MatchExpression(a) => format!(\"MatchExpression({})\", a.repr(tcx)),\n-            IfExpression(a) => format!(\"IfExpression({})\", a.repr(tcx)),\n+            MethodCompatCheck(a) => {\n+                format_strbuf!(\"MethodCompatCheck({})\", a.repr(tcx))\n+            }\n+            ExprAssignable(a) => {\n+                format_strbuf!(\"ExprAssignable({})\", a.repr(tcx))\n+            }\n+            Misc(a) => format_strbuf!(\"Misc({})\", a.repr(tcx)),\n+            RelateTraitRefs(a) => {\n+                format_strbuf!(\"RelateTraitRefs({})\", a.repr(tcx))\n+            }\n+            RelateSelfType(a) => {\n+                format_strbuf!(\"RelateSelfType({})\", a.repr(tcx))\n+            }\n+            MatchExpression(a) => {\n+                format_strbuf!(\"MatchExpression({})\", a.repr(tcx))\n+            }\n+            IfExpression(a) => {\n+                format_strbuf!(\"IfExpression({})\", a.repr(tcx))\n+            }\n         }\n     }\n }\n@@ -875,26 +891,44 @@ impl SubregionOrigin {\n }\n \n impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n-            Subtype(ref a) => format!(\"Subtype({})\", a.repr(tcx)),\n-            InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n-            InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n-            DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n-            FreeVariable(a, b) => format!(\"FreeVariable({}, {})\", a.repr(tcx), b),\n-            IndexSlice(a) => format!(\"IndexSlice({})\", a.repr(tcx)),\n-            RelateObjectBound(a) => format!(\"RelateObjectBound({})\", a.repr(tcx)),\n-            Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n-            ReborrowUpvar(a, b) => format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b),\n-            ReferenceOutlivesReferent(_, a) =>\n-                format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx)),\n-            BindingTypeIsNotValidAtDecl(a) =>\n-                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx)),\n-            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n-            CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n-            CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n-            AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n-            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n+            Subtype(ref a) => {\n+                format_strbuf!(\"Subtype({})\", a.repr(tcx))\n+            }\n+            InfStackClosure(a) => {\n+                format_strbuf!(\"InfStackClosure({})\", a.repr(tcx))\n+            }\n+            InvokeClosure(a) => {\n+                format_strbuf!(\"InvokeClosure({})\", a.repr(tcx))\n+            }\n+            DerefPointer(a) => {\n+                format_strbuf!(\"DerefPointer({})\", a.repr(tcx))\n+            }\n+            FreeVariable(a, b) => {\n+                format_strbuf!(\"FreeVariable({}, {})\", a.repr(tcx), b)\n+            }\n+            IndexSlice(a) => {\n+                format_strbuf!(\"IndexSlice({})\", a.repr(tcx))\n+            }\n+            RelateObjectBound(a) => {\n+                format_strbuf!(\"RelateObjectBound({})\", a.repr(tcx))\n+            }\n+            Reborrow(a) => format_strbuf!(\"Reborrow({})\", a.repr(tcx)),\n+            ReborrowUpvar(a, b) => {\n+                format_strbuf!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n+            }\n+            ReferenceOutlivesReferent(_, a) => {\n+                format_strbuf!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n+            }\n+            BindingTypeIsNotValidAtDecl(a) => {\n+                format_strbuf!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx))\n+            }\n+            CallRcvr(a) => format_strbuf!(\"CallRcvr({})\", a.repr(tcx)),\n+            CallArg(a) => format_strbuf!(\"CallArg({})\", a.repr(tcx)),\n+            CallReturn(a) => format_strbuf!(\"CallReturn({})\", a.repr(tcx)),\n+            AddrOf(a) => format_strbuf!(\"AddrOf({})\", a.repr(tcx)),\n+            AutoBorrow(a) => format_strbuf!(\"AutoBorrow({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -918,25 +952,43 @@ impl RegionVariableOrigin {\n }\n \n impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n-            MiscVariable(a) => format!(\"MiscVariable({})\", a.repr(tcx)),\n-            PatternRegion(a) => format!(\"PatternRegion({})\", a.repr(tcx)),\n-            AddrOfRegion(a) => format!(\"AddrOfRegion({})\", a.repr(tcx)),\n-            AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n-            Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            EarlyBoundRegion(a, b) => format!(\"EarlyBoundRegion({},{})\",\n-                                              a.repr(tcx), b.repr(tcx)),\n-            LateBoundRegion(a, b) => format!(\"LateBoundRegion({},{})\",\n-                                             a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInFnType(a, b) => format!(\"bound_regionInFnType({},{})\",\n-                                              a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInCoherence(a) => format!(\"bound_regionInCoherence({})\",\n-                                                 a.repr(tcx)),\n-            UpvarRegion(a, b) => format!(\"UpvarRegion({}, {})\",\n-                                         a.repr(tcx),\n-                                         b.repr(tcx)),\n+            MiscVariable(a) => {\n+                format_strbuf!(\"MiscVariable({})\", a.repr(tcx))\n+            }\n+            PatternRegion(a) => {\n+                format_strbuf!(\"PatternRegion({})\", a.repr(tcx))\n+            }\n+            AddrOfRegion(a) => {\n+                format_strbuf!(\"AddrOfRegion({})\", a.repr(tcx))\n+            }\n+            AddrOfSlice(a) => format_strbuf!(\"AddrOfSlice({})\", a.repr(tcx)),\n+            Autoref(a) => format_strbuf!(\"Autoref({})\", a.repr(tcx)),\n+            Coercion(ref a) => format_strbuf!(\"Coercion({})\", a.repr(tcx)),\n+            EarlyBoundRegion(a, b) => {\n+                format_strbuf!(\"EarlyBoundRegion({},{})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            LateBoundRegion(a, b) => {\n+                format_strbuf!(\"LateBoundRegion({},{})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            BoundRegionInFnType(a, b) => {\n+                format_strbuf!(\"bound_regionInFnType({},{})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            BoundRegionInCoherence(a) => {\n+                format_strbuf!(\"bound_regionInCoherence({})\", a.repr(tcx))\n+            }\n+            UpvarRegion(a, b) => {\n+                format_strbuf!(\"UpvarRegion({}, {})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n         }\n     }\n }"}, {"sha": "297a29211478bfc9ed9e1fc7bb18d5cd8549e64c", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1332,16 +1332,28 @@ impl<'a> RegionVarBindings<'a> {\n }\n \n impl Repr for Constraint {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n-            ConstrainVarSubVar(a, b) => format!(\"ConstrainVarSubVar({}, {})\",\n-                                             a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubVar(a, b) => format!(\"ConstrainRegSubVar({}, {})\",\n-                                             a.repr(tcx), b.repr(tcx)),\n-            ConstrainVarSubReg(a, b) => format!(\"ConstrainVarSubReg({}, {})\",\n-                                             a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubReg(a, b) => format!(\"ConstrainRegSubReg({}, {})\",\n-                                             a.repr(tcx), b.repr(tcx)),\n+            ConstrainVarSubVar(a, b) => {\n+                format_strbuf!(\"ConstrainVarSubVar({}, {})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            ConstrainRegSubVar(a, b) => {\n+                format_strbuf!(\"ConstrainRegSubVar({}, {})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            ConstrainVarSubReg(a, b) => {\n+                format_strbuf!(\"ConstrainVarSubReg({}, {})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n+            ConstrainRegSubReg(a, b) => {\n+                format_strbuf!(\"ConstrainRegSubReg({}, {})\",\n+                               a.repr(tcx),\n+                               b.repr(tcx))\n+            }\n         }\n     }\n }"}, {"sha": "437a43ed74cfffd1084a859b23b8158300666cdb", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -35,7 +35,7 @@ impl<'f> Sub<'f> {\n \n impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n-    fn tag(&self) -> ~str { \"sub\".to_owned() }\n+    fn tag(&self) -> StrBuf { \"sub\".to_strbuf() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n "}, {"sha": "3b2c72144865561e8aacaff63a1e1e50e162bee2", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -34,7 +34,7 @@ struct Env {\n     krate: @ast::Crate,\n     tcx: ty::ctxt,\n     infcx: infer::infer_ctxt,\n-    err_messages: @DVec<~str>\n+    err_messages: @DVec<StrBuf>\n }\n \n struct RH {\n@@ -93,7 +93,7 @@ impl Env {\n                             sub: &[]}]});\n     }\n \n-    pub fn lookup_item(&self, names: &[~str]) -> ast::node_id {\n+    pub fn lookup_item(&self, names: &[StrBuf]) -> ast::node_id {\n         return match search_mod(self, &self.krate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n@@ -104,7 +104,7 @@ impl Env {\n         fn search_mod(self: &Env,\n                       m: &ast::Mod,\n                       idx: uint,\n-                      names: &[~str]) -> Option<ast::node_id> {\n+                      names: &[StrBuf]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n             for item in m.items.iter() {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n@@ -117,7 +117,7 @@ impl Env {\n         fn search(self: &Env,\n                   it: @ast::Item,\n                   idx: uint,\n-                  names: &[~str]) -> Option<ast::node_id> {\n+                  names: &[StrBuf]) -> Option<ast::node_id> {\n             if idx == names.len() {\n                 return Some(it.id);\n             }\n@@ -174,7 +174,7 @@ impl Env {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_str(&self, a: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, a: ty::t) -> StrBuf {\n         ty_to_str(self.tcx, a)\n     }\n "}, {"sha": "30857f4c3831193272b7b4c5facc7b6021c00ba5", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -20,75 +20,80 @@ use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n use syntax::ast;\n \n pub trait InferStr {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str;\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf;\n }\n \n impl InferStr for ty::t {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n         ty_to_str(cx.tcx, *self)\n     }\n }\n \n impl InferStr for FnSig {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        format!(\"({}) -> {}\",\n-             self.inputs.iter().map(|a| a.inf_str(cx)).collect::<Vec<~str>>().connect(\", \"),\n-             self.output.inf_str(cx))\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+        format_strbuf!(\"({}) -> {}\",\n+                       self.inputs\n+                           .iter()\n+                           .map(|a| a.inf_str(cx))\n+                           .collect::<Vec<StrBuf>>().connect(\", \"),\n+                       self.output.inf_str(cx))\n     }\n }\n \n impl InferStr for ty::mt {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n         mt_to_str(cx.tcx, self)\n     }\n }\n \n impl InferStr for ty::Region {\n-    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl<V:InferStr> InferStr for Bound<V> {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n         match *self {\n-          Some(ref v) => v.inf_str(cx),\n-          None => \"none\".to_owned()\n+            Some(ref v) => v.inf_str(cx),\n+            None => \"none\".to_strbuf()\n         }\n     }\n }\n \n impl<T:InferStr> InferStr for Bounds<T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        format!(\"\\\\{{} <: {}\\\\}\",\n-             self.lb.inf_str(cx),\n-             self.ub.inf_str(cx))\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n+        format_strbuf!(\"\\\\{{} <: {}\\\\}\",\n+                       self.lb.inf_str(cx),\n+                       self.ub.inf_str(cx))\n     }\n }\n \n impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n         match *self {\n-          Redirect(ref vid) => format!(\"Redirect({})\", vid.to_str()),\n-          Root(ref pt, rk) => format!(\"Root({}, {})\", pt.inf_str(cx), rk)\n+          Redirect(ref vid) => format_strbuf!(\"Redirect({})\", vid.to_str()),\n+          Root(ref pt, rk) => {\n+              format_strbuf!(\"Root({}, {})\", pt.inf_str(cx), rk)\n+          }\n         }\n     }\n }\n \n impl InferStr for IntVarValue {\n-    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        self.to_str()\n+    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+        self.to_str().to_strbuf()\n     }\n }\n \n impl InferStr for ast::FloatTy {\n-    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        self.to_str()\n+    fn inf_str(&self, _cx: &InferCtxt) -> StrBuf {\n+        self.to_str().to_strbuf()\n     }\n }\n \n impl InferStr for ty::TraitRef {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n+    fn inf_str(&self, cx: &InferCtxt) -> StrBuf {\n         trait_ref_to_str(cx.tcx, self)\n     }\n }"}, {"sha": "165c573d056edc83f27532a9a5ff0826c6164397", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -198,18 +198,18 @@ pub enum vtable_origin {\n }\n \n impl Repr for vtable_origin {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({:?}:{}, {}, {})\",\n-                     def_id,\n-                     ty::item_path_str(tcx, def_id),\n-                     tys.repr(tcx),\n-                     vtable_res.repr(tcx))\n+                format_strbuf!(\"vtable_static({:?}:{}, {}, {})\",\n+                               def_id,\n+                               ty::item_path_str(tcx, def_id),\n+                               tys.repr(tcx),\n+                               vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                format!(\"vtable_param({:?}, {:?})\", x, y)\n+                format_strbuf!(\"vtable_param({:?}, {:?})\", x, y)\n             }\n         }\n     }\n@@ -230,10 +230,10 @@ pub struct impl_res {\n }\n \n impl Repr for impl_res {\n-    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n-        format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n-             self.trait_vtables.repr(tcx),\n-             self.self_vtables.repr(tcx))\n+    fn repr(&self, tcx: &ty::ctxt) -> StrBuf {\n+        format_strbuf!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n+                       self.trait_vtables.repr(tcx),\n+                       self.self_vtables.repr(tcx))\n     }\n }\n \n@@ -293,7 +293,7 @@ pub fn require_same_types(tcx: &ty::ctxt,\n                           span: Span,\n                           t1: ty::t,\n                           t2: ty::t,\n-                          msg: || -> ~str)\n+                          msg: || -> StrBuf)\n                           -> bool {\n     let result = match maybe_infcx {\n         None => {\n@@ -308,8 +308,10 @@ pub fn require_same_types(tcx: &ty::ctxt,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            tcx.sess.span_err(span, msg() + \": \" +\n-                              ty::type_err_to_str(tcx, terr));\n+            tcx.sess.span_err(span,\n+                              format!(\"{}: {}\",\n+                                      msg(),\n+                                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -350,8 +352,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n-                || format!(\"main function expects type: `{}`\",\n-                        ppaux::ty_to_str(ccx.tcx, se_ty)));\n+                || {\n+                    format_strbuf!(\"main function expects type: `{}`\",\n+                                   ppaux::ty_to_str(ccx.tcx, se_ty))\n+                });\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n@@ -399,7 +403,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n-                || format!(\"start function expects type: `{}`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n+                || {\n+                    format_strbuf!(\"start function expects type: `{}`\",\n+                                   ppaux::ty_to_str(ccx.tcx, se_ty))\n+                });\n \n         }\n         _ => {"}, {"sha": "f2f86485b199716b5cd3edf1229675e2e8499696", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -1001,7 +1001,7 @@ impl<'a> SolveContext<'a> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), found);\n+                tcx.sess.span_err(tcx.map.span(item_id), found.as_slice());\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "5060c5572cdbb54490f52d424ca868849a923744", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 319, "deletions": 268, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -34,12 +34,12 @@ use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n-    fn repr(&self, tcx: &ctxt) -> ~str;\n+    fn repr(&self, tcx: &ctxt) -> StrBuf;\n }\n \n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n-    fn user_string(&self, tcx: &ctxt) -> ~str;\n+    fn user_string(&self, tcx: &ctxt) -> StrBuf;\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -60,7 +60,7 @@ pub fn note_and_explain_region(cx: &ctxt,\n }\n \n pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n-                            -> (~str, Option<Span>) {\n+                            -> (StrBuf, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n         match cx.map.find(node_id) {\n@@ -86,156 +86,171 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {}.  Please report a bug.\", node_id),\n+            (format_strbuf!(\"unknown scope: {}.  Please report a bug.\",\n+                            node_id),\n              None)\n           }\n         }\n       }\n \n       ReFree(ref fr) => {\n         let prefix = match fr.bound_region {\n-          BrAnon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n-                               idx + 1),\n-          BrFresh(_) => format!(\"an anonymous lifetime defined on\"),\n-          _ => format!(\"the lifetime {} as defined on\",\n-                    bound_region_ptr_to_str(cx, fr.bound_region))\n+          BrAnon(idx) => {\n+              format_strbuf!(\"the anonymous lifetime \\\\#{} defined on\",\n+                             idx + 1)\n+          }\n+          BrFresh(_) => \"an anonymous lifetime defined on\".to_strbuf(),\n+          _ => {\n+              format_strbuf!(\"the lifetime {} as defined on\",\n+                             bound_region_ptr_to_str(cx, fr.bound_region))\n+          }\n         };\n \n         match cx.map.find(fr.scope_id) {\n           Some(ast_map::NodeBlock(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-            (format!(\"{} {}\", prefix, msg), opt_span)\n+            (format_strbuf!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(ast_map::NodeItem(it)) if match it.node {\n                 ast::ItemImpl(..) => true, _ => false} => {\n             let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n-            (format!(\"{} {}\", prefix, msg), opt_span)\n+            (format_strbuf!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"{} node {}\", prefix, fr.scope_id), None)\n+            (format_strbuf!(\"{} node {}\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n \n-      ReStatic => { (\"the static lifetime\".to_owned(), None) }\n+      ReStatic => { (\"the static lifetime\".to_strbuf(), None) }\n \n-      ReEmpty => { (\"the empty lifetime\".to_owned(), None) }\n+      ReEmpty => { (\"the empty lifetime\".to_strbuf(), None) }\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       ty::ReInfer(_) | ty::ReEarlyBound(..) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {:?}\", region), None)\n+        (format_strbuf!(\"lifetime {:?}\", region), None)\n       }\n     };\n \n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n-        -> (~str, Option<Span>) {\n+        -> (StrBuf, Option<Span>) {\n         let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading,\n-              lo.line, lo.col.to_uint()), Some(span))\n+        (format_strbuf!(\"the {} at {}:{}\",\n+                        heading,\n+                        lo.line,\n+                        lo.col.to_uint()), Some(span))\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> ~str {\n+pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> StrBuf {\n     bound_region_to_str(cx, \"&\", true, br)\n }\n \n pub fn bound_region_to_str(cx: &ctxt,\n                            prefix: &str, space: bool,\n-                           br: BoundRegion) -> ~str {\n+                           br: BoundRegion) -> StrBuf {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, br.repr(cx), space_str);\n+        return format_strbuf!(\"{}{}{}\", prefix, br.repr(cx), space_str)\n     }\n \n     match br {\n-        BrNamed(_, name)   => format!(\"{}'{}{}\", prefix,\n-                                      token::get_name(name), space_str),\n-        BrAnon(_)           => prefix.to_str(),\n-        BrFresh(_)          => prefix.to_str(),\n+        BrNamed(_, name) => {\n+            format_strbuf!(\"{}'{}{}\",\n+                           prefix,\n+                           token::get_name(name),\n+                           space_str)\n+        }\n+        BrAnon(_) => prefix.to_strbuf(),\n+        BrFresh(_) => prefix.to_strbuf(),\n     }\n }\n \n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> ~str {\n+pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> StrBuf {\n     region_to_str(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n+pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> StrBuf {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return format!(\"{}{}{}\", prefix, region.repr(cx), space_str);\n+        return format_strbuf!(\"{}{}{}\", prefix, region.repr(cx), space_str)\n     }\n \n     // These printouts are concise.  They do not contain all the information\n     // the user might want to diagnose an error, but there is basically no way\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        ty::ReScope(_) => prefix.to_str(),\n-        ty::ReEarlyBound(_, _, name) => token::get_name(name).get().to_str(),\n+        ty::ReScope(_) => prefix.to_strbuf(),\n+        ty::ReEarlyBound(_, _, name) => {\n+            token::get_name(name).get().to_strbuf()\n+        }\n         ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n         ty::ReInfer(ReSkolemized(_, br)) => {\n             bound_region_to_str(cx, prefix, space, br)\n         }\n-        ty::ReInfer(ReVar(_)) => prefix.to_str(),\n-        ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n-        ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str)\n+        ty::ReInfer(ReVar(_)) => prefix.to_strbuf(),\n+        ty::ReStatic => format_strbuf!(\"{}'static{}\", prefix, space_str),\n+        ty::ReEmpty => format_strbuf!(\"{}'<empty>{}\", prefix, space_str),\n     }\n }\n \n-pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n+pub fn mutability_to_str(m: ast::Mutability) -> StrBuf {\n     match m {\n-        ast::MutMutable => \"mut \".to_owned(),\n-        ast::MutImmutable => \"\".to_owned(),\n+        ast::MutMutable => \"mut \".to_strbuf(),\n+        ast::MutImmutable => \"\".to_strbuf(),\n     }\n }\n \n-pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n-    format!(\"{}{}\", mutability_to_str(m.mutbl), ty_to_str(cx, m.ty))\n+pub fn mt_to_str(cx: &ctxt, m: &mt) -> StrBuf {\n+    format_strbuf!(\"{}{}\", mutability_to_str(m.mutbl), ty_to_str(cx, m.ty))\n }\n \n-pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n+pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> StrBuf {\n     match s {\n-        ty::UniqTraitStore => \"Box \".to_owned(),\n+        ty::UniqTraitStore => \"Box \".to_strbuf(),\n         ty::RegionTraitStore(r, m) => {\n-            format!(\"{}{}\", region_ptr_to_str(cx, r), mutability_to_str(m))\n+            format_strbuf!(\"{}{}\",\n+                           region_ptr_to_str(cx, r),\n+                           mutability_to_str(m))\n         }\n     }\n }\n \n-pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n-    let tstrs = ts.iter().map(f).collect::<Vec<~str>>();\n-    format!(\"[{}]\", tstrs.connect(\", \"))\n+pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> StrBuf) -> StrBuf {\n+    let tstrs = ts.iter().map(f).collect::<Vec<StrBuf>>();\n+    format_strbuf!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> ~str {\n-    format!(\"fn{}{} -> {}\",\n-            typ.binder_id,\n-            typ.inputs.repr(cx),\n-            typ.output.repr(cx))\n+pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> StrBuf {\n+    format_strbuf!(\"fn{}{} -> {}\",\n+                   typ.binder_id,\n+                   typ.inputs.repr(cx),\n+                   typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> ~str {\n-    trait_ref.user_string(cx)\n+pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> StrBuf {\n+    trait_ref.user_string(cx).to_strbuf()\n }\n \n-pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n-    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> ~str {\n-        ty_to_str(cx, input)\n+pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n+    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> StrBuf {\n+        ty_to_str(cx, input).to_strbuf()\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n-                      -> ~str {\n+                      -> StrBuf {\n         let mut s = StrBuf::new();\n         match fn_style {\n             ast::NormalFn => {}\n@@ -261,16 +276,16 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n \n         push_sig_to_str(cx, &mut s, '(', ')', sig);\n \n-        s.into_owned()\n+        s\n     }\n \n-    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n+    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> StrBuf {\n         let mut s = StrBuf::new();\n \n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_str(cx, \"\", true, region));\n+                s.push_str(region_to_str(cx, \"\", true, region).as_slice());\n             }\n         }\n \n@@ -299,10 +314,10 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n \n         if !cty.bounds.is_empty() {\n             s.push_str(\":\");\n-            s.push_str(cty.bounds.repr(cx));\n+            s.push_str(cty.bounds.repr(cx).as_slice());\n         }\n \n-        s.into_owned()\n+        s\n     }\n \n     fn push_sig_to_str(cx: &ctxt,\n@@ -311,7 +326,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n                        ket: char,\n                        sig: &ty::FnSig) {\n         s.push_char(bra);\n-        let strs: Vec<~str> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n+        let strs: Vec<StrBuf> = sig.inputs.iter().map(|a| fn_input_to_str(cx, *a)).collect();\n         s.push_str(strs.connect(\", \"));\n         if sig.variadic {\n             s.push_str(\", ...\");\n@@ -323,7 +338,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             if ty::type_is_bot(sig.output) {\n                 s.push_char('!');\n             } else {\n-                s.push_str(ty_to_str(cx, sig.output));\n+                s.push_str(ty_to_str(cx, sig.output).as_slice());\n             }\n         }\n     }\n@@ -336,49 +351,57 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n \n     // pretty print the structural type representation:\n     return match ty::get(typ).sty {\n-      ty_nil => \"()\".to_owned(),\n-      ty_bot => \"!\".to_owned(),\n-      ty_bool => \"bool\".to_owned(),\n-      ty_char => \"char\".to_owned(),\n-      ty_int(t) => ast_util::int_ty_to_str(t, None).to_owned(),\n-      ty_uint(t) => ast_util::uint_ty_to_str(t, None).to_owned(),\n-      ty_float(t) => ast_util::float_ty_to_str(t).to_owned(),\n-      ty_box(typ) => \"@\".to_owned() + ty_to_str(cx, typ),\n-      ty_uniq(typ) => \"~\".to_owned() + ty_to_str(cx, typ),\n-      ty_ptr(ref tm) => \"*\".to_owned() + mt_to_str(cx, tm),\n+      ty_nil => \"()\".to_strbuf(),\n+      ty_bot => \"!\".to_strbuf(),\n+      ty_bool => \"bool\".to_strbuf(),\n+      ty_char => \"char\".to_strbuf(),\n+      ty_int(t) => ast_util::int_ty_to_str(t, None),\n+      ty_uint(t) => ast_util::uint_ty_to_str(t, None),\n+      ty_float(t) => ast_util::float_ty_to_str(t),\n+      ty_box(typ) => {\n+          (\"@\".to_owned() + ty_to_str(cx, typ).as_slice()).to_strbuf()\n+      }\n+      ty_uniq(typ) => {\n+          (\"~\".to_owned() + ty_to_str(cx, typ).as_slice()).to_strbuf()\n+      }\n+      ty_ptr(ref tm) => {\n+          (\"*\".to_owned() + mt_to_str(cx, tm).as_slice()).to_strbuf()\n+      }\n       ty_rptr(r, ref tm) => {\n-        region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n+          let mut buf = region_ptr_to_str(cx, r);\n+          buf.push_str(mt_to_str(cx, tm).as_slice());\n+          buf\n       }\n       ty_tup(ref elems) => {\n-        let strs: Vec<~str> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n-        \"(\".to_owned() + strs.connect(\",\") + \")\"\n+        let strs: Vec<StrBuf> = elems.iter().map(|elem| ty_to_str(cx, *elem)).collect();\n+        (\"(\".to_owned() + strs.connect(\",\") + \")\").to_strbuf()\n       }\n       ty_closure(ref f) => {\n           closure_to_str(cx, *f)\n       }\n       ty_bare_fn(ref f) => {\n           bare_fn_to_str(cx, f.fn_style, f.abi, None, &f.sig)\n       }\n-      ty_infer(infer_ty) => infer_ty.to_str(),\n-      ty_err => \"[type error]\".to_owned(),\n+      ty_infer(infer_ty) => infer_ty.to_str().to_strbuf(),\n+      ty_err => \"[type error]\".to_strbuf(),\n       ty_param(param_ty {idx: id, def_id: did}) => {\n           let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n-              Some(def) => token::get_ident(def.ident).get().to_str(),\n+              Some(def) => token::get_ident(def.ident).get().to_strbuf(),\n               // This can only happen when a type mismatch error happens and\n               // the actual type has more type parameters than the expected one.\n-              None => format!(\"<generic \\\\#{}>\", id)\n+              None => format_strbuf!(\"<generic \\\\#{}>\", id)\n           };\n           if !cx.sess.verbose() {\n               ident\n           } else {\n-            format!(\"{}:{:?}\", ident, did)\n+              format_strbuf!(\"{}:{:?}\", ident, did)\n           }\n       }\n-      ty_self(..) => \"Self\".to_owned(),\n+      ty_self(..) => \"Self\".to_strbuf(),\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let base = ty::item_path_str(cx, did);\n         parameterized(cx,\n-                      base,\n+                      base.as_slice(),\n                       &substs.regions,\n                       substs.tps.as_slice(),\n                       did,\n@@ -388,17 +411,23 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n           def_id: did, ref substs, store, ref bounds\n       }) => {\n         let base = ty::item_path_str(cx, did);\n-        let ty = parameterized(cx, base, &substs.regions,\n+        let ty = parameterized(cx, base.as_slice(), &substs.regions,\n                                substs.tps.as_slice(), did, true);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n-        format!(\"{}{}{}{}\", trait_store_to_str(cx, store), ty, bound_sep, bound_str)\n+        format_strbuf!(\"{}{}{}{}\",\n+                       trait_store_to_str(cx, store),\n+                       ty,\n+                       bound_sep,\n+                       bound_str)\n       }\n-      ty_str => \"str\".to_owned(),\n+      ty_str => \"str\".to_strbuf(),\n       ty_vec(ref mt, sz) => {\n           match sz {\n-              Some(n) => format!(\"[{}, .. {}]\", mt_to_str(cx, mt), n),\n-              None => format!(\"[{}]\", ty_to_str(cx, mt.ty)),\n+              Some(n) => {\n+                  format_strbuf!(\"[{}, .. {}]\", mt_to_str(cx, mt), n)\n+              }\n+              None => format_strbuf!(\"[{}]\", ty_to_str(cx, mt.ty)),\n           }\n       }\n     }\n@@ -409,8 +438,8 @@ pub fn parameterized(cx: &ctxt,\n                      regions: &ty::RegionSubsts,\n                      tps: &[ty::t],\n                      did: ast::DefId,\n-                     is_trait: bool) -> ~str {\n-\n+                     is_trait: bool)\n+                     -> StrBuf {\n     let mut strs = Vec::new();\n     match *regions {\n         ty::ErasedRegions => { }\n@@ -451,240 +480,246 @@ pub fn parameterized(cx: &ctxt,\n     }\n \n     if strs.len() > 0u {\n-        format!(\"{}<{}>\", base, strs.connect(\",\"))\n+        format_strbuf!(\"{}<{}>\", base, strs.connect(\",\"))\n     } else {\n-        format!(\"{}\", base)\n+        format_strbuf!(\"{}\", base)\n     }\n }\n \n-pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n-    let mut s = typ.repr(cx);\n-    if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n+pub fn ty_to_short_str(cx: &ctxt, typ: t) -> StrBuf {\n+    let mut s = typ.repr(cx).to_strbuf();\n+    if s.len() >= 32u {\n+        s = s.as_slice().slice(0u, 32u).to_strbuf();\n+    }\n     return s;\n }\n \n impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match self {\n-            &None => \"None\".to_owned(),\n+            &None => \"None\".to_strbuf(),\n             &Some(ref t) => t.repr(tcx),\n         }\n     }\n }\n \n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n-            &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n+            &Err(ref u) => format_strbuf!(\"Err({})\", u.repr(tcx))\n         }\n     }\n }\n \n impl Repr for () {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        \"()\".to_owned()\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        \"()\".to_strbuf()\n     }\n }\n \n impl<T:Repr> Repr for Rc<T> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for @T {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for Box<T> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> ~str {\n+fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> StrBuf {\n     vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'a, T:Repr> Repr for &'a [T] {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         repr_vec(tcx, *self)\n     }\n }\n \n impl<T:Repr> Repr for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"TypeParameterDef({:?}, {})\",\n-                self.def_id,\n-                self.bounds.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"TypeParameterDef({:?}, {})\",\n+                       self.def_id,\n+                       self.bounds.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"RegionParameterDef({}, {:?})\",\n-                token::get_name(self.name),\n-                self.def_id)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"RegionParameterDef({}, {:?})\",\n+                       token::get_name(self.name),\n+                       self.def_id)\n     }\n }\n \n impl Repr for ty::t {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::substs {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"substs(regions={}, self_ty={}, tps={})\",\n-             self.regions.repr(tcx),\n-             self.self_ty.repr(tcx),\n-             self.tps.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"substs(regions={}, self_ty={}, tps={})\",\n+                       self.regions.repr(tcx),\n+                       self.self_ty.repr(tcx),\n+                       self.tps.repr(tcx))\n     }\n }\n \n impl Repr for ty::ItemSubsts {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"ItemSubsts({})\", self.substs.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionSubsts {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match *self {\n-            ty::ErasedRegions => \"erased\".to_owned(),\n+            ty::ErasedRegions => \"erased\".to_strbuf(),\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n         }\n     }\n }\n \n impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n-                ty::BoundStatic => \"'static\".to_owned(),\n-                ty::BoundSend => \"Send\".to_owned(),\n-                ty::BoundSized => \"Sized\".to_owned(),\n-                ty::BoundCopy => \"Copy\".to_owned(),\n-                ty::BoundShare => \"Share\".to_owned(),\n+                ty::BoundStatic => \"'static\".to_strbuf(),\n+                ty::BoundSend => \"Send\".to_strbuf(),\n+                ty::BoundSized => \"Sized\".to_strbuf(),\n+                ty::BoundCopy => \"Copy\".to_strbuf(),\n+                ty::BoundShare => \"Share\".to_strbuf(),\n             });\n         }\n         for t in self.trait_bounds.iter() {\n             res.push(t.repr(tcx));\n         }\n-        res.connect(\"+\")\n+        res.connect(\"+\").to_strbuf()\n     }\n }\n \n impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         trait_ref_to_str(tcx, self)\n     }\n }\n \n impl Repr for ast::Expr {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n     }\n }\n \n impl Repr for ast::Item {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"item({})\", tcx.map.node_to_str(self.id))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"item({})\", tcx.map.node_to_str(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"stmt({}: {})\",\n-                ast_util::stmt_id(self),\n-                pprust::stmt_to_str(self))\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"stmt({}: {})\",\n+                       ast_util::stmt_id(self),\n+                       pprust::stmt_to_str(self))\n     }\n }\n \n impl Repr for ast::Pat {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"pat({}: {})\",\n-             self.id,\n-             pprust::pat_to_str(self))\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"pat({}: {})\", self.id, pprust::pat_to_str(self))\n     }\n }\n \n impl Repr for ty::BoundRegion {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match *self {\n-            ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n-            ty::BrNamed(id, name) => format!(\"BrNamed({}, {})\",\n-                                             id.repr(tcx),\n-                                             token::get_name(name)),\n-            ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n+            ty::BrAnon(id) => format_strbuf!(\"BrAnon({})\", id),\n+            ty::BrNamed(id, name) => {\n+                format_strbuf!(\"BrNamed({}, {})\",\n+                               id.repr(tcx),\n+                               token::get_name(name))\n+            }\n+            ty::BrFresh(id) => format_strbuf!(\"BrFresh({})\", id),\n         }\n     }\n }\n \n impl Repr for ty::Region {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match *self {\n             ty::ReEarlyBound(id, index, name) => {\n-                format!(\"ReEarlyBound({}, {}, {})\",\n-                        id, index, token::get_name(name))\n+                format_strbuf!(\"ReEarlyBound({}, {}, {})\",\n+                               id,\n+                               index,\n+                               token::get_name(name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n-                format!(\"ReLateBound({}, {})\",\n-                        binder_id, bound_region.repr(tcx))\n+                format_strbuf!(\"ReLateBound({}, {})\",\n+                               binder_id,\n+                               bound_region.repr(tcx))\n             }\n \n             ty::ReFree(ref fr) => {\n-                format!(\"ReFree({}, {})\",\n-                        fr.scope_id,\n-                        fr.bound_region.repr(tcx))\n+                format_strbuf!(\"ReFree({}, {})\",\n+                               fr.scope_id,\n+                               fr.bound_region.repr(tcx))\n             }\n \n             ty::ReScope(id) => {\n-                format!(\"ReScope({})\", id)\n+                format_strbuf!(\"ReScope({})\", id)\n             }\n \n             ty::ReStatic => {\n-                format!(\"ReStatic\")\n+                \"ReStatic\".to_strbuf()\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"ReInfer({})\", vid.id)\n+                format_strbuf!(\"ReInfer({})\", vid.id)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n-                format!(\"re_skolemized({}, {})\",\n-                        id, bound_region.repr(tcx))\n+                format_strbuf!(\"re_skolemized({}, {})\",\n+                               id,\n+                               bound_region.repr(tcx))\n             }\n \n             ty::ReEmpty => {\n-                format!(\"ReEmpty\")\n+                \"ReEmpty\".to_strbuf()\n             }\n         }\n     }\n }\n \n impl Repr for ast::DefId {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n@@ -697,115 +732,119 @@ impl Repr for ast::DefId {\n                     Some(ast_map::NodeTraitMethod(..)) |\n                     Some(ast_map::NodeVariant(..)) |\n                     Some(ast_map::NodeStructCtor(..)) => {\n-                        return format!(\"{:?}:{}\",\n-                                       *self,\n-                                       ty::item_path_str(tcx, *self));\n+                        return format_strbuf!(\n+                                \"{:?}:{}\",\n+                                *self,\n+                                ty::item_path_str(tcx, *self))\n                     }\n                     _ => {}\n                 }\n             }\n         }\n-        return format!(\"{:?}\", *self);\n+        return format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n-             self.generics.repr(tcx),\n-             self.ty.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n+                       self.generics.repr(tcx),\n+                       self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n-                self.type_param_defs().repr(tcx),\n-                self.region_param_defs().repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"Generics(type_param_defs: {}, \\\n+                           region_param_defs: {})\",\n+                 self.type_param_defs().repr(tcx),\n+                 self.region_param_defs().repr(tcx))\n     }\n }\n \n impl Repr for ty::ItemVariances {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n-                self.self_param.repr(tcx),\n-                self.type_params.repr(tcx),\n-                self.region_params.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"IterVariances(self_param={}, \\\n+                                type_params={}, \\\n+                                region_params={})\",\n+                 self.self_param.repr(tcx),\n+                 self.type_params.repr(tcx),\n+                 self.region_params.repr(tcx))\n     }\n }\n \n impl Repr for ty::Variance {\n-    fn repr(&self, _: &ctxt) -> ~str {\n-        self.to_str().to_owned()\n+    fn repr(&self, _: &ctxt) -> StrBuf {\n+        self.to_str().to_strbuf()\n     }\n }\n \n impl Repr for ty::Method {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"method(ident: {}, generics: {}, fty: {}, \\\n-                explicit_self: {}, vis: {}, def_id: {})\",\n-                self.ident.repr(tcx),\n-                self.generics.repr(tcx),\n-                self.fty.repr(tcx),\n-                self.explicit_self.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"method(ident: {}, generics: {}, fty: {}, \\\n+                        explicit_self: {}, vis: {}, def_id: {})\",\n+                       self.ident.repr(tcx),\n+                       self.generics.repr(tcx),\n+                       self.fty.repr(tcx),\n+                       self.explicit_self.repr(tcx),\n+                       self.vis.repr(tcx),\n+                       self.def_id.repr(tcx))\n     }\n }\n \n impl Repr for ast::Name {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        token::get_name(*self).get().to_str()\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        token::get_name(*self).get().to_strbuf()\n     }\n }\n \n impl Repr for ast::Ident {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        token::get_ident(*self).get().to_str()\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        token::get_ident(*self).get().to_strbuf()\n     }\n }\n \n impl Repr for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"BareFnTy \\\\{fn_style: {:?}, abi: {}, sig: {}\\\\}\",\n-             self.fn_style,\n-             self.abi.to_str(),\n-             self.sig.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"BareFnTy \\\\{fn_style: {:?}, abi: {}, sig: {}\\\\}\",\n+                       self.fn_style,\n+                       self.abi.to_str(),\n+                       self.sig.repr(tcx))\n     }\n }\n \n impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         fn_sig_to_str(tcx, self)\n     }\n }\n \n impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n-            self.origin.repr(tcx),\n-            self.ty.repr(tcx),\n-            self.substs.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n+                       self.origin.repr(tcx),\n+                       self.ty.repr(tcx),\n+                       self.substs.repr(tcx))\n     }\n }\n \n impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n-                format!(\"MethodStatic({})\", def_id.repr(tcx))\n+                format_strbuf!(\"MethodStatic({})\", def_id.repr(tcx))\n             }\n             &typeck::MethodParam(ref p) => {\n                 p.repr(tcx)\n@@ -818,144 +857,156 @@ impl Repr for typeck::MethodOrigin {\n }\n \n impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"MethodParam({},{:?},{:?},{:?})\",\n-             self.trait_id.repr(tcx),\n-             self.method_num,\n-             self.param_num,\n-             self.bound_num)\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"MethodParam({},{:?},{:?},{:?})\",\n+                       self.trait_id.repr(tcx),\n+                       self.method_num,\n+                       self.param_num,\n+                       self.bound_num)\n     }\n }\n \n impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"MethodObject({},{:?},{:?})\",\n-             self.trait_id.repr(tcx),\n-             self.method_num,\n-             self.real_index)\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"MethodObject({},{:?},{:?})\",\n+                       self.trait_id.repr(tcx),\n+                       self.method_num,\n+                       self.real_index)\n     }\n }\n \n \n impl Repr for ty::RegionVid {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::TraitStore {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         trait_store_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::BuiltinBound {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl UserString for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: &ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n         match *self {\n-            ty::BoundStatic => \"'static\".to_owned(),\n-            ty::BoundSend => \"Send\".to_owned(),\n-            ty::BoundSized => \"Sized\".to_owned(),\n-            ty::BoundCopy => \"Copy\".to_owned(),\n-            ty::BoundShare => \"Share\".to_owned(),\n+            ty::BoundStatic => \"'static\".to_strbuf(),\n+            ty::BoundSend => \"Send\".to_strbuf(),\n+            ty::BoundSized => \"Sized\".to_strbuf(),\n+            ty::BoundCopy => \"Copy\".to_strbuf(),\n+            ty::BoundShare => \"Share\".to_strbuf(),\n         }\n     }\n }\n \n impl Repr for ty::BuiltinBounds {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n         self.user_string(tcx)\n     }\n }\n \n impl Repr for Span {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        tcx.sess.codemap().span_to_str(*self).to_owned()\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        tcx.sess.codemap().span_to_str(*self).to_strbuf()\n     }\n }\n \n impl<A:UserString> UserString for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n impl UserString for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: &ctxt) -> ~str {\n-        self.iter().map(|bb| bb.user_string(tcx)).collect::<Vec<~str>>().connect(\"+\")\n+    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n+        self.iter()\n+            .map(|bb| bb.user_string(tcx))\n+            .collect::<Vec<StrBuf>>()\n+            .connect(\"+\")\n+            .to_strbuf()\n     }\n }\n \n impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: &ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n         let base = ty::item_path_str(tcx, self.def_id);\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n             for &t in self.substs.self_ty.iter() { all_tps.push(t); }\n-            parameterized(tcx, base, &self.substs.regions,\n-                          all_tps.as_slice(), self.def_id, true)\n+            parameterized(tcx,\n+                          base.as_slice(),\n+                          &self.substs.regions,\n+                          all_tps.as_slice(),\n+                          self.def_id,\n+                          true)\n         } else {\n-            parameterized(tcx, base, &self.substs.regions,\n-                          self.substs.tps.as_slice(), self.def_id, true)\n+            parameterized(tcx,\n+                          base.as_slice(),\n+                          &self.substs.regions,\n+                          self.substs.tps.as_slice(),\n+                          self.def_id,\n+                          true)\n         }\n     }\n }\n \n impl UserString for ty::t {\n-    fn user_string(&self, tcx: &ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> StrBuf {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl UserString for ast::Ident {\n-    fn user_string(&self, _tcx: &ctxt) -> ~str {\n-        token::get_name(self.name).get().to_owned()\n+    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n+        token::get_name(self.name).get().to_strbuf()\n     }\n }\n \n impl Repr for abi::Abi {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        self.to_str()\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        self.to_str().to_strbuf()\n     }\n }\n \n impl UserString for abi::Abi {\n-    fn user_string(&self, _tcx: &ctxt) -> ~str {\n-        self.to_str()\n+    fn user_string(&self, _tcx: &ctxt) -> StrBuf {\n+        self.to_str().to_strbuf()\n     }\n }\n \n impl Repr for ty::UpvarId {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"UpvarId({};`{}`;{})\",\n-             self.var_id,\n-             ty::local_var_name_str(tcx, self.var_id),\n-             self.closure_expr_id)\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"UpvarId({};`{}`;{})\",\n+                       self.var_id,\n+                       ty::local_var_name_str(tcx, self.var_id),\n+                       self.closure_expr_id)\n     }\n }\n \n impl Repr for ast::Mutability {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n-    fn repr(&self, _tcx: &ctxt) -> ~str {\n-        format!(\"{:?}\", *self)\n+    fn repr(&self, _tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::UpvarBorrow {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"UpvarBorrow({}, {})\",\n-             self.kind.repr(tcx),\n-             self.region.repr(tcx))\n+    fn repr(&self, tcx: &ctxt) -> StrBuf {\n+        format_strbuf!(\"UpvarBorrow({}, {})\",\n+                       self.kind.repr(tcx),\n+                       self.region.repr(tcx))\n     }\n }"}, {"sha": "a71ae83e73626a449ffdecaee84ca500ec3fd4b8", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -257,9 +257,9 @@ pub trait Digest {\n     }\n \n     /// Convenience function that retrieves the result of a digest as a\n-    /// ~str in hexadecimal format.\n-    fn result_str(&mut self) -> ~str {\n-        self.result_bytes().as_slice().to_hex()\n+    /// StrBuf in hexadecimal format.\n+    fn result_str(&mut self) -> StrBuf {\n+        self.result_bytes().as_slice().to_hex().to_strbuf()\n     }\n }\n \n@@ -543,15 +543,15 @@ mod tests {\n     }\n \n     struct Test {\n-        input: ~str,\n-        output_str: ~str,\n+        input: StrBuf,\n+        output_str: StrBuf,\n     }\n \n     fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n         // Test that it works when accepting the message all at once\n         for t in tests.iter() {\n             sh.reset();\n-            sh.input_str(t.input);\n+            sh.input_str(t.input.as_slice());\n             let out_str = sh.result_str();\n             assert!(out_str == t.output_str);\n         }\n@@ -563,7 +563,9 @@ mod tests {\n             let mut left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n+                sh.input_str(t.input\n+                              .as_slice()\n+                              .slice(len - left, take + len - left));\n                 left = left - take;\n             }\n             let out_str = sh.result_str();\n@@ -576,19 +578,21 @@ mod tests {\n         // Examples from wikipedia\n         let wikipedia_tests = vec!(\n             Test {\n-                input: \"\".to_owned(),\n+                input: \"\".to_strbuf(),\n                 output_str: \"e3b0c44298fc1c149afb\\\n-            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_owned()\n+            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_strbuf()\n             },\n             Test {\n-                input: \"The quick brown fox jumps over the lazy dog\".to_owned(),\n+                input: \"The quick brown fox jumps over the lazy \\\n+                        dog\".to_strbuf(),\n                 output_str: \"d7a8fbb307d7809469ca\\\n-            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_owned()\n+            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_strbuf()\n             },\n             Test {\n-                input: \"The quick brown fox jumps over the lazy dog.\".to_owned(),\n+                input: \"The quick brown fox jumps over the lazy \\\n+                        dog.\".to_strbuf(),\n                 output_str: \"ef537f25c895bfa78252\\\n-            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_owned()\n+            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_strbuf()\n             });\n \n         let tests = wikipedia_tests;"}, {"sha": "bbc1047ed1ef5300424bed37de500d2819ab03e5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -90,7 +90,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                                                        self.attrs.as_slice(),\n                                                        cx.sess());\n         let id = link::find_crate_id(self.attrs.as_slice(),\n-                                     t_outputs.out_filestem);\n+                                     t_outputs.out_filestem.as_slice());\n         Crate {\n             name: id.name.to_owned(),\n             module: Some(self.module.clean()),"}, {"sha": "fe80bc6c4795796e7010492380259dbe30aa5582", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -100,7 +100,7 @@ pub fn run(input: &str,\n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n            no_run: bool, loose_feature_gating: bool) {\n     let test = maketest(test, cratename, loose_feature_gating);\n-    let input = driver::StrInput(test);\n+    let input = driver::StrInput(test.to_strbuf());\n \n     let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),"}, {"sha": "fecd68e049a6f315d77499d54bf648f42476a1ea", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -504,6 +504,7 @@ use slice::{Vector, ImmutableVector};\n use slice;\n use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n use str;\n+use strbuf::StrBuf;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -788,6 +789,11 @@ pub fn format(args: &Arguments) -> ~str {\n     unsafe { format_unsafe(args.fmt, args.args) }\n }\n \n+/// Temporary transitionary thing.\n+pub fn format_strbuf(args: &Arguments) -> StrBuf {\n+    unsafe { format_unsafe_strbuf(args.fmt, args.args) }\n+}\n+\n /// The unsafe version of the formatting function.\n ///\n /// This is currently an unsafe function because the types of all arguments\n@@ -815,6 +821,14 @@ pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     return str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned();\n }\n \n+/// Temporary transitionary thing.\n+pub unsafe fn format_unsafe_strbuf(fmt: &[rt::Piece], args: &[Argument])\n+                                   -> StrBuf {\n+    let mut output = MemWriter::new();\n+    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n+    return str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf();\n+}\n+\n impl<'a> Formatter<'a> {\n \n     // First up is the collection of functions used to execute a format string"}, {"sha": "3a0e78b39d13dc3682f2663858c67e4477d598f2", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559a3675e021c9e8a416fc0d9ef416ddfda2f13/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=6559a3675e021c9e8a416fc0d9ef416ddfda2f13", "patch": "@@ -229,6 +229,14 @@ macro_rules! format(\n     )\n )\n \n+/// Temporary transitionary thing.\n+#[macro_export]\n+macro_rules! format_strbuf(\n+    ($($arg:tt)*) => (\n+        format_args!(::std::fmt::format_strbuf, $($arg)*)\n+    )\n+)\n+\n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n ///"}]}