{"sha": "7d3b0bf3912fabf52fdd6926900e578e55af1b49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkM2IwYmYzOTEyZmFiZjUyZmRkNjkyNjkwMGU1NzhlNTVhZjFiNDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-17T22:28:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-18T17:06:24Z"}, "message": "std: Make ~[T] no longer a growable vector\n\nThis removes all resizability support for ~[T] vectors in preparation of DST.\nThe only growable vector remaining is Vec<T>. In summary, the following methods\nfrom ~[T] and various functions were removed. Each method/function has an\nequivalent on the Vec type in std::vec unless otherwise stated.\n\n* slice::OwnedCloneableVector\n* slice::OwnedEqVector\n* slice::append\n* slice::append_one\n* slice::build (no replacement)\n* slice::bytes::push_bytes\n* slice::from_elem\n* slice::from_fn\n* slice::with_capacity\n* ~[T].capacity()\n* ~[T].clear()\n* ~[T].dedup()\n* ~[T].extend()\n* ~[T].grow()\n* ~[T].grow_fn()\n* ~[T].grow_set()\n* ~[T].insert()\n* ~[T].pop()\n* ~[T].push()\n* ~[T].push_all()\n* ~[T].push_all_move()\n* ~[T].remove()\n* ~[T].reserve()\n* ~[T].reserve_additional()\n* ~[T].reserve_exect()\n* ~[T].retain()\n* ~[T].set_len()\n* ~[T].shift()\n* ~[T].shrink_to_fit()\n* ~[T].swap_remove()\n* ~[T].truncate()\n* ~[T].unshift()\n* ~str.clear()\n* ~str.set_len()\n* ~str.truncate()\n\nNote that no other API changes were made. Existing apis that took or returned\n~[T] continue to do so.\n\n[breaking-change]", "tree": {"sha": "8405cde2a32e6a2499b9262b5dff6dcb34f36d32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8405cde2a32e6a2499b9262b5dff6dcb34f36d32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d3b0bf3912fabf52fdd6926900e578e55af1b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b0bf3912fabf52fdd6926900e578e55af1b49", "html_url": "https://github.com/rust-lang/rust/commit/7d3b0bf3912fabf52fdd6926900e578e55af1b49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b0bf3912fabf52fdd6926900e578e55af1b49/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce2bab68d69ee04e17c0165dbdb7b583d5a7c991", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2bab68d69ee04e17c0165dbdb7b583d5a7c991", "html_url": "https://github.com/rust-lang/rust/commit/ce2bab68d69ee04e17c0165dbdb7b583d5a7c991"}], "stats": {"total": 1341, "additions": 342, "deletions": 999}, "files": [{"sha": "c0f1aeae26b13a6893324215a55aadb66c096727", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -30,7 +30,6 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n use unstable::mutex::NativeMutex;\n-use slice::OwnedVector;\n \n use mpsc = sync::mpsc_queue;\n "}, {"sha": "44070dc44602003f76c9e451171c7ddf0cb6fb0f", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -30,7 +30,6 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use spsc = sync::spsc_queue;\n use sync::atomics;\n-use slice::OwnedVector;\n \n static DISCONNECTED: int = int::MIN;\n #[cfg(test)]"}, {"sha": "eee8e416231e5047a15a77ed060d021477f5b352", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -359,13 +359,8 @@ pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use io::Writer;\n-    use iter::Iterator;\n+    use prelude::*;\n     use num::ToStrRadix;\n-    use option::{Some, None};\n-    use str::Str;\n-    use strbuf::StrBuf;\n-    use slice::{Vector, ImmutableVector, OwnedVector};\n     use self::test::Bencher;\n \n     use super::super::Hash;\n@@ -454,7 +449,7 @@ mod tests {\n \n         let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n         let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf : ~[u8] = ~[];\n+        let mut buf = Vec::new();\n         let mut t = 0;\n         let mut state_inc = SipState::new_with_keys(k0, k1);\n         let mut state_full = SipState::new_with_keys(k0, k1);\n@@ -496,7 +491,7 @@ mod tests {\n             assert_eq!(vec, out);\n \n             state_full.reset();\n-            state_full.write(buf);\n+            state_full.write(buf.as_slice());\n             let f = result_str(state_full.result());\n             let i = result_str(state_inc.result());\n             let v = to_hex_str(&vecs[t]);"}, {"sha": "c541eb91d06bbdcfd02a6efbec9444f42eec0175", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -17,7 +17,7 @@ use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use slice::{OwnedVector, ImmutableVector, MutableVector};\n+use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;\n \n@@ -391,7 +391,7 @@ mod test {\n \n     /// A dummy reader intended at testing short-reads propagation.\n     pub struct ShortReader {\n-        lengths: ~[uint],\n+        lengths: Vec<uint>,\n     }\n \n     impl Reader for ShortReader {\n@@ -554,7 +554,7 @@ mod test {\n \n     #[test]\n     fn test_short_reads() {\n-        let inner = ShortReader{lengths: ~[0, 1, 2, 0, 1, 0]};\n+        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n         let mut reader = BufferedReader::new(inner);\n         let mut buf = [0, 0];\n         assert_eq!(reader.read(buf), Ok(0));"}, {"sha": "955d4c07d28b871906c8a7955f449eb5634a0402", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io;\n use io::{IoError, IoResult, Reader};\n-use slice::{OwnedVector, ImmutableVector, Vector};\n+use slice::{ImmutableVector, Vector};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -503,21 +503,22 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use self::test::Bencher;\n+\n     use container::Container;\n+    use prelude::*;\n+    use self::test::Bencher;\n \n     macro_rules! u64_from_be_bytes_bench_impl(\n         ($size:expr, $stride:expr, $start_index:expr) =>\n         ({\n-            use slice;\n             use super::u64_from_be_bytes;\n \n-            let data = slice::from_fn($stride*100+$start_index, |i| i as u8);\n+            let data = Vec::from_fn($stride*100+$start_index, |i| i as u8);\n             let mut sum = 0u64;\n             b.iter(|| {\n                 let mut i = $start_index;\n                 while i < data.len() {\n-                    sum += u64_from_be_bytes(data, i, $size);\n+                    sum += u64_from_be_bytes(data.as_slice(), i, $size);\n                     i += $stride;\n                 }\n             });"}, {"sha": "aa3820bcd1ffb84c3a97c5a675758304393be74e", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -17,7 +17,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n+use slice::{Vector, ImmutableVector, MutableVector};\n use vec::Vec;\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {"}, {"sha": "6864f18d26c567bd3bb94c8c9b25b7477707f193", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -228,11 +228,11 @@ use os;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n-use str::{StrSlice, OwnedStr};\n+use str::StrSlice;\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use slice::{Vector, OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n+use slice::{Vector, MutableVector, ImmutableVector};\n use vec::Vec;\n \n // Reexports"}, {"sha": "26ead9e1e5392a8dd3f41248b408b645f3b4db63", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -16,6 +16,7 @@ use fmt;\n use io::IoResult;\n use io;\n use libc;\n+use mem;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -416,12 +417,7 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        loop {\n-            match self.extra_io.pop() {\n-                Some(_) => (),\n-                None => break,\n-            }\n-        }\n+        drop(mem::replace(&mut self.extra_io, ~[]));\n \n         self.wait();\n     }"}, {"sha": "e7dae59acb8819c82eaea0877a7b21b55c984c5e", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -28,7 +28,7 @@ use mem::drop;\n use option::{Some, None};\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use vec::Vec;\n \n /// Signals that can be sent and received"}, {"sha": "78a66f1f7621caf9ebb4dcfde27973bf38191b6b", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -46,7 +46,7 @@ use kinds::Send;\n use mem::replace;\n use option::{None, Option, Some};\n use rt::task::{Task, LocalStorage};\n-use slice::{ImmutableVector, MutableVector, OwnedVector};\n+use slice::{ImmutableVector, MutableVector};\n use vec::Vec;\n \n /**"}, {"sha": "3228b5a1a490a34169898ed8d3cb3930046dd835", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -277,13 +277,13 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf: ~[u8] = ~[];\n+        let mut buf = Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf) }\n+        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n     }\n }\n "}, {"sha": "12befed743a52123fd6ef5f196fdbe2f1dfbf719", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -1779,12 +1779,11 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use num;\n-    use slice;\n     use prelude::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = slice::from_fn(1024, |n| n);\n+        let v = Vec::from_fn(1024, |n| n);\n         b.iter(|| {v.iter().fold(0, |old, new| num::pow(old, *new));});\n     }\n }"}, {"sha": "ffcb129d635724f7ef9b41e34c6de65383477670", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -10,19 +10,21 @@\n \n #![allow(missing_doc)]\n \n+use char;\n use clone::Clone;\n use container::Container;\n-use std::cmp::{Ord, Eq};\n+use iter::Iterator;\n+use num::{NumCast, Zero, One, cast, Int};\n+use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use char;\n+use slice::OwnedVector;\n+use slice::{CloneableVector, ImmutableVector, MutableVector};\n+use std::cmp::{Ord, Eq};\n use str::{StrSlice};\n use str;\n-use slice::{CloneableVector, ImmutableVector, MutableVector};\n-use slice::OwnedVector;\n-use num;\n-use num::{NumCast, Zero, One, cast, Int};\n-use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n+use vec::Vec;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -293,7 +295,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n     }\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    let mut buf: ~[u8] = ~[];\n+    let mut buf = Vec::new();\n     let radix_gen: T   = cast(radix as int).unwrap();\n \n     let (num, exp) = match exp_format {\n@@ -411,23 +413,23 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == '-' as u8\n-                    || buf[i as uint] == '+' as u8 {\n+                    || *buf.get(i as uint) == '-' as u8\n+                    || *buf.get(i as uint) == '+' as u8 {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n+                    if *buf.get(i as uint) == '.' as u8 { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(*buf.get(i as uint));\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        *buf.get_mut(i as uint) = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -444,25 +446,25 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+        while i > start_fractional_digits && *buf.get(i) == '0' as u8 {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if buf[i] == '.' as u8 { i -= 1 }\n+            if *buf.get(i) == '.' as u8 { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1).to_owned();\n+                buf = Vec::from_slice(buf.slice(0, i + 1));\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if buf[max_i] == '.' as u8 {\n-            buf = buf.slice(0, max_i).to_owned();\n+        if *buf.get(max_i) == '.' as u8 {\n+            buf = Vec::from_slice(buf.slice(0, max_i));\n         }\n     }\n \n@@ -481,7 +483,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         }\n     }\n \n-    (buf, false)\n+    (buf.move_iter().collect(), false)\n }\n \n /**"}, {"sha": "61723f339ae1438fc8af4e97b1d056b457713ea0", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -191,13 +191,13 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = ~[];\n+        let mut buf = Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf) }\n+        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n     }\n }\n "}, {"sha": "417bf31c13bacb5b350aad25eee2b4afe90afb28", "filename": "src/libstd/os.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -28,7 +28,6 @@\n \n #![allow(missing_doc)]\n \n-#[cfg(target_os = \"macos\")]\n #[cfg(windows)]\n use iter::range;\n \n@@ -49,6 +48,7 @@ use path::{Path, GenericPath};\n use iter::Iterator;\n use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n use ptr::RawPtr;\n+use vec::Vec;\n \n #[cfg(unix)]\n use c_str::ToCStr;\n@@ -203,7 +203,7 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n             result\n         }\n         #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> ~[~[u8]] {\n+        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n             use c_str::CString;\n \n             extern {\n@@ -214,16 +214,16 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             ptr::array_each(environ, |e| {\n                 let env_pair = CString::new(e, false).as_bytes_no_nul().to_owned();\n                 result.push(env_pair);\n             });\n             result\n         }\n \n-        fn env_convert(input: ~[~[u8]]) -> ~[(~[u8], ~[u8])] {\n-            let mut pairs = ~[];\n+        fn env_convert(input: Vec<~[u8]>) -> Vec<(~[u8], ~[u8])> {\n+            let mut pairs = Vec::new();\n             for p in input.iter() {\n                 let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n                 let key = vs[0].to_owned();\n@@ -234,7 +234,7 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n         }\n         with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n-            env_convert(unparsed_environ)\n+            env_convert(unparsed_environ).move_iter().collect()\n         })\n     }\n }\n@@ -457,15 +457,14 @@ pub fn self_exe_name() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n-            use slice;\n             let mut sz: u32 = 0;\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n-            let mut v: ~[u8] = slice::with_capacity(sz as uint);\n+            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n+            Some(v.move_iter().collect())\n         }\n     }\n \n@@ -795,11 +794,9 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n     use c_str::CString;\n \n-    let mut args = ~[];\n-    for i in range(0u, argc as uint) {\n-        args.push(CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned())\n-    }\n-    args\n+    Vec::from_fn(argc as uint, |i| {\n+        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned()\n+    }).move_iter().collect()\n }\n \n /**"}, {"sha": "2960d55f337c731ea73ab334193feba9bac2ccbe", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -74,7 +74,7 @@ use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n use strbuf::StrBuf;\n-use slice::{OwnedCloneableVector, OwnedVector, Vector};\n+use slice::Vector;\n use slice::{ImmutableEqVector, ImmutableVector};\n use vec::Vec;\n "}, {"sha": "47f9604d63fe10dc45f12b3070650b353068b688", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -21,7 +21,7 @@ use option::{Option, None, Some};\n use str;\n use str::Str;\n use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n-            ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n+            ImmutableEqVector, OwnedVector, ImmutableVector};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};"}, {"sha": "58c7aaa2d32aea474471c5cfb6e153220d543c11", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -21,7 +21,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n-use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n+use str::{CharSplits, Str, StrVector, StrSlice};\n use strbuf::StrBuf;\n use vec::Vec;\n "}, {"sha": "a44b23c42494eb7baf96bf89a9095e51b792022f", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -56,7 +56,7 @@ pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n-pub use slice::{OwnedVector, OwnedCloneableVector, OwnedEqVector};\n+pub use slice::{OwnedVector};\n pub use slice::{MutableVector, MutableTotalOrdVector};\n pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n pub use strbuf::StrBuf;"}, {"sha": "61461096ed9c48ee0a6462375fdc71f2860feb0d", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -170,10 +170,9 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n ///\n /// ```\n /// use std::ptr;\n-/// use std::slice;\n ///\n-/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n-///     let mut dst = slice::with_capacity(elts);\n+/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> Vec<T> {\n+///     let mut dst = Vec::with_capacity(elts);\n ///     dst.set_len(elts);\n ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n ///     dst"}, {"sha": "61238f508c177108bc4435f856d0dca37da3a01a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -28,7 +28,7 @@ use reflect::{MovePtr, align};\n use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n-use slice::{Vector, OwnedVector};\n+use slice::Vector;\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n use vec::Vec;"}, {"sha": "abe2e2ab1dcf51ce923bb3b4bbfbabfcfc7162c4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -125,13 +125,14 @@ mod imp {\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n         use c_str::CString;\n         use ptr::RawPtr;\n-        use {slice, libc};\n+        use libc;\n         use slice::CloneableVector;\n+        use vec::Vec;\n \n-        slice::from_fn(argc as uint, |i| {\n+        Vec::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n             cs.as_bytes_no_nul().to_owned()\n-        })\n+        }).move_iter().collect()\n     }\n \n     #[cfg(test)]"}, {"sha": "4210b2ec670ebd5420dcda5071d1424233f3dbb8", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 218, "deletions": 834, "changes": 1052, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -54,9 +54,9 @@ An example is the method `.push(element)` that will add an element at the end\n of the vector:\n \n ```rust\n-let mut numbers = ~[0, 1, 2];\n+let mut numbers = vec![0, 1, 2];\n numbers.push(7);\n-// numbers is now ~[0, 1, 2, 7];\n+// numbers is now vec![0, 1, 2, 7];\n  ```\n \n ## Implementations of other traits\n@@ -99,117 +99,31 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n-#![warn(non_camel_case_types)]\n-\n use cast;\n use cast::transmute;\n use ops::Drop;\n use clone::Clone;\n-use container::{Container, Mutable};\n+use container::Container;\n use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use fmt;\n use iter::*;\n-use num::{CheckedAdd, Saturating, checked_next_power_of_two, div_rem};\n+use num::{CheckedAdd, Saturating, div_rem};\n+use num::CheckedMul;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n+use rt::global_heap::{malloc_raw, exchange_free};\n use result::{Ok, Err};\n use mem;\n use mem::size_of;\n use kinds::marker;\n use uint;\n use unstable::finally::try_finally;\n-use raw::{Repr, Slice, Vec};\n-\n-/**\n- * Creates and initializes an owned vector.\n- *\n- * Creates an owned vector of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n-    unsafe {\n-        let mut v = with_capacity(n_elts);\n-        let p = v.as_mut_ptr();\n-        let mut i = 0;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| while *i < n_elts {\n-                mem::move_val_init(\n-                    &mut(*p.offset(*i as int)),\n-                    op(*i));\n-                *i += 1u;\n-            },\n-            |i| v.set_len(*i));\n-        v\n-    }\n-}\n-\n-/**\n- * Creates and initializes an owned vector.\n- *\n- * Creates an owned vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n-    // FIXME (#7136): manually inline from_fn for 2x plus speedup (sadly very\n-    // important, from_elem is a bottleneck in borrowck!). Unfortunately it\n-    // still is substantially slower than using the unsafe\n-    // slice::with_capacity/ptr::set_memory for primitive types.\n-    unsafe {\n-        let mut v = with_capacity(n_elts);\n-        let p = v.as_mut_ptr();\n-        let mut i = 0u;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| while *i < n_elts {\n-                mem::move_val_init(\n-                    &mut(*p.offset(*i as int)),\n-                    t.clone());\n-                *i += 1u;\n-            },\n-            |i| v.set_len(*i));\n-        v\n-    }\n-}\n-\n-/// Creates a new vector with a capacity of `capacity`\n-#[inline]\n-pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n-    unsafe {\n-        let alloc = capacity * mem::nonzero_size_of::<T>();\n-        let size = alloc + mem::size_of::<Vec<()>>();\n-        if alloc / mem::nonzero_size_of::<T>() != capacity || size < alloc {\n-            fail!(\"vector size is too large: {}\", capacity);\n-        }\n-        let ptr = malloc_raw(size) as *mut Vec<()>;\n-        (*ptr).alloc = alloc;\n-        (*ptr).fill = 0;\n-        transmute(ptr)\n-    }\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * The initial capacity for the vector may optionally be specified.\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n-    let mut vec = with_capacity(size.unwrap_or(4));\n-    builder(|x| vec.push(x));\n-    vec\n-}\n+use raw::{Repr, Slice};\n+use RawVec = raw::Vec;\n+use vec::Vec;\n \n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n@@ -326,26 +240,6 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n     }\n }\n \n-// Appending\n-\n-/// Iterates over the `rhs` vector, copying each element and appending it to the\n-/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline]\n-pub fn append<T:Clone>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n-    let mut v = lhs;\n-    v.push_all(rhs);\n-    v\n-}\n-\n-/// Appends one element to the vector provided. The vector itself is then\n-/// returned for use again.\n-#[inline]\n-pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n-    let mut v = lhs;\n-    v.push(x);\n-    v\n-}\n-\n // Functional utilities\n \n #[allow(missing_doc)]\n@@ -362,22 +256,22 @@ pub trait VectorVector<T> {\n impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n     fn concat_vec(&self) -> ~[T] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = with_capacity(size);\n+        let mut result = Vec::with_capacity(size);\n         for v in self.iter() {\n             result.push_all(v.as_slice())\n         }\n-        result\n+        result.move_iter().collect()\n     }\n \n     fn connect_vec(&self, sep: &T) -> ~[T] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = with_capacity(size + self.len());\n+        let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self.iter() {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n-        result\n+        result.move_iter().collect()\n     }\n }\n \n@@ -391,13 +285,13 @@ impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n  */\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n     let (lo, _) = iter.size_hint();\n-    let mut ts = with_capacity(lo);\n-    let mut us = with_capacity(lo);\n+    let mut ts = Vec::with_capacity(lo);\n+    let mut us = Vec::with_capacity(lo);\n     for (t, u) in iter {\n         ts.push(t);\n         us.push(u);\n     }\n-    (ts, us)\n+    (ts.move_iter().collect(), us.move_iter().collect())\n }\n \n /// An Iterator that yields the element swaps needed to produce\n@@ -618,8 +512,9 @@ pub mod traits {\n     use container::Container;\n     use clone::Clone;\n     use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n-    use iter::order;\n+    use iter::{order, Iterator};\n     use ops::Add;\n+    use vec::Vec;\n \n     impl<'a,T:Eq> Eq for &'a [T] {\n         fn eq(&self, other: & &'a [T]) -> bool {\n@@ -696,10 +591,10 @@ pub mod traits {\n     impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n-            let mut res = with_capacity(self.len() + rhs.as_slice().len());\n+            let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n             res.push_all(*self);\n             res.push_all(rhs.as_slice());\n-            res\n+            res.move_iter().collect()\n         }\n     }\n \n@@ -761,7 +656,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let len = self.len();\n-        let mut result = with_capacity(len);\n+        let mut result = Vec::with_capacity(len);\n         // Unsafe code so this can be optimised to a memcpy (or something\n         // similarly fast) when T is Copy. LLVM is easily confused, so any\n         // extra operations during the loop can prevent this optimisation\n@@ -780,7 +675,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                 },\n                 |i| result.set_len(*i));\n         }\n-        result\n+        result.move_iter().collect()\n     }\n \n     #[inline(always)]\n@@ -1215,8 +1110,8 @@ pub trait ImmutableCloneableVector<T> {\n impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n     #[inline]\n     fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = ~[];\n-        let mut rights = ~[];\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n         for elt in self.iter() {\n             if f(elt) {\n@@ -1226,7 +1121,7 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n             }\n         }\n \n-        (lefts, rights)\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n     }\n \n     fn permutations(self) -> Permutations<T> {\n@@ -1258,149 +1153,11 @@ pub trait OwnedVector<T> {\n     /// reverse order.\n     fn move_rev_iter(self) -> RevMoveItems<T>;\n \n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `self` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to reserve space for\n-     *\n-     * # Failure\n-     *\n-     * This method always succeeds in reserving space for `n` elements, or it does\n-     * not return.\n-     */\n-    fn reserve_exact(&mut self, n: uint);\n-    /**\n-     * Reserves capacity for at least `n` elements in the given vector.\n-     *\n-     * This function will over-allocate in order to amortize the allocation costs\n-     * in scenarios where the caller may need to repeatedly reserve additional\n-     * space.\n-     *\n-     * If the capacity for `self` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to reserve space for\n-     */\n-    fn reserve(&mut self, n: uint);\n-    /**\n-     * Reserves capacity for at least `n` additional elements in the given vector.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the new required capacity overflows uint.\n-     *\n-     * May also fail if `reserve` fails.\n-     */\n-    fn reserve_additional(&mut self, n: uint);\n-    /// Returns the number of elements the vector can hold without reallocating.\n-    fn capacity(&self) -> uint;\n-    /// Shrink the capacity of the vector to match the length\n-    fn shrink_to_fit(&mut self);\n-\n-    /// Append an element to a vector\n-    fn push(&mut self, t: T);\n-    /// Takes ownership of the vector `rhs`, moving all elements into\n-    /// the current vector. This does not copy any elements, and it is\n-    /// illegal to use the `rhs` vector after calling this method\n-    /// (because it is moved here).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut a = ~[~1];\n-    /// a.push_all_move(~[~2, ~3, ~4]);\n-    /// assert!(a == ~[~1, ~2, ~3, ~4]);\n-    /// ```\n-    fn push_all_move(&mut self, rhs: ~[T]);\n-    /// Remove the last element from a vector and return it, or `None` if it is empty\n-    fn pop(&mut self) -> Option<T>;\n-    /// Removes the first element from a vector and return it, or `None` if it is empty\n-    fn shift(&mut self) -> Option<T>;\n-    /// Prepend an element to the vector\n-    fn unshift(&mut self, x: T);\n-\n-    /// Insert an element at position i within v, shifting all\n-    /// elements after position i one position to the right.\n-    fn insert(&mut self, i: uint, x:T);\n-\n-    /// Remove and return the element at position `i` within `v`,\n-    /// shifting all elements after position `i` one position to the\n-    /// left. Returns `None` if `i` is out of bounds.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let mut v = ~[1, 2, 3];\n-    /// assert_eq!(v.remove(1), Some(2));\n-    /// assert_eq!(v, ~[1, 3]);\n-    ///\n-    /// assert_eq!(v.remove(4), None);\n-    /// // v is unchanged:\n-    /// assert_eq!(v, ~[1, 3]);\n-    /// ```\n-    fn remove(&mut self, i: uint) -> Option<T>;\n-\n-    /// Remove an element from anywhere in the vector and return it, replacing it\n-    /// with the last element. This does not preserve ordering, but is O(1).\n-    ///\n-    /// Returns `None` if `index` is out of bounds.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let mut v = ~[~\"foo\", ~\"bar\", ~\"baz\", ~\"qux\"];\n-    ///\n-    /// assert_eq!(v.swap_remove(1), Some(~\"bar\"));\n-    /// assert_eq!(v, ~[~\"foo\", ~\"qux\", ~\"baz\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(0), Some(~\"foo\"));\n-    /// assert_eq!(v, ~[~\"baz\", ~\"qux\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(2), None);\n-    /// ```\n-    fn swap_remove(&mut self, index: uint) -> Option<T>;\n-\n-    /// Shorten a vector, dropping excess elements.\n-    fn truncate(&mut self, newlen: uint);\n-\n-    /**\n-     * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n-     */\n-    fn retain(&mut self, f: |t: &T| -> bool);\n-\n     /**\n      * Partitions the vector into two vectors `(A,B)`, where all\n      * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n     fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n-\n-    /**\n-     * Expands a vector in place, initializing the new elements to the result of\n-     * a function.\n-     *\n-     * Function `init_op` is called `n` times with the values [0..`n`)\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to add\n-     * * init_op - A function to call to retrieve each appended element's\n-     *             value\n-     */\n-    fn grow_fn(&mut self, n: uint, op: |uint| -> T);\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    unsafe fn set_len(&mut self, new_len: uint);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -1418,202 +1175,10 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().rev()\n     }\n \n-    fn reserve_exact(&mut self, n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if self.capacity() < n {\n-            unsafe {\n-                let ptr: *mut *mut Vec<()> = transmute(self);\n-                let alloc = n * mem::nonzero_size_of::<T>();\n-                let size = alloc + mem::size_of::<Vec<()>>();\n-                if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n-                    fail!(\"vector size is too large: {}\", n);\n-                }\n-                *ptr = realloc_raw(*ptr as *mut u8, size)\n-                                   as *mut Vec<()>;\n-                (**ptr).alloc = alloc;\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn reserve(&mut self, n: uint) {\n-        self.reserve_exact(checked_next_power_of_two(n).unwrap_or(n));\n-    }\n-\n-    #[inline]\n-    fn reserve_additional(&mut self, n: uint) {\n-        if self.capacity() - self.len() < n {\n-            match self.len().checked_add(&n) {\n-                None => fail!(\"slice::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve(new_cap)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            let repr: **Vec<()> = transmute(self);\n-            (**repr).alloc / mem::nonzero_size_of::<T>()\n-        }\n-    }\n-\n-    fn shrink_to_fit(&mut self) {\n-        unsafe {\n-            let ptr: *mut *mut Vec<()> = transmute(self);\n-            let alloc = (**ptr).fill;\n-            let size = alloc + mem::size_of::<Vec<()>>();\n-            *ptr = realloc_raw(*ptr as *mut u8, size) as *mut Vec<()>;\n-            (**ptr).alloc = alloc;\n-        }\n-    }\n-\n-    #[inline]\n-    fn push(&mut self, t: T) {\n-        unsafe {\n-            let repr: **Vec<()> = transmute(&mut *self);\n-            let fill = (**repr).fill;\n-            if (**repr).alloc <= fill {\n-                self.reserve_additional(1);\n-            }\n-\n-            push_fast(self, t);\n-        }\n-\n-        // This doesn't bother to make sure we have space.\n-        #[inline] // really pretty please\n-        unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            let repr: **mut Vec<u8> = transmute(this);\n-            let fill = (**repr).fill;\n-            (**repr).fill += mem::nonzero_size_of::<T>();\n-            let p = &((**repr).data) as *u8;\n-            let p = p.offset(fill as int) as *mut T;\n-            mem::move_val_init(&mut(*p), t);\n-        }\n-    }\n-\n-    #[inline]\n-    fn push_all_move(&mut self, mut rhs: ~[T]) {\n-        let self_len = self.len();\n-        let rhs_len = rhs.len();\n-        let new_len = self_len + rhs_len;\n-        self.reserve_additional(rhs.len());\n-        unsafe { // Note: infallible.\n-            let self_p = self.as_mut_ptr();\n-            let rhs_p = rhs.as_ptr();\n-            ptr::copy_memory(self_p.offset(self_len as int), rhs_p, rhs_len);\n-            self.set_len(new_len);\n-            rhs.set_len(0);\n-        }\n-    }\n-\n-    fn pop(&mut self) -> Option<T> {\n-        match self.len() {\n-            0  => None,\n-            ln => {\n-                let valptr = &mut self[ln - 1u] as *mut T;\n-                unsafe {\n-                    self.set_len(ln - 1u);\n-                    Some(ptr::read(&*valptr))\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    #[inline]\n-    fn shift(&mut self) -> Option<T> {\n-        self.remove(0)\n-    }\n-\n-    #[inline]\n-    fn unshift(&mut self, x: T) {\n-        self.insert(0, x)\n-    }\n-\n-    fn insert(&mut self, i: uint, x: T) {\n-        let len = self.len();\n-        assert!(i <= len);\n-        // space for the new element\n-        self.reserve_additional(1);\n-\n-        unsafe { // infallible\n-            // The spot to put the new value\n-            let p = self.as_mut_ptr().offset(i as int);\n-            // Shift everything over to make space. (Duplicating the\n-            // `i`th element into two consecutive places.)\n-            ptr::copy_memory(p.offset(1), &*p, len - i);\n-            // Write it in, overwriting the first copy of the `i`th\n-            // element.\n-            mem::move_val_init(&mut *p, x);\n-            self.set_len(len + 1);\n-        }\n-    }\n-\n-    fn remove(&mut self, i: uint) -> Option<T> {\n-        let len = self.len();\n-        if i < len {\n-            unsafe { // infallible\n-                // the place we are taking from.\n-                let ptr = self.as_mut_ptr().offset(i as int);\n-                // copy it out, unsafely having a copy of the value on\n-                // the stack and in the vector at the same time.\n-                let ret = Some(ptr::read(ptr as *T));\n-\n-                // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, &*ptr.offset(1), len - i - 1);\n-                self.set_len(len - 1);\n-\n-                ret\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-    fn swap_remove(&mut self, index: uint) -> Option<T> {\n-        let ln = self.len();\n-        if index < ln - 1 {\n-            self.swap(index, ln - 1);\n-        } else if index >= ln {\n-            return None\n-        }\n-        self.pop()\n-    }\n-    fn truncate(&mut self, newlen: uint) {\n-        let oldlen = self.len();\n-        assert!(newlen <= oldlen);\n-\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            // This loop is optimized out for non-drop types.\n-            for i in range(newlen, oldlen) {\n-                ptr::read_and_zero(p.offset(i as int));\n-            }\n-        }\n-        unsafe { self.set_len(newlen); }\n-    }\n-\n-    fn retain(&mut self, f: |t: &T| -> bool) {\n-        let len = self.len();\n-        let mut deleted: uint = 0;\n-\n-        for i in range(0u, len) {\n-            if !f(&self[i]) {\n-                deleted += 1;\n-            } else if deleted > 0 {\n-                self.swap(i - deleted, i);\n-            }\n-        }\n-\n-        if deleted > 0 {\n-            self.truncate(len - deleted);\n-        }\n-    }\n-\n     #[inline]\n     fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = ~[];\n-        let mut rights = ~[];\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n         for elt in self.move_iter() {\n             if f(&elt) {\n@@ -1623,184 +1188,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             }\n         }\n \n-        (lefts, rights)\n-    }\n-    fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n-        let new_len = self.len() + n;\n-        self.reserve(new_len);\n-        let mut i: uint = 0u;\n-        while i < n {\n-            self.push(op(i));\n-            i += 1u;\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        let repr: **mut Vec<()> = transmute(self);\n-        (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n-    }\n-}\n-\n-impl<T> Mutable for ~[T] {\n-    /// Clear the vector, removing all values.\n-    fn clear(&mut self) { self.truncate(0) }\n-}\n-\n-/// Extension methods for owned vectors containing `Clone` elements.\n-pub trait OwnedCloneableVector<T:Clone> {\n-    /// Iterates over the slice `rhs`, copies each element, and then appends it to\n-    /// the vector provided `v`. The `rhs` vector is traversed in-order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut a = ~[1];\n-    /// a.push_all([2, 3, 4]);\n-    /// assert!(a == ~[1, 2, 3, 4]);\n-    /// ```\n-    fn push_all(&mut self, rhs: &[T]);\n-\n-    /**\n-     * Expands a vector in place, initializing the new elements to a given value\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to add\n-     * * initval - The value for the new elements\n-     */\n-    fn grow(&mut self, n: uint, initval: &T);\n-\n-    /**\n-     * Sets the value of a vector element at a given index, growing the vector as\n-     * needed\n-     *\n-     * Sets the element at position `index` to `val`. If `index` is past the end\n-     * of the vector, expands the vector by replicating `initval` to fill the\n-     * intervening space.\n-     */\n-    fn grow_set(&mut self, index: uint, initval: &T, val: T);\n-}\n-\n-impl<T:Clone> OwnedCloneableVector<T> for ~[T] {\n-    #[inline]\n-    fn push_all(&mut self, rhs: &[T]) {\n-        let new_len = self.len() + rhs.len();\n-        self.reserve_exact(new_len);\n-\n-        for elt in rhs.iter() {\n-            self.push((*elt).clone())\n-        }\n-    }\n-    fn grow(&mut self, n: uint, initval: &T) {\n-        let new_len = self.len() + n;\n-        self.reserve(new_len);\n-        let mut i: uint = 0u;\n-\n-        while i < n {\n-            self.push((*initval).clone());\n-            i += 1u;\n-        }\n-    }\n-    fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n-        let l = self.len();\n-        if index >= l { self.grow(index - l + 1u, initval); }\n-        self[index] = val;\n-    }\n-}\n-\n-/// Extension methods for owned vectors containing `Eq` elements.\n-pub trait OwnedEqVector<T:Eq> {\n-    /**\n-    * Remove consecutive repeated elements from a vector; if the vector is\n-    * sorted, this removes all duplicates.\n-    */\n-    fn dedup(&mut self);\n-}\n-\n-impl<T:Eq> OwnedEqVector<T> for ~[T] {\n-    fn dedup(&mut self) {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln < 1 { return; }\n-\n-            // Avoid bounds checks by using unsafe pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r = 1;\n-            let mut w = 1;\n-\n-            while r < ln {\n-                let p_r = p.offset(r as int);\n-                let p_wm1 = p.offset((w - 1) as int);\n-                if *p_r != *p_wm1 {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n     }\n }\n \n@@ -1872,7 +1260,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // length 0 so we can keep shallow copies of the contents of `v`\n     // without risking the dtors running on an object twice if\n     // `compare` fails.\n-    let mut working_space = with_capacity(2 * len);\n+    let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n     let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n@@ -2475,10 +1863,12 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n /// Unsafe operations\n pub mod raw {\n     use cast::transmute;\n-    use ptr;\n+    use iter::Iterator;\n     use ptr::RawPtr;\n-    use slice::{with_capacity, MutableVector, OwnedVector};\n+    use ptr;\n     use raw::Slice;\n+    use slice::{MutableVector, OwnedVector};\n+    use vec::Vec;\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n@@ -2521,10 +1911,10 @@ pub mod raw {\n     // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n     #[inline]\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n-        let mut dst = with_capacity(elts);\n+        let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n-        dst\n+        dst.move_iter().collect()\n     }\n \n     /**\n@@ -2556,9 +1946,8 @@ pub mod raw {\n /// Operations on `[u8]`.\n pub mod bytes {\n     use container::Container;\n-    use slice::{MutableVector, OwnedVector, ImmutableVector};\n+    use slice::MutableVector;\n     use ptr;\n-    use ptr::RawPtr;\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n@@ -2582,19 +1971,6 @@ pub mod bytes {\n         // Bound checks are done at .copy_memory.\n         unsafe { dst.copy_memory(src) }\n     }\n-\n-    /**\n-     * Allocate space in `dst` and append the data to `src`.\n-     */\n-    #[inline]\n-    pub fn push_bytes(dst: &mut ~[u8], src: &[u8]) {\n-        let old_len = dst.len();\n-        dst.reserve_additional(src.len());\n-        unsafe {\n-            ptr::copy_memory(dst.as_mut_ptr().offset(old_len as int), src.as_ptr(), src.len());\n-            dst.set_len(old_len + src.len());\n-        }\n-    }\n }\n \n impl<A: Clone> Clone for ~[A] {\n@@ -2603,17 +1979,6 @@ impl<A: Clone> Clone for ~[A] {\n         // Use the fast to_owned on &[A] for cloning\n         self.as_slice().to_owned()\n     }\n-\n-    fn clone_from(&mut self, source: &~[A]) {\n-        if self.len() < source.len() {\n-            *self = source.clone()\n-        } else {\n-            self.truncate(source.len());\n-            for (x, y) in self.mut_iter().zip(source.iter()) {\n-                x.clone_from(y);\n-            }\n-        }\n-    }\n }\n \n impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n@@ -2914,22 +2279,35 @@ pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n     fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n-        let (lower, _) = iterator.size_hint();\n-        let mut xs = with_capacity(lower);\n-        for x in iterator {\n-            xs.push(x);\n-        }\n-        xs\n-    }\n-}\n+        let mut xs: Vec<A> = iterator.collect();\n \n-impl<A> Extendable<A> for ~[A] {\n-    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n-        let (lower, _) = iterator.size_hint();\n-        let len = self.len();\n-        self.reserve_exact(len + lower);\n-        for x in iterator {\n-            self.push(x);\n+        // Must shrink so the capacity is the same as the length. The length of\n+        // the ~[T] vector must exactly match the length of the allocation.\n+        xs.shrink_to_fit();\n+\n+        let len = xs.len();\n+        assert!(len == xs.capacity());\n+        let data = xs.as_mut_ptr();\n+\n+        let data_size = len.checked_mul(&mem::size_of::<A>());\n+        let data_size = data_size.expect(\"overflow in from_iter()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in from_iter()\");\n+\n+\n+        // This is some terribly awful code. Note that all of this will go away\n+        // with DST because creating ~[T] from Vec<T> will just be some pointer\n+        // swizzling.\n+        unsafe {\n+            let ret = malloc_raw(size) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<A>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n+            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n+                                            data as *u8,\n+                                            data_size);\n+            xs.set_len(0); // ownership has been transferred\n+            cast::transmute(ret)\n         }\n     }\n }\n@@ -2974,38 +2352,50 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = from_fn(3u, square);\n-        assert_eq!(v.len(), 3u);\n-        assert_eq!(v[0], 0u);\n-        assert_eq!(v[1], 1u);\n-        assert_eq!(v[2], 4u);\n+        let mut v = Vec::from_fn(3u, square);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 3u);\n+            assert_eq!(v[0], 0u);\n+            assert_eq!(v[1], 1u);\n+            assert_eq!(v[2], 4u);\n+        }\n \n         // Test on-heap from_fn.\n-        v = from_fn(5u, square);\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 0u);\n-        assert_eq!(v[1], 1u);\n-        assert_eq!(v[2], 4u);\n-        assert_eq!(v[3], 9u);\n-        assert_eq!(v[4], 16u);\n+        v = Vec::from_fn(5u, square);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 5u);\n+            assert_eq!(v[0], 0u);\n+            assert_eq!(v[1], 1u);\n+            assert_eq!(v[2], 4u);\n+            assert_eq!(v[3], 9u);\n+            assert_eq!(v[4], 16u);\n+        }\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = from_elem(2u, 10u);\n-        assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 10u);\n-        assert_eq!(v[1], 10u);\n+        let mut v = Vec::from_elem(2u, 10u);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 2u);\n+            assert_eq!(v[0], 10u);\n+            assert_eq!(v[1], 10u);\n+        }\n \n         // Test on-heap from_elem.\n-        v = from_elem(6u, 20u);\n-        assert_eq!(v[0], 20u);\n-        assert_eq!(v[1], 20u);\n-        assert_eq!(v[2], 20u);\n-        assert_eq!(v[3], 20u);\n-        assert_eq!(v[4], 20u);\n-        assert_eq!(v[5], 20u);\n+        v = Vec::from_elem(6u, 20u);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v[0], 20u);\n+            assert_eq!(v[1], 20u);\n+            assert_eq!(v[2], 20u);\n+            assert_eq!(v[3], 20u);\n+            assert_eq!(v[4], 20u);\n+            assert_eq!(v[5], 20u);\n+        }\n     }\n \n     #[test]\n@@ -3164,7 +2554,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        let mut v = ~[5];\n+        let mut v = vec![5];\n         let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n@@ -3176,25 +2566,25 @@ mod tests {\n \n     #[test]\n     fn test_swap_remove() {\n-        let mut v = ~[1, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, Some(1));\n-        assert_eq!(v, ~[5, 2, 3, 4]);\n+        assert_eq!(v, vec![5, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, Some(4));\n-        assert_eq!(v, ~[5, 2, 3]);\n+        assert_eq!(v, vec![5, 2, 3]);\n \n         e = v.swap_remove(3);\n         assert_eq!(e, None);\n-        assert_eq!(v, ~[5, 2, 3]);\n+        assert_eq!(v, vec![5, 2, 3]);\n     }\n \n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::unstable::sync::Exclusive::new(()),\n-                      ::unstable::sync::Exclusive::new(()),\n-                      ::unstable::sync::Exclusive::new(())];\n+        let mut v = vec![::unstable::sync::Exclusive::new(()),\n+                         ::unstable::sync::Exclusive::new(()),\n+                         ::unstable::sync::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n@@ -3206,41 +2596,48 @@ mod tests {\n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.push(1);\n         assert_eq!(v.len(), 1u);\n-        assert_eq!(v[0], 1);\n+        assert_eq!(v.as_slice()[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n         assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n+        assert_eq!(v.as_slice()[0], 1);\n+        assert_eq!(v.as_slice()[1], 2);\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow(2u, &1);\n-        assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 1);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 2u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+        }\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 1);\n-        assert_eq!(v[2], 2);\n-        assert_eq!(v[3], 2);\n-        assert_eq!(v[4], 2);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 5u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 2);\n+            assert_eq!(v[3], 2);\n+            assert_eq!(v[4], 2);\n+        }\n     }\n \n     #[test]\n     fn test_grow_fn() {\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow_fn(3u, square);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 3u);\n         assert_eq!(v[0], 0u);\n         assert_eq!(v[1], 1u);\n@@ -3249,8 +2646,9 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = ~[1, 2, 3];\n+        let mut v = vec![1, 2, 3];\n         v.grow_set(4u, &4, 5);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 5u);\n         assert_eq!(v[0], 1);\n         assert_eq!(v[1], 2);\n@@ -3261,45 +2659,46 @@ mod tests {\n \n     #[test]\n     fn test_truncate() {\n-        let mut v = ~[~6,~5,~4];\n+        let mut v = vec![~6,~5,~4];\n         v.truncate(1);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 1);\n         assert_eq!(*(v[0]), 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n-        let mut v = ~[~6,~5,~4];\n+        let mut v = vec![~6,~5,~4];\n         v.clear();\n         assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_dedup() {\n-        fn case(a: ~[uint], b: ~[uint]) {\n+        fn case(a: Vec<uint>, b: Vec<uint>) {\n             let mut v = a;\n             v.dedup();\n             assert_eq!(v, b);\n         }\n-        case(~[], ~[]);\n-        case(~[1], ~[1]);\n-        case(~[1,1], ~[1]);\n-        case(~[1,2,3], ~[1,2,3]);\n-        case(~[1,1,2,3], ~[1,2,3]);\n-        case(~[1,2,2,3], ~[1,2,3]);\n-        case(~[1,2,3,3], ~[1,2,3]);\n-        case(~[1,1,2,2,2,3,3], ~[1,2,3]);\n+        case(vec![], vec![]);\n+        case(vec![1], vec![1]);\n+        case(vec![1,1], vec![1]);\n+        case(vec![1,2,3], vec![1,2,3]);\n+        case(vec![1,1,2,3], vec![1,2,3]);\n+        case(vec![1,2,2,3], vec![1,2,3]);\n+        case(vec![1,2,3,3], vec![1,2,3]);\n+        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n     }\n \n     #[test]\n     fn test_dedup_unique() {\n-        let mut v0 = ~[~1, ~1, ~2, ~3];\n+        let mut v0 = vec![~1, ~1, ~2, ~3];\n         v0.dedup();\n-        let mut v1 = ~[~1, ~2, ~2, ~3];\n+        let mut v1 = vec![~1, ~2, ~2, ~3];\n         v1.dedup();\n-        let mut v2 = ~[~1, ~2, ~3, ~3];\n+        let mut v2 = vec![~1, ~2, ~3, ~3];\n         v2.dedup();\n         /*\n          * If the ~pointers were leaked or otherwise misused, valgrind and/or\n@@ -3309,11 +2708,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_shared() {\n-        let mut v0 = ~[~1, ~1, ~2, ~3];\n+        let mut v0 = vec![~1, ~1, ~2, ~3];\n         v0.dedup();\n-        let mut v1 = ~[~1, ~2, ~2, ~3];\n+        let mut v1 = vec![~1, ~2, ~2, ~3];\n         v1.dedup();\n-        let mut v2 = ~[~1, ~2, ~3, ~3];\n+        let mut v2 = vec![~1, ~2, ~3, ~3];\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n@@ -3323,14 +2722,14 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut v = ~[1, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, ~[1, 3, 5]);\n+        assert_eq!(v, vec![1, 3, 5]);\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n-        let z1 = ~[(1, 4), (2, 5), (3, 6)];\n+        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n@@ -3559,9 +2958,9 @@ mod tests {\n \n     #[test]\n     fn test_shift() {\n-        let mut x = ~[1, 2, 3];\n+        let mut x = vec![1, 2, 3];\n         assert_eq!(x.shift(), Some(1));\n-        assert_eq!(&x, &~[2, 3]);\n+        assert_eq!(&x, &vec![2, 3]);\n         assert_eq!(x.shift(), Some(2));\n         assert_eq!(x.shift(), Some(3));\n         assert_eq!(x.shift(), None);\n@@ -3570,73 +2969,73 @@ mod tests {\n \n     #[test]\n     fn test_unshift() {\n-        let mut x = ~[1, 2, 3];\n+        let mut x = vec![1, 2, 3];\n         x.unshift(0);\n-        assert_eq!(x, ~[0, 1, 2, 3]);\n+        assert_eq!(x, vec![0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n-        let mut a = ~[1, 2, 4];\n+        let mut a = vec![1, 2, 4];\n         a.insert(2, 3);\n-        assert_eq!(a, ~[1, 2, 3, 4]);\n+        assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(0, 0);\n-        assert_eq!(a, ~[0, 1, 2, 3]);\n+        assert_eq!(a, vec![0, 1, 2, 3]);\n \n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(3, 4);\n-        assert_eq!(a, ~[1, 2, 3, 4]);\n+        assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = ~[];\n+        let mut a = vec![];\n         a.insert(0, 1);\n-        assert_eq!(a, ~[1]);\n+        assert_eq!(a, vec![1]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_insert_oob() {\n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(4, 5);\n     }\n \n     #[test]\n     fn test_remove() {\n-        let mut a = ~[1,2,3,4];\n+        let mut a = vec![1,2,3,4];\n \n         assert_eq!(a.remove(2), Some(3));\n-        assert_eq!(a, ~[1,2,4]);\n+        assert_eq!(a, vec![1,2,4]);\n \n         assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, ~[1,2]);\n+        assert_eq!(a, vec![1,2]);\n \n         assert_eq!(a.remove(2), None);\n-        assert_eq!(a, ~[1,2]);\n+        assert_eq!(a, vec![1,2]);\n \n         assert_eq!(a.remove(0), Some(1));\n-        assert_eq!(a, ~[2]);\n+        assert_eq!(a, vec![2]);\n \n         assert_eq!(a.remove(0), Some(2));\n-        assert_eq!(a, ~[]);\n+        assert_eq!(a, vec![]);\n \n         assert_eq!(a.remove(0), None);\n         assert_eq!(a.remove(10), None);\n     }\n \n     #[test]\n     fn test_capacity() {\n-        let mut v = ~[0u64];\n+        let mut v = vec![0u64];\n         v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n-        let mut v = ~[0u32];\n+        let mut v = vec![0u32];\n         v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n     }\n \n     #[test]\n     fn test_slice_2() {\n-        let v = ~[1, 2, 3, 4, 5];\n+        let v = vec![1, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v[0], 2);\n@@ -3647,7 +3046,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_from_fn_fail() {\n-        from_fn(100, |v| {\n+        Vec::from_fn(100, |v| {\n             if v == 50 { fail!() }\n             ~0\n         });\n@@ -3674,27 +3073,14 @@ mod tests {\n         }\n \n         let s = S { f: 0, boxes: (~0, Rc::new(0)) };\n-        let _ = from_elem(100, s);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_build_fail() {\n-        use rc::Rc;\n-        build(None, |push| {\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            fail!();\n-        });\n+        let _ = Vec::from_elem(100, s);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_grow_fn_fail() {\n         use rc::Rc;\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow_fn(100, |i| {\n             if i == 50 {\n                 fail!()\n@@ -4036,6 +3422,7 @@ mod tests {\n \n         t!(&[int]);\n         t!(~[int]);\n+        t!(Vec<int>);\n     }\n \n     #[test]\n@@ -4051,7 +3438,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault() {\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.reserve_exact(-1);\n         v.push(1);\n         v.push(2);\n@@ -4061,7 +3448,7 @@ mod tests {\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault_managed() {\n         use rc::Rc;\n-        let mut v = ~[Rc::new(1)];\n+        let mut v = vec![Rc::new(1)];\n         v.reserve_exact(-1);\n         v.push(Rc::new(2));\n     }\n@@ -4090,7 +3477,7 @@ mod tests {\n \n     #[test]\n     fn test_iter_zero_sized() {\n-        let mut v = ~[Foo, Foo, Foo];\n+        let mut v = vec![Foo, Foo, Foo];\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0;\n \n@@ -4118,7 +3505,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 11);\n \n-        let xs = ~[Foo, Foo, Foo];\n+        let xs = vec![Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n                    ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n \n@@ -4135,14 +3522,14 @@ mod tests {\n \n     #[test]\n     fn test_shrink_to_fit() {\n-        let mut xs = ~[0, 1, 2, 3];\n+        let mut xs = vec![0, 1, 2, 3];\n         for i in range(4, 100) {\n             xs.push(i)\n         }\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, range(0, 100).collect::<~[_]>());\n+        assert_eq!(xs, range(0, 100).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -4300,13 +3687,12 @@ mod bench {\n     use prelude::*;\n     use ptr;\n     use rand::{weak_rng, Rng};\n-    use slice;\n \n     #[bench]\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = slice::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n+        let v = Vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -4320,7 +3706,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = slice::from_elem(100, 0);\n+        let mut v = Vec::from_elem(100, 0);\n \n         b.iter(|| {\n             let mut i = 0;\n@@ -4342,23 +3728,23 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n         b.iter(|| {\n-            let _ = xss.concat_vec();\n+            xss.as_slice().concat_vec()\n         });\n     }\n \n     #[bench]\n     fn connect(b: &mut Bencher) {\n-        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n         b.iter(|| {\n-            let _ = xss.connect_vec(&0);\n+            xss.as_slice().connect_vec(&0)\n         });\n     }\n \n     #[bench]\n     fn push(b: &mut Bencher) {\n-        let mut vec: ~[uint] = ~[0u];\n+        let mut vec: Vec<uint> = vec![];\n         b.iter(|| {\n             vec.push(0);\n             &vec\n@@ -4367,59 +3753,59 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n-            vec.starts_with(vec)\n+            vec.as_slice().starts_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: ~[uint] = ~[0u];\n+        let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.starts_with(vec)\n+            vec.as_slice().starts_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = slice::from_fn(99, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(99, |i| i);\n         match_vec.push(0);\n         b.iter(|| {\n-            vec.starts_with(match_vec)\n+            vec.as_slice().starts_with(match_vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n-            vec.ends_with(vec)\n+            vec.as_slice().ends_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: ~[uint] = ~[0u];\n+        let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.ends_with(vec)\n+            vec.as_slice().ends_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = slice::from_fn(100, |i| i);\n-        match_vec[0] = 200;\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n-            vec.starts_with(match_vec)\n+            vec.as_slice().starts_with(match_vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -4428,14 +3814,14 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n         b.iter(|| {\n-            let _v: ~[u8] = slice::from_elem(1024, 0u8);\n+            Vec::from_elem(1024, 0u8)\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_set_memory(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v: Vec<uint> = Vec::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n@@ -4454,23 +3840,21 @@ mod bench {\n \n     #[bench]\n     fn zero_1kb_loop_set(b: &mut Bencher) {\n-        // Slower because the { len, cap, [0 x T] }* repr allows a pointer to the length\n-        // field to be aliased (in theory) and prevents LLVM from optimizing loads away.\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v: Vec<uint> = Vec::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n             for i in range(0u, 1024) {\n-                v[i] = 0;\n+                *v.get_mut(i) = 0;\n             }\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_mut_iter(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v = Vec::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -4485,7 +3869,7 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = slice::from_elem(30, (0u, 0u));\n+                let mut v = Vec::from_elem(30, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.insert(rng.gen::<uint>() % (l + 1),\n@@ -4497,7 +3881,7 @@ mod bench {\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = slice::from_elem(130, (0u, 0u));\n+                let mut v = Vec::from_elem(130, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.remove(rng.gen::<uint>() % l);\n@@ -4537,11 +3921,11 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = slice::from_fn(10000, |i| i);\n+        let mut v = Vec::from_fn(10000, |i| i);\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n     }\n \n     type BigSortable = (u64,u64,u64,u64);\n@@ -4578,10 +3962,10 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = slice::from_fn(10000u, |i| (i, i, i, i));\n+        let mut v = Vec::from_fn(10000u, |i| (i, i, i, i));\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n     }\n }"}, {"sha": "ed4a8c652f7318a7f49585a32f81a626d0c8e136", "filename": "src/libstd/str.rs", "status": "modified", "additions": 31, "deletions": 62, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -80,7 +80,7 @@ use char;\n use char::Char;\n use clone::Clone;\n use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n-use container::{Container, Mutable};\n+use container::Container;\n use fmt;\n use io::Writer;\n use iter::{Iterator, FromIterator, Extendable, range};\n@@ -92,7 +92,7 @@ use option::{None, Option, Some};\n use ptr;\n use from_str::FromStr;\n use slice;\n-use slice::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n+use slice::{OwnedVector, ImmutableVector, MutableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n@@ -588,7 +588,7 @@ enum NormalizationForm {\n pub struct Normalizations<'a> {\n     kind: NormalizationForm,\n     iter: Chars<'a>,\n-    buffer: ~[(char, u8)],\n+    buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n@@ -597,7 +597,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n     fn next(&mut self) -> Option<char> {\n         use unicode::decompose::canonical_combining_class;\n \n-        match self.buffer.head() {\n+        match self.buffer.as_slice().head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.shift();\n@@ -622,7 +622,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n                 decomposer(ch, |d| {\n                     let class = canonical_combining_class(d);\n                     if class == 0 && !*sorted {\n-                        canonical_sort(*buffer);\n+                        canonical_sort(buffer.as_mut_slice());\n                         *sorted = true;\n                     }\n                     buffer.push((d, class));\n@@ -632,7 +632,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n         }\n \n         if !self.sorted {\n-            canonical_sort(self.buffer);\n+            canonical_sort(self.buffer.as_mut_slice());\n             self.sorted = true;\n         }\n \n@@ -1336,22 +1336,23 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n pub mod raw {\n     use cast;\n     use container::Container;\n+    use iter::Iterator;\n     use libc;\n-    use ptr;\n     use ptr::RawPtr;\n-    use str::{is_utf8, OwnedStr, StrSlice};\n-    use slice;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector};\n+    use ptr;\n     use raw::Slice;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector, Vector};\n+    use str::{is_utf8, StrSlice};\n+    use vec::Vec;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v: ~[u8] = slice::with_capacity(len);\n+        let mut v = Vec::with_capacity(len);\n         ptr::copy_memory(v.as_mut_ptr(), buf, len);\n         v.set_len(len);\n \n-        assert!(is_utf8(v));\n-        ::cast::transmute(v)\n+        assert!(is_utf8(v.as_slice()));\n+        ::cast::transmute(v.move_iter().collect::<~[u8]>())\n     }\n \n     #[lang=\"strdup_uniq\"]\n@@ -1594,16 +1595,6 @@ impl Container for ~str {\n     fn len(&self) -> uint { self.as_slice().len() }\n }\n \n-impl Mutable for ~str {\n-    /// Remove all content, make the string empty\n-    #[inline]\n-    fn clear(&mut self) {\n-        unsafe {\n-            self.set_len(0)\n-        }\n-    }\n-}\n-\n /// Methods for string slices\n pub trait StrSlice<'a> {\n     /// Returns true if one string contains another\n@@ -2396,7 +2387,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn nfd_chars(&self) -> Normalizations<'a> {\n         Normalizations {\n             iter: self.chars(),\n-            buffer: ~[],\n+            buffer: Vec::new(),\n             sorted: false,\n             kind: NFD\n         }\n@@ -2406,7 +2397,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn nfkd_chars(&self) -> Normalizations<'a> {\n         Normalizations {\n             iter: self.chars(),\n-            buffer: ~[],\n+            buffer: Vec::new(),\n             sorted: false,\n             kind: NFKD\n         }\n@@ -2544,22 +2535,22 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn to_owned(&self) -> ~str {\n         let len = self.len();\n         unsafe {\n-            let mut v = slice::with_capacity(len);\n+            let mut v = Vec::with_capacity(len);\n \n             ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n             v.set_len(len);\n-            ::cast::transmute(v)\n+            ::cast::transmute(v.move_iter().collect::<~[u8]>())\n         }\n     }\n \n     fn to_utf16(&self) -> ~[u16] {\n-        let mut u = ~[];\n+        let mut u = Vec::new();;\n         for ch in self.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n-        u\n+        u.move_iter().collect()\n     }\n \n     #[inline]\n@@ -2694,29 +2685,30 @@ impl<'a> StrSlice<'a> for &'a str {\n         if slen == 0 { return tlen; }\n         if tlen == 0 { return slen; }\n \n-        let mut dcol = slice::from_fn(tlen + 1, |x| x);\n+        let mut dcol = Vec::from_fn(tlen + 1, |x| x);\n \n         for (i, sc) in self.chars().enumerate() {\n \n             let mut current = i;\n-            dcol[0] = current + 1;\n+            *dcol.get_mut(0) = current + 1;\n \n             for (j, tc) in t.chars().enumerate() {\n \n-                let next = dcol[j + 1];\n+                let next = *dcol.get(j + 1);\n \n                 if sc == tc {\n-                    dcol[j + 1] = current;\n+                    *dcol.get_mut(j + 1) = current;\n                 } else {\n-                    dcol[j + 1] = ::cmp::min(current, next);\n-                    dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                    *dcol.get_mut(j + 1) = ::cmp::min(current, next);\n+                    *dcol.get_mut(j + 1) = ::cmp::min(*dcol.get(j + 1),\n+                                                      *dcol.get(j)) + 1;\n                 }\n \n                 current = next;\n             }\n         }\n \n-        return dcol[tlen];\n+        return *dcol.get(tlen);\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n@@ -2738,43 +2730,21 @@ impl<'a> StrSlice<'a> for &'a str {\n \n /// Methods for owned strings\n pub trait OwnedStr {\n-    /// Shorten a string to the specified length (which must be <= the current length)\n-    fn truncate(&mut self, len: uint);\n-\n     /// Consumes the string, returning the underlying byte buffer.\n     ///\n     /// The buffer does not have a null terminator.\n     fn into_bytes(self) -> ~[u8];\n \n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    unsafe fn set_len(&mut self, new_len: uint);\n-\n     /// Pushes the given string onto this string, returning the concatenation of the two strings.\n     fn append(self, rhs: &str) -> ~str;\n }\n \n impl OwnedStr for ~str {\n-    #[inline]\n-    fn truncate(&mut self, len: uint) {\n-        assert!(len <= self.len());\n-        assert!(self.is_char_boundary(len));\n-        unsafe { self.set_len(len); }\n-    }\n-\n     #[inline]\n     fn into_bytes(self) -> ~[u8] {\n         unsafe { cast::transmute(self) }\n     }\n \n-    #[inline]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        raw::as_owned_vec(self).set_len(new_len)\n-    }\n-\n     #[inline]\n     fn append(self, rhs: &str) -> ~str {\n         let mut new_str = StrBuf::from_owned_str(self);\n@@ -3409,8 +3379,7 @@ mod tests {\n         assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n-        let mut lines = ~[];\n-        for line in string.lines() { lines.push(line) }\n+        let lines: ~[&str] = string.lines().collect();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -4259,9 +4228,9 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = ::slice::from_elem(100, 0xF5u8);\n+        let s = Vec::from_elem(100, 0xF5u8);\n         b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n+            let _ = from_utf8_lossy(s.as_slice());\n         });\n     }\n "}, {"sha": "498a6252a8fb90f937d9e1d43462e17e9fffef6e", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -23,12 +23,13 @@\n \n use cast;\n use clone::Clone;\n+use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n use ptr::RawPtr;\n use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n-use slice;\n use ty::Unsafe;\n+use vec::Vec;\n \n /// An atomically reference counted pointer.\n ///\n@@ -73,7 +74,8 @@ impl<T: Send> UnsafeArc<T> {\n                 ~[] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n-                slice::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n+                let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });\n+                v.move_iter().collect()\n             }\n         }\n     }"}, {"sha": "97239707d329af6a8ba106a700f88bb1beb67981", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -61,7 +61,7 @@ use ptr::RawPtr;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n-use slice::{OwnedVector, ImmutableVector};\n+use slice::ImmutableVector;\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that"}, {"sha": "b7f6d730d12bc11249469c44ec2dd6319e0622d8", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -115,7 +115,7 @@ mod tests {\n     #[test]\n     fn exclusive_new_arc() {\n         unsafe {\n-            let mut futures = ~[];\n+            let mut futures = Vec::new();\n \n             let num_tasks = 10;\n             let count = 10;"}, {"sha": "5480805478c0a7188e2f16f0ff8861a5bb6b65d1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b0bf3912fabf52fdd6926900e578e55af1b49/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7d3b0bf3912fabf52fdd6926900e578e55af1b49", "patch": "@@ -614,13 +614,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        // See the comment in as_slice() for what's going on here.\n-        let slice = if mem::size_of::<T>() == 0 {\n-            Slice { data: 1 as *T, len: self.len }\n-        } else {\n-            Slice { data: self.ptr as *T, len: self.len }\n-        };\n-        unsafe { transmute(slice) }\n+        unsafe {\n+            transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n+        }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each\n@@ -1143,7 +1139,15 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_ptr(&self) -> *T {\n-        self.as_slice().as_ptr()\n+        // If we have a 0-sized vector, then the base pointer should not be NULL\n+        // because an iterator over the slice will attempt to yield the base\n+        // pointer as the first element in the vector, but this will end up\n+        // being Some(NULL) which is optimized to None.\n+        if mem::size_of::<T>() == 0 {\n+            1 as *T\n+        } else {\n+            self.ptr as *T\n+        }\n     }\n \n     /// Returns a mutable unsafe pointer to the vector's buffer.\n@@ -1155,7 +1159,12 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n-        self.as_mut_slice().as_mut_ptr()\n+        // see above for the 0-size check\n+        if mem::size_of::<T>() == 0 {\n+            1 as *mut T\n+        } else {\n+            self.ptr\n+        }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1356,16 +1365,7 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        // If we have a 0-sized vector, then the base pointer should not be NULL\n-        // because an iterator over the slice will attempt to yield the base\n-        // pointer as the first element in the vector, but this will end up\n-        // being Some(NULL) which is optimized to None.\n-        let slice = if mem::size_of::<T>() == 0 {\n-            Slice { data: 1 as *T, len: self.len }\n-        } else {\n-            Slice { data: self.ptr as *T, len: self.len }\n-        };\n-        unsafe { transmute(slice) }\n+        unsafe { transmute(Slice { data: self.as_ptr(), len: self.len }) }\n     }\n }\n "}]}