{"sha": "697118d23eaa5d59940befabedcafbaceaf61a1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NzExOGQyM2VhYTVkNTk5NDBiZWZhYmVkY2FmYmFjZWFmNjFhMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-19T13:44:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-19T13:44:18Z"}, "message": "Auto merge of #88627 - cjgillot:noallocuse, r=petrochenkov\n\nDo not preallocate HirIds\n\nPart of https://github.com/rust-lang/rust/pull/87234\n\nr? `@petrochenkov`", "tree": {"sha": "65323a8b1158d5d3c8be9a8b7df76c74edcb5f4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65323a8b1158d5d3c8be9a8b7df76c74edcb5f4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/697118d23eaa5d59940befabedcafbaceaf61a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/697118d23eaa5d59940befabedcafbaceaf61a1c", "html_url": "https://github.com/rust-lang/rust/commit/697118d23eaa5d59940befabedcafbaceaf61a1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/697118d23eaa5d59940befabedcafbaceaf61a1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08a0307b32ec5af243880056d7cf524f2eff8d69", "url": "https://api.github.com/repos/rust-lang/rust/commits/08a0307b32ec5af243880056d7cf524f2eff8d69", "html_url": "https://github.com/rust-lang/rust/commit/08a0307b32ec5af243880056d7cf524f2eff8d69"}, {"sha": "d60bbde7e21f3e274263fe82f5c85b2a6c215020", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60bbde7e21f3e274263fe82f5c85b2a6c215020", "html_url": "https://github.com/rust-lang/rust/commit/d60bbde7e21f3e274263fe82f5c85b2a6c215020"}], "stats": {"total": 132, "additions": 32, "deletions": 100}, "files": [{"sha": "14a894d61f4f5fdeeb5c8917b61a75b32025ba24", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=697118d23eaa5d59940befabedcafbaceaf61a1c", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 }\n                 StmtKind::Item(ref it) => {\n-                    stmts.extend(self.lower_item_id(it).into_iter().enumerate().map(\n+                    stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n                         |(i, item_id)| {\n                             let hir_id = match i {\n                                 0 => self.lower_node_id(s.id),"}, {"sha": "520faa6dcd6cfd869dae5f72043b0ffd0b1fcfe0", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=697118d23eaa5d59940befabedcafbaceaf61a1c", "patch": "@@ -40,6 +40,7 @@ impl ItemLowerer<'_, '_, '_> {\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_item(&mut self, item: &'a Item) {\n+        self.lctx.allocate_hir_id_counter(item.id);\n         let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n             lctx.without_in_scope_lifetime_defs(|lctx| {\n                 let hir_item = lctx.lower_item(item);\n@@ -77,6 +78,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => {\n                 let hir_item = lctx.lower_trait_item(item);\n@@ -154,41 +156,28 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n             inner: self.lower_span(inner),\n-            item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_id(x))),\n+            item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_ref(x))),\n         }\n     }\n \n-    pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let node_ids = match i.kind {\n-            ItemKind::Use(ref use_tree) => {\n-                let mut vec = smallvec![i.id];\n-                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n-                vec\n-            }\n-            ItemKind::Fn(..) | ItemKind::Impl(box ImplKind { of_trait: None, .. }) => {\n-                smallvec![i.id]\n-            }\n-            _ => smallvec![i.id],\n-        };\n-\n+    pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n+        let mut node_ids = smallvec![hir::ItemId { def_id: self.resolver.local_def_id(i.id) }];\n+        if let ItemKind::Use(ref use_tree) = &i.kind {\n+            self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n+        }\n         node_ids\n-            .into_iter()\n-            .map(|node_id| hir::ItemId {\n-                def_id: self.allocate_hir_id_counter(node_id).expect_owner(),\n-            })\n-            .collect()\n     }\n \n     fn lower_item_id_use_tree(\n         &mut self,\n         tree: &UseTree,\n         base_id: NodeId,\n-        vec: &mut SmallVec<[NodeId; 1]>,\n+        vec: &mut SmallVec<[hir::ItemId; 1]>,\n     ) {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(id);\n+                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -197,7 +186,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(id);\n+                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n                 }\n             }\n         }\n@@ -486,7 +475,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                 }\n \n-                let mut resolutions = self.expect_full_res_from_use(id);\n+                let mut resolutions = self.expect_full_res_from_use(id).fuse();\n                 // We want to return *something* from this function, so hold onto the first item\n                 // for later.\n                 let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n@@ -496,7 +485,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (res, &new_node_id) in iter::zip(resolutions, &[id1, id2]) {\n+                for new_node_id in [id1, id2] {\n+                    // Associate an HirId to both ids even if there is no resolution.\n+                    let new_id = self.allocate_hir_id_counter(new_node_id);\n+\n+                    let res = if let Some(res) = resolutions.next() { res } else { continue };\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n@@ -505,17 +498,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let span = path.span;\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n-                        let new_id = this.lower_node_id(new_node_id);\n                         let res = this.lower_res(res);\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(new_id, attrs);\n+                            this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n                         }\n \n                         this.insert_item(hir::Item {\n-                            def_id: new_id.expect_owner(),\n+                            def_id: new_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n@@ -564,7 +556,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.lower_node_id(id);\n+                    let new_hir_id = self.allocate_hir_id_counter(id);\n \n                     let mut prefix = prefix.clone();\n \n@@ -585,11 +577,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(new_hir_id, attrs);\n+                            this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n                         }\n \n                         this.insert_item(hir::Item {\n-                            def_id: new_hir_id.expect_owner(),\n+                            def_id: new_hir_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n@@ -700,7 +692,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef<'hir> {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n+            id: hir::ForeignItemId { def_id: self.allocate_hir_id_counter(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -839,7 +831,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.lower_node_id(i.id).expect_owner() };\n+        let id = hir::TraitItemId { def_id: self.resolver.local_def_id(i.id) };\n         let defaultness = hir::Defaultness::Default { has_value: has_default };\n         hir::TraitItemRef {\n             id,\n@@ -925,7 +917,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n+            id: hir::ImplItemId { def_id: self.allocate_hir_id_counter(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             vis: self.lower_visibility(&i.vis, Some(i.id)),"}, {"sha": "fb8d5db034a051e939e3271daad4449636a31b1b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=697118d23eaa5d59940befabedcafbaceaf61a1c", "patch": "@@ -38,7 +38,7 @@\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n-use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n@@ -418,60 +418,9 @@ enum AnonymousLifetimeMode {\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n-        /// Full-crate AST visitor that inserts into a fresh\n-        /// `LoweringContext` any information that may be\n-        /// needed from arbitrary locations in the crate,\n-        /// e.g., the number of lifetime generic parameters\n-        /// declared for every type and trait definition.\n-        struct MiscCollector<'tcx, 'lowering, 'hir> {\n-            lctx: &'tcx mut LoweringContext<'lowering, 'hir>,\n-        }\n-\n-        impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree) {\n-                match tree.kind {\n-                    UseTreeKind::Simple(_, id1, id2) => {\n-                        for id in [id1, id2] {\n-                            self.lctx.allocate_hir_id_counter(id);\n-                        }\n-                    }\n-                    UseTreeKind::Glob => (),\n-                    UseTreeKind::Nested(ref trees) => {\n-                        for &(ref use_tree, id) in trees {\n-                            self.lctx.allocate_hir_id_counter(id);\n-                            self.allocate_use_tree_hir_id_counters(use_tree);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n-            fn visit_item(&mut self, item: &'tcx Item) {\n-                self.lctx.allocate_hir_id_counter(item.id);\n-\n-                if let ItemKind::Use(ref use_tree) = item.kind {\n-                    self.allocate_use_tree_hir_id_counters(use_tree);\n-                }\n-\n-                visit::walk_item(self, item);\n-            }\n-\n-            fn visit_assoc_item(&mut self, item: &'tcx AssocItem, ctxt: AssocCtxt) {\n-                self.lctx.allocate_hir_id_counter(item.id);\n-                visit::walk_assoc_item(self, item, ctxt);\n-            }\n-\n-            fn visit_foreign_item(&mut self, item: &'tcx ForeignItem) {\n-                self.lctx.allocate_hir_id_counter(item.id);\n-                visit::walk_foreign_item(self, item);\n-            }\n-        }\n-\n         self.lower_node_id(CRATE_NODE_ID);\n         debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n \n-        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.arena.alloc(self.lower_mod(&c.items, c.span));\n@@ -554,13 +503,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         id\n     }\n \n-    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n+    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LocalDefId {\n         // Set up the counter if needed.\n         self.item_local_id_counters.entry(owner).or_insert(0);\n         // Always allocate the first `HirId` for the owner itself.\n         let lowered = self.lower_node_id_with_owner(owner, owner);\n         debug_assert_eq!(lowered.local_id.as_u32(), 0);\n-        lowered\n+        lowered.owner\n     }\n \n     fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n@@ -1494,9 +1443,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n-\n-        self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n \n         let collected_lifetimes = self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let hir_bounds = lower_bounds(lctx);\n@@ -1753,9 +1700,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n-\n-        self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the"}, {"sha": "495c5e1719765e74f7c0ff1dd8b8ea2f673bd9a0", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697118d23eaa5d59940befabedcafbaceaf61a1c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=697118d23eaa5d59940befabedcafbaceaf61a1c", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -206,11 +206,6 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n-        // FIXME(eddyb) support `find` on the crate root.\n-        if local_def_id.to_def_id().index == CRATE_DEF_INDEX {\n-            return Some(DefKind::Mod);\n-        }\n-\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n         let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {"}]}