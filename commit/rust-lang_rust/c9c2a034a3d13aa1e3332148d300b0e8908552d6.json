{"sha": "c9c2a034a3d13aa1e3332148d300b0e8908552d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YzJhMDM0YTNkMTNhYTFlMzMzMjE0OGQzMDBiMGU4OTA4NTUyZDY=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-06-11T13:34:28Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-06-11T13:34:28Z"}, "message": "run rustfmt on linkchecker folderin src/tools/linkchecker", "tree": {"sha": "0ca3ae8490ba58e94284b73e9c9217e1b0f27e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca3ae8490ba58e94284b73e9c9217e1b0f27e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9c2a034a3d13aa1e3332148d300b0e8908552d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9c2a034a3d13aa1e3332148d300b0e8908552d6", "html_url": "https://github.com/rust-lang/rust/commit/c9c2a034a3d13aa1e3332148d300b0e8908552d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9c2a034a3d13aa1e3332148d300b0e8908552d6/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "682abf79afa40ba17eb6dfe47f944544c966839c", "url": "https://api.github.com/repos/rust-lang/rust/commits/682abf79afa40ba17eb6dfe47f944544c966839c", "html_url": "https://github.com/rust-lang/rust/commit/682abf79afa40ba17eb6dfe47f944544c966839c"}], "stats": {"total": 67, "additions": 30, "deletions": 37}, "files": [{"sha": "4b74833eaf79794ad1f5f7256a335c661cd1c5db", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c9c2a034a3d13aa1e3332148d300b0e8908552d6/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c2a034a3d13aa1e3332148d300b0e8908552d6/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=c9c2a034a3d13aa1e3332148d300b0e8908552d6", "patch": "@@ -75,30 +75,20 @@ struct FileEntry {\n type Cache = HashMap<PathBuf, FileEntry>;\n \n impl FileEntry {\n-    fn parse_ids(&mut self,\n-                file: &Path,\n-                contents: &str,\n-                errors: &mut bool)\n-{\n+    fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n         if self.ids.is_empty() {\n             with_attrs_in_source(contents, \" id\", |fragment, i| {\n                 let frag = fragment.trim_left_matches(\"#\").to_owned();\n                 if !self.ids.insert(frag) {\n                     *errors = true;\n-                    println!(\"{}:{}: id is not unique: `{}`\",\n-                             file.display(), i, fragment);\n+                    println!(\"{}:{}: id is not unique: `{}`\", file.display(), i, fragment);\n                 }\n             });\n         }\n     }\n }\n \n-fn walk(cache: &mut Cache,\n-        root: &Path,\n-        dir: &Path,\n-        url: &mut Url,\n-        errors: &mut bool)\n-{\n+fn walk(cache: &mut Cache, root: &Path, dir: &Path, url: &mut Url, errors: &mut bool) {\n     for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n         let path = entry.path();\n         let kind = t!(entry.file_type());\n@@ -122,8 +112,8 @@ fn check(cache: &mut Cache,\n          root: &Path,\n          file: &Path,\n          base: &Url,\n-         errors: &mut bool) -> Option<PathBuf>\n-{\n+         errors: &mut bool)\n+         -> Option<PathBuf> {\n     // ignore js files as they are not prone to errors as the rest of the\n     // documentation is and they otherwise bring up false positives.\n     if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n@@ -173,8 +163,9 @@ fn check(cache: &mut Cache,\n         Err(_) => return None,\n     };\n     {\n-        cache.get_mut(&pretty_file).unwrap()\n-                                   .parse_ids(&pretty_file, &contents, errors);\n+        cache.get_mut(&pretty_file)\n+             .unwrap()\n+             .parse_ids(&pretty_file, &contents, errors);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n@@ -195,8 +186,10 @@ fn check(cache: &mut Cache,\n                 // the docs offline so it's best to avoid them.\n                 *errors = true;\n                 let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-                println!(\"{}:{}: directory link - {}\", pretty_file.display(),\n-                         i + 1, pretty_path.display());\n+                println!(\"{}:{}: directory link - {}\",\n+                         pretty_file.display(),\n+                         i + 1,\n+                         pretty_path.display());\n                 return;\n             }\n             let res = load_file(cache, root, path.clone(), FromRedirect(false));\n@@ -205,7 +198,9 @@ fn check(cache: &mut Cache,\n                 Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n                 Err(LoadError::BrokenRedirect(target, _)) => {\n                     print!(\"{}:{}: broken redirect to {}\",\n-                           pretty_file.display(), i + 1, target.display());\n+                           pretty_file.display(),\n+                           i + 1,\n+                           target.display());\n                     return;\n                 }\n                 Err(LoadError::IsRedirect) => unreachable!(),\n@@ -225,9 +220,9 @@ fn check(cache: &mut Cache,\n                 if !entry.ids.contains(fragment) {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment  \",\n-                           pretty_file.display(), i + 1);\n-                    println!(\"`#{}` pointing to `{}`\",\n-                             fragment, pretty_path.display());\n+                           pretty_file.display(),\n+                           i + 1);\n+                    println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n                 };\n             }\n         } else {\n@@ -243,15 +238,16 @@ fn check(cache: &mut Cache,\n fn load_file(cache: &mut Cache,\n              root: &Path,\n              file: PathBuf,\n-             redirect: Redirect) -> Result<(PathBuf, String), LoadError> {\n+             redirect: Redirect)\n+             -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n     let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n \n     let maybe_redirect = match cache.entry(pretty_file.clone()) {\n         Entry::Occupied(entry) => {\n             contents = entry.get().source.clone();\n             None\n-        },\n+        }\n         Entry::Vacant(entry) => {\n             let mut fp = try!(File::open(file.clone()).map_err(|err| {\n                 if let FromRedirect(true) = redirect {\n@@ -275,7 +271,7 @@ fn load_file(cache: &mut Cache,\n                 });\n             }\n             maybe\n-        },\n+        }\n     };\n     let base = Url::from_file_path(&file).unwrap();\n     let mut parser = UrlParser::new();\n@@ -286,7 +282,7 @@ fn load_file(cache: &mut Cache,\n             let path = PathBuf::from(redirect_file);\n             load_file(cache, root, path, FromRedirect(true))\n         }\n-        None => Ok((pretty_file, contents))\n+        None => Ok((pretty_file, contents)),\n     }\n }\n \n@@ -307,25 +303,22 @@ fn maybe_redirect(source: &str) -> Option<String> {\n }\n \n fn url_to_file_path(parser: &UrlParser, url: &str) -> Option<(Url, PathBuf)> {\n-    parser.parse(url).ok().and_then(|parsed_url| {\n-        parsed_url.to_file_path().ok().map(|f| (parsed_url, f))\n-    })\n+    parser.parse(url)\n+          .ok()\n+          .and_then(|parsed_url| parsed_url.to_file_path().ok().map(|f| (parsed_url, f)))\n }\n \n-fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str,\n-                                               attr: &str,\n-                                               mut f: F)\n-{\n+fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f: F) {\n     for (i, mut line) in contents.lines().enumerate() {\n         while let Some(j) = line.find(attr) {\n-            let rest = &line[j + attr.len() ..];\n+            let rest = &line[j + attr.len()..];\n             line = rest;\n             let pos_equals = match rest.find(\"=\") {\n                 Some(i) => i,\n                 None => continue,\n             };\n             if rest[..pos_equals].trim_left_matches(\" \") != \"\" {\n-                continue\n+                continue;\n             }\n \n             let rest = &rest[pos_equals + 1..];\n@@ -337,7 +330,7 @@ fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str,\n             let quote_delim = rest.as_bytes()[pos_quote] as char;\n \n             if rest[..pos_quote].trim_left_matches(\" \") != \"\" {\n-                continue\n+                continue;\n             }\n             let rest = &rest[pos_quote + 1..];\n             let url = match rest.find(quote_delim) {"}]}