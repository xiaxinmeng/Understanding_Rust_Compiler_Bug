{"sha": "9fa44a41e67151c5c392e2bd2b3989d74703efec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYTQ0YTQxZTY3MTUxYzVjMzkyZTJiZDJiMzk4OWQ3NDcwM2VmZWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-18T23:40:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-19T00:32:19Z"}, "message": "get pure wrappers approach running", "tree": {"sha": "ca51d17b4108c5ea64d997f04d423cbe90fc956b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca51d17b4108c5ea64d997f04d423cbe90fc956b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fa44a41e67151c5c392e2bd2b3989d74703efec", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa44a41e67151c5c392e2bd2b3989d74703efec", "html_url": "https://github.com/rust-lang/rust/commit/9fa44a41e67151c5c392e2bd2b3989d74703efec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fa44a41e67151c5c392e2bd2b3989d74703efec/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6072ddad33e034a63bddd1ef577492b2842e8136", "url": "https://api.github.com/repos/rust-lang/rust/commits/6072ddad33e034a63bddd1ef577492b2842e8136", "html_url": "https://github.com/rust-lang/rust/commit/6072ddad33e034a63bddd1ef577492b2842e8136"}], "stats": {"total": 217, "additions": 111, "deletions": 106}, "files": [{"sha": "419a7fdc34c29f8aafd1499aaafbcf36806b5fbf", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -26,7 +26,7 @@ type upcalls =\n      dynastack_alloc: ValueRef,\n      dynastack_free: ValueRef,\n      alloc_c_stack: ValueRef,\n-     call_c_stack_shim: ValueRef,\n+     call_shim_on_c_stack: ValueRef,\n      rust_personality: ValueRef};\n \n fn declare_upcalls(targ_cfg: @session::config,\n@@ -85,11 +85,10 @@ fn declare_upcalls(targ_cfg: @session::config,\n                 T_ptr(T_i8())),\n           dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n           alloc_c_stack: d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n-          call_c_stack_shim: d(\"call_c_stack_shim\",\n-                          // first arg is func ptr, but type of func varies,\n-                          // so just call it char* for LLVM\n-                          [T_ptr(T_i8()), T_ptr(T_i8())],\n-                          int_t),\n+          call_shim_on_c_stack: d(\"call_shim_on_c_stack\",\n+                                  // arguments: void *args, void *fn_ptr\n+                                  [T_ptr(T_i8()), T_ptr(T_i8())],\n+                                  int_t),\n           rust_personality: d(\"rust_personality\", [], T_i32())\n          };\n }"}, {"sha": "b821cabb6ae048e3819b221746dfb8c0b6eb74fd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 100, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -183,12 +183,8 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n       }\n       ty::ty_native_fn(abi, args, out) {\n-        if native_abi_requires_pair(abi) {\n-            let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n-            T_fn_pair(cx, nft)\n-        } else {\n-            raw_native_fn_type(cx, sp, args, out)\n-        }\n+        let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n+        T_fn_pair(cx, nft)\n       }\n       ty::ty_obj(meths) { cx.rust_object_type }\n       ty::ty_res(_, sub, tps) {\n@@ -3766,9 +3762,9 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let tcx = bcx_tcx(in_cx);\n     let fn_expr_ty = ty::expr_ty(tcx, f);\n \n-    if check type_is_native_fn_on_c_stack(tcx, fn_expr_ty) {\n-        ret trans_c_stack_native_call(in_cx, f, args, dest);\n-    }\n+//NDM    if check type_is_native_fn_on_c_stack(tcx, fn_expr_ty) {\n+//NDM        ret trans_c_stack_native_call(in_cx, f, args, dest);\n+//NDM    }\n \n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     let f_res = trans_callee(cx, f);\n@@ -3832,63 +3828,6 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     ret next_cx;\n }\n \n-// Translates a native call on the C stack. Calls into the runtime to perform\n-// the stack switching operation. Must be kept in sync with\n-// trans_native_mod().\n-fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n-                             args: [@ast::expr], dest: dest) -> @block_ctxt {\n-    let ccx = bcx_ccx(bcx);\n-    let f_res = trans_callee(bcx, f);\n-    let llfn = f_res.val, bcx = f_res.bcx;\n-    let llfn = BitCast(bcx, llfn, T_ptr(T_fn([], bcx_ccx(bcx).int_type)));\n-\n-    // Translate the callee.\n-    let { params: _, ty: fn_ty } = ty::expr_ty_params_and_ty(bcx_tcx(bcx), f);\n-    let fn_arg_tys = ty::ty_fn_args(bcx_tcx(bcx), fn_ty);\n-    let llargtys = type_of_explicit_args(ccx, f.span, fn_arg_tys);\n-\n-    // Determine return type.\n-    let ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_ty);\n-    check type_has_static_size(ccx, ret_ty);\n-    let llretty = type_of(ccx, f.span, ret_ty);\n-\n-    // Translate arguments.\n-    // n.b.: We must do this before allocating the argument\n-    // bundle in order to avoid problems with nested function calls.\n-    let (to_zero, to_revoke) = ([], []);\n-    let i = 0u, n = vec::len(args);\n-    let llargs = [];\n-    while i < n {\n-        let ty_arg = fn_arg_tys[i];\n-        let arg = args[i];\n-        let llargty = llargtys[i];\n-        let r = trans_arg_expr(bcx, ty_arg, llargty, to_zero, to_revoke, arg);\n-        bcx = r.bcx;\n-        llargs += [r.val];\n-        i += 1u;\n-    }\n-\n-    // Allocate the argument bundle and store arguments.\n-    let llargbundlety = T_struct(llargtys + [llretty]);\n-    let llargbundlesz = llsize_of(ccx, llargbundlety);\n-    let llrawargbundle = Call(bcx, ccx.upcalls.alloc_c_stack,\n-                              [llargbundlesz]);\n-    let llargbundle = PointerCast(bcx, llrawargbundle, T_ptr(llargbundlety));\n-    i = 0u;\n-    while i < n {\n-        store_inbounds(bcx, llargs[i], llargbundle, [0, i as int]);\n-        i += 1u;\n-    }\n-\n-    // Call the upcall function then extract return value from the bundle.\n-    let upcall_fn = ccx.upcalls.call_c_stack_shim;\n-    let llfnptr = PointerCast(bcx, llfn, T_ptr(T_i8()));\n-    Call(bcx, upcall_fn, [llfnptr, llrawargbundle]);\n-    let llres = load_inbounds(bcx, llargbundle, [0, n as int]);\n-    bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n-    ret store_in_dest(bcx, llres, dest);\n-}\n-\n fn zero_and_revoke(bcx: @block_ctxt,\n                    to_zero: [{v: ValueRef, t: ty::t}],\n                    to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n@@ -5354,6 +5293,7 @@ fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n type c_stack_tys = {\n     arg_tys: [TypeRef],\n     ret_ty: TypeRef,\n+    ret_def: bool,\n     base_fn_ty: TypeRef,\n     bundle_ty: TypeRef,\n     shim_fn_ty: TypeRef\n@@ -5364,13 +5304,16 @@ fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n       ty::ty_native_fn(_, arg_tys, ret_ty) {\n+        let tcx = ccx.tcx;\n         let llargtys = type_of_explicit_args(ccx, sp, arg_tys);\n         check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n-        let llretty = T_ptr(type_of_inner(ccx, sp, ret_ty));\n-        let bundle_ty = T_struct(llargtys + [llretty]);\n+        let llretty = type_of_inner(ccx, sp, ret_ty);\n+        let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n         ret @{\n             arg_tys: llargtys,\n             ret_ty: llretty,\n+            ret_def: !ty::type_is_bot(tcx, ret_ty) &&\n+                !ty::type_is_nil(tcx, ret_ty),\n             base_fn_ty: T_fn(llargtys, llretty),\n             bundle_ty: bundle_ty,\n             shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n@@ -5451,8 +5394,15 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n         }\n \n         // Create the call itself and store the return value:\n-        let llretval = CallWithConv(bcx, llbasefn, llargvals, cc);\n-        store_inbounds(bcx, llretval, llargbundle, [0, n as int, 0]);\n+        let llretval = CallWithConv(bcx, llbasefn, llargvals, cc); // r\n+        if tys.ret_def {\n+            // R** llretptr = &args->r;\n+            let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+            // R* llretloc = *llretptr; /* (args->r) */\n+            let llretloc = Load(bcx, llretptr);\n+            // *args->r = r;\n+            Store(bcx, llretval, llretloc);\n+        }\n \n         // Finish up:\n         build_return(bcx);\n@@ -5464,25 +5414,32 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n     fn build_wrap_fn(lcx: @local_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n+                     num_tps: uint,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n-        let fcx = new_fn_ctxt(lcx, span, llshimfn);\n+        let span = native_item.span;\n+        let ccx = lcx_ccx(lcx);\n+        let fcx = new_fn_ctxt(lcx, span, llwrapfn);\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n \n         // Allocate the struct and write the arguments into it.\n         let llargbundle = alloca(bcx, tys.bundle_ty);\n-        let imp = 2u, i = 0u, n = vec::len(tys.arg_tys);\n+        let i = 0u, n = vec::len(tys.arg_tys);\n+        let implicit_args = 2u + num_tps; // ret + env\n         while i < n {\n-            let llargval = llvm::LLVMGetParam(llwrapfn, i + imp);\n+            let llargval = llvm::LLVMGetParam(llwrapfn, i + implicit_args);\n             store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n             i += 1u;\n         }\n-        let llretptr = llvm::LLVMGetParam(llwrapfn, 0);\n+        let llretptr = llvm::LLVMGetParam(llwrapfn, 0u);\n         store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n \n-        // Create call itself:\n-\n+        // Create call itself.\n+        let call_shim_on_c_stack = ccx.upcalls.call_shim_on_c_stack;\n+        let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n+        let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n+        Call(bcx, call_shim_on_c_stack, [llrawargbundle, llshimfnptr]);\n         build_return(bcx);\n         finish_fn(fcx, lltop);\n     }\n@@ -5498,13 +5455,15 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n     for native_item in native_mod.items {\n       alt native_item.node {\n         ast::native_item_ty. {}\n-        ast::native_item_fn(fn_decl, _) {\n+        ast::native_item_fn(fn_decl, tps) {\n+          let span = native_item.span;\n           let id = native_item.id;\n           let tys = c_stack_tys(ccx, span, id);\n           alt ccx.item_ids.find(id) {\n             some(llwrapfn) {\n-              let llshimfn = build_shim_fn(lcx, native_item, cc, tys);\n-              build_wrap_fn(lcx, native_item, tys, llshimfn, llwrapfn);\n+              let llshimfn = build_shim_fn(lcx, native_item, tys, cc);\n+              build_wrap_fn(lcx, native_item, tys,\n+                            vec::len(tps), llshimfn, llwrapfn);\n             }\n \n             none. {\n@@ -5733,21 +5692,6 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-pure fn native_abi_requires_pair(abi: ast::native_abi) -> bool {\n-    alt abi {\n-        ast::native_abi_rust_intrinsic. { ret true; }\n-        ast::native_abi_cdecl. |\n-        ast::native_abi_stdcall. { ret false; }\n-    }\n-}\n-\n-pure fn type_is_native_fn_on_c_stack(tcx: ty::ctxt, t: ty::t) -> bool {\n-    alt ty::struct(tcx, t) {\n-        ty::ty_native_fn(abi, _, _) { ret !native_abi_requires_pair(abi); }\n-        _ { ret false; }\n-    }\n-}\n-\n fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n@@ -5778,19 +5722,24 @@ fn collect_native_item(ccx: @crate_ctxt, i: @ast::native_item, &&pt: [str],\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n         if !ccx.obj_methods.contains_key(i.id) {\n+            let sp = i.span;\n+            let id = i.id;\n+            let node_type = node_id_type(ccx, id);\n             // FIXME NDM abi should come from attr\n-            let abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n+            let abi = ty::ty_fn_abi(ccx.tcx, node_type);\n \n             alt abi {\n               ast::native_abi_rust_intrinsic. {\n                 // For intrinsics: link the function directly to the intrinsic\n                 // function itself.\n                 let num_ty_param = vec::len(tps);\n-                let node_type = node_id_type(ccx, id);\n-                let fn_type = type_of_fn_from_ty(ccx, sp, node_type, num_ty_param);\n-                let ri_name = \"rust_intrinsic_\" + name;\n-                let llnativefn = get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n-                                               lib::llvm::LLVMCCallConv, fn_type);\n+                check returns_non_ty_var(ccx, node_type);\n+                let fn_type = type_of_fn_from_ty(ccx, sp, node_type,\n+                                                 num_ty_param);\n+                let ri_name = \"rust_intrinsic_\" + link_name(i);\n+                let llnativefn = get_extern_fn(\n+                    ccx.externs, ccx.llmod, ri_name,\n+                    lib::llvm::LLVMCCallConv, fn_type);\n                 ccx.item_ids.insert(id, llnativefn);\n                 ccx.item_symbols.insert(id, ri_name);\n               }"}, {"sha": "370c0e7c990533862ebf280bb9013c88fb4bf9eb", "filename": "src/rt/arch/i386/ccall.S", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fi386%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fi386%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fccall.S?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -45,3 +45,20 @@ upcall_call_c_stack_shim:\n     movl %ebp,%esp          // would like to use \"leave\" but it's slower\n     popl %ebp\n     ret\n+\n+#if defined(__APPLE__) || defined(_WIN32)\n+.globl _asm_call_on_stack\n+_asm_call_on_stack:\n+#else\n+.globl asm_call_on_stack\n+asm_call_on_stack:\n+#endif\n+    pushl %ebp\n+    movl %esp,%ebp          // save esp\n+    movl 16(%ebp),%esp      // load new esp\n+    subl $12,%esp           // maintain 16-byte alignment\n+    pushl 8(%ebp)           // push ptr to argument block\n+    calll *12(%ebp)\n+    movl %ebp,%esp          // would like to use \"leave\" but it's slower\n+    popl %ebp\n+    ret"}, {"sha": "fc5eb900a5c7765c7b93f0c182a90a35c812b91b", "filename": "src/rt/arch/i386/context.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fi386%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fi386%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.h?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -29,6 +29,8 @@ struct registers_t {\n   uint32_t eip;\n };\n \n+extern \"C\" void asm_call_on_stack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n+\n class context {\n public:\n   registers_t regs;\n@@ -55,6 +57,10 @@ class context {\n \n     return reinterpret_cast<void *>(top);\n   }\n+\n+  void call_shim_on_c_stack(void *args, void *fn_ptr) {\n+      asm_call_on_stack(args, fn_ptr, regs.esp);\n+  }\n };\n \n #endif"}, {"sha": "943a20279071aa476bc32714aecd442fae83689a", "filename": "src/rt/arch/x86_64/ccall.S", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fccall.S?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -2,6 +2,7 @@\n \n #define ARG0 RUSTRT_ARG0_S\n #define ARG1 RUSTRT_ARG1_S\n+#define ARG2 RUSTRT_ARG2_S\n         \n         .text\n \n@@ -72,3 +73,18 @@ upcall_call_c_stack_shim:\n     mov %rbp,%rsp\n     pop %rbp\n     ret\n+\n+#if defined(__APPLE__) || defined(_WIN32)\n+.globl _asm_call_on_stack\n+_asm_call_on_stack:\n+#else\n+.globl asm_call_on_stack\n+asm_call_on_stack:\n+#endif\n+    push %rbp\n+    mov %rsp,%rbp          // save rsp\n+    mov ARG2,%rsp          // switch stack\n+    call *ARG1             // invoke target address\n+    mov %rbp,%rsp\n+    pop %rbp\n+    ret"}, {"sha": "11c8509274766eab63251730787b1f68173d7e47", "filename": "src/rt/arch/x86_64/context.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.h?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -29,6 +29,8 @@ struct registers_t {\n     uint64_t data[RUSTRT_MAX];\n };\n \n+extern \"C\" void asm_call_on_stack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n+\n class context {\n public:\n     registers_t regs;\n@@ -55,6 +57,10 @@ class context {\n \n         return reinterpret_cast<void *>(top);\n     }\n+\n+    void call_shim_on_c_stack(void *args, void *fn_ptr) {\n+        asm_call_on_stack(args, fn_ptr, regs.data[RUSTRT_RSP]);\n+    }\n };\n \n #endif"}, {"sha": "aac4212cac76b61f6842d4095e4c3758e8f3fcc5", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -219,6 +219,16 @@ upcall_alloc_c_stack(size_t nbytes) {\n     return sched->c_context.alloc_stack(nbytes);\n }\n \n+/**\n+ * Allocates |nbytes| bytes in the C stack and returns a pointer to the start\n+ * of the allocated space.\n+ */\n+extern \"C\" CDECL void\n+upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n+    rust_scheduler *sched = rust_scheduler::get_task()->sched;\n+    sched->c_context.call_shim_on_c_stack(args, fn_ptr);\n+}\n+\n extern \"C\" _Unwind_Reason_Code\n __gxx_personality_v0(int version,\n                      _Unwind_Action actions,"}, {"sha": "c0a9a92ba1bc896253977b9477d9e014b7b6a2c1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/9fa44a41e67151c5c392e2bd2b3989d74703efec/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=9fa44a41e67151c5c392e2bd2b3989d74703efec", "patch": "@@ -74,3 +74,5 @@ upcall_shared_malloc\n upcall_shared_free\n upcall_vec_grow\n upcall_vec_push\n+upcall_call_shim_on_c_stack\n+asm_call_on_stack\n\\ No newline at end of file"}]}