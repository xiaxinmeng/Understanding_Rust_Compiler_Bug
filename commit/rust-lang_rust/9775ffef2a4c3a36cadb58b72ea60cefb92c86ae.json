{"sha": "9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NzVmZmVmMmE0YzNhMzZjYWRiNThiNzJlYTYwY2VmYjkyYzg2YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-30T21:25:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-30T21:25:15Z"}, "message": "Auto merge of #80530 - m-ou-se:rollup-zit69ko, r=m-ou-se\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #78934 (refactor: removing library/alloc/src/vec/mod.rs ignore-tidy-filelength)\n - #79479 (Add `Iterator::intersperse`)\n - #80128 (Edit rustc_ast::ast::FieldPat docs)\n - #80424 (Don't give an error when creating a file for the first time)\n - #80458 (Some Promotion Refactoring)\n - #80488 (Do not create dangling &T in Weak<T>::drop)\n - #80491 (Miri: make size/align_of_val work for dangling raw ptrs)\n - #80495 (Rename kw::Invalid -> kw::Empty)\n - #80513 (Add regression test for #80062)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3cd62fcea1d36df812c14eec010c884c466deb8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cd62fcea1d36df812c14eec010c884c466deb8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "html_url": "https://github.com/rust-lang/rust/commit/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2267046859c9ceb932abc983561d53a117089f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2267046859c9ceb932abc983561d53a117089f6", "html_url": "https://github.com/rust-lang/rust/commit/e2267046859c9ceb932abc983561d53a117089f6"}, {"sha": "8998e31223333cdcf384cf39876d7c4bb533db48", "url": "https://api.github.com/repos/rust-lang/rust/commits/8998e31223333cdcf384cf39876d7c4bb533db48", "html_url": "https://github.com/rust-lang/rust/commit/8998e31223333cdcf384cf39876d7c4bb533db48"}], "stats": {"total": 3211, "additions": 1777, "deletions": 1434}, "files": [{"sha": "cf31e566c384e1c5d52c68c909d7c52b311b5fe4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -630,16 +630,16 @@ impl Pat {\n     }\n }\n \n-/// A single field in a struct pattern\n+/// A single field in a struct pattern.\n ///\n-/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n-/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n-/// except is_shorthand is true\n+/// Patterns like the fields of `Foo { x, ref y, ref mut z }`\n+/// are treated the same as `x: x, y: ref y, z: ref mut z`,\n+/// except when `is_shorthand` is true.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FieldPat {\n-    /// The identifier for the field\n+    /// The identifier for the field.\n     pub ident: Ident,\n-    /// The pattern the field is destructured to\n+    /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n     pub attrs: AttrVec,"}, {"sha": "d17b29089d6949832278459f0979c76a8ba0ac64", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1767,7 +1767,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         self.arena.alloc_from_iter(inputs.iter().map(|param| match param.pat.kind {\n             PatKind::Ident(_, ident, _) => ident,\n-            _ => Ident::new(kw::Invalid, param.pat.span),\n+            _ => Ident::new(kw::Empty, param.pat.span),\n         }))\n     }\n "}, {"sha": "f9eb69bb438156d63b47f3282336562ae46d6ee3", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -184,7 +184,7 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_lifetime(&self, ident: Ident) {\n-        let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Invalid];\n+        let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n             self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }"}, {"sha": "333a396a0b4fc694e9dfd07482e8807fe7eb09f0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -2787,7 +2787,7 @@ impl<'a> State<'a> {\n                     self.print_explicit_self(&eself);\n                 } else {\n                     let invalid = if let PatKind::Ident(_, ident, _) = input.pat.kind {\n-                        ident.name == kw::Invalid\n+                        ident.name == kw::Empty\n                     } else {\n                         false\n                     };"}, {"sha": "d72bfa660e58f855725ff145087abd63b2181af3", "filename": "compiler/rustc_builtin_macros/src/llvm_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -95,7 +95,7 @@ fn parse_inline_asm<'a>(\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(tts.trees().skip(first_colon).collect());\n-    let mut asm = kw::Invalid;\n+    let mut asm = kw::Empty;\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();"}, {"sha": "f1eae605da0181b12967dea276510702b23f894c", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // (after #67586 gets fixed).\n                 None\n             } else {\n-                let name = kw::Invalid;\n+                let name = kw::Empty;\n                 let decl = &self.mir.local_decls[local];\n                 let dbg_var = if full_debug_info {\n                     self.adjusted_span_and_dbg_scope(decl.source_info).map(\n@@ -204,7 +204,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             None\n         } else {\n             Some(match whole_local_var.or(fallback_var) {\n-                Some(var) if var.name != kw::Invalid => var.name.to_string(),\n+                Some(var) if var.name != kw::Empty => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             })\n         };"}, {"sha": "4ba1416be540e8088c48f46fca6e706d2029ce8a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -28,7 +28,7 @@ pub struct Lifetime {\n     pub span: Span,\n \n     /// Either \"`'a`\", referring to a named lifetime definition,\n-    /// or \"``\" (i.e., `kw::Invalid`), for elision placeholders.\n+    /// or \"``\" (i.e., `kw::Empty`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,"}, {"sha": "a8371274f61f8cabf9cc5ca1f655a51db67c4a80", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -868,7 +868,7 @@ impl EarlyLintPass for AnonymousParameters {\n         if let ast::AssocItemKind::Fn(_, ref sig, _, _) = it.kind {\n             for arg in sig.decl.inputs.iter() {\n                 if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n-                    if ident.name == kw::Invalid {\n+                    if ident.name == kw::Empty {\n                         cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n                             let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n "}, {"sha": "ea4f7daec43d198219649ef40fb470093d51ad9a", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -728,7 +728,7 @@ impl<'tcx> LateContext<'tcx> {\n \n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n-    /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;\n+    /// Anonymous scopes such as `extern` imports are matched with `kw::Empty`;\n     /// inherent `impl` blocks are matched with the name of the type.\n     ///\n     /// Instead of using this method, it is often preferable to instead use"}, {"sha": "744fdc83a91ec8d3089ce74ebf634062a7b2a62a", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -132,7 +132,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n impl Collector<'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLib) {\n-        if lib.name.as_ref().map(|&s| s == kw::Invalid).unwrap_or(false) {\n+        if lib.name.as_ref().map(|&s| s == kw::Empty).unwrap_or(false) {\n             match span {\n                 Some(span) => {\n                     struct_span_err!("}, {"sha": "09d5b102103120aebae9b7084e1aaf7f5c055547", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -379,7 +379,7 @@ impl<'hir> Map<'hir> {\n     pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n         self.body(id).params.iter().map(|arg| match arg.pat.kind {\n             PatKind::Binding(_, _, ident, _) => ident,\n-            _ => Ident::new(kw::Invalid, rustc_span::DUMMY_SP),\n+            _ => Ident::new(kw::Empty, rustc_span::DUMMY_SP),\n         })\n     }\n "}, {"sha": "893572785f76b0dde108da22218cc9de28b4dfb5", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1481,7 +1481,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n         let name = disambiguated_data.data.name();\n-        if name != DefPathDataName::Named(kw::Invalid) {\n+        if name != DefPathDataName::Named(kw::Empty) {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n@@ -1608,14 +1608,14 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name != kw::Invalid && data.name != kw::UnderscoreLifetime\n+                data.name != kw::Empty && data.name != kw::UnderscoreLifetime\n             }\n \n             ty::ReLateBound(_, ty::BoundRegion { kind: br })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != kw::Invalid && name != kw::UnderscoreLifetime {\n+                    if name != kw::Empty && name != kw::UnderscoreLifetime {\n                         return true;\n                     }\n                 }\n@@ -1685,7 +1685,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name != kw::Invalid {\n+                if data.name != kw::Empty {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n@@ -1694,7 +1694,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != kw::Invalid && name != kw::UnderscoreLifetime {\n+                    if name != kw::Empty && name != kw::UnderscoreLifetime {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }"}, {"sha": "58858c09f44ef0079afd6c30465995a7e1a07631", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -141,9 +141,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             sym::min_align_of_val | sym::size_of_val => {\n-                let place = self.deref_operand(args[0])?;\n+                // Avoid `deref_operand` -- this is not a deref, the ptr does not have to be\n+                // dereferencable!\n+                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let (size, align) = self\n-                    .size_and_align_of(place.meta, place.layout)?\n+                    .size_and_align_of_mplace(place)?\n                     .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n \n                 let result = match intrinsic_name {"}, {"sha": "423d1270ac8652709ecfe67f1474c65f7439a421", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -391,7 +391,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // Make sure this is dereferenceable and all.\n         let size_and_align = try_validation!(\n-            self.ecx.size_and_align_of(place.meta, place.layout),\n+            self.ecx.size_and_align_of_mplace(place),\n             self.path,\n             err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n         );"}, {"sha": "ea92e23e9bffb6e03fe4a59ec07964720c39a425", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -90,7 +90,7 @@ pub enum TempState {\n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n         debug!(\"is_promotable: self={:?}\", self);\n-        matches!(self, TempState::Defined { .. } )\n+        matches!(self, TempState::Defined { .. })\n     }\n }\n \n@@ -309,50 +309,26 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, Rvalue::Ref(_, kind, place))) => {\n-                        match kind {\n-                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n-\n-                            // FIXME(eddyb) these aren't promoted here but *could*\n-                            // be promoted as part of a larger value because\n-                            // `validate_rvalue`  doesn't check them, need to\n-                            // figure out what is the intended behavior.\n-                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n-                        }\n-\n                         // We can only promote interior borrows of promotable temps (non-temps\n                         // don't get promoted anyway).\n                         self.validate_local(place.local)?;\n \n+                        // The reference operation itself must be promotable.\n+                        // (Needs to come after `validate_local` to avoid ICEs.)\n+                        self.validate_ref(*kind, place)?;\n+\n+                        // We do not check all the projections (they do not get promoted anyway),\n+                        // but we do stay away from promoting anything involving a dereference.\n                         if place.projection.contains(&ProjectionElem::Deref) {\n                             return Err(Unpromotable);\n                         }\n-                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n-                            return Err(Unpromotable);\n-                        }\n \n-                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n-                        let has_mut_interior =\n-                            self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                        if has_mut_interior {\n+                        // We cannot promote things that need dropping, since the promoted value\n+                        // would not get dropped.\n+                        if self.qualif_local::<qualifs::NeedsDrop>(place.local) {\n                             return Err(Unpromotable);\n                         }\n \n-                        if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n-\n-                            // In theory, any zero-sized value could be borrowed\n-                            // mutably without consequences. However, only &mut []\n-                            // is allowed right now.\n-                            if let ty::Array(_, len) = ty.kind() {\n-                                match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) => {}\n-                                    _ => return Err(Unpromotable),\n-                                }\n-                            } else {\n-                                return Err(Unpromotable);\n-                            }\n-                        }\n-\n                         Ok(())\n                     }\n                     _ => bug!(),\n@@ -572,58 +548,115 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n-                    // ptr-to-int casts are not possible in consts and thus not promotable\n+    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+        match kind {\n+            // Reject these borrow types just to be safe.\n+            // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n+            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+\n+            BorrowKind::Shared => {\n+                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n+                if has_mut_interior {\n                     return Err(Unpromotable);\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n-                    assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n-                    );\n+            BorrowKind::Mut { .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n \n-                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                // In theory, any zero-sized value could be borrowed\n+                // mutably without consequences. However, only &mut []\n+                // is allowed right now.\n+                if let ty::Array(_, len) = ty.kind() {\n+                    match len.try_eval_usize(self.tcx, self.param_env) {\n+                        Some(0) => {}\n+                        _ => return Err(Unpromotable),\n+                    }\n+                } else {\n                     return Err(Unpromotable);\n                 }\n             }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n-\n-            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n-            _ => {}\n         }\n \n+        Ok(())\n+    }\n+\n+    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match rvalue {\n-            Rvalue::ThreadLocalRef(_) => Err(Unpromotable),\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, operand) => {\n+                self.validate_operand(operand)?;\n+            }\n \n-            Rvalue::NullaryOp(..) => Ok(()),\n+            Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n+                self.validate_place(place.as_ref())?\n+            }\n \n-            Rvalue::Discriminant(place) | Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+            Rvalue::ThreadLocalRef(_) => return Err(Unpromotable),\n \n-            Rvalue::Use(operand)\n-            | Rvalue::Repeat(operand, _)\n-            | Rvalue::UnaryOp(_, operand)\n-            | Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n+            Rvalue::Cast(kind, operand, cast_ty) => {\n+                if matches!(kind, CastKind::Misc) {\n+                    let operand_ty = operand.ty(self.body, self.tcx);\n+                    let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n+                        // ptr-to-int casts are not possible in consts and thus not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    // int-to-ptr casts are fine, they just use the integer value at pointer type.\n+                }\n+\n+                self.validate_operand(operand)?;\n+            }\n+\n+            Rvalue::BinaryOp(op, lhs, rhs) | Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let op = *op;\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n+                    // raw pointer operations are not allowed inside consts and thus not promotable\n+                    assert!(matches!(\n+                        op,\n+                        BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                    ));\n+                    return Err(Unpromotable);\n+                }\n+\n+                match op {\n+                    // FIXME: reject operations that can fail -- namely, division and modulo.\n+                    BinOp::Eq\n+                    | BinOp::Ne\n+                    | BinOp::Le\n+                    | BinOp::Lt\n+                    | BinOp::Ge\n+                    | BinOp::Gt\n+                    | BinOp::Offset\n+                    | BinOp::Add\n+                    | BinOp::Sub\n+                    | BinOp::Mul\n+                    | BinOp::Div\n+                    | BinOp::Rem\n+                    | BinOp::BitXor\n+                    | BinOp::BitAnd\n+                    | BinOp::BitOr\n+                    | BinOp::Shl\n+                    | BinOp::Shr => {}\n+                }\n \n-            Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n                 self.validate_operand(lhs)?;\n-                self.validate_operand(rhs)\n+                self.validate_operand(rhs)?;\n             }\n \n+            Rvalue::NullaryOp(op, _) => match op {\n+                NullOp::Box => return Err(Unpromotable),\n+                NullOp::SizeOf => {}\n+            },\n+\n             Rvalue::AddressOf(_, place) => {\n                 // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n                 // no problem, only using it is.\n@@ -636,53 +669,36 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         });\n                     }\n                 }\n-                Err(Unpromotable)\n+                return Err(Unpromotable);\n             }\n \n             Rvalue::Ref(_, kind, place) => {\n-                if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n-\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now.\n-                    if let ty::Array(_, len) = ty.kind() {\n-                        match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) => {}\n-                            _ => return Err(Unpromotable),\n-                        }\n-                    } else {\n-                        return Err(Unpromotable);\n-                    }\n-                }\n-\n                 // Special-case reborrows to be more like a copy of the reference.\n-                let mut place = place.as_ref();\n-                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                let mut place_simplified = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n+                    let base_ty =\n+                        Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place = PlaceRef { local: place.local, projection: proj_base };\n+                        place_simplified =\n+                            PlaceRef { local: place_simplified.local, projection: proj_base };\n                     }\n                 }\n \n-                self.validate_place(place)?;\n-\n-                let has_mut_interior = self.qualif_local::<qualifs::HasMutInterior>(place.local);\n-                if has_mut_interior {\n-                    return Err(Unpromotable);\n-                }\n+                self.validate_place(place_simplified)?;\n \n-                Ok(())\n+                // Check that the reference is fine (using the original place!).\n+                // (Needs to come after `validate_place` to avoid ICEs.)\n+                self.validate_ref(*kind, place)?;\n             }\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for o in operands {\n                     self.validate_operand(o)?;\n                 }\n-\n-                Ok(())\n             }\n         }\n+\n+        Ok(())\n     }\n \n     fn validate_call("}, {"sha": "996615995259d58bf77b17dd8d987516585a5394", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -854,7 +854,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let mut mutability = Mutability::Not;\n \n                     // FIXME(project-rfc-2229#8): Store more precise information\n-                    let mut name = kw::Invalid;\n+                    let mut name = kw::Empty;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;"}, {"sha": "c6669f0468296cb3217fdf2ed1c083f422b26ac6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -494,7 +494,7 @@ impl<'a> Parser<'a> {\n         let polarity = self.parse_polarity();\n \n         // Parse both types and traits as a type, then reinterpret if necessary.\n-        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n+        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Empty, span));\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n             let span = self.prev_token.span.between(self.token.span);\n@@ -1699,7 +1699,7 @@ impl<'a> Parser<'a> {\n                 // Skip every token until next possible arg or end.\n                 p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n                 // Create a placeholder argument for proper arg count (issue #34264).\n-                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_token.span))))\n+                Ok(dummy_arg(Ident::new(kw::Empty, lo.to(p.prev_token.span))))\n             });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n             first_param = false;\n@@ -1759,7 +1759,7 @@ impl<'a> Parser<'a> {\n             }\n             match ty {\n                 Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_token.span);\n+                    let ident = Ident::new(kw::Empty, self.prev_token.span);\n                     let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)"}, {"sha": "fcea1b29ec367528f47b0d429bd3694caa1a47b8", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1382,7 +1382,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name == kw::Invalid {\n+        if name == kw::Empty {\n             return None;\n         }\n         let name: &str = &name.as_str();"}, {"sha": "1bcfdf0faf66a8850000c99443a9daf909090507", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -957,7 +957,7 @@ impl<'tcx> NamePrivacyVisitor<'tcx> {\n         in_update_syntax: bool,\n     ) {\n         // definition of the field\n-        let ident = Ident::new(kw::Invalid, use_ctxt);\n+        let ident = Ident::new(kw::Empty, use_ctxt);\n         let current_hir = self.current_item.unwrap();\n         let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {"}, {"sha": "c5f783e84a91ec610c20166c8ccba9c13ac7242e", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let field_names = vdata\n             .fields()\n             .iter()\n-            .map(|field| respan(field.span, field.ident.map_or(kw::Invalid, |ident| ident.name)))\n+            .map(|field| respan(field.span, field.ident.map_or(kw::Empty, |ident| ident.name)))\n             .collect();\n         self.insert_field_names(def_id, field_names);\n     }\n@@ -527,7 +527,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n                         // in `source` breaks `src/test/ui/imports/import-crate-var.rs`,\n                         // while the current crate doesn't have a valid `crate_name`.\n-                        if crate_name != kw::Invalid {\n+                        if crate_name != kw::Empty {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident { name: kw::PathRoot, span: source.ident.span },\n@@ -656,7 +656,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &'b Item) {\n-        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Invalid {\n+        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Empty {\n             // Fake crate root item from expand.\n             return;\n         }"}, {"sha": "48bce88439424524a678b10dd90abe0c60a6893e", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         // information we encapsulate into, the better\n         let def_data = match &i.kind {\n             ItemKind::Impl { .. } => DefPathData::Impl,\n-            ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n+            ItemKind::Mod(..) if i.ident.name == kw::Empty => {\n                 // Fake crate root item from expand.\n                 return visit::walk_item(self, i);\n             }"}, {"sha": "dd1874debbd96afe9a2c55def400e5925c084371", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1639,7 +1639,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n \n         // Record as bound if it's valid:\n-        let ident_valid = ident.name != kw::Invalid;\n+        let ident_valid = ident.name != kw::Empty;\n         if ident_valid {\n             bindings.last_mut().unwrap().1.insert(ident);\n         }"}, {"sha": "ca30d90e6ad1d6a9c228ebe172d8e3030e3a08aa", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1182,12 +1182,12 @@ impl<'a> Resolver<'a> {\n     ) -> Resolver<'a> {\n         let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n         let root_def_id = root_local_def_id.to_def_id();\n-        let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n+        let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n-        let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n+        let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty);\n         let empty_module = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: true,\n             ..ModuleData::new(\n@@ -1797,7 +1797,7 @@ impl<'a> Resolver<'a> {\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n-        if ident.name == kw::Invalid {\n+        if ident.name == kw::Empty {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n         let (general_span, normalized_span) = if ident.name == kw::SelfUpper {"}, {"sha": "5ad7c83ca36afd8b140730a2640bf503632e84d7", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -160,7 +160,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         hygiene::update_dollar_crate_names(|ctxt| {\n             let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));\n             match self.resolve_crate_root(ident).kind {\n-                ModuleKind::Def(.., name) if name != kw::Invalid => name,\n+                ModuleKind::Def(.., name) if name != kw::Empty => name,\n                 _ => kw::Crate,\n             }\n         });"}, {"sha": "fdc0d225bb82d9f1f98b06cfc5052a5a5a88b500", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1065,7 +1065,7 @@ pub fn decode_syntax_context<\n             parent: SyntaxContext::root(),\n             opaque: SyntaxContext::root(),\n             opaque_and_semitransparent: SyntaxContext::root(),\n-            dollar_crate_name: kw::Invalid,\n+            dollar_crate_name: kw::Empty,\n         });\n         let mut ctxts = outer_ctxts.lock();\n         let new_len = raw_id as usize + 1;\n@@ -1092,7 +1092,7 @@ pub fn decode_syntax_context<\n             ctxt_data,\n         );\n         // Make sure nothing weird happening while `decode_data` was running\n-        assert_eq!(dummy.dollar_crate_name, kw::Invalid);\n+        assert_eq!(dummy.dollar_crate_name, kw::Empty);\n     });\n \n     Ok(new_ctxt)"}, {"sha": "7ca2ff4f1fb7177144a6f63b656d612b6b4f2556", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -25,7 +25,7 @@ symbols! {\n     Keywords {\n         // Special reserved identifiers used internally for elided lifetimes,\n         // unnamed method parameters, crate root module, error recovery etc.\n-        Invalid:            \"\",\n+        Empty:              \"\",\n         PathRoot:           \"{{root}}\",\n         DollarCrate:        \"$crate\",\n         Underscore:         \"_\",\n@@ -1273,7 +1273,7 @@ impl Ident {\n \n     #[inline]\n     pub fn invalid() -> Ident {\n-        Ident::with_dummy_span(kw::Invalid)\n+        Ident::with_dummy_span(kw::Empty)\n     }\n \n     /// Maps a string to an identifier with a dummy span.\n@@ -1464,7 +1464,7 @@ impl Symbol {\n     }\n \n     pub fn is_empty(self) -> bool {\n-        self == kw::Invalid\n+        self == kw::Empty\n     }\n \n     /// This method is supposed to be used in error messages, so it's expected to be\n@@ -1648,7 +1648,7 @@ impl Symbol {\n \n     /// Returns `true` if this symbol can be a raw identifier.\n     pub fn can_be_raw(self) -> bool {\n-        self != kw::Invalid && self != kw::Underscore && !self.is_path_segment_keyword()\n+        self != kw::Empty && self != kw::Underscore && !self.is_path_segment_keyword()\n     }\n }\n "}, {"sha": "93eb2cfc72a8059d903db58ec5b0bf81f223a764", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -883,7 +883,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Ok(method)\n             }\n             Err(error) => {\n-                if segment.ident.name != kw::Invalid {\n+                if segment.ident.name != kw::Empty {\n                     self.report_extended_method_error(segment, span, args, rcvr_t, error);\n                 }\n                 Err(())\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return field_ty;\n         }\n \n-        if field.name == kw::Invalid {\n+        if field.name == kw::Empty {\n         } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n             self.ban_take_value_of_method(expr, expr_t, field);\n         } else if !expr_t.is_primitive_ty() {"}, {"sha": "2a8b77da44fc461530d769aae82aa143b53dff93", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -914,7 +914,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n                 _ => Err(ErrorReported),\n             };\n-            if item_name.name != kw::Invalid {\n+            if item_name.name != kw::Empty {\n                 if let Some(mut e) = self.report_method_error(\n                     span,\n                     ty,"}, {"sha": "57df28a15c85aa6dcdd6ecbd305c7b46c5422f61", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -2042,7 +2042,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // the strong pointers have disappeared.\n         if inner.weak() == 0 {\n             unsafe {\n-                Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                Global.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()));\n             }\n         }\n     }"}, {"sha": "85c0a9f085729a33b8e12d5c2147086c7a17c9ec", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1927,7 +1927,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n             acquire!(inner.weak);\n-            unsafe { Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n+            unsafe { Global.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr())) }\n         }\n     }\n }"}, {"sha": "73d15d3064789356264705c5ed125704bdacd2ea", "filename": "library/alloc/src/vec/cow.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,35 @@\n+use crate::borrow::Cow;\n+use core::iter::FromIterator;\n+\n+use super::Vec;\n+\n+#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n+    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n+        Cow::Borrowed(s)\n+    }\n+}\n+\n+#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n+impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n+    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n+        Cow::Owned(v)\n+    }\n+}\n+\n+#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n+impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n+    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n+        Cow::Borrowed(v.as_slice())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> FromIterator<T> for Cow<'a, [T]>\n+where\n+    T: Clone,\n+{\n+    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}"}, {"sha": "fb32d144f872c001b2f4c0ad4a626b248a27d8c1", "filename": "library/alloc/src/vec/drain.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,155 @@\n+use crate::alloc::{Allocator, Global};\n+use core::fmt;\n+use core::iter::{FusedIterator, TrustedLen};\n+use core::mem::{self};\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+\n+use super::Vec;\n+\n+/// A draining iterator for `Vec<T>`.\n+///\n+/// This `struct` is created by [`Vec::drain`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::Drain<_> = v.drain(..);\n+/// ```\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub struct Drain<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    /// Index of tail to preserve\n+    pub(super) tail_start: usize,\n+    /// Length of tail\n+    pub(super) tail_len: usize,\n+    /// Current remaining range to remove\n+    pub(super) iter: slice::Iter<'a, T>,\n+    pub(super) vec: NonNull<Vec<T, A>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n+    }\n+}\n+\n+impl<'a, T, A: Allocator> Drain<'a, T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.iter.as_slice()\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        unsafe { self.vec.as_ref().allocator() }\n+    }\n+}\n+\n+#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n+    fn drop(&mut self) {\n+        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n+        /// un-`Drain`ed elements to restore the original `Vec`.\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n+\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we have below. If the loop already finished, this does\n+                // nothing.\n+                self.0.for_each(drop);\n+\n+                if self.0.tail_len > 0 {\n+                    unsafe {\n+                        let source_vec = self.0.vec.as_mut();\n+                        // memmove back untouched tail, update to new length\n+                        let start = source_vec.len();\n+                        let tail = self.0.tail_start;\n+                        if tail != start {\n+                            let src = source_vec.as_ptr().add(tail);\n+                            let dst = source_vec.as_mut_ptr().add(start);\n+                            ptr::copy(src, dst, self.0.tail_len);\n+                        }\n+                        source_vec.set_len(start + self.0.tail_len);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // exhaust self first\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n+        DropGuard(self);\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}, {"sha": "3c37c92ae44b0cbdbe68a8c0cea948afbaa352ef", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,143 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::Vec;\n+\n+/// An iterator which uses a closure to determine if an element should be removed.\n+///\n+/// This struct is created by [`Vec::drain_filter`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(drain_filter)]\n+///\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n+/// ```\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+pub struct DrainFilter<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    pub(super) vec: &'a mut Vec<T, A>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n+    pub(super) idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n+    pub(super) del: usize,\n+    /// The original length of `vec` prior to draining.\n+    pub(super) old_len: usize,\n+    /// The filter test predicate.\n+    pub(super) pred: F,\n+    /// A flag that indicates a panic has occurred in the filter test predicate.\n+    /// This is used as a hint in the drop implementation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    pub(super) panic_flag: bool,\n+}\n+\n+impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.vec.allocator()\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx < self.old_len {\n+                let i = self.idx;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    let del = self.del;\n+                    let src: *const T = &v[i];\n+                    let dst: *mut T = &mut v[i - del];\n+                    ptr::copy_nonoverlapping(src, dst, 1);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F, A>,\n+        }\n+\n+        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item prior to a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop { drain: self };\n+\n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n+        }\n+    }\n+}"}, {"sha": "354d25c2389fbd515a541ff274de48200b4a6f66", "filename": "library/alloc/src/vec/in_place_drop.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,24 @@\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+// A helper struct for in-place iteration that drops the destination slice of iteration,\n+// i.e. the head. The source slice (the tail) is dropped by IntoIter.\n+pub(super) struct InPlaceDrop<T> {\n+    pub(super) inner: *mut T,\n+    pub(super) dst: *mut T,\n+}\n+\n+impl<T> InPlaceDrop<T> {\n+    fn len(&self) -> usize {\n+        unsafe { self.dst.offset_from(self.inner) as usize }\n+    }\n+}\n+\n+impl<T> Drop for InPlaceDrop<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()));\n+        }\n+    }\n+}"}, {"sha": "f131d06bb18f9ded903cd553f506027c858c0d54", "filename": "library/alloc/src/vec/into_iter.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,283 @@\n+use crate::alloc::{Allocator, Global};\n+use crate::raw_vec::RawVec;\n+use core::fmt;\n+use core::intrinsics::arith_offset;\n+use core::iter::{FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess};\n+use core::marker::PhantomData;\n+use core::mem::{self};\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+\n+/// An iterator that moves out of a vector.\n+///\n+/// This `struct` is created by the `into_iter` method on [`Vec`](super::Vec)\n+/// (provided by the [`IntoIterator`] trait).\n+///\n+/// # Example\n+///\n+/// ```\n+/// let v = vec![0, 1, 2];\n+/// let iter: std::vec::IntoIter<_> = v.into_iter();\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    pub(super) buf: NonNull<T>,\n+    pub(super) phantom: PhantomData<T>,\n+    pub(super) cap: usize,\n+    pub(super) alloc: A,\n+    pub(super) ptr: *const T,\n+    pub(super) end: *const T,\n+}\n+\n+#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n+    }\n+}\n+\n+impl<T, A: Allocator> IntoIter<T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = into_iter.next().unwrap();\n+    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n+    }\n+\n+    /// Returns the remaining items of this iterator as a mutable slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// into_iter.as_mut_slice()[2] = 'z';\n+    /// assert_eq!(into_iter.next().unwrap(), 'a');\n+    /// assert_eq!(into_iter.next().unwrap(), 'b');\n+    /// assert_eq!(into_iter.next().unwrap(), 'z');\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        unsafe { &mut *self.as_raw_mut_slice() }\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        &self.alloc\n+    }\n+\n+    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n+        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n+    }\n+\n+    pub(super) fn drop_remaining(&mut self) {\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice());\n+        }\n+        self.ptr = self.end;\n+    }\n+\n+    /// Relinquishes the backing allocation, equivalent to\n+    /// `ptr::write(&mut self, Vec::new().into_iter())`\n+    pub(super) fn forget_allocation(&mut self) {\n+        self.cap = 0;\n+        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n+        self.ptr = self.buf.as_ptr();\n+        self.end = self.buf.as_ptr();\n+    }\n+}\n+\n+#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n+impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        if self.ptr as *const _ == self.end {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // purposefully don't use 'ptr.offset' because for\n+            // vectors with 0-size elements this would return the\n+            // same pointer.\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            let old = self.ptr;\n+            self.ptr = unsafe { self.ptr.offset(1) };\n+\n+            Some(unsafe { ptr::read(old) })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = if mem::size_of::<T>() == 0 {\n+            (self.end as usize).wrapping_sub(self.ptr as usize)\n+        } else {\n+            unsafe { self.end.offset_from(self.ptr) as usize }\n+        };\n+        (exact, Some(exact))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must guarantee that `i` is in bounds of the\n+        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n+        // is guaranteed to pointer to an element of the `Vec<T>` and\n+        // thus guaranteed to be valid to dereference.\n+        //\n+        // Also note the implementation of `Self: TrustedRandomAccess` requires\n+        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n+        // them for `Drop`.\n+        unsafe {\n+            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.end == self.ptr {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // See above for why 'ptr.offset' isn't used\n+            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            self.end = unsafe { self.end.offset(-1) };\n+\n+            Some(unsafe { ptr::read(self.end) })\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n+\n+#[doc(hidden)]\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n+// and thus we can't implement drop-handling\n+unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n+where\n+    T: Copy,\n+{\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n+impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n+    #[cfg(not(test))]\n+    fn clone(&self) -> Self {\n+        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n+    }\n+    #[cfg(test)]\n+    fn clone(&self) -> Self {\n+        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n+    fn drop(&mut self) {\n+        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n+\n+        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    // `IntoIter::alloc` is not used anymore after this\n+                    let alloc = ptr::read(&self.0.alloc);\n+                    // RawVec handles deallocation\n+                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n+                }\n+            }\n+        }\n+\n+        let guard = DropGuard(self);\n+        // destroy the remaining elements\n+        unsafe {\n+            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n+        }\n+        // now `guard` will be dropped and do the rest\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n+    type Source = Self;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n+        self\n+    }\n+}\n+\n+// internal helper trait for in-place iteration specialization.\n+#[rustc_specialization_trait]\n+pub(crate) trait AsIntoIter {\n+    type Item;\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n+}\n+\n+impl<T> AsIntoIter for IntoIter<T> {\n+    type Item = T;\n+\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n+        self\n+    }\n+}"}, {"sha": "b5739970b6ea469306eef375d3fe223f49363f10", "filename": "library/alloc/src/vec/is_zero.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,71 @@\n+use crate::boxed::Box;\n+\n+#[rustc_specialization_trait]\n+pub(super) unsafe trait IsZero {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n+    ($t:ty, $is_zero:expr) => {\n+        unsafe impl IsZero for $t {\n+            #[inline]\n+            fn is_zero(&self) -> bool {\n+                $is_zero(*self)\n+            }\n+        }\n+    };\n+}\n+\n+impl_is_zero!(i16, |x| x == 0);\n+impl_is_zero!(i32, |x| x == 0);\n+impl_is_zero!(i64, |x| x == 0);\n+impl_is_zero!(i128, |x| x == 0);\n+impl_is_zero!(isize, |x| x == 0);\n+\n+impl_is_zero!(u16, |x| x == 0);\n+impl_is_zero!(u32, |x| x == 0);\n+impl_is_zero!(u64, |x| x == 0);\n+impl_is_zero!(u128, |x| x == 0);\n+impl_is_zero!(usize, |x| x == 0);\n+\n+impl_is_zero!(bool, |x| x == false);\n+impl_is_zero!(char, |x| x == '\\0');\n+\n+impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n+impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n+\n+unsafe impl<T> IsZero for *const T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n+\n+unsafe impl<T> IsZero for *mut T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n+\n+// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n+// variant are padding in the `None` variant, so ignoring them and\n+// zero-initializing instead is ok.\n+// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n+// `SpecFromElem`.\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}"}, {"sha": "2a83eb33fe3eca2979cc530f5684bf5741944ff9", "filename": "library/alloc/src/vec/mod.rs", "status": "renamed", "additions": 56, "deletions": 1268, "changes": 1324, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! A contiguous growable array type with heap-allocated contents, written\n //! `Vec<T>`.\n //!\n@@ -59,9 +58,7 @@ use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{\n-    FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess,\n-};\n+use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -74,6 +71,61 @@ use crate::boxed::Box;\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n \n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub use self::drain_filter::DrainFilter;\n+\n+mod drain_filter;\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub use self::splice::Splice;\n+\n+mod splice;\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub use self::drain::Drain;\n+\n+mod drain;\n+\n+mod cow;\n+\n+pub(crate) use self::into_iter::AsIntoIter;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::into_iter::IntoIter;\n+\n+mod into_iter;\n+\n+use self::is_zero::IsZero;\n+\n+mod is_zero;\n+\n+mod source_iter_marker;\n+\n+mod partial_eq;\n+\n+use self::spec_from_elem::SpecFromElem;\n+\n+mod spec_from_elem;\n+\n+use self::set_len_on_drop::SetLenOnDrop;\n+\n+mod set_len_on_drop;\n+\n+use self::in_place_drop::InPlaceDrop;\n+\n+mod in_place_drop;\n+\n+use self::spec_from_iter_nested::SpecFromIterNested;\n+\n+mod spec_from_iter_nested;\n+\n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n+use self::spec_extend::SpecExtend;\n+\n+mod spec_extend;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -1876,35 +1928,6 @@ impl<T, A: Allocator> Vec<T, A> {\n     }\n }\n \n-// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n-//\n-// The idea is: The length field in SetLenOnDrop is a local variable\n-// that the optimizer will see does not alias with any stores through the Vec's data\n-// pointer. This is a workaround for alias analysis issue #32155\n-struct SetLenOnDrop<'a> {\n-    len: &'a mut usize,\n-    local_len: usize,\n-}\n-\n-impl<'a> SetLenOnDrop<'a> {\n-    #[inline]\n-    fn new(len: &'a mut usize) -> Self {\n-        SetLenOnDrop { local_len: *len, len }\n-    }\n-\n-    #[inline]\n-    fn increment_len(&mut self, increment: usize) {\n-        self.local_len += increment;\n-    }\n-}\n-\n-impl Drop for SetLenOnDrop<'_> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        *self.len = self.local_len;\n-    }\n-}\n-\n impl<T: PartialEq, A: Allocator> Vec<T, A> {\n     /// Removes consecutive repeated elements in the vector according to the\n     /// [`PartialEq`] trait implementation.\n@@ -1964,131 +1987,6 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n     <T as SpecFromElem>::from_elem(elem, n, alloc)\n }\n \n-// Specialization trait used for Vec::from_elem\n-trait SpecFromElem: Sized {\n-    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n-}\n-\n-impl<T: Clone> SpecFromElem for T {\n-    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n-        let mut v = Vec::with_capacity_in(n, alloc);\n-        v.extend_with(n, ExtendElement(elem));\n-        v\n-    }\n-}\n-\n-impl SpecFromElem for i8 {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n-        if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        unsafe {\n-            let mut v = Vec::with_capacity_in(n, alloc);\n-            ptr::write_bytes(v.as_mut_ptr(), elem as u8, n);\n-            v.set_len(n);\n-            v\n-        }\n-    }\n-}\n-\n-impl SpecFromElem for u8 {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n-        if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        unsafe {\n-            let mut v = Vec::with_capacity_in(n, alloc);\n-            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n-            v.set_len(n);\n-            v\n-        }\n-    }\n-}\n-\n-impl<T: Clone + IsZero> SpecFromElem for T {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n-        if elem.is_zero() {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        let mut v = Vec::with_capacity_in(n, alloc);\n-        v.extend_with(n, ExtendElement(elem));\n-        v\n-    }\n-}\n-\n-#[rustc_specialization_trait]\n-unsafe trait IsZero {\n-    /// Whether this value is zero\n-    fn is_zero(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_zero {\n-    ($t:ty, $is_zero:expr) => {\n-        unsafe impl IsZero for $t {\n-            #[inline]\n-            fn is_zero(&self) -> bool {\n-                $is_zero(*self)\n-            }\n-        }\n-    };\n-}\n-\n-impl_is_zero!(i16, |x| x == 0);\n-impl_is_zero!(i32, |x| x == 0);\n-impl_is_zero!(i64, |x| x == 0);\n-impl_is_zero!(i128, |x| x == 0);\n-impl_is_zero!(isize, |x| x == 0);\n-\n-impl_is_zero!(u16, |x| x == 0);\n-impl_is_zero!(u32, |x| x == 0);\n-impl_is_zero!(u64, |x| x == 0);\n-impl_is_zero!(u128, |x| x == 0);\n-impl_is_zero!(usize, |x| x == 0);\n-\n-impl_is_zero!(bool, |x| x == false);\n-impl_is_zero!(char, |x| x == '\\0');\n-\n-impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n-impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n-\n-unsafe impl<T> IsZero for *const T {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        (*self).is_null()\n-    }\n-}\n-\n-unsafe impl<T> IsZero for *mut T {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        (*self).is_null()\n-    }\n-}\n-\n-// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n-// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n-// variant are padding in the `None` variant, so ignoring them and\n-// zero-initializing instead is ok.\n-// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n-// `SpecFromElem`.\n-\n-unsafe impl<T: ?Sized> IsZero for Option<&T> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n-unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n@@ -2263,351 +2161,6 @@ impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     }\n }\n \n-/// Specialization trait used for Vec::from_iter\n-///\n-/// ## The delegation graph:\n-///\n-/// ```text\n-/// +-------------+\n-/// |FromIterator |\n-/// +-+-----------+\n-///   |\n-///   v\n-/// +-+-------------------------------+  +---------------------+\n-/// |SpecFromIter                  +---->+SpecFromIterNested   |\n-/// |where I:                      |  |  |where I:             |\n-/// |  Iterator (default)----------+  |  |  Iterator (default) |\n-/// |  vec::IntoIter               |  |  |  TrustedLen         |\n-/// |  SourceIterMarker---fallback-+  |  |                     |\n-/// |  slice::Iter                    |  |                     |\n-/// |  Iterator<Item = &Clone>        |  +---------------------+\n-/// +---------------------------------+\n-/// ```\n-trait SpecFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n-}\n-\n-/// Another specialization trait for Vec::from_iter\n-/// necessary to manually prioritize overlapping specializations\n-/// see [`SpecFromIter`] for details.\n-trait SpecFromIterNested<T, I> {\n-    fn from_iter(iter: I) -> Self;\n-}\n-\n-impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Unroll the first iteration, as the vector is going to be\n-        // expanded on this iteration in every case when the iterable is not\n-        // empty, but the loop in extend_desugared() is not going to see the\n-        // vector being full in the few subsequent loop iterations.\n-        // So we get better branch prediction.\n-        let mut vector = match iterator.next() {\n-            None => return Vec::new(),\n-            Some(element) => {\n-                let (lower, _) = iterator.size_hint();\n-                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n-                unsafe {\n-                    ptr::write(vector.as_mut_ptr(), element);\n-                    vector.set_len(1);\n-                }\n-                vector\n-            }\n-        };\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n-        vector\n-    }\n-}\n-\n-impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n-where\n-    I: TrustedLen<Item = T>,\n-{\n-    fn from_iter(iterator: I) -> Self {\n-        let mut vector = match iterator.size_hint() {\n-            (_, Some(upper)) => Vec::with_capacity(upper),\n-            _ => Vec::new(),\n-        };\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vector.spec_extend(iterator);\n-        vector\n-    }\n-}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIterNested::from_iter(iterator)\n-    }\n-}\n-\n-// A helper struct for in-place iteration that drops the destination slice of iteration,\n-// i.e. the head. The source slice (the tail) is dropped by IntoIter.\n-struct InPlaceDrop<T> {\n-    inner: *mut T,\n-    dst: *mut T,\n-}\n-\n-impl<T> InPlaceDrop<T> {\n-    fn len(&self) -> usize {\n-        unsafe { self.dst.offset_from(self.inner) as usize }\n-    }\n-}\n-\n-impl<T> Drop for InPlaceDrop<T> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe {\n-            ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()));\n-        }\n-    }\n-}\n-\n-impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n-    fn from_iter(iterator: IntoIter<T>) -> Self {\n-        // A common case is passing a vector into a function which immediately\n-        // re-collects into a vector. We can short circuit this if the IntoIter\n-        // has not been advanced at all.\n-        // When it has been advanced We can also reuse the memory and move the data to the front.\n-        // But we only do so when the resulting Vec wouldn't have more unused capacity\n-        // than creating it through the generic FromIterator implementation would. That limitation\n-        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n-        // But it is a conservative choice.\n-        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n-        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n-            unsafe {\n-                let it = ManuallyDrop::new(iterator);\n-                if has_advanced {\n-                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n-                }\n-                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n-            }\n-        }\n-\n-        let mut vec = Vec::new();\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vec.spec_extend(iterator);\n-        vec\n-    }\n-}\n-\n-fn write_in_place_with_drop<T>(\n-    src_end: *const T,\n-) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n-    move |mut sink, item| {\n-        unsafe {\n-            // the InPlaceIterable contract cannot be verified precisely here since\n-            // try_fold has an exclusive reference to the source pointer\n-            // all we can do is check if it's still in range\n-            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n-            ptr::write(sink.dst, item);\n-            sink.dst = sink.dst.add(1);\n-        }\n-        Ok(sink)\n-    }\n-}\n-\n-/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n-/// source allocation, i.e. executing the pipeline in place.\n-///\n-/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n-/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n-/// additional bounds on the impl.\n-#[rustc_unsafe_specialization_marker]\n-trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n-\n-// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n-// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n-// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n-// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n-// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n-// several other specializations already depend on.\n-impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T> + SourceIterMarker,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n-        // instead:\n-        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n-        // b) size match as required by Alloc contract\n-        // c) alignments match as required by Alloc contract\n-        if mem::size_of::<T>() == 0\n-            || mem::size_of::<T>()\n-                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-            || mem::align_of::<T>()\n-                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-        {\n-            // fallback to more generic implementations\n-            return SpecFromIterNested::from_iter(iterator);\n-        }\n-\n-        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n-            let inner = iterator.as_inner().as_into_iter();\n-            (\n-                inner.buf.as_ptr(),\n-                inner.ptr,\n-                inner.buf.as_ptr() as *mut T,\n-                inner.end as *const T,\n-                inner.cap,\n-            )\n-        };\n-\n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink = iterator\n-            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n-            .unwrap();\n-        // iteration succeeded, don't drop head\n-        let dst = ManuallyDrop::new(sink).dst;\n-\n-        let src = unsafe { iterator.as_inner().as_into_iter() };\n-        // check if SourceIter contract was upheld\n-        // caveat: if they weren't we may not even make it to this point\n-        debug_assert_eq!(src_buf, src.buf.as_ptr());\n-        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n-        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n-        // then the source pointer will stay in its initial position and we can't use it as reference\n-        if src.ptr != src_ptr {\n-            debug_assert!(\n-                dst as *const _ <= src.ptr,\n-                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n-            );\n-        }\n-\n-        // drop any remaining values at the tail of the source\n-        src.drop_remaining();\n-        // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        src.forget_allocation();\n-\n-        let vec = unsafe {\n-            let len = dst.offset_from(dst_buf) as usize;\n-            Vec::from_raw_parts(dst_buf, len, cap)\n-        };\n-\n-        vec\n-    }\n-}\n-\n-impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIter::from_iter(iterator.cloned())\n-    }\n-}\n-\n-// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n-// must take more steps to reason about the final capacity + length\n-// and thus do more work. `to_vec()` directly allocates the correct amount\n-// and fills it exactly.\n-impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n-    #[cfg(not(test))]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        iterator.as_slice().to_vec()\n-    }\n-\n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n-    // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n-    // NB see the slice::hack module in slice.rs for more information\n-    #[cfg(test)]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        crate::slice::to_vec(iterator.as_slice(), Global)\n-    }\n-}\n-\n-// Specialization trait used for Vec::extend\n-trait SpecExtend<T, I> {\n-    fn spec_extend(&mut self, iter: I);\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iter: I) {\n-        self.extend_desugared(iter)\n-    }\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: TrustedLen<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        // This is the case for a TrustedLen iterator.\n-        let (low, high) = iterator.size_hint();\n-        if let Some(high_value) = high {\n-            debug_assert_eq!(\n-                low,\n-                high_value,\n-                \"TrustedLen iterator's size hint is not exact: {:?}\",\n-                (low, high)\n-            );\n-        }\n-        if let Some(additional) = high {\n-            self.reserve(additional);\n-            unsafe {\n-                let mut ptr = self.as_mut_ptr().add(self.len());\n-                let mut local_len = SetLenOnDrop::new(&mut self.len);\n-                iterator.for_each(move |element| {\n-                    ptr::write(ptr, element);\n-                    ptr = ptr.offset(1);\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    local_len.increment_len(1);\n-                });\n-            }\n-        } else {\n-            self.extend_desugared(iterator)\n-        }\n-    }\n-}\n-\n-impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n-    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n-        unsafe {\n-            self.append_elements(iterator.as_slice() as _);\n-        }\n-        iterator.ptr = iterator.end;\n-    }\n-}\n-\n-impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        self.spec_extend(iterator.cloned())\n-    }\n-}\n-\n-impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n-where\n-    T: Copy,\n-{\n-    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n-        let slice = iterator.as_slice();\n-        unsafe { self.append_elements(slice) };\n-    }\n-}\n-\n impl<T, A: Allocator> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply\n@@ -2759,45 +2312,6 @@ impl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n     }\n }\n \n-macro_rules! __impl_slice_eq1 {\n-    ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n-        #[$stability]\n-        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n-        where\n-            T: PartialEq<U>,\n-            $($ty: $bound)?\n-        {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n-        }\n-    }\n-}\n-\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-\n-// NOTE: some less important impls are omitted to reduce code bloat\n-// FIXME(Centril): Reconsider this?\n-//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], }\n-//__impl_slice_eq1! { [const N: usize] [A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] &[A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] &mut [A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], }\n-\n /// Implements comparison of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n@@ -2997,729 +2511,3 @@ impl<T, A: Allocator, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n         Ok(array)\n     }\n }\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Clone-on-write\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n-    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n-        Cow::Borrowed(s)\n-    }\n-}\n-\n-#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n-impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n-    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n-        Cow::Owned(v)\n-    }\n-}\n-\n-#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n-impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n-    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n-        Cow::Borrowed(v.as_slice())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> FromIterator<T> for Cow<'a, [T]>\n-where\n-    T: Clone,\n-{\n-    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n-        Cow::Owned(FromIterator::from_iter(it))\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Iterators\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// An iterator that moves out of a vector.\n-///\n-/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n-/// by the [`IntoIterator`] trait).\n-///\n-/// # Example\n-///\n-/// ```\n-/// let v = vec![0, 1, 2];\n-/// let iter: std::vec::IntoIter<_> = v.into_iter();\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<\n-    T,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> {\n-    buf: NonNull<T>,\n-    phantom: PhantomData<T>,\n-    cap: usize,\n-    alloc: A,\n-    ptr: *const T,\n-    end: *const T,\n-}\n-\n-#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n-    }\n-}\n-\n-impl<T, A: Allocator> IntoIter<T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = into_iter.next().unwrap();\n-    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n-    }\n-\n-    /// Returns the remaining items of this iterator as a mutable slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// into_iter.as_mut_slice()[2] = 'z';\n-    /// assert_eq!(into_iter.next().unwrap(), 'a');\n-    /// assert_eq!(into_iter.next().unwrap(), 'b');\n-    /// assert_eq!(into_iter.next().unwrap(), 'z');\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe { &mut *self.as_raw_mut_slice() }\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        &self.alloc\n-    }\n-\n-    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n-        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n-    }\n-\n-    fn drop_remaining(&mut self) {\n-        unsafe {\n-            ptr::drop_in_place(self.as_mut_slice());\n-        }\n-        self.ptr = self.end;\n-    }\n-\n-    /// Relinquishes the backing allocation, equivalent to\n-    /// `ptr::write(&mut self, Vec::new().into_iter())`\n-    fn forget_allocation(&mut self) {\n-        self.cap = 0;\n-        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n-        self.ptr = self.buf.as_ptr();\n-        self.end = self.buf.as_ptr();\n-    }\n-}\n-\n-#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n-impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        if self.ptr as *const _ == self.end {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // purposefully don't use 'ptr.offset' because for\n-            // vectors with 0-size elements this would return the\n-            // same pointer.\n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            let old = self.ptr;\n-            self.ptr = unsafe { self.ptr.offset(1) };\n-\n-            Some(unsafe { ptr::read(old) })\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = if mem::size_of::<T>() == 0 {\n-            (self.end as usize).wrapping_sub(self.ptr as usize)\n-        } else {\n-            unsafe { self.end.offset_from(self.ptr) as usize }\n-        };\n-        (exact, Some(exact))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.len()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must guarantee that `i` is in bounds of the\n-        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n-        // is guaranteed to pointer to an element of the `Vec<T>` and\n-        // thus guaranteed to be valid to dereference.\n-        //\n-        // Also note the implementation of `Self: TrustedRandomAccess` requires\n-        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n-        // them for `Drop`.\n-        unsafe {\n-            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.end == self.ptr {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // See above for why 'ptr.offset' isn't used\n-            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            self.end = unsafe { self.end.offset(-1) };\n-\n-            Some(unsafe { ptr::read(self.end) })\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n-\n-#[doc(hidden)]\n-#[unstable(issue = \"none\", feature = \"std_internals\")]\n-// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n-// and thus we can't implement drop-handling\n-unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n-where\n-    T: Copy,\n-{\n-    fn may_have_side_effect() -> bool {\n-        false\n-    }\n-}\n-\n-#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n-impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n-    #[cfg(not(test))]\n-    fn clone(&self) -> Self {\n-        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n-    }\n-    #[cfg(test)]\n-    fn clone(&self) -> Self {\n-        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n-    fn drop(&mut self) {\n-        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n-\n-        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    // `IntoIter::alloc` is not used anymore after this\n-                    let alloc = ptr::read(&self.0.alloc);\n-                    // RawVec handles deallocation\n-                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n-                }\n-            }\n-        }\n-\n-        let guard = DropGuard(self);\n-        // destroy the remaining elements\n-        unsafe {\n-            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n-        }\n-        // now `guard` will be dropped and do the rest\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n-    type Source = Self;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n-        self\n-    }\n-}\n-\n-// internal helper trait for in-place iteration specialization.\n-#[rustc_specialization_trait]\n-pub(crate) trait AsIntoIter {\n-    type Item;\n-    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n-}\n-\n-impl<T> AsIntoIter for IntoIter<T> {\n-    type Item = T;\n-\n-    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n-        self\n-    }\n-}\n-\n-/// A draining iterator for `Vec<T>`.\n-///\n-/// This `struct` is created by [`Vec::drain`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::Drain<_> = v.drain(..);\n-/// ```\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<\n-    'a,\n-    T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    /// Index of tail to preserve\n-    tail_start: usize,\n-    /// Length of tail\n-    tail_len: usize,\n-    /// Current remaining range to remove\n-    iter: slice::Iter<'a, T>,\n-    vec: NonNull<Vec<T, A>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n-    }\n-}\n-\n-impl<'a, T, A: Allocator> Drain<'a, T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec!['a', 'b', 'c'];\n-    /// let mut drain = vec.drain(..);\n-    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = drain.next().unwrap();\n-    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        self.iter.as_slice()\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        unsafe { self.vec.as_ref().allocator() }\n-    }\n-}\n-\n-#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n-    fn drop(&mut self) {\n-        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n-        /// un-`Drain`ed elements to restore the original `Vec`.\n-        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n-\n-        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n-            fn drop(&mut self) {\n-                // Continue the same loop we have below. If the loop already finished, this does\n-                // nothing.\n-                self.0.for_each(drop);\n-\n-                if self.0.tail_len > 0 {\n-                    unsafe {\n-                        let source_vec = self.0.vec.as_mut();\n-                        // memmove back untouched tail, update to new length\n-                        let start = source_vec.len();\n-                        let tail = self.0.tail_start;\n-                        if tail != start {\n-                            let src = source_vec.as_ptr().add(tail);\n-                            let dst = source_vec.as_mut_ptr().add(start);\n-                            ptr::copy(src, dst, self.0.tail_len);\n-                        }\n-                        source_vec.set_len(start + self.0.tail_len);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // exhaust self first\n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n-        }\n-\n-        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n-        DropGuard(self);\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}\n-\n-/// A splicing iterator for `Vec`.\n-///\n-/// This struct is created by [`Vec::splice()`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let new = [7, 8];\n-/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-pub struct Splice<\n-    'a,\n-    I: Iterator + 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    drain: Drain<'a, I::Item, A>,\n-    replace_with: I,\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n-    type Item = I::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.drain.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.drain.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.drain.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n-    fn drop(&mut self) {\n-        self.drain.by_ref().for_each(drop);\n-\n-        unsafe {\n-            if self.drain.tail_len == 0 {\n-                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n-                return;\n-            }\n-\n-            // First fill the range left by drain().\n-            if !self.drain.fill(&mut self.replace_with) {\n-                return;\n-            }\n-\n-            // There may be more elements. Use the lower bound as an estimate.\n-            // FIXME: Is the upper bound a better guess? Or something else?\n-            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n-            if lower_bound > 0 {\n-                self.drain.move_tail(lower_bound);\n-                if !self.drain.fill(&mut self.replace_with) {\n-                    return;\n-                }\n-            }\n-\n-            // Collect any remaining elements.\n-            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n-            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n-            // Now we have an exact count.\n-            if collected.len() > 0 {\n-                self.drain.move_tail(collected.len());\n-                let filled = self.drain.fill(&mut collected);\n-                debug_assert!(filled);\n-                debug_assert_eq!(collected.len(), 0);\n-            }\n-        }\n-        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n-    }\n-}\n-\n-/// Private helper methods for `Splice::drop`\n-impl<T, A: Allocator> Drain<'_, T, A> {\n-    /// The range from `self.vec.len` to `self.tail_start` contains elements\n-    /// that have been moved out.\n-    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n-    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let range_start = vec.len;\n-        let range_end = self.tail_start;\n-        let range_slice = unsafe {\n-            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n-        };\n-\n-        for place in range_slice {\n-            if let Some(new_item) = replace_with.next() {\n-                unsafe { ptr::write(place, new_item) };\n-                vec.len += 1;\n-            } else {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Makes room for inserting more elements before the tail.\n-    unsafe fn move_tail(&mut self, additional: usize) {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let len = self.tail_start + self.tail_len;\n-        vec.buf.reserve(len, additional);\n-\n-        let new_tail_start = self.tail_start + additional;\n-        unsafe {\n-            let src = vec.as_ptr().add(self.tail_start);\n-            let dst = vec.as_mut_ptr().add(new_tail_start);\n-            ptr::copy(src, dst, self.tail_len);\n-        }\n-        self.tail_start = new_tail_start;\n-    }\n-}\n-\n-/// An iterator which uses a closure to determine if an element should be removed.\n-///\n-/// This struct is created by [`Vec::drain_filter`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(drain_filter)]\n-///\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n-/// ```\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-#[derive(Debug)]\n-pub struct DrainFilter<\n-    'a,\n-    T,\n-    F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    vec: &'a mut Vec<T, A>,\n-    /// The index of the item that will be inspected by the next call to `next`.\n-    idx: usize,\n-    /// The number of items that have been drained (removed) thus far.\n-    del: usize,\n-    /// The original length of `vec` prior to draining.\n-    old_len: usize,\n-    /// The filter test predicate.\n-    pred: F,\n-    /// A flag that indicates a panic has occurred in the filter test predicate.\n-    /// This is used as a hint in the drop implementation to prevent consumption\n-    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n-    /// backshifted in the `vec`, but no further items will be dropped or\n-    /// tested by the filter predicate.\n-    panic_flag: bool,\n-}\n-\n-impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        self.vec.allocator()\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            while self.idx < self.old_len {\n-                let i = self.idx;\n-                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                self.panic_flag = true;\n-                let drained = (self.pred)(&mut v[i]);\n-                self.panic_flag = false;\n-                // Update the index *after* the predicate is called. If the index\n-                // is updated prior and the predicate panics, the element at this\n-                // index would be leaked.\n-                self.idx += 1;\n-                if drained {\n-                    self.del += 1;\n-                    return Some(ptr::read(&v[i]));\n-                } else if self.del > 0 {\n-                    let del = self.del;\n-                    let src: *const T = &v[i];\n-                    let dst: *mut T = &mut v[i - del];\n-                    ptr::copy_nonoverlapping(src, dst, 1);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.old_len - self.idx))\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            drain: &'b mut DrainFilter<'a, T, F, A>,\n-        }\n-\n-        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n-                        // This is a pretty messed up state, and there isn't really an\n-                        // obviously right thing to do. We don't want to keep trying\n-                        // to execute `pred`, so we just backshift all the unprocessed\n-                        // elements and tell the vec that they still exist. The backshift\n-                        // is required to prevent a double-drop of the last successfully\n-                        // drained item prior to a panic in the predicate.\n-                        let ptr = self.drain.vec.as_mut_ptr();\n-                        let src = ptr.add(self.drain.idx);\n-                        let dst = src.sub(self.drain.del);\n-                        let tail_len = self.drain.old_len - self.drain.idx;\n-                        src.copy_to(dst, tail_len);\n-                    }\n-                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n-                }\n-            }\n-        }\n-\n-        let backshift = BackshiftOnDrop { drain: self };\n-\n-        // Attempt to consume any remaining elements if the filter predicate\n-        // has not yet panicked. We'll backshift any remaining elements\n-        // whether we've already panicked or if the consumption here panics.\n-        if !backshift.drain.panic_flag {\n-            backshift.drain.for_each(drop);\n-        }\n-    }\n-}", "previous_filename": "library/alloc/src/vec.rs"}, {"sha": "ff90b6caf4601d92818dd2f5065602ec2bfc73a6", "filename": "library/alloc/src/vec/partial_eq.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,43 @@\n+use crate::alloc::Allocator;\n+use crate::borrow::Cow;\n+\n+use super::Vec;\n+\n+macro_rules! __impl_slice_eq1 {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n+        #[$stability]\n+        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            T: PartialEq<U>,\n+            $($ty: $bound)?\n+        {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n+        }\n+    }\n+}\n+\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// FIXME(Centril): Reconsider this?\n+//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], }\n+//__impl_slice_eq1! { [const N: usize] [A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] &[A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] &mut [A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], }"}, {"sha": "8b66bc812129694e4976f140a1e18afed0c1aee1", "filename": "library/alloc/src/vec/set_len_on_drop.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,28 @@\n+// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+//\n+// The idea is: The length field in SetLenOnDrop is a local variable\n+// that the optimizer will see does not alias with any stores through the Vec's data\n+// pointer. This is a workaround for alias analysis issue #32155\n+pub(super) struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    pub(super) fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len }\n+    }\n+\n+    #[inline]\n+    pub(super) fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl Drop for SetLenOnDrop<'_> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}"}, {"sha": "8c0e95559fa15e83fc4a07fea4951a533a233ed5", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,108 @@\n+use core::iter::{InPlaceIterable, SourceIter};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr::{self};\n+\n+use super::{AsIntoIter, InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n+\n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+///\n+/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n+/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n+/// additional bounds on the impl.\n+#[rustc_unsafe_specialization_marker]\n+pub(super) trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n+\n+// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n+// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n+// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n+// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n+// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n+// several other specializations already depend on.\n+impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T> + SourceIterMarker,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n+        // instead:\n+        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n+        // b) size match as required by Alloc contract\n+        // c) alignments match as required by Alloc contract\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+        {\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n+        }\n+\n+        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (\n+                inner.buf.as_ptr(),\n+                inner.ptr,\n+                inner.buf.as_ptr() as *mut T,\n+                inner.end as *const T,\n+                inner.cap,\n+            )\n+        };\n+\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink = iterator\n+            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n+            .unwrap();\n+        // iteration succeeded, don't drop head\n+        let dst = ManuallyDrop::new(sink).dst;\n+\n+        let src = unsafe { iterator.as_inner().as_into_iter() };\n+        // check if SourceIter contract was upheld\n+        // caveat: if they weren't we may not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n+        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n+        // then the source pointer will stay in its initial position and we can't use it as reference\n+        if src.ptr != src_ptr {\n+            debug_assert!(\n+                dst as *const _ <= src.ptr,\n+                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n+            );\n+        }\n+\n+        // drop any remaining values at the tail of the source\n+        src.drop_remaining();\n+        // but prevent drop of the allocation itself once IntoIter goes out of scope\n+        src.forget_allocation();\n+\n+        let vec = unsafe {\n+            let len = dst.offset_from(dst_buf) as usize;\n+            Vec::from_raw_parts(dst_buf, len, cap)\n+        };\n+\n+        vec\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}"}, {"sha": "b6186a7ebaf730ba1dba44df5f04f61587bbda0d", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,82 @@\n+use crate::alloc::Allocator;\n+use core::iter::TrustedLen;\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{IntoIter, SetLenOnDrop, Vec};\n+\n+// Specialization trait used for Vec::extend\n+pub(super) trait SpecExtend<T, I> {\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iterator.size_hint();\n+        if let Some(high_value) = high {\n+            debug_assert_eq!(\n+                low,\n+                high_value,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+        }\n+        if let Some(additional) = high {\n+            self.reserve(additional);\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len());\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n+                iterator.for_each(move |element| {\n+                    ptr::write(ptr, element);\n+                    ptr = ptr.offset(1);\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    local_len.increment_len(1);\n+                });\n+            }\n+        } else {\n+            self.extend_desugared(iterator)\n+        }\n+    }\n+}\n+\n+impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n+    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n+        unsafe {\n+            self.append_elements(iterator.as_slice() as _);\n+        }\n+        iterator.ptr = iterator.end;\n+    }\n+}\n+\n+impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        self.spec_extend(iterator.cloned())\n+    }\n+}\n+\n+impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n+where\n+    T: Copy,\n+{\n+    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n+        let slice = iterator.as_slice();\n+        unsafe { self.append_elements(slice) };\n+    }\n+}"}, {"sha": "de610174783c4b51b2e61493d26ca696faaaa1b3", "filename": "library/alloc/src/vec/spec_from_elem.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,60 @@\n+use crate::alloc::Allocator;\n+use crate::raw_vec::RawVec;\n+use core::ptr::{self};\n+\n+use super::{ExtendElement, IsZero, Vec};\n+\n+// Specialization trait used for Vec::from_elem\n+pub(super) trait SpecFromElem: Sized {\n+    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n+}\n+\n+impl<T: Clone> SpecFromElem for T {\n+    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n+        let mut v = Vec::with_capacity_in(n, alloc);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n+impl SpecFromElem for i8 {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n+        if elem == 0 {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity_in(n, alloc);\n+            ptr::write_bytes(v.as_mut_ptr(), elem as u8, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n+}\n+\n+impl SpecFromElem for u8 {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n+        if elem == 0 {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity_in(n, alloc);\n+            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n+}\n+\n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+        if elem.is_zero() {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        let mut v = Vec::with_capacity_in(n, alloc);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}"}, {"sha": "bbfcc68daeff43e2585dc8d01997857c1bd73a3e", "filename": "library/alloc/src/vec/spec_from_iter.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,97 @@\n+use core::mem::ManuallyDrop;\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{IntoIter, SpecExtend, SpecFromIterNested, Vec};\n+\n+/// Specialization trait used for Vec::from_iter\n+///\n+/// ## The delegation graph:\n+///\n+/// ```text\n+/// +-------------+\n+/// |FromIterator |\n+/// +-+-----------+\n+///   |\n+///   v\n+/// +-+-------------------------------+  +---------------------+\n+/// |SpecFromIter                  +---->+SpecFromIterNested   |\n+/// |where I:                      |  |  |where I:             |\n+/// |  Iterator (default)----------+  |  |  Iterator (default) |\n+/// |  vec::IntoIter               |  |  |  TrustedLen         |\n+/// |  SourceIterMarker---fallback-+  |  |                     |\n+/// |  slice::Iter                    |  |                     |\n+/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// +---------------------------------+\n+/// ```\n+pub(super) trait SpecFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIterNested::from_iter(iterator)\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n+    fn from_iter(iterator: IntoIter<T>) -> Self {\n+        // A common case is passing a vector into a function which immediately\n+        // re-collects into a vector. We can short circuit this if the IntoIter\n+        // has not been advanced at all.\n+        // When it has been advanced We can also reuse the memory and move the data to the front.\n+        // But we only do so when the resulting Vec wouldn't have more unused capacity\n+        // than creating it through the generic FromIterator implementation would. That limitation\n+        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n+        // But it is a conservative choice.\n+        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n+        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n+            unsafe {\n+                let it = ManuallyDrop::new(iterator);\n+                if has_advanced {\n+                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n+                }\n+                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n+            }\n+        }\n+\n+        let mut vec = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vec.spec_extend(iterator);\n+        vec\n+    }\n+}\n+\n+impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIter::from_iter(iterator.cloned())\n+    }\n+}\n+\n+// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n+// must take more steps to reason about the final capacity + length\n+// and thus do more work. `to_vec()` directly allocates the correct amount\n+// and fills it exactly.\n+impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n+    #[cfg(not(test))]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        iterator.as_slice().to_vec()\n+    }\n+\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Instead use the\n+    // `slice::to_vec`  function which is only available with cfg(test)\n+    // NB see the slice::hack module in slice.rs for more information\n+    #[cfg(test)]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        crate::slice::to_vec(iterator.as_slice(), crate::alloc::Global)\n+    }\n+}"}, {"sha": "6abd4ff2a3f0a8c2812ae49b364a2c895a89db76", "filename": "library/alloc/src/vec/spec_from_iter_nested.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,56 @@\n+use core::iter::TrustedLen;\n+use core::ptr::{self};\n+\n+use super::{SpecExtend, Vec};\n+\n+/// Another specialization trait for Vec::from_iter\n+/// necessary to manually prioritize overlapping specializations\n+/// see [`SpecFromIter`] for details.\n+pub(super) trait SpecFromIterNested<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Unroll the first iteration, as the vector is going to be\n+        // expanded on this iteration in every case when the iterable is not\n+        // empty, but the loop in extend_desugared() is not going to see the\n+        // vector being full in the few subsequent loop iterations.\n+        // So we get better branch prediction.\n+        let mut vector = match iterator.next() {\n+            None => return Vec::new(),\n+            Some(element) => {\n+                let (lower, _) = iterator.size_hint();\n+                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n+                unsafe {\n+                    ptr::write(vector.as_mut_ptr(), element);\n+                    vector.set_len(1);\n+                }\n+                vector\n+            }\n+        };\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n+        vector\n+    }\n+}\n+\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    fn from_iter(iterator: I) -> Self {\n+        let mut vector = match iterator.size_hint() {\n+            (_, Some(upper)) => Vec::with_capacity(upper),\n+            _ => Vec::new(),\n+        };\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+}"}, {"sha": "0a27b5b62ecf509830473fda17af573a1e2e51c2", "filename": "library/alloc/src/vec/splice.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,133 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{Drain, Vec};\n+\n+/// A splicing iterator for `Vec`.\n+///\n+/// This struct is created by [`Vec::splice()`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let new = [7, 8];\n+/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub struct Splice<\n+    'a,\n+    I: Iterator + 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    pub(super) drain: Drain<'a, I::Item, A>,\n+    pub(super) replace_with: I,\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.drain.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.drain.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.drain.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n+    fn drop(&mut self) {\n+        self.drain.by_ref().for_each(drop);\n+\n+        unsafe {\n+            if self.drain.tail_len == 0 {\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n+                return;\n+            }\n+\n+            // First fill the range left by drain().\n+            if !self.drain.fill(&mut self.replace_with) {\n+                return;\n+            }\n+\n+            // There may be more elements. Use the lower bound as an estimate.\n+            // FIXME: Is the upper bound a better guess? Or something else?\n+            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n+            if lower_bound > 0 {\n+                self.drain.move_tail(lower_bound);\n+                if !self.drain.fill(&mut self.replace_with) {\n+                    return;\n+                }\n+            }\n+\n+            // Collect any remaining elements.\n+            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n+            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n+            // Now we have an exact count.\n+            if collected.len() > 0 {\n+                self.drain.move_tail(collected.len());\n+                let filled = self.drain.fill(&mut collected);\n+                debug_assert!(filled);\n+                debug_assert_eq!(collected.len(), 0);\n+            }\n+        }\n+        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n+    }\n+}\n+\n+/// Private helper methods for `Splice::drop`\n+impl<T, A: Allocator> Drain<'_, T, A> {\n+    /// The range from `self.vec.len` to `self.tail_start` contains elements\n+    /// that have been moved out.\n+    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let range_start = vec.len;\n+        let range_end = self.tail_start;\n+        let range_slice = unsafe {\n+            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n+        };\n+\n+        for place in range_slice {\n+            if let Some(new_item) = replace_with.next() {\n+                unsafe { ptr::write(place, new_item) };\n+                vec.len += 1;\n+            } else {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Makes room for inserting more elements before the tail.\n+    unsafe fn move_tail(&mut self, additional: usize) {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let len = self.tail_start + self.tail_len;\n+        vec.buf.reserve(len, additional);\n+\n+        let new_tail_start = self.tail_start + additional;\n+        unsafe {\n+            let src = vec.as_ptr().add(self.tail_start);\n+            let dst = vec.as_mut_ptr().add(new_tail_start);\n+            ptr::copy(src, dst, self.tail_len);\n+        }\n+        self.tail_start = new_tail_start;\n+    }\n+}"}, {"sha": "362326725490ff3c72e96afcfd2253d104092a1a", "filename": "library/core/src/iter/adapters/intersperse.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,76 @@\n+use super::Peekable;\n+\n+/// An iterator adapter that places a separator between all elements.\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+#[derive(Debug, Clone)]\n+pub struct Intersperse<I: Iterator>\n+where\n+    I::Item: Clone,\n+{\n+    separator: I::Item,\n+    iter: Peekable<I>,\n+    needs_sep: bool,\n+}\n+\n+impl<I: Iterator> Intersperse<I>\n+where\n+    I::Item: Clone,\n+{\n+    pub(in crate::iter) fn new(iter: I, separator: I::Item) -> Self {\n+        Self { iter: iter.peekable(), separator, needs_sep: false }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I> Iterator for Intersperse<I>\n+where\n+    I: Iterator,\n+    I::Item: Clone,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.needs_sep && self.iter.peek().is_some() {\n+            self.needs_sep = false;\n+            Some(self.separator.clone())\n+        } else {\n+            self.needs_sep = true;\n+            self.iter.next()\n+        }\n+    }\n+\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+\n+        // Use `peek()` first to avoid calling `next()` on an empty iterator.\n+        if !self.needs_sep || self.iter.peek().is_some() {\n+            if let Some(x) = self.iter.next() {\n+                accum = f(accum, x);\n+            }\n+        }\n+\n+        let element = &self.separator;\n+\n+        self.iter.fold(accum, |mut accum, x| {\n+            accum = f(accum, element.clone());\n+            accum = f(accum, x);\n+            accum\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lo, hi) = self.iter.size_hint();\n+        let next_is_elem = !self.needs_sep;\n+        let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n+        let hi = match hi {\n+            Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n+            None => None,\n+        };\n+        (lo, hi)\n+    }\n+}"}, {"sha": "7dfbf32cea7b89773d4fdc926abfe85fbb0f709a", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -11,6 +11,7 @@ mod filter_map;\n mod flatten;\n mod fuse;\n mod inspect;\n+mod intersperse;\n mod map;\n mod map_while;\n mod peekable;\n@@ -41,6 +42,9 @@ pub use self::flatten::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::copied::Copied;\n \n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub use self::intersperse::Intersperse;\n+\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::map_while::MapWhile;\n "}, {"sha": "569de719d03d69b4d86ced6d44fc3cebb93507fb", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -395,6 +395,8 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub use self::adapters::Intersperse;\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n #[unstable(feature = \"inplace_iteration\", issue = \"none\")]"}, {"sha": "633175702d870a9e623d4532d432f60bf6e10d08", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -8,7 +8,7 @@ use crate::ops::{Add, ControlFlow, Try};\n use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n-use super::super::{FromIterator, Product, Sum, Zip};\n+use super::super::{FromIterator, Intersperse, Product, Sum, Zip};\n use super::super::{\n     Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n };\n@@ -569,6 +569,28 @@ pub trait Iterator {\n         Zip::new(self, other.into_iter())\n     }\n \n+    /// Places a copy of `separator` between all elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n+    /// let hello = [\"Hello\", \"World\"].iter().copied().intersperse(\" \").collect::<String>();\n+    /// assert_eq!(hello, \"Hello World\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+    fn intersperse(self, separator: Self::Item) -> Intersperse<Self>\n+    where\n+        Self: Sized,\n+        Self::Item: Clone,\n+    {\n+        Intersperse::new(self, separator)\n+    }\n+\n     /// Takes a closure and creates an iterator which calls that closure on each\n     /// element.\n     ///"}, {"sha": "22e44a3c4090459a44d9c49230a4ae5706ade726", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -379,7 +379,8 @@ pub const fn size_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n-pub unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n+#[rustc_const_unstable(feature = \"const_size_of_val_raw\", issue = \"46571\")]\n+pub const unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n     intrinsics::size_of_val(val)\n }\n \n@@ -510,7 +511,8 @@ pub const fn align_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n-pub unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n+#[rustc_const_unstable(feature = \"const_align_of_val_raw\", issue = \"46571\")]\n+pub const unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {\n     intrinsics::min_align_of_val(val)\n }\n "}, {"sha": "7376e7848eff540a50832bf8a6eea4e1cdc08639", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -3505,3 +3505,85 @@ pub fn extend_for_unit() {\n     }\n     assert_eq!(x, 5);\n }\n+\n+#[test]\n+fn test_intersperse() {\n+    let xs = [\"a\", \"\", \"b\", \"c\"];\n+    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n+    let text: String = v.concat();\n+    assert_eq!(text, \"a, , b, c\".to_string());\n+\n+    let ys = [0, 1, 2, 3];\n+    let mut it = ys[..0].iter().map(|x| *x).intersperse(1);\n+    assert!(it.next() == None);\n+}\n+\n+#[test]\n+fn test_intersperse_size_hint() {\n+    let xs = [\"a\", \"\", \"b\", \"c\"];\n+    let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n+    assert_eq!(iter.size_hint(), (7, Some(7)));\n+\n+    assert_eq!(iter.next(), Some(\"a\"));\n+    assert_eq!(iter.size_hint(), (6, Some(6)));\n+    assert_eq!(iter.next(), Some(\", \"));\n+    assert_eq!(iter.size_hint(), (5, Some(5)));\n+\n+    assert_eq!([].iter().intersperse(&()).size_hint(), (0, Some(0)));\n+}\n+\n+#[test]\n+fn test_fold_specialization_intersperse() {\n+    let mut iter = (1..2).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+\n+    let mut iter = (1..3).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+\n+    let mut iter = (1..4).intersperse(0);\n+    iter.clone().for_each(|x| assert_eq!(Some(x), iter.next()));\n+}\n+\n+#[test]\n+fn test_try_fold_specialization_intersperse_ok() {\n+    let mut iter = (1..2).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+\n+    let mut iter = (1..3).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+\n+    let mut iter = (1..4).intersperse(0);\n+    iter.clone().try_for_each(|x| {\n+        assert_eq!(Some(x), iter.next());\n+        Some(())\n+    });\n+}\n+\n+#[test]\n+fn test_try_fold_specialization_intersperse_err() {\n+    let orig_iter = [\"a\", \"b\"].iter().copied().intersperse(\"-\");\n+\n+    // Abort after the first item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|_| None::<()>);\n+    assert_eq!(iter.next(), Some(\"-\"));\n+    assert_eq!(iter.next(), Some(\"b\"));\n+    assert_eq!(iter.next(), None);\n+\n+    // Abort after the second item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|item| if item == \"-\" { None } else { Some(()) });\n+    assert_eq!(iter.next(), Some(\"b\"));\n+    assert_eq!(iter.next(), None);\n+\n+    // Abort after the third item.\n+    let mut iter = orig_iter.clone();\n+    iter.try_for_each(|item| if item == \"b\" { None } else { Some(()) });\n+    assert_eq!(iter.next(), None);\n+}"}, {"sha": "fba3294e0bbdb1f5fdf3e3efef9fbc1d4dc23b7e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -51,6 +51,7 @@\n #![feature(array_value_iter)]\n #![feature(iter_advance_by)]\n #![feature(iter_partition_in_place)]\n+#![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]"}, {"sha": "b8bae69d063309cb82ef44ba4cb559a868a3fe10", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -351,11 +351,13 @@ def output(filepath):\n     with open(tmp, 'w') as f:\n         yield f\n     try:\n-        os.remove(filepath)  # PermissionError/OSError on Win32 if in use\n-        os.rename(tmp, filepath)\n+        if os.path.exists(filepath):\n+            os.remove(filepath)  # PermissionError/OSError on Win32 if in use\n     except OSError:\n         shutil.copy2(tmp, filepath)\n         os.remove(tmp)\n+        return\n+    os.rename(tmp, filepath)\n \n \n class RustBuild(object):"}, {"sha": "766b02a5acd69dc765ac7bd519961a8c86934f66", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -941,7 +941,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n                 .iter()\n                 .enumerate()\n                 .map(|(i, ty)| {\n-                    let mut name = self.1.get(i).map(|ident| ident.name).unwrap_or(kw::Invalid);\n+                    let mut name = self.1.get(i).map(|ident| ident.name).unwrap_or(kw::Empty);\n                     if name.is_empty() {\n                         name = kw::Underscore;\n                     }\n@@ -1000,7 +1000,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n                     .iter()\n                     .map(|t| Argument {\n                         type_: t.clean(cx),\n-                        name: names.next().map(|i| i.name).unwrap_or(kw::Invalid),\n+                        name: names.next().map(|i| i.name).unwrap_or(kw::Empty),\n                     })\n                     .collect(),\n             },"}, {"sha": "a6c090c6576ef4f200973b3076d3b626112a353f", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -8,7 +8,6 @@ use crate::clean::{\n };\n use crate::core::DocContext;\n \n-use itertools::Itertools;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};"}, {"sha": "a83a3600383eee5b5690ef94527f7825613343ef", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -2086,8 +2086,8 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 (true, false) => return Ordering::Greater,\n             }\n         }\n-        let lhs = i1.name.unwrap_or(kw::Invalid).as_str();\n-        let rhs = i2.name.unwrap_or(kw::Invalid).as_str();\n+        let lhs = i1.name.unwrap_or(kw::Empty).as_str();\n+        let rhs = i2.name.unwrap_or(kw::Empty).as_str();\n         compare_names(&lhs, &rhs)\n     }\n \n@@ -4207,7 +4207,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache:\n                 ty: \\\"{ty}\\\", \\\n                 relpath: \\\"{path}\\\"\\\n             }};</script>\",\n-        name = it.name.unwrap_or(kw::Invalid),\n+        name = it.name.unwrap_or(kw::Empty),\n         ty = it.type_(),\n         path = relpath\n     );"}, {"sha": "7ed64c5813fcd8f00203a10d6ad7afa47d0470cf", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -17,6 +17,7 @@\n #![feature(type_ascription)]\n #![feature(split_inclusive)]\n #![feature(str_split_once)]\n+#![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "d4fa5be742ff3486dab53e8773b600c9fa3f410b", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the size for values of type `[u8]` cannot be known at compilation\n LL |     type Ty = Vec<[u8]>;\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "260d78b543a4ca53a791f8b8f90c1d40ecd2289d", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -15,7 +15,7 @@ error[E0277]: the size for values of type `dyn Trait` cannot be known at compila\n LL |     let x: Vec<dyn Trait + Sized> = Vec::new();\n    |            ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "56dc53298fb359f84f8958ee66610ed0c26cffab", "filename": "src/test/ui/const-generics/issues/issue-80062.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for issue #80062 (fixed by `min_const_generics`)\n+\n+fn sof<T>() -> T { unimplemented!() }\n+\n+fn test<T>() {\n+    let _: [u8; sof::<T>()];\n+    //~^ ERROR generic parameters may not be used in const operations\n+}\n+\n+fn main() {}"}, {"sha": "aad8907bda2d0cf8d5ebf63cf418686835738179", "filename": "src/test/ui/const-generics/issues/issue-80062.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-80062.stderr?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -0,0 +1,11 @@\n+error: generic parameters may not be used in const operations\n+  --> $DIR/issue-80062.rs:6:23\n+   |\n+LL |     let _: [u8; sof::<T>()];\n+   |                       ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n+\n+error: aborting due to previous error\n+"}, {"sha": "5c0d7d94d64f1bf061f4e5ca3e0c22309e957c32", "filename": "src/test/ui/consts/const-size_of_val-align_of_val.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(const_size_of_val, const_align_of_val)]\n+#![feature(const_size_of_val_raw, const_align_of_val_raw, layout_for_ptr)]\n \n use std::mem;\n \n@@ -32,6 +33,9 @@ const ALIGN_OF_UGH: usize = mem::align_of_val(&UGH);\n \n const SIZE_OF_SLICE: usize = mem::size_of_val(\"foobar\".as_bytes());\n \n+const SIZE_OF_DANGLING: usize = unsafe { mem::size_of_val_raw(0x100 as *const i32) };\n+const ALIGN_OF_DANGLING: usize = unsafe { mem::align_of_val_raw(0x100 as *const i16) };\n+\n fn main() {\n     assert_eq!(SIZE_OF_FOO, mem::size_of::<Foo>());\n     assert_eq!(SIZE_OF_BAR, mem::size_of::<Bar>());\n@@ -41,5 +45,8 @@ fn main() {\n     assert_eq!(ALIGN_OF_BAR, mem::align_of::<Bar>());\n     assert_eq!(ALIGN_OF_UGH, mem::align_of::<Ugh>());\n \n+    assert_eq!(SIZE_OF_DANGLING, mem::size_of::<i32>());\n+    assert_eq!(ALIGN_OF_DANGLING, mem::align_of::<i16>());\n+\n     assert_eq!(SIZE_OF_SLICE, \"foobar\".len());\n }"}, {"sha": "5fed02164b5b704b482f1026f53e7024ceaeb6f4", "filename": "src/test/ui/issues/issue-20433.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the size for values of type `[i32]` cannot be known at compilation\n LL |     fn iceman(c: Vec<[i32]>) {}\n    |                  ^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "3973af540c81f181ecd929386cc312e2b7f766f2", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -107,7 +107,7 @@ LL |     VEC.push(0);\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: mutable reference created due to call to this method\n-  --> $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | /     pub fn push(&mut self, value: T) {\n LL | |         // This will panic or abort if we would allocate > isize::MAX bytes"}, {"sha": "e84c8b4e5b3e0317e7006e84abd689f1dca56d4b", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "patch": "@@ -501,7 +501,7 @@ impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n \n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.ident().name != kw::Invalid && lifetime.name.ident().name != kw::StaticLifetime {\n+        if lifetime.name.ident().name != kw::Empty && lifetime.name.ident().name != kw::StaticLifetime {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}]}