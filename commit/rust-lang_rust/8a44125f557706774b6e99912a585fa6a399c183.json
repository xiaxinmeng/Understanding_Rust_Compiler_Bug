{"sha": "8a44125f557706774b6e99912a585fa6a399c183", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNDQxMjVmNTU3NzA2Nzc0YjZlOTk5MTJhNTg1ZmE2YTM5OWMxODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-24T03:16:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-24T03:16:47Z"}, "message": "Auto merge of #60224 - Centril:rollup-lfuhhsk, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #56278 (Future-proof MIR for dedicated debuginfo.)\n - #59739 (Stabilize futures_api)\n - #59822 (Fix dark css rule)\n - #60186 (Temporarily accept [i|u][32|size] suffixes on a tuple index and warn)\n - #60190 (Don't generate unnecessary rmeta files.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "72ba05ca46788988c1c644515dda05c7d24bab88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72ba05ca46788988c1c644515dda05c7d24bab88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a44125f557706774b6e99912a585fa6a399c183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a44125f557706774b6e99912a585fa6a399c183", "html_url": "https://github.com/rust-lang/rust/commit/8a44125f557706774b6e99912a585fa6a399c183", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a44125f557706774b6e99912a585fa6a399c183/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0928511d3a11ecc9703c3c34f0fe36282dd9b171", "url": "https://api.github.com/repos/rust-lang/rust/commits/0928511d3a11ecc9703c3c34f0fe36282dd9b171", "html_url": "https://github.com/rust-lang/rust/commit/0928511d3a11ecc9703c3c34f0fe36282dd9b171"}, {"sha": "7304e969df1dddee7ea370df8c91b7dd1ee6d58c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7304e969df1dddee7ea370df8c91b7dd1ee6d58c", "html_url": "https://github.com/rust-lang/rust/commit/7304e969df1dddee7ea370df8c91b7dd1ee6d58c"}], "stats": {"total": 921, "additions": 567, "deletions": 354}, "files": [{"sha": "207359ed6968f029879a267b042d0d7244cc7561", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -911,7 +911,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n "}, {"sha": "eb673488170b64a15d6acc145ddf6465a513d09f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -85,7 +85,6 @@\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n-#![feature(futures_api)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(needs_allocator)]"}, {"sha": "504330a023b31408115f2c8fbdb8c902d25fcf36", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,4 @@\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n use crate::marker::Unpin;\n use crate::ops;\n@@ -26,8 +24,10 @@ use crate::task::{Context, Poll};\n /// `await!` the value.\n #[doc(spotlight)]\n #[must_use = \"futures do nothing unless polled\"]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub trait Future {\n     /// The type of value produced on completion.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering\n@@ -92,9 +92,11 @@ pub trait Future {\n     /// [`Context`]: ../task/struct.Context.html\n     /// [`Waker`]: ../task/struct.Waker.html\n     /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for &mut F {\n     type Output = F::Output;\n \n@@ -103,6 +105,7 @@ impl<F: ?Sized + Future + Unpin> Future for &mut F {\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<P> Future for Pin<P>\n where\n     P: Unpin + ops::DerefMut,"}, {"sha": "89ea4713cfdaaa43b377e9bc18fa49735940a48b", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,8 +1,7 @@\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n //! Asynchronous values.\n \n mod future;\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;"}, {"sha": "ef090928392cd70eff1404c260d9a9dea3c3cc1b", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,11 +1,11 @@\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n //! Types and Traits for working with asynchronous tasks.\n \n mod poll;\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::poll::Poll;\n \n mod wake;\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::wake::{Context, Waker, RawWaker, RawWakerVTable};"}, {"sha": "3db70d5e7645f1eccb4e288aa71c67c562768357", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,4 @@\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n use crate::ops::Try;\n use crate::result::Result;\n@@ -9,20 +7,27 @@ use crate::result::Result;\n /// scheduled to receive a wakeup instead.\n #[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n-    Ready(T),\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+    Ready(\n+        #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+        T\n+    ),\n \n     /// Represents that a value is not ready yet.\n     ///\n     /// When a function returns `Pending`, the function *must* also\n     /// ensure that the current task is scheduled to be awoken when\n     /// progress can be made.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     Pending,\n }\n \n impl<T> Poll<T> {\n     /// Changes the ready value of this `Poll` with the closure provided.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n         where F: FnOnce(T) -> U\n     {\n@@ -34,6 +39,7 @@ impl<T> Poll<T> {\n \n     /// Returns `true` if this is `Poll::Ready`\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn is_ready(&self) -> bool {\n         match *self {\n             Poll::Ready(_) => true,\n@@ -43,13 +49,15 @@ impl<T> Poll<T> {\n \n     /// Returns `true` if this is `Poll::Pending`\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n }\n \n impl<T, E> Poll<Result<T, E>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n         where F: FnOnce(T) -> U\n     {\n@@ -61,6 +69,7 @@ impl<T, E> Poll<Result<T, E>> {\n     }\n \n     /// Changes the error value of this `Poll` with the closure provided.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n         where F: FnOnce(E) -> U\n     {\n@@ -72,12 +81,14 @@ impl<T, E> Poll<Result<T, E>> {\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T> From<T> for Poll<T> {\n     fn from(t: T) -> Poll<T> {\n         Poll::Ready(t)\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T, E> Try for Poll<Result<T, E>> {\n     type Ok = Poll<T>;\n     type Error = E;\n@@ -102,6 +113,7 @@ impl<T, E> Try for Poll<Result<T, E>> {\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T, E> Try for Poll<Option<Result<T, E>>> {\n     type Ok = Poll<Option<T>>;\n     type Error = E;"}, {"sha": "b4e91249832051d7d6fa7482669c6f5bfbb186e7", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,4 @@\n-#![unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n use crate::fmt;\n use crate::marker::{PhantomData, Unpin};\n@@ -13,6 +11,7 @@ use crate::marker::{PhantomData, Unpin};\n /// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n /// customizes the behavior of the `RawWaker`.\n #[derive(PartialEq, Debug)]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct RawWaker {\n     /// A data pointer, which can be used to store arbitrary data as required\n     /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n@@ -37,9 +36,7 @@ impl RawWaker {\n     /// from a `RawWaker`. For each operation on the `Waker`, the associated\n     /// function in the `vtable` of the underlying `RawWaker` will be called.\n     #[rustc_promotable]\n-    #[unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n         RawWaker {\n             data,\n@@ -58,6 +55,7 @@ impl RawWaker {\n /// pointer of a properly constructed [`RawWaker`] object from inside the\n /// [`RawWaker`] implementation. Calling one of the contained functions using\n /// any other `data` pointer will cause undefined behavior.\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RawWakerVTable {\n     /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n@@ -131,9 +129,14 @@ impl RawWakerVTable {\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n     #[rustc_promotable]\n-    #[unstable(feature = \"futures_api\",\n-            reason = \"futures in libcore are unstable\",\n-            issue = \"50547\")]\n+    #[cfg_attr(stage0, unstable(feature = \"futures_api_const_fn_ptr\", issue = \"50547\"))]\n+    #[cfg_attr(not(stage0), stable(feature = \"futures_api\", since = \"1.36.0\"))]\n+    // `rustc_allow_const_fn_ptr` is a hack that should not be used anywhere else\n+    // without first consulting with T-Lang.\n+    //\n+    // FIXME: remove whenever we have a stable way to accept fn pointers from const fn\n+    // (see https://github.com/rust-rfcs/const-eval/issues/19#issuecomment-472799062)\n+    #[cfg_attr(not(stage0), rustc_allow_const_fn_ptr)]\n     pub const fn new(\n         clone: unsafe fn(*const ()) -> RawWaker,\n         wake: unsafe fn(*const ()),\n@@ -153,6 +156,7 @@ impl RawWakerVTable {\n ///\n /// Currently, `Context` only serves to provide access to a `&Waker`\n /// which can be used to wake the current task.\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct Context<'a> {\n     waker: &'a Waker,\n     // Ensure we future-proof against variance changes by forcing\n@@ -164,6 +168,7 @@ pub struct Context<'a> {\n \n impl<'a> Context<'a> {\n     /// Create a new `Context` from a `&Waker`.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[inline]\n     pub fn from_waker(waker: &'a Waker) -> Self {\n         Context {\n@@ -173,12 +178,14 @@ impl<'a> Context<'a> {\n     }\n \n     /// Returns a reference to the `Waker` for the current task.\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[inline]\n     pub fn waker(&self) -> &'a Waker {\n         &self.waker\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl fmt::Debug for Context<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Context\")\n@@ -195,17 +202,22 @@ impl fmt::Debug for Context<'_> {\n ///\n /// Implements [`Clone`], [`Send`], and [`Sync`].\n #[repr(transparent)]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct Waker {\n     waker: RawWaker,\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl Unpin for Waker {}\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n unsafe impl Send for Waker {}\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n unsafe impl Sync for Waker {}\n \n impl Waker {\n     /// Wake up the task associated with this `Waker`.\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn wake(self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n@@ -227,6 +239,7 @@ impl Waker {\n     /// where an owned `Waker` is available. This method should be preferred to\n     /// calling `waker.clone().wake()`.\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn wake_by_ref(&self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n@@ -243,6 +256,7 @@ impl Waker {\n     ///\n     /// This function is primarily used for optimization purposes.\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n         self.waker == other.waker\n     }\n@@ -253,13 +267,15 @@ impl Waker {\n     /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n     /// Therefore this method is unsafe.\n     #[inline]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n         Waker {\n             waker,\n         }\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl Clone for Waker {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -272,6 +288,7 @@ impl Clone for Waker {\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl Drop for Waker {\n     #[inline]\n     fn drop(&mut self) {\n@@ -282,6 +299,7 @@ impl Drop for Waker {\n     }\n }\n \n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl fmt::Debug for Waker {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let vtable_ptr = self.waker.vtable as *const RawWakerVTable;"}, {"sha": "40cce8e77c0e049028d51d44bc9f8879ef43d226", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -121,6 +121,7 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     feature,\n     rustc_depr,\n     promotable,\n+    allow_const_fn_ptr,\n     const_stability\n });\n "}, {"sha": "8ce86f70a551f929047f774c79f79bad228dc42e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -441,6 +441,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                     rustc_depr: None,\n                     const_stability: None,\n                     promotable: false,\n+                    allow_const_fn_ptr: false,\n                 });\n                 annotator.parent_stab = Some(stability);\n             }"}, {"sha": "bf2a1eaafd664fad79ba942d98cac64b8fcb715c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -4,7 +4,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir::{self, HirId, InlineAsm as HirInlineAsm};\n+use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n@@ -138,16 +138,20 @@ pub struct Mir<'tcx> {\n     /// If this MIR was built for a constant, this will be 0.\n     pub arg_count: usize,\n \n-    /// Names and capture modes of all the closure upvars, assuming\n-    /// the first argument is either the closure or a reference to it.\n-    pub upvar_decls: Vec<UpvarDecl>,\n-\n     /// Mark an argument local (which must be a tuple) as getting passed as\n     /// its individual components at the LLVM level.\n     ///\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n+    /// Names and capture modes of all the closure upvars, assuming\n+    /// the first argument is either the closure or a reference to it.\n+    // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n+    // debuginfo generation, and will be removed at some point.\n+    // Do **NOT** use it for anything else, upvar information should not be\n+    // in the MIR, please rely on local crate HIR or other side-channels.\n+    pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+\n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n     /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n     /// this conversion from happening and use short circuiting, we will cause the following code\n@@ -173,7 +177,7 @@ impl<'tcx> Mir<'tcx> {\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n-        upvar_decls: Vec<UpvarDecl>,\n+        __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n@@ -197,7 +201,7 @@ impl<'tcx> Mir<'tcx> {\n             local_decls,\n             user_type_annotations,\n             arg_count,\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n             spread_arg: None,\n             span,\n             cache: cache::Cache::new(),\n@@ -431,7 +435,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     local_decls,\n     user_type_annotations,\n     arg_count,\n-    upvar_decls,\n+    __upvar_debuginfo_codegen_only_do_not_use,\n     spread_arg,\n     control_flow_destroyed,\n     span,\n@@ -983,16 +987,11 @@ impl<'tcx> LocalDecl<'tcx> {\n \n /// A closure capture, with its name and mode.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UpvarDecl {\n+pub struct UpvarDebuginfo {\n     pub debug_name: Name,\n \n-    /// `HirId` of the captured variable\n-    pub var_hir_id: ClearCrossCrate<HirId>,\n-\n     /// If true, the capture is behind a reference.\n     pub by_ref: bool,\n-\n-    pub mutability: Mutability,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -3156,7 +3155,7 @@ CloneTypeFoldableAndLiftImpls! {\n     MirPhase,\n     Mutability,\n     SourceInfo,\n-    UpvarDecl,\n+    UpvarDebuginfo,\n     FakeReadCause,\n     RetagKind,\n     SourceScope,\n@@ -3178,7 +3177,7 @@ BraceStructTypeFoldableImpl! {\n         local_decls,\n         user_type_annotations,\n         arg_count,\n-        upvar_decls,\n+        __upvar_debuginfo_codegen_only_do_not_use,\n         spread_arg,\n         control_flow_destroyed,\n         span,"}, {"sha": "04b763f773d9ed089656ceaf854e877dc3117170", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -133,41 +133,6 @@ impl<'tcx> Place<'tcx> {\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    pub fn is_upvar_field_projection<'cx, 'gcx>(&self, mir: &'cx Mir<'tcx>,\n-                                                tcx: &TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Field> {\n-        let (place, by_ref) = if let Place::Projection(ref proj) = self {\n-            if let ProjectionElem::Deref = proj.elem {\n-                (&proj.base, true)\n-            } else {\n-                (self, false)\n-            }\n-        } else {\n-            (self, false)\n-        };\n-\n-        match place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).ty;\n-\n-                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n-                        (!by_ref || mir.upvar_decls[field.index()].by_ref)\n-                    {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            }\n-            _ => None,\n-        }\n-    }\n }\n \n pub enum RvalueInitializationState {"}, {"sha": "1861420b408b6ccf79494c8e2aa3d0161ae68abb", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -235,6 +235,8 @@ rustc_queries! {\n         /// constructor function).\n         query is_promotable_const_fn(_: DefId) -> bool {}\n \n+        query const_fn_is_allowed_fn_ptr(_: DefId) -> bool {}\n+\n         /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n         query is_foreign_item(_: DefId) -> bool {}\n "}, {"sha": "7298b548f3197ab248581f3d9fa70aacffef76cb", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -95,9 +95,16 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n+    fn const_fn_is_allowed_fn_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+        tcx.is_const_fn(def_id) &&\n+            tcx.lookup_stability(def_id)\n+                .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)\n+    }\n+\n     *providers = Providers {\n         is_const_fn_raw,\n         is_promotable_const_fn,\n+        const_fn_is_allowed_fn_ptr,\n         ..*providers\n     };\n }"}, {"sha": "cb00cca0f9c960f7b491d63ac493726722ec5505", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -542,7 +542,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         finalize(self)\n     }\n \n-    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n+    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n         unsafe {\n             [llvm::LLVMRustDIBuilderCreateOpDeref(),\n              llvm::LLVMRustDIBuilderCreateOpPlusUconst(),"}, {"sha": "fe703ff4d25dd0894723c7dc6707904b4298a110", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -83,14 +83,16 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n         for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n             remove(sess, obj);\n         }\n-        if let Some(ref obj) = codegen_results.metadata_module.object {\n-            remove(sess, obj);\n-        }\n-        if let Some(ref allocator) = codegen_results.allocator_module {\n-            if let Some(ref obj) = allocator.object {\n+        if let Some(ref metadata_module) = codegen_results.metadata_module {\n+            if let Some(ref obj) = metadata_module.object {\n+                remove(sess, obj);\n+            }\n+         }\n+        if let Some(ref allocator_module) = codegen_results.allocator_module {\n+            if let Some(ref obj) = allocator_module.object {\n                 remove(sess, obj);\n             }\n-            if let Some(ref bc) = allocator.bytecode_compressed {\n+            if let Some(ref bc) = allocator_module.bytecode_compressed {\n                 remove(sess, bc);\n             }\n         }\n@@ -1067,7 +1069,10 @@ fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // object file, so we link that in here.\n     if crate_type == config::CrateType::Dylib ||\n        crate_type == config::CrateType::ProcMacro {\n-        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n+        let obj = codegen_results.metadata_module\n+            .as_ref()\n+            .and_then(|m| m.object.as_ref());\n+        if let Some(obj) = obj {\n             cmd.add_object(obj);\n         }\n     }"}, {"sha": "88a5e5a1aec3b4ccf6a256506fe9cfdc7e51177e", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -350,7 +350,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n \n pub struct CompiledModules {\n     pub modules: Vec<CompiledModule>,\n-    pub metadata_module: CompiledModule,\n+    pub metadata_module: Option<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n }\n \n@@ -682,8 +682,10 @@ fn produce_final_output_artifacts(sess: &Session,\n         }\n \n         if !user_wants_bitcode {\n-            if let Some(ref path) = compiled_modules.metadata_module.bytecode {\n-                remove(sess, &path);\n+            if let Some(ref metadata_module) = compiled_modules.metadata_module {\n+                if let Some(ref path) = metadata_module.bytecode {\n+                    remove(sess, &path);\n+                }\n             }\n \n             if let Some(ref allocator_module) = compiled_modules.allocator_module {\n@@ -1564,9 +1566,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         // out deterministic results.\n         compiled_modules.sort_by(|a, b| a.name.cmp(&b.name));\n \n-        let compiled_metadata_module = compiled_metadata_module\n-            .expect(\"Metadata module not compiled?\");\n-\n         Ok(CompiledModules {\n             modules: compiled_modules,\n             metadata_module: compiled_metadata_module,"}, {"sha": "3046c069981cb31ae677c3b4ac0ea734343b7cd2", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -25,7 +25,7 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::session::config::{self, EntryFnType, Lto};\n+use rustc::session::config::{self, CrateType, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n@@ -550,12 +550,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     });\n     tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n \n-    let metadata_module = ModuleCodegen {\n-        name: metadata_cgu_name,\n-        module_llvm: metadata_llvm_module,\n-        kind: ModuleKind::Metadata,\n-    };\n-\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen ||\n        !tcx.sess.opts.output_types.should_codegen() {\n@@ -566,7 +560,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             rx,\n             1);\n \n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n         ongoing_codegen.codegen_finished(tcx);\n \n         assert_and_save_dep_graph(tcx);\n@@ -639,7 +632,24 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n     }\n \n-    ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+    let needs_metadata_module = tcx.sess.crate_types.borrow().iter().any(|ct| {\n+        match *ct {\n+            CrateType::Dylib |\n+            CrateType::ProcMacro => true,\n+            CrateType::Executable |\n+            CrateType::Rlib |\n+            CrateType::Staticlib |\n+            CrateType::Cdylib => false,\n+        }\n+    });\n+    if needs_metadata_module {\n+        let metadata_module = ModuleCodegen {\n+            name: metadata_cgu_name,\n+            module_llvm: metadata_llvm_module,\n+            kind: ModuleKind::Metadata,\n+        };\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n+    }\n \n     // We sort the codegen units by size. This way we can schedule work for LLVM\n     // a bit more efficiently."}, {"sha": "4d7af7a643b66003ed37b917660a826e807d97c6", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -154,7 +154,7 @@ pub struct CodegenResults {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n-    pub metadata_module: CompiledModule,\n+    pub metadata_module: Option<CompiledModule>,\n     pub crate_hash: Svh,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     pub windows_subsystem: Option<String>,"}, {"sha": "621c4e5d4488e77dc49e047220a182bb7d2c6002", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -598,9 +598,10 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 tmp\n             }\n         };\n+        let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n-            if arg_index > 0 || mir.upvar_decls.is_empty() {\n+            if arg_index > 0 || upvar_debuginfo.is_empty() {\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM always does the deref itself,\n@@ -638,16 +639,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             let (def_id, upvar_substs) = match closure_layout.ty.sty {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n+                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n             let extra_locals = {\n-                let upvars = mir.upvar_decls\n+                let upvars = upvar_debuginfo\n                     .iter()\n                     .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (decl, ty))| (i, decl.debug_name, decl.by_ref, ty));\n+                    .map(|(i, (upvar, ty))| (i, upvar.debug_name, upvar.by_ref, ty));\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n                     let (def_id, gen_substs) = match closure_layout.ty.sty {\n@@ -656,7 +657,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     };\n                     let state_tys = gen_substs.state_tys(def_id, tcx);\n \n-                    let upvar_count = mir.upvar_decls.len();\n+                    let upvar_count = upvar_debuginfo.len();\n                     generator_layout.fields\n                         .iter()\n                         .zip(state_tys)\n@@ -673,7 +674,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             for (field, name, by_ref, ty) in extra_locals {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(field).bytes();\n \n-                let ops = bx.debuginfo_upvar_decls_ops_sequence(byte_offset_of_var_in_env);\n+                let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n \n                 // The environment and the capture can each be indirect.\n                 let mut ops = if env_ref { &ops[..] } else { &ops[1..] };"}, {"sha": "aadffc5932ba856d8d2dc790687ce271d8d96858", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -37,7 +37,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n-    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4];\n+    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4];\n }\n \n pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {"}, {"sha": "12dcea7bd5981d619e16fad91602587925e3afb6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1088,7 +1088,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                         LocalKind::Var => \"local variable \",\n                         LocalKind::Arg\n-                        if !self.mir.upvar_decls.is_empty()\n+                        if !self.upvars.is_empty()\n                             && local == Local::new(1) => {\n                             \"variable captured by `move` \"\n                         }\n@@ -1632,11 +1632,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            if self.mir.upvar_decls[var_index].by_ref {\n+                            let name = self.upvars[var_index].name.to_string();\n+                            if self.upvars[var_index].by_ref {\n                                 buf.push_str(&name);\n                             } else {\n                                 buf.push_str(&format!(\"*{}\", &name));\n@@ -1694,10 +1694,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         autoderef = true;\n \n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            let name = self.upvars[var_index].name.to_string();\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);"}, {"sha": "14cafdef67d7de8b2cf931f3f22a66bf0009b3e5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 94, "deletions": 16, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n-use rustc::hir;\n+use rustc::hir::{self, HirId};\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -27,6 +27,7 @@ use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n \n+use syntax::ast::Name;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n@@ -63,6 +64,19 @@ mod used_muts;\n \n pub(crate) mod nll;\n \n+// FIXME(eddyb) perhaps move this somewhere more centrally.\n+#[derive(Debug)]\n+crate struct Upvar {\n+    name: Name,\n+\n+    var_hir_id: HirId,\n+\n+    /// If true, the capture is behind a reference.\n+    by_ref: bool,\n+\n+    mutability: Mutability,\n+}\n+\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         mir_borrowck,\n@@ -126,6 +140,36 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .as_local_hir_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n+    // Gather the upvars of a closure, if any.\n+    let tables = tcx.typeck_tables_of(def_id);\n+    let upvars: Vec<_> = tables\n+        .upvar_list\n+        .get(&def_id)\n+        .into_iter()\n+        .flatten()\n+        .map(|upvar_id| {\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);\n+            let capture = tables.upvar_capture(*upvar_id);\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true,\n+            };\n+            let mut upvar = Upvar {\n+                name: tcx.hir().name(var_node_id),\n+                var_hir_id,\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            let bm = *tables.pat_binding_modes().get(var_hir_id)\n+                .expect(\"missing binding mode\");\n+            if bm == ty::BindByValue(hir::MutMutable) {\n+                upvar.mutability = Mutability::Mut;\n+            }\n+            upvar\n+        })\n+        .collect();\n+\n     // Replace all regions with fresh inference variables. This\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n@@ -168,6 +212,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        &upvars,\n         location_table,\n         param_env,\n         &mut flow_inits,\n@@ -240,6 +285,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n         dominators,\n+        upvars,\n     };\n \n     let mut state = Flows::new(\n@@ -475,6 +521,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n \n     /// Dominators for MIR\n     dominators: Dominators<BasicBlock>,\n+\n+    /// Information about upvars not necessarily preserved in types or MIR\n+    upvars: Vec<Upvar>,\n }\n \n // Check that:\n@@ -1287,8 +1336,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n             match *place {\n                 Place::Projection { .. } => {\n-                    if let Some(field) = place.is_upvar_field_projection(\n-                            this.mir, &this.infcx.tcx) {\n+                    if let Some(field) = this.is_upvar_field_projection(place) {\n                         this.used_mut_upvars.push(field);\n                     }\n                 }\n@@ -2057,7 +2105,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.infcx.tcx) {\n+                if let Some(field) = self.is_upvar_field_projection(place) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -2127,13 +2175,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match place.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx)\n-                                        {\n+                                        let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n-                                                if {\n-                                                    self.mir.upvar_decls[field.index()].by_ref\n-                                                } =>\n+                                                if self.upvars[field.index()].by_ref =>\n                                             {\n                                                 is_local_mutation_allowed\n                                             }\n@@ -2173,15 +2217,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.infcx.tcx);\n+                        let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n-                            let decl = &self.mir.upvar_decls[field.index()];\n+                            let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                decl, is_local_mutation_allowed, place\n+                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                upvar, is_local_mutation_allowed, place\n                             );\n-                            match (decl.mutability, is_local_mutation_allowed) {\n+                            match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n                                     Err(place)\n@@ -2229,6 +2272,41 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// If `place` is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    pub fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        let (place, by_ref) = if let Place::Projection(ref proj) = place {\n+            if let ProjectionElem::Deref = proj.elem {\n+                (&proj.base, true)\n+            } else {\n+                (place, false)\n+            }\n+        } else {\n+            (place, false)\n+        };\n+\n+        match place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = proj.base.ty(self.mir, tcx).ty;\n+\n+                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n+                        (!by_ref || self.upvars[field.index()].by_ref)\n+                    {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "a7bad44c42c7f500f9b85a2894dabb4506ebfc55", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   original_path.is_upvar_field_projection(self.mir, &self.infcx.tcx));\n+                   self.is_upvar_field_projection(original_path));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n@@ -269,16 +269,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n-                                 .is_some());\n+                            .any(|p| self.is_upvar_field_projection(p).is_some());\n                         debug!(\"report: ty={:?}\", ty);\n                         match ty.sty {\n                             ty::Array(..) | ty::Slice(..) =>\n                                 self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n                                     span, ty, None, origin\n                                 ),\n                             ty::Closure(def_id, closure_substs)\n-                                if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n+                                if def_id == self.mir_def_id && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty =\n                                     closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n@@ -303,11 +302,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                     span, place_description, origin);\n \n                                 for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                    if let Some(field) = prefix.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx) {\n-                                        let upvar_decl = &self.mir.upvar_decls[field.index()];\n-                                        let upvar_hir_id =\n-                                            upvar_decl.var_hir_id.assert_crate_local();\n+                                    if let Some(field) = self.is_upvar_field_projection(prefix) {\n+                                        let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n                                         let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n                                             upvar_hir_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");"}, {"sha": "c5ad2b18c23fcf634b31a2ea7c61dd3e58a1d4e6", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -68,10 +68,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if access_place.is_upvar_field_projection(self.mir, &self.infcx.tcx).is_some() {\n+                if self.is_upvar_field_projection(access_place).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n+                    let name = self.upvars[upvar_index.index()].name;\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -81,15 +81,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Deref,\n             }) => {\n                 if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                    !self.mir.upvar_decls.is_empty() {\n+                    !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n-                    reason = if access_place.is_upvar_field_projection(self.mir,\n-                                                                       &self.infcx.tcx).is_some() {\n+                    reason = if self.is_upvar_field_projection(access_place).is_some() {\n                         \", as it is a captured variable in a `Fn` closure\".to_string()\n                     } else {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n@@ -309,9 +308,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n-                    .var_hir_id\n-                    .assert_crate_local();\n+                let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n                 let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n                 if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n@@ -452,7 +449,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 base,\n                 elem: ProjectionElem::Deref,\n             }) if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                  !self.mir.upvar_decls.is_empty() =>\n+                  !self.upvars.is_empty() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help("}, {"sha": "89f85a941d386107e1ae427cabd3c08ee8ab16f5", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -273,11 +273,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if mir.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place::Base(PlaceBase::Local(borrowed_local)) = place {\n-                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n-                            let borrowed_local_scope =\n-                                mir.local_decls[*borrowed_local].visibility_scope;\n-\n-                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                             if mir.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n                             {\n                                 should_note_order = true;\n@@ -298,6 +294,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n                             self.mir,\n+                        &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n                             borrow_region_vid,"}, {"sha": "ad43c8ef66f42b5ecf5bc6d52ea46d618745d65a", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -8,6 +8,7 @@ use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n@@ -72,6 +73,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n@@ -187,7 +189,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id, errors_buffer);\n+    let closure_region_requirements =\n+        regioncx.solve(infcx, &mir, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "abb30d042ca4cd8e819ee4a9ffb3f868e5d60a7a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n@@ -237,6 +238,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn report_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -273,6 +275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n                 self.report_fnmut_error(\n                     mir,\n+                    upvars,\n                     infcx,\n                     mir_def_id,\n                     fr,\n@@ -284,6 +287,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -294,6 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ),\n             _ => self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -353,6 +358,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_fnmut_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         _fr: RegionVid,\n@@ -377,7 +383,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1).unwrap().source {\n+        match self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, &mut 1)\n+            .unwrap().source\n+        {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -415,6 +423,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_escaping_data_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -423,9 +432,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let fr_name_and_span = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+        let fr_name_and_span =\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -442,6 +452,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         {\n             return self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -504,6 +515,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_general_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -520,10 +532,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter).unwrap();\n+        let fr_name = self.give_region_a_name(infcx, mir, upvars, mir_def_id, fr, counter).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, counter).unwrap();\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, counter).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n@@ -656,6 +668,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn free_region_constraint_info(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         borrow_region: RegionVid,\n@@ -664,7 +677,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let (category, from_closure, span) =\n             self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_region, &mut 1);\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "680e7ce576af04ef6addfb05fb4e43869237da9e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -2,6 +2,7 @@ use std::fmt::{self, Display};\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -144,6 +145,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -160,7 +162,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, mir, fr, counter,\n+                    infcx.tcx, upvars, fr, counter,\n                 )\n             })\n             .or_else(|| {\n@@ -639,13 +641,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n+            self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n         Some(RegionName {"}, {"sha": "d8f34233839b9796d77f437ff6a2fb7603a84235", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,5 +1,6 @@\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::mir::{Local, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -11,6 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n@@ -19,7 +21,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n             .map(|index| {\n-                let (name, span) = self.get_upvar_name_and_span_for_region(tcx, mir, index);\n+                let (name, span) =\n+                    self.get_upvar_name_and_span_for_region(tcx, upvars, index);\n                 (Some(name), span)\n             })\n             .or_else(|| {\n@@ -67,10 +70,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n-        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_hir_id = upvars[upvar_index].var_hir_id;\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);"}, {"sha": "9dd18ab76a5f2268a7d908e255afb2f1e694e148", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, O\n use crate::borrow_check::nll::region_infer::values::{\n     PlaceholderIndices, RegionElement, ToElementIndex\n };\n+use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -400,21 +401,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         common::time_ext(\n             infcx.tcx.sess.time_extended(),\n             Some(infcx.tcx.sess),\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, mir, mir_def_id, errors_buffer),\n+            || self.solve_inner(infcx, mir, upvars, mir_def_id, errors_buffer),\n         )\n     }\n \n     fn solve_inner<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n@@ -442,6 +445,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.check_universal_regions(\n             infcx,\n             mir,\n+            upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n@@ -1102,6 +1106,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1115,6 +1120,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_universal_region(\n                         infcx,\n                         mir,\n+                        upvars,\n                         mir_def_id,\n                         fr,\n                         &mut propagated_outlives_requirements,\n@@ -1145,6 +1151,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1177,6 +1184,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 representative,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1192,6 +1200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 shorter_fr,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1208,6 +1217,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1265,7 +1275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        self.report_error(mir, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         Some(ErrorReported)\n     }\n "}, {"sha": "d3cef46b4022d860d77cd9d4808a4d9fb530284c", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// Returns a list of all the upvar types for this MIR. If this is\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n-    /// match up with the `upvar_decls` field of `Mir`.\n+    /// match up with the upvar order in the HIR, typesystem, and MIR.\n     pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),"}, {"sha": "c58b570d8fc9fb74710378ef83a8338836cd8245", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -556,10 +556,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n                 // Not in a closure\n                 debug_assert!(\n-                    this.upvar_decls.len() > upvar_index.index(),\n+                    this.upvar_mutbls.len() > upvar_index.index(),\n                     \"Unexpected capture place\"\n                 );\n-                this.upvar_decls[upvar_index.index()].mutability\n+                this.upvar_mutbls[upvar_index.index()]\n             }\n             _ => bug!(\"Unexpected capture place\"),\n         };"}, {"sha": "5e15d98e246b7935ca9fefbfc0a14e3b959dca54", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -505,14 +505,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n-                    visibility_scope =\n-                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n                     // If we have lints, create a new source scope\n                     // that marks the lints for the locals. See the comment\n                     // on the `source_info` field for why this is needed.\n                     if lint_level.is_explicit() {\n                         scope = this.new_source_scope(scope_span, lint_level, None);\n                     }\n+                visibility_scope = Some(this.new_source_scope(scope_span,\n+                                                           LintLevel::Inherited,\n+                                                           None));\n                 }\n                 let source_info = SourceInfo { span, scope };\n                 let visibility_scope = visibility_scope.unwrap();"}, {"sha": "79e1d5daae1942ed92cb515eb1fcd5684da31287", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -375,7 +375,8 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     var_indices: HirIdMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n-    upvar_decls: Vec<UpvarDecl>,\n+    __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+    upvar_mutbls: Vec<Mutability>,\n     unit_temp: Option<Place<'tcx>>,\n \n     /// Cached block with the `RESUME` terminator; this is created\n@@ -625,11 +626,12 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n+    let mut upvar_mutbls = vec![];\n     // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n     // closure and we stored in a map called upvar_list in TypeckTables indexed\n     // with the closure's DefId. Here, we run through that vec of UpvarIds for\n     // the given closure and use the necessary information to create UpvarDecl.\n-    let upvar_decls: Vec<_> = hir_tables\n+    let upvar_debuginfo: Vec<_> = hir_tables\n         .upvar_list\n         .get(&fn_def_id)\n         .into_iter()\n@@ -642,27 +644,27 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut decl = UpvarDecl {\n+            let mut debuginfo = UpvarDebuginfo {\n                 debug_name: keywords::Invalid.name(),\n-                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n                 by_ref,\n-                mutability: Mutability::Not,\n             };\n+            let mut mutability = Mutability::Not;\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n+                    debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n-                            decl.mutability = Mutability::Mut;\n+                            mutability = Mutability::Mut;\n                         } else {\n-                            decl.mutability = Mutability::Not;\n+                            mutability = Mutability::Not;\n                         }\n                     } else {\n                         tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n             }\n-            decl\n+            upvar_mutbls.push(mutability);\n+            debuginfo\n         })\n         .collect();\n \n@@ -672,7 +674,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         safety,\n         return_ty,\n         return_ty_span,\n-        upvar_decls);\n+        upvar_debuginfo,\n+        upvar_mutbls);\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n@@ -734,7 +737,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, ty_span,vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, ty_span, vec![], vec![]);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -762,7 +765,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![], vec![]);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(None)\n@@ -775,7 +778,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           upvar_decls: Vec<UpvarDecl>)\n+           __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+           upvar_mutbls: Vec<Mutability>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n@@ -797,7 +801,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 1,\n             ),\n             canonical_user_type_annotations: IndexVec::new(),\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n+            upvar_mutbls,\n             var_indices: Default::default(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -832,7 +837,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls,\n             self.canonical_user_type_annotations,\n             self.arg_count,\n-            self.upvar_decls,\n+            self.__upvar_debuginfo_codegen_only_do_not_use,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n         )"}, {"sha": "bd6f005e8736c992de7605eb6a60481934f47a10", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -3,6 +3,7 @@ use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::Symbol;\n+use rustc::hir;\n use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n@@ -165,13 +166,28 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n         match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(upvar) = self.ecx.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n-                    PathElem::ClosureVar(upvar.debug_name)\n-                } else {\n-                    // Sometimes the index is beyond the number of freevars (seen\n-                    // for a generator).\n-                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+                let mut name = None;\n+                if def_id.is_local() {\n+                    let tables = self.ecx.tcx.typeck_tables_of(def_id);\n+                    if let Some(upvars) = tables.upvar_list.get(&def_id) {\n+                        // Sometimes the index is beyond the number of freevars (seen\n+                        // for a generator).\n+                        if let Some(upvar_id) = upvars.get(field) {\n+                            let var_hir_id = upvar_id.var_path.hir_id;\n+                            let var_node_id = self.ecx.tcx.hir().hir_to_node_id(var_hir_id);\n+                            if let hir::Node::Binding(pat) = self.ecx.tcx.hir().get(var_node_id) {\n+                                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                                    name = Some(ident.name);\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n+\n+                PathElem::ClosureVar(name.unwrap_or_else(|| {\n+                    // Fall back to showing the field index.\n+                    Symbol::intern(&field.to_string())\n+                }))\n             }\n \n             // tuples"}, {"sha": "2b909feb9603f0c675745ba02383c09610a5421a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -490,7 +490,7 @@ fn locals_live_across_suspend_points(\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource<'tcx>,\n-                            upvars: Vec<Ty<'tcx>>,\n+                            upvars: &Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n@@ -505,7 +505,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                             movable);\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n-    let allowed_upvars = tcx.erase_regions(&upvars);\n+    let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match interior.sty {\n         ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n@@ -528,7 +528,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let upvar_len = mir.upvar_decls.len();\n+    let upvar_len = upvars.len();\n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n@@ -917,12 +917,12 @@ impl MirPass for StateTransform {\n         let (remap, layout, storage_liveness) = compute_layout(\n             tcx,\n             source,\n-            upvars,\n+            &upvars,\n             interior,\n             movable,\n             mir);\n \n-        let state_field = mir.upvar_decls.len();\n+        let state_field = upvars.len();\n \n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`."}, {"sha": "e96a40ad2f036f1be0a4180a45d9773ef8869c66", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -222,10 +222,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n-        // Don't inline closures that have captures\n+        // Don't inline closures that have capture debuginfo\n         // FIXME: Handle closures better\n-        if callee_mir.upvar_decls.len() > 0 {\n-            debug!(\"    upvar decls present - not inlining\");\n+        if callee_mir.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n+            debug!(\"    upvar debuginfo present - not inlining\");\n             return false;\n         }\n "}, {"sha": "d5f04ca64e4c4ecb8907fe909aa0461b89ea03cc", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -60,13 +60,14 @@ pub fn is_min_const_fn(\n     }\n \n     for local in &mir.local_decls {\n-        check_ty(tcx, local.ty, local.source_info.span)?;\n+        check_ty(tcx, local.ty, local.source_info.span, def_id)?;\n     }\n     // impl trait is gone in MIR, so check the return type manually\n     check_ty(\n         tcx,\n         tcx.fn_sig(def_id).output().skip_binder(),\n         mir.local_decls.iter().next().unwrap().source_info.span,\n+        def_id,\n     )?;\n \n     for bb in mir.basic_blocks() {\n@@ -82,6 +83,7 @@ fn check_ty(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n+    fn_def_id: DefId,\n ) -> McfResult {\n     for ty in ty.walk() {\n         match ty.sty {\n@@ -91,7 +93,9 @@ fn check_ty(\n             )),\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n-                return Err((span, \"function pointers in const fn are unstable\".into()))\n+                if !tcx.const_fn_is_allowed_fn_ptr(fn_def_id) {\n+                    return Err((span, \"function pointers in const fn are unstable\".into()))\n+                }\n             }\n             ty::Dynamic(preds, _) => {\n                 for pred in preds.iter() {"}, {"sha": "1f55a728f9c720c01a6bd27d9f330791cba5f148", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -461,9 +461,7 @@ fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> S\n     )\n }\n \n-/// Prints user-defined variables in a scope tree.\n-///\n-/// Returns the total number of variables printed.\n+/// Prints local variables in a scope tree.\n fn write_scope_tree(\n     tcx: TyCtxt<'_, '_, '_>,\n     mir: &Mir<'_>,\n@@ -474,57 +472,64 @@ fn write_scope_tree(\n ) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n \n+    // Local variable types (including the user's name in a comment).\n+    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+        if (1..mir.arg_count+1).contains(&local.index()) {\n+            // Skip over argument locals, they're printed in the signature.\n+            continue;\n+        }\n+\n+        if local_decl.source_info.scope != parent {\n+            // Not declared in this scope.\n+            continue;\n+        }\n+\n+        let mut_str = if local_decl.mutability == Mutability::Mut {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        };\n+\n+        let mut indented_decl = format!(\n+            \"{0:1$}let {2}{3:?}: {4:?}\",\n+            INDENT,\n+            indent,\n+            mut_str,\n+            local,\n+            local_decl.ty\n+        );\n+        for user_ty in local_decl.user_ty.projections() {\n+            write!(indented_decl, \" as {:?}\", user_ty).unwrap();\n+        }\n+        indented_decl.push_str(\";\");\n+\n+        let local_name = if local == RETURN_PLACE {\n+            format!(\" return place\")\n+        } else if let Some(name) = local_decl.name {\n+            format!(\" \\\"{}\\\"\", name)\n+        } else {\n+            String::new()\n+        };\n+\n+        writeln!(\n+            w,\n+            \"{0:1$} //{2} in {3}\",\n+            indented_decl,\n+            ALIGN,\n+            local_name,\n+            comment(tcx, local_decl.source_info),\n+        )?;\n+    }\n+\n     let children = match scope_tree.get(&parent) {\n-        Some(children) => children,\n+        Some(childs) => childs,\n         None => return Ok(()),\n     };\n \n     for &child in children {\n-        let data = &mir.source_scopes[child];\n-        assert_eq!(data.parent_scope, Some(parent));\n+        assert_eq!(mir.source_scopes[child].parent_scope, Some(parent));\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n-\n-        // User variable types (including the user's name in a comment).\n-        for local in mir.vars_iter() {\n-            let var = &mir.local_decls[local];\n-            let (name, source_info) = if var.source_info.scope == child {\n-                (var.name.unwrap(), var.source_info)\n-            } else {\n-                // Not a variable or not declared in this scope.\n-                continue;\n-            };\n-\n-            let mut_str = if var.mutability == Mutability::Mut {\n-                \"mut \"\n-            } else {\n-                \"\"\n-            };\n-\n-            let indent = indent + INDENT.len();\n-            let mut indented_var = format!(\n-                \"{0:1$}let {2}{3:?}: {4:?}\",\n-                INDENT,\n-                indent,\n-                mut_str,\n-                local,\n-                var.ty\n-            );\n-            for user_ty in var.user_ty.projections() {\n-                write!(indented_var, \" as {:?}\", user_ty).unwrap();\n-            }\n-            indented_var.push_str(\";\");\n-            writeln!(\n-                w,\n-                \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                indented_var,\n-                ALIGN,\n-                name,\n-                comment(tcx, source_info)\n-            )?;\n-        }\n-\n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n-\n         writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }\n \n@@ -556,19 +561,8 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n         }\n     }\n \n-    // Print return place\n-    let indented_retptr = format!(\"{}let mut {:?}: {};\",\n-                                  INDENT,\n-                                  RETURN_PLACE,\n-                                  mir.local_decls[RETURN_PLACE].ty);\n-    writeln!(w, \"{0:1$} // return place\",\n-             indented_retptr,\n-             ALIGN)?;\n-\n     write_scope_tree(tcx, mir, &scope_tree, w, OUTERMOST_SOURCE_SCOPE, 1)?;\n \n-    write_temp_decls(mir, w)?;\n-\n     // Add an empty line before the first block is printed.\n     writeln!(w, \"\")?;\n \n@@ -632,22 +626,6 @@ fn write_mir_sig(\n     Ok(())\n }\n \n-fn write_temp_decls(mir: &Mir<'_>, w: &mut dyn Write) -> io::Result<()> {\n-    // Compiler-introduced temporary types.\n-    for temp in mir.temps_iter() {\n-        writeln!(\n-            w,\n-            \"{}let {}{:?}: {};\",\n-            INDENT,\n-            if mir.local_decls[temp].mutability == Mutability::Mut {\"mut \"} else {\"\"},\n-            temp,\n-            mir.local_decls[temp].ty\n-        )?;\n-    }\n-\n-    Ok(())\n-}\n-\n fn write_user_type_annotations(mir: &Mir<'_>, w: &mut dyn Write) -> io::Result<()> {\n     if !mir.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;"}, {"sha": "f1255f52247376bd1e7f8285dd10bb695e33b592", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -184,12 +184,12 @@ a.test-arrow {\n \tcolor: #ddd;\n }\n \n-.stab.unstable {background: #FFF5D6; border-color: #FFC600; color: #2f2f2f; }\n+.stab.unstable { background: #FFF5D6; border-color: #FFC600; color: #2f2f2f; }\n .stab.internal { background: #FFB9B3; border-color: #B71C1C; color: #2f2f2f; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; color: #2f2f2f; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; color: #2f2f2f; }\n \n-.stab > code {\n+.stab.portability > code {\n \tcolor: #ddd;\n }\n "}, {"sha": "c052e6b37ade7a51e9ac9bfad44763811af9e74b", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -190,7 +190,7 @@ a.test-arrow {\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n .stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n \n-.stab > code {\n+.stab.portability > code {\n \tcolor: #000;\n }\n "}, {"sha": "c18a314116bf0001cedb408cd40862a0a974ad3d", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -9,6 +9,7 @@ use core::task::{Context, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use core::future::*;\n \n /// Wrap a generator in a future."}, {"sha": "bdec0c347f546643f3bb7f8d37ea55b23fe5a118", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -263,7 +263,6 @@\n #![feature(fixed_size_array)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n-#![feature(futures_api)]\n #![feature(generator_trait)]\n #![feature(hash_raw_entry)]\n #![feature(hashmap_internals)]\n@@ -458,18 +457,15 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub mod task {\n     //! Types and Traits for working with asynchronous tasks.\n     #[doc(inline)]\n+    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub use core::task::*;\n }\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub mod future;\n \n // Platform-abstraction modules"}, {"sha": "7a3b5d30500a93a6cda9cb84d06aa5baa5f56c16", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -319,7 +319,7 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n "}, {"sha": "db821f4e5369d2b0c971a6aca7d37988878fddba", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -114,6 +114,8 @@ pub struct Stability {\n     pub const_stability: Option<Symbol>,\n     /// whether the function has a `#[rustc_promotable]` attribute\n     pub promotable: bool,\n+    /// whether the function has a `#[rustc_allow_const_fn_ptr]` attribute\n+    pub allow_const_fn_ptr: bool,\n }\n \n /// The available stability levels.\n@@ -178,6 +180,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n     let mut rustc_const_unstable: Option<Symbol> = None;\n     let mut promotable = false;\n+    let mut allow_const_fn_ptr = false;\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n@@ -187,6 +190,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             \"unstable\",\n             \"stable\",\n             \"rustc_promotable\",\n+            \"rustc_allow_const_fn_ptr\",\n         ].iter().any(|&s| attr.path == s) {\n             continue // not a stability level\n         }\n@@ -198,6 +202,9 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n         if attr.path == \"rustc_promotable\" {\n             promotable = true;\n         }\n+        if attr.path == \"rustc_allow_const_fn_ptr\" {\n+            allow_const_fn_ptr = true;\n+        }\n         // attributes with data\n         else if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n             let meta = meta.as_ref().unwrap();\n@@ -354,6 +361,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                 rustc_depr: None,\n                                 const_stability: None,\n                                 promotable: false,\n+                                allow_const_fn_ptr: false,\n                             })\n                         }\n                         (None, _, _) => {\n@@ -418,6 +426,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                 rustc_depr: None,\n                                 const_stability: None,\n                                 promotable: false,\n+                                allow_const_fn_ptr: false,\n                             })\n                         }\n                         (None, _) => {\n@@ -458,13 +467,14 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n     }\n \n     // Merge the const-unstable info into the stability info\n-    if promotable {\n+    if promotable || allow_const_fn_ptr {\n         if let Some(ref mut stab) = stab {\n-            stab.promotable = true;\n+            stab.promotable = promotable;\n+            stab.allow_const_fn_ptr = allow_const_fn_ptr;\n         } else {\n             span_err!(diagnostic, item_sp, E0717,\n-                      \"rustc_promotable attribute must be paired with \\\n-                       either stable or unstable attribute\");\n+                      \"rustc_promotable and rustc_allow_const_fn_ptr attributes \\\n+                      must be paired with either stable or unstable attribute\");\n         }\n     }\n "}, {"sha": "75d687be28003764677bdffbee2e2526b7fb9ee0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1145,9 +1145,34 @@ impl<'a> Parser<'a> {\n                 if text.is_empty() {\n                     self.span_bug(sp, \"found empty literal suffix in Some\")\n                 }\n-                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n-                    .span_label(sp, format!(\"invalid suffix `{}`\", text))\n-                    .emit();\n+                let mut err = if kind == \"a tuple index\" &&\n+                    [\"i32\", \"u32\", \"isize\", \"usize\"].contains(&text.to_string().as_str())\n+                {\n+                    // #59553: warn instead of reject out of hand to allow the fix to percolate\n+                    // through the ecosystem when people fix their macros\n+                    let mut err = self.struct_span_warn(\n+                        sp,\n+                        &format!(\"suffixes on {} are invalid\", kind),\n+                    );\n+                    err.note(&format!(\n+                        \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n+                         incorrectly accepted on stable for a few releases\",\n+                        text,\n+                    ));\n+                    err.help(\n+                        \"on proc macros, you'll want to use `syn::Index::from` or \\\n+                         `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n+                         to tuple field access\",\n+                    );\n+                    err.note(\n+                        \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n+                    );\n+                    err\n+                } else {\n+                    self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+                };\n+                err.span_label(sp, format!(\"invalid suffix `{}`\", text));\n+                err.emit();\n             }\n         }\n     }\n@@ -1455,6 +1480,9 @@ impl<'a> Parser<'a> {\n     fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n+    fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_warn(sp, m)\n+    }\n     crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }"}, {"sha": "39472ae11fbc565ef63835a6b56da59921c200b6", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,5 +1,5 @@\n #![deny(unused_must_use)]\n-#![feature(arbitrary_self_types, futures_api)]\n+#![feature(arbitrary_self_types)]\n \n use std::iter::Iterator;\n use std::future::Future;"}, {"sha": "d4852db6d475e39736104ebc1de375729077b62e", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -22,15 +22,14 @@ impl Drop for S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.before.mir\n //     let mut _0: ();\n+//     let mut _2: std::boxed::Box<S>;\n+//     let mut _3: ();\n+//     let mut _4: std::boxed::Box<S>;\n //     scope 1 {\n+//         let _1: std::boxed::Box<S>;\n //     }\n //     scope 2 {\n-//         let _1: std::boxed::Box<S>;\n //     }\n-//     let mut _2: std::boxed::Box<S>;\n-//     let mut _3: ();\n-//     let mut _4: std::boxed::Box<S>;\n-//\n //     bb0: {\n //         StorageLive(_1);\n //         StorageLive(_2);"}, {"sha": "023440af0eb10d014549346c9008271b594b7dbe", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -29,27 +29,28 @@ impl S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.after.mir\n //    let mut _0: ();\n-//    scope 1 {\n-//    }\n-//    scope 2 {\n-//        let _1: ();\n-//    }\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n //    let mut _5: bool;\n+//    scope 1 {\n+//        let _1: ();\n+//    }\n+//    scope 2 {\n+//    }\n+//    ...\n //    bb0: {\n // END rustc.main.ElaborateDrops.after.mir\n // START rustc.test.ElaborateDrops.after.mir\n //    let mut _0: ();\n-//    ...\n-//    let mut _2: S;\n-//    ...\n-//    let _1: S;\n-//    ...\n //    let mut _3: ();\n //    let mut _4: S;\n //    let mut _5: S;\n //    let mut _6: bool;\n+//    ...\n+//    let _1: S;\n+//    ...\n+//    let mut _2: S;\n+//    ...\n //    bb0: {\n // END rustc.test.ElaborateDrops.after.mir"}, {"sha": "29446d2ecc23e5d9180ee6f47957cbde30d42977", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -17,16 +17,16 @@ fn main() {\n // START rustc.main.mir_map.0.mir\n // fn main() -> (){\n //     let mut _0: ();\n-//     scope 1 {\n-//     }\n-//     scope 2 {\n-//         let _2: i32;\n-//     }\n //     let mut _1: ();\n //     let mut _3: bool;\n //     let mut _4: !;\n //     let mut _5: ();\n //     let mut _6: &i32;\n+//     scope 1 {\n+//         let _2: i32;\n+//     }\n+//     scope 2 {\n+//     }\n //     bb0: {\n //         goto -> bb1;\n //     }"}, {"sha": "bb27461bb1e0fc1570d7b6e2c36fc9871f6f99d4", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -27,10 +27,10 @@ fn main() {\n // | '_#4r    | U0 | {bb2[4..=5], bb3[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n-// let _6: &'_#4r usize;\n-// ...\n // let _2: &'_#3r usize;\n // ...\n+// let _6: &'_#4r usize;\n+// ...\n // _2 = &'_#2r _1[_3];\n // ...\n // _6 = _2;"}, {"sha": "7e8c58e64c28d60d2689682e094f927291c0da75", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -18,16 +18,16 @@ impl Drop for Droppy {\n // START rustc.main.EraseRegions.before.mir\n // fn main() -> () {\n //     let mut _0: ();\n-//     scope 1 {\n-//     }\n-//     scope 2 {\n-//         let mut _1: Packed;\n-//     }\n //     let mut _2: Aligned;\n //     let mut _3: Droppy;\n //     let mut _4: Aligned;\n //     let mut _5: Droppy;\n //     let mut _6: Aligned;\n+//     scope 1 {\n+//         let mut _1: Packed;\n+//     }\n+//     scope 2 {\n+//     }\n //\n //     bb0: {\n //         StorageLive(_1);"}, {"sha": "e1b4328debd9a8918e7bea0c3e4aa16326bc31a9", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // aux-build:arc_wake.rs\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n extern crate arc_wake;\n "}, {"sha": "c21886f26f467e2176460fc166f95d0d9ee3cc6c", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(futures_api)]\n-\n use std::sync::Arc;\n use std::task::{\n     Waker, RawWaker, RawWakerVTable,"}, {"sha": "ee77053fd5b6af5ef957f3a852696d36935c4e3a", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,5 @@\n // aux-build:arc_wake.rs\n \n-#![feature(futures_api)]\n-\n extern crate arc_wake;\n \n use std::future::Future;"}, {"sha": "961c412f5ecb2751bf86551d087beb84becbf77a", "filename": "src/test/run-pass/issue-54716.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -3,7 +3,7 @@\n // run-pass\n \n #![allow(unused_variables)]\n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n extern crate arc_wake;\n "}, {"sha": "12be6582a21e8e5df40d5dd24b7396ebcd3eae03", "filename": "src/test/run-pass/issue-55809.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-55809.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // run-pass\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n trait Foo { }\n "}, {"sha": "7384f7027d185a1714bd29ff226c4bb80465ca6a", "filename": "src/test/rustdoc/async-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-fn.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(async_await, futures_api)]\n+#![feature(async_await)]\n \n // @has async_fn/fn.foo.html '//pre[@class=\"rust fn\"]' 'pub async fn foo() -> Option<Foo>'\n pub async fn foo() -> Option<Foo> {"}, {"sha": "e3ac817b15ca580e5e9484c8436793020c78f3a4", "filename": "src/test/ui/async-fn-multiple-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n \n use std::ops::Add;\n "}, {"sha": "3992607c387e11acb8a958d47aa6924b3146e6cc", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -0,0 +1,10 @@\n+#![feature(rustc_attrs, staged_api)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+const fn error(_: fn()) {} //~ ERROR function pointers in const fn are unstable\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_allow_const_fn_ptr]\n+const fn compiles(_: fn()) {}\n+\n+fn main() {}"}, {"sha": "e6e1ced6592a24498af60f789566d37ab35af7c6", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr.stderr?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -0,0 +1,12 @@\n+error[E0723]: function pointers in const fn are unstable\n+  --> $DIR/allow_const_fn_ptr.rs:4:16\n+   |\n+LL | const fn error(_: fn()) {}\n+   |                ^\n+   |\n+   = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n+   = help: add #![feature(const_fn)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "0395795ef7bfe03e84f18e75f38dd384ae88c24d", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_feature_gate.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -0,0 +1,11 @@\n+#![feature(staged_api)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+const fn error(_: fn()) {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_allow_const_fn_ptr]\n+//~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved\n+const fn compiles(_: fn()) {}\n+\n+fn main() {}"}, {"sha": "c934307e918b931a1a779ac8eb1f42f00ddf4e87", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_feature_gate.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_feature_gate.stderr?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n+  --> $DIR/allow_const_fn_ptr_feature_gate.rs:7:3\n+   |\n+LL | #[rustc_allow_const_fn_ptr]\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1d8b95ab1a2fdeddb1ab8061ea5268e5d966ab65", "filename": "src/test/ui/consts/min_const_fn/allow_const_fn_ptr_run_pass.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_run_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_run_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_const_fn_ptr_run_pass.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![feature(rustc_attrs, staged_api)]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_allow_const_fn_ptr]\n+const fn takes_fn_ptr(_: fn()) {}\n+\n+const FN: fn() = || ();\n+\n+const fn gives_fn_ptr() {\n+    takes_fn_ptr(FN)\n+}\n+\n+fn main() {\n+    gives_fn_ptr();\n+}"}, {"sha": "e1111f9e0e4b952f26e494921bd24334f3ffdf6f", "filename": "src/test/ui/editions/edition-deny-async-fns-2015.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Feditions%2Fedition-deny-async-fns-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Feditions%2Fedition-deny-async-fns-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-deny-async-fns-2015.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,6 @@\n // edition:2015\n \n-#![feature(futures_api, async_await)]\n+#![feature(async_await)]\n \n async fn foo() {} //~ ERROR `async fn` is not permitted in the 2015 edition\n "}, {"sha": "801aeb82aa266dfed97da4d9d23b22532988b8cf", "filename": "src/test/ui/feature-gates/feature-gate-async-await-2015-edition.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,5 @@\n // edition:2015\n \n-#![feature(futures_api)]\n-\n async fn foo() {} //~ ERROR `async fn` is not permitted in the 2015 edition\n                   //~^ ERROR async fn is unstable\n "}, {"sha": "b419f1232dfab6110f33d526f20b68a4e6ec5cb6", "filename": "src/test/ui/feature-gates/feature-gate-async-await-2015-edition.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await-2015-edition.stderr?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,23 +1,23 @@\n error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:5:1\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:3:1\n    |\n LL | async fn foo() {}\n    | ^^^^^\n \n error[E0422]: cannot find struct, variant or union type `async` in this scope\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:9:13\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:7:13\n    |\n LL |     let _ = async {};\n    |             ^^^^^ not found in this scope\n \n error[E0425]: cannot find value `async` in this scope\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:10:13\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:8:13\n    |\n LL |     let _ = async || { true };\n    |             ^^^^^ not found in this scope\n \n error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await-2015-edition.rs:5:1\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:3:1\n    |\n LL | async fn foo() {}\n    | ^^^^^^^^^^^^^^^^^"}, {"sha": "9cfefef4129de27e3e9e957db9099df93f6957fd", "filename": "src/test/ui/feature-gates/feature-gate-async-await.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,5 @@\n // edition:2018\n \n-#![feature(futures_api)]\n-\n struct S;\n \n impl S {"}, {"sha": "43e41b4545869e568c6f86bf5cf1ceb8467693ec", "filename": "src/test/ui/feature-gates/feature-gate-async-await.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-async-await.stderr?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,11 +1,11 @@\n error[E0706]: trait fns cannot be declared `async`\n-  --> $DIR/feature-gate-async-await.rs:12:5\n+  --> $DIR/feature-gate-async-await.rs:10:5\n    |\n LL |     async fn foo();\n    |     ^^^^^^^^^^^^^^^\n \n error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:8:5\n+  --> $DIR/feature-gate-async-await.rs:6:5\n    |\n LL |     async fn foo() {}\n    |     ^^^^^^^^^^^^^^^^^\n@@ -14,7 +14,7 @@ LL |     async fn foo() {}\n    = help: add #![feature(async_await)] to the crate attributes to enable\n \n error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:12:5\n+  --> $DIR/feature-gate-async-await.rs:10:5\n    |\n LL |     async fn foo();\n    |     ^^^^^^^^^^^^^^^\n@@ -23,7 +23,7 @@ LL |     async fn foo();\n    = help: add #![feature(async_await)] to the crate attributes to enable\n \n error[E0658]: async fn is unstable\n-  --> $DIR/feature-gate-async-await.rs:16:1\n+  --> $DIR/feature-gate-async-await.rs:14:1\n    |\n LL | async fn foo() {}\n    | ^^^^^^^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL | async fn foo() {}\n    = help: add #![feature(async_await)] to the crate attributes to enable\n \n error[E0658]: async blocks are unstable\n-  --> $DIR/feature-gate-async-await.rs:19:13\n+  --> $DIR/feature-gate-async-await.rs:17:13\n    |\n LL |     let _ = async {};\n    |             ^^^^^^^^\n@@ -41,7 +41,7 @@ LL |     let _ = async {};\n    = help: add #![feature(async_await)] to the crate attributes to enable\n \n error[E0658]: async closures are unstable\n-  --> $DIR/feature-gate-async-await.rs:20:13\n+  --> $DIR/feature-gate-async-await.rs:18:13\n    |\n LL |     let _ = async || {};\n    |             ^^^^^^^^^^^"}, {"sha": "a4e080119345e8f1791f4e77496f4d468d98bcb3", "filename": "src/test/ui/impl-trait/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-async-impl-trait-type.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -2,7 +2,7 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-#![feature(await_macro, async_await, futures_api, generators)]\n+#![feature(await_macro, async_await, generators)]\n \n async fn recursive_async_function() -> () { //~ ERROR\n     await!(recursive_async_function());"}, {"sha": "2428b560b7001184fac39f554ad2c28188b8b68e", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden.\n \n-#![feature(futures_api, generators)]\n+#![feature(generators)]\n \n fn option(i: i32) -> impl Sized { //~ ERROR\n     if i < 0 {"}, {"sha": "d6f18875c9e3abc6a42adc5f3342938193fab0b6", "filename": "src/test/ui/issues/issue-54974.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // compile-pass\n // edition:2018\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n use std::sync::Arc;\n "}, {"sha": "4572e543f22de015b7c14b6bea6017aa17c54c33", "filename": "src/test/ui/issues/issue-55324.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // compile-pass\n // edition:2018\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n use std::future::Future;\n "}, {"sha": "99d87b2273c2f2bfd20cb80c1f4cb5da1c84873d", "filename": "src/test/ui/issues/issue-58885.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // compile-pass\n // edition:2018\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n struct Xyz {\n     a: u64,"}, {"sha": "c758244002ff6e14930e187b11eab12f68a31096", "filename": "src/test/ui/issues/issue-59001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,7 @@\n // compile-pass\n // edition:2018\n \n-#![feature(async_await, await_macro, futures_api)]\n+#![feature(async_await, await_macro)]\n \n use std::future::Future;\n "}, {"sha": "345f19b06233bfcfb8b23f1643375d9475f5035b", "filename": "src/test/ui/no-args-non-move-async-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+#![feature(async_await, await_macro)]\n \n fn main() {\n     let _ = async |x: u8| {};"}, {"sha": "f63950ad5e9058981224fd1ca8e6f6ebd90cbf01", "filename": "src/test/ui/try-poll.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ftry-poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a44125f557706774b6e99912a585fa6a399c183/src%2Ftest%2Fui%2Ftry-poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-poll.rs?ref=8a44125f557706774b6e99912a585fa6a399c183", "patch": "@@ -1,7 +1,6 @@\n // compile-pass\n \n #![allow(dead_code, unused)]\n-#![feature(futures_api)]\n \n use std::task::Poll;\n "}]}