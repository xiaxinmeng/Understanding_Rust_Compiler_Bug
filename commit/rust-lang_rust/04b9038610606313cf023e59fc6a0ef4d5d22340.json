{"sha": "04b9038610606313cf023e59fc6a0ef4d5d22340", "node_id": "C_kwDOAAsO6NoAKDA0YjkwMzg2MTA2MDYzMTNjZjAyM2U1OWZjNmEwZWY0ZDVkMjIzNDA", "commit": {"author": {"name": "Ezra Shaw", "email": "ezrasure@outlook.com", "date": "2022-12-29T06:08:59Z"}, "committer": {"name": "Ezra Shaw", "email": "ezrasure@outlook.com", "date": "2023-01-01T02:22:01Z"}, "message": "refactor: clean up `errors.rs` and `error_codes_check.rs`\n\nMove them into new `error_codes.rs` tidy check.", "tree": {"sha": "253c1090aa26988e09c247e26f385883bac90045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/253c1090aa26988e09c247e26f385883bac90045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b9038610606313cf023e59fc6a0ef4d5d22340", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJJBAABCAAzFiEEYSWD6p+RIeSP1N2eF81cKtrg00QFAmOw7kkVHGV6cmFzdXJl\nQG91dGxvb2suY29tAAoJEBfNXCra4NNEeGMP/1W8v0hDcZOdDHerrnxh61YyFKlw\nvJLf8Z5fsezX8n4HF1iW5KQ/yLJkHnPomp8W2pkwR9vShwUhxM17ybwiqP2Q0hTS\nYpqlc/S95aC3ZGrBox/H3o5FAwkrbYiYMcIRblbedoPWSDaEUShjgBavq2FG5Utm\nL5oYHZ4QLOSwj/NG/IyAbiOJze2v/gdwJjJbuq3ceAAZCBklq/XLWuUGsYyl7h91\nnsyWNUwY5YikZnajWWZhokoX5tvHQT/8EQblcTl1Iod+YNIDl4s323uxy/5sXjmT\n7HeQzcRdD44PFTZ0qui+xTapWPuighMY8E+U5FfZ3IHKsrjHFIS+FsqrJmnkuOKy\neA36Iu1uW3OarSFK9kJrT1I+TjiRM34NLBT7qU2WdSPWh/L7gB11tsCYgBWdDBG/\nUQRWKXabt55aEIrirIoqydIj4NTPeLFyCrfriMd4KcdtcC1ry2Q2JVxGGM2TklHj\nxNp51Nav7ew9s8LFMWkDwHmHqV1CV3jChMgX3M/USbW/NwHtfIy9aBq4uFzW5CD2\nB12KsZjZD9UsQalgydd9yjmQ8zP1nrkiygW/goooEnHKCYGwQvCb5+cN+keiuVbG\noB4i0IlQTa5dZkQ3nVJs75JoRpN20euXGYsa0LUDg+lXy5Kn84ANprLIKEG+Iagz\n4RTI7TYcXdnNpoxT\n=7iub\n-----END PGP SIGNATURE-----", "payload": "tree 253c1090aa26988e09c247e26f385883bac90045\nparent c9825f7087adcd9a132d896853b562087e0421a9\nauthor Ezra Shaw <ezrasure@outlook.com> 1672294139 +1300\ncommitter Ezra Shaw <ezrasure@outlook.com> 1672539721 +1300\n\nrefactor: clean up `errors.rs` and `error_codes_check.rs`\n\nMove them into new `error_codes.rs` tidy check.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b9038610606313cf023e59fc6a0ef4d5d22340", "html_url": "https://github.com/rust-lang/rust/commit/04b9038610606313cf023e59fc6a0ef4d5d22340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b9038610606313cf023e59fc6a0ef4d5d22340/comments", "author": {"login": "Ezrashaw", "id": 38062690, "node_id": "MDQ6VXNlcjM4MDYyNjkw", "avatar_url": "https://avatars.githubusercontent.com/u/38062690?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ezrashaw", "html_url": "https://github.com/Ezrashaw", "followers_url": "https://api.github.com/users/Ezrashaw/followers", "following_url": "https://api.github.com/users/Ezrashaw/following{/other_user}", "gists_url": "https://api.github.com/users/Ezrashaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ezrashaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ezrashaw/subscriptions", "organizations_url": "https://api.github.com/users/Ezrashaw/orgs", "repos_url": "https://api.github.com/users/Ezrashaw/repos", "events_url": "https://api.github.com/users/Ezrashaw/events{/privacy}", "received_events_url": "https://api.github.com/users/Ezrashaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ezrashaw", "id": 38062690, "node_id": "MDQ6VXNlcjM4MDYyNjkw", "avatar_url": "https://avatars.githubusercontent.com/u/38062690?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ezrashaw", "html_url": "https://github.com/Ezrashaw", "followers_url": "https://api.github.com/users/Ezrashaw/followers", "following_url": "https://api.github.com/users/Ezrashaw/following{/other_user}", "gists_url": "https://api.github.com/users/Ezrashaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ezrashaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ezrashaw/subscriptions", "organizations_url": "https://api.github.com/users/Ezrashaw/orgs", "repos_url": "https://api.github.com/users/Ezrashaw/repos", "events_url": "https://api.github.com/users/Ezrashaw/events{/privacy}", "received_events_url": "https://api.github.com/users/Ezrashaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9825f7087adcd9a132d896853b562087e0421a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9825f7087adcd9a132d896853b562087e0421a9", "html_url": "https://github.com/rust-lang/rust/commit/c9825f7087adcd9a132d896853b562087e0421a9"}], "stats": {"total": 817, "additions": 400, "deletions": 417}, "files": [{"sha": "137325e6fabfdec57e037045383dfba57c98ae31", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04b9038610606313cf023e59fc6a0ef4d5d22340/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b9038610606313cf023e59fc6a0ef4d5d22340/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=04b9038610606313cf023e59fc6a0ef4d5d22340", "patch": "@@ -443,7 +443,6 @@ E0725: include_str!(\"./error_codes/E0725.md\"),\n E0726: include_str!(\"./error_codes/E0726.md\"),\n E0727: include_str!(\"./error_codes/E0727.md\"),\n E0728: include_str!(\"./error_codes/E0728.md\"),\n-E0729: include_str!(\"./error_codes/E0729.md\"),\n E0730: include_str!(\"./error_codes/E0730.md\"),\n E0731: include_str!(\"./error_codes/E0731.md\"),\n E0732: include_str!(\"./error_codes/E0732.md\"),"}, {"sha": "74f89080b91a16686b378a10e79c70e15439ec96", "filename": "compiler/rustc_error_codes/src/error_codes/E0729.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9825f7087adcd9a132d896853b562087e0421a9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9825f7087adcd9a132d896853b562087e0421a9/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md?ref=c9825f7087adcd9a132d896853b562087e0421a9", "patch": "@@ -1,30 +0,0 @@\n-Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n-since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n-checker for NLL uncovered some bugs in the old borrow checker, which in some\n-cases allowed unsound code to compile, resulting in memory safety issues.\n-\n-### What do I do?\n-\n-Change your code so the warning does no longer trigger. For backwards\n-compatibility, this unsound code may still compile (with a warning) right now.\n-However, at some point in the future, the compiler will no longer accept this\n-code and will throw a hard error.\n-\n-### Shouldn't you fix the old borrow checker?\n-\n-The old borrow checker has known soundness issues that are basically impossible\n-to fix. The new NLL-based borrow checker is the fix.\n-\n-### Can I turn these warnings into errors by denying a lint?\n-\n-No.\n-\n-### When are these warnings going to turn into errors?\n-\n-No formal timeline for turning the warnings into errors has been set. See\n-[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\n-information.\n-\n-### Why do I get this message with code that doesn't involve borrowing?\n-\n-There are some known bugs that trigger this message."}, {"sha": "f4aebbf227759e586a3ac7ae8c5f65d2d998fbf9", "filename": "src/tools/tidy/src/error_codes.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=04b9038610606313cf023e59fc6a0ef4d5d22340", "patch": "@@ -0,0 +1,397 @@\n+//! Tidy check to ensure error codes are properly documented and tested.\n+//!\n+//! Overview of check:\n+//!\n+//! 1. We create a list of error codes used by the compiler. Error codes are extracted from `compiler/rustc_error_codes/src/error_codes.rs`.\n+//!\n+//! 2. We check that the error code has a long-form explanation in `compiler/rustc_error_codes/src/error_codes/`.\n+//!   - The explanation is expected to contain a `doctest` that fails with the correct error code. (`EXEMPT_FROM_DOCTEST` *currently* bypasses this check)\n+//!   - Note that other stylistic conventions for markdown files are checked in the `style.rs` tidy check.\n+//!\n+//! 3. We check that the error code has a UI test in `src/test/ui/error-codes/`.\n+//!   - We ensure that there is both a `Exxxx.rs` file and a corresponding `Exxxx.stderr` file.\n+//!   - We also ensure that the error code is used in the tests.\n+//!   - *Currently*, it is possible to opt-out of this check with the `EXEMPTED_FROM_TEST` constant.\n+//!\n+//! 4. We check that the error code is actually emitted by the compiler.\n+//!   - This is done by searching `compiler/` with a regex.\n+//!\n+//! This tidy check was merged and refactored from two others. See #PR_NUM for information about linting changes that occurred during this refactor.\n+\n+use std::{ffi::OsStr, fs, path::Path};\n+\n+use regex::Regex;\n+\n+use crate::walk::{filter_dirs, walk, walk_many};\n+\n+const ERROR_CODES_PATH: &str = \"compiler/rustc_error_codes/src/error_codes.rs\";\n+const ERROR_DOCS_PATH: &str = \"compiler/rustc_error_codes/src/error_codes/\";\n+const ERROR_TESTS_PATH: &str = \"src/test/ui/error-codes/\";\n+\n+// Error codes that (for some reason) can't have a doctest in their explanation. Error codes are still expected to provide a code example, even if untested.\n+const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n+\n+// Error codes that don't yet have a UI test. This list will eventually be removed.\n+const IGNORE_UI_TEST_CHECK: &[&str] = &[\n+    \"E0313\", \"E0461\", \"E0465\", \"E0476\", \"E0490\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\",\n+    \"E0729\", \"E0789\",\n+];\n+\n+pub fn check(root_path: &Path, search_paths: &[&Path], bad: &mut bool) {\n+    let mut errors = Vec::new();\n+\n+    // Stage 1: create list\n+    let error_codes = extract_error_codes(root_path, &mut errors);\n+    println!(\"Found {} error codes\", error_codes.len());\n+\n+    // Stage 2: check list has docs\n+    let no_longer_emitted = check_error_codes_docs(root_path, &error_codes, &mut errors);\n+\n+    // Stage 3: check list has UI tests\n+    check_error_codes_tests(root_path, &error_codes, &mut errors);\n+\n+    // Stage 4: check list is emitted by compiler\n+    check_error_codes_used(search_paths, &error_codes, &mut errors, &no_longer_emitted);\n+\n+    // Print any errors.\n+    for error in errors {\n+        tidy_error!(bad, \"{}\", error);\n+    }\n+}\n+\n+/// Stage 1: Parses a list of error codes from `error_codes.rs`.\n+fn extract_error_codes(root_path: &Path, errors: &mut Vec<String>) -> Vec<String> {\n+    let file = fs::read_to_string(root_path.join(Path::new(ERROR_CODES_PATH)))\n+        .unwrap_or_else(|e| panic!(\"failed to read `error_codes.rs`: {e}\"));\n+\n+    let mut error_codes = Vec::new();\n+    let mut reached_undocumented_codes = false;\n+\n+    let mut undocumented_count = 0;\n+\n+    for line in file.lines() {\n+        let line = line.trim();\n+\n+        if !reached_undocumented_codes && line.starts_with('E') {\n+            let split_line = line.split_once(':');\n+\n+            // Extract the error code from the line, emitting a fatal error if it is not in a correct format.\n+            let err_code = if let Some(err_code) = split_line {\n+                err_code.0.to_owned()\n+            } else {\n+                errors.push(format!(\n+                    \"Expected a line with the format `Exxxx: include_str!(\\\"..\\\")`, but got \\\"{}\\\" \\\n+                    without a `:` delimiter\",\n+                    line,\n+                ));\n+                continue;\n+            };\n+\n+            // If this is a duplicate of another error code, emit a fatal error.\n+            if error_codes.contains(&err_code) {\n+                errors.push(format!(\"Found duplicate error code: `{}`\", err_code));\n+                continue;\n+            }\n+\n+            // Ensure that the line references the correct markdown file.\n+            let expected_filename = format!(\" include_str!(\\\"./error_codes/{}.md\\\"),\", err_code);\n+            if expected_filename != split_line.unwrap().1 {\n+                errors.push(format!(\n+                    \"Error code `{}` expected to reference docs with `{}` but instead found `{}`\",\n+                    err_code,\n+                    expected_filename,\n+                    split_line.unwrap().1,\n+                ));\n+                continue;\n+            }\n+\n+            error_codes.push(err_code);\n+        } else if reached_undocumented_codes && line.starts_with('E') {\n+            let err_code = match line.split_once(',') {\n+                None => line,\n+                Some((err_code, _)) => err_code,\n+            }\n+            .to_string();\n+\n+            undocumented_count += 1;\n+\n+            if error_codes.contains(&err_code) {\n+                errors.push(format!(\"Found duplicate error code: `{}`\", err_code));\n+            }\n+\n+            error_codes.push(err_code);\n+        } else if line == \";\" {\n+            // Once we reach the undocumented error codes, adapt to different syntax.\n+            reached_undocumented_codes = true;\n+        }\n+    }\n+\n+    println!(\n+        \"WARNING: {} error codes are undocumented. This *will* become a hard error.\",\n+        undocumented_count\n+    );\n+\n+    error_codes\n+}\n+\n+/// Stage 2: Checks that long-form error code explanations exist and have doctests.\n+fn check_error_codes_docs(\n+    root_path: &Path,\n+    error_codes: &[String],\n+    errors: &mut Vec<String>,\n+) -> Vec<String> {\n+    let docs_path = root_path.join(Path::new(ERROR_DOCS_PATH));\n+\n+    let mut emit_ignore_warning = 0;\n+    let mut emit_no_longer_warning = 0;\n+    let mut emit_no_code_warning = 0;\n+\n+    let mut no_longer_emitted_codes = Vec::new();\n+\n+    walk(&docs_path, &mut |_| false, &mut |entry, contents| {\n+        let path = entry.path();\n+\n+        // Error if the file isn't markdown.\n+        if path.extension() != Some(OsStr::new(\"md\")) {\n+            errors.push(format!(\n+                \"Found unexpected non-markdown file in error code docs directory: {}\",\n+                path.display()\n+            ));\n+            return;\n+        }\n+\n+        // Make sure that the file is referenced in `error_codes.rs`\n+        let filename = path.file_name().unwrap().to_str().unwrap().split_once('.');\n+        let err_code = filename.unwrap().0; // `unwrap` is ok because we know the filename is in the correct format.\n+\n+        if error_codes.iter().all(|e| e != err_code) {\n+            errors.push(format!(\n+                \"Found valid file `{}` in error code docs directory without corresponding \\\n+                entry in `error_code.rs`\",\n+                path.display()\n+            ));\n+            return;\n+        }\n+\n+        // `has_test.0` checks whether the error code has any (potentially untested) code example.\n+        // `has_test.1` checks whether the error code has a proper (definitely tested) doctest.\n+        let has_test = check_explanation_has_doctest(&contents, &err_code);\n+        if has_test.2 {\n+            emit_ignore_warning += 1;\n+        }\n+        if has_test.3 {\n+            no_longer_emitted_codes.push(err_code.to_owned());\n+            emit_no_longer_warning += 1;\n+        }\n+        if !has_test.0 {\n+            emit_no_code_warning += 1;\n+        }\n+\n+        let test_ignored = IGNORE_DOCTEST_CHECK.contains(&err_code);\n+\n+        // Check that the explanation has a doctest, and if it shouldn't, that it doesn't\n+        if !has_test.1 && !test_ignored {\n+            errors.push(format!(\n+                \"`{}` doesn't use its own error code in compile_fail example\",\n+                path.display(),\n+            ));\n+        } else if has_test.1 && test_ignored {\n+            errors.push(format!(\n+                \"`{}` has a compile_fail doctest with its own error code, it shouldn't \\\n+                be listed in `IGNORE_DOCTEST_CHECK`\",\n+                path.display(),\n+            ));\n+        }\n+    });\n+\n+    if emit_ignore_warning > 0 {\n+        println!(\n+            \"WARNING: {emit_ignore_warning} error codes use the ignore header. This should not be used, add the error codes to the \\\n+            `IGNORE_DOCTEST_CHECK` constant instead. This *will* become a hard error.\"\n+        );\n+    }\n+    if emit_no_code_warning > 0 {\n+        println!(\n+            \"WARNING: {emit_ignore_warning} error codes don't have a code example, all error codes are expected \\\n+            to have one (even if untested). This *will* become a hard error.\"\n+        );\n+    }\n+    if emit_no_longer_warning > 0 {\n+        println!(\n+            \"WARNING: {emit_no_longer_warning} error codes are no longer emitted and should be removed entirely. \\\n+            This *will* become a hard error.\"\n+        );\n+    }\n+\n+    no_longer_emitted_codes\n+}\n+\n+/// This function returns a tuple indicating whether the provided explanation:\n+/// a) has a code example, tested or not.\n+/// b) has a valid doctest\n+fn check_explanation_has_doctest(explanation: &str, err_code: &str) -> (bool, bool, bool, bool) {\n+    let mut found_code_example = false;\n+    let mut found_proper_doctest = false;\n+\n+    let mut emit_ignore_warning = false;\n+    let mut emit_no_longer_warning = false;\n+\n+    for line in explanation.lines() {\n+        let line = line.trim();\n+\n+        if line.starts_with(\"```\") {\n+            found_code_example = true;\n+\n+            // Check for the `rustdoc` doctest headers.\n+            if line.contains(\"compile_fail\") && line.contains(err_code) {\n+                found_proper_doctest = true;\n+            }\n+\n+            if line.contains(\"ignore\") {\n+                emit_ignore_warning = true;\n+                found_proper_doctest = true;\n+            }\n+        } else if line\n+            .starts_with(\"#### Note: this error code is no longer emitted by the compiler\")\n+        {\n+            emit_no_longer_warning = true;\n+            found_code_example = true;\n+            found_proper_doctest = true;\n+        }\n+    }\n+\n+    (found_code_example, found_proper_doctest, emit_ignore_warning, emit_no_longer_warning)\n+}\n+\n+// Stage 3: Checks that each error code has a UI test in the correct directory\n+fn check_error_codes_tests(root_path: &Path, error_codes: &[String], errors: &mut Vec<String>) {\n+    let tests_path = root_path.join(Path::new(ERROR_TESTS_PATH));\n+\n+    // Some warning counters, this whole thing is clunky but'll be removed eventually.\n+    let mut no_ui_test = 0;\n+    let mut no_error_code_in_test = 0;\n+\n+    for code in error_codes {\n+        let test_path = tests_path.join(format!(\"{}.stderr\", code));\n+\n+        if !test_path.exists() && !IGNORE_UI_TEST_CHECK.contains(&code.as_str()) {\n+            no_ui_test += 1;\n+            continue;\n+        }\n+        if IGNORE_UI_TEST_CHECK.contains(&code.as_str()) {\n+            if test_path.exists() {\n+                errors.push(format!(\n+                    \"Error code `{code}` has a UI test, it shouldn't be listed in `EXEMPTED_FROM_TEST`!\"\n+                ));\n+            }\n+            continue;\n+        }\n+\n+        let file = match fs::read_to_string(test_path) {\n+            Ok(file) => file,\n+            Err(err) => {\n+                println!(\n+                    \"WARNING: Failed to read UI test file for `{code}` but the file exists. The test is assumed to work:\\n{err}\"\n+                );\n+                continue;\n+            }\n+        };\n+\n+        let mut found_code = false;\n+\n+        for line in file.lines() {\n+            let s = line.trim();\n+            // Assuming the line starts with `error[E`, we can substring the error code out.\n+            if s.starts_with(\"error[E\") {\n+                if &s[6..11] == code {\n+                    found_code = true;\n+                    break;\n+                }\n+            };\n+        }\n+\n+        if !found_code {\n+            no_error_code_in_test += 1;\n+        }\n+    }\n+\n+    if no_error_code_in_test > 0 {\n+        println!(\n+            \"WARNING: {no_error_code_in_test} error codes have a UI test file, but don't contain their own error code!\"\n+        );\n+    }\n+\n+    if no_ui_test > 0 {\n+        println!(\n+            \"WARNING: {no_ui_test} error codes need to have at least one UI test in the `src/test/ui/error-codes/` directory`! \\\n+            This *will* become a hard error.\"\n+        );\n+    }\n+}\n+\n+/// Stage 4: Search `compiler/` and ensure that every error code is actually used by the compiler and that no undocumented error codes exist.\n+fn check_error_codes_used(\n+    search_paths: &[&Path],\n+    error_codes: &[String],\n+    errors: &mut Vec<String>,\n+    no_longer_emitted: &[String],\n+) {\n+    // We want error codes which match the following cases:\n+    //\n+    // * foo(a, E0111, a)\n+    // * foo(a, E0111)\n+    // * foo(E0111, a)\n+    // * #[error = \"E0111\"]\n+    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n+\n+    let mut found_codes = Vec::new();\n+\n+    walk_many(search_paths, &mut filter_dirs, &mut |entry, contents| {\n+        let path = entry.path();\n+\n+        // Return early if we aren't looking at a source file.\n+        if path.extension() != Some(OsStr::new(\"rs\")) {\n+            return;\n+        }\n+\n+        for line in contents.lines() {\n+            // We want to avoid parsing error codes in comments.\n+            if line.trim_start().starts_with(\"//\") {\n+                continue;\n+            }\n+\n+            for cap in regex.captures_iter(line) {\n+                if let Some(error_code) = cap.get(1) {\n+                    let error_code = error_code.as_str().to_owned();\n+\n+                    if !error_codes.contains(&error_code) {\n+                        // This error code isn't properly defined, we must error.\n+                        errors.push(format!(\"Error code `{}` is used in the compiler but not defined and documented in `compiler/rustc_error_codes/src/error_codes.rs`.\", error_code));\n+                        continue;\n+                    }\n+\n+                    // This error code can now be marked as used.\n+                    found_codes.push(error_code);\n+                }\n+            }\n+        }\n+    });\n+\n+    let mut used_when_shouldnt = 0;\n+\n+    for code in error_codes {\n+        if !found_codes.contains(code) && !no_longer_emitted.contains(code) {\n+            errors.push(format!(\"Error code `{code}` exists, but is not emitted by the compiler!\"))\n+        }\n+\n+        if found_codes.contains(code) && no_longer_emitted.contains(code) {\n+            used_when_shouldnt += 1;\n+        }\n+    }\n+\n+    if used_when_shouldnt > 0 {\n+        println!(\n+            \"WARNING: {used_when_shouldnt} error codes are used when they are marked as \\\"no longer emitted\\\"\"\n+        );\n+    }\n+}"}, {"sha": "3f060e437aca7ac72a0c3404da445637c81afad6", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/c9825f7087adcd9a132d896853b562087e0421a9/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9825f7087adcd9a132d896853b562087e0421a9/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=c9825f7087adcd9a132d896853b562087e0421a9", "patch": "@@ -1,305 +0,0 @@\n-//! Checks that all error codes have at least one test to prevent having error\n-//! codes that are silently not thrown by the compiler anymore.\n-\n-use crate::walk::{filter_dirs, walk};\n-use std::collections::{HashMap, HashSet};\n-use std::ffi::OsStr;\n-use std::fs::read_to_string;\n-use std::path::Path;\n-\n-use regex::Regex;\n-\n-// A few of those error codes can't be tested but all the others can and *should* be tested!\n-const EXEMPTED_FROM_TEST: &[&str] = &[\n-    \"E0313\", \"E0461\", \"E0476\", \"E0490\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n-    \"E0789\",\n-];\n-\n-// Some error codes don't have any tests apparently...\n-const IGNORE_EXPLANATION_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n-\n-// If the file path contains any of these, we don't want to try to extract error codes from it.\n-//\n-// We need to declare each path in the windows version (with backslash).\n-const PATHS_TO_IGNORE_FOR_EXTRACTION: &[&str] =\n-    &[\"src/test/\", \"src\\\\test\\\\\", \"src/doc/\", \"src\\\\doc\\\\\", \"src/tools/\", \"src\\\\tools\\\\\"];\n-\n-#[derive(Default, Debug)]\n-struct ErrorCodeStatus {\n-    has_test: bool,\n-    has_explanation: bool,\n-    is_used: bool,\n-}\n-\n-fn check_error_code_explanation(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    err_code: String,\n-) -> bool {\n-    let mut invalid_compile_fail_format = false;\n-    let mut found_error_code = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"```\") {\n-            if s.contains(\"compile_fail\") && s.contains('E') {\n-                if !found_error_code {\n-                    error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n-                    found_error_code = true;\n-                }\n-            } else if s.contains(\"compile-fail\") {\n-                invalid_compile_fail_format = true;\n-            }\n-        } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            if !found_error_code {\n-                error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n-                found_error_code = true;\n-            }\n-        }\n-    }\n-    invalid_compile_fail_format\n-}\n-\n-fn check_if_error_code_is_test_in_explanation(f: &str, err_code: &str) -> bool {\n-    let mut ignore_found = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            return true;\n-        }\n-        if s.starts_with(\"```\") {\n-            if s.contains(\"compile_fail\") && s.contains(err_code) {\n-                return true;\n-            } else if s.contains(\"ignore\") {\n-                // It's very likely that we can't actually make it fail compilation...\n-                ignore_found = true;\n-            }\n-        }\n-    }\n-    ignore_found\n-}\n-\n-fn extract_error_codes(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    path: &Path,\n-    errors: &mut Vec<String>,\n-) {\n-    let mut reached_no_explanation = false;\n-\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if !reached_no_explanation && s.starts_with('E') && s.contains(\"include_str!(\\\"\") {\n-            let err_code = s\n-                .split_once(':')\n-                .expect(\n-                    format!(\n-                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} \\\n-                         without a `:` delimiter\",\n-                        s,\n-                    )\n-                    .as_str(),\n-                )\n-                .0\n-                .to_owned();\n-            error_codes.entry(err_code.clone()).or_default().has_explanation = true;\n-\n-            // Now we extract the tests from the markdown file!\n-            let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n-                None => continue,\n-                Some((_, md)) => match md.split_once(\"\\\")\") {\n-                    None => continue,\n-                    Some((file_name, _)) => file_name,\n-                },\n-            };\n-\n-            let Some(parent) = path.parent() else {\n-                continue;\n-            };\n-\n-            let path = parent\n-                .join(md_file_name)\n-                .canonicalize()\n-                .expect(\"failed to canonicalize error explanation file path\");\n-\n-            match read_to_string(&path) {\n-                Ok(content) => {\n-                    let has_test = check_if_error_code_is_test_in_explanation(&content, &err_code);\n-                    if !has_test && !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str()) {\n-                        errors.push(format!(\n-                            \"`{}` doesn't use its own error code in compile_fail example\",\n-                            path.display(),\n-                        ));\n-                    } else if has_test && IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str()) {\n-                        errors.push(format!(\n-                            \"`{}` has a compile_fail example with its own error code, it shouldn't \\\n-                             be listed in IGNORE_EXPLANATION_CHECK!\",\n-                            path.display(),\n-                        ));\n-                    }\n-                    if check_error_code_explanation(&content, error_codes, err_code) {\n-                        errors.push(format!(\n-                            \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n-                            path.display(),\n-                        ));\n-                    }\n-                }\n-                Err(e) => {\n-                    eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n-                }\n-            }\n-        } else if reached_no_explanation && s.starts_with('E') {\n-            let err_code = match s.split_once(',') {\n-                None => s,\n-                Some((err_code, _)) => err_code,\n-            }\n-            .to_string();\n-            if !error_codes.contains_key(&err_code) {\n-                // this check should *never* fail!\n-                error_codes.insert(err_code, ErrorCodeStatus::default());\n-            }\n-        } else if s == \";\" {\n-            reached_no_explanation = true;\n-        }\n-    }\n-}\n-\n-fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, ErrorCodeStatus>) {\n-    for line in f.lines() {\n-        let s = line.trim();\n-        if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n-            let err_code = match s.split_once(']') {\n-                None => continue,\n-                Some((err_code, _)) => match err_code.split_once('[') {\n-                    None => continue,\n-                    Some((_, err_code)) => err_code,\n-                },\n-            };\n-            error_codes.entry(err_code.to_owned()).or_default().has_test = true;\n-        }\n-    }\n-}\n-\n-fn extract_error_codes_from_source(\n-    f: &str,\n-    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n-    regex: &Regex,\n-) {\n-    for line in f.lines() {\n-        if line.trim_start().starts_with(\"//\") {\n-            continue;\n-        }\n-        for cap in regex.captures_iter(line) {\n-            if let Some(error_code) = cap.get(1) {\n-                error_codes.entry(error_code.as_str().to_owned()).or_default().is_used = true;\n-            }\n-        }\n-    }\n-}\n-\n-pub fn check(paths: &[&Path], bad: &mut bool) {\n-    let mut errors = Vec::new();\n-    let mut found_explanations = 0;\n-    let mut found_tests = 0;\n-    let mut error_codes: HashMap<String, ErrorCodeStatus> = HashMap::new();\n-    let mut explanations: HashSet<String> = HashSet::new();\n-    // We want error codes which match the following cases:\n-    //\n-    // * foo(a, E0111, a)\n-    // * foo(a, E0111)\n-    // * foo(E0111, a)\n-    // * #[error = \"E0111\"]\n-    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n-\n-    for path in paths {\n-        walk(path, &mut filter_dirs, &mut |entry, contents| {\n-            let file_name = entry.file_name();\n-            let entry_path = entry.path();\n-\n-            if file_name == \"error_codes.rs\" {\n-                extract_error_codes(contents, &mut error_codes, entry.path(), &mut errors);\n-                found_explanations += 1;\n-            } else if entry_path.extension() == Some(OsStr::new(\"stderr\")) {\n-                extract_error_codes_from_tests(contents, &mut error_codes);\n-                found_tests += 1;\n-            } else if entry_path.extension() == Some(OsStr::new(\"rs\")) {\n-                let path = entry.path().to_string_lossy();\n-                if PATHS_TO_IGNORE_FOR_EXTRACTION.iter().all(|c| !path.contains(c)) {\n-                    extract_error_codes_from_source(contents, &mut error_codes, &regex);\n-                }\n-            } else if entry_path\n-                .parent()\n-                .and_then(|p| p.file_name())\n-                .map(|p| p == \"error_codes\")\n-                .unwrap_or(false)\n-                && entry_path.extension() == Some(OsStr::new(\"md\"))\n-            {\n-                explanations.insert(file_name.to_str().unwrap().replace(\".md\", \"\"));\n-            }\n-        });\n-    }\n-    if found_explanations == 0 {\n-        tidy_error!(bad, \"No error code explanation was tested!\");\n-    }\n-    if found_tests == 0 {\n-        tidy_error!(bad, \"No error code was found in compilation errors!\");\n-    }\n-    if explanations.is_empty() {\n-        tidy_error!(bad, \"No error code explanation was found!\");\n-    }\n-    if errors.is_empty() {\n-        for (err_code, error_status) in &error_codes {\n-            if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n-                errors.push(format!(\"Error code {err_code} needs to have at least one UI test!\"));\n-            } else if error_status.has_test && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n-                errors.push(format!(\n-                    \"Error code {} has a UI test, it shouldn't be listed into EXEMPTED_FROM_TEST!\",\n-                    err_code\n-                ));\n-            }\n-            if !error_status.is_used && !error_status.has_explanation {\n-                errors.push(format!(\n-                    \"Error code {} isn't used and doesn't have an error explanation, it should be \\\n-                     commented in error_codes.rs file\",\n-                    err_code\n-                ));\n-            }\n-        }\n-    }\n-    if errors.is_empty() {\n-        // Checking if local constants need to be cleaned.\n-        for err_code in EXEMPTED_FROM_TEST {\n-            match error_codes.get(err_code.to_owned()) {\n-                Some(status) => {\n-                    if status.has_test {\n-                        errors.push(format!(\n-                            \"{} error code has a test and therefore should be \\\n-                            removed from the `EXEMPTED_FROM_TEST` constant\",\n-                            err_code\n-                        ));\n-                    }\n-                }\n-                None => errors.push(format!(\n-                    \"{} error code isn't used anymore and therefore should be removed \\\n-                        from `EXEMPTED_FROM_TEST` constant\",\n-                    err_code\n-                )),\n-            }\n-        }\n-    }\n-    if errors.is_empty() {\n-        for explanation in explanations {\n-            if !error_codes.contains_key(&explanation) {\n-                errors.push(format!(\n-                    \"{} error code explanation should be listed in `error_codes.rs`\",\n-                    explanation\n-                ));\n-            }\n-        }\n-    }\n-    errors.sort();\n-    for err in &errors {\n-        tidy_error!(bad, \"{err}\");\n-    }\n-}"}, {"sha": "fe5fd72b91a49946337ed8bdda075d9b41733dae", "filename": "src/tools/tidy/src/errors.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c9825f7087adcd9a132d896853b562087e0421a9/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9825f7087adcd9a132d896853b562087e0421a9/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=c9825f7087adcd9a132d896853b562087e0421a9", "patch": "@@ -1,77 +0,0 @@\n-//! Tidy check to verify the validity of long error diagnostic codes.\n-//!\n-//! This ensures that error codes are used at most once and also prints out some\n-//! statistics about the error codes.\n-\n-use crate::walk::{filter_dirs, walk};\n-use std::collections::HashMap;\n-use std::path::Path;\n-\n-pub fn check(path: &Path, bad: &mut bool) {\n-    let mut map: HashMap<_, Vec<_>> = HashMap::new();\n-    walk(\n-        path,\n-        &mut |path| filter_dirs(path) || path.ends_with(\"src/test\"),\n-        &mut |entry, contents| {\n-            let file = entry.path();\n-            let filename = file.file_name().unwrap().to_string_lossy();\n-            if filename != \"error_codes.rs\" {\n-                return;\n-            }\n-\n-            // In the `register_long_diagnostics!` macro, entries look like this:\n-            //\n-            // ```\n-            // EXXXX: r##\"\n-            // <Long diagnostic message>\n-            // \"##,\n-            // ```\n-            //\n-            // and these long messages often have error codes themselves inside\n-            // them, but we don't want to report duplicates in these cases. This\n-            // variable keeps track of whether we're currently inside one of these\n-            // long diagnostic messages.\n-            let mut inside_long_diag = false;\n-            for (num, line) in contents.lines().enumerate() {\n-                if inside_long_diag {\n-                    inside_long_diag = !line.contains(\"\\\"##\");\n-                    continue;\n-                }\n-\n-                let mut search = line;\n-                while let Some(i) = search.find('E') {\n-                    search = &search[i + 1..];\n-                    let code = if search.len() > 4 { search[..4].parse::<u32>() } else { continue };\n-                    let code = match code {\n-                        Ok(n) => n,\n-                        Err(..) => continue,\n-                    };\n-                    map.entry(code).or_default().push((file.to_owned(), num + 1, line.to_owned()));\n-                    break;\n-                }\n-\n-                inside_long_diag = line.contains(\"r##\\\"\");\n-            }\n-        },\n-    );\n-\n-    let mut max = 0;\n-    for (&code, entries) in map.iter() {\n-        if code > max {\n-            max = code;\n-        }\n-        if entries.len() == 1 {\n-            continue;\n-        }\n-\n-        tidy_error!(bad, \"duplicate error code: {}\", code);\n-        for &(ref file, line_num, ref line) in entries.iter() {\n-            tidy_error!(bad, \"{}:{}: {}\", file.display(), line_num, line);\n-        }\n-    }\n-\n-    if !*bad {\n-        println!(\"* {} error codes\", map.len());\n-        println!(\"* highest error code: E{:04}\", max);\n-    }\n-}"}, {"sha": "bf6e2cc250f3d2fbddbe78b46c6867cb53711546", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=04b9038610606313cf023e59fc6a0ef4d5d22340", "patch": "@@ -56,8 +56,7 @@ pub mod bins;\n pub mod debug_artifacts;\n pub mod deps;\n pub mod edition;\n-pub mod error_codes_check;\n-pub mod errors;\n+pub mod error_codes;\n pub mod extdeps;\n pub mod features;\n pub mod mir_opt_tests;"}, {"sha": "8bb79bab1470bf53bfd801c047d458bae0174d13", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b9038610606313cf023e59fc6a0ef4d5d22340/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=04b9038610606313cf023e59fc6a0ef4d5d22340", "patch": "@@ -27,6 +27,7 @@ fn main() {\n     let src_path = root_path.join(\"src\");\n     let library_path = root_path.join(\"library\");\n     let compiler_path = root_path.join(\"compiler\");\n+    let librustdoc_path = src_path.join(\"librustdoc\");\n \n     let args: Vec<String> = env::args().skip(1).collect();\n \n@@ -79,8 +80,7 @@ fn main() {\n         check!(mir_opt_tests, &src_path, bless);\n \n         // Checks that only make sense for the compiler.\n-        check!(errors, &compiler_path);\n-        check!(error_codes_check, &[&src_path, &compiler_path]);\n+        check!(error_codes, &root_path, &[&compiler_path, &librustdoc_path]);\n \n         // Checks that only make sense for the std libs.\n         check!(pal, &library_path);"}]}