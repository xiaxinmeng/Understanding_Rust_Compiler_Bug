{"sha": "d6737e55fb49d286b5e646f57975b27b2c95ce92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NzM3ZTU1ZmI0OWQyODZiNWU2NDZmNTc5NzViMjdiMmM5NWNlOTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-12T21:05:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-12T21:05:12Z"}, "message": "Merge #9239\n\n9239: fix: Fix coercion in match with expected type r=flodiebold a=flodiebold\n\nPlus add infrastructure to test type mismatches without expect.\r\n\r\nCC #8961\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8d79fe8e63f8154e2e331660442aee83d99904a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d79fe8e63f8154e2e331660442aee83d99904a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6737e55fb49d286b5e646f57975b27b2c95ce92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxSGICRBK7hj4Ov3rIwAATYsIAEAwoks7/PHUAa913WUoHVHt\nZjMk3EGIcw9BIyL9a8W/gUAoanvIfKmDwc3Sc9Bm/DakXRjlbFm+wG1Jbim4tDGJ\nr23bes8heFCBFstcl32sKHh5UVlzpC1r9Y1jrWUlGP6Cvmo8Ub5BVgG2jj1zYHek\neBRiwp2eOjh+PEc1X6E+BAOxXA7DVWdXNEiZKZ30h90Bo0C0SBxf24wqWEL8EMzK\nHmwaqyq/sGja9/9pUfN+j2GqoWFrE1SW9z0aeyMYt2WMT+pyCPWxOlBouQNOUH20\nzfMzfCSqal1HOiwTBFWQmMV5o2DNbIm7EwCbQt/fR8pM2IfzpLK8iGBiGFIRMW8=\n=rc1/\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d79fe8e63f8154e2e331660442aee83d99904a4\nparent 7bbb3e34d5e2ca25b6987bf679cb9962bd0c52b6\nparent 20487a1b4a7c2fdffdb1de61c7837ee6f673f21a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623531912 +0000\ncommitter GitHub <noreply@github.com> 1623531912 +0000\n\nMerge #9239\n\n9239: fix: Fix coercion in match with expected type r=flodiebold a=flodiebold\n\nPlus add infrastructure to test type mismatches without expect.\r\n\r\nCC #8961\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6737e55fb49d286b5e646f57975b27b2c95ce92", "html_url": "https://github.com/rust-lang/rust/commit/d6737e55fb49d286b5e646f57975b27b2c95ce92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6737e55fb49d286b5e646f57975b27b2c95ce92/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bbb3e34d5e2ca25b6987bf679cb9962bd0c52b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bbb3e34d5e2ca25b6987bf679cb9962bd0c52b6", "html_url": "https://github.com/rust-lang/rust/commit/7bbb3e34d5e2ca25b6987bf679cb9962bd0c52b6"}, {"sha": "20487a1b4a7c2fdffdb1de61c7837ee6f673f21a", "url": "https://api.github.com/repos/rust-lang/rust/commits/20487a1b4a7c2fdffdb1de61c7837ee6f673f21a", "html_url": "https://github.com/rust-lang/rust/commit/20487a1b4a7c2fdffdb1de61c7837ee6f673f21a"}], "stats": {"total": 239, "additions": 184, "deletions": 55}, "files": [{"sha": "d26f8f180818170c2a07d966d2b86813d1b36a2b", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -42,7 +42,7 @@ pub struct FilePosition {\n     pub offset: TextSize,\n }\n \n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n pub struct FileRange {\n     pub file_id: FileId,\n     pub range: TextRange,"}, {"sha": "f023c1fb7de3f37cb73551309371491b15b5ab3f", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -761,6 +761,38 @@ impl Expectation {\n             Expectation::RValueLikeUnsized(_) | Expectation::None => None,\n         }\n     }\n+\n+    /// Comment copied from rustc:\n+    /// Disregard \"castable to\" expectations because they\n+    /// can lead us astray. Consider for example `if cond\n+    /// {22} else {c} as u8` -- if we propagate the\n+    /// \"castable to u8\" constraint to 22, it will pick the\n+    /// type 22u8, which is overly constrained (c might not\n+    /// be a u8). In effect, the problem is that the\n+    /// \"castable to\" expectation is not the tightest thing\n+    /// we can say, so we want to drop it in this case.\n+    /// The tightest thing we can say is \"must unify with\n+    /// else branch\". Note that in the case of a \"has type\"\n+    /// constraint, this limitation does not hold.\n+    ///\n+    /// If the expected type is just a type variable, then don't use\n+    /// an expected type. Otherwise, we might write parts of the type\n+    /// when checking the 'then' block which are incompatible with the\n+    /// 'else' branch.\n+    fn adjust_for_branches(&self, table: &mut unify::InferenceTable) -> Expectation {\n+        match self {\n+            Expectation::HasType(ety) => {\n+                let ety = table.resolve_ty_shallow(&ety);\n+                if !ety.is_ty_var() {\n+                    Expectation::HasType(ety)\n+                } else {\n+                    Expectation::None\n+                }\n+            }\n+            Expectation::RValueLikeUnsized(ety) => Expectation::RValueLikeUnsized(ety.clone()),\n+            _ => Expectation::None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "e34f194fff8a0a79dbddc71a1d6ec94155bb68c1", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -337,10 +337,15 @@ impl<'a> InferenceContext<'a> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n+                let expected = expected.adjust_for_branches(&mut self.table);\n+\n                 let mut result_ty = if arms.is_empty() {\n                     TyKind::Never.intern(&Interner)\n                 } else {\n-                    self.table.new_type_var()\n+                    match &expected {\n+                        Expectation::HasType(ty) => ty.clone(),\n+                        _ => self.table.new_type_var(),\n+                    }\n                 };\n \n                 let matchee_diverges = self.diverges;"}, {"sha": "b873585c47d792a5ca4aa8c2476685842e5e9852", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -9,7 +9,7 @@ mod macros;\n mod display_source_code;\n mod incremental;\n \n-use std::{env, sync::Arc};\n+use std::{collections::HashMap, env, sync::Arc};\n \n use base_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n use expect_test::Expect;\n@@ -83,9 +83,105 @@ fn check_types_impl(ra_fixture: &str, display_source: bool) {\n             checked_one = true;\n         }\n     }\n+\n     assert!(checked_one, \"no `//^` annotations found\");\n }\n \n+fn check_no_mismatches(ra_fixture: &str) {\n+    check_mismatches_impl(ra_fixture, true)\n+}\n+\n+#[allow(unused)]\n+fn check_mismatches(ra_fixture: &str) {\n+    check_mismatches_impl(ra_fixture, false)\n+}\n+\n+fn check_mismatches_impl(ra_fixture: &str, allow_none: bool) {\n+    let _tracing = setup_tracing();\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let module = db.module_for_file(file_id);\n+    let def_map = module.def_map(&db);\n+\n+    let mut defs: Vec<DefWithBodyId> = Vec::new();\n+    visit_module(&db, &def_map, module.local_id, &mut |it| defs.push(it));\n+    defs.sort_by_key(|def| match def {\n+        DefWithBodyId::FunctionId(it) => {\n+            let loc = it.lookup(&db);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n+        DefWithBodyId::ConstId(it) => {\n+            let loc = it.lookup(&db);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n+        DefWithBodyId::StaticId(it) => {\n+            let loc = it.lookup(&db);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n+    });\n+    let mut mismatches = HashMap::new();\n+    let mut push_mismatch = |src_ptr: InFile<SyntaxNode>, mismatch: TypeMismatch| {\n+        let range = src_ptr.value.text_range();\n+        if src_ptr.file_id.call_node(&db).is_some() {\n+            panic!(\"type mismatch in macro expansion\");\n+        }\n+        let file_range = FileRange { file_id: src_ptr.file_id.original_file(&db), range };\n+        let actual = format!(\n+            \"expected {}, got {}\",\n+            mismatch.expected.display_test(&db),\n+            mismatch.actual.display_test(&db)\n+        );\n+        mismatches.insert(file_range, actual);\n+    };\n+    for def in defs {\n+        let (_body, body_source_map) = db.body_with_source_map(def);\n+        let inference_result = db.infer(def);\n+        for (pat, mismatch) in inference_result.pat_type_mismatches() {\n+            let syntax_ptr = match body_source_map.pat_syntax(pat) {\n+                Ok(sp) => {\n+                    let root = db.parse_or_expand(sp.file_id).unwrap();\n+                    sp.map(|ptr| {\n+                        ptr.either(\n+                            |it| it.to_node(&root).syntax().clone(),\n+                            |it| it.to_node(&root).syntax().clone(),\n+                        )\n+                    })\n+                }\n+                Err(SyntheticSyntax) => continue,\n+            };\n+            push_mismatch(syntax_ptr, mismatch.clone());\n+        }\n+        for (expr, mismatch) in inference_result.expr_type_mismatches() {\n+            let node = match body_source_map.expr_syntax(expr) {\n+                Ok(sp) => {\n+                    let root = db.parse_or_expand(sp.file_id).unwrap();\n+                    sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n+                }\n+                Err(SyntheticSyntax) => continue,\n+            };\n+            push_mismatch(node, mismatch.clone());\n+        }\n+    }\n+    let mut checked_one = false;\n+    for (file_id, annotations) in db.extract_annotations() {\n+        for (range, expected) in annotations {\n+            let file_range = FileRange { file_id, range };\n+            if let Some(mismatch) = mismatches.remove(&file_range) {\n+                assert_eq!(mismatch, expected);\n+            } else {\n+                assert!(false, \"Expected mismatch not encountered: {}\\n\", expected);\n+            }\n+            checked_one = true;\n+        }\n+    }\n+    let mut buf = String::new();\n+    for (range, mismatch) in mismatches {\n+        format_to!(buf, \"{:?}: {}\\n\", range.range, mismatch,);\n+    }\n+    assert!(buf.is_empty(), \"Unexpected type mismatches:\\n{}\", buf);\n+\n+    assert!(checked_one || allow_none, \"no `//^` annotations found\");\n+}\n+\n fn type_at_range(db: &TestDB, pos: FileRange) -> Ty {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_range::<ast::Expr>(file.syntax(), pos.range).unwrap();"}, {"sha": "71047703d18ee1c50de74a7f03de5caf105fea47", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_types};\n+use super::{check_infer, check_infer_with_mismatches, check_no_mismatches, check_types};\n \n #[test]\n fn infer_block_expr_type_mismatch() {\n@@ -963,7 +963,7 @@ fn test() -> i32 {\n \n #[test]\n fn panic_macro() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n mod panic {\n     #[macro_export]\n@@ -991,15 +991,34 @@ fn main() {\n     panic!()\n }\n         \"#,\n-        expect![[r#\"\n-            174..185 '{ loop {} }': !\n-            176..183 'loop {}': !\n-            181..183 '{}': ()\n-            !0..24 '$crate...:panic': fn panic() -> !\n-            !0..26 '$crate...anic()': !\n-            !0..26 '$crate...anic()': !\n-            !0..28 '$crate...015!()': !\n-            454..470 '{     ...c!() }': ()\n-        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn coerce_unsize_expected_type() {\n+    check_no_mismatches(\n+        r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+#[lang = \"unsize\"]\n+pub trait Unsize<T> {}\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<T: Unsize<U>, U> CoerceUnsized<&U> for &T {}\n+\n+fn main() {\n+    let foo: &[u32] = &[1, 2];\n+    let foo: &[u32] = match true {\n+        true => &[1, 2],\n+        false => &[1, 2, 3],\n+    };\n+    let foo: &[u32] = if true {\n+        &[1, 2]\n+    } else {\n+        &[1, 2, 3]\n+    };\n+}\n+        \"#,\n     );\n }"}, {"sha": "aa513c56d5c43226f9736188467d96ce6ae5dfbb", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6737e55fb49d286b5e646f57975b27b2c95ce92/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=d6737e55fb49d286b5e646f57975b27b2c95ce92", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_infer_with_mismatches, check_types};\n+use super::{check_infer, check_infer_with_mismatches, check_mismatches, check_types};\n \n #[test]\n fn infer_pattern() {\n@@ -518,47 +518,24 @@ fn infer_generics_in_patterns() {\n \n #[test]\n fn infer_const_pattern() {\n-    check_infer_with_mismatches(\n+    check_mismatches(\n         r#\"\n-        enum Option<T> { None }\n-        use Option::None;\n-        struct Foo;\n-        const Bar: usize = 1;\n-\n-        fn test() {\n-            let a: Option<u32> = None;\n-            let b: Option<i64> = match a {\n-                None => None,\n-            };\n-            let _: () = match () { Foo => Foo }; // Expected mismatch\n-            let _: () = match () { Bar => Bar }; // Expected mismatch\n-        }\n+enum Option<T> { None }\n+use Option::None;\n+struct Foo;\n+const Bar: usize = 1;\n+\n+fn test() {\n+    let a: Option<u32> = None;\n+    let b: Option<i64> = match a {\n+        None => None,\n+    };\n+    let _: () = match () { Foo => () };\n+                        // ^^^ expected (), got Foo\n+    let _: () = match () { Bar => () };\n+                        // ^^^ expected (), got usize\n+}\n         \"#,\n-        expect![[r#\"\n-            73..74 '1': usize\n-            87..309 '{     ...atch }': ()\n-            97..98 'a': Option<u32>\n-            114..118 'None': Option<u32>\n-            128..129 'b': Option<i64>\n-            145..182 'match ...     }': Option<i64>\n-            151..152 'a': Option<u32>\n-            163..167 'None': Option<u32>\n-            171..175 'None': Option<i64>\n-            192..193 '_': ()\n-            200..223 'match ... Foo }': Foo\n-            206..208 '()': ()\n-            211..214 'Foo': Foo\n-            218..221 'Foo': Foo\n-            254..255 '_': ()\n-            262..285 'match ... Bar }': usize\n-            268..270 '()': ()\n-            273..276 'Bar': usize\n-            280..283 'Bar': usize\n-            200..223: expected (), got Foo\n-            211..214: expected (), got Foo\n-            262..285: expected (), got usize\n-            273..276: expected (), got usize\n-        \"#]],\n     );\n }\n "}]}