{"sha": "0545e4781d3aba3083835cfa8afab07b7442a3aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDVlNDc4MWQzYWJhMzA4MzgzNWNmYThhZmFiMDdiNzQ0MmEzYWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-28T06:03:47Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-28T06:03:47Z"}, "message": "Merge #1336\n\n1336: Refactor SubtreeSource r=matklad a=edwin0cheng\n\nThis PR simplify `SubtreeSource` by removing `SubtreeWalk` and `Querier` and only walk through the top level `TokenTree` when collecting token from source, by comparing two cursors directly.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "a74609717cd2e986057ac9e9c3a0f70088ec5682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74609717cd2e986057ac9e9c3a0f70088ec5682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0545e4781d3aba3083835cfa8afab07b7442a3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0545e4781d3aba3083835cfa8afab07b7442a3aa", "html_url": "https://github.com/rust-lang/rust/commit/0545e4781d3aba3083835cfa8afab07b7442a3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0545e4781d3aba3083835cfa8afab07b7442a3aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b2bf41b2bac48edd53e3059adfba4a12b3c96aa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bf41b2bac48edd53e3059adfba4a12b3c96aa0", "html_url": "https://github.com/rust-lang/rust/commit/b2bf41b2bac48edd53e3059adfba4a12b3c96aa0"}, {"sha": "464a00814cf604a57c77ce456d1ca2677eb4e61a", "url": "https://api.github.com/repos/rust-lang/rust/commits/464a00814cf604a57c77ce456d1ca2677eb4e61a", "html_url": "https://github.com/rust-lang/rust/commit/464a00814cf604a57c77ce456d1ca2677eb4e61a"}], "stats": {"total": 305, "additions": 149, "deletions": 156}, "files": [{"sha": "1f12e42ef001910ac5a0acd3ae0ea061f8a17e17", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=0545e4781d3aba3083835cfa8afab07b7442a3aa", "patch": "@@ -2,16 +2,38 @@ use crate::subtree_source::SubtreeTokenSource;\n \n use ra_parser::{TokenSource, TreeSink};\n use ra_syntax::{SyntaxKind};\n-use tt::buffer::TokenBuffer;\n+use tt::buffer::{TokenBuffer, Cursor};\n \n-struct OffsetTokenSink {\n-    token_pos: usize,\n+struct OffsetTokenSink<'a> {\n+    cursor: Cursor<'a>,\n     error: bool,\n }\n \n-impl TreeSink for OffsetTokenSink {\n+impl<'a> OffsetTokenSink<'a> {\n+    pub fn collect(&self, begin: Cursor<'a>) -> Vec<tt::TokenTree> {\n+        if !self.cursor.is_root() {\n+            return vec![];\n+        }\n+\n+        let mut curr = begin;\n+        let mut res = vec![];\n+\n+        while self.cursor != curr {\n+            if let Some(token) = curr.token_tree() {\n+                res.push(token);\n+            }\n+            curr = curr.bump();\n+        }\n+\n+        res\n+    }\n+}\n+\n+impl<'a> TreeSink for OffsetTokenSink<'a> {\n     fn token(&mut self, _kind: SyntaxKind, n_tokens: u8) {\n-        self.token_pos += n_tokens as usize;\n+        for _ in 0..n_tokens {\n+            self.cursor = self.cursor.bump_subtree();\n+        }\n     }\n     fn start_node(&mut self, _kind: SyntaxKind) {}\n     fn finish_node(&mut self) {}\n@@ -72,23 +94,21 @@ impl<'a> Parser<'a> {\n     {\n         let buffer = TokenBuffer::new(&self.subtree.token_trees[*self.cur_pos..]);\n         let mut src = SubtreeTokenSource::new(&buffer);\n-        let mut sink = OffsetTokenSink { token_pos: 0, error: false };\n+        let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n         f(&mut src, &mut sink);\n \n-        let r = self.finish(sink.token_pos, &mut src);\n+        let r = self.finish(buffer.begin(), &mut sink);\n         if sink.error {\n             return None;\n         }\n         r\n     }\n \n-    fn finish(self, parsed_token: usize, src: &mut SubtreeTokenSource) -> Option<tt::TokenTree> {\n-        let res = src.bump_n(parsed_token);\n+    fn finish(self, begin: Cursor, sink: &mut OffsetTokenSink) -> Option<tt::TokenTree> {\n+        let res = sink.collect(begin);\n         *self.cur_pos += res.len();\n \n-        let res: Vec<_> = res.into_iter().collect();\n-\n         match res.len() {\n             0 => None,\n             1 => Some(res[0].clone()),"}, {"sha": "7647e16d8c23152593f3c7799413e30859f9724a", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 36, "deletions": 103, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=0545e4781d3aba3083835cfa8afab07b7442a3aa", "patch": "@@ -1,34 +1,49 @@\n use ra_parser::{TokenSource, Token};\n use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*, T};\n use std::cell::{RefCell, Cell};\n-use std::sync::Arc;\n use tt::buffer::{TokenBuffer, Cursor};\n \n-pub(crate) trait Querier {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n-}\n-\n #[derive(Debug, Clone, Eq, PartialEq)]\n struct TtToken {\n     pub kind: SyntaxKind,\n     pub is_joint_to_next: bool,\n     pub text: SmolStr,\n }\n \n-// A wrapper class for ref cell\n-#[derive(Debug)]\n-pub(crate) struct SubtreeWalk<'a> {\n-    start: Cursor<'a>,\n-    cursor: Cell<Cursor<'a>>,\n+pub(crate) struct SubtreeTokenSource<'a> {\n+    cached_cursor: Cell<Cursor<'a>>,\n     cached: RefCell<Vec<Option<TtToken>>>,\n+    curr: (Token, usize),\n+}\n+\n+impl<'a> SubtreeTokenSource<'a> {\n+    // Helper function used in test\n+    #[cfg(test)]\n+    pub fn text(&self) -> SmolStr {\n+        match self.get(self.curr.1) {\n+            Some(tt) => tt.text,\n+            _ => SmolStr::new(\"\"),\n+        }\n+    }\n }\n \n-impl<'a> SubtreeWalk<'a> {\n-    fn new(cursor: Cursor<'a>) -> Self {\n-        SubtreeWalk {\n-            start: cursor,\n-            cursor: Cell::new(cursor),\n+impl<'a> SubtreeTokenSource<'a> {\n+    pub fn new(buffer: &'a TokenBuffer) -> SubtreeTokenSource<'a> {\n+        let cursor = buffer.begin();\n+\n+        let mut res = SubtreeTokenSource {\n+            curr: (Token { kind: EOF, is_jointed_to_next: false }, 0),\n+            cached_cursor: Cell::new(cursor),\n             cached: RefCell::new(Vec::with_capacity(10)),\n+        };\n+        res.curr = (res.mk_token(0), 0);\n+        res\n+    }\n+\n+    fn mk_token(&self, pos: usize) -> Token {\n+        match self.get(pos) {\n+            Some(tt) => Token { kind: tt.kind, is_jointed_to_next: tt.is_joint_to_next },\n+            None => Token { kind: EOF, is_jointed_to_next: false },\n         }\n     }\n \n@@ -39,7 +54,7 @@ impl<'a> SubtreeWalk<'a> {\n         }\n \n         while pos >= cached.len() {\n-            let cursor = self.cursor.get();\n+            let cursor = self.cached_cursor.get();\n             if cursor.eof() {\n                 cached.push(None);\n                 continue;\n@@ -48,105 +63,23 @@ impl<'a> SubtreeWalk<'a> {\n             match cursor.token_tree() {\n                 Some(tt::TokenTree::Leaf(leaf)) => {\n                     cached.push(Some(convert_leaf(&leaf)));\n-                    self.cursor.set(cursor.bump());\n+                    self.cached_cursor.set(cursor.bump());\n                 }\n                 Some(tt::TokenTree::Subtree(subtree)) => {\n-                    self.cursor.set(cursor.subtree().unwrap());\n+                    self.cached_cursor.set(cursor.subtree().unwrap());\n                     cached.push(Some(convert_delim(subtree.delimiter, false)));\n                 }\n                 None => {\n                     if let Some(subtree) = cursor.end() {\n                         cached.push(Some(convert_delim(subtree.delimiter, true)));\n-                        self.cursor.set(cursor.bump());\n+                        self.cached_cursor.set(cursor.bump());\n                     }\n                 }\n             }\n         }\n \n         return cached[pos].clone();\n     }\n-\n-    fn collect_token_trees(&self, n: usize) -> Vec<tt::TokenTree> {\n-        let mut res = vec![];\n-\n-        let mut pos = 0;\n-        let mut cursor = self.start;\n-        let mut level = 0;\n-\n-        while pos < n {\n-            if cursor.eof() {\n-                break;\n-            }\n-\n-            match cursor.token_tree() {\n-                Some(tt::TokenTree::Leaf(leaf)) => {\n-                    if level == 0 {\n-                        res.push(leaf.into());\n-                    }\n-                    cursor = cursor.bump();\n-                    pos += 1;\n-                }\n-                Some(tt::TokenTree::Subtree(subtree)) => {\n-                    if level == 0 {\n-                        res.push(subtree.into());\n-                    }\n-                    pos += 1;\n-                    level += 1;\n-                    cursor = cursor.subtree().unwrap();\n-                }\n-\n-                None => {\n-                    if let Some(_) = cursor.end() {\n-                        level -= 1;\n-                        pos += 1;\n-                        cursor = cursor.bump();\n-                    }\n-                }\n-            }\n-        }\n-\n-        res\n-    }\n-}\n-\n-impl<'a> Querier for SubtreeWalk<'a> {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool) {\n-        self.get(uidx)\n-            .map(|tkn| (tkn.kind, tkn.text, tkn.is_joint_to_next))\n-            .unwrap_or_else(|| (SyntaxKind::EOF, \"\".into(), false))\n-    }\n-}\n-\n-pub(crate) struct SubtreeTokenSource<'a> {\n-    walker: Arc<SubtreeWalk<'a>>,\n-    curr: (Token, usize),\n-}\n-\n-impl<'a> SubtreeTokenSource<'a> {\n-    pub fn new(buffer: &'a TokenBuffer) -> SubtreeTokenSource<'a> {\n-        let mut res = SubtreeTokenSource {\n-            walker: Arc::new(SubtreeWalk::new(buffer.begin())),\n-            curr: (Token { kind: EOF, is_jointed_to_next: false }, 0),\n-        };\n-        res.curr = (res.mk_token(0), 0);\n-        res\n-    }\n-\n-    pub fn querier(&self) -> Arc<SubtreeWalk<'a>> {\n-        self.walker.clone()\n-    }\n-\n-    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<tt::TokenTree> {\n-        let res = self.walker.collect_token_trees(parsed_tokens);\n-        res\n-    }\n-\n-    fn mk_token(&self, pos: usize) -> Token {\n-        match self.walker.get(pos) {\n-            Some(tt) => Token { kind: tt.kind, is_jointed_to_next: tt.is_joint_to_next },\n-            None => Token { kind: EOF, is_jointed_to_next: false },\n-        }\n-    }\n }\n \n impl<'a> TokenSource for SubtreeTokenSource<'a> {\n@@ -165,12 +98,12 @@ impl<'a> TokenSource for SubtreeTokenSource<'a> {\n             return;\n         }\n \n-        self.curr = (self.mk_token(self.curr.1 + 1), self.curr.1 + 1)\n+        self.curr = (self.mk_token(self.curr.1 + 1), self.curr.1 + 1);\n     }\n \n     /// Is the current token a specified keyword?\n     fn is_keyword(&self, kw: &str) -> bool {\n-        match self.walker.get(self.curr.1) {\n+        match self.get(self.curr.1) {\n             Some(t) => t.text == *kw,\n             _ => false,\n         }"}, {"sha": "c0a3fec352e8603645e8b9f0bfb99e61b60a3709", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 67, "deletions": 42, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=0545e4781d3aba3083835cfa8afab07b7442a3aa", "patch": "@@ -3,8 +3,8 @@ use ra_syntax::{\n     AstNode, SyntaxNode, TextRange, SyntaxKind, SmolStr, SyntaxTreeBuilder, TreeArc, SyntaxElement,\n     ast, SyntaxKind::*, TextUnit, T\n };\n-\n-use crate::subtree_source::{SubtreeTokenSource, Querier};\n+use tt::buffer::{TokenBuffer, Cursor};\n+use crate::subtree_source::{SubtreeTokenSource};\n use crate::ExpandError;\n \n /// Maps `tt::TokenId` to the relative range of the original token.\n@@ -49,10 +49,9 @@ fn token_tree_to_syntax_node<F>(tt: &tt::Subtree, f: F) -> Result<TreeArc<Syntax\n where\n     F: Fn(&mut ra_parser::TokenSource, &mut ra_parser::TreeSink),\n {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let buffer = TokenBuffer::new(&[tt.clone().into()]);\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n+    let mut tree_sink = TtTreeSink::new(buffer.begin());\n     f(&mut token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n         return Err(ExpandError::ConversionError);\n@@ -259,64 +258,86 @@ fn convert_tt(\n     Some(res)\n }\n \n-struct TtTreeSink<'a, Q: Querier> {\n+struct TtTreeSink<'a> {\n     buf: String,\n-    src_querier: &'a Q,\n+    cursor: Cursor<'a>,\n     text_pos: TextUnit,\n-    token_pos: usize,\n     inner: SyntaxTreeBuilder,\n \n     // Number of roots\n     // Use for detect ill-form tree which is not single root\n     roots: smallvec::SmallVec<[usize; 1]>,\n }\n \n-impl<'a, Q: Querier> TtTreeSink<'a, Q> {\n-    fn new(src_querier: &'a Q) -> Self {\n+impl<'a> TtTreeSink<'a> {\n+    fn new(cursor: Cursor<'a>) -> Self {\n         TtTreeSink {\n             buf: String::new(),\n-            src_querier,\n+            cursor,\n             text_pos: 0.into(),\n-            token_pos: 0,\n             inner: SyntaxTreeBuilder::default(),\n             roots: smallvec::SmallVec::new(),\n         }\n     }\n }\n \n-fn is_delimiter(kind: SyntaxKind) -> bool {\n-    match kind {\n-        T!['('] | T!['['] | T!['{'] | T![')'] | T![']'] | T!['}'] => true,\n-        _ => false,\n-    }\n+fn delim_to_str(d: tt::Delimiter, closing: bool) -> SmolStr {\n+    let texts = match d {\n+        tt::Delimiter::Parenthesis => \"()\",\n+        tt::Delimiter::Brace => \"{}\",\n+        tt::Delimiter::Bracket => \"[]\",\n+        tt::Delimiter::None => \"\",\n+    };\n+\n+    let idx = closing as usize;\n+    let text = if texts.len() > 0 { &texts[idx..texts.len() - (1 - idx)] } else { \"\" };\n+    text.into()\n }\n \n-impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n+impl<'a> TreeSink for TtTreeSink<'a> {\n     fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n         if kind == L_DOLLAR || kind == R_DOLLAR {\n-            self.token_pos += n_tokens as usize;\n+            self.cursor = self.cursor.bump_subtree();\n             return;\n         }\n \n         for _ in 0..n_tokens {\n-            self.buf += &self.src_querier.token(self.token_pos).1;\n-            self.token_pos += 1;\n+            if self.cursor.eof() {\n+                break;\n+            }\n+\n+            match self.cursor.token_tree() {\n+                Some(tt::TokenTree::Leaf(leaf)) => {\n+                    self.cursor = self.cursor.bump();\n+                    self.buf += &format!(\"{}\", leaf);\n+                }\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    self.cursor = self.cursor.subtree().unwrap();\n+                    self.buf += &delim_to_str(subtree.delimiter, false);\n+                }\n+                None => {\n+                    if let Some(parent) = self.cursor.end() {\n+                        self.cursor = self.cursor.bump();\n+                        self.buf += &delim_to_str(parent.delimiter, true);\n+                    }\n+                }\n+            };\n         }\n+\n         self.text_pos += TextUnit::of_str(&self.buf);\n         let text = SmolStr::new(self.buf.as_str());\n         self.buf.clear();\n         self.inner.token(kind, text);\n \n-        // Add a white space between tokens, only if both are not delimiters\n-        if !is_delimiter(kind) {\n-            let (last_kind, _, last_joint_to_next) = self.src_querier.token(self.token_pos - 1);\n-            if !last_joint_to_next && last_kind.is_punct() {\n-                let (cur_kind, _, _) = self.src_querier.token(self.token_pos);\n-                if !is_delimiter(cur_kind) {\n-                    if cur_kind.is_punct() {\n-                        self.inner.token(WHITESPACE, \" \".into());\n-                    }\n-                }\n+        // Add whitespace between adjoint puncts\n+        let next = self.cursor.bump();\n+        if let (\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(curr))),\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(_))),\n+        ) = (self.cursor.token_tree(), next.token_tree())\n+        {\n+            if curr.spacing == tt::Spacing::Alone {\n+                self.inner.token(WHITESPACE, \" \".into());\n             }\n         }\n     }\n@@ -344,6 +365,7 @@ impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n mod tests {\n     use super::*;\n     use crate::tests::{expand, create_rules};\n+    use ra_parser::TokenSource;\n \n     #[test]\n     fn convert_tt_token_source() {\n@@ -363,24 +385,27 @@ mod tests {\n         );\n         let expansion = expand(&rules, \"literals!(foo)\");\n         let buffer = tt::buffer::TokenBuffer::new(&[expansion.clone().into()]);\n-        let tt_src = SubtreeTokenSource::new(&buffer);\n-\n-        let query = tt_src.querier();\n+        let mut tt_src = SubtreeTokenSource::new(&buffer);\n+        let mut tokens = vec![];\n+        while tt_src.current().kind != EOF {\n+            tokens.push((tt_src.current().kind, tt_src.text()));\n+            tt_src.bump();\n+        }\n \n         // [${]\n         // [let] [a] [=] ['c'] [;]\n-        assert_eq!(query.token(2 + 3).1, \"'c'\");\n-        assert_eq!(query.token(2 + 3).0, CHAR);\n+        assert_eq!(tokens[2 + 3].1, \"'c'\");\n+        assert_eq!(tokens[2 + 3].0, CHAR);\n         // [let] [c] [=] [1000] [;]\n-        assert_eq!(query.token(2 + 5 + 3).1, \"1000\");\n-        assert_eq!(query.token(2 + 5 + 3).0, INT_NUMBER);\n+        assert_eq!(tokens[2 + 5 + 3].1, \"1000\");\n+        assert_eq!(tokens[2 + 5 + 3].0, INT_NUMBER);\n         // [let] [f] [=] [12E+99_f64] [;]\n-        assert_eq!(query.token(2 + 10 + 3).1, \"12E+99_f64\");\n-        assert_eq!(query.token(2 + 10 + 3).0, FLOAT_NUMBER);\n+        assert_eq!(tokens[2 + 10 + 3].1, \"12E+99_f64\");\n+        assert_eq!(tokens[2 + 10 + 3].0, FLOAT_NUMBER);\n \n         // [let] [s] [=] [\"rust1\"] [;]\n-        assert_eq!(query.token(2 + 15 + 3).1, \"\\\"rust1\\\"\");\n-        assert_eq!(query.token(2 + 15 + 3).0, STRING);\n+        assert_eq!(tokens[2 + 15 + 3].1, \"\\\"rust1\\\"\");\n+        assert_eq!(tokens[2 + 15 + 3].0, STRING);\n     }\n \n     #[test]"}, {"sha": "940f2b8079e33648b4f4fe97acc7a44cd630b980", "filename": "crates/ra_tt/src/buffer.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0545e4781d3aba3083835cfa8afab07b7442a3aa/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Fbuffer.rs?ref=0545e4781d3aba3083835cfa8afab07b7442a3aa", "patch": "@@ -166,4 +166,19 @@ impl<'a> Cursor<'a> {\n             Cursor::create(self.buffer, EntryPtr(self.ptr.0, self.ptr.1 + 1))\n         }\n     }\n+\n+    /// Bump the cursor, if it is a subtree, returns\n+    /// a cursor into that subtree\n+    pub fn bump_subtree(self) -> Cursor<'a> {\n+        match self.entry() {\n+            Some(Entry::Subtree(_, _)) => self.subtree().unwrap(),\n+            _ => self.bump(),\n+        }\n+    }\n+\n+    /// Check whether it is a top level\n+    pub fn is_root(&self) -> bool {\n+        let entry_id = self.ptr.0;\n+        return entry_id.0 == 0;\n+    }\n }"}]}