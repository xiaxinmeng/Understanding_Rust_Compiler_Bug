{"sha": "6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOWQ5NWE5YTBmODI4OTU1NTlkYzFkYWU2MzAwZWUxNGMzMDRkN2U=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-13T17:56:09Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-13T20:08:05Z"}, "message": "Track purity/unsafety of iface and impl methods\n\nCloses #1807", "tree": {"sha": "0459bf59264521a7168ccf4266ca0859f45d8a99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0459bf59264521a7168ccf4266ca0859f45d8a99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "html_url": "https://github.com/rust-lang/rust/commit/6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9caca02dac6bb9318aaa2f9ac52868b8ccead3e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9caca02dac6bb9318aaa2f9ac52868b8ccead3e0", "html_url": "https://github.com/rust-lang/rust/commit/9caca02dac6bb9318aaa2f9ac52868b8ccead3e0"}], "stats": {"total": 151, "additions": 90, "deletions": 61}, "files": [{"sha": "f77a50bf0560fe176d3ec1643b50ad47ed38af12", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -9,6 +9,7 @@ import driver::session;\n export get_symbol;\n export get_type_param_count;\n export lookup_defs;\n+export lookup_method_purity;\n export get_enum_variants;\n export get_impls_for_mod;\n export get_iface_methods;\n@@ -35,6 +36,15 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n     ret result;\n }\n \n+fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n+    -> ast::purity {\n+    let cdata = cstore::get_crate_data(cstore, did.crate).data;\n+    alt decoder::lookup_def(did.crate, cdata, did) {\n+      ast::def_fn(_, p) { p }\n+      _ { fail; }\n+    }\n+}\n+\n fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n                 path: [ast::ident]) ->\n     [(ast::crate_num, @[u8], ast::def_id)] {"}, {"sha": "1019a179050c496c87d5a2a21cd0148ebebe129d", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -337,7 +337,12 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let fty = alt ty::get(ty).struct { ty::ty_fn(f) { f }\n           _ { tcx.sess.bug(\"get_iface_methods: id has non-function type\");\n         } };\n-        result += [{ident: name, tps: bounds, fty: fty}];\n+        result += [{ident: name, tps: bounds, fty: fty,\n+                    purity: alt item_family(mth) as char {\n+                      'u' { ast::unsafe_fn }\n+                      'f' { ast::impure_fn }\n+                      'p' { ast::pure_fn }\n+                    }}];\n     }\n     @result\n }"}, {"sha": "1226fd56aecf826f41deb5ac3df995e968dfd189", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -311,6 +311,10 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml::end_tag(ebml_w);\n }\n \n+fn purity_fn_family(p: purity) -> char {\n+    alt p { unsafe_fn { 'u' } pure_fn { 'p' } impure_fn { 'f' } }\n+}\n+\n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         &index: [entry<int>], path: ast_map::path) {\n     let tcx = ecx.ccx.tcx;\n@@ -327,12 +331,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_fn(decl, tps, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w,\n-                      alt decl.purity {\n-                        unsafe_fn { 'u' }\n-                        pure_fn { 'p' }\n-                        impure_fn { 'f' }\n-                      } as u8);\n+        encode_family(ebml_w, purity_fn_family(decl.purity) as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n@@ -431,10 +430,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.id));\n-            encode_family(ebml_w, 'f' as u8);\n+            encode_family(ebml_w, purity_fn_family(m.decl.purity) as u8);\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n-            encode_type(ecx, ebml_w,\n-                        node_id_to_type(tcx, m.id));\n+            encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n@@ -454,6 +452,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n             encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+            encode_family(ebml_w, purity_fn_family(mty.purity) as u8);\n             ebml::end_tag(ebml_w);\n             i += 1u;\n         }"}, {"sha": "be751de7d6894ea24c33e8b1b043604b16ee8811", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -88,8 +88,8 @@ fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n           }\n         }\n       }\n-      typeck::method_iface(off) {\n-        trans_iface_callee(bcx, callee_id, self, off)\n+      typeck::method_iface(iid, off) {\n+        trans_iface_callee(bcx, callee_id, self, iid, off)\n       }\n     }\n }\n@@ -165,8 +165,8 @@ fn trans_monomorphized_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                                 ast_util::local_def(mth.id),\n                                 some((tys, sub_origins)));\n       }\n-      typeck::dict_iface(_) {\n-        ret trans_iface_callee(bcx, callee_id, base, n_method);\n+      typeck::dict_iface(iid) {\n+        ret trans_iface_callee(bcx, callee_id, base, iid, n_method);\n       }\n       typeck::dict_param(n_param, n_bound) {\n         fail \"dict_param left in monomorphized function's dict substs\";\n@@ -186,7 +186,7 @@ fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n \n // Method callee where the dict comes from a boxed iface\n fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n-                      base: @ast::expr, n_method: uint)\n+                      base: @ast::expr, iface_id: ast::def_id, n_method: uint)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n@@ -195,10 +195,6 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = PointerCast(bcx, GEPi(bcx, box, [0, abi::box_field_body]),\n                            T_opaque_cbox_ptr(bcx_ccx(bcx)));\n-    let iface_id = alt ty::get(expr_ty(bcx, base)).struct {\n-        ty::ty_iface(did, _) { did }\n-        _ { fail \"base has non-iface type in trans_iface_callee\"; }\n-    };\n     trans_vtable_callee(bcx, self, dict, callee_id, iface_id, n_method)\n }\n "}, {"sha": "e5f8fa26ee7cc26362e94f71e0aa2391529429f5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -140,7 +140,10 @@ type field = {ident: ast::ident, mt: mt};\n \n type param_bounds = @[param_bound];\n \n-type method = {ident: ast::ident, tps: @[param_bounds], fty: fn_ty};\n+type method = {ident: ast::ident,\n+               tps: @[param_bounds],\n+               fty: fn_ty,\n+               purity: ast::purity};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n "}, {"sha": "7da03561ea06be74e566efc71893b7c39c36a6bb", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -25,7 +25,7 @@ enum method_origin {\n     method_static(ast::def_id),\n     // iface id, method num, param num, bound num\n     method_param(ast::def_id, uint, uint, uint),\n-    method_iface(uint),\n+    method_iface(ast::def_id, uint),\n }\n type method_map = hashmap<ast::node_id, method_origin>;\n \n@@ -556,12 +556,14 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl)}\n+     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n+     purity: m.decl.purity}\n }\n fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl)}\n+     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n+     purity: m.decl.purity}\n }\n \n // A convenience function to use a crate_ctxt to resolve names for\n@@ -817,6 +819,12 @@ mod collect {\n                         alt vec::find(my_methods,\n                                       {|m| if_m.ident == m.mty.ident}) {\n                           some({mty: m, id, span}) {\n+                            if m.purity != if_m.purity {\n+                                cx.tcx.sess.span_err(\n+                                    span, \"method `\" + m.ident + \"`'s purity \\\n+                                           not match the iface method's \\\n+                                           purity\");\n+                            }\n                             let mt = compare_impl_method(\n                                 cx.tcx, span, m, vec::len(tps), if_m, tys,\n                                 selfty);\n@@ -1536,30 +1544,39 @@ fn require_impure(sess: session, f_purity: ast::purity, sp: span) {\n \n fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n                      callee: @ast::expr, sp: span) {\n-    alt caller_purity {\n-      ast::unsafe_fn { ret; }\n-      ast::impure_fn {\n-        alt ccx.tcx.def_map.find(callee.id) {\n-          some(ast::def_fn(_, ast::unsafe_fn)) {\n-            ccx.tcx.sess.span_err(\n-                sp,\n-                \"safe function calls function marked unsafe\");\n+    if caller_purity == ast::unsafe_fn { ret; }\n+    let callee_purity = alt ccx.tcx.def_map.find(callee.id) {\n+      some(ast::def_fn(_, p)) { p }\n+      some(ast::def_variant(_, _)) { ast::pure_fn }\n+      _ {\n+        alt ccx.method_map.find(callee.id) {\n+          some(method_static(did)) {\n+            if did.crate == ast::local_crate {\n+                alt ccx.tcx.items.get(did.node) {\n+                  ast_map::node_method(m, _, _) { m.decl.purity }\n+                  _ { fail; }\n+                }\n+            } else {\n+                csearch::lookup_method_purity(ccx.tcx.sess.cstore, did)\n+            }\n           }\n-          _ {\n+          some(method_param(iid, n_m, _, _)) | some(method_iface(iid, n_m)) {\n+            ty::iface_methods(ccx.tcx, iid)[n_m].purity\n           }\n+          none { ast::impure_fn }\n         }\n-        ret;\n       }\n-      ast::pure_fn {\n-        alt ccx.tcx.def_map.find(callee.id) {\n-          some(ast::def_fn(_, ast::pure_fn)) |\n-          some(ast::def_variant(_, _)) { ret; }\n-          _ {\n-            ccx.tcx.sess.span_err\n-                (sp, \"pure function calls function not known to be pure\");\n-          }\n-        }\n+    };\n+    alt (caller_purity, callee_purity) {\n+      (ast::impure_fn, ast::unsafe_fn) {\n+        ccx.tcx.sess.span_err(sp, \"safe function calls function marked \\\n+                                   unsafe\");\n       }\n+      (ast::pure_fn, ast::unsafe_fn) | (ast::pure_fn, ast::impure_fn) {\n+        ccx.tcx.sess.span_err(sp, \"pure function calls function not \\\n+                                   known to be pure\");\n+      }\n+      _ {}\n     }\n }\n \n@@ -1686,7 +1703,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                 ret some({method_ty: fty,\n                           n_tps: vec::len(*m.tps),\n                           substs: tps,\n-                          origin: method_iface(i),\n+                          origin: method_iface(did, i),\n                           self_sub: none});\n             }\n             i += 1u;\n@@ -1875,12 +1892,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n                        args: [@ast::expr], id: ast::node_id) -> bool {\n+        let bot = check_call(fcx, sp, f, args);\n         /* here we're kind of hosed, as f can be any expr\n         need to restrict it to being an explicit expr_path if we're\n         inside a pure function, and need an environment mapping from\n         function name onto purity-designation */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n-        let bot = check_call(fcx, sp, f, args);\n \n         // Pull the return type out of the type of the function.\n         let fty = ty::expr_ty(fcx.ccx.tcx, f);"}, {"sha": "60a71ebe804e0d71600cd548bd5b375fac2d6134", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9d95a9a0f82895559dc1dae6300ee14c304d7e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "patch": "@@ -274,21 +274,22 @@ fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     let constrs: [@ast::constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n     ret {inputs: inputs.node, output: ret_ty,\n-                           purity: ast::impure_fn, cf: ret_style,\n-                           constraints: constrs};\n+         purity: ast::impure_fn, cf: ret_style,\n+         constraints: constrs};\n }\n \n fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n     parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(), {|p|\n         let attrs = parse_outer_attributes(p);\n         let flo = p.span.lo;\n-        expect_word(p, \"fn\");\n+        let pur = parse_fn_purity(p);\n         let ident = parse_method_name(p);\n         let tps = parse_ty_params(p);\n         let d = parse_ty_fn(p), fhi = p.last_span.hi;\n         expect(p, token::SEMI);\n-            {ident: ident, attrs: attrs, decl: d, tps: tps,\n-                    span: ast_util::mk_sp(flo, fhi)}}, p).node\n+        {ident: ident, attrs: attrs, decl: {purity: pur with d}, tps: tps,\n+         span: ast_util::mk_sp(flo, fhi)}\n+    }, p).node\n }\n \n fn parse_mt(p: parser) -> ast::mt {\n@@ -1889,11 +1890,10 @@ fn parse_method_name(p: parser) -> ast::ident {\n \n fn parse_method(p: parser) -> @ast::method {\n     let attrs = parse_outer_attributes(p);\n-    let lo = p.span.lo;\n-    expect_word(p, \"fn\");\n+    let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n     let tps = parse_ty_params(p);\n-    let decl = parse_fn_decl(p, ast::impure_fn);\n+    let decl = parse_fn_decl(p, pur);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n@@ -2109,17 +2109,16 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n+fn parse_fn_purity(p: parser) -> ast::purity {\n+    if eat_word(p, \"fn\") { ast::impure_fn }\n+    else if eat_word(p, \"pure\") { expect_word(p, \"fn\"); ast::pure_fn }\n+    else if eat_word(p, \"unsafe\") { expect_word(p, \"fn\"); ast::unsafe_fn }\n+    else { unexpected(p, p.token); }\n+}\n+\n fn parse_native_item(p: parser, attrs: [ast::attribute]) ->\n    @ast::native_item {\n-    if eat_word(p, \"fn\") {\n-        ret parse_item_native_fn(p, attrs, ast::impure_fn);\n-    } else if eat_word(p, \"pure\") {\n-        expect_word(p, \"fn\");\n-        ret parse_item_native_fn(p, attrs, ast::pure_fn);\n-    } else if eat_word(p, \"unsafe\") {\n-        expect_word(p, \"fn\");\n-        ret parse_item_native_fn(p, attrs, ast::unsafe_fn);\n-    } else { unexpected(p, p.token); }\n+    parse_item_native_fn(p, attrs, parse_fn_purity(p))\n }\n \n fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->"}]}