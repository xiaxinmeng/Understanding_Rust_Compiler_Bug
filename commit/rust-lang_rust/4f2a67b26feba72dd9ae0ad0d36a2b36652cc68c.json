{"sha": "4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "node_id": "C_kwDOAAsO6NoAKDRmMmE2N2IyNmZlYmE3MmRkOWFlMGFkMGQzNmEyYjM2NjUyY2M2OGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-12T14:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-12T14:08:08Z"}, "message": "Auto merge of #12513 - Veykril:ty-utils, r=Veykril\n\ninternal: Simplify `hir_ty::utils`", "tree": {"sha": "ad5423f38275afa1a7631b01e027060e3b521a1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad5423f38275afa1a7631b01e027060e3b521a1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "html_url": "https://github.com/rust-lang/rust/commit/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d513f657a3076ea54ae70714fc44d083b6b801a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d513f657a3076ea54ae70714fc44d083b6b801a6", "html_url": "https://github.com/rust-lang/rust/commit/d513f657a3076ea54ae70714fc44d083b6b801a6"}, {"sha": "9153f17382ff07b3b951657a58b5d1a6c86f2b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/9153f17382ff07b3b951657a58b5d1a6c86f2b10", "html_url": "https://github.com/rust-lang/rust/commit/9153f17382ff07b3b951657a58b5d1a6c86f2b10"}], "stats": {"total": 117, "additions": 48, "deletions": 69}, "files": [{"sha": "f2d8318f7d702381a26dc6700c917de8273ebf7d", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "patch": "@@ -28,7 +28,7 @@ pub struct FunctionData {\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n-    pub legacy_const_generics_indices: Vec<u32>,\n+    pub legacy_const_generics_indices: Box<[u32]>,\n     flags: FnFlags,\n }\n \n@@ -131,7 +131,7 @@ impl FunctionData {\n     }\n }\n \n-fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Vec<u32> {\n+fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Box<[u32]> {\n     let mut indices = Vec::new();\n     for args in tt.token_trees.chunks(2) {\n         match &args[0] {\n@@ -150,7 +150,7 @@ fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Vec<u32> {\n         }\n     }\n \n-    indices\n+    indices.into_boxed_slice()\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "4431d1b3c817eab00269c5f30a9efeff1946d260", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "patch": "@@ -356,8 +356,8 @@ impl From<TypeParamId> for TypeOrConstParamId {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n /// A TypeOrConstParamId with an invariant that it actually belongs to a const\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstParamId(TypeOrConstParamId);\n \n impl ConstParamId {"}, {"sha": "8be236421fb7e5381e9e69d71695f0bd45411bdf", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "patch": "@@ -1211,28 +1211,28 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     /// Returns the argument indices to skip.\n-    fn check_legacy_const_generics(&mut self, callee: Ty, args: &[ExprId]) -> Vec<u32> {\n+    fn check_legacy_const_generics(&mut self, callee: Ty, args: &[ExprId]) -> Box<[u32]> {\n         let (func, subst) = match callee.kind(Interner) {\n             TyKind::FnDef(fn_id, subst) => {\n                 let callable = CallableDefId::from_chalk(self.db, *fn_id);\n                 let func = match callable {\n                     CallableDefId::FunctionId(f) => f,\n-                    _ => return Vec::new(),\n+                    _ => return Default::default(),\n                 };\n                 (func, subst)\n             }\n-            _ => return Vec::new(),\n+            _ => return Default::default(),\n         };\n \n         let data = self.db.function_data(func);\n         if data.legacy_const_generics_indices.is_empty() {\n-            return Vec::new();\n+            return Default::default();\n         }\n \n         // only use legacy const generics if the param count matches with them\n         if data.params.len() + data.legacy_const_generics_indices.len() != args.len() {\n             if args.len() <= data.params.len() {\n-                return Vec::new();\n+                return Default::default();\n             } else {\n                 // there are more parameters than there should be without legacy\n                 // const params; use them"}, {"sha": "e608f8577410853eb7ad5ef9869d0b39b446b076", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 39, "deletions": 60, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=4f2a67b26feba72dd9ae0ad0d36a2b36652cc68c", "patch": "@@ -177,21 +177,19 @@ pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n     if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n         let params = db.generic_params(def);\n-        if params\n-            .type_or_consts\n-            .iter()\n-            .any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)))\n-        {\n+        let has_consts =\n+            params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n+        return if has_consts {\n             // XXX: treat const generic associated types as not existing to avoid crashes (#11769)\n             //\n             // Chalk expects the inner associated type's parameters to come\n             // *before*, not after the trait's generics as we've always done it.\n             // Adapting to this requires a larger refactoring\n             cov_mark::hit!(ignore_gats);\n-            return Generics { def, params: Interned::new(Default::default()), parent_generics };\n+            Generics { def, params: Interned::new(Default::default()), parent_generics }\n         } else {\n-            return Generics { def, params, parent_generics };\n-        }\n+            Generics { def, params, parent_generics }\n+        };\n     }\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n@@ -219,68 +217,46 @@ impl Generics {\n     pub(crate) fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n-        self.parent_generics\n-            .as_ref()\n+        let to_toc_id = |it: &'a Generics| {\n+            move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n+        };\n+        self.parent_generics()\n             .into_iter()\n-            .flat_map(|it| {\n-                it.params\n-                    .iter()\n-                    .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n-            })\n-            .chain(\n-                self.params.iter().map(move |(local_id, p)| {\n-                    (TypeOrConstParamId { parent: self.def, local_id }, p)\n-                }),\n-            )\n+            .flat_map(move |it| it.params.iter().map(to_toc_id(it)))\n+            .chain(self.params.iter().map(to_toc_id(self)))\n     }\n \n     /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n-        self.parent_generics.as_ref().into_iter().flat_map(|it| {\n-            it.params\n-                .type_or_consts\n-                .iter()\n-                .map(move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p))\n+        self.parent_generics().into_iter().flat_map(|it| {\n+            let to_toc_id =\n+                move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n+            it.params.iter().map(to_toc_id)\n         })\n     }\n \n     pub(crate) fn len(&self) -> usize {\n-        self.len_split().0\n-    }\n-\n-    /// (total, parents, child)\n-    pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n-        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n+        let parent = self.parent_generics().map_or(0, Generics::len);\n         let child = self.params.type_or_consts.len();\n-        (parent + child, parent, child)\n+        parent + child\n     }\n \n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n-        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n-        let self_params = self\n-            .params\n-            .iter()\n-            .filter_map(|x| x.1.type_param())\n-            .filter(|p| p.provenance == TypeParamProvenance::TraitSelf)\n-            .count();\n-        let type_params = self\n-            .params\n-            .type_or_consts\n-            .iter()\n-            .filter_map(|x| x.1.type_param())\n-            .filter(|p| p.provenance == TypeParamProvenance::TypeParamList)\n-            .count();\n+        let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n+\n+        let self_params =\n+            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TraitSelf).count();\n+        let type_params =\n+            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TypeParamList).count();\n+        let impl_trait_params =\n+            ty_iter().filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait).count();\n         let const_params = self.params.iter().filter_map(|x| x.1.const_param()).count();\n-        let impl_trait_params = self\n-            .params\n-            .iter()\n-            .filter_map(|x| x.1.type_param())\n-            .filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n-            .count();\n-        (parent, self_params, type_params, const_params, impl_trait_params)\n+\n+        let parent_len = self.parent_generics().map_or(0, Generics::len);\n+        (parent_len, self_params, type_params, const_params, impl_trait_params)\n     }\n \n     pub(crate) fn param_idx(&self, param: TypeOrConstParamId) -> Option<usize> {\n@@ -291,18 +267,21 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n-                .type_or_consts\n                 .iter()\n                 .enumerate()\n                 .find(|(_, (idx, _))| *idx == param.local_id)\n                 .unwrap();\n-            let (_total, parent_len, _child) = self.len_split();\n+            let parent_len = self.parent_generics().map_or(0, Generics::len);\n             Some((parent_len + idx, data))\n         } else {\n-            self.parent_generics.as_ref().and_then(|g| g.find_param(param))\n+            self.parent_generics().and_then(|g| g.find_param(param))\n         }\n     }\n \n+    fn parent_generics(&self) -> Option<&Generics> {\n+        self.parent_generics.as_ref().map(|it| &**it)\n+    }\n+\n     /// Returns a Substitution that replaces each parameter by a bound variable.\n     pub(crate) fn bound_vars_subst(\n         &self,\n@@ -377,10 +356,10 @@ pub fn is_fn_unsafe_to_call(db: &dyn HirDatabase, func: FunctionId) -> bool {\n             // Function in an `extern` block are always unsafe to call, except when it has\n             // `\"rust-intrinsic\"` ABI there are a few exceptions.\n             let id = block.lookup(db.upcast()).id;\n-            match id.item_tree(db.upcast())[id.value].abi.as_deref() {\n-                Some(\"rust-intrinsic\") => is_intrinsic_fn_unsafe(&data.name),\n-                _ => true,\n-            }\n+            !matches!(\n+                id.item_tree(db.upcast())[id.value].abi.as_deref(),\n+                Some(\"rust-intrinsic\") if !is_intrinsic_fn_unsafe(&data.name)\n+            )\n         }\n         _ => false,\n     }"}]}