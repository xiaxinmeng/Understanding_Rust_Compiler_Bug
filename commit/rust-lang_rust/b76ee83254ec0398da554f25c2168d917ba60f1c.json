{"sha": "b76ee83254ec0398da554f25c2168d917ba60f1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NmVlODMyNTRlYzAzOThkYTU1NGYyNWMyMTY4ZDkxN2JhNjBmMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T06:26:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T06:26:21Z"}, "message": "Auto merge of #55859 - pietroalbini:rollup, r=kennytm\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #55630 (resolve: Filter away macro prelude in modules with `#[no_implicit_prelude]` on 2018 edition)\n - #55687 (Take supertraits into account when calculating associated types)\n - #55745 (Convert `outlives_components`' return value to a `SmallVec` outparam.)\n - #55764 (Fix Rc/Arc allocation layout)\n - #55792 (Prevent ICE in const-prop array oob check)\n - #55799 (Removed unneeded instance of `// revisions` from a lint test)\n - #55800 (Fix ICE in `return_type_impl_trait`)\n - #55801 (NLL: Update box insensitivity test)\n - #55802 (Don't inline virtual calls (take 2))\n - #55816 (Use `SmallVec` to avoid allocations in `from_decimal_string`.)\n - #55819 (Typecheck patterns of all match arms first, so we get types for bindings)\n - #55822 (ICE with #![feature(nll)] and elided lifetimes)\n - #55828 (Add missing `rustc_promotable` attribute to unsigned `min_value` and `max_value`)\n - #55839 (Fix docstring spelling mistakes)\n - #55844 (Fix documentation typos.)\n - #55845 (Set BINARYEN_TRAP_MODE=clamp)\n - #55856 (rustdoc: refactor: move all static-file include!s into a single module)", "tree": {"sha": "b2d4ff143f4ceda8c5de52252d5f273aa66e2207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d4ff143f4ceda8c5de52252d5f273aa66e2207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b76ee83254ec0398da554f25c2168d917ba60f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b76ee83254ec0398da554f25c2168d917ba60f1c", "html_url": "https://github.com/rust-lang/rust/commit/b76ee83254ec0398da554f25c2168d917ba60f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b76ee83254ec0398da554f25c2168d917ba60f1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b8f9029762da90a88c8ca6f8ff7690177ec696a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b8f9029762da90a88c8ca6f8ff7690177ec696a", "html_url": "https://github.com/rust-lang/rust/commit/9b8f9029762da90a88c8ca6f8ff7690177ec696a"}, {"sha": "7031e4e7c7b2ab5041aaf9ac54b3bd92169ab908", "url": "https://api.github.com/repos/rust-lang/rust/commits/7031e4e7c7b2ab5041aaf9ac54b3bd92169ab908", "html_url": "https://github.com/rust-lang/rust/commit/7031e4e7c7b2ab5041aaf9ac54b3bd92169ab908"}], "stats": {"total": 1783, "additions": 1117, "deletions": 666}, "files": [{"sha": "2ac51263cb5ca05644dcd816dad2923192b3264f", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -2096,6 +2096,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n+ \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "bb52d7990ff5772fdc27c821ee3c730896af9630", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -672,14 +672,16 @@ impl<T: ?Sized> Rc<T> {\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let (layout, _) = Layout::new::<RcBox<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap();\n+        let layout = Layout::new::<RcBox<()>>()\n+            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n+        debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n         ptr::write(&mut (*inner).weak, Cell::new(1));"}, {"sha": "b63b3684964bb64038366cf6d12365614a99c2a9", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -575,14 +575,16 @@ impl<T: ?Sized> Arc<T> {\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n-        let (layout, _) = Layout::new::<ArcInner<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap();\n+        let layout = Layout::new::<ArcInner<()>>()\n+            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n+        debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n         ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));"}, {"sha": "58639808faedbfc5c3e28fe2e73ad1b0d8cb6838", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -218,6 +218,23 @@ impl Layout {\n         len_rounded_up.wrapping_sub(len)\n     }\n \n+    /// Creates a layout by rounding the size of this layout up to a multiple\n+    /// of the layout's alignment.\n+    ///\n+    /// Returns `Err` if the padded size would overflow.\n+    ///\n+    /// This is equivalent to adding the result of `padding_needed_for`\n+    /// to the layout's current size.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn pad_to_align(&self) -> Result<Layout, LayoutErr> {\n+        let pad = self.padding_needed_for(self.align());\n+        let new_size = self.size().checked_add(pad)\n+            .ok_or(LayoutErr { private: () })?;\n+\n+        Layout::from_size_align(new_size, self.align())\n+    }\n+\n     /// Creates a layout describing the record for `n` instances of\n     /// `self`, with a suitable amount of padding between each to\n     /// ensure that each instance is given its requested size and\n@@ -506,7 +523,7 @@ pub unsafe trait GlobalAlloc {\n         ptr\n     }\n \n-    /// Shink or grow a block of memory to the given `new_size`.\n+    /// Shrink or grow a block of memory to the given `new_size`.\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n     /// If this returns a non-null pointer, then ownership of the memory block\n@@ -757,7 +774,7 @@ pub unsafe trait Alloc {\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n-    /// a new layout with `layout`\u2019s alginment and a size given\n+    /// a new layout with `layout`\u2019s alignment and a size given\n     /// by `new_size`. To\n     /// accomplish this, this may extend or shrink the allocation\n     /// referenced by `ptr` to fit the new layout."}, {"sha": "0c870f9e404a26ca59147ea840bb30760bb16a67", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -17,7 +17,7 @@ use ops;\n use pin::Pin;\n use task::{Poll, LocalWaker};\n \n-/// A future represents an asychronous computation.\n+/// A future represents an asynchronous computation.\n ///\n /// A future is a value that may not have finished computing yet. This kind of\n /// \"asynchronous value\" makes it possible for a thread to continue doing useful"}, {"sha": "c69d4441121ce9d9f6ad72e6403bec7e2929be4a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -228,7 +228,7 @@ mod nonzero;\n mod tuple;\n mod unit;\n \n-// Pull in the the `coresimd` crate directly into libcore. This is where all the\n+// Pull in the `coresimd` crate directly into libcore. This is where all the\n // architecture-specific (and vendor-specific) intrinsics are defined. AKA\n // things like SIMD and such. Note that the actual source for all this lies in a\n // different repository, rust-lang-nursery/stdsimd. That's why the setup here is"}, {"sha": "c008b78e4509292810c8416d293b573bf15773fd", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -350,9 +350,8 @@ macro_rules! try {\n /// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n /// ```\n ///\n-/// Note: This macro can be used in `no_std` setups as well\n-/// In a `no_std` setup you are responsible for the\n-/// implementation details of the components.\n+/// Note: This macro can be used in `no_std` setups as well.\n+/// In a `no_std` setup you are responsible for the implementation details of the components.\n ///\n /// ```no_run\n /// # extern crate core;\n@@ -440,7 +439,7 @@ macro_rules! writeln {\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n /// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n-/// which belongs to the [`std::hint`] module, informs the compilier to\n+/// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///\n /// [`panic!`]:  ../std/macro.panic.html"}, {"sha": "8c4ff02aa140f65afec7d23c05edfee71287d46f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -202,7 +202,7 @@ pub fn forget<T>(t: T) {\n ///\n /// ## Size of Enums\n ///\n-/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n /// on the platform they are compiled for.\n ///\n /// ## Size of Unions\n@@ -1081,7 +1081,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn into_inner(self) -> T {\n@@ -1092,7 +1092,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_ref(&self) -> &T {\n@@ -1103,7 +1103,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {"}, {"sha": "30b7b4546841268750052647cabb30bec85a7ee2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -2152,6 +2152,7 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n             #[inline]\n             pub const fn min_value() -> Self { 0 }\n         }\n@@ -2168,6 +2169,7 @@ Basic usage:\n stringify!($MaxV), \");\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n             #[inline]\n             pub const fn max_value() -> Self { !0 }\n         }"}, {"sha": "308dd9c79fa374391e1e222d379725c3c968f27d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -3,7 +3,7 @@\n //! It is sometimes useful to have objects that are guaranteed to not move,\n //! in the sense that their placement in memory does not change, and can thus be relied upon.\n //!\n-//! A prime example of such a scenario would be building self-referencial structs,\n+//! A prime example of such a scenario would be building self-referential structs,\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n@@ -39,7 +39,7 @@\n //! use std::marker::Pinned;\n //! use std::ptr::NonNull;\n //!\n-//! // This is a self referencial struct since the slice field points to the data field.\n+//! // This is a self-referential struct since the slice field points to the data field.\n //! // We cannot inform the compiler about that with a normal reference,\n //! // since this pattern cannot be described with the usual borrowing rules.\n //! // Instead we use a raw pointer, though one which is known to not be null,"}, {"sha": "827e297c84d1f427918508b885a71395a50884f9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -120,7 +120,7 @@ pub use intrinsics::write_bytes;\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n-/// foo` counts as a use because it will cause the the value to be dropped\n+/// foo` counts as a use because it will cause the value to be dropped\n /// again. [`write`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n@@ -371,7 +371,7 @@ pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n #[inline]\n unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n     // Haswell E processors. LLVM is more able to optimize if we give a struct a\n     // #[repr(simd)], even if we don't actually use this struct directly.\n     //\n@@ -1005,7 +1005,7 @@ impl<T: ?Sized> *const T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```\n@@ -1625,7 +1625,7 @@ impl<T: ?Sized> *mut T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```"}, {"sha": "96590c1fc72d400c8724e663dd39598da5fad024", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -2134,7 +2134,7 @@ static X: u32 = 42;\n \n \n register_diagnostics! {\n-//  E0006 // merged with E0005\n+//  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n //  E0134,\n@@ -2183,9 +2183,7 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-\n     E0697, // closures cannot be static\n-\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with arguments are not currently supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`"}, {"sha": "f57e3ff913b38dd407a7b856fde7093c2281edc4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -506,9 +506,9 @@ pub enum TraitBoundModifier {\n }\n \n /// The AST represents all type param bounds as types.\n-/// typeck::collect::compute_bounds matches these against\n-/// the \"special\" built-in traits (see middle::lang_items) and\n-/// detects Copy, Send and Sync.\n+/// `typeck::collect::compute_bounds` matches these against\n+/// the \"special\" built-in traits (see `middle::lang_items`) and\n+/// detects `Copy`, `Send` and `Sync`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),"}, {"sha": "cc73dd63816aa466b4b75c1eaab89f59e65c120f", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -366,7 +366,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut types = vec![concrete_ty];\n         let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n         while let Some(ty) = types.pop() {\n-            let mut components = self.tcx.outlives_components(ty);\n+            let mut components = smallvec![];\n+            self.tcx.push_outlives_components(ty, &mut components);\n             while let Some(component) = components.pop() {\n                 match component {\n                     Component::Region(r) => {"}, {"sha": "f2825887f36e2d28dae70de54776647af151f6ee", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Code that handles \"type-outlives\" constraints like `T: 'a`. This\n-//! is based on the `outlives_components` function defined on the tcx,\n+//! is based on the `push_outlives_components` function defined on the tcx,\n //! but it adds a bit of heuristics on top, in particular to deal with\n //! associated types and projections.\n //!\n@@ -307,31 +307,32 @@ where\n \n         assert!(!ty.has_escaping_bound_vars());\n \n-        let components = self.tcx.outlives_components(ty);\n-        self.components_must_outlive(origin, components, region);\n+        let mut components = smallvec![];\n+        self.tcx.push_outlives_components(ty, &mut components);\n+        self.components_must_outlive(origin, &components, region);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n-        components: Vec<Component<'tcx>>,\n+        components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n     ) {\n-        for component in components {\n+        for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n                     self.delegate\n                         .push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n-                    self.param_ty_must_outlive(origin, region, param_ty);\n+                    self.param_ty_must_outlive(origin, region, *param_ty);\n                 }\n                 Component::Projection(projection_ty) => {\n-                    self.projection_must_outlive(origin, region, projection_ty);\n+                    self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, subcomponents, region);\n+                    self.components_must_outlive(origin, &subcomponents, region);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error"}, {"sha": "a7a79dd2e6560e6113407cfdb3c1fef2dc9f5971", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -155,7 +155,8 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .map(|subty| self.type_bound(subty))\n             .collect::<Vec<_>>();\n \n-        let mut regions = ty.regions();\n+        let mut regions = smallvec![];\n+        ty.push_regions(&mut regions);\n         regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n         bounds.push(VerifyBound::AllBounds(\n             regions"}, {"sha": "01d87bdbf63374ff4b38e86f077bd8444c38fdfd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -300,12 +300,6 @@ declare_lint! {\n     \"detects labels that are never used\"\n }\n \n-declare_lint! {\n-    pub DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-    Warn,\n-    \"warns about duplicate associated type bindings in generics\"\n-}\n-\n declare_lint! {\n     pub DUPLICATE_MACRO_EXPORTS,\n     Deny,\n@@ -418,7 +412,6 @@ impl LintPass for HardwiredLints {\n             ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n             UNSTABLE_NAME_COLLISIONS,\n             IRREFUTABLE_LET_PATTERNS,\n-            DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             MISSING_DOC_CODE_EXAMPLES,"}, {"sha": "efd7e8b610efc787290e7b977c9e81b95f507951", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -963,6 +963,10 @@ impl Session {\n         self.opts.debugging_opts.teach && self.diagnostic().must_teach(code)\n     }\n \n+    pub fn rust_2015(&self) -> bool {\n+        self.opts.edition == Edition::Edition2015\n+    }\n+\n     /// Are we allowed to use features from the Rust 2018 edition?\n     pub fn rust_2018(&self) -> bool {\n         self.opts.edition >= Edition::Edition2018"}, {"sha": "33b689c60a1188dad35d27597bbe23a67b77ce53", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -50,11 +50,8 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::util::elaborate_predicates;\n-pub use self::util::supertraits;\n-pub use self::util::Supertraits;\n-pub use self::util::supertrait_def_ids;\n-pub use self::util::SupertraitDefIds;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n pub use self::util::transitive_bounds;\n \n #[allow(dead_code)]"}, {"sha": "3a882506b41d6520e90921c0267f3752f75705b4", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -200,8 +200,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 }\n \n                 let visited = &mut self.visited;\n+                let mut components = smallvec![];\n+                tcx.push_outlives_components(ty_max, &mut components);\n                 self.stack.extend(\n-                    tcx.outlives_components(ty_max)\n+                    components\n                        .into_iter()\n                        .filter_map(|component| match component {\n                            Component::Region(r) => if r.is_late_bound() {\n@@ -333,7 +335,7 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx,I:Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {"}, {"sha": "82095a2f5b01de7cc6031f5e068ee7db5e8c4395", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -17,7 +17,7 @@ use session::Session;\n use session::config::{BorrowckMode, OutputFilenames};\n use session::config::CrateType;\n use middle;\n-use hir::{TraitCandidate, HirId, ItemLocalId, Node};\n+use hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use hir::def::{Def, Export};\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n@@ -1602,6 +1602,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n+        // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n+        let node_id = self.hir.as_local_node_id(scope_def_id).unwrap();\n+        match self.hir.get(node_id) {\n+            Node::Item(item) => {\n+                match item.node {\n+                    ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n+                    _ => {\n+                        return None;\n+                    }\n+                }\n+            }\n+            _ => { /* type_of_def_id() will work or panic */ }\n+        }\n+\n         let ret_ty = self.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::FnDef(_, _) => {"}, {"sha": "ef9b3e3efab275f3421c3ea5eb9bcede113efa92", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -294,7 +294,7 @@ impl Visibility {\n         }\n     }\n \n-    /// Returns true if an item with this visibility is accessible from the given block.\n+    /// Returns `true` if an item with this visibility is accessible from the given block.\n     pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n@@ -309,7 +309,7 @@ impl Visibility {\n         tree.is_descendant_of(module, restriction)\n     }\n \n-    /// Returns true if this visibility is at least as accessible as the given visibility\n+    /// Returns `true` if this visibility is at least as accessible as the given visibility\n     pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n@@ -320,7 +320,7 @@ impl Visibility {\n         self.is_accessible_from(vis_restriction, tree)\n     }\n \n-    // Returns true if this item is visible anywhere in the local crate.\n+    // Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -451,7 +451,7 @@ bitflags! {\n         // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9;\n \n-        // true if there are \"names\" of types and regions and so forth\n+        // `true` if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n@@ -544,14 +544,14 @@ impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n             TyKind::Bool |\n-                TyKind::Char |\n-                TyKind::Int(_) |\n-                TyKind::Uint(_) |\n-                TyKind::Float(_) |\n-                TyKind::Infer(InferTy::IntVar(_)) |\n-                TyKind::Infer(InferTy::FloatVar(_)) |\n-                TyKind::Infer(InferTy::FreshIntTy(_)) |\n-                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Char |\n+            TyKind::Int(_) |\n+            TyKind::Uint(_) |\n+            TyKind::Float(_) |\n+            TyKind::Infer(InferTy::IntVar(_)) |\n+            TyKind::Infer(InferTy::FloatVar(_)) |\n+            TyKind::Infer(InferTy::FreshIntTy(_)) |\n+            TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n             TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n@@ -953,7 +953,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .region_param(param, tcx)\n         }\n     }\n@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n@@ -993,6 +993,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n+\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n@@ -1041,15 +1042,15 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n-    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `'a : 'b`\n+    /// where `'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where `T : 'a`\n+    /// where `T: 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n     /// where `<T as TraitRef>::Name == X`, approximately.\n@@ -1062,7 +1063,7 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n     /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n@@ -1111,11 +1112,11 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Let's start with an easy case. Consider two traits:\n         //\n-        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Foo<'a>: Bar<'a,'a> { }\n         //     trait Bar<'b,'c> { }\n         //\n-        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // Now, if we have a trait reference `for<'x> T: Foo<'x>`, then\n+        // we can deduce that `for<'x> T: Bar<'x,'x>`. Basically, if we\n         // knew that `Foo<'x>` (for any 'x) then we also know that\n         // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n         // normal substitution.\n@@ -1128,21 +1129,21 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Another example to be careful of is this:\n         //\n-        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Foo1<'a>: for<'b> Bar1<'a,'b> { }\n         //     trait Bar1<'b,'c> { }\n         //\n-        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n         // To achieve this in practice is fairly straightforward. Let's\n         // consider the more complicated scenario:\n         //\n-        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        // - We start out with `for<'x> T: Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T: Bar1<'x,'b>`,\n         //   where both `'x` and `'b` would have a DB index of 1.\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n@@ -1194,6 +1195,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n+\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n@@ -1218,7 +1220,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n                                                            ty::Region<'tcx>>;\n@@ -1238,11 +1240,11 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n-/// 1. `T : TraitRef<..., Item=Type>`\n+/// 1. `T: TraitRef<..., Item=Type>`\n /// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n ///\n /// In particular, form #1 is \"desugared\" to the combination of a\n-/// normal trait predicate (`T : TraitRef<...>`) and one of these\n+/// normal trait predicate (`T: TraitRef<...>`) and one of these\n /// predicates. Form #2 is a broader form in that it also permits\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n@@ -1256,14 +1258,14 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the def-id of the associated item being projected.\n+    /// Returns the `DefId` of the associated item being projected.\n     pub fn item_def_id(&self) -> DefId {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n     pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n-        // Note: unlike with TraitRef::to_poly_trait_ref(),\n-        // self.0.trait_ref is permitted to have escaping regions.\n+        // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n+        // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n@@ -1274,12 +1276,12 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n-    /// The DefId of the TraitItem for the associated type.\n+    /// The `DefId` of the `TraitItem` for the associated type.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(projection_def_id()).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // okay to skip binder since trait def-id does not care about regions\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1515,14 +1517,14 @@ impl UniverseIndex {\n         UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n     }\n \n-    /// True if `self` can name a name from `other` -- in other words,\n+    /// Returns `true` if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n     /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n \n-    /// True if `self` cannot name some names from `other` -- in other\n+    /// Returns `true` if `self` cannot name some names from `other` -- in other\n     /// words, if the set of names in `self` is a strict subset of\n     /// those in `other` (`self < other`).\n     pub fn cannot_name(self, other: UniverseIndex) -> bool {\n@@ -1574,7 +1576,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n         Self::new(List::empty(), Reveal::All)\n@@ -1979,14 +1981,14 @@ impl ReprOptions {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n \n-    /// Returns true if this `#[repr()]` should inhabit \"smart enum\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n     /// layout\" optimizations, such as representing `Foo<&T>` as a\n     /// single pointer.\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n         self.c() || self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit struct field reordering\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with repr(C) or repr(packed(1)).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n@@ -2089,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns true if this is PhantomData<T>.\n+    /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n@@ -2105,7 +2107,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_RC)\n     }\n \n-    /// Returns true if this is Box<T>.\n+    /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_BOX)\n@@ -2422,7 +2424,7 @@ impl<'a, 'tcx> ClosureKind {\n         }\n     }\n \n-    /// True if this a type that impls this closure kind\n+    /// Returns `true` if this a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n         match (self, other) {\n@@ -2475,7 +2477,7 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n     pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-        where F : FnMut(Ty<'tcx>) -> bool\n+        where F: FnMut(Ty<'tcx>) -> bool\n     {\n         let mut walker = self.walk();\n         while let Some(ty) = walker.next() {\n@@ -2678,7 +2680,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n-    /// Returns true if the impls are the same polarity and the trait either\n+    /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated #[marker] and prevents item overrides.\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n         if self.features().overlapping_marker_traits {\n@@ -2802,7 +2804,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n-    /// Returns true if this is an `auto trait`.\n+    /// Returns `true` if this is an `auto trait`.\n     pub fn trait_is_auto(self, trait_def_id: DefId) -> bool {\n         self.trait_def(trait_def_id).has_auto_impl\n     }"}, {"sha": "7fac88a3d78f1855b97371e8dd793adf88572625", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -12,6 +12,7 @@\n // refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n // RFC for reference.\n \n+use smallvec::SmallVec;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n@@ -55,17 +56,15 @@ pub enum Component<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns all the things that must outlive `'a` for the condition\n+    /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n-    pub fn outlives_components(&self, ty0: Ty<'tcx>)\n-                               -> Vec<Component<'tcx>> {\n-        let mut components = vec![];\n-        self.compute_components(ty0, &mut components);\n-        debug!(\"components({:?}) = {:?}\", ty0, components);\n-        components\n+    pub fn push_outlives_components(&self, ty0: Ty<'tcx>,\n+                                    out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+        self.compute_components(ty0, out);\n+        debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n \n-    fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n+    fn compute_components(&self, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n         // Descend through the types, looking for the various \"base\"\n         // components and collecting them into `out`. This is not written\n         // with `collect()` because of the need to sometimes skip subtrees\n@@ -164,7 +163,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n \n-                push_region_constraints(out, ty.regions());\n+                push_region_constraints(ty, out);\n                 for subty in ty.walk_shallow() {\n                     self.compute_components(subty, out);\n                 }\n@@ -173,15 +172,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n-        let mut temp = vec![];\n-        push_region_constraints(&mut temp, ty.regions());\n+        let mut temp = smallvec![];\n+        push_region_constraints(ty, &mut temp);\n         for subty in ty.walk_shallow() {\n             self.compute_components(subty, &mut temp);\n         }\n-        temp\n+        temp.into_iter().collect()\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n+fn push_region_constraints<'tcx>(ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+    let mut regions = smallvec![];\n+    ty.push_regions(&mut regions);\n     out.extend(regions.iter().filter(|&r| !r.is_late_bound()).map(|r| Component::Region(r)));\n }"}, {"sha": "a4130bf15cb8272f2bd726ae061b5f758a03a042", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -22,6 +22,7 @@ use ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer};\n \n+use smallvec::SmallVec;\n use std::iter;\n use std::cmp::Ordering;\n use rustc_target::spec::abi;\n@@ -627,7 +628,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n-///     T : Foo<U>\n+///     T: Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n /// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n@@ -637,8 +638,8 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// that case the `Self` parameter is absent from the substitutions.\n ///\n /// Note that a `TraitRef` introduces a level of region binding, to\n-/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n-/// U>` or higher-ranked object types.\n+/// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n+/// or higher-ranked object types.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -663,7 +664,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -886,16 +887,16 @@ pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The DefId of the TraitItem for the associated type N.\n+    /// The `DefId` of the `TraitItem` for the associated type `N`.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(item_def_id).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(item_def_id).container`.\n     pub item_def_id: DefId,\n }\n \n impl<'a, 'tcx> ProjectionTy<'tcx> {\n-    /// Construct a ProjectionTy by searching the trait from trait_ref for the\n-    /// associated item named item_name.\n+    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n+    /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n         tcx: TyCtxt<'_, '_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n     ) -> ProjectionTy<'tcx> {\n@@ -1846,28 +1847,27 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Returns the regions directly referenced from this type (but\n-    /// not types reachable from this type via `walk_tys`). This\n-    /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n+    /// Push onto `out` the regions directly referenced from this type (but not\n+    /// types reachable from this type via `walk_tys`). This ignores late-bound\n+    /// regions binders.\n+    pub fn push_regions(&self, out: &mut SmallVec<[ty::Region<'tcx>; 4]>) {\n         match self.sty {\n             Ref(region, _, _) => {\n-                vec![region]\n+                out.push(region);\n             }\n             Dynamic(ref obj, region) => {\n-                let mut v = vec![region];\n-                v.extend(obj.principal().skip_binder().substs.regions());\n-                v\n+                out.push(region);\n+                out.extend(obj.principal().skip_binder().substs.regions());\n             }\n             Adt(_, substs) | Opaque(_, substs) => {\n-                substs.regions().collect()\n+                out.extend(substs.regions())\n             }\n             Closure(_, ClosureSubsts { ref substs }) |\n             Generator(_, GeneratorSubsts { ref substs }, _) => {\n-                substs.regions().collect()\n+                out.extend(substs.regions())\n             }\n             Projection(ref data) | UnnormalizedProjection(ref data) => {\n-                data.substs.regions().collect()\n+                out.extend(data.substs.regions())\n             }\n             FnDef(..) |\n             FnPtr(_) |\n@@ -1887,9 +1887,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             Param(_) |\n             Bound(..) |\n             Infer(_) |\n-            Error => {\n-                vec![]\n-            }\n+            Error => {}\n         }\n     }\n "}, {"sha": "b28e7c9fb199be7daaacce299e889784c7375078", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -27,7 +27,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n \n-/// An entity in the Rust typesystem, which can be one of\n+/// An entity in the Rust type system, which can be one of\n /// several kinds (only types and lifetimes for now).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n@@ -171,17 +171,17 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    /// Creates a Substs that maps each generic parameter to itself.\n+    /// Creates a `Substs` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n         Substs::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n     }\n \n-    /// Creates a Substs for generic parameter definitions,\n+    /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n-    /// The closures get to observe the Substs as they're\n+    /// The closures get to observe the `Substs` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Type(ty) = k.unpack() {\n                 Some(ty)\n@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item = ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Lifetime(lt) = k.unpack() {\n                 Some(lt)\n@@ -332,7 +332,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> : Sized {\n+pub trait Subst<'tcx>: Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)"}, {"sha": "a8a5da90c7a6bb41418cb0b5cf20447eca1fff38", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -10,3 +10,4 @@ path = \"lib.rs\"\n [dependencies]\n bitflags = \"1.0\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n+smallvec = { version = \"0.6.5\", features = [\"union\"] }"}, {"sha": "4f405858e350ce8269b9fba6dfe8512f2f6474ed", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -11,6 +11,7 @@\n use {Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use {Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n+use smallvec::{SmallVec, smallvec};\n use std::cmp::{self, Ordering};\n use std::convert::TryFrom;\n use std::fmt::{self, Write};\n@@ -1962,7 +1963,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         // to hold the full significand, and an extra limb required by\n         // tcMultiplyPart.\n         let max_limbs = limbs_for_bits(1 + 196 * significand_digits / 59);\n-        let mut dec_sig = Vec::with_capacity(max_limbs);\n+        let mut dec_sig: SmallVec<[Limb; 1]> = SmallVec::with_capacity(max_limbs);\n \n         // Convert to binary efficiently - we do almost all multiplication\n         // in a Limb. When this would overflow do we do a single\n@@ -2021,11 +2022,11 @@ impl<S: Semantics> IeeeFloat<S> {\n \n             const FIRST_EIGHT_POWERS: [Limb; 8] = [1, 5, 25, 125, 625, 3125, 15625, 78125];\n \n-            let mut p5_scratch = vec![];\n-            let mut p5 = vec![FIRST_EIGHT_POWERS[4]];\n+            let mut p5_scratch = smallvec![];\n+            let mut p5: SmallVec<[Limb; 1]> = smallvec![FIRST_EIGHT_POWERS[4]];\n \n-            let mut r_scratch = vec![];\n-            let mut r = vec![FIRST_EIGHT_POWERS[power & 7]];\n+            let mut r_scratch = smallvec![];\n+            let mut r: SmallVec<[Limb; 1]> = smallvec![FIRST_EIGHT_POWERS[power & 7]];\n             power >>= 3;\n \n             while power > 0 {\n@@ -2064,7 +2065,7 @@ impl<S: Semantics> IeeeFloat<S> {\n             let calc_precision = (LIMB_BITS << attempt) - 1;\n             attempt += 1;\n \n-            let calc_normal_from_limbs = |sig: &mut Vec<Limb>,\n+            let calc_normal_from_limbs = |sig: &mut SmallVec<[Limb; 1]>,\n                                           limbs: &[Limb]|\n              -> StatusAnd<ExpInt> {\n                 sig.resize(limbs_for_bits(calc_precision), 0);"}, {"sha": "69c9f385409e4a268a1c0d17a39233e64c39bdbf", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -53,6 +53,7 @@ extern crate rustc_cratesio_shim;\n \n #[macro_use]\n extern crate bitflags;\n+extern crate smallvec;\n \n use std::cmp::Ordering;\n use std::fmt;"}, {"sha": "8c0e9bd11a173da5813c13157f8244af22204632", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -317,11 +317,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n             edition: None,\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(DUPLICATE_ASSOCIATED_TYPE_BINDINGS),\n-            reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n-            edition: None,\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n             reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\","}, {"sha": "a32fb0503a814e6ba74f7e65f3134091de8eded8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -687,22 +687,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) =\n-            if let hir::ExprKind::Closure(_, _, _, span, gen_move) =\n-                tcx.hir.expect_expr(mir_node_id).node\n-            {\n-                (\n-                    tcx.sess.source_map().end_point(span),\n-                    if gen_move.is_some() {\n-                        \" of generator\"\n-                    } else {\n-                        \" of closure\"\n-                    },\n-                )\n-            } else {\n-                // unreachable?\n-                (mir.span, \"\")\n-            };\n+        let (return_span, mir_description) = match tcx.hir.get(mir_node_id) {\n+            hir::Node::Expr(hir::Expr {\n+                node: hir::ExprKind::Closure(_, _, _, span, gen_move),\n+                ..\n+            }) => (\n+                tcx.sess.source_map().end_point(*span),\n+                if gen_move.is_some() {\n+                    \" of generator\"\n+                } else {\n+                    \" of closure\"\n+                },\n+            ),\n+            hir::Node::ImplItem(hir::ImplItem {\n+                node: hir::ImplItemKind::Method(method_sig, _),\n+                ..\n+            }) => (method_sig.decl.output.span(), \"\"),\n+            _ => (mir.span, \"\"),\n+        };\n \n         Some(RegionName {\n             // This counter value will already have been used, so this function will increment it"}, {"sha": "98311444e28718d3b24aef07a04d92ba9a221e22", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -37,6 +37,7 @@ use rustc::mir::{BasicBlock, FakeReadCause, Local, Location, Mir, Place};\n use rustc::mir::{Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n use rustc::ty::{Ty, RegionKind, TyCtxt};\n+use smallvec::smallvec;\n use transform::{MirPass, MirSource};\n \n pub struct CleanEndRegions;\n@@ -80,7 +81,11 @@ impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n \n     fn visit_ty(&mut self, ty: &Ty<'tcx>, _: TyContext) {\n         // Gather regions that occur in types\n-        for re in ty.walk().flat_map(|t| t.regions()) {\n+        let mut regions = smallvec![];\n+        for t in ty.walk() {\n+            t.push_regions(&mut regions);\n+        }\n+        for re in regions {\n             match *re {\n                 RegionKind::ReScope(ce) => { self.seen_regions.insert(ce); }\n                 _ => {},"}, {"sha": "885d70dc4304dee3e3cd02c3118df7555aab58b6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -591,8 +591,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = Immediate::Scalar(Scalar::from_bool(*expected).into());\n-                if expected != value.0.to_immediate() {\n+                let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                if expected != self.ecx.read_scalar(value.0).unwrap() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -628,20 +628,20 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match len.0.to_immediate() {\n-                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                            let len = match self.ecx.read_scalar(len.0) {\n+                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n-                                _ => bug!(\"const len not primitive: {:?}\", len),\n+                                other => bug!(\"const len not primitive: {:?}\", other),\n                             };\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match index.0.to_immediate() {\n-                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                            let index = match self.ecx.read_scalar(index.0) {\n+                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n-                                _ => bug!(\"const index not primitive: {:?}\", index),\n+                                other => bug!(\"const index not primitive: {:?}\", other),\n                             };\n                             format!(\n                                 \"index out of bounds: \\"}, {"sha": "1cce0de5152fda7bd649b1b92c80235f9a2958d6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, InstanceDef, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -85,39 +85,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir.as_local_node_id(self.source.def_id).unwrap();\n         let body_owner_kind = self.tcx.hir.body_owner_kind(id);\n+\n         if let (hir::BodyOwnerKind::Fn, None) = (body_owner_kind, self.source.promoted) {\n \n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n-                // Don't inline calls that are in cleanup blocks.\n-                if bb_data.is_cleanup { continue; }\n-\n-                // Only consider direct calls to functions\n-                let terminator = bb_data.terminator();\n-                if let TerminatorKind::Call {\n-                    func: ref op, .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n-                            if let Some(instance) = Instance::resolve(self.tcx,\n-                                                                      param_env,\n-                                                                      callee_def_id,\n-                                                                      substs) {\n-                                let is_virtual =\n-                                    if let InstanceDef::Virtual(..) = instance.def {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                if !is_virtual {\n-                                    callsites.push_back(CallSite {\n-                                        callee: instance.def_id(),\n-                                        substs: instance.substs,\n-                                        bb,\n-                                        location: terminator.source_info\n-                                    });\n-                                }\n-                            }\n-                        }\n-                    }\n+                if let Some(callsite) = self.get_valid_function_call(bb,\n+                                                                     bb_data,\n+                                                                     caller_mir,\n+                                                                     param_env) {\n+                    callsites.push_back(callsite);\n+                }\n             }\n         } else {\n             return;\n@@ -163,20 +140,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n-                    // Only consider direct calls to functions\n-                    let terminator = bb_data.terminator();\n-                    if let TerminatorKind::Call {\n-                        func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n-                            // Don't inline the same function multiple times.\n-                            if callsite.callee != callee_def_id {\n-                                callsites.push_back(CallSite {\n-                                    callee: callee_def_id,\n-                                    substs,\n-                                    bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n+                    if let Some(new_callsite) = self.get_valid_function_call(bb,\n+                                                                             bb_data,\n+                                                                             caller_mir,\n+                                                                             param_env) {\n+                        // Don't inline the same function multiple times.\n+                        if callsite.callee != new_callsite.callee {\n+                            callsites.push_back(new_callsite);\n                         }\n                     }\n                 }\n@@ -198,6 +168,40 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n+    fn get_valid_function_call(&self,\n+                               bb: BasicBlock,\n+                               bb_data: &BasicBlockData<'tcx>,\n+                               caller_mir: &Mir<'tcx>,\n+                               param_env: ParamEnv<'tcx>,\n+    ) -> Option<CallSite<'tcx>> {\n+        // Don't inline calls that are in cleanup blocks.\n+        if bb_data.is_cleanup { return None; }\n+\n+        // Only consider direct calls to functions\n+        let terminator = bb_data.terminator();\n+        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n+                let instance = Instance::resolve(self.tcx,\n+                                                 param_env,\n+                                                 callee_def_id,\n+                                                 substs)?;\n+\n+                if let InstanceDef::Virtual(..) = instance.def {\n+                    return None;\n+                }\n+\n+                return Some(CallSite {\n+                    callee: instance.def_id(),\n+                    substs: instance.substs,\n+                    bb,\n+                    location: terminator.source_info\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n                            callee_mir: &Mir<'tcx>)"}, {"sha": "db5b516e7b23b4c3fe5441a8876098b5e51177d7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -663,10 +663,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n-                        None => Err(Determinacy::Determined),\n+                    let mut result = Err(Determinacy::Determined);\n+                    if use_prelude || self.session.rust_2015() {\n+                        if let Some(binding) = self.macro_use_prelude.get(&ident.name).cloned() {\n+                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                        }\n                     }\n+                    result\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n@@ -685,7 +688,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::LegacyPluginHelpers => {\n-                    if self.session.plugin_attributes.borrow().iter()\n+                    if (use_prelude || self.session.rust_2015()) &&\n+                       self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, ident.span, Mark::root())"}, {"sha": "2c80f3b4b3b02c68da0f9670601f9f8191ae5c9b", "filename": "src/librustc_target/spec/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_emscripten.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -11,12 +11,18 @@\n use super::{LinkArgs, LinkerFlavor, Target, TargetOptions};\n \n pub fn target() -> Result<Target, String> {\n+    // FIXME(nikic) BINARYEN_TRAP_MODE=clamp is needed to avoid trapping in our\n+    // -Zsaturating-float-casts implementation. This can be dropped if/when\n+    // we have native fpto[su]i.sat intrinsics, or the implementation otherwise\n+    // stops relying on non-trapping fpto[su]i.\n     let mut post_link_args = LinkArgs::new();\n     post_link_args.insert(LinkerFlavor::Em,\n                           vec![\"-s\".to_string(),\n                                \"BINARYEN=1\".to_string(),\n                                \"-s\".to_string(),\n-                               \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string()]);\n+                               \"ERROR_ON_UNDEFINED_SYMBOLS=1\".to_string(),\n+                               \"-s\".to_string(),\n+                               \"BINARYEN_TRAP_MODE='clamp'\".to_string()]);\n \n     let opts = TargetOptions {\n         dynamic_linking: false,"}, {"sha": "7514c2c18e7ca8f77aec0fbe7fcd15be28e12c8a", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::wf;\n+use smallvec::{SmallVec, smallvec};\n use syntax::ast::DUMMY_NODE_ID;\n use syntax::source_map::DUMMY_SP;\n use rustc::traits::FulfillmentContext;\n@@ -133,7 +134,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                        let components = tcx.outlives_components(ty_a);\n+                        let mut components = smallvec![];\n+                        tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)\n                     }\n                 },\n@@ -155,7 +157,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n /// those relationships.\n fn implied_bounds_from_components(\n     sub_region: ty::Region<'tcx>,\n-    sup_components: Vec<Component<'tcx>>,\n+    sup_components: SmallVec<[Component<'tcx>; 4]>,\n ) -> Vec<OutlivesBound<'tcx>> {\n     sup_components\n         .into_iter()"}, {"sha": "572e79407a10be41586bc8b9d38d5aeb33de66a6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -37,7 +37,7 @@ use std::iter;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -451,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n \n         // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n+        // methods in `subst.rs` so that we can iterate over the arguments and\n         // parameters in lock-step linearly, rather than trying to match each pair.\n         let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n@@ -469,7 +469,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n \n-            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n             if has_self {\n                 if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n@@ -698,7 +698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n-    /// Get the DefId of the given trait ref. It _must_ actually be a trait.\n+    /// Get the `DefId` of the given trait ref. It _must_ actually be a trait.\n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n         match path.def {\n@@ -711,7 +711,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// The given `trait_ref` must actually be trait.\n+    /// The given trait ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n@@ -738,7 +738,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // ok to ignore Err because ErrorReported (see above)\n+            // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n@@ -831,15 +831,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         if !speculative {\n-            // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+            // Given something like `U: SomeTrait<T = X>`, we want to produce a\n             // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n             // subtle in the event that `T` is defined in a supertrait of\n             // `SomeTrait`, because in that case we need to upcast.\n             //\n             // That is, consider this case:\n             //\n             // ```\n-            // trait SubTrait : SuperTrait<int> { }\n+            // trait SubTrait: SuperTrait<int> { }\n             // trait SuperTrait<A> { type T; }\n             //\n             // ... B : SubTrait<T=foo> ...\n@@ -908,16 +908,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !speculative {\n             dup_bindings.entry(assoc_ty.def_id)\n                 .and_modify(|prev_span| {\n-                    let mut err = self.tcx().struct_span_lint_node(\n-                        ::rustc::lint::builtin::DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-                        ref_id,\n-                        binding.span,\n-                        &format!(\"associated type binding `{}` specified more than once\",\n-                                 binding.item_name)\n-                    );\n-                    err.span_label(binding.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", binding.item_name));\n-                    err.emit();\n+                    struct_span_err!(self.tcx().sess, binding.span, E0719,\n+                                     \"the value of the associated type `{}` (from the trait `{}`) \\\n+                                      is already specified\",\n+                                     binding.item_name,\n+                                     tcx.item_path_str(assoc_ty.container.id()))\n+                        .span_label(binding.span, \"re-bound here\")\n+                        .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n+                        .emit();\n                 })\n                 .or_insert(binding.span);\n         }\n@@ -969,7 +967,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut projection_bounds = vec![];\n+        let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n@@ -994,23 +992,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n-        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n-        let existential_principal = principal.map_bound(|trait_ref| {\n-            self.trait_ref_to_existential(trait_ref)\n-        });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|b| {\n-                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n-                }\n-            })\n-        });\n-\n         // Check that there are no gross object safety violations;\n-        // most importantly, that the supertraits don't contain Self,\n+        // most importantly, that the supertraits don't contain `Self`,\n         // to avoid ICEs.\n         let object_safety_violations =\n             tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n@@ -1021,13 +1004,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        // Use a BTreeSet to keep output in a more consistent order.\n+        // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        for tr in traits::supertraits(tcx, principal) {\n-            associated_types.extend(tcx.associated_items(tr.def_id())\n-                .filter(|item| item.kind == ty::AssociatedKind::Type)\n-                .map(|item| item.def_id));\n+        for tr in traits::elaborate_trait_ref(tcx, principal) {\n+            match tr {\n+                ty::Predicate::Trait(pred) => {\n+                    associated_types.extend(tcx.associated_items(pred.def_id())\n+                                    .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                                    .map(|item| item.def_id));\n+                }\n+                ty::Predicate::Projection(pred) => {\n+                    // Include projections defined on supertraits.\n+                    projection_bounds.push((pred, DUMMY_SP))\n+                }\n+                _ => ()\n+            }\n         }\n \n         for (projection_bound, _) in &projection_bounds {\n@@ -1046,11 +1038,26 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n+        // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            self.trait_ref_to_existential(trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+            bound.map_bound(|b| {\n+                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n+                ty::ExistentialProjection {\n+                    ty: b.ty,\n+                    item_def_id: b.projection_ty.item_def_id,\n+                    substs: trait_ref.substs,\n+                }\n+            })\n+        });\n+\n         // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n         auto_traits.sort();\n         auto_traits.dedup();\n \n-        // skip_binder is okay, because the predicates are re-bound.\n+        // Calling `skip_binder` is okay, because the predicates are re-bound.\n         let mut v =\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n@@ -1128,8 +1135,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                       span)\n     }\n \n-\n-    // Checks that bounds contains exactly one element and reports appropriate\n+    // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n                                    mut bounds: I,\n@@ -1186,11 +1192,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Create a type from a path to an associated type.\n-    // For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n-    // and item_segment is the path segment for D. We return a type and a def for\n+    // For a path `A::B::C::D`, `ty` and `ty_path_def` are the type and def for `A::B::C`\n+    // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n-    // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n-    // parameter or Self.\n+    // Will fail except for `T::A` and `Self::A`; i.e., if `ty`/`ty_path_def` are not a type\n+    // parameter or `Self`.\n     pub fn associated_path_def_to_ty(&self,\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n@@ -1210,7 +1216,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait - we have a concrete self type and a\n+                // `Self` in an impl of a trait - we have a concrete `self` type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1361,7 +1367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let span = path.span;\n         match path.def {\n             Def::Existential(did) => {\n-                // check for desugared impl trait\n+                // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1398,15 +1404,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n-                // Self in impl (we know the concrete type).\n+                // `Self` in impl (we know the concrete type)\n \n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n-                // Self in trait.\n+                // `Self` in trait\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()"}, {"sha": "a477df6ae2d568e4d296876c7a9fd0c91a442612", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -626,9 +626,9 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let discrim_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n-        // Typecheck the patterns first, so that we get types for all the\n-        // bindings.\n-        let all_arm_pats_diverge = arms.iter().map(|arm| {\n+        // rust-lang/rust#55810: Typecheck patterns first (via eager\n+        // collection into `Vec`), so we get types for all bindings.\n+        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n@@ -644,7 +644,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 Diverges::Maybe => Diverges::Maybe,\n                 Diverges::Always | Diverges::WarnedAlways => Diverges::WarnedAlways,\n             }\n-        });\n+        }).collect();\n \n         // Now typecheck the blocks.\n         //"}, {"sha": "8574443190d7c7a2d6a70f8737e3b1b7565de272", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -28,9 +28,9 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-/// Helper type of a temporary returned by .for_item(...).\n+/// Helper type of a temporary returned by `.for_item(...)`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     id: ast::NodeId,\n@@ -186,6 +186,8 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item_id: ast::NodeId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n+    debug!(\"check_associated_item: {:?}\", item_id);\n+\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n@@ -311,6 +313,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    debug!(\"check_trait: {:?}\", item.id);\n+\n     let trait_def_id = tcx.hir.local_def_id(item.id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n@@ -1012,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             None => {\n-                // Inherent impl: take implied bounds from the self type.\n+                // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]"}, {"sha": "d5f5cbb562e78514581bea80c91fc6e1237add51", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -1978,18 +1978,18 @@ pub enum SizedByDefault {\n     No,\n }\n \n-/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n-/// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n-/// built-in trait (formerly known as kind): Send.\n+/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n+/// or a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n+/// built-in trait `Send`.\n pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     astconv: &dyn AstConv<'gcx, 'tcx>,\n     param_ty: Ty<'tcx>,\n     ast_bounds: &[hir::GenericBound],\n     sized_by_default: SizedByDefault,\n     span: Span,\n ) -> Bounds<'tcx> {\n-    let mut region_bounds = vec![];\n-    let mut trait_bounds = vec![];\n+    let mut region_bounds = Vec::new();\n+    let mut trait_bounds = Vec::new();\n \n     for ast_bound in ast_bounds {\n         match *ast_bound {\n@@ -1999,7 +1999,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n         }\n     }\n \n-    let mut projection_bounds = vec![];\n+    let mut projection_bounds = Vec::new();\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n         (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)"}, {"sha": "a985c3e9fdf449bfc8b57664c867ef065d1025f6", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -4909,4 +4909,5 @@ register_diagnostics! {\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n     E0698, // type inside generator must be known in this context\n+    E0719, // duplicate values for associated type binding\n }"}, {"sha": "6ed59837eb49a2c23a709491a25918c5e49d4c03", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -11,6 +11,7 @@\n use rustc::ty::outlives::Component;\n use rustc::ty::subst::{Kind, UnpackedKind};\n use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n+use smallvec::smallvec;\n use std::collections::BTreeSet;\n \n /// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n@@ -40,7 +41,9 @@ pub fn insert_outlives_predicate<'tcx>(\n             //\n             // Or if within `struct Foo<U>` you had `T = Vec<U>`, then\n             // we would want to add `U: 'outlived_region`\n-            for component in tcx.outlives_components(ty) {\n+            let mut components = smallvec![];\n+            tcx.push_outlives_components(ty, &mut components);\n+            for component in components {\n                 match component {\n                     Component::Region(r) => {\n                         // This would arise from something like:"}, {"sha": "7dafe67485a6e92d86f2972fb34571a874a8aeec", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -29,6 +29,7 @@ use core::new_handler;\n use externalfiles::ExternalHtml;\n use html;\n use html::markdown::IdMap;\n+use html::static_files;\n use opts;\n use passes::{self, DefaultPassOption};\n use theme;\n@@ -261,7 +262,7 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"theme-checker\");\n         if !to_check.is_empty() {\n-            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n             let mut errors = 0;\n \n             println!(\"rustdoc: [theme-checker] Starting tests!\");\n@@ -338,7 +339,7 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"themes\") {\n-            let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n+            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n \n             for (theme_file, theme_s) in matches.opt_strs(\"themes\")\n                                                 .iter()"}, {"sha": "f560350d5105d6298de6fada8d39894894cd1ca0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -76,7 +76,7 @@ use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n-use html::{highlight, layout};\n+use html::{highlight, layout, static_files};\n \n use minifier;\n \n@@ -767,10 +767,10 @@ fn write_shared(\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n     write_minify(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/rustdoc.css\"),\n+                 static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/settings.css\"),\n+                 static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n \n     // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n@@ -790,15 +790,15 @@ fn write_shared(\n     }\n \n     write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n-          include_bytes!(\"static/brush.svg\"))?;\n+          static_files::BRUSH_SVG)?;\n     write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n-          include_bytes!(\"static/wheel.svg\"))?;\n+          static_files::WHEEL_SVG)?;\n     write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/themes/light.css\"),\n+                 static_files::themes::LIGHT,\n                  options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n     write_minify(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/themes/dark.css\"),\n+                 static_files::themes::DARK,\n                  options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n \n@@ -854,16 +854,16 @@ themePicker.onblur = handleThemeButtonsBlur;\n     )?;\n \n     write_minify(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/main.js\"),\n+                 static_files::MAIN_JS,\n                  options.enable_minification)?;\n     write_minify(cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/settings.js\"),\n+                 static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n \n     {\n         let mut data = format!(\"var resourcesSuffix = \\\"{}\\\";\\n\",\n                                cx.shared.resource_suffix);\n-        data.push_str(include_str!(\"static/storage.js\"));\n+        data.push_str(static_files::STORAGE_JS);\n         write_minify(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n                      &data,\n                      options.enable_minification)?;\n@@ -882,36 +882,36 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n     }\n     write_minify(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n-                 include_str!(\"static/normalize.css\"),\n+                 static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-          include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n+          static_files::fira_sans::REGULAR)?;\n     write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-          include_bytes!(\"static/FiraSans-Medium.woff\"))?;\n+          static_files::fira_sans::MEDIUM)?;\n     write(cx.dst.join(\"FiraSans-LICENSE.txt\"),\n-          include_bytes!(\"static/FiraSans-LICENSE.txt\"))?;\n+          static_files::fira_sans::LICENSE)?;\n     write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-          include_bytes!(\"static/Heuristica-Italic.woff\"))?;\n+          static_files::heuristica::ITALIC)?;\n     write(cx.dst.join(\"Heuristica-LICENSE.txt\"),\n-          include_bytes!(\"static/Heuristica-LICENSE.txt\"))?;\n+          static_files::heuristica::LICENSE)?;\n     write(cx.dst.join(\"SourceSerifPro-Regular.woff\"),\n-          include_bytes!(\"static/SourceSerifPro-Regular.woff\"))?;\n+          static_files::source_serif_pro::REGULAR)?;\n     write(cx.dst.join(\"SourceSerifPro-Bold.woff\"),\n-          include_bytes!(\"static/SourceSerifPro-Bold.woff\"))?;\n+          static_files::source_serif_pro::BOLD)?;\n     write(cx.dst.join(\"SourceSerifPro-LICENSE.txt\"),\n-          include_bytes!(\"static/SourceSerifPro-LICENSE.txt\"))?;\n+          static_files::source_serif_pro::LICENSE)?;\n     write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n-          include_bytes!(\"static/SourceCodePro-Regular.woff\"))?;\n+          static_files::source_code_pro::REGULAR)?;\n     write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n-          include_bytes!(\"static/SourceCodePro-Semibold.woff\"))?;\n+          static_files::source_code_pro::SEMIBOLD)?;\n     write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n-          include_bytes!(\"static/SourceCodePro-LICENSE.txt\"))?;\n+          static_files::source_code_pro::LICENSE)?;\n     write(cx.dst.join(\"LICENSE-MIT.txt\"),\n-          include_bytes!(\"static/LICENSE-MIT.txt\"))?;\n+          static_files::LICENSE_MIT)?;\n     write(cx.dst.join(\"LICENSE-APACHE.txt\"),\n-          include_bytes!(\"static/LICENSE-APACHE.txt\"))?;\n+          static_files::LICENSE_APACHE)?;\n     write(cx.dst.join(\"COPYRIGHT.txt\"),\n-          include_bytes!(\"static/COPYRIGHT.txt\"))?;\n+          static_files::COPYRIGHT)?;\n \n     fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();"}, {"sha": "3baa082bd0e6936203c966e2c67994a7548723f0", "filename": "src/librustdoc/html/static_files.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Static files bundled with documentation output.\n+//!\n+//! All the static files are included here for centralized access in case anything other than the\n+//! HTML rendering code (say, the theme checker) needs to access one of these files.\n+//!\n+//! Note about types: CSS and JavaScript files are included as `&'static str` to allow for the\n+//! minifier to run on them. All other files are included as `&'static [u8]` so they can be\n+//! directly written to a `Write` handle.\n+\n+/// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n+pub static RUSTDOC_CSS: &'static str = include_str!(\"static/rustdoc.css\");\n+\n+/// The file contents of `settings.css`, responsible for the items on the settings page.\n+pub static SETTINGS_CSS: &'static str = include_str!(\"static/settings.css\");\n+\n+/// The file contents of `normalize.css`, included to even out standard elements between browser\n+/// implementations.\n+pub static NORMALIZE_CSS: &'static str = include_str!(\"static/normalize.css\");\n+\n+/// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n+/// including search behavior and docblock folding, among others.\n+pub static MAIN_JS: &'static str = include_str!(\"static/main.js\");\n+\n+/// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n+/// page.\n+pub static SETTINGS_JS: &'static str = include_str!(\"static/settings.js\");\n+\n+/// The file contents of `storage.js`, which contains functionality related to browser Local\n+/// Storage, used to store documentation settings.\n+pub static STORAGE_JS: &'static str = include_str!(\"static/storage.js\");\n+\n+/// The file contents of `brush.svg`, the icon used for the theme-switch button.\n+pub static BRUSH_SVG: &'static [u8] = include_bytes!(\"static/brush.svg\");\n+\n+/// The file contents of `wheel.svg`, the icon used for the settings button.\n+pub static WHEEL_SVG: &'static [u8] = include_bytes!(\"static/wheel.svg\");\n+\n+/// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n+/// output.\n+pub static COPYRIGHT: &'static [u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+\n+/// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n+pub static LICENSE_APACHE: &'static [u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+\n+/// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n+pub static LICENSE_MIT: &'static [u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+\n+/// The built-in themes given to every documentation site.\n+pub mod themes {\n+    /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n+    /// the `--theme-checker` functionality.\n+    pub static LIGHT: &'static str = include_str!(\"static/themes/light.css\");\n+\n+    /// The \"dark\" theme.\n+    pub static DARK: &'static str = include_str!(\"static/themes/dark.css\");\n+}\n+\n+/// Files related to the Fira Sans font.\n+pub mod fira_sans {\n+    /// The file `FiraSans-Regular.woff`, the Regular variant of the Fira Sans font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n+\n+    /// The file `FiraSans-Medium.woff`, the Medium variant of the Fira Sans font.\n+    pub static MEDIUM: &'static [u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n+\n+    /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n+}\n+\n+/// Files related to the Heuristica font.\n+pub mod heuristica {\n+    /// The file `Heuristica-Italic.woff`, the Italic variant of the Heuristica font.\n+    pub static ITALIC: &'static [u8] = include_bytes!(\"static/Heuristica-Italic.woff\");\n+\n+    /// The file `Heuristica-LICENSE.txt`, the license text for the Heuristica font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/Heuristica-LICENSE.txt\");\n+}\n+\n+/// Files related to the Source Serif Pro font.\n+pub mod source_serif_pro {\n+    /// The file `SourceSerifPro-Regular.woff`, the Regular variant of the Source Serif Pro font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceSerifPro-Regular.woff\");\n+\n+    /// The file `SourceSerifPro-Bold.woff`, the Bold variant of the Source Serif Pro font.\n+    pub static BOLD: &'static [u8] = include_bytes!(\"static/SourceSerifPro-Bold.woff\");\n+\n+    /// The file `SourceSerifPro-LICENSE.txt`, the license text for the Source Serif Pro font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.txt\");\n+}\n+\n+/// Files related to the Source Code Pro font.\n+pub mod source_code_pro {\n+    /// The file `SourceCodePro-Regular.woff`, the Regular variant of the Source Code Pro font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n+\n+    /// The file `SourceCodePro-Semibold.woff`, the Semibold variant of the Source Code Pro font.\n+    pub static SEMIBOLD: &'static [u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n+\n+    /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n+    pub static LICENSE: &'static [u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n+}"}, {"sha": "4b043b26d8650d6a6149062d13cd202979e48000", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -78,6 +78,7 @@ pub mod html {\n     crate mod layout;\n     pub mod markdown;\n     crate mod render;\n+    crate mod static_files;\n     crate mod toc;\n }\n mod markdown;"}, {"sha": "87ffe0f15e45461032f31da6de9159016b7795c6", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -1178,7 +1178,7 @@ impl CStr {\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n     /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n-    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// with the corresponding [`&str`] slice. Otherwise, it will\n     /// replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result."}, {"sha": "0829593505d69e5b8060132d992b922f33d29da4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -495,7 +495,7 @@ mod memchr;\n // compiler\n pub mod rt;\n \n-// Pull in the the `stdsimd` crate directly into libstd. This is the same as\n+// Pull in the `stdsimd` crate directly into libstd. This is the same as\n // libcore's arch/simd modules where the source of truth here is in a different\n // repository, but we pull things in here manually to get it into libstd.\n //"}, {"sha": "aa756f4a2337058da474c8484529e98fee5a653a", "filename": "src/test/mir-opt/inline-trait-method_2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -Z span_free_formats -Z mir-opt-level=3\n+\n+#[inline]\n+fn test(x: &dyn X) -> bool {\n+    x.y()\n+}\n+\n+fn test2(x: &dyn X) -> bool {\n+    test(x)\n+}\n+\n+trait X {\n+    fn y(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl X for () {\n+    fn y(&self) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Should be true: {}\", test2(&()));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.test2.Inline.after.mir\n+// ...\n+// bb0: {\n+// ...\n+//     _0 = const X::y(move _2) -> bb1;\n+// }\n+// ...\n+// END rustc.test2.Inline.after.mir"}, {"sha": "e69c0af2be768dfa4c51c41117eb44894ef04f66", "filename": "src/test/run-pass/associated-types/associated-types-from-supertrait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo {}\n+\n+fn main() {\n+    let _: &dyn Bar;\n+}"}, {"sha": "cce8bb84837f3b2fde9928063a557647e3a82013", "filename": "src/test/run-pass/issues/issue-24010.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Fn(i32) -> i32 + Send {}\n+\n+impl<T: ?Sized + Fn(i32) -> i32 + Send> Foo for T {}\n+\n+fn wants_foo(f: Box<Foo>) -> i32 {\n+    f(42)\n+}\n+\n+fn main() {\n+    let f = Box::new(|x| x);\n+    assert_eq!(wants_foo(f), 42);\n+}"}, {"sha": "adac28eeb1292d40797fc1f322aba3b1fdb7e030", "filename": "src/test/run-pass/traits/trait-alias-object.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -21,7 +21,6 @@ pub fn main() {\n     let b = Box::new(456) as Box<dyn Foo>;\n     assert!(*b == 456);\n \n-    // FIXME(alexreg): associated type should be gotten from trait alias definition\n-    // let c: &dyn I32Iterator = &vec![123].into_iter();\n-    // assert_eq!(c.next(), Some(123));\n+    let c: &mut dyn I32Iterator = &mut vec![123].into_iter();\n+    assert_eq!(c.next(), Some(123));\n }", "previous_filename": "src/test/run-pass/traits/trait-alias-object-type.rs"}, {"sha": "8d91561b7d64feb218d1a0ff9d71c2834a3573ec", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+}"}, {"sha": "536cd945083a60cb8b6f77919a45ea6da7175b0c", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,13 @@\n+error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding-2.rs:16:39\n+   |\n+LL |     let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ expected u32, found i32\n+   |\n+   = note: expected type `u32`\n+              found type `i32`\n+   = note: required for the cast to the object type `dyn I32Iterator<Item=u32, Item=i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "ed2211ecffd2bff8fba1f529674d4eda3138e3ce", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo<Item = u32> {}\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+trait U32Iterator = I32Iterator<Item = u32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32>;\n+}"}, {"sha": "216aa097db9fb7c44f0af2ea27b691c859415ec6", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,15 @@\n+error[E0284]: type annotations required: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding.rs:14:1\n+   |\n+LL | trait Bar: Foo<Item = u32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: required by `Foo`\n+  --> $DIR/associated-types-overridden-binding.rs:13:1\n+   |\n+LL | trait Foo: Iterator<Item = i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "95b26a5724a412da7024ec1f88ecd1a4f59ce61f", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.ast.stderr", "status": "renamed", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -3,8 +3,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -14,8 +14,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -25,8 +25,8 @@ error[E0382]: use of moved value: `a`\n    |\n LL |     let _x = a.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = &a.y; //~ ERROR use of moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = &a.y; //[ast]~ ERROR use of moved\n    |               ^^^ value used here after move\n    |\n    = note: move occurs because `a.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -44,7 +44,7 @@ error[E0503]: cannot use `a.y` because it was mutably borrowed\n    |\n LL |     let _x = &mut a.x;\n    |                   --- borrow of `a.x` occurs here\n-LL |     let _y = a.y; //~ ERROR cannot use\n+LL |     let _y = a.y; //[ast]~ ERROR cannot use\n    |         ^^ use of borrowed `a.x`\n \n error[E0505]: cannot move out of `a.y` because it is borrowed\n@@ -60,9 +60,9 @@ error[E0502]: cannot borrow `a` (via `a.y`) as immutable because `a` is also bor\n    |\n LL |     let _x = &mut a.x;\n    |                   --- mutable borrow occurs here (via `a.x`)\n-LL |     let _y = &a.y; //~ ERROR cannot borrow\n+LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n    |               ^^^ immutable borrow occurs here (via `a.y`)\n-LL |     //~^ immutable borrow occurs here (via `a.y`)\n+...\n LL | }\n    | - mutable borrow ends here\n \n@@ -71,9 +71,9 @@ error[E0502]: cannot borrow `a` (via `a.y`) as mutable because `a` is also borro\n    |\n LL |     let _x = &a.x;\n    |               --- immutable borrow occurs here (via `a.x`)\n-LL |     let _y = &mut a.y; //~ ERROR cannot borrow\n+LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n    |                   ^^^ mutable borrow occurs here (via `a.y`)\n-LL |     //~^ mutable borrow occurs here (via `a.y`)\n+...\n LL | }\n    | - immutable borrow ends here\n \n@@ -82,8 +82,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of collaterally moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -93,8 +93,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = a.y; //[ast]~ ERROR use of collaterally moved\n    |         ^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -104,8 +104,8 @@ error[E0382]: use of collaterally moved value: `a.y`\n    |\n LL |     let _x = a.x.x;\n    |         -- value moved here\n-LL |     //~^ value moved here\n-LL |     let _y = &a.y; //~ ERROR use of collaterally moved\n+LL |     //[ast]~^ value moved here\n+LL |     let _y = &a.y; //[ast]~ ERROR use of collaterally moved\n    |               ^^^ value used here after move\n    |\n    = note: move occurs because `a.x.x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -115,7 +115,7 @@ error[E0505]: cannot move out of `a.y` because it is borrowed\n    |\n LL |     let _x = &a.x.x;\n    |               ----- borrow of `a.x.x` occurs here\n-LL |     //~^ borrow of `a.x.x` occurs here\n+LL |     //[ast]~^ borrow of `a.x.x` occurs here\n LL |     let _y = a.y;\n    |         ^^ move out of `a.y` occurs here\n \n@@ -124,7 +124,7 @@ error[E0503]: cannot use `a.y` because it was mutably borrowed\n    |\n LL |     let _x = &mut a.x.x;\n    |                   ----- borrow of `a.x.x` occurs here\n-LL |     let _y = a.y; //~ ERROR cannot use\n+LL |     let _y = a.y; //[ast]~ ERROR cannot use\n    |         ^^ use of borrowed `a.x.x`\n \n error[E0505]: cannot move out of `a.y` because it is borrowed\n@@ -140,10 +140,10 @@ error[E0502]: cannot borrow `a.y` as immutable because `a.x.x` is also borrowed\n    |\n LL |     let _x = &mut a.x.x;\n    |                   ----- mutable borrow occurs here\n-LL |     //~^ mutable borrow occurs here\n-LL |     let _y = &a.y; //~ ERROR cannot borrow\n+LL |     //[ast]~^ mutable borrow occurs here\n+LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n    |               ^^^ immutable borrow occurs here\n-LL |     //~^ immutable borrow occurs here\n+...\n LL | }\n    | - mutable borrow ends here\n \n@@ -152,10 +152,10 @@ error[E0502]: cannot borrow `a.y` as mutable because `a.x.x` is also borrowed as\n    |\n LL |     let _x = &a.x.x;\n    |               ----- immutable borrow occurs here\n-LL |     //~^ immutable borrow occurs here\n-LL |     let _y = &mut a.y; //~ ERROR cannot borrow\n+LL |     //[ast]~^ immutable borrow occurs here\n+LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n    |                   ^^^ mutable borrow occurs here\n-LL |     //~^ mutable borrow occurs here\n+...\n LL | }\n    | - immutable borrow ends here\n ", "previous_filename": "src/test/ui/borrowck/borrowck-box-insensitivity.stderr"}, {"sha": "171e992e8a628e7aa1b072991509860f9f293e51", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.mir.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.mir.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,14 @@\n+error: compilation successful\n+  --> $DIR/borrowck-box-insensitivity.rs:160:1\n+   |\n+LL | / fn main() { //[mir]~ ERROR compilation successful\n+LL | |     copy_after_move();\n+LL | |     move_after_move();\n+LL | |     borrow_after_move();\n+...  |\n+LL | |     mut_borrow_after_borrow_nested();\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2af97a9fc1d58718ed3e92eefa80f0549adbe68e", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -1,13 +1,13 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n+// This test is an artifact of the old policy that `Box<T>` should not\n+// be treated specially by the AST-borrowck.\n //\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// NLL goes back to treating `Box<T>` specially (namely, knowing that\n+// it uniquely owns the data it holds). See rust-lang/rfcs#130.\n \n+// revisions: ast mir\n+//[ast] compile-flags: -Z borrowck=ast\n+//[mir] compile-flags: -Z borrowck=mir\n+// ignore-compare-mode-nll\n #![feature(box_syntax, rustc_attrs)]\n \n struct A {\n@@ -33,131 +33,131 @@ struct D {\n fn copy_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn move_after_move() {\n     let a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn borrow_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    //~^ value moved here\n-    let _y = &a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = &a.y; //[ast]~ ERROR use of moved\n+    //[ast]~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n+    //[ast]~| value used here after move\n }\n \n fn move_after_borrow() {\n     let a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = &a.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_imm(_x);\n }\n-\n fn copy_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n-    let _y = a.y; //~ ERROR cannot use\n+    let _y = a.y; //[ast]~ ERROR cannot use\n+    use_mut(_x);\n }\n-\n fn move_after_mut_borrow() {\n     let mut a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = &mut a.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_mut(_x);\n }\n-\n fn borrow_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n-    let _y = &a.y; //~ ERROR cannot borrow\n-    //~^ immutable borrow occurs here (via `a.y`)\n+    let _y = &a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ immutable borrow occurs here (via `a.y`)\n+    use_mut(_x);\n }\n-\n fn mut_borrow_after_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &a.x;\n-    let _y = &mut a.y; //~ ERROR cannot borrow\n-    //~^ mutable borrow occurs here (via `a.y`)\n+    let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ mutable borrow occurs here (via `a.y`)\n+    use_imm(_x);\n }\n-\n fn copy_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn move_after_move_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn borrow_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ value moved here\n-    let _y = &a.y; //~ ERROR use of collaterally moved\n-    //~| value used here after move\n+    //[ast]~^ value moved here\n+    let _y = &a.y; //[ast]~ ERROR use of collaterally moved\n+    //[ast]~| value used here after move\n }\n \n fn move_after_borrow_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = &a.x.x;\n-    //~^ borrow of `a.x.x` occurs here\n+    //[ast]~^ borrow of `a.x.x` occurs here\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_imm(_x);\n }\n-\n fn copy_after_mut_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &mut a.x.x;\n-    let _y = a.y; //~ ERROR cannot use\n+    let _y = a.y; //[ast]~ ERROR cannot use\n+    use_mut(_x);\n }\n-\n fn move_after_mut_borrow_nested() {\n     let mut a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = &mut a.x.x;\n     let _y = a.y;\n-    //~^ ERROR cannot move\n-    //~| move out of\n+    //[ast]~^ ERROR cannot move\n+    //[ast]~| move out of\n+    use_mut(_x);\n }\n-\n fn borrow_after_mut_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &mut a.x.x;\n-    //~^ mutable borrow occurs here\n-    let _y = &a.y; //~ ERROR cannot borrow\n-    //~^ immutable borrow occurs here\n+    //[ast]~^ mutable borrow occurs here\n+    let _y = &a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ immutable borrow occurs here\n+    use_mut(_x);\n }\n-\n fn mut_borrow_after_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &a.x.x;\n-    //~^ immutable borrow occurs here\n-    let _y = &mut a.y; //~ ERROR cannot borrow\n-    //~^ mutable borrow occurs here\n+    //[ast]~^ immutable borrow occurs here\n+    let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n+    //[ast]~^ mutable borrow occurs here\n+    use_imm(_x);\n }\n-\n #[rustc_error]\n-fn main() {\n+fn main() { //[mir]~ ERROR compilation successful\n     copy_after_move();\n     move_after_move();\n     borrow_after_move();\n@@ -180,3 +180,6 @@ fn main() {\n     borrow_after_mut_borrow_nested();\n     mut_borrow_after_borrow_nested();\n }\n+\n+fn use_mut<T>(_: &mut T) { }\n+fn use_imm<T>(_: &T) { }"}, {"sha": "f6bbcc60e4e6456fc388d5fdb34baeb20ab14197", "filename": "src/test/ui/consts/auxiliary/promotable_const_fn_lib.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fpromotable_const_fn_lib.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Crate that exports a const fn. Used for testing cross-crate.\n+\n+#![feature(staged_api, rustc_attrs)]\n+#![stable(since=\"1.0.0\", feature = \"mep\")]\n+\n+#![crate_type=\"rlib\"]\n+\n+#[rustc_promotable]\n+#[stable(since=\"1.0.0\", feature = \"mep\")]\n+#[inline]\n+pub const fn foo() -> usize { 22 }\n+\n+#[stable(since=\"1.0.0\", feature = \"mep\")]\n+pub struct Foo(usize);\n+\n+impl Foo {\n+    #[stable(since=\"1.0.0\", feature = \"mep\")]\n+    #[inline]\n+    #[rustc_promotable]\n+    pub const fn foo() -> usize { 22 }\n+}"}, {"sha": "13309f978b6729733584a2ea1dd170e77a8a2338", "filename": "src/test/ui/consts/const-prop-ice.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    [0; 3][3u64 as usize]; //~ ERROR the len is 3 but the index is 3\n+}"}, {"sha": "749ef952b5ddbee40f4bf382809dd21241788aac", "filename": "src/test/ui/consts/const-prop-ice.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,10 @@\n+error: index out of bounds: the len is 3 but the index is 3\n+  --> $DIR/const-prop-ice.rs:2:5\n+   |\n+LL |     [0; 3][3u64 as usize]; //~ ERROR the len is 3 but the index is 3\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "e5fd79f11676e76f456263be064f26e2a60e96b1", "filename": "src/test/ui/consts/const-prop-ice2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    enum Enum { One=1 }\n+    let xs=[0;1 as usize];\n+    println!(\"{}\", xs[Enum::One as usize]); //~ ERROR the len is 1 but the index is 1\n+}"}, {"sha": "4febd0ee1e3911a3b16ad2f6f7f2b164fe9c5cce", "filename": "src/test/ui/consts/const-prop-ice2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-ice2.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,10 @@\n+error: index out of bounds: the len is 1 but the index is 1\n+  --> $DIR/const-prop-ice2.rs:4:20\n+   |\n+LL |     println!(\"{}\", xs[Enum::One as usize]); //~ ERROR the len is 1 but the index is 1\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "045322de3470820ed61789bd5ddcf5d038d93b4d", "filename": "src/test/ui/consts/promote_fn_calls.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+// aux-build:promotable_const_fn_lib.rs\n+\n+#![feature(nll)]\n+\n+extern crate promotable_const_fn_lib;\n+\n+use promotable_const_fn_lib::{foo, Foo};\n+\n+fn main() {\n+    let x: &'static usize = &foo();\n+    let x: &'static usize = &Foo::foo();\n+}"}, {"sha": "0350708d673d7d52a9558f76aaf806f6d6ea6a72", "filename": "src/test/ui/consts/promote_fn_calls_std.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote_fn_calls_std.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,30 @@\n+// compile-pass\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let x: &'static u8 = &u8::max_value();\n+    let x: &'static u16 = &u16::max_value();\n+    let x: &'static u32 = &u32::max_value();\n+    let x: &'static u64 = &u64::max_value();\n+    let x: &'static u128 = &u128::max_value();\n+    let x: &'static usize = &usize::max_value();\n+    let x: &'static u8 = &u8::min_value();\n+    let x: &'static u16 = &u16::min_value();\n+    let x: &'static u32 = &u32::min_value();\n+    let x: &'static u64 = &u64::min_value();\n+    let x: &'static u128 = &u128::min_value();\n+    let x: &'static usize = &usize::min_value();\n+    let x: &'static i8 = &i8::max_value();\n+    let x: &'static i16 = &i16::max_value();\n+    let x: &'static i32 = &i32::max_value();\n+    let x: &'static i64 = &i64::max_value();\n+    let x: &'static i128 = &i128::max_value();\n+    let x: &'static isize = &isize::max_value();\n+    let x: &'static i8 = &i8::min_value();\n+    let x: &'static i16 = &i16::min_value();\n+    let x: &'static i32 = &i32::min_value();\n+    let x: &'static i64 = &i64::min_value();\n+    let x: &'static i128 = &i128::min_value();\n+    let x: &'static isize = &isize::min_value();\n+}"}, {"sha": "c35c7e10f5a38500ab26cff4ab0cc8854964f397", "filename": "src/test/ui/error-codes/E0191.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -14,5 +14,4 @@ trait Trait {\n \n type Foo = Trait; //~ ERROR E0191\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "c7bfa85093f2da7147a162af5bdbe627a9c5c32f", "filename": "src/test/ui/error-codes/E0719.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n-use std::iter::Iterator;\n+trait Foo: Iterator<Item = i32, Item = i32> {}\n \n type Unit = ();\n \n-fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n+fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n     Box::new(None.into_iter())\n }\n \n fn main() {\n+    let _: &Iterator<Item = i32, Item = i32>;\n     test();\n }", "previous_filename": "src/test/ui/lint/issue-50589-multiple-associated-types.rs"}, {"sha": "3a908fceced6028cd4612ee7b1753115350cb04d", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,19 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:11:33\n+   |\n+LL | trait Foo: Iterator<Item = i32, Item = i32> {}\n+   |                     ----------  ^^^^^^^^^^ re-bound here\n+   |                     |\n+   |                     `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:15:38\n+   |\n+LL | fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n+   |                           ---------  ^^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "3ad7435fecf29790d20ea7d1b500432b6b48f817", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#[no_implicit_prelude]\n+mod bar {\n+    fn f() {\n+        ::std::print!(\"\"); // OK\n+        print!(); //~ ERROR cannot find macro `print!` in this scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "370fc9784ad4da3357ec5bf7722d94ef2d4b8d86", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,10 @@\n+error: cannot find macro `print!` in this scope\n+  --> $DIR/no_implicit_prelude-2018.rs:7:9\n+   |\n+LL |         print!(); //~ ERROR cannot find macro `print!` in this scope\n+   |         ^^^^^\n+   |\n+   = help: have you added the `#[macro_use]` on the module/import?\n+\n+error: aborting due to previous error\n+"}, {"sha": "5b6041945abea76a2f9d57e39d0b591a66ab9798", "filename": "src/test/ui/hygiene/no_implicit_prelude.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -21,7 +21,10 @@ mod bar {\n         Vec::new(); //~ ERROR failed to resolve\n         ().clone() //~ ERROR no method named `clone` found\n     }\n-    fn f() { ::foo::m!(); }\n+    fn f() {\n+        ::foo::m!();\n+        println!(); // OK on 2015 edition (at least for now)\n+    }\n }\n \n fn main() {}"}, {"sha": "7b79807e4d7ff5df6ffa42a3e4a12a3ec698367d", "filename": "src/test/ui/issue-51947.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51947.rs?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -1,17 +0,0 @@\n-// compile-pass\n-\n-#![crate_type = \"lib\"]\n-#![feature(linkage)]\n-\n-// MergeFunctions will merge these via an anonymous internal\n-// backing function, which must be named if ThinLTO buffers are used\n-\n-#[linkage = \"weak\"]\n-pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}\n-\n-#[linkage = \"weak\"]\n-pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}"}, {"sha": "3e0c3c002f64962cb97c905a8f8e1faa239c30d7", "filename": "src/test/ui/issues/issue-51947.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![crate_type = \"lib\"]\n+#![feature(linkage)]\n+\n+// MergeFunctions will merge these via an anonymous internal\n+// backing function, which must be named if ThinLTO buffers are used\n+\n+#[linkage = \"weak\"]\n+pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}\n+\n+#[linkage = \"weak\"]\n+pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}"}, {"sha": "b48d4a9c022f42dbe1aadab24058278dd2aef4a9", "filename": "src/test/ui/issues/issue-55796.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,22 @@\n+pub trait EdgeTrait<N> {\n+    fn target(&self) -> N;\n+}\n+\n+pub trait Graph<'a> {\n+    type Node;\n+    type Edge: EdgeTrait<Self::Node>;\n+    type NodesIter: Iterator<Item = Self::Node> + 'a;\n+    type EdgesIter: Iterator<Item = Self::Edge> + 'a;\n+\n+    fn nodes(&'a self) -> Self::NodesIter;\n+    fn out_edges(&'a self, u: &Self::Node) -> Self::EdgesIter;\n+    fn in_edges(&'a self, u: &Self::Node) -> Self::EdgesIter;\n+\n+    fn out_neighbors(&'a self, u: &Self::Node) -> Box<Iterator<Item = Self::Node>> {\n+        Box::new(self.out_edges(u).map(|e| e.target()))\n+    }\n+\n+    fn in_neighbors(&'a self, u: &Self::Node) -> Box<Iterator<Item = Self::Node>> {\n+        Box::new(self.in_edges(u).map(|e| e.target()))\n+    }\n+}"}, {"sha": "60ce8293a5ceb4e4ee54219687464b9351c6413c", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,50 @@\n+error[E0601]: `main` function not found in crate `issue_55796`\n+   |\n+   = note: consider adding a `main` function to `$DIR/issue-55796.rs`\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/issue-55796.rs:16:9\n+   |\n+LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+  --> $DIR/issue-55796.rs:5:17\n+   |\n+LL | pub trait Graph<'a> {\n+   |                 ^^\n+note: ...so that the type `std::iter::Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:16:40: 16:54]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:16:9\n+   |\n+LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: but, the lifetime must be valid for the static lifetime...\n+   = note: ...so that the expression is assignable:\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n+  --> $DIR/issue-55796.rs:20:9\n+   |\n+LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'a as defined on the trait at 5:17...\n+  --> $DIR/issue-55796.rs:5:17\n+   |\n+LL | pub trait Graph<'a> {\n+   |                 ^^\n+note: ...so that the type `std::iter::Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:20:39: 20:53]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:20:9\n+   |\n+LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: but, the lifetime must be valid for the static lifetime...\n+   = note: ...so that the expression is assignable:\n+           expected std::boxed::Box<(dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node> + 'static)>\n+              found std::boxed::Box<dyn std::iter::Iterator<Item=<Self as Graph<'a>>::Node>>\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0495, E0601.\n+For more information about an error, try `rustc --explain E0495`."}, {"sha": "7f0a1ee1f3307b2a4f3f226d88f715a50af84def", "filename": "src/test/ui/lint/issue-50589-multiple-associated-types.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -1,23 +0,0 @@\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = note: #[warn(duplicate_associated_type_bindings)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-"}, {"sha": "40f68c6782781f0b01163c4c1db385d167e5a7e6", "filename": "src/test/ui/lint/lint-unused-mut-variables.nll.stderr", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b8f9029762da90a88c8ca6f8ff7690177ec696a/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.nll.stderr?ref=9b8f9029762da90a88c8ca6f8ff7690177ec696a", "patch": "@@ -1,150 +0,0 @@\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:59:14\n-   |\n-LL |     let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n-   |              ----^\n-   |              |\n-   |              help: remove this `mut`\n-   |\n-note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:19:9\n-   |\n-LL | #![deny(unused_mut)]\n-   |         ^^^^^^^^^^\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:24:9\n-   |\n-LL |     let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:26:9\n-   |\n-LL |     let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:28:9\n-   |\n-LL |     let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:30:9\n-   |\n-LL |     let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:32:10\n-   |\n-LL |     let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n-   |          ----^\n-   |          |\n-   |          help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:34:9\n-   |\n-LL |     let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:38:9\n-   |\n-LL |     let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:47:9\n-   |\n-LL |         mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:51:8\n-   |\n-LL |       (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n-   |        ----^\n-   |        |\n-   |        help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:64:9\n-   |\n-LL |     let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:69:9\n-   |\n-LL |     let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:72:9\n-   |\n-LL |     let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:84:9\n-   |\n-LL |     let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:61:13\n-   |\n-LL |     fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n-   |             ----^^^\n-   |             |\n-   |             help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:79:20\n-   |\n-LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-   |                    ----^^^\n-   |                    |\n-   |                    help: remove this `mut`\n-\n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:143:9\n-   |\n-LL |     let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n-   |         ----^\n-   |         |\n-   |         help: remove this `mut`\n-   |\n-note: lint level defined here\n-  --> $DIR/lint-unused-mut-variables.rs:139:8\n-   |\n-LL | #[deny(unused_mut)]\n-   |        ^^^^^^^^^^\n-\n-error: aborting due to 17 previous errors\n-"}, {"sha": "a2005ba9f72e02db8b82d3d3736c3d6756d9d9a2", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lexical nll\n-#![cfg_attr(nll, feature(nll))]\n+\n+\n \n // Exercise the unused_mut attribute in some positive and negative cases\n \n@@ -21,68 +21,68 @@\n \n fn main() {\n     // negative cases\n-    let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n-                         //[nll]~^ ERROR: variable does not need to be mutable\n-    let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n-                             //[nll]~^ ERROR: variable does not need to be mutable\n-    let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n-               //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = 3; //~ ERROR: variable does not need to be mutable\n+\n+    let mut a = 2; //~ ERROR: variable does not need to be mutable\n+\n+    let mut b = 3; //~ ERROR: variable does not need to be mutable\n+\n+    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n+\n+    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n+\n+    let mut a; //~ ERROR: variable does not need to be mutable\n+\n     a = 3;\n \n-    let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n-               //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b; //~ ERROR: variable does not need to be mutable\n+\n     if true {\n         b = 3;\n     } else {\n         b = 4;\n     }\n \n     match 30 {\n-        mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n-                    //[nll]~^ ERROR: variable does not need to be mutable\n+        mut x => {} //~ ERROR: variable does not need to be mutable\n+\n     }\n     match (30, 2) {\n-      (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n-                   //[nll]~^ ERROR: variable does not need to be mutable\n+      (mut x, 1) | //~ ERROR: variable does not need to be mutable\n+\n       (mut x, 2) |\n       (mut x, 3) => {\n       }\n       _ => {}\n     }\n \n-    let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n-                               //[nll]~^ ERROR: variable does not need to be mutable\n-    fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n-                               //[nll]~^ ERROR: variable does not need to be mutable\n+    let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n+\n+    fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n+\n+\n+    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n \n-    let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n-                        //[nll]~^ ERROR: variable does not need to be mutable\n     *a = 4;\n \n     let mut a = 5;\n-    let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n-    *b.0 = 4;              //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = (&mut a,); //~ ERROR: variable does not need to be mutable\n+    *b.0 = 4;\n+\n+    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n \n-    let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n-                        //[nll]~^ ERROR: variable does not need to be mutable\n     let mut f = || {\n       *x += 1;\n     };\n     f();\n \n     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-        &mut arg[..] //[lexical]~^ ERROR: variable does not need to be mutable\n-                     //[nll]~^^ ERROR: variable does not need to be mutable\n+        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+\n     }\n \n-    let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n-                                            //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+\n     v.push(());\n \n     // positive cases\n@@ -140,6 +140,6 @@ fn foo(mut a: isize) {\n fn bar() {\n     #[allow(unused_mut)]\n     let mut a = 3;\n-    let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n-                         //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n+\n }"}, {"sha": "60e8400c42870980a52cefe5a4f0bd430270661f", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -1,7 +1,7 @@\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:59:14\n    |\n-LL |     let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n    |              ----^\n    |              |\n    |              help: remove this `mut`\n@@ -15,111 +15,111 @@ LL | #![deny(unused_mut)]\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:24:9\n    |\n-LL |     let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = 3; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:26:9\n    |\n-LL |     let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = 2; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:28:9\n    |\n-LL |     let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = 3; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:30:9\n    |\n-LL |     let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:32:10\n    |\n-LL |     let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n    |          ----^\n    |          |\n    |          help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:34:9\n    |\n-LL |     let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:38:9\n    |\n-LL |     let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:47:9\n    |\n-LL |         mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n+LL |         mut x => {} //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:51:8\n    |\n-LL |       (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n+LL |       (mut x, 1) | //~ ERROR: variable does not need to be mutable\n    |        ----^\n    |        |\n    |        help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:64:9\n    |\n-LL |     let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:69:9\n    |\n-LL |     let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = (&mut a,); //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:72:9\n    |\n-LL |     let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:84:9\n    |\n-LL |     let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:61:13\n    |\n-LL |     fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n    |             ----^^^\n    |             |\n    |             help: remove this `mut`\n@@ -135,7 +135,7 @@ LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n error: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:143:9\n    |\n-LL |     let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n+LL |     let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n    |         ----^\n    |         |\n    |         help: remove this `mut`", "previous_filename": "src/test/ui/lint/lint-unused-mut-variables.lexical.stderr"}, {"sha": "452fc88d1ecdd07083f7b2f63c5d187b1e02b681", "filename": "src/test/ui/nll/issue-55394.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct Bar;\n+\n+struct Foo<'s> {\n+    bar: &'s mut Bar,\n+}\n+\n+impl Foo<'_> {\n+    fn new(bar: &mut Bar) -> Self {\n+        Foo { bar }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "284d7afa6fd23cc38056422be695d5ec9a35daea", "filename": "src/test/ui/nll/issue-55394.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,12 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-55394.rs:21:9\n+   |\n+LL |     fn new(bar: &mut Bar) -> Self {\n+   |                 -            ---- return type is Foo<'2>\n+   |                 |\n+   |                 let's call the lifetime of this reference `'1`\n+LL |         Foo { bar }\n+   |         ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3adcd8436d8a1c2c9075aaf5b7bbfe67552660da", "filename": "src/test/ui/traits/trait-alias-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "previous_filename": "src/test/ui/traits/trait-alias-objects.rs"}, {"sha": "6b7b322a53d9e86ec530d55da1ef9a887bbd02ff", "filename": "src/test/ui/traits/trait-alias-object.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -1,13 +1,13 @@\n error[E0038]: the trait `EqAlias` cannot be made into an object\n-  --> $DIR/trait-alias-objects.rs:17:13\n+  --> $DIR/trait-alias-object.rs:17:13\n    |\n LL |     let _: &dyn EqAlias = &123;\n    |             ^^^^^^^^^^^ the trait `EqAlias` cannot be made into an object\n    |\n    = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n \n error[E0191]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified\n-  --> $DIR/trait-alias-objects.rs:18:13\n+  --> $DIR/trait-alias-object.rs:18:13\n    |\n LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n    |             ^^^^^^^^^^^^^^^^^ missing associated type `Item` value", "previous_filename": "src/test/ui/traits/trait-alias-objects.stderr"}, {"sha": "9eed80ad886e0c876a3d14e08031382e7404dec3", "filename": "src/test/ui/typeck/issue-55810-must-typeck-match-pats-before-guards.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76ee83254ec0398da554f25c2168d917ba60f1c/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-55810-must-typeck-match-pats-before-guards.rs?ref=b76ee83254ec0398da554f25c2168d917ba60f1c", "patch": "@@ -0,0 +1,23 @@\n+// compile-pass\n+\n+// rust-lang/rust#55810: types for a binding in a match arm can be\n+// inferred from arms that come later in the match.\n+\n+struct S;\n+\n+impl S {\n+    fn method(&self) -> bool {\n+        unimplemented!()\n+    }\n+}\n+\n+fn get<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn main() {\n+    match get() {\n+        x if x.method() => {}\n+        &S => {}\n+    }\n+}"}]}