{"sha": "5e55a4411684a9cf3932b0597607cf82433ff3ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNTVhNDQxMTY4NGE5Y2YzOTMyYjA1OTc2MDdjZjgyNDMzZmYzYmE=", "commit": {"author": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-05-14T12:42:47Z"}, "committer": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-07-13T19:10:45Z"}, "message": "syntax_ext: format: allow multiple formats for one argument\n\nThis commit removed the restriction of only allowing one type per argument.\nThis is achieved by adding mappings between macro arguments and format\nplaceholders, then taking the mapping into consideration when emitting\nthe Arguments expression.\n\nsyntax_ext: format: fix implicit positional arguments\n\nsyntax_ext: format: don't panic if no args given for implicit positional args\n\nCheck the list lengths before use.\nFixes regression of `compile-fail/macro-backtrace-println.rs`.\n\nsyntax_ext: format: also map CountIsParam indices to expanded args\n\nsyntax_ext: format: fix ICE in case of malformed format args", "tree": {"sha": "aed9cd2295885841a9b51bf24231017b2383d7f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed9cd2295885841a9b51bf24231017b2383d7f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e55a4411684a9cf3932b0597607cf82433ff3ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXhpI1AAoJEHg5bO9pIxDsO5cP/iNTzPHqONJD2Gtva9TlrOR+\niuOyqZZoXLMlTFYq1UhLJO5qsB0tQgI4Pr/hIq137Y44c2AI+3HOV0kibZYxfUxy\nXPKhbtKK9DPYnhdU9CBHxILqMzAMkayOqkeYLCf7i3sNqUXjjYCQYrZM3A+JIoBD\nn31QWrd20X7AM15gDkH+75ZJxN6bfhH9lNwliUzbvvQYdK/+oo6RzE+e3OK7TXWW\nf+sKev9V4mAzn4NaThc/z29mEu8CbmvY0R4XiQGQa1LnLsCyRQHT9ASOCmbtg9D0\ngUxwCrGoZCv+umiOOZXbFO/11/CfpchHbJZSttmSeiyXh2457//c42iNoP8U5Ioc\nSxwmX34ghqCOw6Ck6cdEJ/KkcfF8MUWezVz53z7VdqRUzDdBMop2TYydeYBVrRVC\nPW/hpUL+ZwSeiuO56IpD3MMIqE4PBRgllKzSKyu52C7Q63hHvhv9swpfEXrRaIja\nBmEH9gMfrv7awQb/u5Beh99CNgJ8ecPGUTvGuKYKukF2c9rAKD/gCwxPswMJexsS\n8Z21Gj6dxx/8gjZ4vgRoQNtTmLERbEFq5m34aDeNO3LI7XXTe91wbiMpwwyHHcT2\n2ux+wMdOGpxyYJioHbkVRAcm12LowzA6PZDVW0hoZy1FK60E1wbbnbqAmZi6j0kd\nIF5FnHz8oVl21iFyScqp\n=3bCH\n-----END PGP SIGNATURE-----", "payload": "tree aed9cd2295885841a9b51bf24231017b2383d7f3\nparent eb5417bf12ea7f709f6603308d86b61a1fc845c5\nauthor Wang Xuerui <idontknw.wang@gmail.com> 1463229767 +0800\ncommitter Wang Xuerui <idontknw.wang@gmail.com> 1468437045 +0800\n\nsyntax_ext: format: allow multiple formats for one argument\n\nThis commit removed the restriction of only allowing one type per argument.\nThis is achieved by adding mappings between macro arguments and format\nplaceholders, then taking the mapping into consideration when emitting\nthe Arguments expression.\n\nsyntax_ext: format: fix implicit positional arguments\n\nsyntax_ext: format: don't panic if no args given for implicit positional args\n\nCheck the list lengths before use.\nFixes regression of `compile-fail/macro-backtrace-println.rs`.\n\nsyntax_ext: format: also map CountIsParam indices to expanded args\n\nsyntax_ext: format: fix ICE in case of malformed format args\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e55a4411684a9cf3932b0597607cf82433ff3ba", "html_url": "https://github.com/rust-lang/rust/commit/5e55a4411684a9cf3932b0597607cf82433ff3ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e55a4411684a9cf3932b0597607cf82433ff3ba/comments", "author": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb5417bf12ea7f709f6603308d86b61a1fc845c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5417bf12ea7f709f6603308d86b61a1fc845c5", "html_url": "https://github.com/rust-lang/rust/commit/eb5417bf12ea7f709f6603308d86b61a1fc845c5"}], "stats": {"total": 129, "additions": 57, "deletions": 72}, "files": [{"sha": "e6a5ff1d444826f81907b5e10f879d2e61a6f115", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 57, "deletions": 69, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5e55a4411684a9cf3932b0597607cf82433ff3ba/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55a4411684a9cf3932b0597607cf82433ff3ba/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5e55a4411684a9cf3932b0597607cf82433ff3ba", "patch": "@@ -49,7 +49,7 @@ struct Context<'a, 'b:'a> {\n     /// Named expressions are resolved early, and are appended to the end of\n     /// argument expressions.\n     args: Vec<P<ast::Expr>>,\n-    arg_types: Vec<Option<ArgumentType>>,\n+    arg_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n     names: HashMap<String, usize>,\n \n@@ -63,6 +63,13 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n+    /// Mapping between positional argument references and indices into the\n+    /// final generated static argument array. We record the starting indices\n+    /// corresponding to each positional argument, and number of references\n+    /// consumed so far for each argument, to facilitate correct `Position`\n+    /// mapping in `trans_piece`.\n+    arg_index_map: Vec<usize>,\n+\n     /// Current position of the implicit positional arg pointer, as if it\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n@@ -218,16 +225,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n                 }\n-                {\n-                    let arg_type = match self.arg_types[arg] {\n-                        None => None,\n-                        Some(ref x) => Some(x)\n-                    };\n-                    self.verify_same(self.args[arg].span, &ty, arg_type);\n-                }\n-                if self.arg_types[arg].is_none() {\n-                    self.arg_types[arg] = Some(ty);\n-                }\n+                self.arg_types[arg].push(ty);\n             }\n \n             Named(name) => {\n@@ -245,56 +243,27 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// When we're keeping track of the types that are declared for certain\n-    /// arguments, we assume that `None` means we haven't seen this argument\n-    /// yet, `Some(None)` means that we've seen the argument, but no format was\n-    /// specified, and `Some(Some(x))` means that the argument was declared to\n-    /// have type `x`.\n-    ///\n-    /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n-    /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self,\n-                   sp: Span,\n-                   ty: &ArgumentType,\n-                   before: Option<&ArgumentType>) {\n-        let cur = match before {\n-            None => return,\n-            Some(t) => t,\n-        };\n-        if *ty == *cur {\n-            return\n-        }\n-        match (cur, ty) {\n-            (&Known(ref cur), &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument redeclared with type `{}` when \\\n-                                           it was previously `{}`\",\n-                                          *ty,\n-                                          *cur));\n-            }\n-            (&Known(ref cur), _) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument used to format with `{}` was \\\n-                                           attempted to not be used for formatting\",\n-                                           *cur));\n-            }\n-            (_, &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument previously used as a format \\\n-                                           argument attempted to be used as `{}`\",\n-                                           *ty));\n-            }\n-            (_, _) => {\n-                self.ecx.span_err(sp, \"argument declared with multiple formats\");\n-            }\n+    // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n+    fn build_index_map(&mut self) {\n+        let args_len = self.args.len();\n+        self.arg_index_map.reserve(args_len);\n+\n+        let mut sofar = 0usize;\n+\n+        // Generate mapping for positional args\n+        for i in 0..args_len {\n+            self.arg_index_map.push(sofar);\n+            sofar += self.arg_types[i].len();\n         }\n     }\n \n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n         ecx.std_path(&[\"fmt\", \"rt\", \"v1\", s])\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n+    fn trans_count(&self,\n+                   c: parse::Count,\n+                   arg_index_consumed: &mut Vec<usize>) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -307,7 +276,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n+                // This needs mapping too, as `i` is referring to a macro\n+                // argument.\n+                let arg_idx = self.arg_index_map[i] + arg_index_consumed[i];\n+                arg_index_consumed[i] += 1;\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, arg_idx)))\n             }\n             parse::CountImplied => count(\"Implied\", None),\n             // should never be the case, names are already resolved\n@@ -325,7 +298,10 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<P<ast::Expr>> {\n+    fn trans_piece(&mut self,\n+                   piece: &parse::Piece,\n+                   arg_index_consumed: &mut Vec<usize>)\n+                   -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -349,7 +325,18 @@ impl<'a, 'b> Context<'a, 'b> {\n                         }\n                     };\n                     match arg.position {\n-                        parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n+                        parse::ArgumentIs(i) => {\n+                            // Map to index in final generated argument array\n+                            // in case of multiple types specified\n+                            let arg_idx = if self.args.len() > i {\n+                                let arg_idx = self.arg_index_map[i] + arg_index_consumed[i];\n+                                arg_index_consumed[i] += 1;\n+                                arg_idx\n+                            } else {\n+                                0 // error already emitted elsewhere\n+                            };\n+                            pos(\"At\", Some(arg_idx))\n+                        }\n \n                         // should never be the case, because names are already\n                         // resolved.\n@@ -396,8 +383,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n-                let prec = self.trans_count(arg.format.precision);\n-                let width = self.trans_count(arg.format.width);\n+                let prec = self.trans_count(arg.format.precision, arg_index_consumed);\n+                let width = self.trans_count(arg.format.width, arg_index_consumed);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n@@ -469,15 +456,12 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let arg_ty = match self.arg_types[i].as_ref() {\n-                Some(ty) => ty,\n-                None => continue // error already generated\n-            };\n-\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n-            locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                            self.ecx.expr_ident(e.span, name)));\n+            for ref arg_ty in self.arg_types[i].iter() {\n+                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n+                                                self.ecx.expr_ident(e.span, name)));\n+            }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n \n@@ -597,7 +581,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     args: Vec<P<ast::Expr>>,\n                                     names: HashMap<String, usize>)\n                                     -> P<ast::Expr> {\n-    let arg_types: Vec<_> = (0..args.len()).map(|_| None).collect();\n+    let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n     // Expand the format literal so that efmt.span will have a backtrace. This\n     // is essential for locating a bug when the format literal is generated in\n@@ -609,6 +593,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         arg_types: arg_types,\n         names: names,\n         curarg: 0,\n+        arg_index_map: Vec::new(),\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n@@ -638,8 +623,11 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n+    cx.build_index_map();\n+\n+    let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n     for piece in pieces {\n-        if let Some(piece) = cx.trans_piece(&piece) {\n+        if let Some(piece) = cx.trans_piece(&piece, &mut arg_index_consumed) {\n             let s = cx.trans_literal_string();\n             cx.str_pieces.push(s);\n             cx.pieces.push(piece);\n@@ -659,7 +647,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.is_none() {\n+        if ty.len() == 0 {\n             let msg = if i >= num_pos_args {\n                 // named argument\n                 \"named argument never used\""}, {"sha": "272ad980feb467c767f36088f10da6881dd3dade", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e55a4411684a9cf3932b0597607cf82433ff3ba/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55a4411684a9cf3932b0597607cf82433ff3ba/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=5e55a4411684a9cf3932b0597607cf82433ff3ba", "patch": "@@ -23,9 +23,6 @@ fn main() {\n     format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n     format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    format!(\"{0:x} {0:X}\", 1);         //~ ERROR: redeclared with type `X`\n-    format!(\"{foo:x} {foo:X}\", foo=1); //~ ERROR: redeclared with type `X`\n-\n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n "}]}