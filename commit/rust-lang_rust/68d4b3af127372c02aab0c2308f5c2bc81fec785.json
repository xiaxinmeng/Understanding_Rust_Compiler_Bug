{"sha": "68d4b3af127372c02aab0c2308f5c2bc81fec785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZDRiM2FmMTI3MzcyYzAyYWFiMGMyMzA4ZjVjMmJjODFmZWM3ODU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-15T16:07:37Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-15T16:07:37Z"}, "message": "Merge pull request #314 from nweston/loop-counter\n\nLint for loops with explicit counter variable (#159)", "tree": {"sha": "5b74a008db218b7852cbf31f3690492aa4d0bd99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b74a008db218b7852cbf31f3690492aa4d0bd99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68d4b3af127372c02aab0c2308f5c2bc81fec785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68d4b3af127372c02aab0c2308f5c2bc81fec785", "html_url": "https://github.com/rust-lang/rust/commit/68d4b3af127372c02aab0c2308f5c2bc81fec785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68d4b3af127372c02aab0c2308f5c2bc81fec785/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a10db7bcd642d035151949a3e2d24265387b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a10db7bcd642d035151949a3e2d24265387b98", "html_url": "https://github.com/rust-lang/rust/commit/d2a10db7bcd642d035151949a3e2d24265387b98"}, {"sha": "8a5b4f19fd6cec7b3ef583afa592fde99dabe58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a5b4f19fd6cec7b3ef583afa592fde99dabe58e", "html_url": "https://github.com/rust-lang/rust/commit/8a5b4f19fd6cec7b3ef583afa592fde99dabe58e"}], "stats": {"total": 323, "additions": 293, "deletions": 30}, "files": [{"sha": "011078c5407299325ec21013a03475c25ae9e002", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -6,7 +6,7 @@ A collection of lints that give helpful tips to newbies and catch oversights.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 57 lints included in this crate:\n+There are 58 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -21,6 +21,7 @@ name\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                 | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                       | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                         | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)         | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)               | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                 | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                             | warn    | using identity operations, e.g. `x + 0` or `y / 1`"}, {"sha": "b88d2c844b0f57fde7ae9cc37ac2313b12ddd49d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -119,6 +119,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n         lifetimes::NEEDLESS_LIFETIMES,\n+        loops::EXPLICIT_COUNTER_LOOP,\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,"}, {"sha": "406fbee0b7c5a42126f8c2a153b12184a22d183c", "filename": "src/loops.rs", "status": "modified", "additions": 209, "deletions": 4, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -1,13 +1,15 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use reexport::*;\n-use rustc_front::visit::{Visitor, walk_expr};\n+use rustc_front::visit::{Visitor, walk_expr, walk_block, walk_decl};\n use rustc::middle::ty;\n+use rustc::middle::def::DefLocal;\n use consts::{constant_simple, Constant};\n-use std::collections::HashSet;\n+use rustc::front::map::Node::{NodeBlock};\n+use std::collections::{HashSet,HashMap};\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n-            in_external_macro, expr_block, span_help_and_lint};\n+            in_external_macro, expr_block, span_help_and_lint, is_integer_literal};\n use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n@@ -29,13 +31,16 @@ declare_lint!{ pub UNUSED_COLLECT, Warn,\n declare_lint!{ pub REVERSE_RANGE_LOOP, Warn,\n                \"Iterating over an empty range, such as `10..0` or `5..5`\" }\n \n+declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n+               \"for-looping with an explicit counter when `_.enumerate()` would do\" }\n+\n #[derive(Copy, Clone)]\n pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n-                    WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP)\n+                    WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP, EXPLICIT_COUNTER_LOOP)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -120,6 +125,35 @@ impl LintPass for LoopsPass {\n                     }\n                 }\n             }\n+\n+            // Look for variables that are incremented once per loop iteration.\n+            let mut visitor = IncrementVisitor { cx: cx, states: HashMap::new(), depth: 0, done: false };\n+            walk_expr(&mut visitor, body);\n+\n+            // For each candidate, check the parent block to see if\n+            // it's initialized to zero at the start of the loop.\n+            let map = &cx.tcx.map;\n+            let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id) );\n+            if let Some(parent_id) = parent_scope {\n+                if let NodeBlock(block) = map.get(parent_id) {\n+                    for (id, _) in visitor.states.iter().filter( |&(_,v)| *v == VarState::IncrOnce) {\n+                        let mut visitor2 = InitializeVisitor { cx: cx, end_expr: expr, var_id: id.clone(),\n+                                                               state: VarState::IncrOnce, name: None,\n+                                                               depth: 0, done: false };\n+                        walk_block(&mut visitor2, block);\n+\n+                        if visitor2.state == VarState::Warn {\n+                            if let Some(name) = visitor2.name {\n+                                span_lint(cx, EXPLICIT_COUNTER_LOOP, expr.span,\n+                                          &format!(\"the variable `{0}` is used as a loop counter. Consider \\\n+                                                    using `for ({0}, item) in {1}.enumerate()` \\\n+                                                    or similar iterators\",\n+                                                   name, snippet(cx, arg.span, \"_\")));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n         }\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches explicit \"match\" instead of \"if let\")\n@@ -270,3 +304,174 @@ fn is_break_expr(expr: &Expr) -> bool {\n         _ => false,\n     }\n }\n+\n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n+#[derive(PartialEq)]\n+enum VarState {\n+    Initial,      // Not examined yet\n+    IncrOnce,     // Incremented exactly once, may be a loop counter\n+    Declared,     // Declared but not (yet) initialized to zero\n+    Warn,\n+    DontWarn\n+}\n+\n+// Scan a for loop for variables that are incremented exactly once.\n+struct IncrementVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>,      // context reference\n+    states: HashMap<NodeId, VarState>,  // incremented variables\n+    depth: u32,                         // depth of conditional expressions\n+    done: bool\n+}\n+\n+impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if self.done {\n+            return;\n+        }\n+\n+        // If node is a variable\n+        if let Some(def_id) = var_def_id(self.cx, expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                let state = self.states.entry(def_id).or_insert(VarState::Initial);\n+\n+                match parent.node {\n+                    ExprAssignOp(op, ref lhs, ref rhs) =>\n+                        if lhs.id == expr.id {\n+                            if op.node == BiAdd && is_integer_literal(rhs, 1) {\n+                                *state = match *state {\n+                                    VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n+                                    _ => VarState::DontWarn\n+                                };\n+                            }\n+                            else {\n+                                // Assigned some other value\n+                                *state = VarState::DontWarn;\n+                            }\n+                        },\n+                    ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprAddrOf(mutability,_) if mutability == MutMutable => *state = VarState::DontWarn,\n+                    _ => ()\n+                }\n+            }\n+        }\n+        // Give up if there are nested loops\n+        else if is_loop(expr) {\n+            self.states.clear();\n+            self.done = true;\n+            return;\n+        }\n+        // Keep track of whether we're inside a conditional expression\n+        else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+// Check whether a variable is initialized to zero at the start of a loop.\n+struct InitializeVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>, // context reference\n+    end_expr: &'v Expr,      // the for loop. Stop scanning here.\n+    var_id: NodeId,\n+    state: VarState,\n+    name: Option<Name>,\n+    depth: u32,              // depth of conditional expressions\n+    done: bool\n+}\n+\n+impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n+    fn visit_decl(&mut self, decl: &'v Decl) {\n+        // Look for declarations of the variable\n+        if let DeclLocal(ref local) = decl.node {\n+            if local.pat.id == self.var_id {\n+                if let PatIdent(_, ref ident, _) = local.pat.node {\n+                    self.name = Some(ident.node.name);\n+\n+                    self.state = if let Some(ref init) = local.init {\n+                        if is_integer_literal(init, 0) {\n+                            VarState::Warn\n+                        } else {\n+                            VarState::Declared\n+                        }\n+                    }\n+                    else {\n+                        VarState::Declared\n+                    }\n+                }\n+            }\n+        }\n+        walk_decl(self, decl);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if self.state == VarState::DontWarn || expr == self.end_expr {\n+            self.done = true;\n+        }\n+        // No need to visit expressions before the variable is\n+        // declared or after we've rejected it.\n+        if self.state == VarState::IncrOnce || self.done {\n+            return;\n+        }\n+\n+        // If node is the desired variable, see how it's used\n+        if var_def_id(self.cx, expr) == Some(self.var_id) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.node {\n+                    ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                        self.state = VarState::DontWarn;\n+                    },\n+                    ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                        self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n+                            VarState::Warn\n+                        } else {\n+                            VarState::DontWarn\n+                        }},\n+                    ExprAddrOf(mutability,_) if mutability == MutMutable => self.state = VarState::DontWarn,\n+                    _ => ()\n+                }\n+            }\n+        }\n+        // If there are other loops between the declaration and the target loop, give up\n+        else if is_loop(expr) {\n+            self.state = VarState::DontWarn;\n+            self.done = true;\n+            return;\n+        }\n+        // Keep track of whether we're inside a conditional expression\n+        else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+fn var_def_id(cx: &Context, expr: &Expr) -> Option<NodeId> {\n+    if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n+        if let DefLocal(node_id) = path_res.base_def {\n+            return Some(node_id)\n+        }\n+    }\n+    None\n+}\n+\n+fn is_loop(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprLoop(..) | ExprWhile(..)  => true,\n+        _ => false\n+    }\n+}\n+\n+fn is_conditional(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprIf(..) | ExprMatch(..) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "63c2082abde0291bcf805cb6b34d916f859e34fc", "filename": "src/misc.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::{Span, Spanned};\n use rustc_front::visit::FnKind;\n use rustc::middle::ty;\n \n-use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty};\n+use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty, is_integer_literal};\n use consts::constant;\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n@@ -183,23 +183,14 @@ impl LintPass for ModuloOne {\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let &Spanned {node: BinOp_::BiRem, ..} = cmp {\n-                if is_lit_one(right) {\n+                if is_integer_literal(right, 1) {\n                     cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             }\n         }\n     }\n }\n \n-fn is_lit_one(expr: &Expr) -> bool {\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(1, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n declare_lint!(pub REDUNDANT_PATTERN, Warn, \"using `name @ _` in a pattern\");\n \n #[derive(Copy,Clone)]"}, {"sha": "97f59a3aadde0ae07133b654c9e6898af9992dc1", "filename": "src/ranges.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::match_type;\n+use utils::{match_type, is_integer_literal};\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -21,7 +21,7 @@ impl LintPass for StepByZero {\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n             if ident.name == \"step_by\" && args.len() == 2 &&\n-                is_range(cx, &args[0]) && is_lit_zero(&args[1]) {\n+                is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\\n                               Consider using `std::iter::repeat()` instead\")\n@@ -37,13 +37,3 @@ fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // Note: RangeTo and RangeFull don't have step_by\n     match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n-\n-fn is_lit_zero(expr: &Expr) -> bool {\n-    // FIXME: use constant folding\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(0, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "01c9adf866c6c2c834e8a37d5d4a83329891e10f", "filename": "src/utils.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -244,6 +244,17 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     inner(ty, 0)\n }\n \n+pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n+{\n+    // FIXME: use constant folding\n+    if let ExprLit(ref spanned) = expr.node {\n+        if let LitInt(v, _) = spanned.node {\n+            return v == value;\n+        }\n+    }\n+    false\n+}\n+\n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n ///     if_let_chain! {"}, {"sha": "d6d73db3c18b85be765d166ed6f8493f34405be0", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/68d4b3af127372c02aab0c2308f5c2bc81fec785/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d4b3af127372c02aab0c2308f5c2bc81fec785/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=68d4b3af127372c02aab0c2308f5c2bc81fec785", "patch": "@@ -14,9 +14,9 @@ impl Unrelated {\n     }\n }\n \n-#[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop)]\n+#[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist)]\n+#[allow(linkedlist,shadow_unrelated)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n@@ -119,4 +119,68 @@ fn main() {\n     let mut out = vec![];\n     vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); //~ERROR you are collect()ing an iterator\n     let _y = vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n+\n+    // Loop with explicit counter variable\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+\n+    let mut _index = 1;\n+    _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+\n+    let mut _index;\n+    _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+    for _v in &vec { _index += 1 } // But this does not warn\n+\n+    // Potential false positives\n+    let mut _index = 0;\n+    _index = 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    _index += 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    if true { _index = 1 }\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    let mut _index = 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index *= 2; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index = 1; _index += 1 }\n+\n+    let mut _index = 0;\n+\n+    for _v in &vec { let mut _index = 0; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1; _index = 0; }\n+\n+    let mut _index = 0;\n+    for _v in &vec { for _x in 0..1 { _index += 1; }; _index += 1 }\n+\n+    let mut _index = 0;\n+    for x in &vec { if *x == 1 { _index += 1 } }\n+\n+    let mut _index = 0;\n+    if true { _index = 1 };\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 1;\n+    if false { _index = 0 };\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    { let mut _x = &mut _index; }\n+    for _v in &vec { _index += 1 }\n }"}]}