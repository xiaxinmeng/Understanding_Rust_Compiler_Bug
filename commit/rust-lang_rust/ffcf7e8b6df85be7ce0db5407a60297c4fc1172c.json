{"sha": "ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmY2Y3ZThiNmRmODViZTdjZTBkYjU0MDdhNjAyOTdjNGZjMTE3MmM=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T05:27:03Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:32:13Z"}, "message": "Moved all Assoc* types to assoc.rs.", "tree": {"sha": "a6911e130c02035564dc75a0f599aa4500f05861", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6911e130c02035564dc75a0f599aa4500f05861"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "html_url": "https://github.com/rust-lang/rust/commit/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e41b052f1f2e036fc70477fd4c61d0a0a3099b", "html_url": "https://github.com/rust-lang/rust/commit/11e41b052f1f2e036fc70477fd4c61d0a0a3099b"}], "stats": {"total": 335, "additions": 173, "deletions": 162}, "files": [{"sha": "d3770fa416b53e0d51fd2dc7b171a2407aaf0e57", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "patch": "@@ -0,0 +1,170 @@\n+pub use self::AssocItemContainer::*;\n+\n+use crate::ty;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Namespace};\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+use super::{TyCtxt, Visibility};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Hash)]\n+pub enum AssocItemContainer {\n+    TraitContainer(DefId),\n+    ImplContainer(DefId),\n+}\n+\n+impl AssocItemContainer {\n+    /// Asserts that this is the `DefId` of an associated item declared\n+    /// in a trait, and returns the trait `DefId`.\n+    pub fn assert_trait(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            _ => bug!(\"associated item has wrong container type: {:?}\", self),\n+        }\n+    }\n+\n+    pub fn id(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            ImplContainer(id) => id,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n+pub struct AssocItem {\n+    pub def_id: DefId,\n+    #[stable_hasher(project(name))]\n+    pub ident: Ident,\n+    pub kind: AssocKind,\n+    pub vis: Visibility,\n+    pub defaultness: hir::Defaultness,\n+    pub container: AssocItemContainer,\n+\n+    /// Whether this is a method with an explicit self\n+    /// as its first parameter, allowing method calls.\n+    pub fn_has_self_parameter: bool,\n+}\n+\n+impl AssocItem {\n+    pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n+        match self.kind {\n+            ty::AssocKind::Fn => {\n+                // We skip the binder here because the binder would deanonymize all\n+                // late-bound regions, and we don't want method signatures to show up\n+                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+                // regions just fine, showing `fn(&MyType)`.\n+                tcx.fn_sig(self.def_id).skip_binder().to_string()\n+            }\n+            ty::AssocKind::Type => format!(\"type {};\", self.ident),\n+            ty::AssocKind::Const => {\n+                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable, Eq, Hash)]\n+pub enum AssocKind {\n+    Const,\n+    Fn,\n+    Type,\n+}\n+\n+impl AssocKind {\n+    pub fn namespace(&self) -> Namespace {\n+        match *self {\n+            ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n+        }\n+    }\n+\n+    pub fn as_def_kind(&self) -> DefKind {\n+        match self {\n+            AssocKind::Const => DefKind::AssocConst,\n+            AssocKind::Fn => DefKind::AssocFn,\n+            AssocKind::Type => DefKind::AssocTy,\n+        }\n+    }\n+}\n+\n+/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n+///\n+/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n+/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n+/// done only on items with the same name.\n+#[derive(Debug, Clone, PartialEq, HashStable)]\n+pub struct AssociatedItems<'tcx> {\n+    pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+}\n+\n+impl<'tcx> AssociatedItems<'tcx> {\n+    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n+        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        AssociatedItems { items }\n+    }\n+\n+    /// Returns a slice of associated items in the order they were defined.\n+    ///\n+    /// New code should avoid relying on definition order. If you need a particular associated item\n+    /// for a known trait, make that trait a lang item instead of indexing this array.\n+    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.iter().map(|(_, v)| *v)\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.items.len()\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n+    pub fn filter_by_name_unhygienic(\n+        &self,\n+        name: Symbol,\n+    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.get_by_key(&name).copied()\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name.\n+    ///\n+    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n+    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n+    /// methods below if you know which item you are looking for.\n+    pub fn filter_by_name(\n+        &'a self,\n+        tcx: TyCtxt<'a>,\n+        ident: Ident,\n+        parent_def_id: DefId,\n+    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kind(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kind: AssocKind,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind == kind)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n+    pub fn find_by_name_and_namespace(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind.namespace() == ns)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+}"}, {"sha": "f380a9b4b81ea887d357f66308b4bd0b859116b2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 162, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcf7e8b6df85be7ce0db5407a60297c4fc1172c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ffcf7e8b6df85be7ce0db5407a60297c4fc1172c", "patch": "@@ -14,6 +14,7 @@ pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n+pub use assoc::*;\n pub use generics::*;\n pub use upvar::*;\n \n@@ -34,13 +35,12 @@ use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, ParallelIterator};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Constness, Node};\n@@ -107,6 +107,7 @@ pub mod trait_def;\n pub mod util;\n pub mod walk;\n \n+mod assoc;\n mod consts;\n mod context;\n mod diagnostics;\n@@ -134,30 +135,6 @@ pub struct ResolverOutputs {\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable, Hash)]\n-pub enum AssocItemContainer {\n-    TraitContainer(DefId),\n-    ImplContainer(DefId),\n-}\n-\n-impl AssocItemContainer {\n-    /// Asserts that this is the `DefId` of an associated item declared\n-    /// in a trait, and returns the trait `DefId`.\n-    pub fn assert_trait(&self) -> DefId {\n-        match *self {\n-            TraitContainer(id) => id,\n-            _ => bug!(\"associated item has wrong container type: {:?}\", self),\n-        }\n-    }\n-\n-    pub fn id(&self) -> DefId {\n-        match *self {\n-            TraitContainer(id) => id,\n-            ImplContainer(id) => id,\n-        }\n-    }\n-}\n-\n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n /// bounds / where-clauses).\n@@ -182,142 +159,6 @@ pub enum ImplPolarity {\n     Reservation,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n-pub struct AssocItem {\n-    pub def_id: DefId,\n-    #[stable_hasher(project(name))]\n-    pub ident: Ident,\n-    pub kind: AssocKind,\n-    pub vis: Visibility,\n-    pub defaultness: hir::Defaultness,\n-    pub container: AssocItemContainer,\n-\n-    /// Whether this is a method with an explicit self\n-    /// as its first parameter, allowing method calls.\n-    pub fn_has_self_parameter: bool,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug, HashStable, Eq, Hash)]\n-pub enum AssocKind {\n-    Const,\n-    Fn,\n-    Type,\n-}\n-\n-impl AssocKind {\n-    pub fn namespace(&self) -> Namespace {\n-        match *self {\n-            ty::AssocKind::Type => Namespace::TypeNS,\n-            ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n-        }\n-    }\n-\n-    pub fn as_def_kind(&self) -> DefKind {\n-        match self {\n-            AssocKind::Const => DefKind::AssocConst,\n-            AssocKind::Fn => DefKind::AssocFn,\n-            AssocKind::Type => DefKind::AssocTy,\n-        }\n-    }\n-}\n-\n-impl AssocItem {\n-    pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n-        match self.kind {\n-            ty::AssocKind::Fn => {\n-                // We skip the binder here because the binder would deanonymize all\n-                // late-bound regions, and we don't want method signatures to show up\n-                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n-                // regions just fine, showing `fn(&MyType)`.\n-                tcx.fn_sig(self.def_id).skip_binder().to_string()\n-            }\n-            ty::AssocKind::Type => format!(\"type {};\", self.ident),\n-            ty::AssocKind::Const => {\n-                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n-            }\n-        }\n-    }\n-}\n-\n-/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n-///\n-/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n-/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n-/// done only on items with the same name.\n-#[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssociatedItems<'tcx> {\n-    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n-}\n-\n-impl<'tcx> AssociatedItems<'tcx> {\n-    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n-    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n-        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n-        AssociatedItems { items }\n-    }\n-\n-    /// Returns a slice of associated items in the order they were defined.\n-    ///\n-    /// New code should avoid relying on definition order. If you need a particular associated item\n-    /// for a known trait, make that trait a lang item instead of indexing this array.\n-    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.iter().map(|(_, v)| *v)\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.items.len()\n-    }\n-\n-    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n-    pub fn filter_by_name_unhygienic(\n-        &self,\n-        name: Symbol,\n-    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(&name).copied()\n-    }\n-\n-    /// Returns an iterator over all associated items with the given name.\n-    ///\n-    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n-    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n-    /// methods below if you know which item you are looking for.\n-    pub fn filter_by_name(\n-        &'a self,\n-        tcx: TyCtxt<'a>,\n-        ident: Ident,\n-        parent_def_id: DefId,\n-    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-\n-    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n-    pub fn find_by_name_and_kind(\n-        &self,\n-        tcx: TyCtxt<'_>,\n-        ident: Ident,\n-        kind: AssocKind,\n-        parent_def_id: DefId,\n-    ) -> Option<&ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(|item| item.kind == kind)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-\n-    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n-    pub fn find_by_name_and_namespace(\n-        &self,\n-        tcx: TyCtxt<'_>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_def_id: DefId,\n-    ) -> Option<&ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(|item| item.kind.namespace() == ns)\n-            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates)."}]}