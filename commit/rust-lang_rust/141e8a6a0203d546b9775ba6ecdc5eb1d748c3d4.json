{"sha": "141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MWU4YTZhMDIwM2Q1NDZiOTc3NWJhNmVjZGM1ZWIxZDc0OGMzZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-12T05:02:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-12T05:02:10Z"}, "message": "Auto merge of #41716 - nikomatsakis:issue-41677, r=arielb1\n\nenforce WF conditions after generalizing\n\nAdd a `WF(T')` obligation after generalizing `T` to `T'`, if `T'` contains an unconstrained type variable in a bivariant context.\n\nFixes #41677.\n\nBeta nominating -- regression.\n\nr? @arielb1", "tree": {"sha": "f1f296764342e7ba6dfbb1731351d1586ac53924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1f296764342e7ba6dfbb1731351d1586ac53924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "html_url": "https://github.com/rust-lang/rust/commit/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39bcd6f425426bfacd7de9fe0378df4bd9263d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/39bcd6f425426bfacd7de9fe0378df4bd9263d00", "html_url": "https://github.com/rust-lang/rust/commit/39bcd6f425426bfacd7de9fe0378df4bd9263d00"}, {"sha": "2490ee5080ef1810fc137c676f4906d65a407dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/2490ee5080ef1810fc137c676f4906d65a407dde", "html_url": "https://github.com/rust-lang/rust/commit/2490ee5080ef1810fc137c676f4906d65a407dde"}], "stats": {"total": 330, "additions": 249, "deletions": 81}, "files": [{"sha": "82578f6aa61d5a78ca3fb793cc582a1179c2ff87", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 143, "deletions": 41, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -42,9 +42,8 @@ use super::{MiscVariable, TypeTrace};\n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n-use ty::fold::TypeFoldable;\n-use ty::relate::{RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -207,11 +206,16 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let b_ty = self.generalize(a_ty, b_vid, dir == EqTo)?;\n+        let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n         debug!(\"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n                a_ty, dir, b_vid, b_ty);\n         self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n \n+        if needs_wf {\n+            self.obligations.push(Obligation::new(self.trace.cause.clone(),\n+                                                  ty::Predicate::WellFormed(b_ty)));\n+        }\n+\n         // Finally, relate `b_ty` to `a_ty`, as described in previous comment.\n         //\n         // FIXME(#16847): This code is non-ideal because all these subtype\n@@ -230,50 +234,125 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n \n     /// Attempts to generalize `ty` for the type variable `for_vid`.\n     /// This checks for cycle -- that is, whether the type `ty`\n-    /// references `for_vid`. If `is_eq_relation` is false, it will\n-    /// also replace all regions/unbound-type-variables with fresh\n-    /// variables. Returns `TyError` in the case of a cycle, `Ok`\n-    /// otherwise.\n+    /// references `for_vid`. The `dir` is the \"direction\" for which we\n+    /// a performing the generalization (i.e., are we producing a type\n+    /// that can be used as a supertype etc).\n     ///\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n-                  is_eq_relation: bool)\n-                  -> RelateResult<'tcx, Ty<'tcx>>\n+                  dir: RelationDir)\n+                  -> RelateResult<'tcx, Generalization<'tcx>>\n     {\n+        // Determine the ambient variance within which `ty` appears.\n+        // The surrounding equation is:\n+        //\n+        //     ty [op] ty2\n+        //\n+        // where `op` is either `==`, `<:`, or `:>`. This maps quite\n+        // naturally.\n+        let ambient_variance = match dir {\n+            RelationDir::EqTo => ty::Invariant,\n+            RelationDir::SubtypeOf => ty::Covariant,\n+            RelationDir::SupertypeOf => ty::Contravariant,\n+        };\n+\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n-            is_eq_relation: is_eq_relation,\n-            cycle_detected: false\n+            ambient_variance: ambient_variance,\n+            needs_wf: false,\n         };\n-        let u = ty.fold_with(&mut generalize);\n-        if generalize.cycle_detected {\n-            Err(TypeError::CyclicTy)\n-        } else {\n-            Ok(u)\n-        }\n+\n+        let ty = generalize.relate(&ty, &ty)?;\n+        let needs_wf = generalize.needs_wf;\n+        Ok(Generalization { ty, needs_wf })\n     }\n }\n \n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n     for_vid_sub_root: ty::TyVid,\n-    is_eq_relation: bool,\n-    cycle_detected: bool,\n+    ambient_variance: ty::Variance,\n+    needs_wf: bool, // see the field `needs_wf` in `Generalization`\n }\n \n-impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+/// Result from a generalization operation. This includes\n+/// not only the generalized type, but also a bool flag\n+/// indicating whether further WF checks are needed.q\n+struct Generalization<'tcx> {\n+    ty: Ty<'tcx>,\n+\n+    /// If true, then the generalized type may not be well-formed,\n+    /// even if the source type is well-formed, so we should add an\n+    /// additional check to enforce that it is. This arises in\n+    /// particular around 'bivariant' type parameters that are only\n+    /// constrained by a where-clause. As an example, imagine a type:\n+    ///\n+    ///     struct Foo<A, B> where A: Iterator<Item=B> {\n+    ///         data: A\n+    ///     }\n+    ///\n+    /// here, `A` will be covariant, but `B` is\n+    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n+    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n+    /// then after generalization we will wind up with a type like\n+    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n+    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n+    /// <: ?C`, but no particular relationship between `?B` and `?D`\n+    /// (after all, we do not know the variance of the normalized form\n+    /// of `A::Item` with respect to `A`). If we do nothing else, this\n+    /// may mean that `?D` goes unconstrained (as in #41677).  So, in\n+    /// this scenario where we create a new type variable in a\n+    /// bivariant context, we set the `needs_wf` flag to true. This\n+    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n+    /// holds, which in turn implies that `?C::Item == ?D`. So once\n+    /// `?C` is constrained, that should suffice to restrict `?D`.\n+    needs_wf: bool,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"Generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'tcx>\n+    {\n+        Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n+    {\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        let result = self.relate(a, b);\n+        self.ambient_variance = old_ambient_variance;\n+        result\n+    }\n+\n+    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n+\n         // Check to see whether the type we are genealizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n@@ -286,41 +365,63 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n-                    self.cycle_detected = true;\n-                    self.tcx().types.err\n+                    return Err(TypeError::CyclicTy);\n                 } else {\n                     match variables.probe_root(vid) {\n                         Some(u) => {\n                             drop(variables);\n-                            self.fold_ty(u)\n+                            self.relate(&u, &u)\n                         }\n                         None => {\n-                            if !self.is_eq_relation {\n-                                let origin = variables.origin(vid);\n-                                let new_var_id = variables.new_var(false, origin, None);\n-                                let u = self.tcx().mk_var(new_var_id);\n-                                debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n-                                       vid, u);\n-                                u\n-                            } else {\n-                                t\n+                            match self.ambient_variance {\n+                                // Invariant: no need to make a fresh type variable.\n+                                ty::Invariant => return Ok(t),\n+\n+                                // Bivariant: make a fresh var, but we\n+                                // may need a WF predicate. See\n+                                // comment on `needs_wf` field for\n+                                // more info.\n+                                ty::Bivariant => self.needs_wf = true,\n+\n+                                // Co/contravariant: this will be\n+                                // sufficiently constrained later on.\n+                                ty::Covariant | ty::Contravariant => (),\n                             }\n+\n+                            let origin = variables.origin(vid);\n+                            let new_var_id = variables.new_var(false, origin, None);\n+                            let u = self.tcx().mk_var(new_var_id);\n+                            debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n+                                   vid, u);\n+                            return Ok(u);\n                         }\n                     }\n                 }\n             }\n+            ty::TyInfer(ty::IntVar(_)) |\n+            ty::TyInfer(ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(t)\n+            }\n             _ => {\n-                t.super_fold_with(self)\n+                relate::super_relate_tys(self, t, t)\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn regions(&mut self, r: ty::Region<'tcx>, r2: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        assert_eq!(r, r2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n+\n         match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n             ty::ReLateBound(..) |\n-            ty::ReErased => { return r; }\n+            ty::ReErased => {\n+                return Ok(r);\n+            }\n \n             // Early-bound regions should really have been substituted away before\n             // we get to this point.\n@@ -342,15 +443,16 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReFree(..) => {\n-                if self.is_eq_relation {\n-                    return r;\n+                match self.ambient_variance {\n+                    ty::Invariant => return Ok(r),\n+                    ty::Bivariant | ty::Covariant | ty::Contravariant => (),\n                 }\n             }\n         }\n \n         // FIXME: This is non-ideal because we don't give a\n         // very descriptive origin for this region variable.\n-        self.infcx.next_region_var(MiscVariable(self.span))\n+        Ok(self.infcx.next_region_var(MiscVariable(self.span)))\n     }\n }\n "}, {"sha": "f5d510c11ae9dd64d1f48b4c3d021b7f29c6e334", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -330,6 +330,66 @@ pub struct CrateVariancesMap {\n     pub empty_variance: Rc<Vec<ty::Variance>>,\n }\n \n+impl Variance {\n+    /// `a.xform(b)` combines the variance of a context with the\n+    /// variance of a type with the following meaning.  If we are in a\n+    /// context with variance `a`, and we encounter a type argument in\n+    /// a position with variance `b`, then `a.xform(b)` is the new\n+    /// variance with which the argument appears.\n+    ///\n+    /// Example 1:\n+    ///\n+    ///     *mut Vec<i32>\n+    ///\n+    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n+    /// invariant with respect to `T`, so the variance in which the\n+    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n+    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n+    /// respect to its type argument `T`, and hence the variance of\n+    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n+    /// (again) in `Invariant`.\n+    ///\n+    /// Example 2:\n+    ///\n+    ///     fn(*const Vec<i32>, *mut Vec<i32)\n+    ///\n+    /// The ambient variance is covariant. A `fn` type is\n+    /// contravariant with respect to its parameters, so the variance\n+    /// within which both pointer types appear is\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`.  `*const\n+    /// T` is covariant with respect to `T`, so the variance within\n+    /// which the first `Vec<i32>` appears is\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`.  The same\n+    /// is true for its `i32` argument. In the `*mut T` case, the\n+    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n+    /// and hence the outermost type is `Invariant` with respect to\n+    /// `Vec<i32>` (and its `i32` argument).\n+    ///\n+    /// Source: Figure 1 of \"Taming the Wildcards:\n+    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n+    pub fn xform(self, v: ty::Variance) -> ty::Variance {\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (ty::Covariant, ty::Covariant) => ty::Covariant,\n+            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n+            (ty::Covariant, ty::Invariant) => ty::Invariant,\n+            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n+            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n+            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n+            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (ty::Invariant, _) => ty::Invariant,\n+\n+            // Figure 1, column 4.\n+            (ty::Bivariant, _) => ty::Bivariant,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise."}, {"sha": "cb2ee7dd1bcda5c7b89bcc4fda7a95e6d543f81c", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -27,7 +27,6 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::xform::*;\n \n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,"}, {"sha": "7106ca4d420a86100bebc22a21d4e64a8f98dd81", "filename": "src/librustc_typeck/variance/xform.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -10,35 +10,6 @@\n \n use rustc::ty;\n \n-pub trait Xform {\n-    fn xform(self, v: Self) -> Self;\n-}\n-\n-impl Xform for ty::Variance {\n-    fn xform(self, v: ty::Variance) -> ty::Variance {\n-        // \"Variance transformation\", Figure 1 of The Paper\n-        match (self, v) {\n-            // Figure 1, column 1.\n-            (ty::Covariant, ty::Covariant) => ty::Covariant,\n-            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n-            (ty::Covariant, ty::Invariant) => ty::Invariant,\n-            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 2.\n-            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n-            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n-            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n-            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 3.\n-            (ty::Invariant, _) => ty::Invariant,\n-\n-            // Figure 1, column 4.\n-            (ty::Bivariant, _) => ty::Bivariant,\n-        }\n-    }\n-}\n-\n pub fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n     // Greatest lower bound of the variance lattice as\n     // defined in The Paper:"}, {"sha": "646ae8183a20ce8c93047a4dfc4d5203162f97e6", "filename": "src/test/compile-fail/region-invariant-static-error-reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-invariant-static-error-reporting.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -13,9 +13,8 @@\n // over time, but this test used to exhibit some pretty bogus messages\n // that were not remotely helpful.\n \n-// error-pattern:cannot infer\n-// error-pattern:cannot outlive the lifetime 'a\n-// error-pattern:must be valid for the static lifetime\n+// error-pattern:the lifetime 'a\n+// error-pattern:the static lifetime\n \n struct Invariant<'a>(Option<&'a mut &'a mut ()>);\n "}, {"sha": "948fb7e1ef6c29759aed6ba0ddd3ac5db4349471", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR cannot infer an appropriate lifetime\n+    x //~ ERROR lifetime bound not satisfied\n      //~^ ERROR cannot infer an appropriate lifetime\n }\n "}, {"sha": "1795ac95358d7c6c29c2bde494f0212b16ad6076", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -21,15 +21,15 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n     // Previously OK:\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "ad059a467f570bb2d4b9e5ef872d907ff1f8522c", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -22,14 +22,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n     where 'max : 'min\n {\n     // Previously OK, now an error as traits are invariant.\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "9edb510b826a12df92df2fe2ea40966ca9ac98fa", "filename": "src/test/compile-fail/variance-invariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -18,14 +18,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR cannot infer an appropriate lifetime\n+    v //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "d014382ca39b6cb10680c6df4b36ccada6a1b63d", "filename": "src/test/run-pass/issue-41677.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Frun-pass%2Fissue-41677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4/src%2Ftest%2Frun-pass%2Fissue-41677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41677.rs?ref=141e8a6a0203d546b9775ba6ecdc5eb1d748c3d4", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41677. The local variable was winding up with\n+// a type `Receiver<?T, H>` where `?T` was unconstrained, because we\n+// failed to enforce the WF obligations and `?T` is a bivariant type\n+// parameter position.\n+\n+#![allow(unused_variables, dead_code)]\n+\n+use std::marker::PhantomData;\n+\n+trait Handle {\n+    type Inner;\n+}\n+\n+struct ResizingHandle<H>(PhantomData<H>);\n+impl<H> Handle for ResizingHandle<H> {\n+    type Inner = H;\n+}\n+\n+struct Receiver<T, H: Handle<Inner=T>>(PhantomData<H>);\n+\n+fn channel<T>(size: usize) -> Receiver<T, ResizingHandle<T>> {\n+    let rx = Receiver(PhantomData);\n+    rx\n+}\n+\n+fn main() {\n+}"}]}