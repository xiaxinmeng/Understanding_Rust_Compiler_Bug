{"sha": "31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDk1ZDdlMzc5OWUxZTlkNDAzYWM4OGZhMTBiMzkwNmViOGJhMzc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-01-16T12:21:10Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-01-20T11:00:43Z"}, "message": "Make sure that all upstream generics get re-exported from Rust dylibs.", "tree": {"sha": "35c855134e86257e4a49371006526a9a2c392ad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c855134e86257e4a49371006526a9a2c392ad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "html_url": "https://github.com/rust-lang/rust/commit/31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900811e43047fc5593f39b0363373530b02c87e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/900811e43047fc5593f39b0363373530b02c87e0", "html_url": "https://github.com/rust-lang/rust/commit/900811e43047fc5593f39b0363373530b02c87e0"}], "stats": {"total": 188, "additions": 140, "deletions": 48}, "files": [{"sha": "a349b34eb1a0c18a45dd339565a99cf5f9eb02e8", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -32,7 +32,9 @@ pub enum ExportedSymbol<'tcx> {\n }\n \n impl<'tcx> ExportedSymbol<'tcx> {\n-    pub fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n+    /// This is the symbol name of an instance if it is instantiated in the\n+    /// local crate.\n+    pub fn symbol_name_for_local_instance(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => tcx.symbol_name(ty::Instance::mono(tcx, def_id)),\n             ExportedSymbol::Generic(def_id, substs) => {\n@@ -50,9 +52,22 @@ impl<'tcx> ExportedSymbol<'tcx> {\n                 }\n                 ExportedSymbol::Generic(..) | ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n             },\n-            ExportedSymbol::Generic(..) => match *other {\n+            ExportedSymbol::Generic(self_def_id, self_substs) => match *other {\n                 ExportedSymbol::NonGeneric(_) => cmp::Ordering::Greater,\n-                ExportedSymbol::Generic(..) => self.symbol_name(tcx).cmp(&other.symbol_name(tcx)),\n+                ExportedSymbol::Generic(other_def_id, other_substs) => {\n+                    // We compare the symbol names because they are cached as query\n+                    // results which makes them relatively cheap to access repeatedly.\n+                    //\n+                    // It might be even faster to build a local cache of stable IDs\n+                    // for sorting. Exported symbols are really only sorted once\n+                    // in order to make the `exported_symbols` query result stable.\n+                    let self_symbol_name =\n+                        tcx.symbol_name(ty::Instance::new(self_def_id, self_substs));\n+                    let other_symbol_name =\n+                        tcx.symbol_name(ty::Instance::new(other_def_id, other_substs));\n+\n+                    self_symbol_name.cmp(&other_symbol_name)\n+                }\n                 ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n             },\n             ExportedSymbol::NoDefId(self_symbol_name) => match *other {"}, {"sha": "b7aef0c44d9ee397ae59454f98b08161bd590d8f", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -557,6 +557,9 @@ rustc_queries! {\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n+        /// The `symbol_name` query provides the symbol name for calling a\n+        /// given instance from the local crate. In particular, it will also\n+        /// look up the correct symbol name of instances from upstream crates.\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n             no_force\n             desc { \"computing the symbol for `{}`\", key }\n@@ -971,6 +974,11 @@ rustc_queries! {\n     }\n \n     Linking {\n+        /// The list of symbols exported from the given crate.\n+        ///\n+        /// - All names contained in `exported_symbols(cnum)` are guaranteed to\n+        ///   correspond to a publicly visible symbol in `cnum` machine code.\n+        /// - The `exported_symbols` sets of different crates do not intersect.\n         query exported_symbols(_: CrateNum)\n             -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n             desc { \"exported_symbols\" }"}, {"sha": "4679f6501336cfcda6e2fff8185a57a4327a0712", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -1103,7 +1103,11 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n     for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n-            symbols.push(symbol.symbol_name(tcx).to_string());\n+            symbols.push(symbol_export::symbol_name_for_instance_in_crate(\n+                tcx,\n+                symbol,\n+                LOCAL_CRATE,\n+            ));\n         }\n     }\n \n@@ -1124,12 +1128,7 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n                     continue;\n                 }\n \n-                // FIXME rust-lang/rust#64319, rust-lang/rust#64872:\n-                // We want to block export of generics from dylibs,\n-                // but we must fix rust-lang/rust#65890 before we can\n-                // do that robustly.\n-\n-                symbols.push(symbol.symbol_name(tcx).to_string());\n+                symbols.push(symbol_export::symbol_name_for_instance_in_crate(tcx, symbol, cnum));\n             }\n         }\n     }"}, {"sha": "bd44b4a38fd58c0c3572a23462214fab35b14610", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -8,6 +8,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::Instance;\n use rustc::ty::{SymbolName, TyCtxt};\n+use rustc_codegen_utils::symbol_names;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -358,3 +359,32 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         SymbolExportLevel::Rust\n     }\n }\n+\n+/// This is the symbol name of the given instance instantiated in a specific crate.\n+pub fn symbol_name_for_instance_in_crate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    symbol: ExportedSymbol<'tcx>,\n+    instantiating_crate: CrateNum,\n+) -> String {\n+    // If this is something instantiated in the local crate then we might\n+    // already have cached the name as a query result.\n+    if instantiating_crate == LOCAL_CRATE {\n+        return symbol.symbol_name_for_local_instance(tcx).to_string();\n+    }\n+\n+    // This is something instantiated in an upstream crate, so we have to use\n+    // the slower (because uncached) version of computing the symbol name.\n+    match symbol {\n+        ExportedSymbol::NonGeneric(def_id) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::mono(tcx, def_id),\n+            instantiating_crate,\n+        ),\n+        ExportedSymbol::Generic(def_id, substs) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::new(def_id, substs),\n+            instantiating_crate,\n+        ),\n+        ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n+    }\n+}"}, {"sha": "049faff7c49ee69609e4d191968c84fbcf90d8da", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -2,7 +2,7 @@ use super::command::Command;\n use super::link::{self, get_linker, remove};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n-use super::symbol_export::ExportedSymbols;\n+use super::symbol_export::{symbol_name_for_instance_in_crate, ExportedSymbols};\n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n     RLIB_BYTECODE_EXTENSION,\n@@ -956,7 +956,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             let symbols = tcx\n                 .exported_symbols(cnum)\n                 .iter()\n-                .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                .map(|&(s, lvl)| (symbol_name_for_instance_in_crate(tcx, s, cnum), lvl))\n                 .collect();\n             Arc::new(symbols)\n         };"}, {"sha": "96a74f96fcf6054ba64b5dbb3721e30d949d1251", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31095d7e3799e1e9d403ac88fa10b3906eb8ba37/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=31095d7e3799e1e9d403ac88fa10b3906eb8ba37", "patch": "@@ -91,8 +91,9 @@ use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::query::Providers;\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::Node;\n \n use rustc_span::symbol::Symbol;\n@@ -102,15 +103,70 @@ use log::debug;\n mod legacy;\n mod v0;\n \n+/// This function computes the symbol name for the given `instance` and the\n+/// given instantiating crate. That is, if you know that instance X is\n+/// instantiated in crate Y, this is the symbol name this instance would have.\n+pub fn symbol_name_for_instance_in_crate(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: CrateNum,\n+) -> String {\n+    compute_symbol_name(tcx, instance, || instantiating_crate)\n+}\n+\n pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        symbol_name: |tcx, instance| ty::SymbolName { name: symbol_name(tcx, instance) },\n+    *providers = Providers { symbol_name: symbol_name_provider, ..*providers };\n+}\n \n-        ..*providers\n-    };\n+// The `symbol_name` query provides the symbol name for calling a given\n+// instance from the local crate. In particular, it will also look up the\n+// correct symbol name of instances from upstream crates.\n+fn symbol_name_provider(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+    let symbol_name = compute_symbol_name(tcx, instance, || {\n+        // This closure determines the instantiating crate for instances that\n+        // need an instantiating-crate-suffix for their symbol name, in order\n+        // to differentiate between local copies.\n+        //\n+        // For generics we might find re-usable upstream instances. For anything\n+        // else we rely on their being a local copy available.\n+\n+        if is_generic(instance.substs) {\n+            let def_id = instance.def_id();\n+\n+            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n+                // If we are re-using a monomorphization from another crate,\n+                // we have to compute the symbol hash accordingly.\n+                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n+\n+                upstream_monomorphizations\n+                    .and_then(|monos| monos.get(&instance.substs).cloned())\n+                    // If there is no instance available upstream, there'll be\n+                    // one in the current crate.\n+                    .unwrap_or(LOCAL_CRATE)\n+            } else {\n+                // For generic functions defined in the current crate, there\n+                // can be no upstream instances. Also, if we don't share\n+                // generics, we'll instantiate a local copy too.\n+                LOCAL_CRATE\n+            }\n+        } else {\n+            // For non-generic things that need to avoid naming conflicts, we\n+            // always instantiate a copy in the local crate.\n+            LOCAL_CRATE\n+        }\n+    });\n+\n+    ty::SymbolName { name: Symbol::intern(&symbol_name) }\n }\n \n-fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n+/// Computes the symbol name for the given instance. This function will call\n+/// `compute_instantiating_crate` if it needs to factor the instantiating crate\n+/// into the symbol name.\n+fn compute_symbol_name(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    compute_instantiating_crate: impl FnOnce() -> CrateNum,\n+) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -121,11 +177,11 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n+            return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n+            return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n     }\n \n@@ -162,29 +218,28 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n             || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id)\n         {\n             if let Some(name) = attrs.link_name {\n-                return name;\n+                return name.to_string();\n             }\n-            return tcx.item_name(def_id);\n+            return tcx.item_name(def_id).to_string();\n         }\n     }\n \n     if let Some(name) = attrs.export_name {\n         // Use provided name\n-        return name;\n+        return name.to_string();\n     }\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id);\n+        return tcx.item_name(def_id).to_string();\n     }\n \n-    let is_generic = substs.non_erasable_generics().next().is_some();\n     let avoid_cross_crate_conflicts =\n         // If this is an instance of a generic function, we also hash in\n         // the ID of the instantiating crate. This avoids symbol conflicts\n         // in case the same instances is emitted in two crates of the same\n         // project.\n-        is_generic ||\n+        is_generic(substs) ||\n \n         // If we're dealing with an instance of a function that's inlined from\n         // another crate but we're marking it as globally shared to our\n@@ -197,25 +252,8 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n             _ => false,\n         };\n \n-    let instantiating_crate = if avoid_cross_crate_conflicts {\n-        Some(if is_generic {\n-            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                // If we are re-using a monomorphization from another crate,\n-                // we have to compute the symbol hash accordingly.\n-                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                upstream_monomorphizations\n-                    .and_then(|monos| monos.get(&substs).cloned())\n-                    .unwrap_or(LOCAL_CRATE)\n-            } else {\n-                LOCAL_CRATE\n-            }\n-        } else {\n-            LOCAL_CRATE\n-        })\n-    } else {\n-        None\n-    };\n+    let instantiating_crate =\n+        if avoid_cross_crate_conflicts { Some(compute_instantiating_crate()) } else { None };\n \n     // Pick the crate responsible for the symbol mangling version, which has to:\n     // 1. be stable for each instance, whether it's being defined or imported\n@@ -232,10 +270,12 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n         tcx.symbol_mangling_version(mangling_version_crate)\n     };\n \n-    let mangled = match mangling_version {\n+    match mangling_version {\n         SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate),\n         SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n-    };\n+    }\n+}\n \n-    Symbol::intern(&mangled)\n+fn is_generic(substs: SubstsRef<'_>) -> bool {\n+    substs.non_erasable_generics().next().is_some()\n }"}]}