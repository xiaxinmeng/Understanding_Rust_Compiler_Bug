{"sha": "531752f39ab662a73e7ab580bf8a06c6bfeef486", "node_id": "C_kwDOAAsO6NoAKDUzMTc1MmYzOWFiNjYyYTczZTdhYjU4MGJmOGEwNmM2YmZlZWY0ODY", "commit": {"author": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2022-03-28T12:34:16Z"}, "committer": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2022-06-15T08:28:57Z"}, "message": "Mitigate MMIO stale data vulnerabilities\n\nIntel Security Advisory: https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00615.html", "tree": {"sha": "0f1d0066e3c5e1c2e47fc5ffc12c64b3cc663194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f1d0066e3c5e1c2e47fc5ffc12c64b3cc663194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/531752f39ab662a73e7ab580bf8a06c6bfeef486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/531752f39ab662a73e7ab580bf8a06c6bfeef486", "html_url": "https://github.com/rust-lang/rust/commit/531752f39ab662a73e7ab580bf8a06c6bfeef486", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/531752f39ab662a73e7ab580bf8a06c6bfeef486/comments", "author": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab3a2a024fb58d5ad3e893f1d5694468b187b2d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab3a2a024fb58d5ad3e893f1d5694468b187b2d3", "html_url": "https://github.com/rust-lang/rust/commit/ab3a2a024fb58d5ad3e893f1d5694468b187b2d3"}], "stats": {"total": 100, "additions": 98, "deletions": 2}, "files": [{"sha": "b37e9b257edb4394a11a725ccf3e57aa02234836", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/531752f39ab662a73e7ab580bf8a06c6bfeef486/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531752f39ab662a73e7ab580bf8a06c6bfeef486/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=531752f39ab662a73e7ab580bf8a06c6bfeef486", "patch": "@@ -1,13 +1,15 @@\n #![allow(unused)]\n \n+use crate::arch::asm;\n use crate::cell::UnsafeCell;\n+use crate::convert::TryInto;\n use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\n use crate::ptr::{self, NonNull};\n use crate::slice;\n use crate::slice::SliceIndex;\n \n-use super::super::mem::is_user_range;\n+use super::super::mem::{is_enclave_range, is_user_range};\n use fortanix_sgx_abi::*;\n \n /// A type that can be safely read from or written to userspace.\n@@ -300,6 +302,100 @@ where\n     }\n }\n \n+/// Copies `len` bytes of data from enclave pointer `src` to userspace `dst`\n+///\n+/// This function mitigates stale data vulnerabilities\n+/// https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00615.html\n+///\n+/// # Panics\n+/// This function panics if:\n+///\n+/// * The `src` pointer is null\n+/// * The `dst` pointer is null\n+/// * The `src` memory range is not in enclave memory\n+/// * The `dst` memory range is not in user memory\n+unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+    unsafe fn copy_bytewise_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+        unsafe {\n+            let seg_sel: u16 = 0;\n+            for off in 0..len {\n+                asm!(\"\n+                    mov %ds, ({seg_sel})\n+                    verw ({seg_sel})\n+                    movb {val}, ({dst})\n+                    mfence\n+                    lfence\n+                     \",\n+                    val = in(reg_byte) *src.offset(off as isize),\n+                    dst = in(reg) dst.offset(off as isize),\n+                    seg_sel = in(reg) &seg_sel,\n+                    options(nostack, att_syntax)\n+                );\n+            }\n+        }\n+    }\n+\n+    unsafe fn copy_aligned_quadwords_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+        unsafe {\n+            asm!(\n+                \"rep movsq (%rsi), (%rdi)\",\n+                inout(\"rcx\") len / 8 => _,\n+                inout(\"rdi\") dst => _,\n+                inout(\"rsi\") src => _,\n+                options(att_syntax, nostack, preserves_flags)\n+            );\n+        }\n+    }\n+    assert!(!src.is_null());\n+    assert!(!dst.is_null());\n+    assert!(is_enclave_range(src, len));\n+    assert!(is_user_range(dst, len));\n+    assert!(len < isize::MAX as usize);\n+    assert!(!(src as usize).overflowing_add(len).1);\n+    assert!(!(dst as usize).overflowing_add(len).1);\n+\n+    if len < 8 {\n+        // Can't align on 8 byte boundary: copy safely byte per byte\n+        unsafe {\n+            copy_bytewise_to_userspace(src, dst, len);\n+        }\n+    } else if len % 8 == 0 && dst as usize % 8 == 0 {\n+        // Copying 8-byte aligned quadwords: copy quad word per quad word\n+        unsafe {\n+            copy_aligned_quadwords_to_userspace(src, dst, len);\n+        }\n+    } else {\n+        // Split copies into three parts:\n+        //   +--------+\n+        //   | small0 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        //   |   big  | Chunk 8-byte aligned, and size a multiple of 8 bytes\n+        //   +--------+\n+        //   | small1 | Chunk smaller than 8 bytes\n+        //   +--------+\n+\n+        unsafe {\n+            // Copy small0\n+            let small0_size = (8 - dst as usize % 8) as u8;\n+            let small0_src = src;\n+            let small0_dst = dst;\n+            copy_bytewise_to_userspace(small0_src as _, small0_dst, small0_size as _);\n+\n+            // Copy big\n+            let small1_size = ((len - small0_size as usize) % 8) as u8;\n+            let big_size = len - small0_size as usize - small1_size as usize;\n+            let big_src = src.offset(small0_size as _);\n+            let big_dst = dst.offset(small0_size as _);\n+            copy_aligned_quadwords_to_userspace(big_src as _, big_dst, big_size);\n+\n+            // Copy small1\n+            let small1_src = src.offset(big_size as isize + small0_size as isize);\n+            let small1_dst = dst.offset(big_size as isize + small0_size as isize);\n+            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size as _);\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T>\n where\n@@ -348,7 +444,7 @@ where\n     pub fn copy_from_enclave(&mut self, val: &T) {\n         unsafe {\n             assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n-            ptr::copy(\n+            copy_to_userspace(\n                 val as *const T as *const u8,\n                 self.0.get() as *mut T as *mut u8,\n                 mem::size_of_val(val),"}]}