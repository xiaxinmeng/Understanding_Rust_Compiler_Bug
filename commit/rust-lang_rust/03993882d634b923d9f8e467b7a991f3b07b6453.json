{"sha": "03993882d634b923d9f8e467b7a991f3b07b6453", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOTkzODgyZDYzNGI5MjNkOWY4ZTQ2N2I3YTk5MWYzYjA3YjY0NTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T11:23:20Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:52Z"}, "message": "trans: Handle calls for all ABIs through FnType.", "tree": {"sha": "dbc55e81296983895e6dfcfca2904dc7bbf5ea39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbc55e81296983895e6dfcfca2904dc7bbf5ea39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03993882d634b923d9f8e467b7a991f3b07b6453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03993882d634b923d9f8e467b7a991f3b07b6453", "html_url": "https://github.com/rust-lang/rust/commit/03993882d634b923d9f8e467b7a991f3b07b6453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03993882d634b923d9f8e467b7a991f3b07b6453/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "html_url": "https://github.com/rust-lang/rust/commit/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f"}], "stats": {"total": 1169, "additions": 472, "deletions": 697}, "files": [{"sha": "91e2aef26ef601c9408eb47886ab7aa69c308b43", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n+use trans::base;\n+use trans::build::*;\n use trans::common::{type_is_fat_ptr, Block};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n@@ -126,6 +128,34 @@ impl ArgType {\n     pub fn is_ignore(&self) -> bool {\n         self.kind == ArgKind::Ignore\n     }\n+\n+    /// Store a direct/indirect value described by this ArgType into a\n+    /// lvalue for the original Rust type of this argument/return.\n+    /// Can be used for both storing formal arguments into Rust variables\n+    /// or results of call/invoke instructions into their destinations.\n+    pub fn store(&self, bcx: Block, mut val: ValueRef, dst: ValueRef) {\n+        if self.is_ignore() {\n+            return;\n+        }\n+        if self.is_indirect() {\n+            let llsz = llsize_of(bcx.ccx(), self.ty);\n+            let llalign = llalign_of_min(bcx.ccx(), self.ty);\n+            base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n+        } else if let Some(ty) = self.cast {\n+            let store = Store(bcx, val, PointerCast(bcx, dst, ty.ptr_to()));\n+            let llalign = llalign_of_min(bcx.ccx(), self.ty);\n+            if !bcx.unreachable.get() {\n+                unsafe {\n+                    llvm::LLVMSetAlignment(store, llalign);\n+                }\n+            }\n+        } else {\n+            if self.original_ty == Type::i1(bcx.ccx()) {\n+                val = ZExt(bcx, val, Type::i8(bcx.ccx()));\n+            }\n+            Store(bcx, val, dst);\n+        }\n+    }\n }\n \n /// Metadata describing how the arguments to a native function"}, {"sha": "27c3dfc4c974d0987ffb33b7f3d94856804e2e38", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -10,12 +10,12 @@\n \n //! # Translation of inline assembly.\n \n-use llvm;\n+use llvm::{self, ValueRef};\n use trans::build::*;\n-use trans::callee;\n use trans::common::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n+use trans::datum::{Datum, Expr};\n use trans::expr;\n use trans::type_of;\n use trans::type_::Type;\n@@ -35,6 +35,29 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n+    let take_datum = |mut bcx: Block<'blk, 'tcx>,\n+                      arg_datum: Datum<'tcx, Expr>,\n+                      llargs: &mut Vec<ValueRef>|\n+                      -> Block<'blk, 'tcx> {\n+        // Make this an rvalue, since we are going to be\n+        // passing ownership.\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+\n+        // Now that arg_datum is owned, get it into the appropriate\n+        // mode (ref vs value).\n+        let arg_datum = unpack_datum!(\n+            bcx, arg_datum.to_appropriate_datum(bcx));\n+\n+        // Technically, ownership of val passes to the callee.\n+        // However, we must cleanup should we panic before the\n+        // callee is actually invoked.\n+        let val = arg_datum.add_clean(bcx.fcx,\n+            cleanup::CustomScope(temp_scope));\n+        llargs.push(val);\n+        bcx\n+    };\n+\n     let mut ext_inputs = Vec::new();\n     let mut ext_constraints = Vec::new();\n \n@@ -46,11 +69,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n         let out_datum = unpack_datum!(bcx, expr::trans(bcx, &out.expr));\n         if out.is_indirect {\n-            bcx = callee::trans_arg_datum(bcx,\n-                                          expr_ty(bcx, &out.expr),\n-                                          out_datum,\n-                                          cleanup::CustomScope(temp_scope),\n-                                          &mut inputs);\n+            bcx = take_datum(bcx, out_datum, &mut inputs);\n             if out.is_rw {\n                 ext_inputs.push(*inputs.last().unwrap());\n                 ext_constraints.push(i.to_string());\n@@ -59,11 +78,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n             output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n             outputs.push(out_datum.val);\n             if out.is_rw {\n-                bcx = callee::trans_arg_datum(bcx,\n-                                              expr_ty(bcx, &out.expr),\n-                                              out_datum,\n-                                              cleanup::CustomScope(temp_scope),\n-                                              &mut ext_inputs);\n+                bcx = take_datum(bcx, out_datum, &mut ext_inputs);\n                 ext_constraints.push(i.to_string());\n             }\n         }\n@@ -74,11 +89,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         constraints.push((*c).clone());\n \n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &input));\n-        bcx = callee::trans_arg_datum(bcx,\n-                                    expr_ty(bcx, &input),\n-                                    in_datum,\n-                                    cleanup::CustomScope(temp_scope),\n-                                    &mut inputs);\n+        bcx = take_datum(bcx, in_datum, &mut inputs);\n     }\n     inputs.extend_from_slice(&ext_inputs[..]);\n "}, {"sha": "dbcbdbf56028db309192b58df5b6e306af682758", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -1488,7 +1488,9 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         }\n         ty::FnDiverging => false,\n     };\n-    let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n+    let debug_context = debuginfo::create_function_debug_context(ccx, id,\n+                                                                 param_substs,\n+                                                                 llfndecl);\n     let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n     let nested_returns = if let Some(ref cfg) = cfg {\n         has_nested_returns(ccx.tcx(), cfg, blk_id)"}, {"sha": "22536f2dc434d3ca9c70af6cc4f02b4882a1d045", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use trans::common::*;\n@@ -920,20 +920,6 @@ pub fn Call(cx: Block,\n     B(cx).call(fn_, args, bundle)\n }\n \n-pub fn CallWithConv(cx: Block,\n-                    fn_: ValueRef,\n-                    args: &[ValueRef],\n-                    conv: CallConv,\n-                    debug_loc: DebugLoc)\n-                    -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _UndefReturn(cx, fn_);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call_with_conv(fn_, args, conv, bundle)\n-}\n-\n pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order, scope)"}, {"sha": "7f8e8393e8c4e94928d8fd0b01f7b871f2f145d0", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n@@ -843,15 +843,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                          conv: CallConv,\n-                          bundle: Option<&OperandBundleDef>) -> ValueRef {\n-        self.count_insn(\"callwithconv\");\n-        let v = self.call(llfn, args, bundle);\n-        llvm::SetInstructionCallConv(v, conv);\n-        v\n-    }\n-\n     pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n         self.count_insn(\"select\");\n         unsafe {"}, {"sha": "3e515fd5937719552700b956d8ed6062f188c10b", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 209, "deletions": 241, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -37,6 +37,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::closure;\n use trans::common::{self, Block, Result, NodeIdAndSpan, CrateContext, FunctionContext};\n+use trans::common::{C_uint, C_undef};\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n@@ -46,6 +47,7 @@ use trans::glue;\n use trans::inline;\n use trans::foreign;\n use trans::intrinsic;\n+use trans::machine::{llalign_of_min, llsize_of_store};\n use trans::meth;\n use trans::monomorphize::{self, Instance};\n use trans::type_::Type;\n@@ -60,6 +62,9 @@ use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n \n+use std::cmp;\n+\n+#[derive(Debug)]\n pub enum CalleeData {\n     /// Constructor for enum variant/tuple-like-struct.\n     NamedTupleConstructor(Disr),\n@@ -73,6 +78,7 @@ pub enum CalleeData {\n     Virtual(usize)\n }\n \n+#[derive(Debug)]\n pub struct Callee<'tcx> {\n     pub data: CalleeData,\n     pub ty: Ty<'tcx>\n@@ -591,16 +597,22 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    let (abi, ret_ty) = match callee.ty.sty {\n-        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-            let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-            let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-            (f.abi, sig.output)\n+    let abi = callee.ty.fn_abi();\n+    let sig = callee.ty.fn_sig();\n+    let output = bcx.tcx().erase_late_bound_regions(&sig.output());\n+    let output = infer::normalize_associated_type(bcx.tcx(), &output);\n+\n+    let extra_args = match args {\n+        ArgExprs(args) if abi != Abi::RustCall => {\n+            args[sig.0.inputs.len()..].iter().map(|expr| {\n+                common::expr_ty_adjusted(bcx, expr)\n+            }).collect()\n         }\n-        _ => panic!(\"expected fn item or ptr in Callee::call\")\n+        _ => vec![]\n     };\n+    let fn_ty = callee.direct_fn_type(ccx, &extra_args);\n \n-    match callee.data {\n+    let mut callee = match callee.data {\n         Intrinsic => {\n             assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n@@ -613,7 +625,7 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             };\n \n             let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n-            return intrinsic::trans_intrinsic_call(bcx, callee.ty,\n+            return intrinsic::trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(),\n                                                    call_info);\n@@ -628,34 +640,25 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                        dest.unwrap(),\n                                                        debug_loc);\n         }\n-        _ => {}\n-    }\n-\n-    // Intrinsics should not become actual functions.\n-    // We trans them in place in `trans_intrinsic_call`\n-    assert!(abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic);\n-\n-    let is_rust_fn = abi == Abi::Rust || abi == Abi::RustCall;\n+        f => f\n+    };\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot.\n     let opt_llretslot = dest.and_then(|dest| match dest {\n         expr::SaveIn(dst) => Some(dst),\n         expr::Ignore => {\n-            let ret_ty = match ret_ty {\n-                ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ccx.tcx().mk_nil()\n+            let needs_drop = || match output {\n+                ty::FnConverging(ret_ty) => bcx.fcx.type_needs_drop(ret_ty),\n+                ty::FnDiverging => false\n             };\n-            if !is_rust_fn ||\n-              type_of::return_uses_outptr(ccx, ret_ty) ||\n-              bcx.fcx.type_needs_drop(ret_ty) {\n+            if fn_ty.ret.is_indirect() || fn_ty.ret.cast.is_some() || needs_drop() {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n-                if common::type_is_zero_size(ccx, ret_ty) {\n-                    let llty = type_of::type_of(ccx, ret_ty);\n-                    Some(common::C_undef(llty.ptr_to()))\n+                if fn_ty.ret.is_ignore() {\n+                    Some(C_undef(fn_ty.ret.original_ty.ptr_to()))\n                 } else {\n-                    let llresult = alloc_ty(bcx, ret_ty, \"__llret\");\n+                    let llresult = alloca(bcx, fn_ty.ret.original_ty, \"__llret\");\n                     call_lifetime_start(bcx, llresult);\n                     Some(llresult)\n                 }\n@@ -665,134 +668,95 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     });\n \n-    let mut llresult = unsafe {\n-        llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n-    };\n+    // If there no destination, return must be direct, with no cast.\n+    if opt_llretslot.is_none() {\n+        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n+    }\n \n-    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+    let mut llargs = Vec::new();\n \n-    // The code below invokes the function, using either the Rust\n-    // conventions (if it is a rust fn) or the native conventions\n-    // (otherwise).  The important part is that, when all is said\n-    // and done, either the return value of the function will have been\n-    // written in opt_llretslot (if it is Some) or `llresult` will be\n-    // set appropriately (otherwise).\n-    if is_rust_fn {\n-        let mut llargs = Vec::new();\n-\n-        if let (ty::FnConverging(ret_ty), Some(mut llretslot)) = (ret_ty, opt_llretslot) {\n-            if type_of::return_uses_outptr(ccx, ret_ty) {\n-                let llformal_ret_ty = type_of::type_of(ccx, ret_ty).ptr_to();\n-                let llret_ty = common::val_ty(llretslot);\n-                if llformal_ret_ty != llret_ty {\n-                    // this could happen due to e.g. subtyping\n-                    debug!(\"casting actual return type ({:?}) to match formal ({:?})\",\n-                        llret_ty, llformal_ret_ty);\n-                    llretslot = PointerCast(bcx, llretslot, llformal_ret_ty);\n-                }\n-                llargs.push(llretslot);\n-            }\n+    if fn_ty.ret.is_indirect() {\n+        let mut llretslot = opt_llretslot.unwrap();\n+        if let Some(ty) = fn_ty.ret.cast {\n+            llretslot = PointerCast(bcx, llretslot, ty.ptr_to());\n         }\n+        llargs.push(llretslot);\n+    }\n \n-        let arg_start = llargs.len();\n-\n-        // Push the arguments.\n-        bcx = trans_args(bcx,\n-                         args,\n-                         callee.ty,\n-                         &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope),\n-                         abi);\n-\n-        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-\n-        let datum = match callee.data {\n-            Fn(f) => immediate_rvalue(f, callee.ty),\n-            Virtual(idx) => {\n-                // The data and vtable pointers were split by trans_arg_datum.\n-                let vtable = llargs.remove(arg_start + 1);\n-                meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n-            }\n-            _ => unreachable!()\n-        };\n-\n-        // Invoke the actual rust fn and update bcx/llresult.\n-        let (llret, b) = base::invoke(bcx, datum.val, &llargs, debug_loc);\n-\n-        let fn_ty = match datum.ty.sty {\n-            ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => {\n-                let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-                let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-                FnType::new(bcx.ccx(), f.abi, &sig, &[])\n-            }\n-            _ => unreachable!(\"expected fn type\")\n-        };\n+    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+    bcx = trans_args(bcx, abi, &fn_ty, &mut callee, args, &mut llargs,\n+                     cleanup::CustomScope(arg_cleanup_scope));\n+    fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n-        if !bcx.unreachable.get() {\n-            fn_ty.apply_attrs_callsite(llret);\n-        }\n+    let llfn = match callee {\n+        Fn(f) => f,\n+        _ => unreachable!(\"expected fn pointer callee, found {:?}\", callee)\n+    };\n \n-        bcx = b;\n-        llresult = llret;\n+    let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n+    if !bcx.unreachable.get() {\n+        fn_ty.apply_attrs_callsite(llret);\n+    }\n \n-        // If the Rust convention for this type is return via\n-        // the return value, copy it into llretslot.\n-        if let Some(llretslot) = opt_llretslot {\n-            let llty = fn_ty.ret.original_ty;\n-            if !fn_ty.ret.is_indirect() && llty != Type::void(bcx.ccx()) {\n-                store_ty(bcx, llret, llretslot, ret_ty.unwrap())\n-            }\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if !fn_ty.ret.is_ignore() && !fn_ty.ret.is_indirect() {\n+        if let Some(llforeign_ret_ty) = fn_ty.ret.cast {\n+            let llrust_ret_ty = fn_ty.ret.original_ty;\n+            let llretslot = opt_llretslot.unwrap();\n+\n+            // The actual return type is a struct, but the ABI\n+            // adaptation code has cast it into some scalar type.  The\n+            // code that follows is the only reliable way I have\n+            // found to do a transform like i64 -> {i32,i32}.\n+            // Basically we dump the data onto the stack then memcpy it.\n+            //\n+            // Other approaches I tried:\n+            // - Casting rust ret pointer to the foreign type and using Store\n+            //   is (a) unsafe if size of foreign type > size of rust type and\n+            //   (b) runs afoul of strict aliasing rules, yielding invalid\n+            //   assembly under -O (specifically, the store gets removed).\n+            // - Truncating foreign type to correct integral type and then\n+            //   bitcasting to the struct type yields invalid cast errors.\n+            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n+            base::call_lifetime_start(bcx, llscratch);\n+            Store(bcx, llret, llscratch);\n+            let llscratch_i8 = PointerCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n+            let llretptr_i8 = PointerCast(bcx, llretslot, Type::i8(ccx).ptr_to());\n+            let llrust_size = llsize_of_store(ccx, llrust_ret_ty);\n+            let llforeign_align = llalign_of_min(ccx, llforeign_ret_ty);\n+            let llrust_align = llalign_of_min(ccx, llrust_ret_ty);\n+            let llalign = cmp::min(llforeign_align, llrust_align);\n+            debug!(\"llrust_size={}\", llrust_size);\n+            base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n+                              C_uint(ccx, llrust_size), llalign as u32);\n+            base::call_lifetime_end(bcx, llscratch);\n+        } else if let Some(llretslot) = opt_llretslot {\n+            base::store_ty(bcx, llret, llretslot, output.unwrap());\n         }\n-    } else {\n-        // Lang items are the only case where dest is None, and\n-        // they are always Rust fns.\n-        assert!(dest.is_some());\n-\n-        let mut llargs = Vec::new();\n-        let (llfn, arg_tys) = match (callee.data, &args) {\n-            (Fn(f), &ArgExprs(a)) => {\n-                (f, a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect())\n-            }\n-            _ => panic!(\"expected fn ptr and arg exprs.\")\n-        };\n-        bcx = trans_args(bcx,\n-                         args,\n-                         callee.ty,\n-                         &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope),\n-                         abi);\n-        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-\n-        bcx = foreign::trans_native_call(bcx,\n-                                         callee.ty,\n-                                         llfn,\n-                                         opt_llretslot.unwrap(),\n-                                         &llargs[..],\n-                                         arg_tys,\n-                                         debug_loc);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n \n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n-    match (dest, opt_llretslot, ret_ty) {\n+    match (dest, opt_llretslot, output) {\n         (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx,\n-                                llretslot,\n-                                ret_ty,\n-                                debug_loc);\n+            bcx = glue::drop_ty(bcx, llretslot, ret_ty, debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n     }\n \n-    if ret_ty == ty::FnDiverging {\n+    if output == ty::FnDiverging {\n         Unreachable(bcx);\n     }\n \n-    Result::new(bcx, llresult)\n+    Result::new(bcx, llret)\n }\n \n pub enum CallArgs<'a, 'tcx> {\n@@ -818,20 +782,19 @@ pub enum CallArgs<'a, 'tcx> {\n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[P<hir::Expr>],\n-                             fn_ty: Ty<'tcx>,\n+                             callee: &mut CalleeData,\n+                             fn_ty: &FnType,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx>\n {\n-    let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-    let args = sig.inputs;\n+    let mut arg_idx = 0;\n \n     // Translate the `self` argument first.\n     let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n     bcx = trans_arg_datum(bcx,\n-                          args[0],\n                           arg_datum,\n+                          callee, fn_ty, &mut arg_idx,\n                           arg_cleanup_scope,\n                           llargs);\n \n@@ -858,8 +821,8 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, Disr(0), i)\n                     }).to_expr_datum();\n                 bcx = trans_arg_datum(bcx,\n-                                      field_type,\n                                       arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n             }\n@@ -873,64 +836,20 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     bcx\n }\n \n-fn trans_overloaded_call_args<'blk, 'tcx>(\n-                              mut bcx: Block<'blk, 'tcx>,\n-                              arg_exprs: Vec<&hir::Expr>,\n-                              fn_ty: Ty<'tcx>,\n-                              llargs: &mut Vec<ValueRef>,\n-                              arg_cleanup_scope: cleanup::ScopeId)\n-                              -> Block<'blk, 'tcx> {\n-    // Translate the `self` argument first.\n-    let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-\n-    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n-    bcx = trans_arg_datum(bcx,\n-                          arg_tys[0],\n-                          arg_datum,\n-                          arg_cleanup_scope,\n-                          llargs);\n-\n-    // Now untuple the rest of the arguments.\n-    let tuple_type = arg_tys[1];\n-    match tuple_type.sty {\n-        ty::TyTuple(ref field_types) => {\n-            for (i, &field_type) in field_types.iter().enumerate() {\n-                let arg_datum =\n-                    unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));\n-                bcx = trans_arg_datum(bcx,\n-                                      field_type,\n-                                      arg_datum,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        _ => {\n-            bcx.sess().span_bug(arg_exprs[0].span,\n-                                \"argument to `.call()` wasn't a tuple?!\")\n-        }\n-    };\n-\n-    bcx\n-}\n-\n-pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn trans_args<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  abi: Abi,\n+                                  fn_ty: &FnType,\n+                                  callee: &mut CalleeData,\n                                   args: CallArgs<'a, 'tcx>,\n-                                  fn_ty: Ty<'tcx>,\n                                   llargs: &mut Vec<ValueRef>,\n-                                  arg_cleanup_scope: cleanup::ScopeId,\n-                                  abi: Abi)\n+                                  arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let sig = cx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-    let variadic = sig.variadic;\n \n-    let mut bcx = cx;\n+    let mut bcx = bcx;\n+    let mut arg_idx = 0;\n \n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n@@ -940,78 +859,90 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             if abi == Abi::RustCall {\n                 // This is only used for direct calls to the `call`,\n                 // `call_mut` or `call_once` functions.\n-                return trans_args_under_call_abi(cx,\n-                                                 arg_exprs,\n-                                                 fn_ty,\n+                return trans_args_under_call_abi(bcx,\n+                                                 arg_exprs, callee, fn_ty,\n                                                  llargs,\n                                                  arg_cleanup_scope)\n             }\n \n-            let num_formal_args = arg_tys.len();\n-            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n-                let arg_ty = if i >= num_formal_args {\n-                    assert!(variadic);\n-                    common::expr_ty_adjusted(cx, &arg_expr)\n-                } else {\n-                    arg_tys[i]\n-                };\n-\n+            for arg_expr in arg_exprs {\n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n-                bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n+                bcx = trans_arg_datum(bcx,\n+                                      arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n             }\n         }\n         ArgOverloadedCall(arg_exprs) => {\n-            return trans_overloaded_call_args(cx,\n-                                              arg_exprs,\n-                                              fn_ty,\n-                                              llargs,\n-                                              arg_cleanup_scope)\n+            for expr in arg_exprs {\n+                let arg_datum =\n+                    unpack_datum!(bcx, expr::trans(bcx, expr));\n+                bcx = trans_arg_datum(bcx,\n+                                      arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n+                                      arg_cleanup_scope,\n+                                      llargs);\n+            }\n         }\n         ArgOverloadedOp(lhs, rhs) => {\n-            assert!(!variadic);\n-\n-            bcx = trans_arg_datum(bcx, arg_tys[0], lhs,\n+            bcx = trans_arg_datum(bcx, lhs,\n+                                  callee, fn_ty, &mut arg_idx,\n                                   arg_cleanup_scope,\n                                   llargs);\n \n             if let Some(rhs) = rhs {\n-                assert_eq!(arg_tys.len(), 2);\n-                bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n+                bcx = trans_arg_datum(bcx, rhs,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n-            } else {\n-                assert_eq!(arg_tys.len(), 1);\n             }\n         }\n         ArgVals(vs) => {\n-            llargs.extend_from_slice(vs);\n+            match *callee {\n+                Virtual(idx) => {\n+                    llargs.push(vs[0]);\n+\n+                    let fn_ptr = meth::get_virtual_method(bcx, vs[1], idx);\n+                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                    *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n+                    llargs.extend_from_slice(&vs[2..]);\n+                }\n+                _ => llargs.extend_from_slice(vs)\n+            }\n         }\n     }\n \n     bcx\n }\n \n-pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   formal_arg_ty: Ty<'tcx>,\n-                                   arg_datum: Datum<'tcx, Expr>,\n-                                   arg_cleanup_scope: cleanup::ScopeId,\n-                                   llargs: &mut Vec<ValueRef>)\n-                                   -> Block<'blk, 'tcx> {\n+fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               arg_datum: Datum<'tcx, Expr>,\n+                               callee: &mut CalleeData,\n+                               fn_ty: &FnType,\n+                               next_idx: &mut usize,\n+                               arg_cleanup_scope: cleanup::ScopeId,\n+                               llargs: &mut Vec<ValueRef>)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n-    let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_datum({:?})\", formal_arg_ty);\n+    debug!(\"trans_arg_datum({:?})\", arg_datum);\n \n-    let arg_datum_ty = arg_datum.ty;\n+    let arg = &fn_ty.args[*next_idx];\n+    *next_idx += 1;\n \n-    debug!(\"   arg datum: {:?}\", arg_datum);\n+    // Fill padding with undef value, where applicable.\n+    if let Some(ty) = arg.pad {\n+        llargs.push(C_undef(ty));\n+    }\n+\n+    // Determine whether we want a by-ref datum even if not appropriate.\n+    let want_by_ref = arg.is_indirect() || arg.cast.is_some();\n \n-    let mut val = if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n-                     !bcx.fcx.type_needs_drop(arg_datum_ty) {\n-        arg_datum.val\n+    let fat_ptr = common::type_is_fat_ptr(bcx.tcx(), arg_datum.ty);\n+    let (by_ref, val) = if fat_ptr && !bcx.fcx.type_needs_drop(arg_datum.ty) {\n+        (true, arg_datum.val)\n     } else {\n         // Make this an rvalue, since we are going to be\n         // passing ownership.\n@@ -1020,33 +951,70 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         // Now that arg_datum is owned, get it into the appropriate\n         // mode (ref vs value).\n-        let arg_datum = unpack_datum!(\n-            bcx, arg_datum.to_appropriate_datum(bcx));\n+        let arg_datum = unpack_datum!(bcx, if want_by_ref {\n+            arg_datum.to_ref_datum(bcx)\n+        } else {\n+            arg_datum.to_appropriate_datum(bcx)\n+        });\n \n         // Technically, ownership of val passes to the callee.\n         // However, we must cleanup should we panic before the\n         // callee is actually invoked.\n-        arg_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n+        (arg_datum.kind.is_by_ref(),\n+         arg_datum.add_clean(bcx.fcx, arg_cleanup_scope))\n     };\n \n-    if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n-        // this could happen due to e.g. subtyping\n-        let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-        debug!(\"casting actual type ({:?}) to match formal ({:?})\",\n-               Value(val), llformal_arg_ty);\n-        debug!(\"Rust types: {:?}; {:?}\", arg_datum_ty,\n-                                     formal_arg_ty);\n-        val = PointerCast(bcx, val, llformal_arg_ty);\n+    if arg.is_ignore() {\n+        return bcx;\n     }\n \n     debug!(\"--- trans_arg_datum passing {:?}\", Value(val));\n \n-    if common::type_is_fat_ptr(bcx.tcx(), formal_arg_ty) {\n+    if fat_ptr {\n+        // Fat pointers should be passed without any transformations.\n+        assert!(!arg.is_indirect() && arg.cast.is_none());\n         llargs.push(Load(bcx, expr::get_dataptr(bcx, val)));\n-        llargs.push(Load(bcx, expr::get_meta(bcx, val)));\n-    } else {\n-        llargs.push(val);\n+\n+        let info_arg = &fn_ty.args[*next_idx];\n+        *next_idx += 1;\n+        assert!(!info_arg.is_indirect() && info_arg.cast.is_none());\n+        let info = Load(bcx, expr::get_meta(bcx, val));\n+\n+        if let Virtual(idx) = *callee {\n+            // We have to grab the fn pointer from the vtable when\n+            // handling the first argument, ensure that here.\n+            assert_eq!(*next_idx, 2);\n+            assert!(info_arg.is_ignore());\n+            let fn_ptr = meth::get_virtual_method(bcx, info, idx);\n+            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+            *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n+        } else {\n+            assert!(!info_arg.is_ignore());\n+            llargs.push(info);\n+        }\n+        return bcx;\n+    }\n+\n+    let mut val = val;\n+    if by_ref && !arg.is_indirect() {\n+        // Have to load the argument, maybe while casting it.\n+        if arg.original_ty == Type::i1(bcx.ccx()) {\n+            // We store bools as i8 so we need to truncate to i1.\n+            val = LoadRangeAssert(bcx, val, 0, 2, llvm::False);\n+            val = Trunc(bcx, val, arg.original_ty);\n+        } else if let Some(ty) = arg.cast {\n+            val = Load(bcx, PointerCast(bcx, val, ty.ptr_to()));\n+            if !bcx.unreachable.get() {\n+                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(val, llalign);\n+                }\n+            }\n+        } else {\n+            val = Load(bcx, val);\n+        }\n     }\n \n+    llargs.push(val);\n     bcx\n }"}, {"sha": "193ff31c5c852283069d7edce7c1f1af1fd462f2", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -107,211 +107,6 @@ pub fn register_static(ccx: &CrateContext,\n     return c;\n }\n \n-/// Prepares a call to a native function. This requires adapting\n-/// from the Rust argument passing rules to the native rules.\n-///\n-/// # Parameters\n-///\n-/// - `callee_ty`: Rust type for the function we are calling\n-/// - `llfn`: the function pointer we are calling\n-/// - `llretptr`: where to store the return value of the function\n-/// - `llargs_rust`: a list of the argument values, prepared\n-///   as they would be if calling a Rust function\n-/// - `passed_arg_tys`: Rust type for the arguments. Normally we\n-///   can derive these from callee_ty but in the case of variadic\n-///   functions passed_arg_tys will include the Rust type of all\n-///   the arguments including the ones not specified in the fn's signature.\n-pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     callee_ty: Ty<'tcx>,\n-                                     llfn: ValueRef,\n-                                     llretptr: ValueRef,\n-                                     llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<Ty<'tcx>>,\n-                                     call_debug_loc: DebugLoc)\n-                                     -> Block<'blk, 'tcx>\n-{\n-    let ccx = bcx.ccx();\n-\n-    debug!(\"trans_native_call(callee_ty={:?}, llfn={:?}, llretptr={:?})\",\n-           callee_ty, Value(llfn), Value(llretptr));\n-\n-    let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) |\n-        ty::TyFnPtr(ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n-        _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n-    };\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-\n-    let extra_args = &passed_arg_tys[fn_sig.inputs.len()..];\n-    let fn_type = FnType::new(ccx, fn_abi, &fn_sig, extra_args);\n-\n-    let mut llargs_foreign = Vec::new();\n-\n-    // If the foreign ABI expects return value by pointer, supply the\n-    // pointer that Rust gave us. Sometimes we have to bitcast\n-    // because foreign fns return slightly different (but equivalent)\n-    // views on the same type (e.g., i64 in place of {i32,i32}).\n-    if fn_type.ret.is_indirect() {\n-        match fn_type.ret.cast {\n-            Some(ty) => {\n-                let llcastedretptr =\n-                    BitCast(bcx, llretptr, ty.ptr_to());\n-                llargs_foreign.push(llcastedretptr);\n-            }\n-            None => {\n-                llargs_foreign.push(llretptr);\n-            }\n-        }\n-    }\n-\n-    let mut i = 0;\n-    for &passed_arg_ty in &passed_arg_tys {\n-        let arg_ty = fn_type.args[i];\n-\n-        if arg_ty.is_ignore() {\n-            i += 1;\n-            continue;\n-        }\n-\n-        if type_is_fat_ptr(ccx.tcx(), passed_arg_ty) {\n-            // Fat pointers are one pointer and one integer or pointer.\n-            let (a, b) = (fn_type.args[i], fn_type.args[i + 1]);\n-            assert_eq!((a.cast, b.cast), (None, None));\n-            assert!(!a.is_indirect() && !b.is_indirect());\n-\n-            if let Some(ty) = a.pad {\n-                llargs_foreign.push(C_undef(ty));\n-            }\n-            llargs_foreign.push(llargs_rust[i]);\n-            i += 1;\n-\n-            if let Some(ty) = b.pad {\n-                llargs_foreign.push(C_undef(ty));\n-            }\n-            llargs_foreign.push(llargs_rust[i]);\n-            i += 1;\n-            continue;\n-        }\n-\n-        // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_ty);\n-\n-        let mut llarg_rust = llargs_rust[i];\n-        i += 1;\n-        debug!(\"argument {}, llarg_rust={:?}, rust_indirect={}, arg_ty={:?}\",\n-               i,\n-               Value(llarg_rust),\n-               rust_indirect,\n-               arg_ty);\n-\n-        // Ensure that we always have the Rust value indirectly,\n-        // because it makes bitcasting easier.\n-        if !rust_indirect {\n-            let scratch = base::alloc_ty(bcx, passed_arg_ty, \"__arg\");\n-            base::store_ty(bcx, llarg_rust, scratch, passed_arg_ty);\n-            llarg_rust = scratch;\n-        }\n-\n-        debug!(\"llarg_rust={:?} (after indirection)\",\n-               Value(llarg_rust));\n-\n-        // Check whether we need to do any casting\n-        if let Some(ty) = arg_ty.cast {\n-            llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to());\n-        }\n-\n-        debug!(\"llarg_rust={:?} (after casting)\",\n-               Value(llarg_rust));\n-\n-        // Finally, load the value if needed for the foreign ABI\n-        let foreign_indirect = arg_ty.is_indirect();\n-        let llarg_foreign = if foreign_indirect {\n-            llarg_rust\n-        } else if passed_arg_ty.is_bool() {\n-            let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n-            Trunc(bcx, val, Type::i1(bcx.ccx()))\n-        } else {\n-            Load(bcx, llarg_rust)\n-        };\n-\n-        debug!(\"argument {}, llarg_foreign={:?}\",\n-               i, Value(llarg_foreign));\n-\n-        // fill padding with undef value\n-        if let Some(ty) = arg_ty.pad {\n-            llargs_foreign.push(C_undef(ty));\n-        }\n-        llargs_foreign.push(llarg_foreign);\n-    }\n-\n-    // A function pointer is called without the declaration available, so we have to apply\n-    // any attributes with ABI implications directly to the call instruction.\n-\n-\n-    let llforeign_retval = CallWithConv(bcx,\n-                                        llfn,\n-                                        &llargs_foreign[..],\n-                                        fn_type.cconv,\n-                                        call_debug_loc);\n-    if !bcx.unreachable.get() {\n-        fn_type.apply_attrs_callsite(llforeign_retval);\n-    }\n-\n-    // If the function we just called does not use an outpointer,\n-    // store the result into the rust outpointer. Cast the outpointer\n-    // type to match because some ABIs will use a different type than\n-    // the Rust type. e.g., a {u32,u32} struct could be returned as\n-    // u64.\n-    let llrust_ret_ty = fn_type.ret.original_ty;\n-    if llrust_ret_ty != Type::void(ccx) && !fn_type.ret.is_indirect() {\n-        let llforeign_ret_ty = fn_type.ret.cast.unwrap_or(llrust_ret_ty);\n-\n-        debug!(\"llretptr={:?}\", Value(llretptr));\n-        debug!(\"llforeign_retval={:?}\", Value(llforeign_retval));\n-        debug!(\"llrust_ret_ty={:?}\", llrust_ret_ty);\n-        debug!(\"llforeign_ret_ty={:?}\", llforeign_ret_ty);\n-\n-        if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.output {\n-                ty::FnConverging(result_ty) => {\n-                    base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n-                }\n-                ty::FnDiverging => {}\n-            }\n-        } else {\n-            // The actual return type is a struct, but the ABI\n-            // adaptation code has cast it into some scalar type.  The\n-            // code that follows is the only reliable way I have\n-            // found to do a transform like i64 -> {i32,i32}.\n-            // Basically we dump the data onto the stack then memcpy it.\n-            //\n-            // Other approaches I tried:\n-            // - Casting rust ret pointer to the foreign type and using Store\n-            //   is (a) unsafe if size of foreign type > size of rust type and\n-            //   (b) runs afoul of strict aliasing rules, yielding invalid\n-            //   assembly under -O (specifically, the store gets removed).\n-            // - Truncating foreign type to correct integral type and then\n-            //   bitcasting to the struct type yields invalid cast errors.\n-            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n-            base::call_lifetime_start(bcx, llscratch);\n-            Store(bcx, llforeign_retval, llscratch);\n-            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n-            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8(ccx).ptr_to());\n-            let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n-            let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n-            let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n-            let llalign = cmp::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size={}\", llrust_size);\n-            base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n-                              C_uint(ccx, llrust_size), llalign as u32);\n-            base::call_lifetime_end(bcx, llscratch);\n-        }\n-    }\n-\n-    return bcx;\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Rust functions with foreign ABIs\n //"}, {"sha": "b200ff1ff03654cf992f7bd01ff70c416aebb0ad", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -18,7 +18,7 @@ use llvm::{ValueRef, TypeKind};\n use middle::infer;\n use middle::subst;\n use middle::subst::FnSpace;\n-use trans::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -172,6 +172,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             callee_ty: Ty<'tcx>,\n+                                            fn_ty: &FnType,\n                                             cleanup_scope: cleanup::CustomScopeIndex,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n@@ -396,11 +397,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Push the arguments.\n     let mut llargs = Vec::new();\n     bcx = callee::trans_args(bcx,\n+                             Abi::RustIntrinsic,\n+                             fn_ty,\n+                             &mut callee::Intrinsic,\n                              args,\n-                             callee_ty,\n                              &mut llargs,\n-                             cleanup::CustomScope(cleanup_scope),\n-                             Abi::RustIntrinsic);\n+                             cleanup::CustomScope(cleanup_scope));\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n@@ -973,7 +975,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     if val_ty(llval) != Type::void(ccx) &&\n        machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n-        store_ty(bcx, llval, llresult, ret_ty);\n+        if let Some(ty) = fn_ty.ret.cast {\n+            let ptr = PointerCast(bcx, llresult, ty.ptr_to());\n+            let store = Store(bcx, llval, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, ret_ty));\n+            }\n+        } else {\n+            store_ty(bcx, llval, llresult, ret_ty);\n+        }\n     }\n \n     // If we made a temporary stack slot, let's clean it up"}, {"sha": "3aaab4a0d82465338721667e19ecbd9b96b854e9", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -41,29 +41,16 @@ use syntax::codemap::DUMMY_SP;\n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;\n \n-/// Extracts a method from a trait object's vtable, at the\n-/// specified index, and casts it to the given type.\n+/// Extracts a method from a trait object's vtable, at the specified index.\n pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       llvtable: ValueRef,\n-                                      vtable_index: usize,\n-                                      method_ty: Ty<'tcx>)\n-                                      -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"meth::get_virtual_method\");\n-    let ccx = bcx.ccx();\n-\n+                                      vtable_index: usize)\n+                                      -> ValueRef {\n     // Load the data pointer from the object.\n-    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={:?})\",\n-           method_ty, vtable_index, Value(llvtable));\n-\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n+    debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n+           vtable_index, Value(llvtable));\n \n-    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-    if let ty::TyFnDef(_, _, fty) = method_ty.sty {\n-        let opaque_ty = opaque_method_ty(ccx.tcx(), fty);\n-        immediate_rvalue(PointerCast(bcx, mptr, type_of(ccx, opaque_ty)), opaque_ty)\n-    } else {\n-        immediate_rvalue(mptr, method_ty)\n-    }\n+    Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]))\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to\n@@ -323,23 +310,6 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         .collect()\n }\n \n-/// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n-                          -> Ty<'tcx> {\n-    let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::IntTy::I8));\n-\n-    tcx.mk_fn_ptr(ty::BareFnTy {\n-        unsafety: method_ty.unsafety,\n-        abi: method_ty.abi,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: inputs,\n-            output: method_ty.sig.0.output,\n-            variadic: method_ty.sig.0.variadic,\n-        }),\n-    })\n-}\n-\n #[derive(Debug)]\n pub struct ImplMethod<'tcx> {\n     pub method: Rc<ty::Method<'tcx>>,"}, {"sha": "f305d8964b1f857b36d6ff0fb67c7d97527479b7", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 178, "deletions": 121, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -8,25 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::{infer, ty};\n+use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n+use rustc::middle::ty;\n use rustc::mir::repr as mir;\n use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::base;\n use trans::build;\n-use trans::callee::{Callee, Fn, Virtual};\n-use trans::common::{self, Block, BlockAndBuilder};\n+use trans::callee::{Callee, CalleeData, Fn, Virtual};\n+use trans::common::{self, Block, BlockAndBuilder, C_undef};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n-use trans::foreign;\n+use trans::machine::llalign_of_min;\n use trans::meth;\n use trans::type_of;\n use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n-use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n+use super::lvalue::LvalueRef;\n+use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n@@ -152,115 +153,78 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n-                let debugloc = DebugLoc::None;\n-                // The arguments we'll be passing. Plus one to account for outptr, if used.\n-                let mut llargs = Vec::with_capacity(args.len() + 1);\n-                // Types of the arguments. We do not preallocate, because this vector is only\n-                // filled when `is_foreign` is `true` and foreign calls are minority of the cases.\n-                let mut arg_tys = Vec::new();\n \n-                let (callee, fty) = match callee.ty.sty {\n+                let (mut callee, abi, sig) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, f) => {\n-                        (Callee::def(bcx.ccx(), def_id, substs), f)\n+                        (Callee::def(bcx.ccx(), def_id, substs), f.abi, &f.sig)\n                     }\n                     ty::TyFnPtr(f) => {\n                         (Callee {\n                             data: Fn(callee.immediate()),\n                             ty: callee.ty\n-                        }, f)\n+                        }, f.abi, &f.sig)\n                     }\n                     _ => unreachable!(\"{} is not callable\", callee.ty)\n                 };\n \n                 // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                assert!(fty.abi != Abi::RustIntrinsic && fty.abi != Abi::PlatformIntrinsic);\n-                // Foreign-ABI functions are translated differently\n-                let is_foreign = fty.abi != Abi::Rust && fty.abi != Abi::RustCall;\n+                assert!(abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic);\n+\n+                let extra_args = &args[sig.0.inputs.len()..];\n+                let extra_args = extra_args.iter().map(|op_arg| {\n+                    self.mir.operand_ty(bcx.tcx(), op_arg)\n+                }).collect::<Vec<_>>();\n+                let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);\n+\n+                // The arguments we'll be passing. Plus one to account for outptr, if used.\n+                let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n+                let mut llargs = Vec::with_capacity(arg_count);\n \n                 // Prepare the return value destination\n-                let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n+                let ret_dest = if let Some((ref d, _)) = *destination {\n                     let dest = self.trans_lvalue(&bcx, d);\n-                    let ret_ty = dest.ty.to_ty(bcx.tcx());\n-                    if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n+                    if fn_ty.ret.is_indirect() {\n                         llargs.push(dest.llval);\n-                        (Some((dest, ret_ty)), false)\n+                        None\n+                    } else if fn_ty.ret.is_ignore() {\n+                        None\n                     } else {\n-                        (Some((dest, ret_ty)), !common::type_is_zero_size(bcx.ccx(), ret_ty))\n+                        Some(dest)\n                     }\n                 } else {\n-                    (None, false)\n+                    None\n                 };\n \n                 // Split the rust-call tupled arguments off.\n-                let (args, rest) = if fty.abi == Abi::RustCall && !args.is_empty() {\n+                let (args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n                     let (tup, args) = args.split_last().unwrap();\n-                    // we can reorder safely because of MIR\n-                    (args, self.trans_operand_untupled(&bcx, tup))\n+                    (args, Some(tup))\n                 } else {\n-                    (&args[..], vec![])\n+                    (&args[..], None)\n                 };\n \n-                let datum = {\n-                    let mut arg_ops = args.iter().map(|arg| {\n-                        self.trans_operand(&bcx, arg)\n-                    }).chain(rest.into_iter());\n-\n-                    // Get the actual pointer we can call.\n-                    // This can involve vtable accesses or reification.\n-                    let datum = if let Virtual(idx) = callee.data {\n-                        assert!(!is_foreign);\n-\n-                        // Grab the first argument which is a trait object.\n-                        let vtable = match arg_ops.next().unwrap().val {\n-                            FatPtr(data, vtable) => {\n-                                llargs.push(data);\n-                                vtable\n-                            }\n-                            _ => unreachable!(\"expected FatPtr for Virtual call\")\n-                        };\n-\n-                        bcx.with_block(|bcx| {\n-                            meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n-                        })\n-                    } else {\n-                        callee.reify(bcx.ccx())\n-                    };\n-\n-                    // Process the rest of the args.\n-                    for operand in arg_ops {\n-                        match operand.val {\n-                            Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                            FatPtr(b, e) => {\n-                                llargs.push(b);\n-                                llargs.push(e);\n-                            }\n-                        }\n-                        if is_foreign {\n-                            arg_tys.push(operand.ty);\n-                        }\n-                    }\n+                let mut idx = 0;\n+                for arg in args {\n+                    let val = self.trans_operand(&bcx, arg).val;\n+                    self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n+                                        &mut idx, &mut callee.data);\n+                }\n+                if let Some(tup) = untuple {\n+                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n+                                                  &mut idx, &mut callee.data)\n+                }\n \n-                    datum\n-                };\n-\n-                let fn_ty = match datum.ty.sty {\n-                    ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => {\n-                        let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-                        let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-                        FnType::new(bcx.ccx(), f.abi, &sig, &[])\n-                    }\n-                    _ => unreachable!(\"expected fn type\")\n-                };\n+                let fn_ptr = callee.reify(bcx.ccx()).val;\n \n                 // Many different ways to call a function handled here\n-                match (is_foreign, cleanup, destination) {\n+                match (cleanup, destination) {\n                     // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (false, &Some(cleanup), &None) => {\n+                    (&Some(cleanup), &None) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        let cs = bcx.invoke(datum.val,\n-                                            &llargs[..],\n+                        let cs = bcx.invoke(fn_ptr,\n+                                            &llargs,\n                                             unreachable_blk.llbb,\n                                             landingpad.llbb(),\n                                             cleanup_bundle.as_ref());\n@@ -269,22 +233,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             self.set_operand_dropped(bcx, op);\n                         });\n                     },\n-                    (false, &Some(cleanup), &Some((_, success))) => {\n+                    (&Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n-                        let invokeret = bcx.invoke(datum.val,\n-                                                   &llargs[..],\n+                        let invokeret = bcx.invoke(fn_ptr,\n+                                                   &llargs,\n                                                    self.llblock(success),\n                                                    landingpad.llbb(),\n                                                    cleanup_bundle.as_ref());\n                         fn_ty.apply_attrs_callsite(invokeret);\n-                        if must_copy_dest {\n-                            let (ret_dest, ret_ty) = ret_dest_ty\n-                                .expect(\"return destination and type not set\");\n+                        if let Some(ret_dest) = ret_dest {\n                             // We translate the copy straight into the beginning of the target\n                             // block.\n                             self.bcx(success).at_start(|bcx| bcx.with_block( |bcx| {\n-                                base::store_ty(bcx, invokeret, ret_dest.llval, ret_ty);\n+                                fn_ty.ret.store(bcx, invokeret, ret_dest.llval);\n                             }));\n                         }\n                         self.bcx(success).at_start(|bcx| for op in args {\n@@ -294,56 +256,151 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             self.set_operand_dropped(bcx, op);\n                         });\n                     },\n-                    (false, _, &None) => {\n-                        let cs = bcx.call(datum.val,\n-                                          &llargs[..],\n-                                          cleanup_bundle.as_ref());\n+                    (&None, &None) => {\n+                        let cs = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n                         fn_ty.apply_attrs_callsite(cs);\n                         // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n-                    (false, _, &Some((_, target))) => {\n-                        let llret = bcx.call(datum.val,\n-                                             &llargs[..],\n-                                             cleanup_bundle.as_ref());\n+                    (&None, &Some((_, target))) => {\n+                        let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n                         fn_ty.apply_attrs_callsite(llret);\n-                        if must_copy_dest {\n-                            let (ret_dest, ret_ty) = ret_dest_ty\n-                                .expect(\"return destination and type not set\");\n+                        if let Some(ret_dest) = ret_dest {\n                             bcx.with_block(|bcx| {\n-                                base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n+                                fn_ty.ret.store(bcx, llret, ret_dest.llval);\n                             });\n                         }\n                         for op in args {\n                             self.set_operand_dropped(&bcx, op);\n                         }\n                         funclet_br(bcx, self.llblock(target));\n                     }\n-                    // Foreign functions\n-                    (true, _, destination) => {\n-                        let (dest, _) = ret_dest_ty\n-                            .expect(\"return destination is not set\");\n-                        bcx = bcx.map_block(|bcx| {\n-                            foreign::trans_native_call(bcx,\n-                                                       datum.ty,\n-                                                       datum.val,\n-                                                       dest.llval,\n-                                                       &llargs[..],\n-                                                       arg_tys,\n-                                                       debugloc)\n-                        });\n-                        if let Some((_, target)) = *destination {\n-                            for op in args {\n-                                self.set_operand_dropped(&bcx, op);\n-                            }\n-                            funclet_br(bcx, self.llblock(target));\n-                        }\n-                    },\n                 }\n             }\n         }\n     }\n \n+    fn trans_argument(&mut self,\n+                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      val: OperandValue,\n+                      llargs: &mut Vec<ValueRef>,\n+                      fn_ty: &FnType,\n+                      next_idx: &mut usize,\n+                      callee: &mut CalleeData) {\n+        // Treat the values in a fat pointer separately.\n+        if let FatPtr(ptr, meta) = val {\n+            if *next_idx == 0 {\n+                if let Virtual(idx) = *callee {\n+                    let llfn = bcx.with_block(|bcx| {\n+                        meth::get_virtual_method(bcx, meta, idx)\n+                    });\n+                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                    *callee = Fn(bcx.pointercast(llfn, llty));\n+                }\n+            }\n+            self.trans_argument(bcx, Immediate(ptr), llargs, fn_ty, next_idx, callee);\n+            self.trans_argument(bcx, Immediate(meta), llargs, fn_ty, next_idx, callee);\n+            return;\n+        }\n+\n+        let arg = &fn_ty.args[*next_idx];\n+        *next_idx += 1;\n+\n+        // Fill padding with undef value, where applicable.\n+        if let Some(ty) = arg.pad {\n+            llargs.push(C_undef(ty));\n+        }\n+\n+        if arg.is_ignore() {\n+            return;\n+        }\n+\n+        // Force by-ref if we have to load through a cast pointer.\n+        let (mut llval, by_ref) = match val {\n+            Immediate(llval) if arg.cast.is_some() => {\n+                let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n+                bcx.store(llval, llscratch);\n+                (llscratch, true)\n+            }\n+            Immediate(llval) => (llval, false),\n+            Ref(llval) => (llval, true),\n+            FatPtr(_, _) => unreachable!(\"fat pointers handled above\")\n+        };\n+\n+        if by_ref && !arg.is_indirect() {\n+            // Have to load the argument, maybe while casting it.\n+            if arg.original_ty == Type::i1(bcx.ccx()) {\n+                // We store bools as i8 so we need to truncate to i1.\n+                llval = bcx.load_range_assert(llval, 0, 2, llvm::False);\n+                llval = bcx.trunc(llval, arg.original_ty);\n+            } else if let Some(ty) = arg.cast {\n+                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()));\n+                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(llval, llalign);\n+                }\n+            } else {\n+                llval = bcx.load(llval);\n+            }\n+        }\n+\n+        llargs.push(llval);\n+    }\n+\n+    fn trans_arguments_untupled(&mut self,\n+                                bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                operand: &mir::Operand<'tcx>,\n+                                llargs: &mut Vec<ValueRef>,\n+                                fn_ty: &FnType,\n+                                next_idx: &mut usize,\n+                                callee: &mut CalleeData) {\n+        // FIXME: consider having some optimization to avoid tupling/untupling\n+        // (and storing/loading in the case of immediates)\n+\n+        // avoid trans_operand for pointless copying\n+        let lv = match *operand {\n+            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n+            mir::Operand::Constant(ref constant) => {\n+                // FIXME: consider being less pessimized\n+                if constant.ty.is_nil() {\n+                    return;\n+                }\n+\n+                let ty = bcx.monomorphize(&constant.ty);\n+                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n+                let constant = self.trans_constant(bcx, constant);\n+                self.store_operand(bcx, lv.llval, constant);\n+                lv\n+           }\n+        };\n+\n+        let lv_ty = lv.ty.to_ty(bcx.tcx());\n+        let result_types = match lv_ty.sty {\n+            ty::TyTuple(ref tys) => tys,\n+            _ => bcx.tcx().sess.span_bug(\n+                self.mir.span,\n+                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+        };\n+\n+        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n+        let base = adt::MaybeSizedValue::sized(lv.llval);\n+        for (n, &ty) in result_types.iter().enumerate() {\n+            let ptr = bcx.with_block(|bcx| {\n+                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n+            });\n+            let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                let (lldata, llextra) = bcx.with_block(|bcx| {\n+                    base::load_fat_ptr(bcx, ptr, ty)\n+                });\n+                FatPtr(lldata, llextra)\n+            } else {\n+                // Don't bother loading the value, trans_argument will.\n+                Ref(ptr)\n+            };\n+            self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+        }\n+    }\n+\n     fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx();\n         if let Some(slot) = self.llpersonalityslot {"}, {"sha": "0871b2e394e05ea4b191484f7e901739a1872ed4", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03993882d634b923d9f8e467b7a991f3b07b6453/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=03993882d634b923d9f8e467b7a991f3b07b6453", "patch": "@@ -9,20 +9,17 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty::Ty;\n use rustc::mir::repr as mir;\n-use trans::adt;\n use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n use trans::value::Value;\n-use trans::Disr;\n use trans::glue;\n \n use std::fmt;\n \n use super::{MirContext, TempRef, drop};\n-use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -190,48 +187,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    pub fn trans_operand_untupled(&mut self,\n-                                  bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                                  operand: &mir::Operand<'tcx>)\n-                                  -> Vec<OperandRef<'tcx>>\n-    {\n-        // FIXME: consider having some optimization to avoid tupling/untupling\n-        // (and storing/loading in the case of immediates)\n-\n-        // avoid trans_operand for pointless copying\n-        let lv = match *operand {\n-            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n-            mir::Operand::Constant(ref constant) => {\n-                // FIXME: consider being less pessimized\n-                if constant.ty.is_nil() {\n-                    return vec![];\n-                }\n-\n-                let ty = bcx.monomorphize(&constant.ty);\n-                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n-                let constant = self.trans_constant(bcx, constant);\n-                self.store_operand(bcx, lv.llval, constant);\n-                lv\n-           }\n-        };\n-\n-        let lv_ty = lv.ty.to_ty(bcx.tcx());\n-        let result_types = match lv_ty.sty {\n-            ty::TyTuple(ref tys) => tys,\n-            _ => bcx.tcx().sess.span_bug(\n-                self.mir.span,\n-                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n-        };\n-\n-        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n-        let base = adt::MaybeSizedValue::sized(lv.llval);\n-        result_types.iter().enumerate().map(|(n, &ty)| {\n-            self.trans_load(bcx, bcx.with_block(|bcx| {\n-                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n-            }), ty)\n-        }).collect()\n-    }\n-\n     pub fn set_operand_dropped(&mut self,\n                                bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                operand: &mir::Operand<'tcx>) {"}]}