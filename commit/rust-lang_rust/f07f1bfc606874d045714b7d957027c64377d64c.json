{"sha": "f07f1bfc606874d045714b7d957027c64377d64c", "node_id": "C_kwDOAAsO6NoAKGYwN2YxYmZjNjA2ODc0ZDA0NTcxNGI3ZDk1NzAyN2M2NDM3N2Q2NGM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-17T20:33:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-19T14:41:36Z"}, "message": "Encode metadata using queries.", "tree": {"sha": "99baf23cba8168f2844f0a570fa9cf6efd552043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99baf23cba8168f2844f0a570fa9cf6efd552043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f07f1bfc606874d045714b7d957027c64377d64c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f07f1bfc606874d045714b7d957027c64377d64c", "html_url": "https://github.com/rust-lang/rust/commit/f07f1bfc606874d045714b7d957027c64377d64c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f07f1bfc606874d045714b7d957027c64377d64c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "227d91248988f24c14f9d440ec0171c844bd89e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/227d91248988f24c14f9d440ec0171c844bd89e0", "html_url": "https://github.com/rust-lang/rust/commit/227d91248988f24c14f9d440ec0171c844bd89e0"}], "stats": {"total": 465, "additions": 222, "deletions": 243}, "files": [{"sha": "cf32f1dd6abb68c989e7855abb6e6f56c3947800", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 111, "deletions": 152, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f07f1bfc606874d045714b7d957027c64377d64c", "patch": "@@ -11,7 +11,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n-use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -21,10 +20,12 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use rustc_middle::middle::stability::DeprecationEntry;\n+use rustc_middle::mir;\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n@@ -278,6 +279,99 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n     }\n }\n \n+trait LazyQueryDecodable<'a, 'tcx, T> {\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> T;\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> T {\n+        if let Some(l) = self { l.decode((cdata, tcx)) } else { err() }\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx T> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+    T: ArenaAllocatable<'tcx>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> &'tcx T {\n+        if let Some(l) = self { tcx.arena.alloc(l.decode((cdata, tcx))) } else { err() }\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, Option<T>> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Option<T> {\n+        self.map(|l| l.decode((cdata, tcx)))\n+    }\n+}\n+\n+impl<'a, 'tcx, T, E> LazyQueryDecodable<'a, 'tcx, Result<Option<T>, E>> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Result<Option<T>, E> {\n+        Ok(self.map(|l| l.decode((cdata, tcx))))\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx [T]> for Option<Lazy<[T], usize>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>> + Copy,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> &'tcx [T] {\n+        if let Some(l) = self { tcx.arena.alloc_from_iter(l.decode((cdata, tcx))) } else { &[] }\n+    }\n+}\n+\n+impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DeprecationEntry>>\n+    for Option<Lazy<attr::Deprecation>>\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Option<DeprecationEntry> {\n+        self.map(|l| l.decode((cdata, tcx))).map(DeprecationEntry::external)\n+    }\n+}\n+\n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -716,7 +810,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n         let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n-        let span = match self.root.tables.ident_span.get(self, item_index) {\n+        let span = match self.root.tables.def_ident_span.get(self, item_index) {\n             Some(lazy_span) => lazy_span.decode((self, sess)),\n             None => {\n                 // FIXME: this weird case of a name with no span is specific to `extern crate`\n@@ -750,20 +844,22 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn def_kind(self, item_id: DefIndex) -> DefKind {\n-        self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n+        self.root.tables.opt_def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(\n+            || {\n+                bug!(\n+                    \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n+                    item_id,\n+                    self.root.name,\n+                    self.cnum,\n+                )\n+            },\n+        )\n     }\n \n     fn get_span(self, index: DefIndex, sess: &Session) -> Span {\n         self.root\n             .tables\n-            .span\n+            .def_span\n             .get(self, index)\n             .unwrap_or_else(|| panic!(\"Missing span for {:?}\", index))\n             .decode((self, sess))\n@@ -908,71 +1004,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    fn get_explicit_predicates(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n-    }\n-\n-    fn get_inferred_outlives(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-        self.root\n-            .tables\n-            .inferred_outlives\n-            .get(self, item_id)\n-            .map(|predicates| tcx.arena.alloc_from_iter(predicates.decode((self, tcx))))\n-            .unwrap_or_default()\n-    }\n-\n-    fn get_super_predicates(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n-    }\n-\n-    fn get_explicit_item_bounds(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-        self.root\n-            .tables\n-            .explicit_item_bounds\n-            .get(self, item_id)\n-            .map(|bounds| tcx.arena.alloc_from_iter(bounds.decode((self, tcx))))\n-            .unwrap_or_default()\n-    }\n-\n     fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n-    }\n-\n-    fn get_type(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.root\n-            .tables\n-            .ty\n-            .get(self, id)\n-            .unwrap_or_else(|| panic!(\"Not a type: {:?}\", id))\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_stability(self, id: DefIndex) -> Option<attr::Stability> {\n-        self.root.tables.stability.get(self, id).map(|stab| stab.decode(self))\n-    }\n-\n-    fn get_const_stability(self, id: DefIndex) -> Option<attr::ConstStability> {\n-        self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n-    }\n-\n-    fn get_deprecation(self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.root.tables.deprecation.get(self, id).map(|depr| depr.decode(self))\n+        self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     fn get_visibility(self, id: DefIndex) -> ty::Visibility {\n@@ -1010,22 +1043,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    fn get_impl_trait(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n-    }\n-\n     fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n         self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n     }\n \n-    fn get_const_param_default(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> rustc_middle::ty::Const<'tcx> {\n-        self.root.tables.const_defaults.get(self, id).unwrap().decode((self, tcx))\n-    }\n-\n     /// Iterates over all the stability attributes in the given crate.\n     fn get_lib_features(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n@@ -1163,7 +1184,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn is_item_mir_available(self, id: DefIndex) -> bool {\n-        self.root.tables.mir.get(self, id).is_some()\n+        self.root.tables.optimized_mir.get(self, id).is_some()\n     }\n \n     fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n@@ -1175,60 +1196,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_optimized_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.root\n-            .tables\n-            .mir\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_mir_for_ctfe(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.root\n-            .tables\n-            .mir_for_ctfe\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_mir_for_ctfe: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_thir_abstract_const(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n-        self.root\n-            .tables\n-            .thir_abstract_consts\n-            .get(self, id)\n-            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n-    }\n-\n-    fn get_unused_generic_params(self, id: DefIndex) -> FiniteBitSet<u32> {\n-        self.root\n-            .tables\n-            .unused_generic_params\n-            .get(self, id)\n-            .map(|params| params.decode(self))\n-            .unwrap_or_default()\n-    }\n-\n-    fn get_promoted_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.root\n-            .tables\n-            .promoted_mir\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n     fn mir_const_qualif(self, id: DefIndex) -> mir::ConstQualifs {\n         match self.kind(id) {\n             EntryKind::AnonConst(qualif, _)\n@@ -1288,10 +1255,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_variances(self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n-        self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self)\n-    }\n-\n     fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) | EntryKind::Variant(data) => {\n@@ -1479,7 +1442,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        tcx.arena.alloc_from_iter(param_names.decode((self, tcx)))\n+        LazyQueryDecodable::decode_query(Some(param_names), self, tcx, || unreachable!())\n     }\n \n     fn exported_symbols(\n@@ -1551,10 +1514,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn fn_sig(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n-    }\n-\n     #[inline]\n     fn def_key(self, index: DefIndex) -> DefKey {\n         *self"}, {"sha": "ef840181b848dead00d0ac4c2fc8acc2e5e63ed5", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f07f1bfc606874d045714b7d957027c64377d64c", "patch": "@@ -1,3 +1,4 @@\n+use super::LazyQueryDecodable;\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n@@ -8,7 +9,6 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE}\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n-use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n@@ -23,32 +23,51 @@ use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n use std::any::Any;\n \n+macro_rules! provide_one {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table }) => {\n+        provide_one! {\n+            <$lt> $tcx, $def_id, $other, $cdata, $name => {\n+                $cdata.root.tables.$name.get($cdata, $def_id.index).decode_query(\n+                    $cdata,\n+                    $tcx,\n+                    || panic!(\"{:?} does not have a {:?}\", $def_id, stringify!($name)),\n+                )\n+            }\n+        }\n+    };\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => $compute:block) => {\n+        fn $name<$lt>(\n+            $tcx: TyCtxt<$lt>,\n+            def_id_arg: ty::query::query_keys::$name<$lt>,\n+        ) -> ty::query::query_values::$name<$lt> {\n+            let _prof_timer =\n+                $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n+\n+            #[allow(unused_variables)]\n+            let ($def_id, $other) = def_id_arg.into_args();\n+            assert!(!$def_id.is_local());\n+\n+            // External query providers call `crate_hash` in order to register a dependency\n+            // on the crate metadata. The exception is `crate_hash` itself, which obviously\n+            // doesn't need to do this (and can't, as it would cause a query cycle).\n+            use rustc_middle::dep_graph::DepKind;\n+            if DepKind::$name != DepKind::crate_hash && $tcx.dep_graph.is_fully_enabled() {\n+                $tcx.ensure().crate_hash($def_id.krate);\n+            }\n+\n+            let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n+\n+            $compute\n+        }\n+    };\n+}\n+\n macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n-      $($name:ident => $compute:block)*) => {\n+      $($name:ident => { $($compute:tt)* })*) => {\n         pub fn provide_extern(providers: &mut ExternProviders) {\n-            $(fn $name<$lt>(\n-                $tcx: TyCtxt<$lt>,\n-                def_id_arg: ty::query::query_keys::$name<$lt>,\n-            ) -> ty::query::query_values::$name<$lt> {\n-                let _prof_timer =\n-                    $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n-\n-                #[allow(unused_variables)]\n-                let ($def_id, $other) = def_id_arg.into_args();\n-                assert!(!$def_id.is_local());\n-\n-                // External query providers call `crate_hash` in order to register a dependency\n-                // on the crate metadata. The exception is `crate_hash` itself, which obviously\n-                // doesn't need to do this (and can't, as it would cause a query cycle).\n-                use rustc_middle::dep_graph::DepKind;\n-                if DepKind::$name != DepKind::crate_hash && $tcx.dep_graph.is_fully_enabled() {\n-                    $tcx.ensure().crate_hash($def_id.krate);\n-                }\n-\n-                let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n-\n-                $compute\n+            $(provide_one! {\n+                <$lt> $tcx, $def_id, $other, $cdata, $name => { $($compute)* }\n             })*\n \n             *providers = ExternProviders {\n@@ -90,50 +109,50 @@ impl<'tcx> IntoArgs for ty::InstanceDef<'tcx> {\n }\n \n provide! { <'tcx> tcx, def_id, other, cdata,\n-    type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => { cdata.get_generics(def_id.index, tcx.sess) }\n-    explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n-    inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n-    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n-    explicit_item_bounds => { cdata.get_explicit_item_bounds(def_id.index, tcx) }\n+    explicit_item_bounds => { table }\n+    explicit_predicates_of => { table }\n+    generics_of => { table }\n+    inferred_outlives_of => { table }\n+    super_predicates_of => { table }\n+    type_of => { table }\n+    variances_of => { table }\n+    fn_sig => { table }\n+    impl_trait_ref => { table }\n+    const_param_default => { table }\n+    thir_abstract_const => { table }\n+    optimized_mir => { table }\n+    mir_for_ctfe => { table }\n+    promoted_mir => { table }\n+    def_span => { table }\n+    def_ident_span => { table }\n+    lookup_stability => { table }\n+    lookup_const_stability => { table }\n+    lookup_deprecation_entry => { table }\n+    visibility => { table }\n+    unused_generic_params => { table }\n+    opt_def_kind => { table }\n+\n     trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n-    variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => { cdata.get_associated_item_def_ids(tcx, def_id.index) }\n     associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n-    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n     impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n         cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n-    mir_for_ctfe => { tcx.arena.alloc(cdata.get_mir_for_ctfe(tcx, def_id.index)) }\n-    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n-    unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n-    const_param_default => { cdata.get_const_param_default(tcx, def_id.index) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n-    fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     asyncness => { cdata.asyncness(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n     generator_kind => { cdata.generator_kind(def_id.index) }\n-    opt_def_kind => { Some(cdata.def_kind(def_id.index)) }\n-    def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    def_ident_span => { cdata.opt_item_ident(def_id.index, &tcx.sess).map(|ident| ident.span) }\n-    lookup_stability => { cdata.get_stability(def_id.index) }\n-    lookup_const_stability => { cdata.get_const_stability(def_id.index) }\n-    lookup_deprecation_entry => {\n-        cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n-    }\n     item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n     fn_arg_names => { cdata.get_fn_param_names(tcx, def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n@@ -185,7 +204,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n \n-    visibility => { cdata.get_visibility(def_id.index) }\n     dep_kind => {\n         let r = *cdata.dep_kind.lock();\n         r"}, {"sha": "c0bf2b60b9c8bd1ef9588e019fae42abcc40eb3c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f07f1bfc606874d045714b7d957027c64377d64c", "patch": "@@ -983,13 +983,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            record!(self.tables.def_kind[def_id] <- match def_kind {\n+            record!(self.tables.opt_def_kind[def_id] <- match def_kind {\n                 // Replace Ctor by the enclosing object to avoid leaking details in children crates.\n                 DefKind::Ctor(CtorOf::Struct, _) => DefKind::Struct,\n                 DefKind::Ctor(CtorOf::Variant, _) => DefKind::Variant,\n                 def_kind => def_kind,\n             });\n-            record!(self.tables.span[def_id] <- tcx.def_span(def_id));\n+            record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n             record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if should_encode_visibility(def_kind) {\n@@ -1002,19 +1002,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             if should_encode_variances(def_kind) {\n                 let v = self.tcx.variances_of(def_id);\n-                record!(self.tables.variances[def_id] <- v);\n+                record!(self.tables.variances_of[def_id] <- v);\n             }\n             if should_encode_generics(def_kind) {\n                 let g = tcx.generics_of(def_id);\n-                record!(self.tables.generics[def_id] <- g);\n-                record!(self.tables.explicit_predicates[def_id] <- self.tcx.explicit_predicates_of(def_id));\n+                record!(self.tables.generics_of[def_id] <- g);\n+                record!(self.tables.explicit_predicates_of[def_id] <- self.tcx.explicit_predicates_of(def_id));\n                 let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n                 if !inferred_outlives.is_empty() {\n-                    record!(self.tables.inferred_outlives[def_id] <- inferred_outlives);\n+                    record!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n-                record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+                record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n         }\n         let inherent_impls = tcx.crate_inherent_impls(());\n@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_item_type(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n+        record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n@@ -1332,15 +1332,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n             if encode_opt {\n-                record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n+                record!(self.tables.optimized_mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n             }\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n                 // FIXME(generic_const_exprs): this feels wrong to have in `encode_mir`\n                 let abstract_const = self.tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n-                    record!(self.tables.thir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                    record!(self.tables.thir_abstract_const[def_id.to_def_id()] <- abstract_const);\n                 }\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n@@ -1361,7 +1361,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the stability attributes are even enabled before using their queries.\n         if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n             if let Some(stab) = self.tcx.lookup_stability(def_id) {\n-                record!(self.tables.stability[def_id] <- stab)\n+                record!(self.tables.lookup_stability[def_id] <- stab)\n             }\n         }\n     }\n@@ -1373,15 +1373,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the stability attributes are even enabled before using their queries.\n         if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n             if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n-                record!(self.tables.const_stability[def_id] <- stab)\n+                record!(self.tables.lookup_const_stability[def_id] <- stab)\n             }\n         }\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n-            record!(self.tables.deprecation[def_id] <- depr);\n+            record!(self.tables.lookup_deprecation_entry[def_id] <- depr);\n         }\n     }\n \n@@ -1670,12 +1670,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.proc_macro_quoted_spans.set(i, span);\n             }\n \n-            record!(self.tables.def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n-            record!(self.tables.span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n+            record!(self.tables.opt_def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n+            record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.attributes[LOCAL_CRATE.as_def_id()] <- tcx.get_attrs(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n             if let Some(stability) = stability {\n-                record!(self.tables.stability[LOCAL_CRATE.as_def_id()] <- stability);\n+                record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n             }\n             self.encode_deprecation(LOCAL_CRATE.as_def_id());\n \n@@ -1711,15 +1711,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                record!(self.tables.def_kind[def_id] <- DefKind::Macro(macro_kind));\n+                record!(self.tables.opt_def_kind[def_id] <- DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n-                record!(self.tables.ident_span[def_id] <- span);\n-                record!(self.tables.span[def_id] <- span);\n+                record!(self.tables.def_ident_span[def_id] <- span);\n+                record!(self.tables.def_span[def_id] <- span);\n                 record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n                 if let Some(stability) = stability {\n-                    record!(self.tables.stability[def_id] <- stability);\n+                    record!(self.tables.lookup_stability[def_id] <- stability);\n                 }\n             }\n \n@@ -1972,7 +1972,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let def_id = def_id.to_def_id();\n                     self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                     if default.is_some() {\n-                        record!(self.tables.const_defaults[def_id] <- self.tcx.const_param_default(def_id))\n+                        record!(self.tables.const_param_default[def_id] <- self.tcx.const_param_default(def_id))\n                     }\n                 }\n             }\n@@ -1986,7 +1986,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n-        record!(self.tables.ident_span[def_id] <- ident.span);\n+        record!(self.tables.def_ident_span[def_id] <- ident.span);\n     }\n \n     /// In some cases, along with the item itself, we also"}, {"sha": "6dbab8b0a27830683eb175152aab8782e0c2e37d", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07f1bfc606874d045714b7d957027c64377d64c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=f07f1bfc606874d045714b7d957027c64377d64c", "patch": "@@ -275,35 +275,37 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-    def_kind: Table<DefIndex, Lazy<DefKind>>,\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n-    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n-    span: Table<DefIndex, Lazy<Span>>,\n-    ident_span: Table<DefIndex, Lazy<Span>>,\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n-    stability: Table<DefIndex, Lazy<attr::Stability>>,\n-    const_stability: Table<DefIndex, Lazy<attr::ConstStability>>,\n-    deprecation: Table<DefIndex, Lazy<attr::Deprecation>>,\n-    ty: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n+\n+    opt_def_kind: Table<DefIndex, Lazy<DefKind>>,\n+    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n+    def_span: Table<DefIndex, Lazy<Span>>,\n+    def_ident_span: Table<DefIndex, Lazy<Span>>,\n+    lookup_stability: Table<DefIndex, Lazy<attr::Stability>>,\n+    lookup_const_stability: Table<DefIndex, Lazy<attr::ConstStability>>,\n+    lookup_deprecation_entry: Table<DefIndex, Lazy<attr::Deprecation>>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n+    explicit_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    generics_of: Table<DefIndex, Lazy<ty::Generics>>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    inferred_outlives_of: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n+    super_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    type_of: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n+    variances_of: Table<DefIndex, Lazy<[ty::Variance]>>,\n     fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n     impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n+    const_param_default: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n+    optimized_mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    thir_abstract_const: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n+\n     trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n-    variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n-    generics: Table<DefIndex, Lazy<ty::Generics>>,\n-    explicit_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    thir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n-    const_defaults: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire"}]}