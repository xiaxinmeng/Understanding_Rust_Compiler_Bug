{"sha": "13ab1ab9de20dc7571347ff5c72026052e415dda", "node_id": "C_kwDOAAsO6NoAKDEzYWIxYWI5ZGUyMGRjNzU3MTM0N2ZmNWM3MjAyNjA1MmU0MTVkZGE", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-03-30T02:47:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-30T02:47:16Z"}, "message": "Merge pull request #129 from rust-lang/feature/simd\n\nFeature/simd", "tree": {"sha": "985b69db3e388fab7aded4c15b83799d77c6678f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985b69db3e388fab7aded4c15b83799d77c6678f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13ab1ab9de20dc7571347ff5c72026052e415dda", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiQ8S0CRBK7hj4Ov3rIwAABZMIAJ8gbjrmoOTfgm7SL2W9nvzT\ngm6cGkCCG8OPigzcE+3QmVYkzuhvV46uGnvFBSdiViG6CqFQ5HbqsDM2pYa6+7Qm\nd3ciXjyPOTSS2vp/gZrZGrAebXW+paMka2UewQ79HZoVm2HSje4Ws6jauPOULdqT\nKz2s98za26DzwCtrFIAaHoUuScy38SxZZz7HYJyedStdPAcTUzWblgu0TbqJwZdx\nbChILMCM5wy+pShNdf/UaV6wcGcC7JktiOA72A1TXKbaFyH58A/0Jvm6PTmdiEyF\nEdoHSNVFHbImjL3z1l3FAAKecRHSUGV1epujIv5oBWWrWC1D6OSDu71k2+lRm/k=\n=otXX\n-----END PGP SIGNATURE-----\n", "payload": "tree 985b69db3e388fab7aded4c15b83799d77c6678f\nparent 14c33f592ae9ecd65c5f7f2436350e8489972a60\nparent 02970a6ca89e1288e823756ec992c9070b06baee\nauthor antoyo <antoyo@users.noreply.github.com> 1648608436 -0400\ncommitter GitHub <noreply@github.com> 1648608436 -0400\n\nMerge pull request #129 from rust-lang/feature/simd\n\nFeature/simd"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13ab1ab9de20dc7571347ff5c72026052e415dda", "html_url": "https://github.com/rust-lang/rust/commit/13ab1ab9de20dc7571347ff5c72026052e415dda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13ab1ab9de20dc7571347ff5c72026052e415dda/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c33f592ae9ecd65c5f7f2436350e8489972a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c33f592ae9ecd65c5f7f2436350e8489972a60", "html_url": "https://github.com/rust-lang/rust/commit/14c33f592ae9ecd65c5f7f2436350e8489972a60"}, {"sha": "02970a6ca89e1288e823756ec992c9070b06baee", "url": "https://api.github.com/repos/rust-lang/rust/commits/02970a6ca89e1288e823756ec992c9070b06baee", "html_url": "https://github.com/rust-lang/rust/commit/02970a6ca89e1288e823756ec992c9070b06baee"}], "stats": {"total": 1114, "additions": 778, "deletions": 336}, "files": [{"sha": "0b611d05b5c93c9918232ce4274f7721b568a697", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -13,6 +13,7 @@ perf.data.old\n /rust\n /simple-raytracer\n /regex\n+/rand\n gimple*\n *asm\n res"}, {"sha": "f66c98742695a655c253ed49d9a8e6f5321644f4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#f24e1f49d99430941d8a747275b41c9a7930e049\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#f24e1f49d99430941d8a747275b41c9a7930e049\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "b25e215fb9ee9053c473e6fdfdeb7d63c57e5822", "filename": "config.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -2,7 +2,7 @@ set -e\n \n export CARGO_INCREMENTAL=0\n \n-if [ -f ./gcc_path ]; then \n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "449ca5f6e29cdc3ee3cc689a0e5989b53a593320", "filename": "crate_patches/0002-rand-Disable-failing-test.patch", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/crate_patches%2F0002-rand-Disable-failing-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/crate_patches%2F0002-rand-Disable-failing-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crate_patches%2F0002-rand-Disable-failing-test.patch?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -0,0 +1,32 @@\n+From a8fb97120d71252538b6b026695df40d02696bdb Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 15 Aug 2020 20:04:38 +0200\n+Subject: [PATCH] [rand] Disable failing test\n+\n+---\n+ src/distributions/uniform.rs | 3 ++-\n+ 1 file changed, 2 insertions(+), 1 deletion(-)\n+\n+diff --git a/src/distributions/uniform.rs b/src/distributions/uniform.rs\n+index 480b859..c80bb6f 100644\n+--- a/src/distributions/uniform.rs\n++++ b/src/distributions/uniform.rs\n+@@ -1085,7 +1085,7 @@ mod tests {\n+             _ => panic!(\"`UniformDurationMode` was not serialized/deserialized correctly\")\n+         }\n+     }\n+-    \n++\n+     #[test]\n+     #[cfg(feature = \"serde1\")]\n+     fn test_uniform_serialization() {\n+@@ -1314,6 +1314,7 @@ mod tests {\n+         not(target_arch = \"wasm32\"),\n+         not(target_arch = \"asmjs\")\n+     ))]\n++    #[ignore] // FIXME\n+     fn test_float_assertions() {\n+         use super::SampleUniform;\n+         use std::panic::catch_unwind;\n+-- \n+2.20.1"}, {"sha": "722666f7e1664cee049ba22e250b70a1d5f67bbd", "filename": "example/std_example.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -93,9 +93,9 @@ fn main() {\n \n     println!(\"{:?}\", std::intrinsics::caller_location());\n \n-    /*unsafe {\n+    unsafe {\n         test_simd();\n-    }*/\n+    }\n \n     Box::pin(move |mut _task_context| {\n         yield ();\n@@ -104,15 +104,15 @@ fn main() {\n     println!(\"End\");\n }\n \n-/*#[target_feature(enable = \"sse2\")]\n+#[target_feature(enable = \"sse2\")]\n unsafe fn test_simd() {\n     let x = _mm_setzero_si128();\n     let y = _mm_set1_epi16(7);\n     let or = _mm_or_si128(x, y);\n     let cmp_eq = _mm_cmpeq_epi8(y, y);\n     let cmp_lt = _mm_cmplt_epi8(y, y);\n \n-    /*assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n \n@@ -124,14 +124,14 @@ unsafe fn test_simd() {\n     test_mm_cvtepi8_epi16();\n     test_mm_cvtsi128_si64();\n \n-    // FIXME(#666) implement `#[rustc_arg_required_const(..)]` support\n-    //test_mm_extract_epi8();\n+    test_mm_extract_epi8();\n+    test_mm_insert_epi16();\n \n     let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n-    assert_eq!(mask1, 1);*/\n-}*/\n+    assert_eq!(mask1, 1);\n+}\n \n-/*#[target_feature(enable = \"sse2\")]\n+#[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_slli_si128() {\n     #[rustfmt::skip]\n     let a = _mm_setr_epi8(\n@@ -155,22 +155,9 @@ unsafe fn test_mm_slli_si128() {\n     );\n     let r = _mm_slli_si128(a, 16);\n     assert_eq_m128i(r, _mm_set1_epi8(0));\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -1);\n-    assert_eq_m128i(_mm_set1_epi8(0), r);\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -0x80000000);\n-    assert_eq_m128i(r, _mm_set1_epi8(0));\n }\n \n+\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_movemask_epi8() {\n     #[rustfmt::skip]\n@@ -254,10 +241,19 @@ unsafe fn test_mm_extract_epi8() {\n         8, 9, 10, 11, 12, 13, 14, 15\n     );\n     let r1 = _mm_extract_epi8(a, 0);\n-    let r2 = _mm_extract_epi8(a, 19);\n+    let r2 = _mm_extract_epi8(a, 3);\n     assert_eq!(r1, 0xFF);\n     assert_eq!(r2, 3);\n-}*/\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_insert_epi16() {\n+    let a = _mm_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7);\n+    let r = _mm_insert_epi16(a, 9, 0);\n+    let e = _mm_setr_epi16(9, 1, 2, 3, 4, 5, 6, 7);\n+    assert_eq_m128i(r, e);\n+}\n \n #[derive(PartialEq)]\n enum LoopState {"}, {"sha": "d5fa1cec061dd6f9d441246bb8bec4bc61186f6f", "filename": "patches/0024-core-Disable-portable-simd-test.patch", "status": "modified", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/patches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/patches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0024-core-Disable-portable-simd-test.patch?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -7,167 +7,6 @@ Subject: [PATCH] [core] Disable portable-simd test\n  library/core/tests/lib.rs | 1 -\n  1 file changed, 1 deletion(-)\n \n-diff --git a/library/core/src/lib.rs b/library/core/src/lib.rs\n-index aa1ad93..95fbf55 100644\n---- a/library/core/src/lib.rs\n-+++ b/library/core/src/lib.rs\n-@@ -398,23 +398,4 @@ pub mod arch {\n-     }\n- }\n- \n--// Pull in the `core_simd` crate directly into libcore. The contents of\n--// `core_simd` are in a different repository: rust-lang/portable-simd.\n--//\n--// `core_simd` depends on libcore, but the contents of this module are\n--// set up in such a way that directly pulling it here works such that the\n--// crate uses this crate as its libcore.\n--#[path = \"../../portable-simd/crates/core_simd/src/mod.rs\"]\n--#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n--#[allow(rustdoc::bare_urls)]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--mod core_simd;\n--\n--#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--pub mod simd {\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub use crate::core_simd::simd::*;\n--}\n--\n- include!(\"primitive_docs.rs\");\n-diff --git a/library/core/src/slice/mod.rs b/library/core/src/slice/mod.rs\n-index cd38c3a..ad632dc 100644\n---- a/library/core/src/slice/mod.rs\n-+++ b/library/core/src/slice/mod.rs\n-@@ -17,6 +17,5 @@ use crate::ptr;\n- use crate::result::Result;\n- use crate::result::Result::{Err, Ok};\n--use crate::simd::{self, Simd};\n- use crate::slice;\n- \n- #[unstable(\n-@@ -3475,121 +3474,6 @@ impl<T> [T] {\n-         }\n-     }\n- \n--    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n--    ///\n--    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n--    /// postconditions as that method.  You're only assured that\n--    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n--    ///\n--    /// Notably, all of the following are possible:\n--    /// - `prefix.len() >= LANES`.\n--    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n--    /// - `suffix.len() >= LANES`.\n--    ///\n--    /// That said, this is a safe method, so if you're only writing safe code,\n--    /// then this can at most cause incorrect logic, not unsoundness.\n--    ///\n--    /// # Panics\n--    ///\n--    /// This will panic if the size of the SIMD type is different from\n--    /// `LANES` times that of the scalar.\n--    ///\n--    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n--    /// that from ever happening, as only power-of-two numbers of lanes are\n--    /// supported.  It's possible that, in the future, those restrictions might\n--    /// be lifted in a way that would make it possible to see panics from this\n--    /// method for something like `LANES == 3`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// #![feature(portable_simd)]\n--    ///\n--    /// let short = &[1, 2, 3];\n--    /// let (prefix, middle, suffix) = short.as_simd::<4>();\n--    /// assert_eq!(middle, []); // Not enough elements for anything in the middle\n--    ///\n--    /// // They might be split in any possible way between prefix and suffix\n--    /// let it = prefix.iter().chain(suffix).copied();\n--    /// assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n--    ///\n--    /// fn basic_simd_sum(x: &[f32]) -> f32 {\n--    ///     use std::ops::Add;\n--    ///     use std::simd::f32x4;\n--    ///     let (prefix, middle, suffix) = x.as_simd();\n--    ///     let sums = f32x4::from_array([\n--    ///         prefix.iter().copied().sum(),\n--    ///         0.0,\n--    ///         0.0,\n--    ///         suffix.iter().copied().sum(),\n--    ///     ]);\n--    ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n--    ///     sums.reduce_sum()\n--    /// }\n--    ///\n--    /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n--    /// assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n--    /// ```\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T])\n--    where\n--        Simd<T, LANES>: AsRef<[T; LANES]>,\n--        T: simd::SimdElement,\n--        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n--    {\n--        // These are expected to always match, as vector types are laid out like\n--        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n--        // might as well double-check since it'll optimize away anyhow.\n--        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n--\n--        // SAFETY: The simd types have the same layout as arrays, just with\n--        // potentially-higher alignment, so the de-facto transmutes are sound.\n--        unsafe { self.align_to() }\n--    }\n--\n--    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n--    ///\n--    /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n--    /// postconditions as that method.  You're only assured that\n--    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n--    ///\n--    /// Notably, all of the following are possible:\n--    /// - `prefix.len() >= LANES`.\n--    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n--    /// - `suffix.len() >= LANES`.\n--    ///\n--    /// That said, this is a safe method, so if you're only writing safe code,\n--    /// then this can at most cause incorrect logic, not unsoundness.\n--    ///\n--    /// This is the mutable version of [`slice::as_simd`]; see that for examples.\n--    ///\n--    /// # Panics\n--    ///\n--    /// This will panic if the size of the SIMD type is different from\n--    /// `LANES` times that of the scalar.\n--    ///\n--    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n--    /// that from ever happening, as only power-of-two numbers of lanes are\n--    /// supported.  It's possible that, in the future, those restrictions might\n--    /// be lifted in a way that would make it possible to see panics from this\n--    /// method for something like `LANES == 3`.\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])\n--    where\n--        Simd<T, LANES>: AsMut<[T; LANES]>,\n--        T: simd::SimdElement,\n--        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n--    {\n--        // These are expected to always match, as vector types are laid out like\n--        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n--        // might as well double-check since it'll optimize away anyhow.\n--        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n--\n--        // SAFETY: The simd types have the same layout as arrays, just with\n--        // potentially-higher alignment, so the de-facto transmutes are sound.\n--        unsafe { self.align_to_mut() }\n--    }\n--\n-     /// Checks if the elements of this slice are sorted.\n-     ///\n-     /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n index 06c7be0..359e2e7 100644\n --- a/library/core/tests/lib.rs\n@@ -188,41 +27,3 @@ index 06c7be0..359e2e7 100644\n  mod slice;\n  mod str;\n  mod str_lossy;\n-diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs\n-index 5dc586d..b6fc48f 100644\n---- a/library/std/src/lib.rs\n-+++ b/library/std/src/lib.rs\n-@@ -312,6 +312,5 @@\n- #![feature(panic_can_unwind)]\n- #![feature(panic_unwind)]\n- #![feature(platform_intrinsics)]\n--#![feature(portable_simd)]\n- #![feature(prelude_import)]\n- #![feature(ptr_as_uninit)]\n-@@ -508,23 +508,6 @@ pub mod time;\n- #[unstable(feature = \"once_cell\", issue = \"74465\")]\n- pub mod lazy;\n- \n--// Pull in `std_float` crate  into libstd. The contents of\n--// `std_float` are in a different repository: rust-lang/portable-simd.\n--#[path = \"../../portable-simd/crates/std_float/src/lib.rs\"]\n--#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n--#[allow(rustdoc::bare_urls)]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--mod std_float;\n--\n--#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--pub mod simd {\n--    #[doc(inline)]\n--    pub use crate::std_float::StdFloat;\n--    #[doc(inline)]\n--    pub use core::simd::*;\n--}\n--\n- #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n- pub mod task {\n-     //! Types and Traits for working with asynchronous tasks.\n---\n-2.26.2.7.g19db9cfb68\n-"}, {"sha": "d39f43f5e1b38f74b36959d8d5e591fd9fdc7f42", "filename": "prepare.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/prepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/prepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/prepare.sh?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -5,6 +5,13 @@ source prepare_build.sh\n \n cargo install hyperfine || echo \"Skipping hyperfine install\"\n \n+git clone https://github.com/rust-random/rand.git || echo \"rust-random/rand has already been cloned\"\n+pushd rand\n+git checkout -- .\n+git checkout 0f933f9c7176e53b2a3c7952ded484e1783f0bf1\n+git am ../crate_patches/*-rand-*.patch\n+popd\n+\n git clone https://github.com/rust-lang/regex.git || echo \"rust-lang/regex has already been cloned\"\n pushd regex\n git checkout -- ."}, {"sha": "59143eac37b3f03a23ec3d7538b2a34feec9823c", "filename": "rustc_patches/compile_test.patch", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/rustc_patches%2Fcompile_test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/rustc_patches%2Fcompile_test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_patches%2Fcompile_test.patch?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -0,0 +1,14 @@\n+diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n+index 887d27fd6dca4..2c2239f2b83d1 100644\n+--- a/src/tools/compiletest/src/header.rs\n++++ b/src/tools/compiletest/src/header.rs\n+@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n+     cfg: Option<&str>,\n+ ) -> test::TestDesc {\n+     let mut ignore = false;\n+     #[cfg(not(bootstrap))]\n+-    let ignore_message: Option<String> = None;\n++    let ignore_message: Option<&str> = None;\n+     let mut should_fail = false;\n+\n+     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();"}, {"sha": "4ce5cdaccd3a183f405bf1f571aae14dd552260e", "filename": "src/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -78,6 +78,11 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         let context = Context::default();\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n+        // TODO(antoyo): only add the following cli argument if the feature is supported.\n+        context.add_command_line_option(\"-mavx2\");\n+        // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n+        // Only add if the CPU supports it.\n+        //context.add_command_line_option(\"-mavx512f\");\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "d53e1712dc8f0ae408924fa0db8b943c36d81757", "filename": "src/builder.rs", "status": "modified", "additions": 88, "deletions": 28, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -3,7 +3,6 @@ use std::cell::Cell;\n use std::convert::TryFrom;\n use std::ops::Deref;\n \n-use gccjit::FunctionType;\n use gccjit::{\n     BinaryOp,\n     Block,\n@@ -224,10 +223,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             .map(|(index, (expected_ty, &actual_val))| {\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if on_stack_param_indices.contains(&index) {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                        self.context.new_cast(None, actual_val, expected_ty)\n+                    }\n+                    else if on_stack_param_indices.contains(&index) {\n                         actual_val.dereference(None).to_rvalue()\n                     }\n                     else {\n+                        assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -286,29 +289,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n         let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n-        let mut return_type = gcc_func.get_return_type();\n+        let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n-        // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-        if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n-            return_type = self.int_type;\n-        }\n-\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n             self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n         else {\n-            if gcc_func.get_param_count() == 0 {\n-                // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n-            }\n-            else {\n-                self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n-            }\n+            self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             // Return dummy value when not having return value.\n             let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n             self.block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n@@ -529,12 +521,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() == self.cx.float_type {\n+        if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n             return self.context.new_call(None, fmodf, &[a, b]);\n         }\n-        assert_eq!(a.get_type(), self.cx.double_type);\n+        assert_eq!(a.get_type().unqualified(), self.cx.double_type);\n \n         let fmod = self.context.get_builtin_function(\"fmod\");\n         return self.context.new_call(None, fmod, &[a, b]);\n@@ -657,7 +649,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // NOTE: instead of returning the dereference here, we have to assign it to a variable in\n         // the current basic block. Otherwise, it could be used in another basic block, causing a\n         // dereference after a drop, for instance.\n-        // TODO(antoyo): handle align.\n+        // TODO(antoyo): handle align of the load instruction.\n         let deref = ptr.dereference(None).to_rvalue();\n         let value_type = deref.get_type();\n         unsafe { RETURN_VALUE_COUNT += 1 };\n@@ -797,9 +789,16 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n-    fn store_with_flags(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, _align: Align, _flags: MemFlags) -> RValue<'gcc> {\n+    fn store_with_flags(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, align: Align, _flags: MemFlags) -> RValue<'gcc> {\n         let ptr = self.check_store(val, ptr);\n-        self.llbb().add_assignment(None, ptr.dereference(None), val);\n+        let destination = ptr.dereference(None);\n+        // NOTE: libgccjit does not support specifying the alignment on the assignment, so we cast\n+        // to type so it gets the proper alignment.\n+        let destination_type = destination.to_rvalue().get_type().unqualified();\n+        let aligned_type = destination_type.get_aligned(align.bytes()).make_pointer();\n+        let aligned_destination = self.cx.context.new_bitcast(None, ptr, aligned_type);\n+        let aligned_destination = aligned_destination.dereference(None);\n+        self.llbb().add_assignment(None, aligned_destination, val);\n         // TODO(antoyo): handle align and flags.\n         // NOTE: dummy value here since it's never used. FIXME(antoyo): API should not return a value here?\n         self.cx.context.new_rvalue_zero(self.type_i32())\n@@ -1288,14 +1287,75 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let return_type = v1.get_type();\n-        let params = [\n-            self.context.new_parameter(None, return_type, \"v1\"),\n-            self.context.new_parameter(None, return_type, \"v2\"),\n-            self.context.new_parameter(None, mask.get_type(), \"mask\"),\n-        ];\n-        let shuffle = self.context.new_function(None, FunctionType::Extern, return_type, &params, \"_mm_shuffle_epi8\", false);\n-        self.context.new_call(None, shuffle, &[v1, v2, mask])\n+        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+\n+        // TODO(antoyo): use a recursive unqualified() here.\n+        let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let vec_num_units = vector_type.get_num_units();\n+\n+        let mask_num_units = struct_type.get_field_count();\n+        let mut vector_elements = vec![];\n+        let mask_element_type =\n+            if element_type.is_integral() {\n+                element_type\n+            }\n+            else {\n+                self.int_type\n+            };\n+        for i in 0..mask_num_units {\n+            let field = struct_type.get_field(i as i32);\n+            vector_elements.push(self.context.new_cast(None, mask.access_field(None, field).to_rvalue(), mask_element_type));\n+        }\n+\n+        // NOTE: the mask needs to be the same length as the input vectors, so add the missing\n+        // elements in the mask if needed.\n+        for _ in mask_num_units..vec_num_units {\n+            vector_elements.push(self.context.new_rvalue_zero(mask_element_type));\n+        }\n+\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n+        let result_type = self.context.new_vector_type(element_type, mask_num_units as u64);\n+        let (v1, v2) =\n+            if vec_num_units < mask_num_units {\n+                // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n+                // vectors and create a dummy second vector.\n+                let array = self.context.new_bitcast(None, v1, array_type);\n+                let mut elements = vec![];\n+                for i in 0..vec_num_units {\n+                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                }\n+                let array = self.context.new_bitcast(None, v2, array_type);\n+                for i in 0..vec_num_units {\n+                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                }\n+                let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n+                let zero = self.context.new_rvalue_zero(element_type);\n+                let v2 = self.context.new_rvalue_from_vector(None, result_type, &vec![zero; mask_num_units]);\n+                (v1, v2)\n+            }\n+            else {\n+                (v1, v2)\n+            };\n+\n+        let new_mask_num_units = std::cmp::max(mask_num_units, vec_num_units);\n+        let mask_type = self.context.new_vector_type(mask_element_type, new_mask_num_units as u64);\n+        let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n+        let result = self.context.new_rvalue_vector_perm(None, v1, v2, mask);\n+\n+        if vec_num_units != mask_num_units {\n+            // NOTE: if padding was added, only select the number of elements of the masks to\n+            // remove that padding in the result.\n+            let mut elements = vec![];\n+            let array = self.context.new_bitcast(None, result, array_type);\n+            for i in 0..mask_num_units {\n+                elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+            }\n+            self.context.new_rvalue_from_vector(None, result_type, &elements)\n+        }\n+        else {\n+            result\n+        }\n     }\n }\n "}, {"sha": "703e20947fe8e09d6edd12b0959319df74d10c5a", "filename": "src/common.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -322,6 +322,8 @@ pub trait TypeReflection<'gcc, 'tcx>  {\n \n     fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+\n+    fn is_vector(&self) -> bool;\n }\n \n impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n@@ -392,4 +394,21 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n         self.unqualified() == cx.context.new_type::<f64>()\n     }\n+\n+    fn is_vector(&self) -> bool {\n+        let mut typ = self.clone();\n+        loop {\n+            if typ.dyncast_vector().is_some() {\n+                return true;\n+            }\n+\n+            let old_type = typ;\n+            typ = typ.unqualified();\n+            if old_type == typ {\n+                break;\n+            }\n+        }\n+\n+        false\n+    }\n }"}, {"sha": "4350c00e94a7c0e67bf1e59afaf3b8da2a1224a8", "filename": "src/consts.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -25,7 +25,14 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                 }\n             }\n         }\n-        self.context.new_bitcast(None, value, typ)\n+        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n+        // SIMD builtins require a constant value.\n+        if value.get_type() != typ {\n+            self.context.new_bitcast(None, value, typ)\n+        }\n+        else {\n+            value\n+        }\n     }\n }\n \n@@ -171,8 +178,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n                     // TODO(antoyo): check if it's okay that no link_section is set.\n-                    // TODO(antoyo): set alignment here as well.\n-                    let global = self.declare_private_global(&name[..], self.val_ty(cv));\n+\n+                    let typ = self.val_ty(cv).get_aligned(align.bytes());\n+                    let global = self.declare_private_global(&name[..], typ);\n                     global\n                 }\n                 _ => {"}, {"sha": "83c4683a66838c2f73612b61ce77de36ab6c585b", "filename": "src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -269,11 +269,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn is_native_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n-        self.is_native_int_type(typ) || typ == self.bool_type\n+        self.is_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n     pub fn is_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n-        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ == self.bool_type\n+        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n     pub fn sess(&self) -> &Session {"}, {"sha": "ed779d5d888db799cee8ba5c15728a8a1d176242", "filename": "src/int.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fint.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -153,8 +153,14 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let a_type = a.get_type();\n         let b_type = b.get_type();\n         if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n-            if a.get_type() != b.get_type() {\n-                b = self.context.new_cast(None, b, a.get_type());\n+            if a_type != b_type {\n+                if a_type.is_vector() {\n+                    // Vector types need to be bitcast.\n+                    b = self.context.new_bitcast(None, b, a.get_type());\n+                }\n+                else {\n+                    b = self.context.new_cast(None, b, a.get_type());\n+                }\n             }\n             self.context.new_binary_op(None, operation, a_type, a, b)\n         }\n@@ -593,7 +599,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let b_type = b.get_type();\n         let a_native = self.is_native_int_type_or_bool(a_type);\n         let b_native = self.is_native_int_type_or_bool(b_type);\n-        if a_native && b_native {\n+        if a_type.is_vector() && b_type.is_vector() {\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else if a_native && b_native {\n             if a_type != b_type {\n                 b = self.context.new_cast(None, b, a_type);\n             }\n@@ -639,6 +648,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         else {\n             // Since u128 and i128 are the only types that can be unsupported, we know the type of\n             // value and the destination type have the same size, so a bitcast is fine.\n+\n+            // TODO(antoyo): perhaps use __builtin_convertvector for vector casting. (This is elsewhere,\n+            // though.)\n             self.context.new_bitcast(None, value, dest_typ)\n         }\n     }"}, {"sha": "1a2a352b5a3bd9642d50984a30ee93e034b7dc2c", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 112, "deletions": 10, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -3,20 +3,122 @@ use gccjit::Function;\n use crate::context::CodegenCx;\n \n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n-    let _gcc_name =\n+    let gcc_name =\n         match name {\n-            \"llvm.x86.xgetbv\" => {\n-                let gcc_name = \"__builtin_trap\";\n-                let func = cx.context.get_builtin_function(gcc_name);\n-                cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n-                return func;\n-            },\n+            \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n             // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n+            \"llvm.x86.sse2.pmovmskb.128\" => \"__builtin_ia32_pmovmskb128\",\n+            \"llvm.x86.avx2.pmovmskb\" => \"__builtin_ia32_pmovmskb256\",\n             \"llvm.x86.sse2.cmp.pd\" => \"__builtin_ia32_cmppd\",\n             \"llvm.x86.sse2.movmsk.pd\" => \"__builtin_ia32_movmskpd\",\n-            \"llvm.x86.sse2.pmovmskb.128\" => \"__builtin_ia32_pmovmskb128\",\n-            _ => unimplemented!(\"unsupported LLVM intrinsic {}\", name)\n+            \"llvm.x86.ssse3.pshuf.b.128\" => \"__builtin_ia32_pshufb128\",\n+            \"llvm.x86.sse2.pause\" => \"__builtin_ia32_pause\",\n+            \"llvm.x86.avx2.pshuf.b\" => \"__builtin_ia32_pshufb256\",\n+            \"llvm.x86.avx2.pslli.d\" => \"__builtin_ia32_pslldi256\",\n+            \"llvm.x86.avx2.psrli.d\" => \"__builtin_ia32_psrldi256\",\n+            \"llvm.x86.avx.vzeroupper\" => \"__builtin_ia32_vzeroupper\",\n+            \"llvm.x86.avx2.vperm2i128\" => \"__builtin_ia32_permti256\",\n+            \"llvm.x86.avx2.psrli.w\" => \"__builtin_ia32_psrlwi256\",\n+            \"llvm.x86.sse2.storeu.dq\" => \"__builtin_ia32_storedqu\",\n+            \"llvm.x86.sse2.psrli.w\" => \"__builtin_ia32_psrlwi128\",\n+            \"llvm.x86.avx2.pabs.d\" => \"__builtin_ia32_pabsd256\",\n+            \"llvm.x86.sse2.psrli.q\" => \"__builtin_ia32_psrlqi128\",\n+            \"llvm.x86.avx2.pabs.w\" => \"__builtin_ia32_pabsw256\",\n+            \"llvm.x86.avx2.pblendvb\" => \"__builtin_ia32_pblendvb256\",\n+            \"llvm.x86.avx2.pabs.b\" => \"__builtin_ia32_pabsb256\",\n+            \"llvm.x86.avx2.psrli.q\" => \"__builtin_ia32_psrlqi256\",\n+            \"llvm.x86.sse41.pblendvb\" => \"__builtin_ia32_pblendvb128\",\n+            \"llvm.x86.avx2.pavg.w\" => \"__builtin_ia32_pavgw256\",\n+            \"llvm.x86.avx2.pavg.b\" => \"__builtin_ia32_pavgb256\",\n+            \"llvm.x86.avx2.phadd.w\" => \"__builtin_ia32_phaddw256\",\n+            \"llvm.x86.avx2.phadd.d\" => \"__builtin_ia32_phaddd256\",\n+            \"llvm.x86.avx2.phadd.sw\" => \"__builtin_ia32_phaddsw256\",\n+            \"llvm.x86.avx2.phsub.w\" => \"__builtin_ia32_phsubw256\",\n+            \"llvm.x86.avx2.phsub.d\" => \"__builtin_ia32_phsubd256\",\n+            \"llvm.x86.avx2.phsub.sw\" => \"__builtin_ia32_phsubsw256\",\n+            \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gatherd_d\",\n+            \"llvm.x86.avx2.gather.d.d.256\" => \"__builtin_ia32_gatherd_d256\",\n+            \"llvm.x86.avx2.gather.d.ps\" => \"__builtin_ia32_gatherd_ps\",\n+            \"llvm.x86.avx2.gather.d.ps.256\" => \"__builtin_ia32_gatherd_ps256\",\n+            \"llvm.x86.avx2.gather.d.q\" => \"__builtin_ia32_gatherd_q\",\n+            \"llvm.x86.avx2.gather.d.q.256\" => \"__builtin_ia32_gatherd_q256\",\n+            \"llvm.x86.avx2.gather.d.pd\" => \"__builtin_ia32_gatherd_pd\",\n+            \"llvm.x86.avx2.gather.d.pd.256\" => \"__builtin_ia32_gatherd_pd256\",\n+            \"llvm.x86.avx2.gather.q.d\" => \"__builtin_ia32_gatherq_d\",\n+            \"llvm.x86.avx2.gather.q.d.256\" => \"__builtin_ia32_gatherq_d256\",\n+            \"llvm.x86.avx2.gather.q.ps\" => \"__builtin_ia32_gatherq_ps\",\n+            \"llvm.x86.avx2.gather.q.ps.256\" => \"__builtin_ia32_gatherq_ps256\",\n+            \"llvm.x86.avx2.gather.q.q\" => \"__builtin_ia32_gatherq_q\",\n+            \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherq_q256\",\n+            \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherq_pd\",\n+            \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherq_pd256\",\n+            \"llvm.x86.avx2.pmadd.wd\" => \"__builtin_ia32_pmaddwd256\",\n+            \"llvm.x86.avx2.pmadd.ub.sw\" => \"__builtin_ia32_pmaddubsw256\",\n+            \"llvm.x86.avx2.maskload.d\" => \"__builtin_ia32_maskloadd\",\n+            \"llvm.x86.avx2.maskload.d.256\" => \"__builtin_ia32_maskloadd256\",\n+            \"llvm.x86.avx2.maskload.q\" => \"__builtin_ia32_maskloadq\",\n+            \"llvm.x86.avx2.maskload.q.256\" => \"__builtin_ia32_maskloadq256\",\n+            \"llvm.x86.avx2.maskstore.d\" => \"__builtin_ia32_maskstored\",\n+            \"llvm.x86.avx2.maskstore.d.256\" => \"__builtin_ia32_maskstored256\",\n+            \"llvm.x86.avx2.maskstore.q\" => \"__builtin_ia32_maskstoreq\",\n+            \"llvm.x86.avx2.maskstore.q.256\" => \"__builtin_ia32_maskstoreq256\",\n+            \"llvm.x86.avx2.pmaxs.w\" => \"__builtin_ia32_pmaxsw256\",\n+            \"llvm.x86.avx2.pmaxs.d\" => \"__builtin_ia32_pmaxsd256\",\n+            \"llvm.x86.avx2.pmaxs.b\" => \"__builtin_ia32_pmaxsb256\",\n+            \"llvm.x86.avx2.pmaxu.w\" => \"__builtin_ia32_pmaxuw256\",\n+            \"llvm.x86.avx2.pmaxu.d\" => \"__builtin_ia32_pmaxud256\",\n+            \"llvm.x86.avx2.pmaxu.b\" => \"__builtin_ia32_pmaxub256\",\n+            \"llvm.x86.avx2.pmins.w\" => \"__builtin_ia32_pminsw256\",\n+            \"llvm.x86.avx2.pmins.d\" => \"__builtin_ia32_pminsd256\",\n+            \"llvm.x86.avx2.pmins.b\" => \"__builtin_ia32_pminsb256\",\n+            \"llvm.x86.avx2.pminu.w\" => \"__builtin_ia32_pminuw256\",\n+            \"llvm.x86.avx2.pminu.d\" => \"__builtin_ia32_pminud256\",\n+            \"llvm.x86.avx2.pminu.b\" => \"__builtin_ia32_pminub256\",\n+            \"llvm.x86.avx2.mpsadbw\" => \"__builtin_ia32_mpsadbw256\",\n+            \"llvm.x86.avx2.pmul.dq\" => \"__builtin_ia32_pmuldq256\",\n+            \"llvm.x86.avx2.pmulu.dq\" => \"__builtin_ia32_pmuludq256\",\n+            \"llvm.x86.avx2.pmulh.w\" => \"__builtin_ia32_pmulhw256\",\n+            \"llvm.x86.avx2.pmulhu.w\" => \"__builtin_ia32_pmulhuw256\",\n+            \"llvm.x86.avx2.pmul.hr.sw\" => \"__builtin_ia32_pmulhrsw256\",\n+            \"llvm.x86.avx2.packsswb\" => \"__builtin_ia32_packsswb256\",\n+            \"llvm.x86.avx2.packssdw\" => \"__builtin_ia32_packssdw256\",\n+            \"llvm.x86.avx2.packuswb\" => \"__builtin_ia32_packuswb256\",\n+            \"llvm.x86.avx2.packusdw\" => \"__builtin_ia32_packusdw256\",\n+            \"llvm.x86.avx2.permd\" => \"__builtin_ia32_permvarsi256\",\n+            \"llvm.x86.avx2.permps\" => \"__builtin_ia32_permvarsf256\",\n+            \"llvm.x86.avx2.psad.bw\" => \"__builtin_ia32_psadbw256\",\n+            \"llvm.x86.avx2.psign.w\" => \"__builtin_ia32_psignw256\",\n+            \"llvm.x86.avx2.psign.d\" => \"__builtin_ia32_psignd256\",\n+            \"llvm.x86.avx2.psign.b\" => \"__builtin_ia32_psignb256\",\n+            \"llvm.x86.avx2.psll.w\" => \"__builtin_ia32_psllw256\",\n+            \"llvm.x86.avx2.psll.d\" => \"__builtin_ia32_pslld256\",\n+            \"llvm.x86.avx2.psll.q\" => \"__builtin_ia32_psllq256\",\n+            \"llvm.x86.avx2.pslli.w\" => \"__builtin_ia32_psllwi256\",\n+            \"llvm.x86.avx2.pslli.q\" => \"__builtin_ia32_psllqi256\",\n+            \"llvm.x86.avx2.psllv.d\" => \"__builtin_ia32_psllv4si\",\n+            \"llvm.x86.avx2.psllv.d.256\" => \"__builtin_ia32_psllv8si\",\n+            \"llvm.x86.avx2.psllv.q\" => \"__builtin_ia32_psllv2di\",\n+            \"llvm.x86.avx2.psllv.q.256\" => \"__builtin_ia32_psllv4di\",\n+            \"llvm.x86.avx2.psra.w\" => \"__builtin_ia32_psraw256\",\n+            \"llvm.x86.avx2.psra.d\" => \"__builtin_ia32_psrad256\",\n+            \"llvm.x86.avx2.psrai.w\" => \"__builtin_ia32_psrawi256\",\n+            \"llvm.x86.avx2.psrai.d\" => \"__builtin_ia32_psradi256\",\n+            \"llvm.x86.avx2.psrav.d\" => \"__builtin_ia32_psrav4si\",\n+            \"llvm.x86.avx2.psrav.d.256\" => \"__builtin_ia32_psrav8si\",\n+            \"llvm.x86.avx2.psrl.w\" => \"__builtin_ia32_psrlw256\",\n+            \"llvm.x86.avx2.psrl.d\" => \"__builtin_ia32_psrld256\",\n+            \"llvm.x86.avx2.psrl.q\" => \"__builtin_ia32_psrlq256\",\n+            \"llvm.x86.avx2.psrlv.d\" => \"__builtin_ia32_psrlv4si\",\n+            \"llvm.x86.avx2.psrlv.d.256\" => \"__builtin_ia32_psrlv8si\",\n+            \"llvm.x86.avx2.psrlv.q\" => \"__builtin_ia32_psrlv2di\",\n+            \"llvm.x86.avx2.psrlv.q.256\" => \"__builtin_ia32_psrlv4di\",\n+            \"llvm.x86.sse.sqrt.ss\" => \"__builtin_ia32_sqrtss\",\n+\n+            \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n+            _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\n         };\n \n-    unimplemented!();\n+    let func = cx.context.get_target_builtin_function(gcc_name);\n+    cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+    func\n }"}, {"sha": "11f1e7dd99937a079a8d66b30ef262ecedd0eda2", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 356, "deletions": 4, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -1,4 +1,6 @@\n-use gccjit::{RValue, Type};\n+use std::cmp::Ordering;\n+\n+use gccjit::{RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -10,6 +12,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, Symbol, sym};\n \n use crate::builder::Builder;\n+use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n@@ -100,9 +103,27 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     }\n \n     if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n-        let n: u64 = stripped.parse().unwrap_or_else(|_| {\n-            span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n-        });\n+        let n: u64 =\n+            if stripped.is_empty() {\n+                // Make sure this is actually an array, since typeck only checks the length-suffixed\n+                // version of this intrinsic.\n+                match args[2].layout.ty.kind() {\n+                    ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n+                        len.try_eval_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(|| {\n+                            span_bug!(span, \"could not evaluate shuffle index array length\")\n+                        })\n+                    }\n+                    _ => return_error!(\n+                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n+                        args[2].layout.ty\n+                    ),\n+                }\n+            }\n+            else {\n+                stripped.parse().unwrap_or_else(|_| {\n+                    span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n+                })\n+            };\n \n         require_simd!(ret_ty, \"return\");\n \n@@ -133,6 +154,202 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         ));\n     }\n \n+    if name == sym::simd_insert {\n+        require!(\n+            in_elem == arg_tys[2],\n+            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n+            in_elem,\n+            in_ty,\n+            arg_tys[2]\n+        );\n+        let vector = args[0].immediate();\n+        let index = args[1].immediate();\n+        let value = args[2].immediate();\n+        // TODO(antoyo): use a recursive unqualified() here.\n+        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        // NOTE: we cannot cast to an array and assign to its element here because the value might\n+        // not be an l-value. So, call a builtin to set the element.\n+        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n+        let func_name =\n+            match in_len {\n+                2 => {\n+                    if element_type == bx.i64_type {\n+                        \"__builtin_ia32_vec_set_v2di\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                4 => {\n+                    if element_type == bx.i32_type {\n+                        \"__builtin_ia32_vec_set_v4si\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                8 => {\n+                    if element_type == bx.i16_type {\n+                        \"__builtin_ia32_vec_set_v8hi\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                _ => unimplemented!(\"Len: {}\", in_len),\n+            };\n+        let builtin = bx.context.get_target_builtin_function(func_name);\n+        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n+        let vector =\n+            if vector.get_type() != param1_type {\n+                bx.context.new_bitcast(None, vector, param1_type)\n+            }\n+            else {\n+                vector\n+            };\n+        let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n+        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+    }\n+    if name == sym::simd_extract {\n+        require!(\n+            ret_ty == in_elem,\n+            \"expected return type `{}` (element of input `{}`), found `{}`\",\n+            in_elem,\n+            in_ty,\n+            ret_ty\n+        );\n+        let vector = args[0].immediate();\n+        return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n+    }\n+\n+    if name == sym::simd_cast {\n+        require_simd!(ret_ty, \"return\");\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+        // casting cares about nominal type, not just structural type\n+        if in_elem == out_elem {\n+            return Ok(args[0].immediate());\n+        }\n+\n+        enum Style {\n+            Float,\n+            Int(/* is signed? */ bool),\n+            Unsupported,\n+        }\n+\n+        let (in_style, in_width) = match in_elem.kind() {\n+            // vectors of pointer-sized integers should've been\n+            // disallowed before here, so this unwrap is safe.\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0),\n+        };\n+        let (out_style, out_width) = match out_elem.kind() {\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0),\n+        };\n+\n+        let extend = |in_type, out_type| {\n+            let vector_type = bx.context.new_vector_type(out_type, 8);\n+            let vector = args[0].immediate();\n+            let array_type = bx.context.new_array_type(None, in_type, 8);\n+            let array = bx.context.new_bitcast(None, vector, array_type);\n+\n+            let cast_vec_element = |index| {\n+                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n+                bx.context.new_cast(None, bx.context.new_array_access(None, array, index).to_rvalue(), out_type)\n+            };\n+\n+            bx.context.new_rvalue_from_vector(None, vector_type, &[\n+                cast_vec_element(0),\n+                cast_vec_element(1),\n+                cast_vec_element(2),\n+                cast_vec_element(3),\n+                cast_vec_element(4),\n+                cast_vec_element(5),\n+                cast_vec_element(6),\n+                cast_vec_element(7),\n+            ])\n+        };\n+\n+        match (in_style, out_style) {\n+            (Style::Int(in_is_signed), Style::Int(_)) => {\n+                return Ok(match in_width.cmp(&out_width) {\n+                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n+                    Ordering::Less => {\n+                        if in_is_signed {\n+                            match (in_width, out_width) {\n+                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n+                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n+                                // we can generate a call to it.\n+                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n+                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n+                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n+                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n+                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n+                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n+                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n+                            }\n+                        } else {\n+                            match (in_width, out_width) {\n+                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n+                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n+                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n+                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n+                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n+                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n+                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+            (Style::Int(_), Style::Float) => {\n+                unimplemented!();\n+            }\n+            (Style::Float, Style::Int(_)) => {\n+                unimplemented!();\n+            }\n+            (Style::Float, Style::Float) => {\n+                unimplemented!();\n+            }\n+            _ => { /* Unsupported. Fallthrough. */ }\n+        }\n+        require!(\n+            false,\n+            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+            in_ty,\n+            in_elem,\n+            ret_ty,\n+            out_elem\n+        );\n+    }\n+\n     macro_rules! arith_binary {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n             $(if name == sym::$name {\n@@ -150,6 +367,105 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         }\n     }\n \n+    fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n+        name: Symbol,\n+        in_elem: Ty<'_>,\n+        in_ty: Ty<'_>,\n+        in_len: u64,\n+        bx: &mut Builder<'_, 'gcc, 'tcx>,\n+        span: Span,\n+        args: &[OperandRef<'tcx, RValue<'gcc>>],\n+    ) -> Result<RValue<'gcc>, ()> {\n+        macro_rules! emit_error {\n+            ($msg: tt) => {\n+                emit_error!($msg, )\n+            };\n+            ($msg: tt, $($fmt: tt)*) => {\n+                span_invalid_monomorphization_error(\n+                    bx.sess(), span,\n+                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n+                             name, $($fmt)*));\n+            }\n+        }\n+        macro_rules! return_error {\n+            ($($fmt: tt)*) => {\n+                {\n+                    emit_error!($($fmt)*);\n+                    return Err(());\n+                }\n+            }\n+        }\n+\n+        let (elem_ty_str, elem_ty) =\n+            if let ty::Float(f) = in_elem.kind() {\n+                let elem_ty = bx.cx.type_float_from_ty(*f);\n+                match f.bit_width() {\n+                    32 => (\"f32\", elem_ty),\n+                    64 => (\"f64\", elem_ty),\n+                    _ => {\n+                        return_error!(\n+                            \"unsupported element type `{}` of floating-point vector `{}`\",\n+                            f.name_str(),\n+                            in_ty\n+                        );\n+                    }\n+                }\n+            }\n+            else {\n+                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            };\n+\n+        let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n+\n+        let (intr_name, fn_ty) =\n+            match name {\n+                sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)), // TODO(antoyo): pand with 170141183420855150465331762880109871103\n+                sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n+                sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n+                sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n+                sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n+                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+            };\n+        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n+        let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n+        let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n+        let c = bx.call(fn_ty, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        Ok(c)\n+    }\n+\n+    if std::matches!(\n+        name,\n+        sym::simd_ceil\n+            | sym::simd_fabs\n+            | sym::simd_fcos\n+            | sym::simd_fexp2\n+            | sym::simd_fexp\n+            | sym::simd_flog10\n+            | sym::simd_flog2\n+            | sym::simd_flog\n+            | sym::simd_floor\n+            | sym::simd_fma\n+            | sym::simd_fpow\n+            | sym::simd_fpowi\n+            | sym::simd_fsin\n+            | sym::simd_fsqrt\n+            | sym::simd_round\n+            | sym::simd_trunc\n+    ) {\n+        return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n@@ -184,5 +500,41 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         simd_neg: Int => neg, Float => fneg;\n     }\n \n+    if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n+        let lhs = args[0].immediate();\n+        let rhs = args[1].immediate();\n+        let is_add = name == sym::simd_saturating_add;\n+        let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n+        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n+            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n+            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n+            _ => {\n+                return_error!(\n+                    \"expected element type `{}` of vector type `{}` \\\n+                     to be a signed or unsigned integer type\",\n+                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    arg_tys[0]\n+                );\n+            }\n+        };\n+        let builtin_name =\n+            match (signed, is_add, in_len, elem_width) {\n+                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n+                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n+                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n+                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n+                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n+                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n+                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n+                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n+                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n+            };\n+        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n+\n+        let func = bx.context.get_target_builtin_function(builtin_name);\n+        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n+        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+    }\n+\n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "a8029f0425a4a28fb4fda08855b4de2c1534aa35", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -205,7 +205,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n     fn run_fat_lto(_cgcx: &CodegenContext<Self>, mut modules: Vec<FatLTOInput<Self>>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<LtoModuleCodegen<Self>, FatalError> {\n         // TODO(antoyo): implement LTO by sending -flto to libgccjit and adding the appropriate gcc linker plugins.\n         // NOTE: implemented elsewhere.\n-        // TODO: what is implemented elsewhere ^ ?\n+        // TODO(antoyo): what is implemented elsewhere ^ ?\n         let module =\n             match modules.remove(0) {\n                 FatLTOInput::InMemory(module) => module,\n@@ -299,9 +299,17 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n                 if sess.is_nightly_build() || gate.is_none() { Some(feature) } else { None }\n             },\n         )\n-        .filter(|_feature| {\n+        .filter(|feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n-            false\n+            // Probably using the equivalent of __builtin_cpu_supports.\n+            feature.contains(\"sse\") || feature.contains(\"avx\")\n+            /*\n+               adx, aes, avx, avx2, avx512bf16, avx512bitalg, avx512bw, avx512cd, avx512dq, avx512er, avx512f, avx512gfni,\n+               avx512ifma, avx512pf, avx512vaes, avx512vbmi, avx512vbmi2, avx512vl, avx512vnni, avx512vp2intersect, avx512vpclmulqdq,\n+               avx512vpopcntdq, bmi1, bmi2, cmpxchg16b, ermsb, f16c, fma, fxsr, lzcnt, movbe, pclmulqdq, popcnt, rdrand, rdseed, rtm,\n+               sha, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, xsave, xsavec, xsaveopt, xsaves\n+             */\n+            //false\n         })\n         .map(|feature| Symbol::intern(feature))\n         .collect()"}, {"sha": "8a17d94da41f2a079e4e1a018c4eea1e20835a23", "filename": "src/type_.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -3,10 +3,11 @@ use std::convert::TryInto;\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods};\n use rustc_codegen_ssa::common::TypeKind;\n-use rustc_middle::bug;\n+use rustc_middle::{bug, ty};\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n+use crate::common::TypeReflection;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n@@ -60,6 +61,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ity = Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n+\n+    pub fn type_vector(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        self.context.new_vector_type(ty, len)\n+    }\n+\n+    pub fn type_float_from_ty(&self, t: ty::FloatTy) -> Type<'gcc> {\n+        match t {\n+            ty::FloatTy::F32 => self.type_f32(),\n+            ty::FloatTy::F64 => self.type_f64(),\n+        }\n+    }\n }\n \n impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -127,7 +139,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         else if typ.is_compatible_with(self.double_type) {\n             TypeKind::Double\n         }\n-        else if typ.dyncast_vector().is_some() {\n+        else if typ.is_vector() {\n             TypeKind::Vector\n         }\n         else {\n@@ -141,7 +153,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn type_ptr_to_ext(&self, ty: Type<'gcc>, _address_space: AddressSpace) -> Type<'gcc> {\n-        // TODO(antoyo): use address_space\n+        // TODO(antoyo): use address_space, perhaps with TYPE_ADDR_SPACE?\n         ty.make_pointer()\n     }\n \n@@ -167,10 +179,10 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn float_width(&self, typ: Type<'gcc>) -> usize {\n         let f32 = self.context.new_type::<f32>();\n         let f64 = self.context.new_type::<f64>();\n-        if typ == f32 {\n+        if typ.is_compatible_with(f32) {\n             32\n         }\n-        else if typ == f64 {\n+        else if typ.is_compatible_with(f64) {\n             64\n         }\n         else {"}, {"sha": "c6d6f91a7429c756141b5a2a7d437021b60977ca", "filename": "src/type_of.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -24,6 +24,28 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             I128 => self.type_u128(),\n         }\n     }\n+\n+    pub fn type_int_from_ty(&self, t: ty::IntTy) -> Type<'gcc> {\n+        match t {\n+            ty::IntTy::Isize => self.type_isize(),\n+            ty::IntTy::I8 => self.type_i8(),\n+            ty::IntTy::I16 => self.type_i16(),\n+            ty::IntTy::I32 => self.type_i32(),\n+            ty::IntTy::I64 => self.type_i64(),\n+            ty::IntTy::I128 => self.type_i128(),\n+        }\n+    }\n+\n+    pub fn type_uint_from_ty(&self, t: ty::UintTy) -> Type<'gcc> {\n+        match t {\n+            ty::UintTy::Usize => self.type_isize(),\n+            ty::UintTy::U8 => self.type_i8(),\n+            ty::UintTy::U16 => self.type_i16(),\n+            ty::UintTy::U32 => self.type_i32(),\n+            ty::UintTy::U64 => self.type_i64(),\n+            ty::UintTy::U128 => self.type_i128(),\n+        }\n+    }\n }\n \n pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {"}, {"sha": "1d2fbd0a24cfe68a7f68ca6cff54de5ac2bea4bb", "filename": "test.sh", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/13ab1ab9de20dc7571347ff5c72026052e415dda/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/13ab1ab9de20dc7571347ff5c72026052e415dda/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=13ab1ab9de20dc7571347ff5c72026052e415dda", "patch": "@@ -97,25 +97,6 @@ function std_tests() {\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n \n-# TODO(antoyo): uncomment when it works.\n-#pushd simple-raytracer\n-#if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs ${RUN_RUNS:-10} --warmup 1 --prepare \"rm -r target/*/debug || true\" \\\n-    #\"RUSTFLAGS='' cargo build --target $TARGET_TRIPLE\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/*/debug/main ./raytracer_cg_gccjit\n-    #hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_gccjit\n-#else\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n-    #echo \"[COMPILE] ebobby/simple-raytracer\"\n-    #../cargo.sh build\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n-#fi\n-#popd\n-\n function test_libcore() {\n     pushd build_sysroot/sysroot_src/library/core/tests\n     echo \"[TEST] libcore\"\n@@ -124,19 +105,6 @@ function test_libcore() {\n     popd\n }\n \n-# TODO(antoyo): uncomment when it works.\n-#pushd regex\n-#echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-#../cargo.sh clean\n-## Make sure `[codegen mono items] start` doesn't poison the diff\n-#../cargo.sh build --example shootout-regex-dna\n-#cat examples/regexdna-input.txt | ../cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n-#diff -u res.txt examples/regexdna-output.txt\n-\n-#echo \"[TEST] rust-lang/regex tests\"\n-#../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options\n-#popd\n-\n #echo\n #echo \"[BENCH COMPILE] mod_bench\"\n \n@@ -153,6 +121,40 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n+function extended_sysroot_tests() {\n+    pushd rand\n+    cargo clean\n+    echo \"[TEST] rust-random/rand\"\n+    ../cargo.sh test --workspace\n+    popd\n+\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n+\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n+\n+    pushd regex\n+    echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n+    cargo clean\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n+    # Make sure `[codegen mono items] start` doesn't poison the diff\n+    ../cargo.sh build --example shootout-regex-dna\n+    cat examples/regexdna-input.txt \\\n+        | ../cargo.sh run --example shootout-regex-dna \\\n+        | grep -v \"Spawned thread\" > res.txt\n+    diff -u res.txt examples/regexdna-output.txt\n+\n+    echo \"[TEST] rust-lang/regex tests\"\n+    ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    popd\n+}\n+\n function test_rustc() {\n     echo\n     echo \"[TEST] rust-lang/rust\"\n@@ -165,23 +167,7 @@ function test_rustc() {\n     git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n     export RUSTFLAGS=\n \n-    git apply - <<EOF\n-diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n-index 887d27fd6dca4..2c2239f2b83d1 100644\n---- a/src/tools/compiletest/src/header.rs\n-+++ b/src/tools/compiletest/src/header.rs\n-@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n-     cfg: Option<&str>,\n- ) -> test::TestDesc {\n-     let mut ignore = false;\n-     #[cfg(not(bootstrap))]\n--    let ignore_message: Option<String> = None;\n-+    let ignore_message: Option<&str> = None;\n-     let mut should_fail = false;\n-\n-     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n-\n-EOF\n+    git apply ../rustc_patches/compile_test.patch || true\n \n     rm config.toml || true\n \n@@ -205,7 +191,7 @@ EOF\n \n     git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n     for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n       rm $test\n     done\n@@ -239,6 +225,10 @@ case $1 in\n         std_tests\n         ;;\n \n+    \"--extended-tests\")\n+        extended_sysroot_tests\n+        ;;\n+\n     \"--build-sysroot\")\n         build_sysroot\n         ;;\n@@ -249,6 +239,7 @@ case $1 in\n         build_sysroot\n         std_tests\n         test_libcore\n+        extended_sysroot_tests\n         test_rustc\n         ;;\n esac"}]}