{"sha": "c2afca36672a85248f4da3e8db8cdfac198ad4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYWZjYTM2NjcyYTg1MjQ4ZjRkYTNlOGRiOGNkZmFjMTk4YWQ0YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-31T11:25:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-31T11:25:53Z"}, "message": "Auto merge of #53403 - spastorino:move-out-lazily, r=nikomatsakis\n\nDo not used Move data flow analysis, make it lazy instead\n\nClose #53394", "tree": {"sha": "d8a79616a7a7c6ab432f1f37daf403669118b122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a79616a7a7c6ab432f1f37daf403669118b122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2afca36672a85248f4da3e8db8cdfac198ad4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2afca36672a85248f4da3e8db8cdfac198ad4ad", "html_url": "https://github.com/rust-lang/rust/commit/c2afca36672a85248f4da3e8db8cdfac198ad4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2afca36672a85248f4da3e8db8cdfac198ad4ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1114ab684fbad001c4e580326d8eb4d8c4e917d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1114ab684fbad001c4e580326d8eb4d8c4e917d3", "html_url": "https://github.com/rust-lang/rust/commit/1114ab684fbad001c4e580326d8eb4d8c4e917d3"}, {"sha": "a6aa5ddf56a42f547224f616c4f37d490d5e9b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6aa5ddf56a42f547224f616c4f37d490d5e9b88", "html_url": "https://github.com/rust-lang/rust/commit/a6aa5ddf56a42f547224f616c4f37d490d5e9b88"}], "stats": {"total": 406, "additions": 172, "deletions": 234}, "files": [{"sha": "3ef8cdfd1044d0a5549bb6e09312e4092297bd77", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -17,17 +17,17 @@ use hir::def::CtorKind;\n use hir::def_id::DefId;\n use hir::{self, HirId, InlineAsm};\n use middle::region;\n-use mir::interpret::{EvalErrorKind, Scalar, ScalarMaybeUndef, ConstValue};\n+use mir::interpret::{ConstValue, EvalErrorKind, Scalar, ScalarMaybeUndef};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::ReadGuard;\n use rustc_serialize as serialize;\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::ops::{Index, IndexMut};\n@@ -203,6 +203,35 @@ impl<'tcx> Mir<'tcx> {\n         ReadGuard::map(self.predecessors(), |p| &p[bb])\n     }\n \n+    #[inline]\n+    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n+        let if_zero_locations = if loc.statement_index == 0 {\n+            let predecessor_blocks = self.predecessors_for(loc.block);\n+            let num_predecessor_blocks = predecessor_blocks.len();\n+            Some(\n+                (0..num_predecessor_blocks)\n+                    .map(move |i| predecessor_blocks[i])\n+                    .map(move |bb| self.terminator_loc(bb)),\n+            )\n+        } else {\n+            None\n+        };\n+\n+        let if_not_zero_locations = if loc.statement_index == 0 {\n+            None\n+        } else {\n+            Some(Location {\n+                block: loc.block,\n+                statement_index: loc.statement_index - 1,\n+            })\n+        };\n+\n+        if_zero_locations\n+            .into_iter()\n+            .flatten()\n+            .chain(if_not_zero_locations)\n+    }\n+\n     #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(self)\n@@ -555,13 +584,15 @@ impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n });\n \n mod binding_form_impl {\n-    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n     use ich::StableHashingContext;\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n-        fn hash_stable<W: StableHasherResult>(&self,\n-                                            hcx: &mut StableHashingContext<'a>,\n-                                            hasher: &mut StableHasher<W>) {\n+        fn hash_stable<W: StableHasherResult>(\n+            &self,\n+            hcx: &mut StableHashingContext<'a>,\n+            hasher: &mut StableHasher<W>,\n+        ) {\n             use super::BindingForm::*;\n             ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -1478,16 +1509,17 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .map(|&u| {\n                         let mut s = String::new();\n                         let c = ty::Const {\n-                            val: ConstValue::Scalar(Scalar::Bits {\n+                            val: ConstValue::Scalar(\n+                                Scalar::Bits {\n                                     bits: u,\n                                     size: size.bytes() as u8,\n-                                }.into()),\n+                                }.into(),\n+                            ),\n                             ty: switch_ty,\n                         };\n                         fmt_const_val(&mut s, &c).unwrap();\n                         s.into()\n-                    })\n-                    .chain(iter::once(String::from(\"otherwise\").into()))\n+                    }).chain(iter::once(String::from(\"otherwise\").into()))\n                     .collect()\n             }\n             Call {\n@@ -2017,7 +2049,13 @@ pub enum AggregateKind<'tcx> {\n     /// active field number and is present only for union expressions\n     /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n-    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<CanonicalTy<'tcx>>, Option<usize>),\n+    Adt(\n+        &'tcx AdtDef,\n+        usize,\n+        &'tcx Substs<'tcx>,\n+        Option<CanonicalTy<'tcx>>,\n+        Option<usize>,\n+    ),\n \n     Closure(DefId, ClosureSubsts<'tcx>),\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n@@ -2267,7 +2305,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n                 return write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i);\n             }\n             Char => return write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n-            _ => {},\n+            _ => {}\n         }\n     }\n     // print function definitons\n@@ -2283,14 +2321,12 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(interpret::AllocType::Memory(alloc)) = alloc {\n                             assert_eq!(len as usize as u128, len);\n-                            let slice = &alloc\n-                                .bytes\n-                                    [(ptr.offset.bytes() as usize)..]\n-                                    [..(len as usize)];\n+                            let slice =\n+                                &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n                             let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n                             write!(f, \"{:?}\", s)\n                         } else {\n-                             write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                            write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n                         }\n                     });\n                 }\n@@ -2821,15 +2857,13 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 let kind = box match **kind {\n                     AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n                     AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => {\n-                        AggregateKind::Adt(\n-                            def,\n-                            v,\n-                            substs.fold_with(folder),\n-                            user_ty.fold_with(folder),\n-                            n,\n-                        )\n-                    }\n+                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                        def,\n+                        v,\n+                        substs.fold_with(folder),\n+                        user_ty.fold_with(folder),\n+                        n,\n+                    ),\n                     AggregateKind::Closure(id, substs) => {\n                         AggregateKind::Closure(id, substs.fold_with(folder))\n                     }\n@@ -2860,8 +2894,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 (match **kind {\n                     AggregateKind::Array(ty) => ty.visit_with(visitor),\n                     AggregateKind::Tuple => false,\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) =>\n-                        substs.visit_with(visitor) || user_ty.visit_with(visitor),\n+                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n+                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n+                    }\n                     AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n                     AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n                 }) || fields.visit_with(visitor)"}, {"sha": "a0b0aabf73e02b40a6beefdb36305933ceca53b6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 103, "deletions": 25, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n use rustc::mir::{LocalDecl, LocalKind, Location, Operand, Place};\n use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::DiagnosticBuilder;\n@@ -24,8 +25,9 @@ use super::borrow_set::BorrowData;\n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n \n+use dataflow::drop_flag_effects;\n+use dataflow::move_paths::indexes::MoveOutIndex;\n use dataflow::move_paths::MovePathIndex;\n-use dataflow::{FlowAtLocation, MovingOutStatements};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -35,17 +37,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         desired_action: InitializationRequiringAction,\n         (place, span): (&Place<'tcx>, Span),\n         mpi: MovePathIndex,\n-        curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n     ) {\n         let use_spans = self\n             .move_spans(place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n-        let mois = self.move_data.path_map[mpi]\n-            .iter()\n-            .filter(|moi| curr_move_out.contains(moi))\n-            .collect::<Vec<_>>();\n+        let mois = self.get_moved_indexes(context, mpi);\n+        debug!(\"report_use_of_moved_or_uninitialized: mois={:?}\", mois);\n \n         if mois.is_empty() {\n             let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n@@ -93,7 +92,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let mut is_loop_move = false;\n             for moi in &mois {\n-                let move_out = self.move_data.moves[**moi];\n+                let move_out = self.move_data.moves[*moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n                 let move_spans = self.move_spans(moved_place, move_out.source);\n@@ -148,7 +147,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 if needs_note {\n-                    let mpi = self.move_data.moves[*mois[0]].path;\n+                    let mpi = self.move_data.moves[mois[0]].path;\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n@@ -348,10 +347,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if issued_spans == borrow_spans {\n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\n-                    \"borrows occur due to use of `{}` in closure\",\n-                    desc_place\n-                ),\n+                format!(\"borrows occur due to use of `{}` in closure\", desc_place),\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n@@ -366,7 +362,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\"second borrow occurs due to use of `{}` in closure\", desc_place),\n+                format!(\n+                    \"second borrow occurs due to use of `{}` in closure\",\n+                    desc_place\n+                ),\n             );\n         }\n \n@@ -413,10 +412,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let mut err = match &self.describe_place(&borrow.borrowed_place) {\n             Some(_) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(\n-                    drop_span,\n-                    borrow_span,\n-                )\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n             }\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n                 context,\n@@ -462,7 +458,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let mut err = self.tcx.path_does_not_live_long_enough(\n-            borrow_span, &format!(\"`{}`\", name), Origin::Mir);\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n \n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(\n@@ -486,11 +485,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self.tcx.thread_local_value_does_not_live_long_enough(\n-            borrow_span, Origin::Mir);\n+        let mut err = self\n+            .tcx\n+            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n \n-        err.span_label(borrow_span,\n-                       \"thread-local variables cannot be borrowed beyond the end of the function\");\n+        err.span_label(\n+            borrow_span,\n+            \"thread-local variables cannot be borrowed beyond the end of the function\",\n+        );\n         err.span_label(drop_span, \"end of enclosing function is here\");\n         err\n     }\n@@ -521,6 +523,80 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n+    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveOutIndex> {\n+        let mir = self.mir;\n+\n+        let mut stack = Vec::new();\n+        stack.extend(mir.predecessor_locations(context.loc));\n+\n+        let mut visited = FxHashSet();\n+        let mut result = vec![];\n+\n+        'dfs: while let Some(l) = stack.pop() {\n+            debug!(\n+                \"report_use_of_moved_or_uninitialized: current_location={:?}\",\n+                l\n+            );\n+\n+            if !visited.insert(l) {\n+                continue;\n+            }\n+\n+            // check for moves\n+            let stmt_kind = mir[l.block]\n+                .statements\n+                .get(l.statement_index)\n+                .map(|s| &s.kind);\n+            if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n+                // this analysis only tries to find moves explicitly\n+                // written by the user, so we ignore the move-outs\n+                // created by `StorageDead` and at the beginning\n+                // of a function.\n+            } else {\n+                for moi in &self.move_data.loc_map[l] {\n+                    debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n+                    if self.move_data.moves[*moi].path == mpi {\n+                        debug!(\"report_use_of_moved_or_uninitialized: found\");\n+                        result.push(*moi);\n+\n+                        // Strictly speaking, we could continue our DFS here. There may be\n+                        // other moves that can reach the point of error. But it is kind of\n+                        // confusing to highlight them.\n+                        //\n+                        // Example:\n+                        //\n+                        // ```\n+                        // let a = vec![];\n+                        // let b = a;\n+                        // let c = a;\n+                        // drop(a); // <-- current point of error\n+                        // ```\n+                        //\n+                        // Because we stop the DFS here, we only highlight `let c = a`,\n+                        // and not `let b = a`. We will of course also report an error at\n+                        // `let c = a` which highlights `let b = a` as the move.\n+                        continue 'dfs;\n+                    }\n+                }\n+            }\n+\n+            // check for inits\n+            let mut any_match = false;\n+            drop_flag_effects::for_location_inits(self.tcx, self.mir, self.move_data, l, |m| {\n+                if m == mpi {\n+                    any_match = true;\n+                }\n+            });\n+            if any_match {\n+                continue 'dfs;\n+            }\n+\n+            stack.extend(mir.predecessor_locations(l));\n+        }\n+\n+        result\n+    }\n+\n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n         context: Context,\n@@ -890,8 +966,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let attrs = self.tcx.get_attrs(statik.def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n-            debug!(\"is_place_thread_local: attrs={:?} is_thread_local={:?}\",\n-                   attrs, is_thread_local);\n+            debug!(\n+                \"is_place_thread_local: attrs={:?} is_thread_local={:?}\",\n+                attrs, is_thread_local\n+            );\n             is_thread_local\n         } else {\n             debug!(\"is_place_thread_local: no\");\n@@ -909,7 +987,7 @@ pub(super) enum UseSpans {\n         // it's present.\n         args_span: Span,\n         // The span of the first use of the captured variable inside the closure.\n-        var_span: Span\n+        var_span: Span,\n     },\n     // This access has a single span associated to it: common case.\n     OtherUse(Span),"}, {"sha": "6b964fec74fdd1417b1145de05f44ed2df3b696e", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -24,7 +24,7 @@ use polonius_engine::Output;\n use dataflow::move_paths::indexes::BorrowIndex;\n use dataflow::move_paths::HasMoveData;\n use dataflow::Borrows;\n-use dataflow::{EverInitializedPlaces, MovingOutStatements};\n+use dataflow::EverInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::MaybeUninitializedPlaces;\n use either::Either;\n@@ -35,7 +35,6 @@ use std::rc::Rc;\n crate struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-    pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n     pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n \n     /// Polonius Output\n@@ -46,14 +45,12 @@ impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     crate fn new(\n         borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-        move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n         ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n         polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     ) -> Self {\n         Flows {\n             borrows,\n             uninits,\n-            move_outs,\n             ever_inits,\n             polonius_output,\n         }\n@@ -79,7 +76,6 @@ macro_rules! each_flow {\n     ($this:ident, $meth:ident($arg:ident)) => {\n         FlowAtLocation::$meth(&mut $this.borrows, $arg);\n         FlowAtLocation::$meth(&mut $this.uninits, $arg);\n-        FlowAtLocation::$meth(&mut $this.move_outs, $arg);\n         FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n     };\n }\n@@ -146,18 +142,6 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n         });\n         s.push_str(\"] \");\n \n-        s.push_str(\"move_out: [\");\n-        let mut saw_one = false;\n-        self.move_outs.each_state_bit(|mpi_move_out| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_out = &self.move_outs.operator().move_data().moves[mpi_move_out];\n-            s.push_str(&format!(\"{:?}\", move_out));\n-        });\n-        s.push_str(\"] \");\n-\n         s.push_str(\"ever_init: [\");\n         let mut saw_one = false;\n         self.ever_inits.each_state_bit(|mpi_ever_init| {"}, {"sha": "3536947b25ebfbdba7e75f2049751a82deced06d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -43,7 +43,7 @@ use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n use dataflow::{do_dataflow, DebugFormatted};\n-use dataflow::{EverInitializedPlaces, MovingOutStatements};\n+use dataflow::EverInitializedPlaces;\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -186,15 +186,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n-    let flow_move_outs = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        MovingOutStatements::new(tcx, mir, &mdpe),\n-        |bd, i| DebugFormatted::new(&bd.move_data().moves[i]),\n-    ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n@@ -268,7 +259,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut state = Flows::new(\n         flow_borrows,\n         flow_uninits,\n-        flow_move_outs,\n         flow_ever_inits,\n         polonius_output,\n     );\n@@ -1617,7 +1607,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1663,7 +1652,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         desired_action,\n                         place_span,\n                         mpi,\n-                        curr_move_outs,\n                     );\n                     return; // don't bother finding other problems.\n                 }\n@@ -1691,7 +1679,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1727,7 +1714,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     desired_action,\n                     place_span,\n                     child_mpi,\n-                    curr_move_outs,\n                 );\n                 return; // don't bother finding other problems.\n             }"}, {"sha": "62c6018809f39ef161b8407d8b0c26b0c4c657c1", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 127, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -22,13 +22,13 @@ use super::MoveDataParamEnv;\n \n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex};\n use super::move_paths::{LookupResult, InitKind};\n use super::{BitDenotation, BlockSets, InitialFlow};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n-use super::{on_lookup_result_bits, for_location_inits};\n+use super::on_lookup_result_bits;\n \n mod storage_liveness;\n \n@@ -211,40 +211,6 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular places. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// place in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that place.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedPlaces`. Both structures on their own only tell\n-/// you if a place *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error message may need to report.\n-#[allow(dead_code)]\n-pub struct MovingOutStatements<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> MovingOutStatements<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n-        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n-}\n-\n /// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n /// for a function, without an intervening `Storage Dead`.\n@@ -488,83 +454,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    type Idx = MoveOutIndex;\n-    fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.move_data().moves.len()\n-    }\n-\n-    fn start_block_effect(&self, _sets: &mut IdxSet<MoveOutIndex>) {\n-        // no move-statements have been executed prior to function\n-        // execution, so this method has no effect on `_sets`.\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<MoveOutIndex>,\n-                        location: Location) {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[location.block].statements[location.statement_index];\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-\n-        match stmt.kind {\n-            // this analysis only tries to find moves explicitly\n-            // written by the user, so we ignore the move-outs\n-            // created by `StorageDead` and at the beginning\n-            // of a function.\n-            mir::StatementKind::StorageDead(_) => {}\n-            _ => {\n-                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                       stmt, location, &loc_map[location]);\n-                // Every path deinitialized by a *particular move*\n-                // has corresponding bit, \"gen'ed\" (i.e. set)\n-                // here, in dataflow vector\n-                sets.gen_all_and_assert_dead(&loc_map[location]);\n-            }\n-        }\n-\n-        for_location_inits(tcx, mir, move_data, location,\n-                           |mpi| sets.kill_all(&path_map[mpi]));\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<MoveOutIndex>,\n-                         location: Location)\n-    {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let term = mir[location.block].terminator();\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-\n-        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, location, &loc_map[location]);\n-        sets.gen_all_and_assert_dead(&loc_map[location]);\n-\n-        for_location_inits(tcx, mir, move_data, location,\n-                           |mpi| sets.kill_all(&path_map[mpi]));\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place) {\n-        let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n-\n-        let path_map = &move_data.path_map;\n-        on_lookup_result_bits(self.tcx,\n-                              self.mir,\n-                              move_data,\n-                              move_data.rev_lookup.find(dest_place),\n-                              |mpi| for moi in &path_map[mpi] {\n-                                  assert!(moi.index() < bits_per_block);\n-                                  in_out.remove(&moi);\n-                              });\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n@@ -682,13 +571,6 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedPlaces<'a, 'gcx, '\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: Word, pred2: Word) -> Word {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: Word, pred2: Word) -> Word {\n@@ -727,13 +609,6 @@ impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MovingOutStatements<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no loans in scope by default\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {"}, {"sha": "bee7d443c85408b430520fd4abc9612f3468e5cd", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -28,7 +28,7 @@ use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n+pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::HaveBeenBorrowedLocals;\n@@ -38,7 +38,7 @@ pub(crate) use self::drop_flag_effects::*;\n use self::move_paths::MoveData;\n \n mod at_location;\n-mod drop_flag_effects;\n+pub mod drop_flag_effects;\n mod graphviz;\n mod impls;\n pub mod move_paths;\n@@ -511,18 +511,6 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         }\n     }\n \n-    fn gen_all_and_assert_dead<I>(&mut self, i: I)\n-        where I: IntoIterator,\n-        I::Item: Borrow<E>\n-    {\n-        for j in i {\n-            let j = j.borrow();\n-            let retval = self.gen_set.add(j);\n-            self.kill_set.remove(j);\n-            assert!(retval);\n-        }\n-    }\n-\n     fn kill(&mut self, e: &E) {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);"}, {"sha": "9b25a865f921e1ff806c5efb99a478ece047f0c4", "filename": "src/test/ui/hygiene/fields-move.nll.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2afca36672a85248f4da3e8db8cdfac198ad4ad/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr?ref=c2afca36672a85248f4da3e8db8cdfac198ad4ad", "patch": "@@ -1,9 +1,6 @@\n error[E0382]: use of moved value: `foo.x`\n   --> $DIR/fields-move.rs:28:9\n    |\n-LL |    $foo.x\n-   |    ------ value moved here\n-...\n LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n    |         ^^^^^^ value used here after move\n ...\n@@ -28,14 +25,9 @@ LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved val\n error[E0382]: use of moved value: `foo.x`\n   --> $DIR/fields-move.rs:39:42\n    |\n-LL |    $foo.x\n-   |    ------ value moved here\n-...\n LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n    |         ------ value moved here\n ...\n-LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n-   |                                          ----- value moved here\n LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n    |                                          ^^^^^ value used here after move\n    |"}]}