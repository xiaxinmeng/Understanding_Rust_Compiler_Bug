{"sha": "eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZjJmOTA5NTYxYzNiMmMyNmVlOGQ0MGFjN2E5NWU4OWM1MDM0ZDk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-02-19T18:49:14Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:40Z"}, "message": "Refactor core specialization and subst translation code to avoid\ndanger of inference variables floating around without their inference\ncontext.\n\nThe main insight here is that, when we are translating substitutions\nbetween two impls, *we already know that the more specific impl holds*,\nso we do not need to add its obligations to the parameter\nenvironment. Instead, we can just thread through the inference context\nwe used to show select the more specific impl in the first place.", "tree": {"sha": "bbaae2b97e59aa5131fc3d35b1540807ae152c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbaae2b97e59aa5131fc3d35b1540807ae152c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "html_url": "https://github.com/rust-lang/rust/commit/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f20cbf03088c8fa89a343de9e97e7608cd701b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f20cbf03088c8fa89a343de9e97e7608cd701b6", "html_url": "https://github.com/rust-lang/rust/commit/8f20cbf03088c8fa89a343de9e97e7608cd701b6"}], "stats": {"total": 334, "additions": 156, "deletions": 178}, "files": [{"sha": "2df3184a0fba1647ded27b746a9ae95f585175c7", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "patch": "@@ -1008,7 +1008,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n             });\n-            let substs = translate_substs(tcx, impl_def_id, substs, node_item.node);\n+            let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             (ty.subst(tcx, &substs), nested)\n         }\n         None => {"}, {"sha": "5939128719c0146338a58bbac0577a2085aa0d2d", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "modified", "additions": 143, "deletions": 169, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "patch": "@@ -17,7 +17,8 @@\n // See traits/README.md for a bit more detail on how specialization\n // fits together with the rest of the trait machinery.\n \n-use super::{util, build_selcx, SelectionContext};\n+use super::{build_selcx, SelectionContext, FulfillmentContext};\n+use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n \n use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n@@ -40,117 +41,90 @@ pub struct Overlap<'a, 'tcx: 'a> {\n /// Given a subst for the requested impl, translate it to a subst\n /// appropriate for the actual item definition (whether it be in that impl,\n /// a parent impl, or the trait).\n-pub fn translate_substs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              from_impl: DefId,\n-                              from_impl_substs: Substs<'tcx>,\n-                              to_node: specialization_graph::Node)\n-                              -> Substs<'tcx> {\n-    match to_node {\n-        specialization_graph::Node::Impl(to_impl) => {\n+// When we have selected one impl, but are actually using item definitions from\n+// a parent impl providing a default, we need a way to translate between the\n+// type parameters of the two impls. Here the `source_impl` is the one we've\n+// selected, and `source_substs` is a substitution of its generics (and\n+// possibly some relevant `FnSpace` variables as well). And `target_node` is\n+// the impl/trait we're actually going to get the definition from. The resulting\n+// substitution will map from `target_node`'s generics to `source_impl`'s\n+// generics as instantiated by `source_subst`.\n+//\n+// For example, consider the following scenario:\n+//\n+// ```rust\n+// trait Foo { ... }\n+// impl<T, U> Foo for (T, U) { ... }  // target impl\n+// impl<V> Foo for (V, V) { ... }     // source impl\n+// ```\n+//\n+// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n+// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n+//\n+// Where clauses add some trickiness here, because they can be used to \"define\"\n+// an argument indirectly:\n+//\n+// ```rust\n+// impl<'a, I, T: 'a> Iterator for Cloned<I>\n+//    where I: Iterator<Item=&'a T>, T: Clone\n+// ```\n+//\n+// In a case like this, the substitution for `T` is determined indirectly,\n+// through associated type projection. We deal with such cases by using\n+// *fulfillment* to relate the two impls, requiring that all projections are\n+// resolved.\n+pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                  source_impl: DefId,\n+                                  source_substs: Substs<'tcx>,\n+                                  target_node: specialization_graph::Node)\n+                                  -> Substs<'tcx>\n+{\n+    let source_trait_ref = infcx.tcx\n+                                .impl_trait_ref(source_impl)\n+                                .unwrap()\n+                                .subst(infcx.tcx, &source_substs);\n+\n+    // translate the Self and TyParam parts of the substitution, since those\n+    // vary across impls\n+    let target_substs = match target_node {\n+        specialization_graph::Node::Impl(target_impl) => {\n             // no need to translate if we're targetting the impl we started with\n-            if from_impl == to_impl {\n-                return from_impl_substs;\n+            if source_impl == target_impl {\n+                return source_substs;\n             }\n \n-            translate_substs_between_impls(tcx, from_impl, from_impl_substs, to_impl)\n-\n-        }\n-        specialization_graph::Node::Trait(..) => {\n-            translate_substs_from_impl_to_trait(tcx, from_impl, from_impl_substs)\n+            fulfill_implication(infcx, source_trait_ref, target_impl).unwrap_or_else(|_| {\n+                infcx.tcx\n+                     .sess\n+                     .bug(\"When translating substitutions for specialization, the expected \\\n+                           specializaiton failed to hold\")\n+            })\n         }\n-    }\n-}\n-\n-/// When we have selected one impl, but are actually using item definitions from\n-/// a parent impl providing a default, we need a way to translate between the\n-/// type parameters of the two impls. Here the `source_impl` is the one we've\n-/// selected, and `source_substs` is a substitution of its generics (and\n-/// possibly some relevant `FnSpace` variables as well). And `target_impl` is\n-/// the impl we're actually going to get the definition from. The resulting\n-/// substitution will map from `target_impl`'s generics to `source_impl`'s\n-/// generics as instantiated by `source_subst`.\n-///\n-/// For example, consider the following scenario:\n-///\n-/// ```rust\n-/// trait Foo { ... }\n-/// impl<T, U> Foo for (T, U) { ... }  // target impl\n-/// impl<V> Foo for (V, V) { ... }     // source impl\n-/// ```\n-///\n-/// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n-/// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n-///\n-/// Where clauses add some trickiness here, because they can be used to \"define\"\n-/// an argument indirectly:\n-///\n-/// ```rust\n-/// impl<'a, I, T: 'a> Iterator for Cloned<I>\n-///    where I: Iterator<Item=&'a T>, T: Clone\n-/// ```\n-///\n-/// In a case like this, the substitution for `T` is determined indirectly,\n-/// through associated type projection. We deal with such cases by using\n-/// *fulfillment* to relate the two impls, requiring that all projections are\n-/// resolved.\n-fn translate_substs_between_impls<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        source_impl: DefId,\n-                                        source_substs: Substs<'tcx>,\n-                                        target_impl: DefId)\n-                                        -> Substs<'tcx> {\n-\n-    // We need to build a subst that covers all the generics of\n-    // `target_impl`. Start by introducing fresh infer variables:\n-    let target_generics = tcx.lookup_item_type(target_impl).generics;\n-    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut target_substs = infcx.fresh_substs_for_generics(DUMMY_SP, &target_generics);\n-    if source_substs.regions.is_erased() {\n-        target_substs = target_substs.erase_regions()\n-    }\n+        specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),\n+    };\n \n-    if !fulfill_implication(&mut infcx,\n-                            source_impl,\n-                            source_substs.clone(),\n-                            target_impl,\n-                            target_substs.clone()) {\n-        tcx.sess\n-           .bug(\"When translating substitutions for specialization, the expected specializaiton \\\n-                 failed to hold\")\n-    }\n+    // retain erasure mode\n+    // NB: this must happen before inheriting method generics below\n+    let target_substs = if source_substs.regions.is_erased() {\n+        target_substs.erase_regions()\n+    } else {\n+        target_substs\n+    };\n \n-    // Now resolve the *substitution* we built for the target earlier, replacing\n-    // the inference variables inside with whatever we got from fulfillment. We\n-    // also carry along any FnSpace substitutions, which don't need to be\n-    // adjusted when mapping from one impl to another.\n-    infcx.resolve_type_vars_if_possible(&target_substs)\n-         .with_method_from_subst(&source_substs)\n+    // directly inherent the method generics, since those do not vary across impls\n+    target_substs.with_method_from_subst(&source_substs)\n }\n \n-/// When we've selected an impl but need to use an item definition provided by\n-/// the trait itself, we need to translate the substitution applied to the impl\n-/// to one that makes sense for the trait.\n-fn translate_substs_from_impl_to_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                             source_impl: DefId,\n-                                             source_substs: Substs<'tcx>)\n-                                             -> Substs<'tcx> {\n \n-    let source_trait_ref = tcx.impl_trait_ref(source_impl).unwrap().subst(tcx, &source_substs);\n+fn skolemizing_subst_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        impl_def_id: DefId)\n+                                        -> Substs<'tcx>\n+{\n+    let impl_generics = infcx.tcx.lookup_item_type(impl_def_id).generics;\n \n-    let mut new_substs = source_trait_ref.substs.clone();\n-    if source_substs.regions.is_erased() {\n-        new_substs = new_substs.erase_regions()\n-    }\n-\n-    // Carry any FnSpace substitutions along; they don't need to be adjusted\n-    new_substs.with_method_from_subst(&source_substs)\n-}\n+    let types = impl_generics.types.map(|def| infcx.tcx.mk_param_from_def(def));\n \n-fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Substs<'a> {\n-    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n-\n-    let types = impl_generics.types.map(|def| tcx.mk_param_from_def(def));\n-\n-    // FIXME: figure out what we actually want here\n+    // TODO: figure out what we actually want here\n     let regions = impl_generics.regions.map(|_| ty::Region::ReStatic);\n     // |d| infcx.next_region_var(infer::RegionVariableOrigin::EarlyBoundRegion(span, d.name)));\n \n@@ -170,101 +144,101 @@ pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) ->\n     // We determine whether there's a subset relationship by:\n     //\n     // - skolemizing impl1,\n-    // - instantiating impl2 with fresh inference variables,\n     // - assuming the where clauses for impl1,\n+    // - instantiating impl2 with fresh inference variables,\n     // - unifying,\n     // - attempting to prove the where clauses for impl2\n     //\n-    // The last three steps are essentially checking for an implication between two impls\n-    // after appropriate substitutions. This is what `fulfill_implication` checks for.\n+    // The last three steps are encapsulated in `fulfill_implication`.\n     //\n     // See RFC 1210 for more details and justification.\n \n     let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n \n-    let impl1_substs = skolemizing_subst_for_impl(tcx, impl1_def_id);\n-    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n-\n-    fulfill_implication(&mut infcx,\n-                        impl1_def_id,\n-                        impl1_substs,\n-                        impl2_def_id,\n-                        impl2_substs)\n-}\n-\n-/// Does impl1 (instantiated with the impl1_substs) imply impl2\n-/// (instantiated with impl2_substs)?\n-///\n-/// Mutates the `infcx` in two ways:\n-/// - by adding the obligations of impl1 to the parameter environment\n-/// - via fulfillment, so that if the implication holds the various unifications\n-fn fulfill_implication<'a, 'tcx>(infcx: &mut InferCtxt<'a, 'tcx>,\n-                                 impl1_def_id: DefId,\n-                                 impl1_substs: Substs<'tcx>,\n-                                 impl2_def_id: DefId,\n-                                 impl2_substs: Substs<'tcx>)\n-                                 -> bool {\n-    let tcx = &infcx.tcx;\n-\n+    // Skiolemize impl1: we want to prove that \"for all types matched by impl1,\n+    // those types are also matched by impl2\".\n+    let impl1_substs = skolemizing_subst_for_impl(&infcx, impl1_def_id);\n     let (impl1_trait_ref, impl1_obligations) = {\n         let selcx = &mut SelectionContext::new(&infcx);\n-        util::impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n+        impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n     };\n \n+    // Add impl1's obligations as assumptions to the environment.\n     let impl1_predicates: Vec<_> = impl1_obligations.iter()\n                                                     .cloned()\n                                                     .map(|oblig| oblig.predicate)\n                                                     .collect();\n-\n     infcx.parameter_environment = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: impl1_substs,\n-        implicit_region_bound: ty::ReEmpty, // FIXME: is this OK?\n+        implicit_region_bound: ty::ReEmpty, // TODO: is this OK?\n         caller_bounds: impl1_predicates,\n         selection_cache: traits::SelectionCache::new(),\n         evaluation_cache: traits::EvaluationCache::new(),\n-        free_id_outlive: region::DUMMY_CODE_EXTENT, // FIXME: is this OK?\n+        free_id_outlive: region::DUMMY_CODE_EXTENT, // TODO: is this OK?\n     };\n \n-    let selcx = &mut build_selcx(&infcx).project_topmost().build();\n-    let (impl2_trait_ref, impl2_obligations) = util::impl_trait_ref_and_oblig(selcx,\n-                                                                              impl2_def_id,\n-                                                                              &impl2_substs);\n-\n-    // do the impls unify? If not, no specialization.\n-    if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n-                                            true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            impl1_trait_ref,\n-                                            impl2_trait_ref) {\n-        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-               impl1_trait_ref,\n-               impl2_trait_ref);\n-        return false;\n-    }\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+}\n \n-    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+/// Attempt to fulfill all obligations of `target_impl` after unification with\n+/// `source_trait_ref`. If successful, returns a substitution for *all* the\n+/// generics of `target_impl`, including both those needed to unify with\n+/// `source_trait_ref` and those whose identity is determined via a where\n+/// clause in the impl.\n+fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                 source_trait_ref: ty::TraitRef<'tcx>,\n+                                 target_impl: DefId)\n+                                 -> Result<Substs<'tcx>, ()>\n+{\n+    infcx.probe(|_| {\n+        let selcx = &mut build_selcx(&infcx).project_topmost().build();\n+        let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+        let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                       target_impl,\n+                                                                       &target_substs);\n+\n+        // do the impls unify? If not, no specialization.\n+        if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n+                                                true,\n+                                                TypeOrigin::Misc(DUMMY_SP),\n+                                                source_trait_ref,\n+                                                target_trait_ref) {\n+            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+            return Err(());\n+        }\n \n-    // attempt to prove all of the predicates for impl2 given those for impl1\n-    // (which are packed up in penv)\n+        // attempt to prove all of the predicates for impl2 given those for impl1\n+        // (which are packed up in penv)\n \n-    for oblig in impl2_obligations.into_iter() {\n-        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-    }\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        for oblig in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+        }\n \n-    if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n-        // no dice!\n-        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                {:?}\",\n-               impl1_trait_ref,\n-               impl2_trait_ref,\n-               errors,\n-               infcx.parameter_environment.caller_bounds);\n-        false\n-    } else {\n-        debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n-               impl1_trait_ref,\n-               impl2_trait_ref);\n-        true\n-    }\n+        if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+            // no dice!\n+            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} \\\n+                    given {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref,\n+                   errors,\n+                   infcx.parameter_environment.caller_bounds);\n+            Err(())\n+        } else {\n+            debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses \\\n+                    elided)\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+\n+            // Now resolve the *substitution* we built for the target earlier, replacing\n+            // the inference variables inside with whatever we got from fulfillment.\n+\n+            // TODO: should this use `fully_resolve` instead?\n+            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+        }\n+    })\n }"}, {"sha": "411c98c6066cf392d750739b6b3456352ca34b56", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "patch": "@@ -105,6 +105,7 @@ impl Graph {\n                     } else if ge && !le {\n                         // possible_sibling specializes the impl\n                         *slot = impl_def_id;\n+                        self.parent.insert(impl_def_id, parent);\n                         self.parent.insert(possible_sibling, impl_def_id);\n                         // we have to defer the insertion, because we can't\n                         // relinquish the borrow of `self.children`"}, {"sha": "b7e107ae5e7834e615a425fce88e7f931762b2a1", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "patch": "@@ -819,9 +819,10 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             nested: _ }) =>\n         {\n             let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n-            let impl_method = tcx.get_impl_method(impl_did,\n-                                                  tcx.mk_substs(callee_substs),\n-                                                  trait_method.name);\n+            let impl_method = meth::get_impl_method(tcx,\n+                                                    impl_did,\n+                                                    tcx.mk_substs(callee_substs),\n+                                                    trait_method.name);\n             Some((impl_method.method.def_id, impl_method.substs))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n@@ -1160,9 +1161,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n-                    let mth = tcx.get_impl_method(impl_def_id,\n-                                                  callee_substs,\n-                                                  default_impl.name);\n+                    let mth = meth::get_impl_method(tcx,\n+                                                    impl_def_id,\n+                                                    callee_substs.clone(),\n+                                                    default_impl.name);\n \n                     assert!(mth.is_provided);\n "}, {"sha": "28e9fcd47ff02d19647524eced219ff52e89be27", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=eaf2f909561c3b2c26ee8d40ac7a95e89c5034d9", "patch": "@@ -381,7 +381,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     impl_id: DefId,\n                                     substs: &'tcx subst::Substs<'tcx>)\n-                                    -> Vec<Option<ty::util::ImplMethod<'tcx>>>\n+                                    -> Vec<Option<ImplMethod<'tcx>>>\n {\n     let tcx = ccx.tcx();\n \n@@ -488,12 +488,13 @@ pub fn get_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n             ImplMethod {\n                 method: node_item.item,\n-                substs: traits::translate_substs(tcx, impl_def_id, substs, node_item.node),\n+                substs: traits::translate_substs(&infcx, impl_def_id, substs, node_item.node),\n                 is_provided: node_item.node.is_from_trait(),\n             }\n         }"}]}