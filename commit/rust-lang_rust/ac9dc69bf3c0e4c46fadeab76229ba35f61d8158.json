{"sha": "ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOWRjNjliZjNjMGU0YzQ2ZmFkZWFiNzYyMjliYTM1ZjYxZDgxNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T15:28:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T15:28:02Z"}, "message": "auto merge of #5796 : nikomatsakis/rust/issue-5656-fix-map-iteration, r=nikomatsakis\n\nRevert map.each to something which takes two parameters rather than a tuple.  The current setup iterates over `BaseIter<(&'self K, &'self V)>` where 'self is a lifetime declared *in the `each()` method*.  You can't place such a type in the impl declaration.  The compiler currently allows it, but this will not be legal under #5656 and I'm pretty sure it's not sound now.  It's too bad that maps can't implement `BaseIter` (at least not over a tuple as they do here) but I think it has to be this way for the time being.\r\n\r\nr? @thestinger", "tree": {"sha": "7583fe26dbee8952573b38dff904ccda2c7ec566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7583fe26dbee8952573b38dff904ccda2c7ec566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "html_url": "https://github.com/rust-lang/rust/commit/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d01f649b4cda55cb6ec358d0e2685c9901f62a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d01f649b4cda55cb6ec358d0e2685c9901f62a1", "html_url": "https://github.com/rust-lang/rust/commit/5d01f649b4cda55cb6ec358d0e2685c9901f62a1"}, {"sha": "5606fc0c90461db40faeca16d7bffd9e61c2be73", "url": "https://api.github.com/repos/rust-lang/rust/commits/5606fc0c90461db40faeca16d7bffd9e61c2be73", "html_url": "https://github.com/rust-lang/rust/commit/5606fc0c90461db40faeca16d7bffd9e61c2be73"}], "stats": {"total": 290, "additions": 132, "deletions": 158}, "files": [{"sha": "a1836d16fd733ad1e6583f3a05b0afc098d065ff", "filename": "src/libcore/container.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -29,6 +29,9 @@ pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n \n+    // Visits all keys and values\n+    fn each(&self, f: &fn(&K, &V) -> bool);\n+\n     /// Visit all keys\n     fn each_key(&self, f: &fn(&K) -> bool);\n "}, {"sha": "d4af0ffe7fe7b2b8383064454bfd8ecf4c92ab47", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -279,24 +279,6 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     }\n }\n \n-impl<'self,K:Hash + IterBytes + Eq,V>\n-        BaseIter<(&'self K, &'self V)> for HashMap<K, V> {\n-    /// Visit all key-value pairs\n-    fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            let mut broke = false;\n-            do self.buckets[i].map |bucket| {\n-                if !blk(&(&bucket.key, &bucket.value)) {\n-                    broke = true; // FIXME(#3064) just write \"break;\"\n-                }\n-            };\n-            if broke { break; }\n-        }\n-    }\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-\n impl<K:Hash + IterBytes + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint { self.size }\n@@ -315,7 +297,7 @@ impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n     }\n }\n \n-impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n+impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, k: &K) -> bool {\n         match self.bucket_for_key(k) {\n@@ -324,14 +306,25 @@ impl<'self,K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all key-value pairs\n+    fn each(&self, blk: &fn(&'self K, &'self V) -> bool) {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            for self.buckets[i].each |bucket| {\n+                if !blk(&bucket.key, &bucket.value) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Visit all keys\n     fn each_key(&self, blk: &fn(k: &K) -> bool) {\n-        self.each(|&(k, _)| blk(k))\n+        self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values\n     fn each_value(&self, blk: &fn(v: &V) -> bool) {\n-        self.each(|&(_, v)| blk(v))\n+        self.each(|_, v| blk(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -545,7 +538,7 @@ impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        for self.each |&(key, value)| {\n+        for self.each |key, value| {\n             match other.find(key) {\n                 None => return false,\n                 Some(v) => if value != v { return false },\n@@ -798,7 +791,7 @@ mod test_map {\n             assert!(m.insert(i, i*2));\n         }\n         let mut observed = 0;\n-        for m.each |&(k, v)| {\n+        for m.each |k, v| {\n             assert!(*v == *k * 2);\n             observed |= (1 << *k);\n         }"}, {"sha": "f6a92a213859e76bd0974bf5a16c72c52f8c3fb4", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -28,24 +28,6 @@ pub struct TrieMap<T> {\n     priv length: uint\n }\n \n-impl<'self,T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n-    /// Visit all key-value pairs in order\n-    #[inline(always)]\n-    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n-        self.root.each(f);\n-    }\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<'self,T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n-    /// Visit all key-value pairs in reverse order\n-    #[inline(always)]\n-    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n-        self.root.each_reverse(f);\n-    }\n-}\n-\n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline(always)]\n@@ -72,16 +54,22 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         self.find(key).is_some()\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    fn each(&self, f: &fn(&uint, &'self T) -> bool) {\n+        self.root.each(f);\n+    }\n+\n     /// Visit all keys in order\n     #[inline(always)]\n     fn each_key(&self, f: &fn(&uint) -> bool) {\n-        self.each(|&(k, _)| f(&k))\n+        self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n     fn each_value(&self, f: &fn(&T) -> bool) {\n-        self.each(|&(_, v)| f(v))\n+        self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -148,16 +136,22 @@ pub impl<T> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) {\n+        self.root.each_reverse(f);\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline(always)]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n-        self.each_reverse(|&(k, _)| f(&k))\n+        self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n     fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n-        self.each_reverse(|&(_, v)| f(v))\n+        self.each_reverse(|_, v| f(v))\n     }\n }\n \n@@ -239,22 +233,22 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n-                External(k, ref v) => if !f(&(k, v)) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n         }\n         true\n     }\n \n-    fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n+    fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },\n-                External(k, ref v) => if !f(&(k, v)) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n         }\n@@ -438,8 +432,8 @@ mod tests {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |&(k, v)| {\n-            assert!(k == n);\n+        for m.each |k, v| {\n+            assert!(*k == n);\n             assert!(*v == n * 2);\n             n += 1;\n         }\n@@ -454,11 +448,11 @@ mod tests {\n         }\n \n         let mut n = uint::max_value - 9999;\n-        for m.each |&(k, v)| {\n+        for m.each |k, v| {\n             if n == uint::max_value - 5000 { break }\n             assert!(n < uint::max_value - 5000);\n \n-            assert!(k == n);\n+            assert!(*k == n);\n             assert!(*v == n / 2);\n             n += 1;\n         }\n@@ -475,8 +469,8 @@ mod tests {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        for m.each_reverse |&(k, v)| {\n-            assert!(k == n);\n+        for m.each_reverse |k, v| {\n+            assert!(*k == n);\n             assert!(*v == n * 2);\n             n -= 1;\n         }\n@@ -491,11 +485,11 @@ mod tests {\n         }\n \n         let mut n = uint::max_value;\n-        for m.each_reverse |&(k, v)| {\n+        for m.each_reverse |k, v| {\n             if n == uint::max_value - 5000 { break }\n             assert!(n > uint::max_value - 5000);\n \n-            assert!(k == n);\n+            assert!(*k == n);\n             assert!(*v == n / 2);\n             n -= 1;\n         }"}, {"sha": "d738c3e7747945a340601996c39b055534727750", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -86,7 +86,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::crate_num) -> bool {\n \n pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::crate_num, @crate_metadata)) {\n-    for cstore.metas.each |&(&k, &v)| {\n+    for cstore.metas.each |&k, &v| {\n         i(k, v);\n     }\n }"}, {"sha": "0dd28e5ca7ca1750b7ba5635b4c91c0cdde75d1b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -397,7 +397,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn check_completeness(&self) {\n-        for self.item_refs.each |&(&key, &item_ref)| {\n+        for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", *key));"}, {"sha": "6f8992bf1ca4ad09bdbb3c0373c847cbb2fb633d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -460,7 +460,7 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n \n     do cx.with_lint_attrs(/*bad*/copy crate.node.attrs) |cx| {\n         // Copy out the default settings\n-        for cx.curr.each |&(k, &v)| {\n+        for cx.curr.each |&k, &v| {\n             sess.lint_settings.default_settings.insert(k, v);\n         }\n "}, {"sha": "50c193ab3b095a17f3b11942a8372fb03709df53", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -842,7 +842,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.each |&(&key, &value)| {\n+        for region_paramd_items.each |&key, &value| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "c7f53c744f1bfe49b6778bf6c5eda6904f347985", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -2369,7 +2369,7 @@ pub impl Resolver {\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n-                |&(ident, target_import_resolution)| {\n+                |ident, target_import_resolution| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n@@ -2457,13 +2457,13 @@ pub impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |&(ident, name_bindings)| {\n+        for containing_module.children.each |ident, name_bindings| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n         for containing_module.external_module_children.each\n-                |&(ident, module)| {\n+                |ident, module| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);\n@@ -3111,7 +3111,7 @@ pub impl Resolver {\n     fn add_exports_for_module(@mut self,\n                               exports2: &mut ~[Export2],\n                               module_: @mut Module) {\n-        for module_.children.each |&(ident, namebindings)| {\n+        for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    *self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n@@ -3126,7 +3126,7 @@ pub impl Resolver {\n                                              false);\n         }\n \n-        for module_.import_resolutions.each |&(ident, importresolution)| {\n+        for module_.import_resolutions.each |ident, importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        *self.session.str_of(*ident));\n@@ -3934,7 +3934,7 @@ pub impl Resolver {\n         for arm.pats.eachi() |i, p| {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.each |&(&key, &binding_0)| {\n+            for map_0.each |&key, &binding_0| {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -3955,7 +3955,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            for map_i.each |&(&key, &binding)| {\n+            for map_i.each |&key, &binding| {\n                 if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n@@ -5248,7 +5248,7 @@ pub impl Resolver {\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each |&(name, import_resolution)| {\n+        for module_.import_resolutions.each |name, import_resolution| {\n             let mut value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "4faff086098b0293524c5e7fd7f336be940f8d82", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -2848,7 +2848,7 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n         lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     }\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each |&(key, &val)| {\n+    for ccx.module_data.each |key, &val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n@@ -3139,7 +3139,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n \n         if ccx.sess.count_llvm_insns() {\n-            for ccx.stats.llvm_insns.each |&(&k, &v)| {\n+            for ccx.stats.llvm_insns.each |&k, &v| {\n                 io::println(fmt!(\"%-7u %s\", v, k));\n             }\n         }"}, {"sha": "e6354d4ab88f67fe3c23887b5258d3d9b954ff14", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -1223,7 +1223,7 @@ pub impl RegionVarBindings {\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.each |&(constraint, span)| {\n+        for self.constraints.each |constraint, span| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,"}, {"sha": "642a94b194582032797e9453c18e45f4d2b28972", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -177,7 +177,7 @@ Available lint options:\n                      padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |&(k, v)| {\n+    for lint_dict.each |k, v| {\n         let k = str::replace(*k, ~\"_\", ~\"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),"}, {"sha": "90a745aaeb9b7da2b526338465e6291d52b18022", "filename": "src/libstd/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -926,7 +926,7 @@ impl Eq for Json {\n                     &Object(ref d1) => {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n-                            for d0.each |&(k, v0)| {\n+                            for d0.each |k, v0| {\n                                 match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n@@ -989,12 +989,12 @@ impl Ord for Json {\n                         let mut d1_flat = ~[];\n \n                         // FIXME #4430: this is horribly inefficient...\n-                        for d0.each |&(k, v)| {\n+                        for d0.each |k, v| {\n                              d0_flat.push((@copy *k, @copy *v));\n                         }\n                         d0_flat.qsort();\n \n-                        for d1.each |&(k, v)| {\n+                        for d1.each |k, v| {\n                             d1_flat.push((@copy *k, @copy *v));\n                         }\n                         d1_flat.qsort();\n@@ -1125,7 +1125,7 @@ impl<A:ToJson> ToJson for ~[A] {\n impl<A:ToJson + Copy> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = HashMap::new();\n-        for self.each |&(key, value)| {\n+        for self.each |key, value| {\n             d.insert(copy *key, value.to_json());\n         }\n         Object(~d)"}, {"sha": "b8e0d9d9b2ac43cea0656bf5fe5e0383079f023b", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -216,7 +216,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.each |&(key, values)| {\n+    for m.each |key, values| {\n         let key = encode_plus(*key);\n \n         for values.each |value| {"}, {"sha": "c2f0d9cb43f098ac54788ddfd511e59a10c70376", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -595,7 +595,7 @@ impl<\n     fn encode(&self, e: &E) {\n         do e.emit_map(self.len()) {\n             let mut i = 0;\n-            for self.each |&(key, val)| {\n+            for self.each |key, val| {\n                 e.emit_map_elt_key(i, || key.encode(e));\n                 e.emit_map_elt_val(i, || val.encode(e));\n                 i += 1;\n@@ -659,7 +659,7 @@ impl<\n     fn encode(&self, e: &E) {\n         do e.emit_map(self.len()) {\n             let mut i = 0;\n-            for self.each |&(key, val)| {\n+            for self.each |key, val| {\n                 e.emit_map_elt_key(i, || key.encode(e));\n                 e.emit_map_elt_val(i, || val.encode(e));\n                 i += 1;\n@@ -717,7 +717,7 @@ impl<\n     fn encode(&self, e: &E) {\n         do e.emit_map(self.len()) {\n             let mut i = 0;\n-            for self.each |&(key, val)| {\n+            for self.each |key, val| {\n                 e.emit_map_elt_key(i, || key.encode(e));\n                 e.emit_map_elt_val(i, || val.encode(e));\n                 i += 1;"}, {"sha": "811cd710a62cc46104fd955c13d0247a15560146", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -14,40 +14,14 @@\n  */\n \n use core::container::{Container, Mutable, Map, Set};\n-use core::iter::{BaseIter, ReverseIter};\n+use core::iter::{BaseIter};\n use core::option::{Some, None};\n use core::prelude::*;\n \n pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n }\n \n-impl<'self, V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n-    /// Visit all key-value pairs in order\n-    fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&(i, elt)) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<'self, V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n-    /// Visit all key-value pairs in reverse order\n-    fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n-        for uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i - 1] {\n-              Some(ref elt) => if !it(&(i - 1, elt)) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-}\n-\n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint {\n@@ -76,14 +50,24 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         self.find(key).is_some()\n     }\n \n+    /// Visit all key-value pairs in order\n+    fn each(&self, it: &fn(&uint, &'self V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n     /// Visit all keys in order\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n-        self.each(|&(k, _)| blk(&k))\n+        self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values in order\n     fn each_value(&self, blk: &fn(value: &V) -> bool) {\n-        self.each(|&(_, v)| blk(v))\n+        self.each(|_, v| blk(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -149,6 +133,16 @@ pub impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n+    /// Visit all key-value pairs in reverse order\n+    fn each_reverse(&self, it: &fn(uint, &'self V) -> bool) {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(i - 1, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n     fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "041ea855cb39d24d87226c1b6fb638ca5428bd9d", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -82,24 +82,6 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n-impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n-    /// Visit all key-value pairs in order\n-    fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n-        each(&self.root, f)\n-    }\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<'self, K: TotalOrd, V>\n-    ReverseIter<(&'self K, &'self V)>\n-    for TreeMap<K, V>\n-{\n-    /// Visit all key-value pairs in reverse order\n-    fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n-        each_reverse(&self.root, f);\n-    }\n-}\n-\n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint { self.length }\n@@ -122,12 +104,19 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         self.find(key).is_some()\n     }\n \n+    /// Visit all key-value pairs in order\n+    fn each(&self, f: &fn(&'self K, &'self V) -> bool) {\n+        each(&self.root, f)\n+    }\n+\n     /// Visit all keys in order\n-    fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n+    fn each_key(&self, f: &fn(&K) -> bool) {\n+        self.each(|k, _| f(k))\n+    }\n \n     /// Visit all values in order\n     fn each_value(&self, f: &fn(&V) -> bool) {\n-        self.each(|&(_, v)| f(v))\n+        self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -180,14 +169,19 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n+    /// Visit all key-value pairs in reverse order\n+    fn each_reverse(&'self self, f: &fn(&'self K, &'self V) -> bool) {\n+        each_reverse(&self.root, f);\n+    }\n+\n     /// Visit all keys in reverse order\n     fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n-        self.each_reverse(|&(k, _)| f(k))\n+        self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n-        self.each_reverse(|&(_, v)| f(v))\n+        self.each_reverse(|_, v| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n@@ -538,18 +532,18 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n }\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                            f: &fn(&(&'r K, &'r V)) -> bool) {\n+                            f: &fn(&'r K, &'r V) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n-        if f(&(&x.key, &x.value)) { each(&x.right, f) }\n+        if f(&x.key, &x.value) { each(&x.right, f) }\n     }\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                                    f: &fn(&(&'r K, &'r V)) -> bool) {\n+                                    f: &fn(&'r K, &'r V) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);\n-        if f(&(&x.key, &x.value)) { each_reverse(&x.left, f) }\n+        if f(&x.key, &x.value) { each_reverse(&x.left, f) }\n     }\n }\n \n@@ -796,7 +790,7 @@ mod test_treemap {\n             let &(k, v) = x;\n             assert!(map.find(&k).unwrap() == &v)\n         }\n-        for map.each |&(map_k, map_v)| {\n+        for map.each |map_k, map_v| {\n             let mut found = false;\n             for ctrl.each |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n@@ -912,7 +906,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        for m.each |&(k, v)| {\n+        for m.each |k, v| {\n             assert!(*k == n);\n             assert!(*v == n * 2);\n             n += 1;\n@@ -930,7 +924,7 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        for m.each_reverse |&(k, v)| {\n+        for m.each_reverse |k, v| {\n             assert!(*k == n);\n             assert!(*v == n * 2);\n             n -= 1;"}, {"sha": "c4b450810aa86af9b53920eee9a556ab34d777fd", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -145,7 +145,7 @@ impl WorkMap {\n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n         let mut d = ~[];\n-        for self.each |&(k, v)| {\n+        for self.each |k, v| {\n             d.push((copy *k, copy *v))\n         }\n         sort::tim_sort(d);\n@@ -319,7 +319,7 @@ impl TPrep for Prep {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.each |&(k, v)| {\n+        for map.each |k, v| {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}, {"sha": "c8b13a6e27fa3038886b704e6132bdfef7250cbb", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -48,7 +48,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.each |&(&key, &val)| {\n+   for mm.each |&key, &val| {\n       pairs.push((key, pct(val, total)));\n    }\n "}, {"sha": "cfde61d74b21bbdef98ff711f7815ed24a612796", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -49,18 +49,6 @@ pub impl<T> cat<T> {\n     }\n }\n \n-impl<'self,T> BaseIter<(int, &'self T)> for cat<T> {\n-    fn each(&self, f: &fn(&(int, &'self T)) -> bool) {\n-        let mut n = int::abs(self.meows);\n-        while n > 0 {\n-            if !f(&(n, &self.name)) { break; }\n-            n -= 1;\n-        }\n-    }\n-\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n impl<T> Container for cat<T> {\n     fn len(&const self) -> uint { self.meows as uint }\n     fn is_empty(&const self) -> bool { self.meows == 0 }\n@@ -71,17 +59,25 @@ impl<T> Mutable for cat<T> {\n }\n \n impl<T> Map<int, T> for cat<T> {\n+    fn each(&self, f: &fn(&int, &T) -> bool) {\n+        let mut n = int::abs(self.meows);\n+        while n > 0 {\n+            if !f(&n, &self.name) { break; }\n+            n -= 1;\n+        }\n+    }\n+\n     fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n     fn each_key(&self, f: &fn(v: &int) -> bool) {\n-        for self.each |&(k, _)| { if !f(&k) { break; } loop;};\n+        for self.each |k, _| { if !f(k) { break; } loop;};\n     }\n \n     fn each_value(&self, f: &fn(v: &T) -> bool) {\n-        for self.each |&(_, v)| { if !f(v) { break; } loop;};\n+        for self.each |_, v| { if !f(v) { break; } loop;};\n     }\n \n-    fn mutate_values(&mut self, f: &fn(&int, &mut T) -> bool) {\n+    fn mutate_values(&mut self, _f: &fn(&int, &mut T) -> bool) {\n         fail!(~\"nope\")\n     }\n \n@@ -98,7 +94,7 @@ impl<T> Map<int, T> for cat<T> {\n         }\n     }\n \n-    fn find_mut(&mut self, k: &int) -> Option<&'self mut T> { fail!() }\n+    fn find_mut(&mut self, _k: &int) -> Option<&'self mut T> { fail!() }\n \n     fn remove(&mut self, k: &int) -> bool {\n         if self.find(k).is_some() {"}]}