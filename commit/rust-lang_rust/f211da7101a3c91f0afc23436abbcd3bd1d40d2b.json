{"sha": "f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "node_id": "C_kwDOAAsO6NoAKGYyMTFkYTcxMDFhM2M5MWYwYWZjMjM0MzZhYmJjZDNiZDFkNDBkMmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T03:05:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T03:05:47Z"}, "message": "Auto merge of #109792 - cjgillot:reachable-lint, r=oli-obk\n\nOnly visit reachable blocks in ConstProp lint.\n\nFixes https://github.com/rust-lang/rust/issues/78803\nFixes https://github.com/rust-lang/rust/issues/109731", "tree": {"sha": "56aed604366e17b2fb07f43ffd8ca8d402f24619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56aed604366e17b2fb07f43ffd8ca8d402f24619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "html_url": "https://github.com/rust-lang/rust/commit/f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7ad16e82dd19ea03b19d78a02a815f2f138db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7ad16e82dd19ea03b19d78a02a815f2f138db5", "html_url": "https://github.com/rust-lang/rust/commit/8c7ad16e82dd19ea03b19d78a02a815f2f138db5"}, {"sha": "98255cc2424b8ad3de462dc4241e14e23b1aa5c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/98255cc2424b8ad3de462dc4241e14e23b1aa5c5", "html_url": "https://github.com/rust-lang/rust/commit/98255cc2424b8ad3de462dc4241e14e23b1aa5c5"}], "stats": {"total": 287, "additions": 155, "deletions": 132}, "files": [{"sha": "942ccd5a9d19efcfe36aaf5624dfcf42ea9e7ed8", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 139, "deletions": 132, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "patch": "@@ -1,15 +1,15 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use either::{Left, Right};\n+use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -130,11 +130,8 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    source_scopes: &'mir IndexSlice<SourceScope, SourceScopeData<'tcx>>,\n-    local_decls: &'mir IndexSlice<Local, LocalDecl<'tcx>>,\n-    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n-    // the last known `SourceInfo` here and just keep revisiting it.\n-    source_info: Option<SourceInfo>,\n+    worklist: Vec<BasicBlock>,\n+    visited_blocks: BitSet<BasicBlock>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n@@ -213,12 +210,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             ecx,\n             tcx,\n             param_env,\n-            source_scopes: &dummy_body.source_scopes,\n-            local_decls: &dummy_body.local_decls,\n-            source_info: None,\n+            worklist: vec![START_BLOCK],\n+            visited_blocks: BitSet::new_empty(body.basic_blocks.len()),\n         }\n     }\n \n+    fn body(&self) -> &'mir Body<'tcx> {\n+        self.ecx.frame().body\n+    }\n+\n+    fn local_decls(&self) -> &'mir LocalDecls<'tcx> {\n+        &self.body().local_decls\n+    }\n+\n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n             Ok(op) => {\n@@ -251,15 +255,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n-        source_info.scope.lint_root(self.source_scopes)\n+        source_info.scope.lint_root(&self.body().source_scopes)\n     }\n \n-    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, location: Location, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n         // Overwrite the PC -- whatever the interpreter does to it does not make any sense anyway.\n-        self.ecx.frame_mut().loc = Right(source_info.span);\n+        self.ecx.frame_mut().loc = Left(location);\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -278,7 +282,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n-    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n         if c.needs_subst() {\n             return None;\n@@ -292,45 +296,41 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // manually normalized.\n         let val = self.tcx.try_normalize_erasing_regions(self.param_env, c.literal).ok()?;\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_mir_constant(&val, Some(c.span), None))\n+        self.use_ecx(location, |this| this.ecx.eval_mir_constant(&val, Some(c.span), None))\n     }\n \n     /// Returns the value, if any, of evaluating `place`.\n-    fn eval_place(&mut self, place: Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(location, |this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n     /// or `eval_place`, depending on the variant of `Operand` used.\n-    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c, location),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, location),\n         }\n     }\n \n     fn report_assert_as_lint(\n         &self,\n         lint: &'static lint::Lint,\n-        source_info: SourceInfo,\n+        location: Location,\n         message: &'static str,\n         panic: AssertKind<impl std::fmt::Debug>,\n     ) {\n-        if let Some(lint_root) = self.lint_root(source_info) {\n+        let source_info = self.body().source_info(location);\n+        if let Some(lint_root) = self.lint_root(*source_info) {\n             self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n                 lint.span_label(source_info.span, format!(\"{:?}\", panic))\n             });\n         }\n     }\n \n-    fn check_unary_op(\n-        &mut self,\n-        op: UnOp,\n-        arg: &Operand<'tcx>,\n-        source_info: SourceInfo,\n-    ) -> Option<()> {\n-        if let (val, true) = self.use_ecx(source_info, |this| {\n+    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>, location: Location) -> Option<()> {\n+        if let (val, true) = self.use_ecx(location, |this| {\n             let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n@@ -340,7 +340,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n             self.report_assert_as_lint(\n                 lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n+                location,\n                 \"this arithmetic operation will overflow\",\n                 AssertKind::OverflowNeg(val.to_const_int()),\n             );\n@@ -355,28 +355,27 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         op: BinOp,\n         left: &Operand<'tcx>,\n         right: &Operand<'tcx>,\n-        source_info: SourceInfo,\n+        location: Location,\n     ) -> Option<()> {\n-        let r = self.use_ecx(source_info, |this| {\n+        let r = self.use_ecx(location, |this| {\n             this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?)\n         });\n-        let l = self.use_ecx(source_info, |this| {\n-            this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n-        });\n+        let l = self\n+            .use_ecx(location, |this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(self.local_decls, self.tcx);\n+            let left_ty = left.ty(self.local_decls(), self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n+                debug!(\"check_binary_op: reporting assert for {:?}\", location);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(\n                         op,\n@@ -398,13 +397,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         if let (Some(l), Some(r)) = (l, r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(source_info, |this| {\n+            if self.use_ecx(location, |this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n                 );\n@@ -414,7 +413,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -429,11 +428,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // lint.\n             Rvalue::UnaryOp(op, arg) => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg, source_info)?;\n+                self.check_unary_op(*op, arg, location)?;\n             }\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 trace!(\n@@ -442,7 +441,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     left,\n                     right\n                 );\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n \n             // Do not try creating references (#67862)\n@@ -481,10 +480,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n-        if !rvalue\n-            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(*self.ecx.tcx, self.param_env)\n-        {\n+        if !rvalue.ty(self.local_decls(), self.tcx).is_sized(self.tcx, self.param_env) {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here\n             return None;\n@@ -493,12 +489,80 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n+    fn check_assertion(\n+        &mut self,\n+        expected: bool,\n+        msg: &AssertKind<Operand<'tcx>>,\n+        cond: &Operand<'tcx>,\n+        location: Location,\n+    ) -> Option<!> {\n+        let ref value = self.eval_operand(&cond, location)?;\n+        trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+\n+        let expected = Scalar::from_bool(expected);\n+        let value_const = self.use_ecx(location, |this| this.ecx.read_scalar(&value))?;\n+\n+        if expected != value_const {\n+            // Poison all places this operand references so that further code\n+            // doesn't use the invalid value\n+            if let Some(place) = cond.place() {\n+                Self::remove_const(&mut self.ecx, place.local);\n+            }\n+\n+            enum DbgVal<T> {\n+                Val(T),\n+                Underscore,\n+            }\n+            impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n+                fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                    match self {\n+                        Self::Val(val) => val.fmt(fmt),\n+                        Self::Underscore => fmt.write_str(\"_\"),\n+                    }\n+                }\n+            }\n+            let mut eval_to_int = |op| {\n+                // This can be `None` if the lhs wasn't const propagated and we just\n+                // triggered the assert on the value of the rhs.\n+                self.eval_operand(op, location)\n+                    .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                    .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n+            };\n+            let msg = match msg {\n+                AssertKind::DivisionByZero(op) => AssertKind::DivisionByZero(eval_to_int(op)),\n+                AssertKind::RemainderByZero(op) => AssertKind::RemainderByZero(eval_to_int(op)),\n+                AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n+                    // Division overflow is *UB* in the MIR, and different than the\n+                    // other overflow checks.\n+                    AssertKind::Overflow(*bin_op, eval_to_int(op1), eval_to_int(op2))\n+                }\n+                AssertKind::BoundsCheck { ref len, ref index } => {\n+                    let len = eval_to_int(len);\n+                    let index = eval_to_int(index);\n+                    AssertKind::BoundsCheck { len, index }\n+                }\n+                // Remaining overflow errors are already covered by checks on the binary operators.\n+                AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => return None,\n+                // Need proper const propagator for these.\n+                _ => return None,\n+            };\n+            self.report_assert_as_lint(\n+                lint::builtin::UNCONDITIONAL_PANIC,\n+                location,\n+                \"this operation will panic at runtime\",\n+                msg,\n+            );\n+        }\n+\n+        None\n+    }\n+\n     fn ensure_not_propagated(&self, local: Local) {\n         if cfg!(debug_assertions) {\n             assert!(\n                 self.get_const(local.into()).is_none()\n                     || self\n-                        .layout_of(self.local_decls[local].ty)\n+                        .layout_of(self.local_decls()[local].ty)\n                         .map_or(true, |layout| layout.is_zst()),\n                 \"failed to remove values for `{local:?}`, value={:?}\",\n                 self.get_const(local.into()),\n@@ -509,7 +573,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks.iter_enumerated() {\n+        while let Some(bb) = self.worklist.pop() {\n+            if !self.visited_blocks.insert(bb) {\n+                continue;\n+            }\n+\n+            let data = &body.basic_blocks[bb];\n             self.visit_basic_block_data(bb, data);\n         }\n     }\n@@ -521,22 +590,21 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant, self.source_info.unwrap());\n+        self.eval_constant(constant, location);\n     }\n \n     fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_assign(place, rvalue, location);\n \n-        let source_info = self.source_info.unwrap();\n-        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+        let Some(()) = self.check_rvalue(rvalue, location) else { return };\n \n         match self.ecx.machine.can_const_prop[place.local] {\n             // Do nothing if the place is indirect.\n             _ if place.is_indirect() => {}\n             ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n             ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n                 if self\n-                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .use_ecx(location, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n                     .is_none()\n                 {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n@@ -562,8 +630,6 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n \n         // We want to evaluate operands before any change to the assigned-to value,\n         // so we recurse first.\n@@ -576,8 +642,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     _ if place.is_indirect() => {}\n                     ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n-                        {\n+                        if self.use_ecx(location, |this| this.ecx.statement(statement)).is_some() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n@@ -599,83 +664,24 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        let source_info = terminator.source_info;\n-        self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n-                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = Scalar::from_bool(*expected);\n-                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n-                        // FIXME should be used use_ecx rather than a local match... but we have\n-                        // quite a few of these read_scalar/read_immediate that need fixing.\n-                        return\n-                    };\n-                    if expected != value_const {\n-                        enum DbgVal<T> {\n-                            Val(T),\n-                            Underscore,\n-                        }\n-                        impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n-                            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                                match self {\n-                                    Self::Val(val) => val.fmt(fmt),\n-                                    Self::Underscore => fmt.write_str(\"_\"),\n-                                }\n-                            }\n-                        }\n-                        let mut eval_to_int = |op| {\n-                            // This can be `None` if the lhs wasn't const propagated and we just\n-                            // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info)\n-                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n-                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n-                        };\n-                        let msg = match msg {\n-                            AssertKind::DivisionByZero(op) => {\n-                                Some(AssertKind::DivisionByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::RemainderByZero(op) => {\n-                                Some(AssertKind::RemainderByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n-                                // Division overflow is *UB* in the MIR, and different than the\n-                                // other overflow checks.\n-                                Some(AssertKind::Overflow(\n-                                    *bin_op,\n-                                    eval_to_int(op1),\n-                                    eval_to_int(op2),\n-                                ))\n-                            }\n-                            AssertKind::BoundsCheck { ref len, ref index } => {\n-                                let len = eval_to_int(len);\n-                                let index = eval_to_int(index);\n-                                Some(AssertKind::BoundsCheck { len, index })\n-                            }\n-                            // Remaining overflow errors are already covered by checks on the binary operators.\n-                            AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => None,\n-                            // Need proper const propagator for these.\n-                            _ => None,\n-                        };\n-                        // Poison all places this operand references so that further code\n-                        // doesn't use the invalid value\n-                        match cond {\n-                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                            Operand::Constant(_) => {}\n-                        }\n-                        if let Some(msg) = msg {\n-                            self.report_assert_as_lint(\n-                                lint::builtin::UNCONDITIONAL_PANIC,\n-                                source_info,\n-                                \"this operation will panic at runtime\",\n-                                msg,\n-                            );\n-                        }\n-                    }\n+                self.check_assertion(*expected, msg, cond, location);\n+            }\n+            TerminatorKind::SwitchInt { ref discr, ref targets } => {\n+                if let Some(ref value) = self.eval_operand(&discr, location)\n+                  && let Some(value_const) = self.use_ecx(location, |this| this.ecx.read_scalar(&value))\n+                  && let Ok(constant) = value_const.try_to_int()\n+                  && let Ok(constant) = constant.to_bits(constant.size())\n+                {\n+                    // We managed to evaluate the discriminant, so we know we only need to visit\n+                    // one target.\n+                    let target = targets.target_for_value(constant);\n+                    self.worklist.push(target);\n+                    return;\n                 }\n+                // We failed to evaluate the discriminant, fallback to visiting all successors.\n             }\n             // None of these have Operands to const-propagate.\n             TerminatorKind::Goto { .. }\n@@ -688,10 +694,11 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. } => {}\n         }\n+\n+        self.worklist.extend(terminator.successors());\n     }\n \n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {"}, {"sha": "8cf98e154eaa06c7de31aba1743c74ee98cbc075", "filename": "tests/ui/const_prop/unreachable-bounds.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/tests%2Fui%2Fconst_prop%2Funreachable-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/tests%2Fui%2Fconst_prop%2Funreachable-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst_prop%2Funreachable-bounds.rs?ref=f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "patch": "@@ -0,0 +1,6 @@\n+// Use `build-pass` to ensure const-prop lint runs.\n+// build-pass\n+\n+fn main() {\n+    [()][if false { 1 } else { return }]\n+}"}, {"sha": "2875135424d2003c1b4b573268ddb7c2d80b4315", "filename": "tests/ui/const_prop/unreachable-overflow.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/tests%2Fui%2Fconst_prop%2Funreachable-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f211da7101a3c91f0afc23436abbcd3bd1d40d2b/tests%2Fui%2Fconst_prop%2Funreachable-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst_prop%2Funreachable-overflow.rs?ref=f211da7101a3c91f0afc23436abbcd3bd1d40d2b", "patch": "@@ -0,0 +1,10 @@\n+// Use `build-pass` to ensure const-prop lint runs.\n+// build-pass\n+\n+fn main() {\n+    let x = 2u32;\n+    let y = 3u32;\n+    if y <= x {\n+        dbg!(x - y);\n+    }\n+}"}]}