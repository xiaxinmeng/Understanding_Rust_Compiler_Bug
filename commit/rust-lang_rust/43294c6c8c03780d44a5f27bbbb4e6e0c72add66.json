{"sha": "43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMjk0YzZjOGMwMzc4MGQ0NGE1ZjI3YmJiYjRlNmUwYzcyYWRkNjY=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-26T10:01:11Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-01T10:18:48Z"}, "message": "middle: HirIdify dead", "tree": {"sha": "c09a7d0b074f71ce939400576bc4104779844f7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c09a7d0b074f71ce939400576bc4104779844f7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "html_url": "https://github.com/rust-lang/rust/commit/43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43294c6c8c03780d44a5f27bbbb4e6e0c72add66/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4543fc243e23780f29b15b4a805253660569f980", "url": "https://api.github.com/repos/rust-lang/rust/commits/4543fc243e23780f29b15b4a805253660569f980", "html_url": "https://github.com/rust-lang/rust/commit/4543fc243e23780f29b15b4a805253660569f980"}], "stats": {"total": 117, "additions": 59, "deletions": 58}, "files": [{"sha": "3b607127d8628a1afedba18529ed986edb1cd59a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/43294c6c8c03780d44a5f27bbbb4e6e0c72add66/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43294c6c8c03780d44a5f27bbbb4e6e0c72add66/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "patch": "@@ -26,8 +26,8 @@ use syntax_pos;\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            node_id: ast::NodeId) -> bool {\n-    match tcx.hir().find(node_id) {\n+                            hir_id: hir::HirId) -> bool {\n+    match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -39,33 +39,33 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) ||\n-               self.struct_constructors.contains_key(&node_id) {\n-                self.worklist.push(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            if should_explore(self.tcx, hir_id) ||\n+               self.struct_constructors.contains_key(&hir_id) {\n+                self.worklist.push(hir_id);\n             }\n-            self.live_symbols.insert(node_id);\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            debug_assert!(!should_explore(self.tcx, node_id));\n-            self.live_symbols.insert(node_id);\n+        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            debug_assert!(!should_explore(self.tcx, hir_id));\n+            self.live_symbols.insert(hir_id);\n         }\n     }\n \n@@ -136,7 +136,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(id) {\n+            if let Some(node) = self.tcx.hir().find_by_hir_id(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         let live_fields = def.fields().iter().filter(|f| {\n             has_repr_c || inherited_pub_visibility || f.vis.node.is_pub()\n         });\n-        self.live_symbols.extend(live_fields.map(|f| f.id));\n+        self.live_symbols.extend(live_fields.map(|f| f.hir_id));\n \n         intravisit::walk_struct_def(self, def);\n     }\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n }\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n-                                    id: ast::NodeId,\n+                                    id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n@@ -306,7 +306,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n         return true;\n     }\n \n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n@@ -333,25 +333,25 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder<'k, 'tcx: 'k> {\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n-    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n+    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                               item.id,\n+                                                               item.hir_id,\n                                                                &item.attrs);\n         if allow_dead_code {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter()\n-                                                      .map(|variant| variant.node.data.id()));\n+                                                      .map(|variant| variant.node.data.hir_id()));\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n@@ -360,9 +360,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                                trait_item.id,\n+                                                                trait_item.hir_id,\n                                                                 &trait_item.attrs) {\n-                                self.worklist.push(trait_item.id);\n+                                self.worklist.push(trait_item.hir_id);\n                             }\n                         }\n                         _ => {}\n@@ -374,14 +374,14 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                             impl_item.id,\n+                                                             impl_item.hir_id,\n                                                              &impl_item.attrs) {\n-                        self.worklist.push(impl_item_ref.id.node_id);\n+                        self.worklist.push(self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id));\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n-                self.struct_constructors.insert(variant_data.id(), item.id);\n+                self.struct_constructors.insert(variant_data.hir_id(), item.hir_id);\n             }\n             _ => ()\n         }\n@@ -400,16 +400,16 @@ fn create_and_seed_worklist<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n-) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n+) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n-            Some(id)\n+            Some(tcx.hir().node_to_hir_id(id))\n         } else {\n             None\n         }\n     }).chain(\n         // Seed entry point\n-        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_node_id(def_id).unwrap())\n+        tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id).unwrap())\n     ).collect::<Vec<_>>();\n \n     // Seed implemented trait items\n@@ -427,7 +427,7 @@ fn create_and_seed_worklist<'a, 'tcx>(\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> FxHashSet<ast::NodeId> {\n+                       -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -446,7 +446,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: FxHashSet<ast::NodeId>,\n+    live_symbols: FxHashSet<hir::HirId>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n@@ -461,33 +461,33 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        should_warn && !self.symbol_is_live(item.id)\n+        should_warn && !self.symbol_is_live(item.hir_id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id)\n+            && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id())\n+        !self.symbol_is_live(variant.data.hir_id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                 variant.data.id(),\n+                                                 variant.data.hir_id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id)\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n+        !self.symbol_is_live(fi.hir_id)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id, &fi.attrs)\n     }\n \n-    // id := node id of an item's definition.\n+    // id := HIR id of an item's definition.\n     fn symbol_is_live(\n         &mut self,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) -> bool {\n         if self.live_symbols.contains(&id) {\n             return true;\n@@ -496,12 +496,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir().local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_node_id) = self.tcx.hir().as_local_node_id(item_did) {\n-                    if self.live_symbols.contains(&item_node_id) {\n+                if let Some(item_hir_id) = self.tcx.hir().as_local_hir_id(item_did) {\n+                    if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }\n                 }\n@@ -511,18 +511,18 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn warn_dead_code(&mut self,\n-                      id: ast::NodeId,\n+                      id: hir::HirId,\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str,\n                       participle: &str) {\n         if !name.as_str().starts_with(\"_\") {\n             self.tcx\n-                .lint_node(lint::builtin::DEAD_CODE,\n-                           id,\n-                           span,\n-                           &format!(\"{} is never {}: `{}`\",\n-                                    node_type, participle, name));\n+                .lint_hir(lint::builtin::DEAD_CODE,\n+                          id,\n+                          span,\n+                          &format!(\"{} is never {}: `{}`\",\n+                                   node_type, participle, name));\n         }\n     }\n }\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 _ => \"used\"\n             };\n             self.warn_dead_code(\n-                item.id,\n+                item.hir_id,\n                 span,\n                 item.ident.name,\n                 item.node.descriptive_variant(),\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.ident.name,\n+            self.warn_dead_code(variant.node.data.hir_id(), variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n@@ -581,24 +581,24 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident.name,\n+            self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name,\n                                 fi.node.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n-            self.warn_dead_code(field.id, field.span, field.ident.name, \"field\", \"used\");\n+            self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"field\", \"used\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n-                    self.warn_dead_code(impl_item.id,\n+                if !self.symbol_is_live(impl_item.hir_id) {\n+                    self.warn_dead_code(impl_item.hir_id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n                                         \"associated const\",\n@@ -607,9 +607,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id) {\n+                if !self.symbol_is_live(impl_item.hir_id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n-                    self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n+                    self.warn_dead_code(impl_item.hir_id, span, impl_item.ident.name, \"method\",\n+                        \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}]}