{"sha": "fba1926a2f291528e651fa9b86129f786a10be68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTE5MjZhMmYyOTE1MjhlNjUxZmE5Yjg2MTI5Zjc4NmExMGJlNjg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-10T21:01:25Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-11T22:49:23Z"}, "message": "Fix hygiene regression in patterns", "tree": {"sha": "c48fec56f3d808c00283c94f537a9daa67437661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c48fec56f3d808c00283c94f537a9daa67437661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba1926a2f291528e651fa9b86129f786a10be68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba1926a2f291528e651fa9b86129f786a10be68", "html_url": "https://github.com/rust-lang/rust/commit/fba1926a2f291528e651fa9b86129f786a10be68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba1926a2f291528e651fa9b86129f786a10be68/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8eaa1605a40978c65ebf255dd2e16ef729193c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8eaa1605a40978c65ebf255dd2e16ef729193c2", "html_url": "https://github.com/rust-lang/rust/commit/b8eaa1605a40978c65ebf255dd2e16ef729193c2"}], "stats": {"total": 79, "additions": 65, "deletions": 14}, "files": [{"sha": "e794ab39e54508aaaabd92d67f6eb7ad58e9d3e5", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -14,6 +14,7 @@ use middle::ty;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n+use syntax::ext::mtwt;\n use rustc_front::hir;\n use rustc_front::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n@@ -26,8 +27,8 @@ pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n-    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n-        map.insert(path1.node, p_id);\n+    pat_bindings_hygienic(dm, pat, |_bm, p_id, _s, path1| {\n+        map.insert(mtwt::resolve(path1.node), p_id);\n     });\n     map\n }"}, {"sha": "d83bb411b4d05c6c080b721dd7fb74143156c954", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -678,8 +678,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || resolve::resolve_crate(sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n+    // FIXME: get rid of uses of MTWT tables in typeck, mir and trans and clear them\n     if !sess.opts.debugging_opts.keep_mtwt_tables {\n-        syntax::ext::mtwt::clear_tables();\n+        // syntax::ext::mtwt::clear_tables();\n     }\n \n     let named_region_map = time(time_passes,"}, {"sha": "a590a2c61e16afa8c5a4a10dba1fa743bbab9448", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::pat_util;\n use rustc::middle::ty::{self, VariantDef, Ty};\n use rustc_front::hir;\n use rustc_front::util as hir_util;\n+use syntax::ext::mtwt;\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -490,8 +491,8 @@ fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<\n         None\n     } else {\n         map = FnvHashMap();\n-        pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n-            map.insert(path.node, p_id);\n+        pat_util::pat_bindings_hygienic(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n+            map.insert(mtwt::resolve(path.node), p_id);\n         });\n         Some(&map)\n     };"}, {"sha": "3d5cb83197585c7b7aea5b5fe73ab21158ce7b85", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -19,6 +19,7 @@ use rustc::middle::subst::Substs;\n use rustc::middle::ty::{self, Ty};\n use rustc_front::hir;\n use syntax::ast;\n+use syntax::ext::mtwt;\n use syntax::ptr::P;\n \n /// When there are multiple patterns in a single arm, each one has its\n@@ -161,7 +162,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             {\n                 let id = match self.binding_map {\n                     None => pat.id,\n-                    Some(ref map) => map[&ident.node.name],\n+                    Some(ref map) => map[&mtwt::resolve(ident.node)],\n                 };\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {"}, {"sha": "b2e989bc874a3b03a766838fb76219ed953a4b9f", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -228,6 +228,7 @@ use std::fmt;\n use std::rc::Rc;\n use rustc_front::hir;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n+use syntax::ext::mtwt;\n use syntax::codemap::Span;\n use rustc_front::fold::Folder;\n use syntax::ptr::P;\n@@ -477,7 +478,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 hir::PatIdent(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node.name, val.val));\n+                    bound_ptrs.push((mtwt::resolve(path.node), val.val));\n                     &**inner\n                 },\n                 _ => break\n@@ -518,15 +519,15 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(&dm.borrow(), &*this) {\n-                        bound_ptrs.push((path.node.name, val.val));\n+                        bound_ptrs.push((mtwt::resolve(path.node), val.val));\n                     }\n                 }\n                 hir::PatVec(ref before, Some(ref slice), ref after) => {\n                     if let hir::PatIdent(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n-                        bound_ptrs.push((path.node.name, subslice_val));\n+                        bound_ptrs.push((mtwt::resolve(path.node), subslice_val));\n                     }\n                 }\n                 _ => {}\n@@ -1127,8 +1128,8 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         None => {\n             let data = &m[0].data;\n-            for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n-                let binfo = *data.bindings_map.get(ident).unwrap();\n+            for &(ref name, ref value_ptr) in &m[0].bound_ptrs {\n+                let binfo = *data.bindings_map.get(name).unwrap();\n                 call_lifetime_start(bcx, binfo.llmatch);\n                 if binfo.trmode == TrByRef && type_is_fat_ptr(bcx.tcx(), binfo.ty) {\n                     expr::copy_fat_ptr(bcx, *value_ptr, binfo.llmatch);\n@@ -1526,8 +1527,8 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n-        let name = path1.node;\n+    pat_bindings_hygienic(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+        let name = mtwt::resolve(path1.node);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();"}, {"sha": "aaaca48600661878662050f31c608c3232611904", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -25,6 +25,7 @@ use util::nodemap::FnvHashMap;\n use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n+use syntax::ext::mtwt;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n@@ -179,7 +180,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = *pcx.map.get(&path.node.name).unwrap();\n+            let canon_id = *pcx.map.get(&mtwt::resolve(path.node)).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);"}, {"sha": "61c601ac6a903d887306a55d204b90d153a629b9", "filename": "src/test/run-pass/issue-29746.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fba1926a2f291528e651fa9b86129f786a10be68/src%2Ftest%2Frun-pass%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1926a2f291528e651fa9b86129f786a10be68/src%2Ftest%2Frun-pass%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29746.rs?ref=fba1926a2f291528e651fa9b86129f786a10be68", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// zip!(a1,a2,a3,a4) is equivalent to:\n+//  a1.zip(a2).zip(a3).zip(a4).map(|(((x1,x2),x3),x4)| (x1,x2,x3,x4))\n+macro_rules! zip {\n+    // Entry point\n+    ([$a:expr, $b:expr, $($rest:expr),*]) => {\n+        zip!([$($rest),*], $a.zip($b), (x,y), [x,y])\n+    };\n+\n+    // Intermediate steps to build the zipped expression, the match pattern, and\n+    //  and the output tuple of the closure, using macro hygene to repeatedly\n+    //  introduce new variables named 'x'.\n+    ([$a:expr, $($rest:expr),*], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n+        zip!([$($rest),*], $zip.zip($a), ($pat,x), [$($flat),*, x])\n+    };\n+\n+    // Final step\n+    ([], $zip:expr, $pat:pat, [$($flat:expr),+]) => {\n+        $zip.map(|$pat| ($($flat),+))\n+    };\n+\n+    // Comma\n+    ([$a:expr], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n+        zip!([$a,], $zip, $pat, [$($flat),*])\n+    };\n+}\n+\n+fn main() {\n+    let p1 = vec![1i32,    2].into_iter();\n+    let p2 = vec![\"10\",    \"20\"].into_iter();\n+    let p3 = vec![100u16,  200].into_iter();\n+    let p4 = vec![1000i64, 2000].into_iter();\n+\n+    let e = zip!([p1,p2,p3,p4]).collect::<Vec<_>>();\n+    assert_eq!(e[0], (1i32,\"10\",100u16,1000i64));\n+}"}]}