{"sha": "b16556efa06ac5705d91d026e947dd2052659147", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNjU1NmVmYTA2YWM1NzA1ZDkxZDAyNmU5NDdkZDIwNTI2NTkxNDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-23T19:50:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-23T19:50:58Z"}, "message": "Rollup merge of #60177 - rasendubi:rustdoc-comments, r=varkor\n\nPromote rust comments to rustdoc", "tree": {"sha": "5ff1742174c29672c9454616131d9458de00bcb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ff1742174c29672c9454616131d9458de00bcb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b16556efa06ac5705d91d026e947dd2052659147", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcv2yiCRBK7hj4Ov3rIwAAdHIIAD8eeZ1JR/mTVmUX3avozrut\nC6AkoqhVWUOSU053+OXrOa9WtApcfLYUidShm7xx6V19i0Q3JmN+7VQkiTf4llSM\n6QkdGYb5KYDmumiMFCa56P9vrwmfaLakFzBMWN0gE4c3e71FUOXe+7mPILNbYATw\n+hR61QLtyywYDCu0T2GgjYHUGlgGYsTgC5SuTNpdcKi5U5zxWp72G79XMHDG7NvC\nvl4iYg4GEuLMd4t+ldsSN8eMo7wDEEA3yRJMEHb0i1puLFWPhI5XBtqB2hilfXMk\nmeHxstOUtsGsu7cxTeOwrzwOqogVCnG5WfhNjMrnW+d1FdwqnWkEQ04HMHoUixw=\n=Veqb\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ff1742174c29672c9454616131d9458de00bcb8\nparent d1b2d6d64d0ec496c176c1c5169e211918080514\nparent 517fb1b06f8b481d559285d1c3c665e143ad8156\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556049058 +0200\ncommitter GitHub <noreply@github.com> 1556049058 +0200\n\nRollup merge of #60177 - rasendubi:rustdoc-comments, r=varkor\n\nPromote rust comments to rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b16556efa06ac5705d91d026e947dd2052659147", "html_url": "https://github.com/rust-lang/rust/commit/b16556efa06ac5705d91d026e947dd2052659147", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b16556efa06ac5705d91d026e947dd2052659147/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1b2d6d64d0ec496c176c1c5169e211918080514", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b2d6d64d0ec496c176c1c5169e211918080514", "html_url": "https://github.com/rust-lang/rust/commit/d1b2d6d64d0ec496c176c1c5169e211918080514"}, {"sha": "517fb1b06f8b481d559285d1c3c665e143ad8156", "url": "https://api.github.com/repos/rust-lang/rust/commits/517fb1b06f8b481d559285d1c3c665e143ad8156", "html_url": "https://github.com/rust-lang/rust/commit/517fb1b06f8b481d559285d1c3c665e143ad8156"}], "stats": {"total": 299, "additions": 148, "deletions": 151}, "files": [{"sha": "f33250343513113f870c9a9594f38b79e45e1099", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 134, "deletions": 137, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b16556efa06ac5705d91d026e947dd2052659147", "patch": "@@ -111,31 +111,31 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// and for error reporting logic to read arbitrary node types.\n     pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n-    // Cache for projections. This cache is snapshotted along with the\n-    // infcx.\n-    //\n-    // Public so that `traits::project` can use it.\n+    /// Cache for projections. This cache is snapshotted along with the\n+    /// infcx.\n+    ///\n+    /// Public so that `traits::project` can use it.\n     pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n \n-    // We instantiate UnificationTable with bounds<Ty> because the\n-    // types that might instantiate a general type variable have an\n-    // order, represented by its upper and lower bounds.\n+    /// We instantiate `UnificationTable` with `bounds<Ty>` because the\n+    /// types that might instantiate a general type variable have an\n+    /// order, represented by its upper and lower bounds.\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n-    // Map from integral variable to the kind of integer it represents\n+    /// Map from integral variable to the kind of integer it represents\n     int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n \n-    // Map from floating variable to the kind of float it represents\n+    /// Map from floating variable to the kind of float it represents\n     float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n \n-    // Tracks the set of region variables and the constraints between\n-    // them.  This is initially `Some(_)` but when\n-    // `resolve_regions_and_report_errors` is invoked, this gets set\n-    // to `None` -- further attempts to perform unification etc may\n-    // fail if new region constraints would've been added.\n+    /// Tracks the set of region variables and the constraints between\n+    /// them.  This is initially `Some(_)` but when\n+    /// `resolve_regions_and_report_errors` is invoked, this gets set\n+    /// to `None` -- further attempts to perform unification etc may\n+    /// fail if new region constraints would've been added.\n     region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n \n-    // Once region inference is done, the values for each variable.\n+    /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n \n     /// Caches the results of trait selection. This cache is used\n@@ -145,65 +145,65 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// Caches the results of trait evaluation.\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n-    // the set of predicates on which errors have been reported, to\n-    // avoid reporting the same error twice.\n+    /// the set of predicates on which errors have been reported, to\n+    /// avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n-    // When an error occurs, we want to avoid reporting \"derived\"\n-    // errors that are due to this original failure. Normally, we\n-    // handle this with the `err_count_on_creation` count, which\n-    // basically just tracks how many errors were reported when we\n-    // started type-checking a fn and checks to see if any new errors\n-    // have been reported since then. Not great, but it works.\n-    //\n-    // However, when errors originated in other passes -- notably\n-    // resolve -- this heuristic breaks down. Therefore, we have this\n-    // auxiliary flag that one can set whenever one creates a\n-    // type-error that is due to an error in a prior pass.\n-    //\n-    // Don't read this flag directly, call `is_tainted_by_errors()`\n-    // and `set_tainted_by_errors()`.\n+    /// When an error occurs, we want to avoid reporting \"derived\"\n+    /// errors that are due to this original failure. Normally, we\n+    /// handle this with the `err_count_on_creation` count, which\n+    /// basically just tracks how many errors were reported when we\n+    /// started type-checking a fn and checks to see if any new errors\n+    /// have been reported since then. Not great, but it works.\n+    ///\n+    /// However, when errors originated in other passes -- notably\n+    /// resolve -- this heuristic breaks down. Therefore, we have this\n+    /// auxiliary flag that one can set whenever one creates a\n+    /// type-error that is due to an error in a prior pass.\n+    ///\n+    /// Don't read this flag directly, call `is_tainted_by_errors()`\n+    /// and `set_tainted_by_errors()`.\n     tainted_by_errors_flag: Cell<bool>,\n \n-    // Track how many errors were reported when this infcx is created.\n-    // If the number of errors increases, that's also a sign (line\n-    // `tained_by_errors`) to avoid reporting certain kinds of errors.\n+    /// Track how many errors were reported when this infcx is created.\n+    /// If the number of errors increases, that's also a sign (line\n+    /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n \n-    // This flag is true while there is an active snapshot.\n+    /// This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    // A set of constraints that regionck must validate. Each\n-    // constraint has the form `T:'a`, meaning \"some type `T` must\n-    // outlive the lifetime 'a\". These constraints derive from\n-    // instantiated type parameters. So if you had a struct defined\n-    // like\n-    //\n-    //     struct Foo<T:'static> { ... }\n-    //\n-    // then in some expression `let x = Foo { ... }` it will\n-    // instantiate the type parameter `T` with a fresh type `$0`. At\n-    // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck. (We\n-    // can't generally check these things right away because we have\n-    // to wait until types are resolved.)\n-    //\n-    // These are stored in a map keyed to the id of the innermost\n-    // enclosing fn body / static initializer expression. This is\n-    // because the location where the obligation was incurred can be\n-    // relevant with respect to which sublifetime assumptions are in\n-    // place. The reason that we store under the fn-id, and not\n-    // something more fine-grained, is so that it is easier for\n-    // regionck to be sure that it has found *all* the region\n-    // obligations (otherwise, it's easy to fail to walk to a\n-    // particular node-id).\n-    //\n-    // Before running `resolve_regions_and_report_errors`, the creator\n-    // of the inference context is expected to invoke\n-    // `process_region_obligations` (defined in `self::region_obligations`)\n-    // for each body-id in this map, which will process the\n-    // obligations within. This is expected to be done 'late enough'\n-    // that all type inference variables have been bound and so forth.\n+    /// A set of constraints that regionck must validate. Each\n+    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// outlive the lifetime 'a\". These constraints derive from\n+    /// instantiated type parameters. So if you had a struct defined\n+    /// like\n+    ///\n+    ///     struct Foo<T:'static> { ... }\n+    ///\n+    /// then in some expression `let x = Foo { ... }` it will\n+    /// instantiate the type parameter `T` with a fresh type `$0`. At\n+    /// the same time, it will record a region obligation of\n+    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// can't generally check these things right away because we have\n+    /// to wait until types are resolved.)\n+    ///\n+    /// These are stored in a map keyed to the id of the innermost\n+    /// enclosing fn body / static initializer expression. This is\n+    /// because the location where the obligation was incurred can be\n+    /// relevant with respect to which sublifetime assumptions are in\n+    /// place. The reason that we store under the fn-id, and not\n+    /// something more fine-grained, is so that it is easier for\n+    /// regionck to be sure that it has found *all* the region\n+    /// obligations (otherwise, it's easy to fail to walk to a\n+    /// particular node-id).\n+    ///\n+    /// Before running `resolve_regions_and_report_errors`, the creator\n+    /// of the inference context is expected to invoke\n+    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// for each body-id in this map, which will process the\n+    /// obligations within. This is expected to be done 'late enough'\n+    /// that all type inference variables have been bound and so forth.\n     pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n \n     /// What is the innermost universe we have created? Starts out as\n@@ -247,85 +247,85 @@ pub struct TypeTrace<'tcx> {\n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n-    // Arose from a subtyping relation\n+    /// Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n \n-    // Stack-allocated closures cannot outlive innermost loop\n-    // or function so as to ensure we only require finite stack\n+    /// Stack-allocated closures cannot outlive innermost loop\n+    /// or function so as to ensure we only require finite stack\n     InfStackClosure(Span),\n \n-    // Invocation of closure must be within its lifetime\n+    /// Invocation of closure must be within its lifetime\n     InvokeClosure(Span),\n \n-    // Dereference of reference must be within its lifetime\n+    /// Dereference of reference must be within its lifetime\n     DerefPointer(Span),\n \n-    // Closure bound must not outlive captured free variables\n+    /// Closure bound must not outlive captured free variables\n     FreeVariable(Span, ast::NodeId),\n \n-    // Index into slice must be within its lifetime\n+    /// Index into slice must be within its lifetime\n     IndexSlice(Span),\n \n-    // When casting `&'a T` to an `&'b Trait` object,\n-    // relating `'a` to `'b`\n+    /// When casting `&'a T` to an `&'b Trait` object,\n+    /// relating `'a` to `'b`\n     RelateObjectBound(Span),\n \n-    // Some type parameter was instantiated with the given type,\n-    // and that type must outlive some region.\n+    /// Some type parameter was instantiated with the given type,\n+    /// and that type must outlive some region.\n     RelateParamBound(Span, Ty<'tcx>),\n \n-    // The given region parameter was instantiated with a region\n-    // that must outlive some other region.\n+    /// The given region parameter was instantiated with a region\n+    /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    // A bound placed on type parameters that states that must outlive\n-    // the moment of their instantiation.\n+    /// A bound placed on type parameters that states that must outlive\n+    /// the moment of their instantiation.\n     RelateDefaultParamBound(Span, Ty<'tcx>),\n \n-    // Creating a pointer `b` to contents of another reference\n+    /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n-    // Creating a pointer `b` to contents of an upvar\n+    /// Creating a pointer `b` to contents of an upvar\n     ReborrowUpvar(Span, ty::UpvarId),\n \n-    // Data with type `Ty<'tcx>` was borrowed\n+    /// Data with type `Ty<'tcx>` was borrowed\n     DataBorrowed(Ty<'tcx>, Span),\n \n-    // (&'a &'b T) where a >= b\n+    /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n-    // Type or region parameters must be in scope.\n+    /// Type or region parameters must be in scope.\n     ParameterInScope(ParameterOrigin, Span),\n \n-    // The type T of an expression E must outlive the lifetime for E.\n+    /// The type T of an expression E must outlive the lifetime for E.\n     ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n-    // A `ref b` whose region does not enclose the decl site\n+    /// A `ref b` whose region does not enclose the decl site\n     BindingTypeIsNotValidAtDecl(Span),\n \n-    // Regions appearing in a method receiver must outlive method call\n+    /// Regions appearing in a method receiver must outlive method call\n     CallRcvr(Span),\n \n-    // Regions appearing in a function argument must outlive func call\n+    /// Regions appearing in a function argument must outlive func call\n     CallArg(Span),\n \n-    // Region in return type of invoked fn must enclose call\n+    /// Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n-    // Operands must be in scope\n+    /// Operands must be in scope\n     Operand(Span),\n \n-    // Region resulting from a `&` expr must enclose the `&` expr\n+    /// Region resulting from a `&` expr must enclose the `&` expr\n     AddrOf(Span),\n \n-    // An auto-borrow that does not enclose the expr where it occurs\n+    /// An auto-borrow that does not enclose the expr where it occurs\n     AutoBorrow(Span),\n \n-    // Region constraint arriving from destructor safety\n+    /// Region constraint arriving from destructor safety\n     SafeDestructor(Span),\n \n-    // Comparing the signature and requirements of an impl method against\n-    // the containing trait.\n+    /// Comparing the signature and requirements of an impl method against\n+    /// the containing trait.\n     CompareImplMethodObligation {\n         span: Span,\n         item_name: ast::Name,\n@@ -361,35 +361,35 @@ pub enum LateBoundRegionConversionTime {\n /// See `error_reporting` module for more details\n #[derive(Copy, Clone, Debug)]\n pub enum RegionVariableOrigin {\n-    // Region variables created for ill-categorized reasons,\n-    // mostly indicates places in need of refactoring\n+    /// Region variables created for ill-categorized reasons,\n+    /// mostly indicates places in need of refactoring\n     MiscVariable(Span),\n \n-    // Regions created by a `&P` or `[...]` pattern\n+    /// Regions created by a `&P` or `[...]` pattern\n     PatternRegion(Span),\n \n-    // Regions created by `&` operator\n+    /// Regions created by `&` operator\n     AddrOfRegion(Span),\n \n-    // Regions created as part of an autoref of a method receiver\n+    /// Regions created as part of an autoref of a method receiver\n     Autoref(Span),\n \n-    // Regions created as part of an automatic coercion\n+    /// Regions created as part of an automatic coercion\n     Coercion(Span),\n \n-    // Region variables created as the values for early-bound regions\n+    /// Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, InternedString),\n \n-    // Region variables created for bound regions\n-    // in a function or method that is called\n+    /// Region variables created for bound regions\n+    /// in a function or method that is called\n     LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n \n     UpvarRegion(ty::UpvarId, Span),\n \n     BoundRegionInCoherence(ast::Name),\n \n-    // This origin is used for the inference variables that we create\n-    // during NLL region processing.\n+    /// This origin is used for the inference variables that we create\n+    /// during NLL region processing.\n     NLL(NLLRegionVariableOrigin),\n }\n \n@@ -686,22 +686,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    // then restore the flag to its original value. This flag is a\n-    // debugging measure designed to detect cases where we start a\n-    // snapshot, create type variables, and register obligations\n-    // which may involve those type variables in the fulfillment cx,\n-    // potentially leaving \"dangling type variables\" behind.\n-    // In such cases, an assertion will fail when attempting to\n-    // register obligations, within a snapshot. Very useful, much\n-    // better than grovelling through megabytes of RUST_LOG output.\n-    //\n-    // HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    // obligations. As long as this fulfillment cx is fully drained\n-    // before we return, this is not a problem, as there won't be any\n-    // escaping obligations in the main cx. In those cases, you can\n-    // use this function.\n+    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n+    /// then restore the flag to its original value. This flag is a\n+    /// debugging measure designed to detect cases where we start a\n+    /// snapshot, create type variables, and register obligations\n+    /// which may involve those type variables in the fulfillment cx,\n+    /// potentially leaving \"dangling type variables\" behind.\n+    /// In such cases, an assertion will fail when attempting to\n+    /// register obligations, within a snapshot. Very useful, much\n+    /// better than grovelling through megabytes of `RUST_LOG` output.\n+    ///\n+    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n+    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n+    /// obligations. As long as this fulfillment cx is fully drained\n+    /// before we return, this is not a problem, as there won't be any\n+    /// escaping obligations in the main cx. In those cases, you can\n+    /// use this function.\n     pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n     where\n         F: FnOnce(&Self) -> R,\n@@ -828,7 +828,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    // Execute `f` in a snapshot, and commit the bindings it creates\n+    /// Execute `f` in a snapshot, and commit the bindings it creates.\n     pub fn in_snapshot<T, F>(&self, f: F) -> T\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n@@ -854,9 +854,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n-    /// - None -- if none of them involve \"region outlives\" constraints\n-    /// - Some(true) -- if there are `'a: 'b` constraints where `'a` or `'b` is a placehodler\n-    /// - Some(false) -- if there are `'a: 'b` constraints but none involve placeholders\n+    /// - `None` -- if none of them involve \"region outlives\" constraints\n+    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n+    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n     pub fn region_constraints_added_in_snapshot(\n         &self,\n         snapshot: &CombinedSnapshot<'a, 'tcx>,\n@@ -1292,19 +1292,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.type_variables.borrow_mut().root_var(var)\n     }\n \n+    /// Where possible, replaces type/int/float variables in\n+    /// `value` with their final value. Note that region variables\n+    /// are unaffected. If a type variable has not been unified, it\n+    /// is left as is. This is an idempotent operation that does\n+    /// not affect inference state in any way and so you can do it\n+    /// at will.\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        /*!\n-         * Where possible, replaces type/int/float variables in\n-         * `value` with their final value. Note that region variables\n-         * are unaffected. If a type variable has not been unified, it\n-         * is left as is. This is an idempotent operation that does\n-         * not affect inference state in any way and so you can do it\n-         * at will.\n-         */\n-\n         if !value.needs_infer() {\n             return value.clone(); // avoid duplicated subst-folding\n         }"}, {"sha": "67be228d232e16c2fe5ef75fdda7eefa049f6d7b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b16556efa06ac5705d91d026e947dd2052659147", "patch": "@@ -438,12 +438,12 @@ bitflags! {\n         // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9;\n \n-        // `true` if there are \"names\" of types and regions and so forth\n-        // that are local to a particular fn\n+        /// `true` if there are \"names\" of types and regions and so forth\n+        /// that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n-        // Present if the type belongs in a local type context.\n-        // Only set for Infer other than Fresh.\n+        /// Present if the type belongs in a local type context.\n+        /// Only set for Infer other than Fresh.\n         const KEEP_IN_LOCAL_TCX  = 1 << 11;\n \n         // Is there a projection that does not involve a bound region?\n@@ -462,9 +462,9 @@ bitflags! {\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n-        // Flags representing the nominal content of a type,\n-        // computed by FlagsComputation. If you add a new nominal\n-        // flag, it should be added here too.\n+        /// Flags representing the nominal content of a type,\n+        /// computed by FlagsComputation. If you add a new nominal\n+        /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n                                   TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |"}, {"sha": "b8ae0430502b5f9d5bd0c4ae8103d31d191f9493", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b16556efa06ac5705d91d026e947dd2052659147", "patch": "@@ -439,16 +439,16 @@ struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     substs: &'a [Kind<'tcx>],\n \n-    // The location for which the substitution is performed, if available.\n+    /// The location for which the substitution is performed, if available.\n     span: Option<Span>,\n \n-    // The root type that is being substituted, if available.\n+    /// The root type that is being substituted, if available.\n     root_ty: Option<Ty<'tcx>>,\n \n-    // Depth of type stack\n+    /// Depth of type stack\n     ty_stack_depth: usize,\n \n-    // Number of region binders we have passed through while doing the substitution\n+    /// Number of region binders we have passed through while doing the substitution\n     binders_passed: u32,\n }\n "}, {"sha": "c806020039d267cd4462cc9f5baa6be84d6caf2b", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16556efa06ac5705d91d026e947dd2052659147/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=b16556efa06ac5705d91d026e947dd2052659147", "patch": "@@ -24,11 +24,11 @@ struct SyntaxContextData {\n     outer_mark: Mark,\n     transparency: Transparency,\n     prev_ctxt: SyntaxContext,\n-    // This context, but with all transparent and semi-transparent marks filtered away.\n+    /// This context, but with all transparent and semi-transparent marks filtered away.\n     opaque: SyntaxContext,\n-    // This context, but with all transparent marks filtered away.\n+    /// This context, but with all transparent marks filtered away.\n     opaque_and_semitransparent: SyntaxContext,\n-    // Name of the crate to which `$crate` with this context would resolve.\n+    /// Name of the crate to which `$crate` with this context would resolve.\n     dollar_crate_name: Symbol,\n }\n "}]}