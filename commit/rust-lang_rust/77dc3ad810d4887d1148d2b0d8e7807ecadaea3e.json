{"sha": "77dc3ad810d4887d1148d2b0d8e7807ecadaea3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZGMzYWQ4MTBkNDg4N2QxMTQ4ZDJiMGQ4ZTc4MDdlY2FkYWVhM2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-22T00:17:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-23T00:09:16Z"}, "message": "libsyntax: De-mut the macro parser. rs=demuting", "tree": {"sha": "126079d2365d3aa2d4e1d74e25fbc662ef702c0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/126079d2365d3aa2d4e1d74e25fbc662ef702c0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e", "html_url": "https://github.com/rust-lang/rust/commit/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17dcaee9d13a39fe38e010514d8489060a20509d", "url": "https://api.github.com/repos/rust-lang/rust/commits/17dcaee9d13a39fe38e010514d8489060a20509d", "html_url": "https://github.com/rust-lang/rust/commit/17dcaee9d13a39fe38e010514d8489060a20509d"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "1a04da95801534b8293740007831bf04dd3dcf8e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77dc3ad810d4887d1148d2b0d8e7807ecadaea3e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=77dc3ad810d4887d1148d2b0d8e7807ecadaea3e", "patch": "@@ -114,8 +114,8 @@ pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n pub struct MatcherPos {\n     elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n     sep: Option<Token>,\n-    mut idx: uint,\n-    mut up: matcher_pos_up, // mutable for swapping only\n+    idx: uint,\n+    up: matcher_pos_up, // mutable for swapping only\n     matches: ~[DVec<@named_match>],\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n@@ -155,8 +155,8 @@ pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n-        mut idx: 0u,\n-        mut up: matcher_pos_up(None),\n+        idx: 0u,\n+        up: matcher_pos_up(None),\n         matches: copy vec::from_fn(count_names(ms), |_i| dvec::DVec()),\n         match_lo: 0u,\n         match_hi: match_idx_hi,\n@@ -267,7 +267,7 @@ pub fn parse(sess: @mut ParseSess,\n                     if idx == len {\n                         // pop from the matcher position\n \n-                        let new_pos = copy_up(ei.up);\n+                        let mut new_pos = copy_up(ei.up);\n \n                         // update matches (the MBE \"parse tree\") by appending\n                         // each tree as a subtree.\n@@ -295,13 +295,13 @@ pub fn parse(sess: @mut ParseSess,\n                     match copy ei.sep {\n                       Some(ref t) if idx == len => { // we need a separator\n                         if tok == (*t) { //pass the separator\n-                            let ei_t = ei;\n+                            let mut ei_t = ei;\n                             ei_t.idx += 1;\n                             next_eis.push(ei_t);\n                         }\n                       }\n                       _ => { // we don't need a separator\n-                        let ei_t = ei;\n+                        let mut ei_t = ei;\n                         ei_t.idx = 0;\n                         cur_eis.push(ei_t);\n                       }\n@@ -315,7 +315,7 @@ pub fn parse(sess: @mut ParseSess,\n                   match_seq(ref matchers, ref sep, zero_ok,\n                             match_idx_lo, match_idx_hi) => {\n                     if zero_ok {\n-                        let new_ei = copy ei;\n+                        let mut new_ei = copy ei;\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for uint::range(match_idx_lo, match_idx_hi) |idx| {\n@@ -331,16 +331,16 @@ pub fn parse(sess: @mut ParseSess,\n                     cur_eis.push(~MatcherPos {\n                         elts: (*matchers),\n                         sep: (*sep),\n-                        mut idx: 0u,\n-                        mut up: matcher_pos_up(Some(ei_t)),\n+                        idx: 0u,\n+                        up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n                   match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n                   match_tok(ref t) => {\n-                    let ei_t = ei;\n+                    let mut ei_t = ei;\n                     if (*t) == tok {\n                         ei_t.idx += 1;\n                         next_eis.push(ei_t);\n@@ -388,7 +388,7 @@ pub fn parse(sess: @mut ParseSess,\n             } else /* bb_eis.len() == 1 */ {\n                 let rust_parser = Parser(sess, cfg, rdr.dup());\n \n-                let ei = bb_eis.pop();\n+                let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal("}]}