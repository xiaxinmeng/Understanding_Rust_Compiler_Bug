{"sha": "c817e6e4b3bc2879b08390fb2f5a421467397910", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MTdlNmU0YjNiYzI4NzliMDgzOTBmYjJmNWE0MjE0NjczOTc5MTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-05-31T06:24:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-31T06:24:15Z"}, "message": "Merge pull request #171 from RalfJung/println\n\nWork with MIR-libstd", "tree": {"sha": "d6a6783536f0aa29896f65d9b48e04acf1c9b509", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6a6783536f0aa29896f65d9b48e04acf1c9b509"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c817e6e4b3bc2879b08390fb2f5a421467397910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c817e6e4b3bc2879b08390fb2f5a421467397910", "html_url": "https://github.com/rust-lang/rust/commit/c817e6e4b3bc2879b08390fb2f5a421467397910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c817e6e4b3bc2879b08390fb2f5a421467397910/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53412abe76b5f53a66df68279bd3bb38b07521c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/53412abe76b5f53a66df68279bd3bb38b07521c5", "html_url": "https://github.com/rust-lang/rust/commit/53412abe76b5f53a66df68279bd3bb38b07521c5"}, {"sha": "d06c1653689d255bb66f0f778f870067f66b51e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d06c1653689d255bb66f0f778f870067f66b51e8", "html_url": "https://github.com/rust-lang/rust/commit/d06c1653689d255bb66f0f778f870067f66b51e8"}], "stats": {"total": 712, "additions": 580, "deletions": 132}, "files": [{"sha": "fa3fea79e940794377812831752046d8b0325b6d", "filename": "README.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -54,6 +54,29 @@ Then, inside your own project, use `cargo +nightly miri` to run your project, if\n a bin project, or run `cargo +nightly miri test` to run all tests in your project\n through miri.\n \n+## Running miri with full libstd\n+\n+Per default libstd does not contain the MIR of non-polymorphic functions.  When\n+miri hits a call to such a function, execution terminates.  To fix this, it is\n+possible to compile libstd with full MIR:\n+\n+```sh\n+rustup component add rust-src\n+chmod +x -R ~/.rustup/toolchains/*/lib/rustlib/src/rust/src/jemalloc/include/jemalloc/\n+cargo install xargo\n+cd xargo/\n+RUSTFLAGS='-Zalways-encode-mir' xargo build\n+```\n+\n+Now you can run miri against the libstd compiled by xargo:\n+\n+```sh\n+cargo run --bin miri -- --sysroot ~/.xargo/HOST tests/run-pass/vecs.rs\n+```\n+\n+Notice that you will have to re-run the last step of the preparations above when\n+your toolchain changes (e.g., when you update the nightly).\n+\n ## Contributing and getting help\n \n Check out the issues on this GitHub repository for some ideas. There's lots that"}, {"sha": "3af3bee3c8badae69c68bf3095b5c74dc9f9f424", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -84,7 +84,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n                     if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n                         let did = self.1.hir.body_owner_def_id(body_id);\n                         println!(\"running test: {}\", self.1.hir.def_path(did).to_string(self.1));\n-                        miri::eval_main(self.1, did, self.0);\n+                        miri::eval_main(self.1, did, None, self.0);\n                         self.2.session.abort_if_errors();\n                     }\n                 }\n@@ -95,7 +95,9 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n     } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        miri::eval_main(tcx, entry_def_id, limits);\n+        let start_wrapper = tcx.lang_items.start_fn().and_then(|start_fn|\n+                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n+        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n \n         state.session.abort_if_errors();\n     } else {"}, {"sha": "7b6542bff93456372441ca72657a0736514f9efa", "filename": "src/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -38,6 +38,9 @@ pub enum EvalError<'tcx> {\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n+    OutOfTls,\n+    TlsOutOfBounds,\n+    AbiViolation(String),\n     AlignmentCheckFailed {\n         required: u64,\n         has: u64,\n@@ -101,6 +104,11 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the configured maximum execution time\",\n             EvalError::StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n+            EvalError::OutOfTls =>\n+                \"reached the maximum number of representable TLS keys\",\n+            EvalError::TlsOutOfBounds =>\n+                \"accessed an invalid (unallocated) TLS key\",\n+            EvalError::AbiViolation(ref msg) => msg,\n             EvalError::AlignmentCheckFailed{..} =>\n                 \"tried to execute a misaligned read or write\",\n             EvalError::CalledClosureAsFunction =>"}, {"sha": "922a36c892ae5bc24f3684fc893dc08c4b218a4d", "filename": "src/eval_context.rs", "status": "modified", "additions": 99, "deletions": 46, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -126,6 +126,7 @@ impl Default for ResourceLimits {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+        // Register array drop glue code\n         let source_info = mir::SourceInfo {\n             span: DUMMY_SP,\n             scope: mir::ARGUMENT_VISIBILITY_SCOPE\n@@ -852,7 +853,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let fn_ptr = self.memory.create_fn_alloc(instance);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n-                        ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                        ref other => bug!(\"closure fn pointer on {:?}\", other),\n                     },\n                 }\n             }\n@@ -1557,6 +1558,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+        // Debug output\n         if let Lvalue::Local { frame, local, field } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n@@ -1676,62 +1678,113 @@ impl<'tcx> Frame<'tcx> {\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n     limits: ResourceLimits,\n ) {\n-    let mut ecx = EvalContext::new(tcx, limits);\n-    let instance = ty::Instance::mono(tcx, def_id);\n-    let mir = ecx.load_mir(instance.def).expect(\"main function's MIR not found\");\n-\n-    if !mir.return_ty.is_nil() || mir.arg_count != 0 {\n-        let msg = \"miri does not support main functions without `fn()` type signatures\";\n-        tcx.sess.err(&EvalError::Unimplemented(String::from(msg)).to_string());\n-        return;\n-    }\n-\n-    ecx.push_stack_frame(\n-        instance,\n-        DUMMY_SP,\n-        mir,\n-        Lvalue::from_ptr(Pointer::zst_ptr()),\n-        StackPopCleanup::None,\n-    ).expect(\"could not allocate first stack frame\");\n-\n-    loop {\n-        match ecx.step() {\n-            Ok(true) => {}\n-            Ok(false) => {\n-                let leaks = ecx.memory.leak_report();\n-                if leaks != 0 {\n-                    tcx.sess.err(\"the evaluated program leaked memory\");\n-                }\n-                return;\n+    fn run_main<'a, 'tcx: 'a>(\n+        ecx: &mut EvalContext<'a, 'tcx>,\n+        main_id: DefId,\n+        start_wrapper: Option<DefId>,\n+    ) -> EvalResult<'tcx> {\n+        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n+        let main_mir = ecx.load_mir(main_instance.def)?;\n+        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n+\n+        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n+            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+        }\n+\n+        if let Some(start_id) = start_wrapper {\n+            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n+            let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+            if start_mir.arg_count != 3 {\n+                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n             }\n-            Err(e) => {\n-                report(tcx, &ecx, e);\n-                return;\n+\n+            // Return value\n+            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi())?;\n+            cleanup_ptr = Some(ret_ptr);\n+\n+            // Push our stack frame\n+            ecx.push_stack_frame(\n+                start_instance,\n+                start_mir.span,\n+                start_mir,\n+                Lvalue::from_ptr(ret_ptr),\n+                StackPopCleanup::None,\n+            )?;\n+\n+            let mut args = ecx.frame().mir.args_iter();\n+\n+            // First argument: pointer to main()\n+            let main_ptr = ecx.memory.create_fn_alloc(main_instance);\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let main_ty = main_instance.def.def_ty(ecx.tcx);\n+            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig());\n+            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n+\n+            // Second argument (argc): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.types.isize;\n+            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+\n+            // Third argument (argv): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+        } else {\n+            ecx.push_stack_frame(\n+                main_instance,\n+                main_mir.span,\n+                main_mir,\n+                Lvalue::from_ptr(Pointer::zst_ptr()),\n+                StackPopCleanup::None,\n+            )?;\n+        }\n+\n+        while ecx.step()? {}\n+        if let Some(cleanup_ptr) = cleanup_ptr {\n+            ecx.memory.deallocate(cleanup_ptr)?;\n+        }\n+        return Ok(());\n+    }\n+\n+    let mut ecx = EvalContext::new(tcx, limits);\n+    match run_main(&mut ecx, main_id, start_wrapper) {\n+        Ok(()) => {\n+            let leaks = ecx.memory.leak_report();\n+            if leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n             }\n         }\n+        Err(e) => {\n+            report(tcx, &ecx, e);\n+        }\n     }\n }\n \n fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n-    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n-    let block = &frame.mir.basic_blocks()[frame.block];\n-    let span = if frame.stmt < block.statements.len() {\n-        block.statements[frame.stmt].source_info.span\n-    } else {\n-        block.terminator().source_info.span\n-    };\n-    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n-        if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n-            err.span_note(span, \"inside call to closure\");\n-            continue;\n+    if let Some(frame) = ecx.stack().last() {\n+        let block = &frame.mir.basic_blocks()[frame.block];\n+        let span = if frame.stmt < block.statements.len() {\n+            block.statements[frame.stmt].source_info.span\n+        } else {\n+            block.terminator().source_info.span\n+        };\n+        let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n+        for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n+            if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                err.span_note(span, \"inside call to closure\");\n+                continue;\n+            }\n+            err.span_note(span, &format!(\"inside call to {}\", instance));\n         }\n-        err.span_note(span, &format!(\"inside call to {}\", instance));\n+        err.emit();\n+    } else {\n+        tcx.sess.err(&e.to_string());\n     }\n-    err.emit();\n }\n \n // TODO(solson): Upstream these methods into rustc::ty::layout."}, {"sha": "cad4ca9d0290b0e2e1b0547aa0abcb838ea49f84", "filename": "src/lvalue.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -104,6 +104,15 @@ impl<'tcx> Global<'tcx> {\n             initialized: false,\n         }\n     }\n+\n+    pub(super) fn initialized(ty: Ty<'tcx>, value: Value, mutable: bool) -> Self {\n+        Global {\n+            value,\n+            mutable,\n+            ty,\n+            initialized: true,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {"}, {"sha": "bfdc45c921d133e6b7c9a784070c957368149ce3", "filename": "src/memory.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -98,6 +98,18 @@ impl Pointer {\n     pub fn never_ptr() -> Self {\n         Pointer::new(NEVER_ALLOC_ID, 0)\n     }\n+    \n+    pub fn is_null_ptr(&self) -> bool {\n+        return *self == Pointer::from_int(0)\n+    }\n+}\n+\n+pub type TlsKey = usize;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct TlsEntry<'tcx> {\n+    data: Pointer, // will eventually become a map from thread IDs to pointers\n+    dtor: Option<ty::Instance<'tcx>>,\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -149,6 +161,12 @@ pub struct Memory<'a, 'tcx> {\n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n+    \n+    /// pthreads-style Thread-local storage.  We only have one thread, so this is just a map from TLS keys (indices into the vector) to the pointer stored there.\n+    thread_local: HashMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// The Key to use for the next thread-local allocation.\n+    next_thread_local: TlsKey,\n }\n \n const ZST_ALLOC_ID: AllocId = AllocId(0);\n@@ -167,6 +185,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             packed: BTreeSet::new(),\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n+            thread_local: HashMap::new(),\n+            next_thread_local: 0,\n         }\n     }\n \n@@ -345,6 +365,59 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn clear_packed(&mut self) {\n         self.packed.clear();\n     }\n+\n+    pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n+        let new_key = self.next_thread_local;\n+        self.next_thread_local += 1;\n+        self.thread_local.insert(new_key, TlsEntry { data: Pointer::from_int(0), dtor });\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n+        return new_key;\n+    }\n+\n+    pub(crate) fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        return match self.thread_local.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+        return match self.thread_local.get(&key) {\n+            Some(&TlsEntry { data, .. }) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, data);\n+                Ok(data)\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+        return match self.thread_local.get_mut(&key) {\n+            Some(&mut TlsEntry { ref mut data, .. }) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n+                *data = new_data;\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+    \n+    // Returns a dtor and its argument, if one is supposed to run\n+    pub(crate) fn fetch_tls_dtor(&mut self) -> Option<(ty::Instance<'tcx>, Pointer)> {\n+        for (_, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.iter_mut() {\n+            if !data.is_null_ptr() {\n+                if let Some(dtor) = dtor {\n+                    let old_data = *data;\n+                    *data = Pointer::from_int(0);\n+                    return Some((dtor, old_data));\n+                }\n+            }\n+        }\n+        return None;\n+    }\n }\n \n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same"}, {"sha": "cbd9871e83fa39442bf614dd896d027f6e2676bd", "filename": "src/step.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -13,6 +13,7 @@ use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n+use memory::Pointer;\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -31,6 +32,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.clear_packed();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n+            if let Some((instance, ptr)) = self.memory.fetch_tls_dtor() {\n+                trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+                // TODO: Potientially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+                let mir = self.load_mir(instance.def)?;\n+                self.push_stack_frame(\n+                    instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::from_ptr(Pointer::zst_ptr()),\n+                    StackPopCleanup::None,\n+                )?;\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                self.write_value(Value::ByVal(PrimVal::Ptr(ptr)), dest, ty)?;\n+                return Ok(true);\n+            }\n             return Ok(false);\n         }\n \n@@ -48,11 +66,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 mir,\n                 new_constants: &mut new,\n             }.visit_statement(block, stmt, mir::Location { block, statement_index: stmt_id });\n+            // if ConstantExtractor added new frames, we don't execute anything here\n+            // but await the next call to step\n             if new? == 0 {\n                 self.statement(stmt)?;\n             }\n-            // if ConstantExtractor added new frames, we don't execute anything here\n-            // but await the next call to step\n             return Ok(true);\n         }\n \n@@ -65,11 +83,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir,\n             new_constants: &mut new,\n         }.visit_terminator(block, terminator, mir::Location { block, statement_index: stmt_id });\n+        // if ConstantExtractor added new frames, we don't execute anything here\n+        // but await the next call to step\n         if new? == 0 {\n             self.terminator(terminator)?;\n         }\n-        // if ConstantExtractor added new frames, we don't execute anything here\n-        // but await the next call to step\n         Ok(true)\n     }\n \n@@ -158,6 +176,11 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         if self.ecx.globals.contains_key(&cid) {\n             return;\n         }\n+        if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n+            trace!(\"Initializing an extern global with NULL\");\n+            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Ptr(Pointer::from_int(0))), !shared));\n+            return;\n+        }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(instance.def)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n@@ -178,6 +201,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             )\n         });\n     }\n+\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx>>(&mut self, f: F) {\n         if let Ok(ref mut n) = *self.new_constants {\n             *n += 1;"}, {"sha": "81927ba32996bde8e7ee0dfdd1ca709f33b3a30d", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 262, "deletions": 63, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, TypeVariants, Ty, TypeAndMut};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::attr;\n@@ -9,7 +9,7 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::Pointer;\n+use memory::{Pointer, TlsKey};\n use value::PrimVal;\n use value::Value;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -72,15 +72,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             ty::TyFnDef(_, _, real_sig) => {\n                                 let sig = self.erase_lifetimes(&sig);\n                                 let real_sig = self.erase_lifetimes(&real_sig);\n-                                match instance.def {\n-                                    // FIXME: this needs checks for weird transmutes\n-                                    // we need to bail here, because noncapturing closures as fn ptrs fail the checks\n-                                    ty::InstanceDef::ClosureOnceShim{..} => {}\n-                                    _ => if sig.abi != real_sig.abi ||\n-                                        sig.variadic != real_sig.variadic ||\n-                                        sig.inputs_and_output != real_sig.inputs_and_output {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n-                                    },\n+                                if !self.check_sig_compat(sig, real_sig)? {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n                             },\n                             ref other => bug!(\"instance def ty: {:?}\", other),\n@@ -138,6 +131,70 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`.\n+    /// FIXME: This should take into account the platform-dependent ABI description.\n+    fn check_sig_compat(\n+        &mut self,\n+        sig: ty::FnSig<'tcx>,\n+        real_sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        fn check_ty_compat<'tcx>(\n+            ty: ty::Ty<'tcx>,\n+            real_ty: ty::Ty<'tcx>,\n+        ) -> bool {\n+            if ty == real_ty { return true; } // This is actually a fast pointer comparison\n+            return match (&ty.sty, &real_ty.sty) {\n+                // Permit changing the pointer type of raw pointers and references as well as\n+                // mutability of raw pointers.\n+                // TODO: Should not be allowed when fat pointers are involved.\n+                (&TypeVariants::TyRawPtr(_), &TypeVariants::TyRawPtr(_)) => true,\n+                (&TypeVariants::TyRef(_, _), &TypeVariants::TyRef(_, _)) =>\n+                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer(),\n+                // rule out everything else\n+                _ => false\n+            }\n+        }\n+\n+        if sig.abi == real_sig.abi &&\n+            sig.variadic == real_sig.variadic &&\n+            sig.inputs_and_output.len() == real_sig.inputs_and_output.len() &&\n+            sig.inputs_and_output.iter().zip(real_sig.inputs_and_output).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+            // Definitely good.\n+            return Ok(true);\n+        }\n+\n+        if sig.variadic || real_sig.variadic {\n+            // We're not touching this\n+            return Ok(false);\n+        }\n+\n+        // We need to allow what comes up when a non-capturing closure is cast to a fn().\n+        match (sig.abi, real_sig.abi) {\n+            (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n+                if check_ty_compat(sig.output(), real_sig.output()) && real_sig.inputs_and_output.len() == 3 => {\n+                // First argument of real_sig must be a ZST\n+                let fst_ty = real_sig.inputs_and_output[0];\n+                let layout = self.type_layout(fst_ty)?;\n+                let size = layout.size(&self.tcx.data_layout).bytes();\n+                if size == 0 {\n+                    // Second argument must be a tuple matching the argument list of sig\n+                    let snd_ty = real_sig.inputs_and_output[1];\n+                    match snd_ty.sty {\n+                        TypeVariants::TyTuple(tys, _) if sig.inputs().len() == tys.len() =>\n+                            if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+                                return Ok(true)\n+                            },\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        };\n+\n+        // Nope, this doesn't work.\n+        return Ok(false);\n+    }\n+\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -172,7 +229,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n@@ -202,44 +261,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(())\n             }\n             ty::InstanceDef::Item(_) => {\n-                match sig.abi {\n-                    Abi::C => {\n-                        let ty = sig.output();\n-                        let (ret, target) = destination.unwrap();\n-                        self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n-                        self.dump_local(ret);\n-                        self.goto_block(target);\n-                        return Ok(());\n-                    },\n-                    Abi::Rust | Abi::RustCall => {},\n-                    _ => unimplemented!(),\n-                }\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n \n+                // Push the stack frame, and potentially be entirely done if the call got hooked\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n \n+                // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n                 trace!(\"arg_operands: {:?}\", arg_operands);\n                 match sig.abi {\n-                    Abi::Rust => {\n-                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                            self.write_value(arg_val, dest, arg_ty)?;\n-                        }\n-                    }\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);\n \n@@ -282,8 +327,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         } else {\n                             bug!(\"rust-call ABI tuple argument was {:?}, {:?}\", arg_ty, layout);\n                         }\n+                    },\n+                    _ => {\n+                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n                     }\n-                    _ => unimplemented!(),\n                 }\n                 Ok(())\n             },\n@@ -314,7 +364,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n@@ -361,7 +413,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n+        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", instance, destination);\n \n@@ -370,28 +424,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n-                match &path[..] {\n-                    // let's just ignore all output for now\n-                    \"std::io::_print\" => {\n-                        self.goto_block(destination.unwrap().1);\n-                        return Ok(true);\n-                    },\n-                    \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-                    \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-                    \"std::panicking::rust_panic_with_hook\" |\n-                    \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-                    \"std::panicking::panicking\" |\n-                    \"std::rt::panicking\" => {\n-                        let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n-                        // we abort on panic -> `std::rt::panicking` always returns false\n-                        let bool = self.tcx.types.bool;\n-                        self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                        self.goto_block(block);\n-                        return Ok(true);\n-                    }\n-                    _ => {},\n-                }\n-                return Err(EvalError::NoMirFor(path));\n+                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+                return Ok(true);\n             },\n             Err(other) => return Err(other),\n         };\n@@ -464,21 +498,64 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         assert!(nndiscr == 0 || nndiscr == 1);\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n+    \n+    /// Returns Ok() when the function was handled, fail otherwise\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            let ty = sig.output();\n+            let (ret, target) = destination.unwrap();\n+            self.call_c_abi(instance.def_id(), arg_operands, ret, ty, target)?;\n+            return Ok(());\n+        }\n+    \n+        // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+        // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+        match &path[..] {\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+                self.goto_block(destination.unwrap().1);\n+                Ok(())\n+            },\n+            \"std::thread::Builder::new\" => Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => Err(EvalError::Panic),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n+                self.goto_block(block);\n+                Ok(())\n+            }\n+            _ => Err(EvalError::NoMirFor(path)),\n+        }\n+    }\n \n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n-        args: &[mir::Operand<'tcx>],\n+        arg_operands: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n             .unwrap_or(name)\n             .as_str();\n \n-        let args_res: EvalResult<Vec<Value>> = args.iter()\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n@@ -517,6 +594,41 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n+            \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                let f = args[0].read_ptr(&self.memory)?;\n+                let data = args[1].read_ptr(&self.memory)?;\n+                let f_instance = self.memory.get_fn(f.alloc_id)?;\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n+                let mir = self.load_mir(f_instance.def)?;\n+                self.push_stack_frame(\n+                    f_instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::from_ptr(Pointer::zst_ptr()),\n+                    StackPopCleanup::Goto(dest_block),\n+                )?;\n+\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_value(Value::ByVal(PrimVal::Ptr(data)), arg_dest, u8_ptr_ty)?;\n+\n+                // We ourselbes return 0\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+\n+                // Don't fall through\n+                return Ok(());\n+            }\n+\n+            \"__rust_start_panic\" => {\n+                return Err(EvalError::Panic);\n+            }\n+\n             \"memcmp\" => {\n                 let left = args[0].read_ptr(&self.memory)?;\n                 let right = args[1].read_ptr(&self.memory)?;\n@@ -543,9 +655,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1);\n-                    self.write_value(Value::ByVal(PrimVal::Ptr(new_ptr)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n-                    self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n@@ -555,9 +667,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64);\n-                    self.write_value(Value::ByVal(PrimVal::Ptr(new_ptr)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n-                    self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n@@ -567,17 +679,102 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     info!(\"ignored env var request for `{:?}`\", ::std::str::from_utf8(name));\n                 }\n-                self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            \"write\" => {\n+                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let buf = args[1].read_ptr(&self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n+                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                    use std::io::{self, Write};\n+                \n+                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n+                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                } else {\n+                    info!(\"Ignored output to FD {}\", fd);\n+                    n as isize // pretend it all went well\n+                }; // now result is the value we return back to the program\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n             }\n \n-            // unix panic code inside libstd will read the return value of this function\n-            \"pthread_rwlock_rdlock\" => {\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n \n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                let result = match name {\n+                    30 => 4096, // _SC_PAGESIZE\n+                    _ => return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)))\n+                };\n+                self.write_primval(dest, PrimVal::Bytes(result), dest_ty)?;\n+            }\n+\n+            \"mmap\" => {\n+                // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n+                let addr = args[0].read_ptr(&self.memory)?;\n+                self.write_primval(dest, PrimVal::Ptr(addr), dest_ty)?;\n+            }\n+\n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key_ptr = args[0].read_ptr(&self.memory)?;\n+                \n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                let dtor_ptr = args[1].read_ptr(&self.memory)?;\n+                let dtor = if dtor_ptr.is_null_ptr() { None } else { Some(self.memory.get_fn(dtor_ptr.alloc_id)?) };\n+                \n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_size = match self.operand_ty(&arg_operands[0]).sty {\n+                    TypeVariants::TyRawPtr(TypeAndMut { ty, .. }) => {\n+                        let layout = self.type_layout(ty)?;\n+                        layout.size(&self.tcx.data_layout)\n+                    }\n+                    _ => return Err(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))\n+                };\n+                \n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor);\n+                if key >= (1 << key_size.bits()) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                self.memory.write_int(key_ptr, key as i128, key_size.bytes())?;\n+                \n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].read_ptr(&self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            // Stub out all the other pthread calls to just return 0\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 warn!(\"ignoring C ABI call: {}\", link_name);\n-                return Ok(());\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             },\n \n             _ => {\n@@ -588,6 +785,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // Since we pushed no stack frame, the main loop will act\n         // as if the call just completed and it's returning to the\n         // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n         Ok(())\n-    }   \n+    }\n }"}, {"sha": "5d902e1f9aaaf811f7729293bda0f9b1c69459dd", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_ : (i32,i32)) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n+    };\n+\n+    g(42) //~ ERROR tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n+}"}, {"sha": "fe17e0a7b48973f1cd8bf4e615c04041edb0eb59", "filename": "tests/compile-fail/env_args.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53412abe76b5f53a66df68279bd3bb38b07521c5/tests%2Fcompile-fail%2Fenv_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53412abe76b5f53a66df68279bd3bb38b07521c5/tests%2Fcompile-fail%2Fenv_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenv_args.rs?ref=53412abe76b5f53a66df68279bd3bb38b07521c5", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let x = std::env::args(); //~ ERROR miri does not support program arguments\n-    assert_eq!(x.count(), 1);\n-}"}, {"sha": "d4aebb912ee1707ef795f555cfa88497b1ff82e9", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute, attr_literals)]\n-#![miri(memory_size=0)]\n+#![miri(memory_size=4095)]\n \n fn main() {\n-    let _x = [42; 10];\n-    //~^ERROR tried to allocate 40 more bytes, but only 0 bytes are free of the 0 byte memory\n+    let _x = [42; 1024];\n+    //~^ERROR tried to allocate 4096 more bytes, but only\n }"}, {"sha": "1a4a47efe68584f9cc9c71f5aa0fd64f7b371c3b", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -1,5 +1,5 @@\n #![feature(box_syntax, custom_attribute, attr_literals)]\n-#![miri(memory_size=1000)]\n+#![miri(memory_size=2048)]\n \n fn main() {\n     loop {"}, {"sha": "4b61e12d602fcb069abec34ab93688fa8aba57ff", "filename": "tests/compile-fail/stack_limit.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Fstack_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Fcompile-fail%2Fstack_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_limit.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -1,5 +1,5 @@\n #![feature(custom_attribute, attr_literals)]\n-#![miri(stack_limit=2)]\n+#![miri(stack_limit=16)]\n \n fn bar() {\n     foo();\n@@ -10,10 +10,16 @@ fn foo() {\n }\n \n fn cake() {\n-    flubber();\n+    flubber(3);\n }\n \n-fn flubber() {}\n+fn flubber(i: u32) {\n+    if i > 0 {\n+        flubber(i-1);\n+    } else {\n+        bar();\n+    }\n+}\n \n fn main() {\n     bar();"}, {"sha": "109e8dfc2a02be11da01cf14bd84ca0ccd6f9842", "filename": "tests/run-pass/cast_fn_ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast_fn_ptr.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_: *const u8) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(*const u8), fn(*const i32)>(f)\n+    };\n+\n+    g(&42 as *const _);\n+}"}, {"sha": "439edc82dde259a1281baa1b4754740fb9f9fd25", "filename": "tests/run-pass/catch.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcatch.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,9 @@\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+fn main() {\n+    let mut i = 3;\n+    let _ = catch_unwind(AssertUnwindSafe(|| {i -= 2;} ));\n+    for _ in 0..i {\n+        println!(\"I\");\n+    }\n+}"}, {"sha": "78729b915613af908634833702f458b9e3fe2521", "filename": "tests/run-pass/format.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fformat.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"Hello {}\", 13);\n+}"}, {"sha": "e7a11a969c037e00a796aafeff6258501ec15e9a", "filename": "tests/run-pass/hello.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhello.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "8c69be8e2cd791c2ff83455f42aded17b593858e", "filename": "tests/run-pass/thread-local-no-dtor.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fthread-local-no-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fthread-local-no-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local-no-dtor.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,16 @@\n+#![feature(libc)]\n+extern crate libc;\n+\n+use std::mem;\n+\n+pub type Key = libc::pthread_key_t;\n+\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    let mut key = 0;\n+    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n+    key\n+}\n+\n+fn main() {\n+    let _ = unsafe { create(None) };\n+}"}, {"sha": "06e41e59e60231a4940c789aadc81b12bfcb0918", "filename": "tests/run-pass/zst.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -1,9 +1,3 @@\n-// the following flag prevents this test from running on the host machine\n-// this should only be run on miri, because rust doesn't (yet?) optimize ZSTs of different types\n-// into the same memory location\n-// ignore-test\n-\n-\n #[derive(PartialEq, Debug)]\n struct A;\n "}, {"sha": "031ad9a8795491b7e05f2290d3063fa31ab808df", "filename": "xargo/Cargo.lock", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FCargo.lock?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,4 @@\n+[root]\n+name = \"miri-xargo\"\n+version = \"0.0.0\"\n+"}, {"sha": "9129c105b112bb1b3dd597b118e2ac13466b505b", "filename": "xargo/Cargo.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FCargo.toml?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,6 @@\n+[package]\n+name = \"miri-xargo\"\n+description = \"A dummy project for building libstd with xargo.\"\n+version = \"0.0.0\"\n+\n+[dependencies]"}, {"sha": "32f45c4a9816ff58cf8bb929f7edc6c0687a3bd5", "filename": "xargo/Xargo.toml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FXargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2FXargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FXargo.toml?ref=c817e6e4b3bc2879b08390fb2f5a421467397910", "patch": "@@ -0,0 +1,2 @@\n+[dependencies]\n+std = {features = [\"panic_unwind\", \"jemalloc\"]}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "xargo/src/lib.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c817e6e4b3bc2879b08390fb2f5a421467397910/xargo%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2Fsrc%2Flib.rs?ref=c817e6e4b3bc2879b08390fb2f5a421467397910"}]}