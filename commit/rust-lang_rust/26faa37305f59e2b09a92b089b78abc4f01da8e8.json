{"sha": "26faa37305f59e2b09a92b089b78abc4f01da8e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZmFhMzczMDVmNTllMmIwOWE5MmIwODliNzhhYmM0ZjAxZGE4ZTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T04:53:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-08T04:53:47Z"}, "message": "syntax: Add a lot of copy keywords", "tree": {"sha": "68f2618785f4b7fbe324f4ae9839e3c57b2fedd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f2618785f4b7fbe324f4ae9839e3c57b2fedd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26faa37305f59e2b09a92b089b78abc4f01da8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26faa37305f59e2b09a92b089b78abc4f01da8e8", "html_url": "https://github.com/rust-lang/rust/commit/26faa37305f59e2b09a92b089b78abc4f01da8e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26faa37305f59e2b09a92b089b78abc4f01da8e8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847c5e4e9892ef56873ac52a552997267c4d385a", "url": "https://api.github.com/repos/rust-lang/rust/commits/847c5e4e9892ef56873ac52a552997267c4d385a", "html_url": "https://github.com/rust-lang/rust/commit/847c5e4e9892ef56873ac52a552997267c4d385a"}], "stats": {"total": 146, "additions": 87, "deletions": 59}, "files": [{"sha": "b2e6446d7ee01961638a33420ba4211558347a3d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -123,7 +123,7 @@ fn map_decoded_item(diag: span_handler,\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for decl.inputs.each {|a|\n-        cx.map.insert(a.id, node_arg(a, cx.local_id));\n+        cx.map.insert(a.id, node_arg(/* FIXME: bad */ copy a, cx.local_id));\n         cx.local_id += 1u;\n     }\n     alt fk {\n@@ -133,13 +133,17 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                             dec: /* FIXME: bad */ copy decl,\n                             body: /* FIXME: bad */ copy body},\n                     span: sp};\n-          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm, tps,\n-                                      class_ctor(ct, parent_id), @cx.path));\n+          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm,\n+                                      /* FIXME: bad */ copy tps,\n+                                      class_ctor(ct, parent_id),\n+                                      @/* FIXME: bad */ copy cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n-          let dt = @{node: {id: id, self_id: self_id, body: body},\n-                    span: sp};\n-          cx.map.insert(id, node_dtor(tps, dt, parent_id, @cx.path));\n+          let dt = @{node: {id: id, self_id: self_id,\n+                     body: /* FIXME: bad */ copy body}, span: sp};\n+          cx.map.insert(id, node_dtor(/* FIXME: bad */ copy tps, dt,\n+                                      parent_id,\n+                                      @/* FIXME: bad */ copy cx.path));\n        }\n \n        _ {}\n@@ -148,7 +152,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn map_block(b: blk, cx: ctx, v: vt) {\n-    cx.map.insert(b.node.id, node_block(b));\n+    cx.map.insert(b.node.id, node_block(/* FIXME: bad */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -182,25 +186,29 @@ fn map_method(impl_did: def_id, impl_path: @path,\n }\n \n fn map_item(i: @item, cx: ctx, v: vt) {\n-    let item_path = @cx.path;\n+    let item_path = @/* FIXME: bad */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n       item_impl(_, _, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each {|m|\n-            map_method(impl_did, extend(cx, i.ident), m, cx);\n+            map_method(impl_did, extend(cx, /* FIXME: bad */ copy i.ident), m,\n+                       cx);\n         }\n       }\n       item_res(decl, tps, _, dtor_id, ctor_id, _) {\n-        cx.map.insert(ctor_id, node_ctor(i.ident, tps,\n-                                         res_ctor(decl, ctor_id, i.span),\n+        cx.map.insert(ctor_id, node_ctor(/* FIXME: bad */ copy i.ident,\n+                                         /* FIXME: bad */ copy tps,\n+                                         res_ctor(/* FIXME: bad */ copy decl,\n+                                                  ctor_id, i.span),\n                                          item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n-                v, i, extend(cx, i.ident)));\n+                /* FIXME: bad */ copy v, i,\n+                extend(cx, /* FIXME: bad */ copy i.ident)));\n         }\n       }\n       item_native_mod(nm) {\n@@ -209,7 +217,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           either::right(abi) { abi }\n         };\n         for nm.items.each {|nitem|\n-            cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n+            cx.map.insert(nitem.id,\n+                          node_native_item(nitem, abi,\n+                                           @/* FIXME: bad */ copy cx.path));\n         }\n       }\n       item_class(tps, ifces, items, ctor, dtor, _) {\n@@ -219,17 +229,17 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           vec::iter(ifces) {|p| cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n-          let p = extend(cx, i.ident);\n+          let p = extend(cx, /* FIXME: bad */ copy i.ident);\n            // only need to handle methods\n           vec::iter(ms) {|m| map_method(d_id, p, m, cx); }\n       }\n       _ { }\n     }\n     alt i.node {\n       item_mod(_) | item_native_mod(_) {\n-        cx.path += [path_mod(i.ident)];\n+        cx.path += [path_mod(/* FIXME: bad */ copy i.ident)];\n       }\n-      _ { cx.path += [path_name(i.ident)]; }\n+      _ { cx.path += [path_name(/* FIXME: bad */ copy i.ident)]; }\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);\n@@ -240,7 +250,7 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n       view_item_export(vps) {\n         for vps.each {|vp|\n             let (id, name) = alt vp.node {\n-              view_path_simple(nm, _, id) { (id, nm) }\n+              view_path_simple(nm, _, id) { (id, /* FIXME: bad */ copy nm) }\n               view_path_glob(pth, id) | view_path_list(pth, _, id) {\n                 (id, path_to_ident(pth))\n               }"}, {"sha": "af780bc5e383605a006ca521dff7137d0d46ff65", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -51,7 +51,8 @@ fn mk_name_value_item_str(+name: ast::ident, +value: str) -> @ast::meta_item {\n     ret mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(+name: ast::ident, +value: ast::lit) -> @ast::meta_item {\n+fn mk_name_value_item(+name: ast::ident, +value: ast::lit)\n+        -> @ast::meta_item {\n     ret @dummy_spanned(ast::meta_name_value(name, value));\n }\n "}, {"sha": "04a3c95ce1c0e010244331c179666cc4caad18e7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -88,10 +88,11 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, vec::map(mis, fold_meta_item))\n+                  meta_list(/* FIXME: bad */ copy id,\n+                            vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) {\n-                  meta_name_value(fld.fold_ident(id), s)\n+                  meta_name_value(fld.fold_ident(id), /* FIXME: bad */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};\n@@ -121,8 +122,8 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n                mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n                mac_ellipsis { mac_ellipsis }\n-               mac_aq(_,_) { /* fixme */ m.node }\n-               mac_var(_) { /* fixme */ m.node }\n+               mac_aq(_,_) { /* FIXME: bad */ copy m.node }\n+               mac_var(_) { /* FIXME: bad */ copy m.node }\n              },\n          span: fld.new_span(m.span)};\n }\n@@ -143,7 +144,7 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n }\n \n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    {ident: tp.ident,\n+    {ident: /* FIXME: bad */ copy tp.ident,\n      id: fld.new_id(tp.id),\n      bounds: @vec::map(*tp.bounds, fold_ty_param_bound(_, fld))}\n }\n@@ -166,19 +167,20 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     ret alt cd {\n           cdir_src_mod(id, attrs) {\n-            cdir_src_mod(fld.fold_ident(id), attrs)\n+            cdir_src_mod(fld.fold_ident(id), /* FIXME: bad */ copy attrs)\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n-                         vec::map(cds, fld.fold_crate_directive), attrs)\n+                         vec::map(cds, fld.fold_crate_directive),\n+                         /* FIXME: bad */ copy attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n-          cdir_syntax(_) { cd }\n+          cdir_syntax(_) { copy cd }\n         }\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n-    ret vi;\n+    ret /* FIXME: bad */ copy vi;\n }\n \n \n@@ -220,7 +222,8 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n     @{node: alt ci.node {\n         instance_var(ident, t, cm, id, p) {\n-           instance_var(ident, fld.fold_ty(t), cm, id, p)\n+           instance_var(/* FIXME: bad */ copy ident, fld.fold_ty(t), cm, id,\n+                        p)\n         }\n         class_method(m) { class_method(fld.fold_method(m)) }\n       },\n@@ -256,7 +259,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n               item_class(\n-                  typms,\n+                  /* FIXME: bad */ copy typms,\n                   vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n@@ -274,7 +277,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_iface(tps, rp, methods) {\n             item_iface(fold_ty_params(tps, fld),\n                        rp,\n-                       methods)\n+                       /* FIXME: bad */ copy methods)\n           }\n           item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n@@ -293,7 +296,7 @@ fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n-          attrs: m.attrs,\n+          attrs: /* FIXME: bad */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n@@ -328,7 +331,7 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n-          pat_wild { p }\n+          pat_wild { pat_wild }\n           pat_ident(pth, sub) {\n             pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n           }\n@@ -340,7 +343,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_rec(fields, etc) {\n             let mut fs = [];\n             for fields.each {|f|\n-                fs += [{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n+                fs += [{ident: /* FIXME: bad */ copy f.ident,\n+                        pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)\n           }\n@@ -410,7 +414,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_unary(binop, ohs) { expr_unary(binop, fld.fold_expr(ohs)) }\n           expr_loop_body(f) { expr_loop_body(fld.fold_expr(f)) }\n-          expr_lit(_) { e }\n+          expr_lit(_) { copy e }\n           expr_cast(expr, ty) { expr_cast(fld.fold_expr(expr), ty) }\n           expr_addr_of(m, ohs) { expr_addr_of(m, fld.fold_expr(ohs)) }\n           expr_if(cond, tr, fl) {\n@@ -462,7 +466,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n           expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n-          expr_break | expr_cont { e }\n+          expr_break | expr_cont { copy e }\n           expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n                                         fld.fold_expr(e)) }\n@@ -487,7 +491,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n          span: fld.new_span(f.span)}\n     }\n     alt t {\n-      ty_nil | ty_bot {t}\n+      ty_nil | ty_bot | ty_infer {copy t}\n       ty_box(mt) {ty_box(fold_mt(mt, fld))}\n       ty_uniq(mt) {ty_uniq(fold_mt(mt, fld))}\n       ty_vec(mt) {ty_vec(fold_mt(mt, fld))}\n@@ -501,17 +505,18 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n                                 vec::map(constrs, fld.fold_ty_constr))}\n       ty_vstore(t, vs) {ty_vstore(fld.fold_ty(t), vs)}\n       ty_mac(mac) {ty_mac(fold_mac(mac))}\n-      ty_infer {t}\n     }\n }\n \n fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: c.args, id: fld.new_id(c.id)}\n+    {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+     id: fld.new_id(c.id)}\n }\n \n fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n     let rslt: ty_constr_ =\n-        {path: fld.fold_path(c.path), args: c.args, id: fld.new_id(c.id)};\n+        {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+         id: fld.new_id(c.id)};\n     rslt\n }\n // ...nor do modules\n@@ -539,14 +544,16 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       some(e) {some(fld.fold_expr(e))}\n       none {none}\n     };\n-    ret {name: v.name,\n+    ret {name: /* FIXME: bad */ copy v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }\n \n-fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n+fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n+    ret /* FIXME: bad */ copy i;\n+}\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n     ret {span: fld.new_span(p.span), global: p.global,\n@@ -639,8 +646,8 @@ impl of ast_fold for ast_fold_precursor {\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(nm, (self as ast_fold).fold_ty(t),\n-                            mt, id, p)\n+               instance_var(/* FIXME: bad */ copy nm,\n+                            (self as ast_fold).fold_ty(t), mt, id, p)\n            }\n            class_method(m) {\n                class_method(self.fold_method(m, self as ast_fold))"}, {"sha": "c0a2f9b9e6e9a2f724244ea42469aa1515324056", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -209,6 +209,9 @@ impl parser_common for parser {\n         ret v;\n     }\n \n+    // FIXME: A lot of callers go through here, only to copy out the T and\n+    // discard the spanned<> wrapper. I feel as though there should be a\n+    // version of this that does not return a spanned result.\n     fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n                           f: fn(parser) -> T) -> spanned<[T]> {\n         let lo = self.span.lo;\n@@ -218,4 +221,4 @@ impl parser_common for parser {\n         self.bump();\n         ret spanned(lo, hi, result);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "254d5cc5d5d09d626fd6015d698d0e52ab27f816", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -44,7 +44,7 @@ optional suffix then adding the .rs extension.\n fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     -> ([@ast::view_item], [@ast::item], [ast::attribute]) {\n \n-    fn companion_file(prefix: str, suffix: option<str>) -> str {\n+    fn companion_file(+prefix: str, suffix: option<str>) -> str {\n         ret alt suffix {\n           option::some(s) { path::connect(prefix, s) }\n           option::none { prefix }\n@@ -66,8 +66,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n         #debug(\"found companion mod\");\n         let p0 = new_parser_from_file(cx.sess, cx.cfg, modpath, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n-        let first_item_outer_attrs = inner_attrs.next;\n-        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         cx.sess.chpos = p0.reader.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + p0.reader.pos;\n         ret (m0.view_items, m0.items, inner_attrs.inner);\n@@ -102,7 +101,8 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let first_item_outer_attrs = inner_attrs.next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n-        let i = p0.mk_item(cdir.span.lo, cdir.span.hi, id,\n+        let i = p0.mk_item(cdir.span.lo, cdir.span.hi,\n+                           /* FIXME: bad */ copy id,\n                            ast::item_mod(m0), ast::public, mod_attrs);\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = p0.reader.chpos;\n@@ -118,7 +118,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i =\n-            @{ident: id,\n+            @{ident: /* FIXME: bad */ copy id,\n               attrs: attrs + a0,\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),"}, {"sha": "fa0286ded812c566177972c23126e865e4ebe902", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26faa37305f59e2b09a92b089b78abc4f01da8e8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=26faa37305f59e2b09a92b089b78abc4f01da8e8", "patch": "@@ -28,7 +28,7 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n-          | fk_ctor(name, _, _, _) { name }\n+          | fk_ctor(name, _, _, _) { /* FIXME: bad */ copy name }\n       fk_anon(*) | fk_fn_block(*) { \"anon\" }\n       fk_dtor(*)                  { \"drop\" }\n     }\n@@ -37,7 +37,9 @@ fn name_of_fn(fk: fn_kind) -> ident {\n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n-          | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) { tps }\n+              | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n+          /* FIXME: bad */ copy tps\n+      }\n       fk_anon(*) | fk_fn_block(*) { [] }\n     }\n }\n@@ -115,7 +117,9 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) {\n-        v.visit_fn(fk_item_fn(i.ident, tp), decl, body, i.span, i.id, e, v);\n+        v.visit_fn(fk_item_fn(/* FIXME: bad */ copy i.ident,\n+                              /* FIXME: bad */ copy tp), decl, body,\n+                   i.span, i.id, e, v);\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n       item_native_mod(nm) {\n@@ -127,8 +131,10 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n       }\n       item_res(decl, tps, body, dtor_id, _, rp) {\n-        v.visit_fn(fk_res(i.ident, tps, rp), decl, body, i.span,\n-                   dtor_id, e, v);\n+        v.visit_fn(fk_res(/* FIXME: bad */ copy i.ident,\n+                          /* FIXME: bad */ copy tps,\n+                          rp),\n+                   decl, body, i.span, dtor_id, e, v);\n       }\n       item_enum(variants, tps, _) {\n         v.visit_ty_params(tps, e, v);\n@@ -281,22 +287,23 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    v.visit_fn(fk_method(m.ident, m.tps, m), m.decl, m.body, m.span,\n-               m.id, e, v);\n+    v.visit_fn(fk_method(/* FIXME: bad */ copy m.ident,\n+                         /* FIXME: bad */ copy m.tps, m),\n+               m.decl, m.body, m.span, m.id, e, v);\n }\n \n // Similar logic to the comment on visit_method_helper - Tim\n fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_ctor(nm, tps, ctor.node.self_id,\n-                              parent_id), ctor.node.dec,\n+    v.visit_fn(fk_ctor(/* FIXME: bad */ copy nm, /* FIXME: bad */ copy tps,\n+                       ctor.node.self_id, parent_id), ctor.node.dec,\n                ctor.node.body, ctor.span, ctor.node.id, e, v)\n \n }\n \n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_dtor(tps, dtor.node.self_id,\n+    v.visit_fn(fk_dtor(/* FIXME: bad */ copy tps, dtor.node.self_id,\n                        parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n "}]}