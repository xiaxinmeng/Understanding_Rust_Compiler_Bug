{"sha": "e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyOWFhMTQzMGJiNDVkMThhNWQzZmNjNWYzYjdkMjBlOTlhNTc3NTg=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-08-11T17:33:58Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:55Z"}, "message": "move back::link::write into a separate file", "tree": {"sha": "23919f099fbecf92f3cf1f86623d2feb704a1a13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23919f099fbecf92f3cf1f86623d2feb704a1a13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "html_url": "https://github.com/rust-lang/rust/commit/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab27b1d5b68d3bc3c727895e5219ce254c685ad", "html_url": "https://github.com/rust-lang/rust/commit/0ab27b1d5b68d3bc3c727895e5219ce254c685ad"}], "stats": {"total": 1017, "additions": 511, "deletions": 506}, "files": [{"sha": "07fa63336e33ebfbb89e13f9db0ab63825bf9297", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 476, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -13,12 +13,11 @@ use super::archive;\n use super::rpath;\n use super::rpath::RPathConfig;\n use super::svh::Svh;\n+use super::write::{OutputTypeBitcode, OutputTypeExe, OutputTypeObject};\n use driver::driver::{CrateTranslation, OutputFilenames, Input, FileInput};\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use driver::config;\n-use llvm;\n-use llvm::ModuleRef;\n use metadata::common::LinkMeta;\n use metadata::{encoder, cstore, filesearch, csearch, loader, creader};\n use middle::trans::context::CrateContext;\n@@ -28,13 +27,11 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::c_str::{ToCStr, CString};\n use std::char;\n use std::collections::HashSet;\n use std::io::{fs, TempDir, Command};\n use std::io;\n use std::mem;\n-use std::ptr;\n use std::str;\n use std::string::String;\n use flate;\n@@ -77,477 +74,6 @@ pub static RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n-#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n-pub enum OutputType {\n-    OutputTypeBitcode,\n-    OutputTypeAssembly,\n-    OutputTypeLlvmAssembly,\n-    OutputTypeObject,\n-    OutputTypeExe,\n-}\n-\n-pub fn llvm_err(sess: &Session, msg: String) -> ! {\n-    unsafe {\n-        let cstr = llvm::LLVMRustGetLastError();\n-        if cstr == ptr::null() {\n-            sess.fatal(msg.as_slice());\n-        } else {\n-            let err = CString::new(cstr, true);\n-            let err = String::from_utf8_lossy(err.as_bytes());\n-            sess.fatal(format!(\"{}: {}\",\n-                               msg.as_slice(),\n-                               err.as_slice()).as_slice());\n-        }\n-    }\n-}\n-\n-pub fn write_output_file(\n-        sess: &Session,\n-        target: llvm::TargetMachineRef,\n-        pm: llvm::PassManagerRef,\n-        m: ModuleRef,\n-        output: &Path,\n-        file_type: llvm::FileType) {\n-    unsafe {\n-        output.with_c_str(|output| {\n-            let result = llvm::LLVMRustWriteOutputFile(\n-                    target, pm, m, output, file_type);\n-            if !result {\n-                llvm_err(sess, \"could not write output\".to_string());\n-            }\n-        })\n-    }\n-}\n-\n-pub mod write {\n-\n-    use super::super::lto;\n-    use super::{write_output_file, OutputType};\n-    use super::{OutputTypeAssembly, OutputTypeBitcode};\n-    use super::{OutputTypeExe, OutputTypeLlvmAssembly};\n-    use super::{OutputTypeObject};\n-    use driver::driver::{CrateTranslation, OutputFilenames};\n-    use driver::config::NoDebugInfo;\n-    use driver::session::Session;\n-    use driver::config;\n-    use llvm;\n-    use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n-    use util::common::time;\n-    use syntax::abi;\n-\n-    use std::c_str::ToCStr;\n-    use std::io::{Command};\n-    use libc::{c_uint, c_int};\n-    use std::str;\n-\n-    // On android, we by default compile for armv7 processors. This enables\n-    // things like double word CAS instructions (rather than emulating them)\n-    // which are *far* more efficient. This is obviously undesirable in some\n-    // cases, so if any sort of target feature is specified we don't append v7\n-    // to the feature list.\n-    //\n-    // On iOS only armv7 and newer are supported. So it is useful to\n-    // get all hardware potential via VFP3 (hardware floating point)\n-    // and NEON (SIMD) instructions supported by LLVM.\n-    // Note that without those flags various linking errors might\n-    // arise as some of intrinsics are converted into function calls\n-    // and nobody provides implementations those functions\n-    fn target_feature<'a>(sess: &'a Session) -> &'a str {\n-        match sess.targ_cfg.os {\n-            abi::OsAndroid => {\n-                if \"\" == sess.opts.cg.target_feature.as_slice() {\n-                    \"+v7\"\n-                } else {\n-                    sess.opts.cg.target_feature.as_slice()\n-                }\n-            },\n-            abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n-                \"+v7,+thumb2,+vfp3,+neon\"\n-            },\n-            _ => sess.opts.cg.target_feature.as_slice()\n-        }\n-    }\n-\n-    pub fn run_passes(sess: &Session,\n-                      trans: &CrateTranslation,\n-                      output_types: &[OutputType],\n-                      output: &OutputFilenames) {\n-        let llmod = trans.module;\n-        let llcx = trans.context;\n-        unsafe {\n-            configure_llvm(sess);\n-\n-            if sess.opts.cg.save_temps {\n-                output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                })\n-            }\n-\n-            let opt_level = match sess.opts.optimize {\n-              config::No => llvm::CodeGenLevelNone,\n-              config::Less => llvm::CodeGenLevelLess,\n-              config::Default => llvm::CodeGenLevelDefault,\n-              config::Aggressive => llvm::CodeGenLevelAggressive,\n-            };\n-            let use_softfp = sess.opts.cg.soft_float;\n-\n-            // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n-            // FIXME: #11954: mac64 unwinding may not work with fp elim\n-            let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n-                             (sess.targ_cfg.os == abi::OsMacos &&\n-                              sess.targ_cfg.arch == abi::X86_64);\n-\n-            // OSX has -dead_strip, which doesn't rely on ffunction_sections\n-            // FIXME(#13846) this should be enabled for windows\n-            let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n-                                     sess.targ_cfg.os != abi::OsWindows;\n-            let fdata_sections = ffunction_sections;\n-\n-            let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n-                \"pic\" => llvm::RelocPIC,\n-                \"static\" => llvm::RelocStatic,\n-                \"default\" => llvm::RelocDefault,\n-                \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n-                _ => {\n-                    sess.err(format!(\"{} is not a valid relocation mode\",\n-                                     sess.opts\n-                                         .cg\n-                                         .relocation_model).as_slice());\n-                    sess.abort_if_errors();\n-                    return;\n-                }\n-            };\n-\n-            let code_model = match sess.opts.cg.code_model.as_slice() {\n-                \"default\" => llvm::CodeModelDefault,\n-                \"small\" => llvm::CodeModelSmall,\n-                \"kernel\" => llvm::CodeModelKernel,\n-                \"medium\" => llvm::CodeModelMedium,\n-                \"large\" => llvm::CodeModelLarge,\n-                _ => {\n-                    sess.err(format!(\"{} is not a valid code model\",\n-                                     sess.opts\n-                                         .cg\n-                                         .code_model).as_slice());\n-                    sess.abort_if_errors();\n-                    return;\n-                }\n-            };\n-\n-            let tm = sess.targ_cfg\n-                         .target_strs\n-                         .target_triple\n-                         .as_slice()\n-                         .with_c_str(|t| {\n-                sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n-                    target_feature(sess).with_c_str(|features| {\n-                        llvm::LLVMRustCreateTargetMachine(\n-                            t, cpu, features,\n-                            code_model,\n-                            reloc_model,\n-                            opt_level,\n-                            true /* EnableSegstk */,\n-                            use_softfp,\n-                            no_fp_elim,\n-                            ffunction_sections,\n-                            fdata_sections,\n-                        )\n-                    })\n-                })\n-            });\n-\n-            // Create the two optimizing pass managers. These mirror what clang\n-            // does, and are by populated by LLVM's default PassManagerBuilder.\n-            // Each manager has a different set of passes, but they also share\n-            // some common passes.\n-            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-            let mpm = llvm::LLVMCreatePassManager();\n-\n-            // If we're verifying or linting, add them to the function pass\n-            // manager.\n-            let addpass = |pass: &str| {\n-                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n-            };\n-            if !sess.no_verify() { assert!(addpass(\"verify\")); }\n-\n-            if !sess.opts.cg.no_prepopulate_passes {\n-                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n-                                     trans.no_builtins);\n-            }\n-\n-            for pass in sess.opts.cg.passes.iter() {\n-                pass.as_slice().with_c_str(|s| {\n-                    if !llvm::LLVMRustAddPass(mpm, s) {\n-                        sess.warn(format!(\"unknown pass {}, ignoring\",\n-                                          *pass).as_slice());\n-                    }\n-                })\n-            }\n-\n-            // Finally, run the actual optimization passes\n-            time(sess.time_passes(), \"llvm function passes\", (), |()|\n-                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-            time(sess.time_passes(), \"llvm module passes\", (), |()|\n-                 llvm::LLVMRunPassManager(mpm, llmod));\n-\n-            // Deallocate managers that we're now done with\n-            llvm::LLVMDisposePassManager(fpm);\n-            llvm::LLVMDisposePassManager(mpm);\n-\n-            // Emit the bytecode if we're either saving our temporaries or\n-            // emitting an rlib. Whenever an rlib is created, the bytecode is\n-            // inserted into the archive in order to allow LTO against it.\n-            if sess.opts.cg.save_temps ||\n-               (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-                sess.opts.output_types.contains(&OutputTypeExe)) {\n-                output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                })\n-            }\n-\n-            if sess.lto() {\n-                time(sess.time_passes(), \"all lto passes\", (), |()|\n-                     lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n-\n-                if sess.opts.cg.save_temps {\n-                    output.with_extension(\"lto.bc\").with_c_str(|buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                    })\n-                }\n-            }\n-\n-            // A codegen-specific pass manager is used to generate object\n-            // files for an LLVM module.\n-            //\n-            // Apparently each of these pass managers is a one-shot kind of\n-            // thing, so we create a new one for each type of output. The\n-            // pass manager passed to the closure should be ensured to not\n-            // escape the closure itself, and the manager should only be\n-            // used once.\n-            fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                            no_builtins: bool, f: |PassManagerRef|) {\n-                unsafe {\n-                    let cpm = llvm::LLVMCreatePassManager();\n-                    llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                    llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-                    f(cpm);\n-                    llvm::LLVMDisposePassManager(cpm);\n-                }\n-            }\n-\n-            let mut object_file = None;\n-            let mut needs_metadata = false;\n-            for output_type in output_types.iter() {\n-                let path = output.path(*output_type);\n-                match *output_type {\n-                    OutputTypeBitcode => {\n-                        path.with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n-                    }\n-                    OutputTypeLlvmAssembly => {\n-                        path.with_c_str(|output| {\n-                            with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                                llvm::LLVMRustPrintModule(cpm, llmod, output);\n-                            })\n-                        })\n-                    }\n-                    OutputTypeAssembly => {\n-                        // If we're not using the LLVM assembler, this function\n-                        // could be invoked specially with output_type_assembly,\n-                        // so in this case we still want the metadata object\n-                        // file.\n-                        let ty = OutputTypeAssembly;\n-                        let path = if sess.opts.output_types.contains(&ty) {\n-                           path\n-                        } else {\n-                            needs_metadata = true;\n-                            output.temp_path(OutputTypeAssembly)\n-                        };\n-                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            write_output_file(sess, tm, cpm, llmod, &path,\n-                                            llvm::AssemblyFile);\n-                        });\n-                    }\n-                    OutputTypeObject => {\n-                        object_file = Some(path);\n-                    }\n-                    OutputTypeExe => {\n-                        object_file = Some(output.temp_path(OutputTypeObject));\n-                        needs_metadata = true;\n-                    }\n-                }\n-            }\n-\n-            time(sess.time_passes(), \"codegen passes\", (), |()| {\n-                match object_file {\n-                    Some(ref path) => {\n-                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            write_output_file(sess, tm, cpm, llmod, path,\n-                                            llvm::ObjectFile);\n-                        });\n-                    }\n-                    None => {}\n-                }\n-                if needs_metadata {\n-                    with_codegen(tm, trans.metadata_module,\n-                                 trans.no_builtins, |cpm| {\n-                        let out = output.temp_path(OutputTypeObject)\n-                                        .with_extension(\"metadata.o\");\n-                        write_output_file(sess, tm, cpm,\n-                                        trans.metadata_module, &out,\n-                                        llvm::ObjectFile);\n-                    })\n-                }\n-            });\n-\n-            llvm::LLVMRustDisposeTargetMachine(tm);\n-            llvm::LLVMDisposeModule(trans.metadata_module);\n-            llvm::LLVMContextDispose(trans.metadata_context);\n-            llvm::LLVMDisposeModule(llmod);\n-            llvm::LLVMContextDispose(llcx);\n-            if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n-        }\n-    }\n-\n-    pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-        let pname = super::get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.as_slice());\n-\n-        cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(OutputTypeObject))\n-                               .arg(outputs.temp_path(OutputTypeAssembly));\n-        debug!(\"{}\", &cmd);\n-\n-        match cmd.output() {\n-            Ok(prog) => {\n-                if !prog.status.success() {\n-                    sess.err(format!(\"linking with `{}` failed: {}\",\n-                                     pname,\n-                                     prog.status).as_slice());\n-                    sess.note(format!(\"{}\", &cmd).as_slice());\n-                    let mut note = prog.error.clone();\n-                    note.push_all(prog.output.as_slice());\n-                    sess.note(str::from_utf8(note.as_slice()).unwrap());\n-                    sess.abort_if_errors();\n-                }\n-            },\n-            Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\",\n-                                 pname,\n-                                 e).as_slice());\n-                sess.abort_if_errors();\n-            }\n-        }\n-    }\n-\n-    unsafe fn configure_llvm(sess: &Session) {\n-        use std::sync::{Once, ONCE_INIT};\n-        static mut INIT: Once = ONCE_INIT;\n-\n-        // Copy what clang does by turning on loop vectorization at O2 and\n-        // slp vectorization at O3\n-        let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n-                             (sess.opts.optimize == config::Default ||\n-                              sess.opts.optimize == config::Aggressive);\n-        let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                            sess.opts.optimize == config::Aggressive;\n-\n-        let mut llvm_c_strs = Vec::new();\n-        let mut llvm_args = Vec::new();\n-        {\n-            let add = |arg: &str| {\n-                let s = arg.to_c_str();\n-                llvm_args.push(s.as_ptr());\n-                llvm_c_strs.push(s);\n-            };\n-            add(\"rustc\"); // fake program name\n-            if vectorize_loop { add(\"-vectorize-loops\"); }\n-            if vectorize_slp  { add(\"-vectorize-slp\");   }\n-            if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-            if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-            for arg in sess.opts.cg.llvm_args.iter() {\n-                add((*arg).as_slice());\n-            }\n-        }\n-\n-        INIT.doit(|| {\n-            llvm::LLVMInitializePasses();\n-\n-            // Only initialize the platforms supported by Rust here, because\n-            // using --llvm-root will have multiple platforms that rustllvm\n-            // doesn't actually link to and it's pointless to put target info\n-            // into the registry that Rust cannot generate machine code for.\n-            llvm::LLVMInitializeX86TargetInfo();\n-            llvm::LLVMInitializeX86Target();\n-            llvm::LLVMInitializeX86TargetMC();\n-            llvm::LLVMInitializeX86AsmPrinter();\n-            llvm::LLVMInitializeX86AsmParser();\n-\n-            llvm::LLVMInitializeARMTargetInfo();\n-            llvm::LLVMInitializeARMTarget();\n-            llvm::LLVMInitializeARMTargetMC();\n-            llvm::LLVMInitializeARMAsmPrinter();\n-            llvm::LLVMInitializeARMAsmParser();\n-\n-            llvm::LLVMInitializeMipsTargetInfo();\n-            llvm::LLVMInitializeMipsTarget();\n-            llvm::LLVMInitializeMipsTargetMC();\n-            llvm::LLVMInitializeMipsAsmPrinter();\n-            llvm::LLVMInitializeMipsAsmParser();\n-\n-            llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                         llvm_args.as_ptr());\n-        });\n-    }\n-\n-    unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n-                                   mpm: llvm::PassManagerRef,\n-                                   llmod: ModuleRef,\n-                                   opt: llvm::CodeGenOptLevel,\n-                                   no_builtins: bool) {\n-        // Create the PassManagerBuilder for LLVM. We configure it with\n-        // reasonable defaults and prepare it to actually populate the pass\n-        // manager.\n-        let builder = llvm::LLVMPassManagerBuilderCreate();\n-        match opt {\n-            llvm::CodeGenLevelNone => {\n-                // Don't add lifetime intrinsics at O0\n-                llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n-            }\n-            llvm::CodeGenLevelLess => {\n-                llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n-            }\n-            // numeric values copied from clang\n-            llvm::CodeGenLevelDefault => {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                    225);\n-            }\n-            llvm::CodeGenLevelAggressive => {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                    275);\n-            }\n-        }\n-        llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n-        llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n-\n-        // Use the builder to populate the function/module pass managers.\n-        llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n-        llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n-        llvm::LLVMPassManagerBuilderDispose(builder);\n-\n-        match opt {\n-            llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n-                \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n-            }\n-            _ => {}\n-        };\n-    }\n-}\n-\n-\n /*\n  * Name mangling and its relationship to metadata. This is complex. Read\n  * carefully.\n@@ -878,7 +404,7 @@ pub fn get_ar_prog(sess: &Session) -> String {\n     }\n }\n \n-fn remove(sess: &Session, path: &Path) {\n+pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {"}, {"sha": "eeba34064905afbef7be9753679e564257d24c19", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use super::link;\n+use super::write;\n use driver::session;\n use driver::config;\n use llvm;\n@@ -119,9 +120,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *const libc::c_char,\n                                                     bc_decoded.len() as libc::size_t) {\n-                link::llvm_err(sess,\n-                               format!(\"failed to load bc of `{}`\",\n-                                       name.as_slice()));\n+                write::llvm_err(sess,\n+                                format!(\"failed to load bc of `{}`\",\n+                                        name.as_slice()));\n             }\n         });\n     }"}, {"sha": "c234539036603c4430aafeb3f8580157a9210075", "filename": "src/librustc/back/write.rs", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -0,0 +1,476 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::lto;\n+use back::link::get_cc_prog;\n+use driver::driver::{CrateTranslation, OutputFilenames};\n+use driver::config::NoDebugInfo;\n+use driver::session::Session;\n+use driver::config;\n+use llvm;\n+use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n+use util::common::time;\n+use syntax::abi;\n+\n+use std::c_str::{ToCStr, CString};\n+use std::io::Command;\n+use std::ptr;\n+use std::str;\n+use libc::{c_uint, c_int};\n+\n+\n+#[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n+pub enum OutputType {\n+    OutputTypeBitcode,\n+    OutputTypeAssembly,\n+    OutputTypeLlvmAssembly,\n+    OutputTypeObject,\n+    OutputTypeExe,\n+}\n+\n+\n+pub fn llvm_err(sess: &Session, msg: String) -> ! {\n+    unsafe {\n+        let cstr = llvm::LLVMRustGetLastError();\n+        if cstr == ptr::null() {\n+            sess.fatal(msg.as_slice());\n+        } else {\n+            let err = CString::new(cstr, true);\n+            let err = String::from_utf8_lossy(err.as_bytes());\n+            sess.fatal(format!(\"{}: {}\",\n+                               msg.as_slice(),\n+                               err.as_slice()).as_slice());\n+        }\n+    }\n+}\n+\n+pub fn write_output_file(\n+        sess: &Session,\n+        target: llvm::TargetMachineRef,\n+        pm: llvm::PassManagerRef,\n+        m: ModuleRef,\n+        output: &Path,\n+        file_type: llvm::FileType) {\n+    unsafe {\n+        output.with_c_str(|output| {\n+            let result = llvm::LLVMRustWriteOutputFile(\n+                    target, pm, m, output, file_type);\n+            if !result {\n+                llvm_err(sess, \"could not write output\".to_string());\n+            }\n+        })\n+    }\n+}\n+\n+\n+// On android, we by default compile for armv7 processors. This enables\n+// things like double word CAS instructions (rather than emulating them)\n+// which are *far* more efficient. This is obviously undesirable in some\n+// cases, so if any sort of target feature is specified we don't append v7\n+// to the feature list.\n+//\n+// On iOS only armv7 and newer are supported. So it is useful to\n+// get all hardware potential via VFP3 (hardware floating point)\n+// and NEON (SIMD) instructions supported by LLVM.\n+// Note that without those flags various linking errors might\n+// arise as some of intrinsics are converted into function calls\n+// and nobody provides implementations those functions\n+fn target_feature<'a>(sess: &'a Session) -> &'a str {\n+    match sess.targ_cfg.os {\n+        abi::OsAndroid => {\n+            if \"\" == sess.opts.cg.target_feature.as_slice() {\n+                \"+v7\"\n+            } else {\n+                sess.opts.cg.target_feature.as_slice()\n+            }\n+        },\n+        abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n+            \"+v7,+thumb2,+vfp3,+neon\"\n+        },\n+        _ => sess.opts.cg.target_feature.as_slice()\n+    }\n+}\n+\n+pub fn run_passes(sess: &Session,\n+                  trans: &CrateTranslation,\n+                  output_types: &[OutputType],\n+                  output: &OutputFilenames) {\n+    let llmod = trans.module;\n+    let llcx = trans.context;\n+    unsafe {\n+        configure_llvm(sess);\n+\n+        if sess.opts.cg.save_temps {\n+            output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n+                llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+            })\n+        }\n+\n+        let opt_level = match sess.opts.optimize {\n+          config::No => llvm::CodeGenLevelNone,\n+          config::Less => llvm::CodeGenLevelLess,\n+          config::Default => llvm::CodeGenLevelDefault,\n+          config::Aggressive => llvm::CodeGenLevelAggressive,\n+        };\n+        let use_softfp = sess.opts.cg.soft_float;\n+\n+        // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n+        // FIXME: #11954: mac64 unwinding may not work with fp elim\n+        let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n+                         (sess.targ_cfg.os == abi::OsMacos &&\n+                          sess.targ_cfg.arch == abi::X86_64);\n+\n+        // OSX has -dead_strip, which doesn't rely on ffunction_sections\n+        // FIXME(#13846) this should be enabled for windows\n+        let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n+                                 sess.targ_cfg.os != abi::OsWindows;\n+        let fdata_sections = ffunction_sections;\n+\n+        let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n+            \"pic\" => llvm::RelocPIC,\n+            \"static\" => llvm::RelocStatic,\n+            \"default\" => llvm::RelocDefault,\n+            \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+            _ => {\n+                sess.err(format!(\"{} is not a valid relocation mode\",\n+                                 sess.opts\n+                                     .cg\n+                                     .relocation_model).as_slice());\n+                sess.abort_if_errors();\n+                return;\n+            }\n+        };\n+\n+        let code_model = match sess.opts.cg.code_model.as_slice() {\n+            \"default\" => llvm::CodeModelDefault,\n+            \"small\" => llvm::CodeModelSmall,\n+            \"kernel\" => llvm::CodeModelKernel,\n+            \"medium\" => llvm::CodeModelMedium,\n+            \"large\" => llvm::CodeModelLarge,\n+            _ => {\n+                sess.err(format!(\"{} is not a valid code model\",\n+                                 sess.opts\n+                                     .cg\n+                                     .code_model).as_slice());\n+                sess.abort_if_errors();\n+                return;\n+            }\n+        };\n+\n+        let tm = sess.targ_cfg\n+                     .target_strs\n+                     .target_triple\n+                     .as_slice()\n+                     .with_c_str(|t| {\n+            sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n+                target_feature(sess).with_c_str(|features| {\n+                    llvm::LLVMRustCreateTargetMachine(\n+                        t, cpu, features,\n+                        code_model,\n+                        reloc_model,\n+                        opt_level,\n+                        true /* EnableSegstk */,\n+                        use_softfp,\n+                        no_fp_elim,\n+                        ffunction_sections,\n+                        fdata_sections,\n+                    )\n+                })\n+            })\n+        });\n+\n+        // Create the two optimizing pass managers. These mirror what clang\n+        // does, and are by populated by LLVM's default PassManagerBuilder.\n+        // Each manager has a different set of passes, but they also share\n+        // some common passes.\n+        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+        let mpm = llvm::LLVMCreatePassManager();\n+\n+        // If we're verifying or linting, add them to the function pass\n+        // manager.\n+        let addpass = |pass: &str| {\n+            pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+        };\n+        if !sess.no_verify() { assert!(addpass(\"verify\")); }\n+\n+        if !sess.opts.cg.no_prepopulate_passes {\n+            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+            populate_llvm_passes(fpm, mpm, llmod, opt_level,\n+                                 trans.no_builtins);\n+        }\n+\n+        for pass in sess.opts.cg.passes.iter() {\n+            pass.as_slice().with_c_str(|s| {\n+                if !llvm::LLVMRustAddPass(mpm, s) {\n+                    sess.warn(format!(\"unknown pass {}, ignoring\",\n+                                      *pass).as_slice());\n+                }\n+            })\n+        }\n+\n+        // Finally, run the actual optimization passes\n+        time(sess.time_passes(), \"llvm function passes\", (), |()|\n+             llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+        time(sess.time_passes(), \"llvm module passes\", (), |()|\n+             llvm::LLVMRunPassManager(mpm, llmod));\n+\n+        // Deallocate managers that we're now done with\n+        llvm::LLVMDisposePassManager(fpm);\n+        llvm::LLVMDisposePassManager(mpm);\n+\n+        // Emit the bytecode if we're either saving our temporaries or\n+        // emitting an rlib. Whenever an rlib is created, the bytecode is\n+        // inserted into the archive in order to allow LTO against it.\n+        if sess.opts.cg.save_temps ||\n+           (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+            sess.opts.output_types.contains(&OutputTypeExe)) {\n+            output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n+                llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+            })\n+        }\n+\n+        if sess.lto() {\n+            time(sess.time_passes(), \"all lto passes\", (), |()|\n+                 lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n+\n+            if sess.opts.cg.save_temps {\n+                output.with_extension(\"lto.bc\").with_c_str(|buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                })\n+            }\n+        }\n+\n+        // A codegen-specific pass manager is used to generate object\n+        // files for an LLVM module.\n+        //\n+        // Apparently each of these pass managers is a one-shot kind of\n+        // thing, so we create a new one for each type of output. The\n+        // pass manager passed to the closure should be ensured to not\n+        // escape the closure itself, and the manager should only be\n+        // used once.\n+        fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n+                        no_builtins: bool, f: |PassManagerRef|) {\n+            unsafe {\n+                let cpm = llvm::LLVMCreatePassManager();\n+                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+                llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+                f(cpm);\n+                llvm::LLVMDisposePassManager(cpm);\n+            }\n+        }\n+\n+        let mut object_file = None;\n+        let mut needs_metadata = false;\n+        for output_type in output_types.iter() {\n+            let path = output.path(*output_type);\n+            match *output_type {\n+                OutputTypeBitcode => {\n+                    path.with_c_str(|buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                    })\n+                }\n+                OutputTypeLlvmAssembly => {\n+                    path.with_c_str(|output| {\n+                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n+                            llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                        })\n+                    })\n+                }\n+                OutputTypeAssembly => {\n+                    // If we're not using the LLVM assembler, this function\n+                    // could be invoked specially with output_type_assembly,\n+                    // so in this case we still want the metadata object\n+                    // file.\n+                    let ty = OutputTypeAssembly;\n+                    let path = if sess.opts.output_types.contains(&ty) {\n+                       path\n+                    } else {\n+                        needs_metadata = true;\n+                        output.temp_path(OutputTypeAssembly)\n+                    };\n+                    with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n+                        write_output_file(sess, tm, cpm, llmod, &path,\n+                                        llvm::AssemblyFile);\n+                    });\n+                }\n+                OutputTypeObject => {\n+                    object_file = Some(path);\n+                }\n+                OutputTypeExe => {\n+                    object_file = Some(output.temp_path(OutputTypeObject));\n+                    needs_metadata = true;\n+                }\n+            }\n+        }\n+\n+        time(sess.time_passes(), \"codegen passes\", (), |()| {\n+            match object_file {\n+                Some(ref path) => {\n+                    with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n+                        write_output_file(sess, tm, cpm, llmod, path,\n+                                        llvm::ObjectFile);\n+                    });\n+                }\n+                None => {}\n+            }\n+            if needs_metadata {\n+                with_codegen(tm, trans.metadata_module,\n+                             trans.no_builtins, |cpm| {\n+                    let out = output.temp_path(OutputTypeObject)\n+                                    .with_extension(\"metadata.o\");\n+                    write_output_file(sess, tm, cpm,\n+                                    trans.metadata_module, &out,\n+                                    llvm::ObjectFile);\n+                })\n+            }\n+        });\n+\n+        llvm::LLVMRustDisposeTargetMachine(tm);\n+        llvm::LLVMDisposeModule(trans.metadata_module);\n+        llvm::LLVMDisposeModule(llmod);\n+        llvm::LLVMContextDispose(llcx);\n+        if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n+    }\n+}\n+\n+pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n+    let pname = get_cc_prog(sess);\n+    let mut cmd = Command::new(pname.as_slice());\n+\n+    cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(OutputTypeObject))\n+                           .arg(outputs.temp_path(OutputTypeAssembly));\n+    debug!(\"{}\", &cmd);\n+\n+    match cmd.output() {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                sess.err(format!(\"linking with `{}` failed: {}\",\n+                                 pname,\n+                                 prog.status).as_slice());\n+                sess.note(format!(\"{}\", &cmd).as_slice());\n+                let mut note = prog.error.clone();\n+                note.push_all(prog.output.as_slice());\n+                sess.note(str::from_utf8(note.as_slice()).unwrap());\n+                sess.abort_if_errors();\n+            }\n+        },\n+        Err(e) => {\n+            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                             pname,\n+                             e).as_slice());\n+            sess.abort_if_errors();\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    use std::sync::{Once, ONCE_INIT};\n+    static mut INIT: Once = ONCE_INIT;\n+\n+    // Copy what clang does by turning on loop vectorization at O2 and\n+    // slp vectorization at O3\n+    let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n+                         (sess.opts.optimize == config::Default ||\n+                          sess.opts.optimize == config::Aggressive);\n+    let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n+                        sess.opts.optimize == config::Aggressive;\n+\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+    {\n+        let add = |arg: &str| {\n+            let s = arg.to_c_str();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if vectorize_loop { add(\"-vectorize-loops\"); }\n+        if vectorize_slp  { add(\"-vectorize-slp\");   }\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in sess.opts.cg.llvm_args.iter() {\n+            add((*arg).as_slice());\n+        }\n+    }\n+\n+    INIT.doit(|| {\n+        llvm::LLVMInitializePasses();\n+\n+        // Only initialize the platforms supported by Rust here, because\n+        // using --llvm-root will have multiple platforms that rustllvm\n+        // doesn't actually link to and it's pointless to put target info\n+        // into the registry that Rust cannot generate machine code for.\n+        llvm::LLVMInitializeX86TargetInfo();\n+        llvm::LLVMInitializeX86Target();\n+        llvm::LLVMInitializeX86TargetMC();\n+        llvm::LLVMInitializeX86AsmPrinter();\n+        llvm::LLVMInitializeX86AsmParser();\n+\n+        llvm::LLVMInitializeARMTargetInfo();\n+        llvm::LLVMInitializeARMTarget();\n+        llvm::LLVMInitializeARMTargetMC();\n+        llvm::LLVMInitializeARMAsmPrinter();\n+        llvm::LLVMInitializeARMAsmParser();\n+\n+        llvm::LLVMInitializeMipsTargetInfo();\n+        llvm::LLVMInitializeMipsTarget();\n+        llvm::LLVMInitializeMipsTargetMC();\n+        llvm::LLVMInitializeMipsAsmPrinter();\n+        llvm::LLVMInitializeMipsAsmParser();\n+\n+        llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                     llvm_args.as_ptr());\n+    });\n+}\n+\n+unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n+                               mpm: llvm::PassManagerRef,\n+                               llmod: ModuleRef,\n+                               opt: llvm::CodeGenOptLevel,\n+                               no_builtins: bool) {\n+    // Create the PassManagerBuilder for LLVM. We configure it with\n+    // reasonable defaults and prepare it to actually populate the pass\n+    // manager.\n+    let builder = llvm::LLVMPassManagerBuilderCreate();\n+    match opt {\n+        llvm::CodeGenLevelNone => {\n+            // Don't add lifetime intrinsics at O0\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n+        }\n+        llvm::CodeGenLevelLess => {\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n+        }\n+        // numeric values copied from clang\n+        llvm::CodeGenLevelDefault => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                225);\n+        }\n+        llvm::CodeGenLevelAggressive => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                275);\n+        }\n+    }\n+    llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n+    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n+\n+    // Use the builder to populate the function/module pass managers.\n+    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n+    llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n+    llvm::LLVMPassManagerBuilderDispose(builder);\n+\n+    match opt {\n+        llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n+            \"mergefunc\".with_c_str(|s| llvm::LLVMRustAddPass(mpm, s));\n+        }\n+        _ => {}\n+    };\n+}"}, {"sha": "04315149a784e318a6c6f4c68de874c2fd958042", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -16,7 +16,7 @@ use driver::driver;\n use driver::session::Session;\n \n use back;\n-use back::link;\n+use back::write;\n use back::target_strs;\n use back::{arm, x86, x86_64, mips, mipsel};\n use lint;\n@@ -72,7 +72,7 @@ pub struct Options {\n     pub debuginfo: DebugInfoLevel,\n     pub lint_opts: Vec<(String, lint::Level)>,\n     pub describe_lints: bool,\n-    pub output_types: Vec<back::link::OutputType> ,\n+    pub output_types: Vec<back::write::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -646,11 +646,11 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         for unparsed_output_type in unparsed_output_types.iter() {\n             for part in unparsed_output_type.as_slice().split(',') {\n                 let output_type = match part.as_slice() {\n-                    \"asm\"  => link::OutputTypeAssembly,\n-                    \"ir\"   => link::OutputTypeLlvmAssembly,\n-                    \"bc\"   => link::OutputTypeBitcode,\n-                    \"obj\"  => link::OutputTypeObject,\n-                    \"link\" => link::OutputTypeExe,\n+                    \"asm\"  => write::OutputTypeAssembly,\n+                    \"ir\"   => write::OutputTypeLlvmAssembly,\n+                    \"bc\"   => write::OutputTypeBitcode,\n+                    \"obj\"  => write::OutputTypeObject,\n+                    \"link\" => write::OutputTypeExe,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n                                             part).as_slice())\n@@ -663,7 +663,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     output_types.as_mut_slice().sort();\n     output_types.dedup();\n     if output_types.len() == 0 {\n-        output_types.push(link::OutputTypeExe);\n+        output_types.push(write::OutputTypeExe);\n     }\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));"}, {"sha": "fa1a1b38a2d0d9422c177daaa0d929660ff54c19", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -10,6 +10,7 @@\n \n \n use back::link;\n+use back::write;\n use driver::session::Session;\n use driver::config;\n use front;\n@@ -473,23 +474,23 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &CrateTranslation,\n                                outputs: &OutputFilenames) {\n     if sess.opts.cg.no_integrated_as {\n-        let output_type = link::OutputTypeAssembly;\n+        let output_type = write::OutputTypeAssembly;\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            link::write::run_passes(sess, trans, [output_type], outputs));\n+            write::run_passes(sess, trans, [output_type], outputs));\n \n-        link::write::run_assembler(sess, outputs);\n+        write::run_assembler(sess, outputs);\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.cg.save_temps {\n-            fs::unlink(&outputs.temp_path(link::OutputTypeAssembly)).unwrap();\n+            fs::unlink(&outputs.temp_path(write::OutputTypeAssembly)).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            link::write::run_passes(sess,\n-                                    trans,\n-                                    sess.opts.output_types.as_slice(),\n-                                    outputs));\n+            write::run_passes(sess,\n+                              trans,\n+                              sess.opts.output_types.as_slice(),\n+                              outputs));\n     }\n }\n \n@@ -533,7 +534,7 @@ pub fn stop_after_phase_2(sess: &Session) -> bool {\n }\n \n pub fn stop_after_phase_5(sess: &Session) -> bool {\n-    if !sess.opts.output_types.iter().any(|&i| i == link::OutputTypeExe) {\n+    if !sess.opts.output_types.iter().any(|&i| i == write::OutputTypeExe) {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n@@ -549,7 +550,7 @@ fn write_out_deps(sess: &Session,\n     for output_type in sess.opts.output_types.iter() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n-            link::OutputTypeExe => {\n+            write::OutputTypeExe => {\n                 for output in sess.crate_types.borrow().iter() {\n                     let p = link::filename_for_input(sess, *output,\n                                                      id, &file);\n@@ -688,22 +689,22 @@ pub struct OutputFilenames {\n }\n \n impl OutputFilenames {\n-    pub fn path(&self, flavor: link::OutputType) -> Path {\n+    pub fn path(&self, flavor: write::OutputType) -> Path {\n         match self.single_output_file {\n             Some(ref path) => return path.clone(),\n             None => {}\n         }\n         self.temp_path(flavor)\n     }\n \n-    pub fn temp_path(&self, flavor: link::OutputType) -> Path {\n+    pub fn temp_path(&self, flavor: write::OutputType) -> Path {\n         let base = self.out_directory.join(self.filestem());\n         match flavor {\n-            link::OutputTypeBitcode => base.with_extension(\"bc\"),\n-            link::OutputTypeAssembly => base.with_extension(\"s\"),\n-            link::OutputTypeLlvmAssembly => base.with_extension(\"ll\"),\n-            link::OutputTypeObject => base.with_extension(\"o\"),\n-            link::OutputTypeExe => base,\n+            write::OutputTypeBitcode => base.with_extension(\"bc\"),\n+            write::OutputTypeAssembly => base.with_extension(\"s\"),\n+            write::OutputTypeLlvmAssembly => base.with_extension(\"ll\"),\n+            write::OutputTypeObject => base.with_extension(\"o\"),\n+            write::OutputTypeExe => base,\n         }\n     }\n "}, {"sha": "e4eac80c4afd92ab06d3a62acdbc640b79caf136", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -69,6 +69,7 @@ pub mod back {\n \n     pub mod link;\n     pub mod lto;\n+    pub mod write;\n \n }\n "}, {"sha": "d2345614b25c218ce1433115dc215c1d1b7a78e4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "patch": "@@ -20,7 +20,7 @@ use std::string::String;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n-use rustc::back::link;\n+use rustc::back::write;\n use rustc::driver::config;\n use rustc::driver::driver;\n use rustc::driver::session;\n@@ -120,7 +120,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, externs: core::Exte\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(config::CrateTypeExecutable),\n-        output_types: vec!(link::OutputTypeExe),\n+        output_types: vec!(write::OutputTypeExe),\n         no_trans: no_run,\n         externs: externs,\n         cg: config::CodegenOptions {"}]}