{"sha": "dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZmU3MGRmY2RiMGVhYjVlMWUyMWY0MTljNzE4ZTU4Y2Y2MjAyOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T01:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-22T01:51:31Z"}, "message": "Auto merge of #61027 - Centril:rollup-oewauf1, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #59742 (Move `edition` outside the hygiene lock and avoid accessing it)\n - #60581 (convert custom try macro to `?`)\n - #60963 (Update boxed::Box docs on memory layout)\n - #60973 (Avoid symbol interning in `file_metadata`.)\n - #60982 (Do not fail on child without DefId)\n - #60991 (LocalDecl push returns Local len)\n - #60995 (Add stream_to_parser_with_base_dir)\n - #60998 (static_assert: make use of anonymous constants)\n - #61003 (Remove impls for `InternedString`/string equality.)\n - #61006 (adjust deprecation date of mem::uninitialized)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "452e9e1ca7bc89a661fd3c3d5c2d4b1fb79c09b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/452e9e1ca7bc89a661fd3c3d5c2d4b1fb79c09b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "html_url": "https://github.com/rust-lang/rust/commit/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119bbc2056a60e8557d1e5f2e0a7ab46d479bcaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/119bbc2056a60e8557d1e5f2e0a7ab46d479bcaf", "html_url": "https://github.com/rust-lang/rust/commit/119bbc2056a60e8557d1e5f2e0a7ab46d479bcaf"}, {"sha": "2551a54af1785df544343cbba2e53fcc4c5052ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/2551a54af1785df544343cbba2e53fcc4c5052ec", "html_url": "https://github.com/rust-lang/rust/commit/2551a54af1785df544343cbba2e53fcc4c5052ec"}], "stats": {"total": 723, "additions": 377, "deletions": 346}, "files": [{"sha": "024594517d9884bfa636789086d6e570c44d4611", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -4,16 +4,6 @@\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n //! drop their contents when they go out of scope.\n //!\n-//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n-//! its allocation. It is valid to convert both ways between a [`Box`] and a\n-//! raw pointer allocated with the [`Global`] allocator, given that the\n-//! [`Layout`] used with the allocator is correct for the type. More precisely,\n-//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n-//! with `Layout::for_value(&*value)` may be converted into a box using\n-//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n-//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n-//! [`Global`] allocator with `Layout::for_value(&*value)`.\n-//!\n //! # Examples\n //!\n //! Move a value from the stack to the heap by creating a [`Box`]:\n@@ -61,6 +51,19 @@\n //! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n //! big `Cons` needs to be.\n //!\n+//! # Memory layout\n+//!\n+//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n+//! its allocation. It is valid to convert both ways between a [`Box`] and a\n+//! raw pointer allocated with the [`Global`] allocator, given that the\n+//! [`Layout`] used with the allocator is correct for the type. More precisely,\n+//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n+//! with `Layout::for_value(&*value)` may be converted into a box using\n+//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n+//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n+//! [`Global`] allocator with `Layout::for_value(&*value)`.\n+//!\n+//!\n //! [dereferencing]: ../../std/ops/trait.Deref.html\n //! [`Box`]: struct.Box.html\n //! [`Global`]: ../alloc/struct.Global.html\n@@ -127,24 +130,38 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// After calling this function, the raw pointer is owned by the\n     /// resulting `Box`. Specifically, the `Box` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `Box` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `Box` via the [`Box::into_raw`] function.\n+    /// the destructor of `T` and free the allocated memory. For this\n+    /// to be safe, the memory must have been allocated in accordance\n+    /// with the [memory layout] used by `Box` .\n+    ///\n+    /// # Safety\n     ///\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n-    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Recreate a `Box` which was previously converted to a raw pointer\n+    /// using [`Box::into_raw`]:\n     /// ```\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw(x);\n     /// let x = unsafe { Box::from_raw(ptr) };\n     /// ```\n+    /// Manually create a `Box` from scratch by using the global allocator:\n+    /// ```\n+    /// use std::alloc::{alloc, Layout};\n+    ///\n+    /// unsafe {\n+    ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n+    ///     *ptr = 5;\n+    ///     let x = Box::from_raw(ptr);\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Layout`]: ../alloc/struct.Layout.html\n+    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -157,22 +174,40 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// caller should properly destroy `T` and release the memory, taking\n+    /// into account the [memory layout] used by `Box`. The easiest way to\n+    /// do this is to convert the raw pointer back into a `Box` with the\n+    /// [`Box::from_raw`] function, allowing the `Box` destructor to perform\n+    /// the cleanup.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n+    /// for automatic cleanup:\n     /// ```\n-    /// let x = Box::new(5);\n+    /// let x = Box::new(String::from(\"Hello\"));\n     /// let ptr = Box::into_raw(x);\n+    /// let x = unsafe { Box::from_raw(ptr) };\n+    /// ```\n+    /// Manual cleanup by explicitly running the destructor and deallocating\n+    /// the memory:\n     /// ```\n+    /// use std::alloc::{dealloc, Layout};\n+    /// use std::ptr;\n+    ///\n+    /// let x = Box::new(String::from(\"Hello\"));\n+    /// let p = Box::into_raw(x);\n+    /// unsafe {\n+    ///     ptr::drop_in_place(p);\n+    ///     dealloc(p as *mut u8, Layout::new::<String>());\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n@@ -184,7 +219,7 @@ impl<T: ?Sized> Box<T> {\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the `NonNull<T>` pointer\n+    /// easiest way to do so is to convert the `NonNull<T>` pointer\n     /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n     /// function.\n     ///\n@@ -203,6 +238,10 @@ impl<T: ?Sized> Box<T> {\n     /// fn main() {\n     ///     let x = Box::new(5);\n     ///     let ptr = Box::into_raw_non_null(x);\n+    ///\n+    ///     // Clean up the memory by converting the NonNull pointer back\n+    ///     // into a Box and letting the Box be dropped.\n+    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// }\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]"}, {"sha": "56869f38a4f6bb3f09dd2988ef1ff4cc46137405", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -466,7 +466,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [`MaybeUninit<T>`]: union.MaybeUninit.html\n /// [inv]: union.MaybeUninit.html#initialization-invariant\n #[inline]\n-#[rustc_deprecated(since = \"1.40.0\", reason = \"use `mem::MaybeUninit` instead\")]\n+#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "1f25dba2915c4c8c38950ea56f4b3ea8da558895", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -6,7 +6,7 @@ use crate::ty::query::Providers;\n \n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, sym};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n@@ -69,7 +69,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n-        self.tcx.item_name(def_id) == \"transmute\"\n+        self.tcx.item_name(def_id) == sym::transmute\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {"}, {"sha": "f16137bd2c27ade42d3d91d35403cbd5ae0b04d9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1853,7 +1853,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n-    syntax::with_globals(move || {\n+    syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n             let sess = parse::ParseSess::new(FilePathMapping::empty());\n             let filename = FileName::cfg_spec_source_code(&s);\n@@ -2735,7 +2735,7 @@ mod tests {\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n-        syntax::with_globals(|| {\n+        syntax::with_default_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n                 Ok(m) => m,\n                 Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n@@ -2753,7 +2753,7 @@ mod tests {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         use syntax::symbol::sym;\n-        syntax::with_globals(|| {\n+        syntax::with_default_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string(),\n                                                      \"--cfg=test\".to_string()]) {\n                 Ok(m) => m,\n@@ -2771,15 +2771,15 @@ mod tests {\n \n     #[test]\n     fn test_can_print_warnings() {\n-        syntax::with_globals(|| {\n+        syntax::with_default_globals(|| {\n             let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, None, registry);\n             assert!(!sess.diagnostic().flags.can_emit_warnings);\n         });\n \n-        syntax::with_globals(|| {\n+        syntax::with_default_globals(|| {\n             let matches = optgroups()\n                 .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n                 .unwrap();\n@@ -2789,7 +2789,7 @@ mod tests {\n             assert!(sess.diagnostic().flags.can_emit_warnings);\n         });\n \n-        syntax::with_globals(|| {\n+        syntax::with_default_globals(|| {\n             let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);"}, {"sha": "f9ceeb5bfc01b373e22b615a6056481c0dfa729f", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -243,15 +243,15 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                     // `{Self}` is allowed\n                     Position::ArgumentNamed(s) if s == \"Self\" => (),\n                     // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s) if s == name => (),\n+                    Position::ArgumentNamed(s) if s == name.as_str() => (),\n                     // `{from_method}` is allowed\n                     Position::ArgumentNamed(s) if s == \"from_method\" => (),\n                     // `{from_desugaring}` is allowed\n                     Position::ArgumentNamed(s) if s == \"from_desugaring\" => (),\n                     // So is `{A}` if A is a type parameter\n-                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param|\n-                        param.name == s\n-                    ) {\n+                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n+                        param.name.as_str() == s\n+                    }) {\n                         Some(_) => (),\n                         None => {\n                             span_err!(tcx.sess, span, E0230,\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 Piece::NextArgument(a) => match a.position {\n                     Position::ArgumentNamed(s) => match generic_map.get(s) {\n                         Some(val) => val,\n-                        None if s == name => {\n+                        None if s == name.as_str() => {\n                             &trait_str\n                         }\n                         None => {"}, {"sha": "b60ef557cb84f660271a0c10e2dd353cf1342abc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -2981,9 +2981,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn item_name(self, id: DefId) -> InternedString {\n+    pub fn item_name(self, id: DefId) -> Symbol {\n         if id.index == CRATE_DEF_INDEX {\n-            self.original_crate_name(id.krate).as_interned_str()\n+            self.original_crate_name(id.krate)\n         } else {\n             let def_key = self.def_key(id);\n             match def_key.disambiguated_data.data {\n@@ -2995,7 +2995,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }),\n                 _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n                     bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                }),\n+                }).as_symbol(),\n             }\n         }\n     }"}, {"sha": "c18852a832fce8bd6226e829c75f8a87074eb666", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1140,14 +1140,16 @@ impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F>\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name != \"\" && data.name != \"'_\"\n+                data.name.as_symbol() != keywords::Invalid.name() &&\n+                data.name.as_symbol() != keywords::UnderscoreLifetime.name()\n             }\n \n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n+                    if name.as_symbol() != keywords::Invalid.name() &&\n+                       name.as_symbol() != keywords::UnderscoreLifetime.name() {\n                         return true;\n                     }\n                 }\n@@ -1203,7 +1205,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name != \"\" {\n+                if data.name.as_symbol() != keywords::Invalid.name() {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n@@ -1212,7 +1214,8 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name != \"\" && name != \"'_\" {\n+                    if name.as_symbol() != keywords::Invalid.name() &&\n+                       name.as_symbol() != keywords::UnderscoreLifetime.name() {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }"}, {"sha": "0c19d770194b2ea486f268ab30e526bdb9259451", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n         base::{ExtCtxt, Resolver},\n         build::AstBuilder,\n         expand::ExpansionConfig,\n-        hygiene::{self, Mark, SyntaxContext},\n+        hygiene::{Mark, SyntaxContext},\n     },\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n@@ -96,7 +96,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n             ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: hygiene::default_edition(),\n+            edition: self.sess.edition,\n         });\n \n         // Tie the span to the macro expansion info we just created"}, {"sha": "b000628a3f70653e9653e519cf47b61cf71aff88", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -38,14 +38,15 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::abi::HasDataLayout;\n \n use libc::{c_uint, c_longlong};\n+use std::collections::hash_map::Entry;\n use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ptr;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n-use syntax::symbol::{Interner, InternedString, Symbol};\n+use syntax::symbol::{Interner, InternedString};\n use syntax_pos::{self, Span, FileName};\n \n impl PartialEq for llvm::Metadata {\n@@ -787,49 +788,48 @@ pub fn file_metadata(cx: &CodegenCx<'ll, '_>,\n            file_name,\n            defining_crate);\n \n-    let file_name = &file_name.to_string();\n-    let file_name_symbol = Symbol::intern(file_name);\n-    if defining_crate == LOCAL_CRATE {\n-        let directory = &cx.sess().working_dir.0.to_string_lossy();\n-        file_metadata_raw(cx, file_name, Some(file_name_symbol),\n-                          directory, Some(Symbol::intern(directory)))\n+    let file_name = Some(file_name.to_string());\n+    let directory = if defining_crate == LOCAL_CRATE {\n+        Some(cx.sess().working_dir.0.to_string_lossy().to_string())\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n-        file_metadata_raw(cx, file_name, Some(file_name_symbol), \"\", None)\n-    }\n+        None\n+    };\n+    file_metadata_raw(cx, file_name, directory)\n }\n \n pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n-    file_metadata_raw(cx, \"<unknown>\", None, \"\", None)\n+    file_metadata_raw(cx, None, None)\n }\n \n fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n-                     file_name: &str,\n-                     file_name_symbol: Option<Symbol>,\n-                     directory: &str,\n-                     directory_symbol: Option<Symbol>)\n+                     file_name: Option<String>,\n+                     directory: Option<String>)\n                      -> &'ll DIFile {\n-    let key = (file_name_symbol, directory_symbol);\n+    let key = (file_name, directory);\n+\n+    match debug_context(cx).created_files.borrow_mut().entry(key) {\n+        Entry::Occupied(o) => return o.get(),\n+        Entry::Vacant(v) => {\n+            let (file_name, directory) = v.key();\n+            debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n+\n+            let file_name = SmallCStr::new(\n+                if let Some(file_name) = file_name { &file_name } else { \"<unknown>\" });\n+            let directory = SmallCStr::new(\n+                if let Some(directory) = directory { &directory } else { \"\" });\n+\n+            let file_metadata = unsafe {\n+                llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n+                                                  file_name.as_ptr(),\n+                                                  directory.as_ptr())\n+            };\n \n-    if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n-        return *file_metadata;\n+            v.insert(file_metadata);\n+            file_metadata\n+        }\n     }\n-\n-    debug!(\"file_metadata: file_name: {}, directory: {}\", file_name, directory);\n-\n-    let file_name = SmallCStr::new(file_name);\n-    let directory = SmallCStr::new(directory);\n-\n-    let file_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n-                                          file_name.as_ptr(),\n-                                          directory.as_ptr())\n-    };\n-\n-    let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(key, file_metadata);\n-    file_metadata\n }\n \n fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {"}, {"sha": "527290392fff45a27f73ef22404f7d37f6d22f5a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -37,7 +37,7 @@ use std::ffi::CString;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc_codegen_ssa::traits::*;\n \n@@ -63,7 +63,7 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     llcontext: &'a llvm::Context,\n     llmod: &'a llvm::Module,\n     builder: &'a mut DIBuilder<'a>,\n-    created_files: RefCell<FxHashMap<(Option<Symbol>, Option<Symbol>), &'a DIFile>>,\n+    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'a DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), &'a DIType>>,\n \n     type_map: RefCell<TypeMap<'a, 'tcx>>,"}, {"sha": "1a8647ed197b5c316f45db8ed205d3c68ec5c6b0", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -264,7 +264,7 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n             return name.as_interned_str();\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id);\n+        return tcx.item_name(def_id).as_interned_str();\n     }\n \n     if let Some(name) = &attrs.export_name {\n@@ -274,7 +274,7 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id);\n+        return tcx.item_name(def_id).as_interned_str();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some"}, {"sha": "b851263aaf9c4e6a4668226a3bbb5f531e0c6896", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1,13 +1,12 @@\n-/// A simple static assertion macro. The first argument should be a unique\n-/// ALL_CAPS identifier that describes the condition.\n+/// A simple static assertion macro.\n #[macro_export]\n-#[allow_internal_unstable(type_ascription)]\n+#[allow_internal_unstable(type_ascription, underscore_const_names)]\n macro_rules! static_assert {\n-    ($name:ident: $test:expr) => {\n+    ($test:expr) => {\n         // Use the bool to access an array such that if the bool is false, the access\n         // is out-of-bounds.\n         #[allow(dead_code)]\n-        static $name: () = [()][!($test: bool) as usize];\n+        const _: () = [()][!($test: bool) as usize];\n     }\n }\n "}, {"sha": "674b2b60e44a2520dcfe81209b47399b61863b46", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -18,6 +18,7 @@ use std::result;\n use std::sync::{Arc, Mutex};\n use syntax;\n use syntax::source_map::{FileLoader, SourceMap};\n+use syntax_pos::edition;\n \n pub type Result<T> = result::Result<T, ErrorReported>;\n \n@@ -135,16 +136,17 @@ where\n {\n     let stderr = config.stderr.take();\n     util::spawn_thread_pool(\n+        config.opts.edition,\n         config.opts.debugging_opts.threads,\n         &stderr,\n         || run_compiler_in_existing_thread_pool(config, f),\n     )\n }\n \n-pub fn default_thread_pool<F, R>(f: F) -> R\n+pub fn default_thread_pool<F, R>(edition: edition::Edition, f: F) -> R\n where\n     F: FnOnce() -> R + Send,\n     R: Send,\n {\n-    util::spawn_thread_pool(None, &None, f)\n+    util::spawn_thread_pool(edition, None, &None, f)\n }"}, {"sha": "04041f88344204bf20efc4efda72f004d97d2ed3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -48,7 +48,7 @@ use syntax::util::node_count::NodeCounter;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::symbol::Symbol;\n use syntax::feature_gate::AttributeType;\n-use syntax_pos::{FileName, hygiene};\n+use syntax_pos::{FileName, edition::Edition, hygiene};\n use syntax_ext;\n \n use serialize::json;\n@@ -70,8 +70,6 @@ use std::ops::Generator;\n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     sess.diagnostic()\n         .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n-    hygiene::set_default_edition(sess.edition());\n-\n     sess.profiler(|p| p.start_activity(\"parsing\"));\n     let krate = time(sess, \"parsing\", || match *input {\n         Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n@@ -375,7 +373,7 @@ fn configure_and_expand_inner<'a>(\n         crate_loader,\n         &resolver_arenas,\n     );\n-    syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts);\n+    syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts, sess.edition());\n \n     // Expand all macros\n     sess.profiler(|p| p.start_activity(\"macro expansion\"));"}, {"sha": "09bb547191f491f29d4dc42f74c7e3f043c5e419", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -37,6 +37,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n use syntax::symbol::{Symbol, sym};\n use syntax::{self, ast, attr};\n+use syntax_pos::edition::Edition;\n #[cfg(not(parallel_compiler))]\n use std::{thread, panic};\n \n@@ -167,6 +168,7 @@ pub fn scoped_thread<F: FnOnce() -> R + Send, R: Send>(cfg: thread::Builder, f:\n \n #[cfg(not(parallel_compiler))]\n pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n+    edition: Edition,\n     _threads: Option<usize>,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n@@ -178,7 +180,7 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n     }\n \n     scoped_thread(cfg, || {\n-        syntax::with_globals( || {\n+        syntax::with_globals(edition, || {\n             ty::tls::GCX_PTR.set(&Lock::new(0), || {\n                 if let Some(stderr) = stderr {\n                     io::set_panic(Some(box Sink(stderr.clone())));\n@@ -191,6 +193,7 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n \n #[cfg(parallel_compiler)]\n pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n+    edition: Edition,\n     threads: Option<usize>,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n@@ -213,7 +216,7 @@ pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n \n     let with_pool = move |pool: &ThreadPool| pool.install(move || f());\n \n-    syntax::with_globals(|| {\n+    syntax::with_globals(edition, || {\n         syntax::GLOBALS.with(|syntax_globals| {\n             syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n                 // The main handler runs for each Rayon worker thread and sets up"}, {"sha": "d17a92efb066bb9dd3725577049292b578223f1d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -929,7 +929,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n \n         fn def_id_is_transmute(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n             cx.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n-            cx.tcx.item_name(def_id) == \"transmute\"\n+            cx.tcx.item_name(def_id) == sym::transmute\n         }\n     }\n }"}, {"sha": "2070a38b7b85de5ef15715ca5394e487f7720863", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -355,20 +355,20 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n                         return;\n                     }\n \n-                    let child = child.res.def_id();\n-\n-                    match visible_parent_map.entry(child) {\n-                        Entry::Occupied(mut entry) => {\n-                            // If `child` is defined in crate `cnum`, ensure\n-                            // that it is mapped to a parent in `cnum`.\n-                            if child.krate == cnum && entry.get().krate != cnum {\n+                    if let Some(child) = child.res.opt_def_id() {\n+                        match visible_parent_map.entry(child) {\n+                            Entry::Occupied(mut entry) => {\n+                                // If `child` is defined in crate `cnum`, ensure\n+                                // that it is mapped to a parent in `cnum`.\n+                                if child.krate == cnum && entry.get().krate != cnum {\n+                                    entry.insert(parent);\n+                                }\n+                            }\n+                            Entry::Vacant(entry) => {\n                                 entry.insert(parent);\n+                                bfs_queue.push_back(child);\n                             }\n                         }\n-                        Entry::Vacant(entry) => {\n-                            entry.insert(parent);\n-                            bfs_queue.push_back(child);\n-                        }\n                     }\n                 };\n \n@@ -432,7 +432,7 @@ impl cstore::CStore {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n-        } else if data.name == sym::proc_macro && data.item_name(id.index) == \"quote\" {\n+        } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n "}, {"sha": "d2ba82b5a1c9f04df492895bcc356a63c593db22", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -29,7 +29,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n-use syntax::symbol::{InternedString, sym};\n+use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -497,12 +497,13 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> InternedString {\n+    pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n         self.def_key(item_index)\n             .disambiguated_data\n             .data\n             .get_opt_name()\n             .expect(\"no name in item_name\")\n+            .as_symbol()\n     }\n \n     pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n@@ -568,15 +569,15 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::from_interned_str(self.item_name(index)),\n+            Ident::with_empty_ctxt(self.item_name(index)),\n             variant_did,\n             ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::from_interned_str(self.item_name(index)),\n+                    ident: Ident::with_empty_ctxt(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -787,7 +788,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::from_interned_str(self.item_name(child_index)),\n+                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });\n@@ -982,7 +983,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(index).as_symbol())\n+            .map(|index| self.item_name(index))\n             .collect()\n     }\n "}, {"sha": "7f0993e799f5424031d143c432de3e0624cda489", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -34,7 +34,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{keywords, sym};\n-use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n+use syntax_pos::{self, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n use rustc::hir::{self, PatKind};\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hash: tcx.crate_hash(LOCAL_CRATE),\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: tcx.sess.panic_strategy(),\n-            edition: hygiene::default_edition(),\n+            edition: tcx.sess.edition(),\n             has_global_allocator: has_global_allocator,\n             has_panic_handler: has_panic_handler,\n             has_default_lib_allocator: has_default_lib_allocator,"}, {"sha": "b9224d973fe7b8fe9ca69f731aca2b72c3733971", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::query::Providers;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use rustc_target::spec::abi::Abi;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, sym};\n \n use std::fmt;\n use std::iter;\n@@ -100,9 +100,9 @@ fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n             let name = tcx.item_name(def_id);\n-            if name == \"clone\" {\n+            if name == sym::clone {\n                 build_clone_shim(tcx, def_id, ty)\n-            } else if name == \"clone_from\" {\n+            } else if name == sym::clone_from {\n                 debug!(\"make_shim({:?}: using default trait implementation\", instance);\n                 return tcx.optimized_mir(def_id);\n             } else {"}, {"sha": "780b3c9686b6a27c9a193753cbb4abe0e7836185", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -212,8 +212,8 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     // Create a statement which reads the discriminant into a temporary\n     fn get_discr(&self, mir: &mut Mir<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n         let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, mir.span);\n-        let temp = Place::Base(PlaceBase::Local(Local::new(mir.local_decls.len())));\n-        mir.local_decls.push(temp_decl);\n+        let local_decls_len = mir.local_decls.push(temp_decl);\n+        let temp = Place::Base(PlaceBase::Local(local_decls_len));\n \n         let self_place = Place::Base(PlaceBase::Local(self_arg()));\n         let assign = Statement {"}, {"sha": "84e2caec68e1ccfb58137f46a390a3674ffab453", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -544,14 +544,14 @@ impl Qualif for IsNotImplicitlyPromotable {\n // Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n macro_rules! static_assert_seq_qualifs {\n     ($i:expr => $first:ident $(, $rest:ident)*) => {\n-        static_assert!(SEQ_QUALIFS: {\n+        static_assert!({\n             static_assert_seq_qualifs!($i + 1 => $($rest),*);\n \n             $first::IDX == $i\n         });\n     };\n     ($i:expr =>) => {\n-        static_assert!(SEQ_QUALIFS: QUALIF_COUNT == $i);\n+        static_assert!(QUALIF_COUNT == $i);\n     };\n }\n static_assert_seq_qualifs!("}, {"sha": "7d2dbff996d084148c098ff0ebab4e34c7e468f4", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -223,7 +223,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if let ty::FnDef(def_id, _) = func.ty.sty {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {\n+                    if abi == Abi::RustIntrinsic && name == sym::rustc_peek {\n                         return Some((args, source_info.span));\n                     }\n                 }"}, {"sha": "2ed6f868fa1ee7cd818a675eaea810b59cbb5b1e", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -6,7 +6,6 @@ use rustc::util::nodemap::FxHashMap;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::hygiene;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -130,7 +129,7 @@ impl<'a> Registry<'a> {\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             unstable_feature: None,\n-            edition: hygiene::default_edition(),\n+            edition: self.sess.edition(),\n         });\n     }\n "}, {"sha": "d07f7b65275f19f3ac3f6e80083dd49b2d89d276", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -17,7 +17,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark};\n+use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{\n     feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n@@ -1100,7 +1100,7 @@ impl<'a> Resolver<'a> {\n         let def_id = self.definitions.local_def_id(item.id);\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n-                                               item, hygiene::default_edition()));\n+                                               item, self.session.edition()));\n         self.macro_map.insert(def_id, ext);\n \n         let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };"}, {"sha": "67113787915a3e251b455c5d117d87faabbd219f", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -418,7 +418,7 @@ mod test {\n     use syntax::attr;\n     use syntax::source_map::dummy_spanned;\n     use syntax::symbol::Symbol;\n-    use syntax::with_globals;\n+    use syntax::with_default_globals;\n \n     fn word_cfg(s: &str) -> Cfg {\n         Cfg::Cfg(Symbol::intern(s), None)\n@@ -466,7 +466,7 @@ mod test {\n \n     #[test]\n     fn test_cfg_not() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             assert_eq!(!Cfg::False, Cfg::True);\n             assert_eq!(!Cfg::True, Cfg::False);\n             assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n@@ -484,7 +484,7 @@ mod test {\n \n     #[test]\n     fn test_cfg_and() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mut x = Cfg::False;\n             x &= Cfg::True;\n             assert_eq!(x, Cfg::False);\n@@ -536,7 +536,7 @@ mod test {\n \n     #[test]\n     fn test_cfg_or() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mut x = Cfg::True;\n             x |= Cfg::False;\n             assert_eq!(x, Cfg::True);\n@@ -588,7 +588,7 @@ mod test {\n \n     #[test]\n     fn test_parse_ok() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n@@ -622,7 +622,7 @@ mod test {\n \n     #[test]\n     fn test_parse_err() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mi = attr::mk_name_value_item(\n                 DUMMY_SP,\n                 Ident::from_str(\"foo\"),\n@@ -661,7 +661,7 @@ mod test {\n \n     #[test]\n     fn test_render_short_html() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             assert_eq!(\n                 word_cfg(\"unix\").render_short_html(),\n                 \"Unix\"\n@@ -741,7 +741,7 @@ mod test {\n \n     #[test]\n     fn test_render_long_html() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             assert_eq!(\n                 word_cfg(\"unix\").render_long_html(),\n                 \"This is supported on <strong>Unix</strong> only.\""}, {"sha": "6d03a5ad63bbbb237b960a16d94b795b59cf81ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1702,7 +1702,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime => None,\n             ty::GenericParamDefKind::Type { .. } => {\n-                if param.name == keywords::SelfUpper.name().as_str() {\n+                if param.name.as_symbol() == keywords::SelfUpper.name() {\n                     assert_eq!(param.index, 0);\n                     return None;\n                 }"}, {"sha": "ffe277ae50bdc39616b7230ba7b0f760f43712e1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -94,9 +94,7 @@ pub fn main() {\n     rustc_driver::set_sigpipe_handler();\n     env_logger::init();\n     let res = std::thread::Builder::new().stack_size(thread_stack_size).spawn(move || {\n-        rustc_interface::interface::default_thread_pool(move || {\n-            get_args().map(|args| main_args(&args)).unwrap_or(1)\n-        })\n+        get_args().map(|args| main_args(&args)).unwrap_or(1)\n     }).unwrap().join().unwrap_or(rustc_driver::EXIT_FAILURE);\n     process::exit(res);\n }\n@@ -382,7 +380,12 @@ fn main_args(args: &[String]) -> i32 {\n         Ok(opts) => opts,\n         Err(code) => return code,\n     };\n+    rustc_interface::interface::default_thread_pool(options.edition, move || {\n+        main_options(options)\n+    })\n+}\n \n+fn main_options(options: config::Options) -> i32 {\n     let diag = core::new_handler(options.error_format,\n                                  None,\n                                  options.debugging_options.treat_err_as_bug,"}, {"sha": "d76d4380755f24b40b4d97e48f323663b53708c7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -8,6 +8,7 @@ use rustc::session::config::{OutputType, OutputTypes, Externs, CodegenOptions};\n use rustc::session::search_paths::SearchPath;\n use rustc::util::common::ErrorReported;\n use syntax::ast;\n+use syntax::with_globals;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -386,13 +387,11 @@ pub fn make_test(s: &str,\n \n     // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n-    let (already_has_main, already_has_extern_crate, found_macro) = crate::syntax::with_globals(|| {\n+    let (already_has_main, already_has_extern_crate, found_macro) = with_globals(edition, || {\n         use crate::syntax::{parse::{self, ParseSess}, source_map::FilePathMapping};\n         use errors::emitter::EmitterWriter;\n         use errors::Handler;\n \n-        syntax::ext::hygiene::set_default_edition(edition);\n-\n         let filename = FileName::anon_source_code(s);\n         let source = crates + &everything_else;\n "}, {"sha": "2a553b2c93bd3939b0b270d534a85555de7783a3", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -150,7 +150,7 @@ impl Command {\n              match cvt(syscall::clone(0))? {\n                  0 => {\n                      drop(input);\n-                     let err = self.do_exec(theirs);\n+                     let Err(err) = self.do_exec(theirs);\n                      let errno = err.raw_os_error().unwrap_or(syscall::EINVAL) as u32;\n                      let bytes = [\n                          (errno >> 24) as u8,\n@@ -218,7 +218,10 @@ impl Command {\n         }\n \n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Ok((_, theirs)) => unsafe {\n+                let Err(e) = self.do_exec(theirs);\n+                e\n+            },\n             Err(e) => e,\n         }\n     }\n@@ -253,45 +256,38 @@ impl Command {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke syscall::exit)\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> Result<!, io::Error> {\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt(syscall::dup2(fd, 2, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(2, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 2, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(2, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(2, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(2, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt(syscall::dup2(fd, 1, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(1, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 1, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(1, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(1, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(1, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt(syscall::dup2(fd, 0, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(0, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 0, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(0, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(0, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(0, syscall::F_SETFD, flags))?;\n         }\n \n         if let Some(g) = self.gid {\n-            t!(cvt(syscall::setregid(g as usize, g as usize)));\n+            cvt(syscall::setregid(g as usize, g as usize))?;\n         }\n         if let Some(u) = self.uid {\n-            t!(cvt(syscall::setreuid(u as usize, u as usize)));\n+            cvt(syscall::setreuid(u as usize, u as usize))?;\n         }\n         if let Some(ref cwd) = self.cwd {\n-            t!(cvt(syscall::chdir(cwd)));\n+            cvt(syscall::chdir(cwd))?;\n         }\n \n         for callback in self.closures.iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         self.env.apply();\n@@ -313,9 +309,9 @@ impl Command {\n         };\n \n         let mut file = if let Some(program) = program {\n-            t!(File::open(program.as_os_str()))\n+            File::open(program.as_os_str())?\n         } else {\n-            return io::Error::from_raw_os_error(syscall::ENOENT);\n+            return Err(io::Error::from_raw_os_error(syscall::ENOENT));\n         };\n \n         // Push all the arguments\n@@ -327,7 +323,7 @@ impl Command {\n             let mut shebang = [0; 2];\n             let mut read = 0;\n             loop {\n-                match t!(reader.read(&mut shebang[read..])) {\n+                match reader.read(&mut shebang[read..])? {\n                     0 => break,\n                     n => read += n,\n                 }\n@@ -338,9 +334,9 @@ impl Command {\n                 // First of all, since we'll be passing another file to\n                 // fexec(), we need to manually check that we have permission\n                 // to execute this file:\n-                let uid = t!(cvt(syscall::getuid()));\n-                let gid = t!(cvt(syscall::getgid()));\n-                let meta = t!(file.metadata());\n+                let uid = cvt(syscall::getuid())?;\n+                let gid = cvt(syscall::getgid())?;\n+                let meta = file.metadata()?;\n \n                 let mode = if uid == meta.uid() as usize {\n                     meta.mode() >> 3*2 & 0o7\n@@ -350,12 +346,12 @@ impl Command {\n                     meta.mode() & 0o7\n                 };\n                 if mode & 1 == 0 {\n-                    return io::Error::from_raw_os_error(syscall::EPERM);\n+                    return Err(io::Error::from_raw_os_error(syscall::EPERM));\n                 }\n \n                 // Second of all, we need to actually read which interpreter it wants\n                 let mut interpreter = Vec::new();\n-                t!(reader.read_until(b'\\n', &mut interpreter));\n+                reader.read_until(b'\\n', &mut interpreter)?;\n                 // Pop one trailing newline, if any\n                 if interpreter.ends_with(&[b'\\n']) {\n                     interpreter.pop().unwrap();\n@@ -373,11 +369,11 @@ impl Command {\n         };\n         if let Some(ref interpreter) = interpreter {\n             let path: &OsStr = OsStr::from_bytes(&interpreter);\n-            file = t!(File::open(path));\n+            file = File::open(path)?;\n \n             args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n         } else {\n-            t!(file.seek(SeekFrom::Start(0)));\n+            file.seek(SeekFrom::Start(0))?;\n         }\n \n         args.push([self.program.as_ptr() as usize, self.program.len()]);\n@@ -396,13 +392,12 @@ impl Command {\n         }\n \n         if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n-            io::Error::from_raw_os_error(err.errno as i32)\n+            Err(io::Error::from_raw_os_error(err.errno as i32))\n         } else {\n             panic!(\"return from exec without err\");\n         }\n     }\n \n-\n     fn setup_io(&self, default: Stdio, needs_stdin: bool)\n                 -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;"}, {"sha": "80fe763aecc888266398d400e8ce0feb87895349", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -47,7 +47,7 @@ impl Command {\n             match result {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs, envp.as_ref());\n+                    let Err(err) = self.do_exec(theirs, envp.as_ref());\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -123,7 +123,8 @@ impl Command {\n                     // environment lock before we try to exec.\n                     let _lock = sys::os::env_lock();\n \n-                    self.do_exec(theirs, envp.as_ref())\n+                    let Err(e) = self.do_exec(theirs, envp.as_ref());\n+                    e\n                 }\n             }\n             Err(e) => e,\n@@ -164,29 +165,22 @@ impl Command {\n         &mut self,\n         stdio: ChildPipes,\n         maybe_envp: Option<&CStringArray>\n-    ) -> io::Error {\n+    ) -> Result<!, io::Error> {\n         use crate::sys::{self, cvt_r};\n \n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n         if cfg!(not(any(target_os = \"l4re\"))) {\n             if let Some(u) = self.get_gid() {\n-                t!(cvt(libc::setgid(u as gid_t)));\n+                cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n                 // When dropping privileges from root, the `setgroups` call\n@@ -198,11 +192,11 @@ impl Command {\n                 // privilege dropping function.\n                 let _ = libc::setgroups(0, ptr::null());\n \n-                t!(cvt(libc::setuid(u as uid_t)));\n+                cvt(libc::setuid(u as uid_t))?;\n             }\n         }\n         if let Some(ref cwd) = *self.get_cwd() {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n+            cvt(libc::chdir(cwd.as_ptr()))?;\n         }\n \n         // emscripten has no signal support.\n@@ -225,18 +219,18 @@ impl Command {\n                              0,\n                              mem::size_of::<libc::sigset_t>());\n             } else {\n-                t!(cvt(libc::sigemptyset(&mut set)));\n+                cvt(libc::sigemptyset(&mut set))?;\n             }\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                         ptr::null_mut())));\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                         ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n-                return io::Error::last_os_error()\n+                return Err(io::Error::last_os_error())\n             }\n         }\n \n         for callback in self.get_closures().iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         // Although we're performing an exec here we may also return with an\n@@ -261,7 +255,7 @@ impl Command {\n         }\n \n         libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n-        io::Error::last_os_error()\n+        Err(io::Error::last_os_error())\n     }\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"freebsd\","}, {"sha": "489fac4f1ca4c642d8a5c290d3e86391abc8afef", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -5,7 +5,7 @@ use crate::attr::HasAttrs;\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{Mark, SyntaxContext, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -713,7 +713,7 @@ impl SyntaxExtension {\n         }\n     }\n \n-    pub fn edition(&self) -> Edition {\n+    pub fn edition(&self, default_edition: Edition) -> Edition {\n         match *self {\n             SyntaxExtension::NormalTT { edition, .. } |\n             SyntaxExtension::DeclMacro { edition, .. } |\n@@ -725,7 +725,7 @@ impl SyntaxExtension {\n             SyntaxExtension::IdentTT { .. } |\n             SyntaxExtension::MultiDecorator(..) |\n             SyntaxExtension::MultiModifier(..) |\n-            SyntaxExtension::BuiltinDerive(..) => hygiene::default_edition(),\n+            SyntaxExtension::BuiltinDerive(..) => default_edition,\n         }\n     }\n }\n@@ -734,6 +734,7 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n+\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n \n     fn resolve_dollar_crates(&mut self, fragment: &AstFragment);\n@@ -768,6 +769,7 @@ pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n+\n     fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n \n     fn resolve_dollar_crates(&mut self, _fragment: &AstFragment) {}"}, {"sha": "6e789c4c7086b71ad6036a0654573b2a02ee6b8e", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1,6 +1,6 @@\n use crate::attr::HasAttrs;\n use crate::ast;\n-use crate::source_map::{hygiene, ExpnInfo, ExpnFormat};\n+use crate::source_map::{ExpnInfo, ExpnFormat};\n use crate::ext::base::ExtCtxt;\n use crate::ext::build::AstBuilder;\n use crate::parse::parser::PathStyle;\n@@ -64,7 +64,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n-        edition: hygiene::default_edition(),\n+        edition: cx.parse_sess.edition,\n     });\n \n     let span = span.with_ctxt(cx.backtrace());"}, {"sha": "478ae4de82b74958eb23ed5942171a7a25c47e76", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, resp\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n-use crate::ext::hygiene::{self, Mark, SyntaxContext};\n+use crate::ext::hygiene::{Mark, SyntaxContext};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -560,7 +560,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: ext.edition(),\n+            edition: ext.edition(self.cx.parse_sess.edition),\n         });\n \n         match *ext {\n@@ -805,7 +805,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         allow_internal_unstable: allow_internal_unstable.clone(),\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n-                        edition: hygiene::default_edition(),\n+                        edition: self.cx.parse_sess.edition,\n                     });\n \n                     let input: Vec<_> = mac.node.stream().into_trees().collect();\n@@ -921,7 +921,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: ext.edition(),\n+            edition: ext.edition(self.cx.parse_sess.edition),\n         };\n \n         match *ext {"}, {"sha": "5eda975bc9ee464c62c8aafedcde336a1b5c0118", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -29,6 +29,7 @@ use rustc_data_structures::sync::Lock;\n use rustc_data_structures::bit_set::GrowableBitSet;\n pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n+use syntax_pos::edition::Edition;\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n@@ -82,26 +83,32 @@ pub struct Globals {\n }\n \n impl Globals {\n-    fn new() -> Globals {\n+    fn new(edition: Edition) -> Globals {\n         Globals {\n             // We have no idea how many attributes their will be, so just\n             // initiate the vectors with 0 bits. We'll grow them as necessary.\n             used_attrs: Lock::new(GrowableBitSet::new_empty()),\n             known_attrs: Lock::new(GrowableBitSet::new_empty()),\n-            syntax_pos_globals: syntax_pos::Globals::new(),\n+            syntax_pos_globals: syntax_pos::Globals::new(edition),\n         }\n     }\n }\n \n-pub fn with_globals<F, R>(f: F) -> R\n+pub fn with_globals<F, R>(edition: Edition, f: F) -> R\n     where F: FnOnce() -> R\n {\n-    let globals = Globals::new();\n+    let globals = Globals::new(edition);\n     GLOBALS.set(&globals, || {\n         syntax_pos::GLOBALS.set(&globals.syntax_pos_globals, f)\n     })\n }\n \n+pub fn with_default_globals<F, R>(f: F) -> R\n+    where F: FnOnce() -> R\n+{\n+    with_globals(edition::DEFAULT_EDITION, f)\n+}\n+\n scoped_tls::scoped_thread_local!(pub static GLOBALS: Globals);\n \n #[macro_use]"}, {"sha": "8fdd15a029f13808d002543c65656ee71884040c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1305,7 +1305,7 @@ mod tests {\n     use crate::util::parser_testing::{string_to_crate, matches_codepattern};\n     use crate::print::pprust;\n     use crate::mut_visit;\n-    use crate::with_globals;\n+    use crate::with_default_globals;\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n@@ -1343,7 +1343,7 @@ mod tests {\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mut zz_visitor = ToZzIdentMutVisitor;\n             let mut krate = string_to_crate(\n                 \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_string());\n@@ -1358,7 +1358,7 @@ mod tests {\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let mut zz_visitor = ToZzIdentMutVisitor;\n             let mut krate = string_to_crate(\n                 \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\"}, {"sha": "c97d804076157e039d827e66c61acd6a9f22adf0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1558,10 +1558,10 @@ mod tests {\n     use crate::feature_gate::UnstableFeatures;\n     use crate::parse::token;\n     use crate::diagnostics::plugin::ErrorMap;\n-    use crate::with_globals;\n+    use crate::with_default_globals;\n     use std::io;\n     use std::path::PathBuf;\n-    use syntax_pos::{BytePos, Span, NO_EXPANSION};\n+    use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n     use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n     use rustc_data_structures::sync::Lock;\n \n@@ -1581,6 +1581,7 @@ mod tests {\n             raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             buffered_lints: Lock::new(vec![]),\n+            edition: Edition::from_session(),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n         }\n     }\n@@ -1601,7 +1602,7 @@ mod tests {\n \n     #[test]\n     fn t1() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             let mut string_reader = setup(&sm,\n@@ -1649,7 +1650,7 @@ mod tests {\n \n     #[test]\n     fn doublecolonparsing() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             check_tokenization(setup(&sm, &sh, \"a b\".to_string()),\n@@ -1659,7 +1660,7 @@ mod tests {\n \n     #[test]\n     fn dcparsing_2() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             check_tokenization(setup(&sm, &sh, \"a::b\".to_string()),\n@@ -1669,7 +1670,7 @@ mod tests {\n \n     #[test]\n     fn dcparsing_3() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             check_tokenization(setup(&sm, &sh, \"a ::b\".to_string()),\n@@ -1679,7 +1680,7 @@ mod tests {\n \n     #[test]\n     fn dcparsing_4() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             check_tokenization(setup(&sm, &sh, \"a:: b\".to_string()),\n@@ -1689,7 +1690,7 @@ mod tests {\n \n     #[test]\n     fn character_a() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             assert_eq!(setup(&sm, &sh, \"'a'\".to_string()).next_token().tok,\n@@ -1699,7 +1700,7 @@ mod tests {\n \n     #[test]\n     fn character_space() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             assert_eq!(setup(&sm, &sh, \"' '\".to_string()).next_token().tok,\n@@ -1709,7 +1710,7 @@ mod tests {\n \n     #[test]\n     fn character_escaped() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             assert_eq!(setup(&sm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n@@ -1719,7 +1720,7 @@ mod tests {\n \n     #[test]\n     fn lifetime_name() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             assert_eq!(setup(&sm, &sh, \"'abc\".to_string()).next_token().tok,\n@@ -1729,7 +1730,7 @@ mod tests {\n \n     #[test]\n     fn raw_string() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             assert_eq!(setup(&sm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n@@ -1741,7 +1742,7 @@ mod tests {\n \n     #[test]\n     fn literal_suffixes() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             macro_rules! test {\n@@ -1787,7 +1788,7 @@ mod tests {\n \n     #[test]\n     fn nested_block_comments() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             let mut lexer = setup(&sm, &sh, \"/* /* */ */'a'\".to_string());\n@@ -1802,7 +1803,7 @@ mod tests {\n \n     #[test]\n     fn crlf_comments() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(sm.clone());\n             let mut lexer = setup(&sm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());"}, {"sha": "1073fc6f3ab4d3a00e760aa918fdb2a9a92a7772", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -13,6 +13,7 @@ use crate::print::pprust::token_to_string;\n use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::{Lrc, Lock};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n+use syntax_pos::edition::Edition;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use std::borrow::Cow;\n@@ -38,6 +39,7 @@ pub struct ParseSess {\n     pub span_diagnostic: Handler,\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n+    pub edition: Edition,\n     pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n@@ -74,6 +76,7 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n+            edition: Edition::from_session(),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n         }\n     }\n@@ -329,6 +332,23 @@ pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n     Parser::new(sess, stream, None, true, false)\n }\n \n+/// Given stream, the `ParseSess` and the base directory, produces a parser.\n+///\n+/// Use this function when you are creating a parser from the token stream\n+/// and also care about the current working directory of the parser (e.g.,\n+/// you are trying to resolve modules defined inside a macro invocation).\n+///\n+/// # Note\n+///\n+/// The main usage of this function is outside of rustc, for those who uses\n+/// libsyntax as a library. Please do not remove this function while refactoring\n+/// just because it is not used in rustc codebase!\n+pub fn stream_to_parser_with_base_dir<'a>(sess: &'a ParseSess,\n+                                          stream: TokenStream,\n+                                          base_dir: Directory<'a>) -> Parser<'a> {\n+    Parser::new(sess, stream, Some(base_dir), true, false)\n+}\n+\n /// A sequence separator.\n pub struct SeqSep {\n     /// The seperator token.\n@@ -363,7 +383,7 @@ mod tests {\n     use crate::tokenstream::{DelimSpan, TokenTree};\n     use crate::util::parser_testing::string_to_stream;\n     use crate::util::parser_testing::{string_to_expr, string_to_item};\n-    use crate::with_globals;\n+    use crate::with_default_globals;\n     use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n \n     /// Parses an item.\n@@ -382,15 +402,15 @@ mod tests {\n \n     #[should_panic]\n     #[test] fn bad_path_expr_1() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             string_to_expr(\"::abc::def::return\".to_string());\n         })\n     }\n \n     // check the token-tree-ization of macros\n     #[test]\n     fn string_to_tts_macro () {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             use crate::symbol::sym;\n \n             let tts: Vec<_> =\n@@ -447,7 +467,7 @@ mod tests {\n \n     #[test]\n     fn string_to_tts_1() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let tts = string_to_stream(\"fn a (b : i32) { b; }\".to_string());\n \n             let expected = TokenStream::new(vec![\n@@ -480,7 +500,7 @@ mod tests {\n     }\n \n     #[test] fn parse_use() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let use_s = \"use foo::bar::baz;\";\n             let vitem = string_to_item(use_s.to_string()).unwrap();\n             let vitem_s = item_to_string(&vitem);\n@@ -494,7 +514,7 @@ mod tests {\n     }\n \n     #[test] fn parse_extern_crate() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let ex_s = \"extern crate foo;\";\n             let vitem = string_to_item(ex_s.to_string()).unwrap();\n             let vitem_s = item_to_string(&vitem);\n@@ -531,7 +551,7 @@ mod tests {\n     }\n \n     #[test] fn span_of_self_arg_pat_idents_are_correct() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n \n             let srcs = [\"impl z { fn a (&self, &myarg: i32) {} }\",\n                         \"impl z { fn a (&mut self, &myarg: i32) {} }\",\n@@ -551,15 +571,15 @@ mod tests {\n     }\n \n     #[test] fn parse_exprs () {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             // just make sure that they parse....\n             string_to_expr(\"3 + 4\".to_string());\n             string_to_expr(\"a::z.froob(b,&(987+3))\".to_string());\n         })\n     }\n \n     #[test] fn attrs_fix_bug () {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<Box<Writer>, String> {\n     #[cfg(windows)]\n@@ -576,7 +596,7 @@ mod tests {\n     }\n \n     #[test] fn crlf_doc_comments() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             use crate::symbol::sym;\n \n             let sess = ParseSess::new(FilePathMapping::empty());\n@@ -613,7 +633,7 @@ mod tests {\n             new_parser_from_source_str(sess, name, source).parse_expr()\n         }\n \n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sess = ParseSess::new(FilePathMapping::empty());\n             let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n                 \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n@@ -637,7 +657,7 @@ mod tests {\n     // See `recurse_into_file_modules` in the parser.\n     #[test]\n     fn out_of_line_mod() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let sess = ParseSess::new(FilePathMapping::empty());\n             let item = parse_item_from_source_str(\n                 PathBuf::from(\"foo\").into(),"}, {"sha": "ac240359b56b6f68387852472028a725640997e1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -3147,12 +3147,12 @@ mod tests {\n \n     use crate::ast;\n     use crate::source_map;\n-    use crate::with_globals;\n+    use crate::with_default_globals;\n     use syntax_pos;\n \n     #[test]\n     fn test_fun_to_string() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let abba_ident = ast::Ident::from_str(\"abba\");\n \n             let decl = ast::FnDecl {\n@@ -3180,7 +3180,7 @@ mod tests {\n \n     #[test]\n     fn test_variant_to_string() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let ident = ast::Ident::from_str(\"principal_skinner\");\n \n             let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {"}, {"sha": "8a210db91858ebb046da7023e668b6886d1478f8", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -947,7 +947,7 @@ impl SourceMap {\n             allow_internal_unstable,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: hygiene::default_edition(),\n+            edition: edition::Edition::from_session(),\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }"}, {"sha": "e01a3260d4993a5e878ef3bc8e92ca617eb0470b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -3,7 +3,7 @@ use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n use crate::symbol::{Ident, Symbol, keywords, sym};\n-use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n+use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n \n@@ -14,7 +14,7 @@ use syntax_pos::{DUMMY_SP, Span};\n /// Craft a span that will be ignored by the stability lint's\n /// call to source_map's `is_internal` check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n-fn ignored_span(sp: Span) -> Span {\n+fn ignored_span(sp: Span, edition: Edition) -> Span {\n     let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n@@ -25,7 +25,7 @@ fn ignored_span(sp: Span) -> Span {\n         ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n-        edition: hygiene::default_edition(),\n+        edition,\n     });\n     sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }\n@@ -94,7 +94,7 @@ pub fn maybe_inject_crates_ref(\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let span = ignored_span(DUMMY_SP);\n+    let span = ignored_span(DUMMY_SP, edition);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,"}, {"sha": "7cd83f3e495be5a1094b2a56f56b79c9124eea9b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -291,7 +291,7 @@ fn generate_test_harness(sess: &ParseSess,\n         ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n-        edition: hygiene::default_edition(),\n+        edition: sess.edition,\n     });\n \n     TestHarnessGenerator {"}, {"sha": "107cbe70a23d7aef0d4a1058f41da25bf3bd9be2", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1,5 +1,5 @@\n use crate::source_map::{SourceMap, FilePathMapping};\n-use crate::with_globals;\n+use crate::with_default_globals;\n \n use errors::Handler;\n use errors::emitter::EmitterWriter;\n@@ -39,7 +39,7 @@ impl<T: Write> Write for Shared<T> {\n }\n \n fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &str) {\n-    with_globals(|| {\n+    with_default_globals(|| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n         let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));"}, {"sha": "79efc6bf689c4c8b75f09fa1178ccc124124a67a", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -557,7 +557,7 @@ impl DelimSpan {\n mod tests {\n     use super::*;\n     use crate::syntax::ast::Ident;\n-    use crate::with_globals;\n+    use crate::with_default_globals;\n     use crate::parse::token::Token;\n     use crate::util::parser_testing::string_to_stream;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION};\n@@ -572,7 +572,7 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"foo::bar::baz\");\n             let test_fst = string_to_ts(\"foo::bar\");\n             let test_snd = string_to_ts(\"::baz\");\n@@ -585,7 +585,7 @@ mod tests {\n \n     #[test]\n     fn test_to_from_bijection() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_start = string_to_ts(\"foo::bar(baz)\");\n             let test_end = test_start.trees().collect();\n             assert_eq!(test_start, test_end)\n@@ -594,7 +594,7 @@ mod tests {\n \n     #[test]\n     fn test_eq_0() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"foo\");\n             let test_eqs = string_to_ts(\"foo\");\n             assert_eq!(test_res, test_eqs)\n@@ -603,7 +603,7 @@ mod tests {\n \n     #[test]\n     fn test_eq_1() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"::bar::baz\");\n             let test_eqs = string_to_ts(\"::bar::baz\");\n             assert_eq!(test_res, test_eqs)\n@@ -612,7 +612,7 @@ mod tests {\n \n     #[test]\n     fn test_eq_3() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"\");\n             let test_eqs = string_to_ts(\"\");\n             assert_eq!(test_res, test_eqs)\n@@ -621,7 +621,7 @@ mod tests {\n \n     #[test]\n     fn test_diseq_0() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"::bar::baz\");\n             let test_eqs = string_to_ts(\"bar::baz\");\n             assert_eq!(test_res == test_eqs, false)\n@@ -630,7 +630,7 @@ mod tests {\n \n     #[test]\n     fn test_diseq_1() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test_res = string_to_ts(\"(bar,baz)\");\n             let test_eqs = string_to_ts(\"bar,baz\");\n             assert_eq!(test_res == test_eqs, false)\n@@ -639,7 +639,7 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        with_globals(|| {\n+        with_default_globals(|| {\n             let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n             let test1: TokenStream =\n                 TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\"), false)).into();\n@@ -653,12 +653,14 @@ mod tests {\n \n     #[test]\n     fn test_dotdotdot() {\n-        let mut builder = TokenStreamBuilder::new();\n-        builder.push(TokenTree::Token(sp(0, 1), Token::Dot).joint());\n-        builder.push(TokenTree::Token(sp(1, 2), Token::Dot).joint());\n-        builder.push(TokenTree::Token(sp(2, 3), Token::Dot));\n-        let stream = builder.build();\n-        assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n-        assert_eq!(stream.trees().count(), 1);\n+        with_default_globals(|| {\n+            let mut builder = TokenStreamBuilder::new();\n+            builder.push(TokenTree::Token(sp(0, 1), Token::Dot).joint());\n+            builder.push(TokenTree::Token(sp(1, 2), Token::Dot).joint());\n+            builder.push(TokenTree::Token(sp(2, 3), Token::Dot));\n+            let stream = builder.build();\n+            assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n+            assert_eq!(stream.trees().count(), 1);\n+        })\n     }\n }"}, {"sha": "885b5a4f333b8fc74177f76f3c118e31ac2a70e4", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -101,8 +101,8 @@ fn test_lev_distance() {\n \n #[test]\n fn test_find_best_match_for_name() {\n-    use crate::with_globals;\n-    with_globals(|| {\n+    use crate::with_default_globals;\n+    with_default_globals(|| {\n         let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n         assert_eq!(\n             find_best_match_for_name(input.iter(), \"aaaa\", None),"}, {"sha": "e5fc7aab61db41c57f995805e9ff512546223511", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -42,17 +42,17 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n-use syntax::ext::hygiene;\n use syntax::symbol::Symbol;\n+use syntax::edition::Edition;\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n-                         user_exts: Vec<NamedSyntaxExtension>) {\n+                         user_exts: Vec<NamedSyntaxExtension>,\n+                         edition: Edition) {\n     deriving::register_builtin_derives(resolver);\n \n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n-\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),\n@@ -63,7 +63,7 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n                         unstable_feature: None,\n-                        edition: hygiene::default_edition(),\n+                        edition,\n                     });\n         )* }\n     }\n@@ -108,7 +108,7 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                 allow_internal_unsafe: false,\n                 local_inner_macros: false,\n                 unstable_feature: None,\n-                edition: hygiene::default_edition(),\n+                edition,\n             });\n     register(Symbol::intern(\"format_args_nl\"),\n              NormalTT {\n@@ -120,7 +120,7 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                  allow_internal_unsafe: false,\n                  local_inner_macros: false,\n                  unstable_feature: None,\n-                 edition: hygiene::default_edition(),\n+                 edition,\n              });\n \n     for (name, ext) in user_exts {"}, {"sha": "a13fe65ca0ddf84435fad0d33d5dfd0e6a5ba189", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -4,7 +4,7 @@ use crate::deriving;\n \n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnInfo, MacroAttribute, hygiene, respan};\n+use syntax::source_map::{ExpnInfo, MacroAttribute, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n@@ -358,7 +358,7 @@ fn mk_decls(\n         ].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n-        edition: hygiene::default_edition(),\n+        edition: cx.parse_sess.edition,\n     });\n     let span = DUMMY_SP.apply_mark(mark);\n "}, {"sha": "8ee61a3f67f591b890b728b20266f636e0a47a82", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -3,7 +3,7 @@\n \n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n@@ -72,7 +72,7 @@ pub fn expand_test_or_bench(\n             ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: hygiene::default_edition(),\n+            edition: cx.parse_sess.edition,\n         });\n         (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n          attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))"}, {"sha": "5b1ae167ce31543850a1475dcf5f9379536baaa6", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -11,7 +11,7 @@\n \n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::{Symbol, sym};\n@@ -47,7 +47,7 @@ pub fn expand(\n             ].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: hygiene::default_edition(),\n+            edition: ecx.parse_sess.edition,\n         });\n         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     };"}, {"sha": "20216568426fed72d2938c8d0fdcbee129df52e7", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1,6 +1,7 @@\n use crate::symbol::{Symbol, sym};\n use std::fmt;\n use std::str::FromStr;\n+use crate::GLOBALS;\n \n /// The edition of the compiler (RFC 2052)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n@@ -38,6 +39,10 @@ impl fmt::Display for Edition {\n }\n \n impl Edition {\n+    pub fn from_session() -> Edition {\n+        GLOBALS.with(|globals| globals.edition)\n+    }\n+\n     pub fn lint_name(&self) -> &'static str {\n         match *self {\n             Edition::Edition2015 => \"rust_2015_compatibility\","}, {"sha": "6e787c08504f37872cf2203c889f1db72e06879a", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -7,7 +7,7 @@\n \n use crate::GLOBALS;\n use crate::Span;\n-use crate::edition::{Edition, DEFAULT_EDITION};\n+use crate::edition::Edition;\n use crate::symbol::{keywords, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -174,7 +174,6 @@ crate struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: FxHashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n-    default_edition: Edition,\n }\n \n impl HygieneData {\n@@ -196,7 +195,6 @@ impl HygieneData {\n                 dollar_crate_name: keywords::DollarCrate.name(),\n             }],\n             markings: FxHashMap::default(),\n-            default_edition: DEFAULT_EDITION,\n         }\n     }\n \n@@ -205,14 +203,6 @@ impl HygieneData {\n     }\n }\n \n-pub fn default_edition() -> Edition {\n-    HygieneData::with(|data| data.default_edition)\n-}\n-\n-pub fn set_default_edition(edition: Edition) {\n-    HygieneData::with(|data| data.default_edition = edition);\n-}\n-\n pub fn clear_markings() {\n     HygieneData::with(|data| data.markings = FxHashMap::default());\n }"}, {"sha": "cb5aaf7eb882ffba2f382f7ad2ebfedc12dc69e5", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -26,6 +26,7 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod edition;\n+use edition::Edition;\n pub mod hygiene;\n pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, CompilerDesugaringKind};\n \n@@ -52,14 +53,16 @@ pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n     span_interner: Lock<span_encoding::SpanInterner>,\n     hygiene_data: Lock<hygiene::HygieneData>,\n+    edition: Edition,\n }\n \n impl Globals {\n-    pub fn new() -> Globals {\n+    pub fn new(edition: Edition) -> Globals {\n         Globals {\n             symbol_interner: Lock::new(symbol::Interner::fresh()),\n             span_interner: Lock::new(span_encoding::SpanInterner::default()),\n             hygiene_data: Lock::new(hygiene::HygieneData::new()),\n+            edition,\n         }\n     }\n }\n@@ -356,8 +359,9 @@ impl Span {\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer().expn_info().map_or_else(|| hygiene::default_edition(),\n-                                                    |einfo| einfo.edition)\n+        self.ctxt().outer().expn_info().map_or_else(|| {\n+            Edition::from_session()\n+        }, |einfo| einfo.edition)\n     }\n \n     #[inline]"}, {"sha": "8b07e81e5863790e27daec7e459ffb63e99a4d76", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -1147,7 +1147,7 @@ impl Encodable for LocalInternedString {\n /// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n /// assert_eq!(Symbol::gensym(\"x\").as_interned_str(), Symbol::gensym(\"x\").as_interned_str())\n /// ```\n-#[derive(Clone, Copy, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub struct InternedString {\n     symbol: Symbol,\n }\n@@ -1212,42 +1212,6 @@ impl Ord for InternedString {\n     }\n }\n \n-impl<T: std::ops::Deref<Target = str>> PartialEq<T> for InternedString {\n-    fn eq(&self, other: &T) -> bool {\n-        self.with(|string| string == other.deref())\n-    }\n-}\n-\n-impl PartialEq<InternedString> for InternedString {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        self.symbol == other.symbol\n-    }\n-}\n-\n-impl PartialEq<InternedString> for str {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        other.with(|string| self == string)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a str {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        other.with(|string| *self == string)\n-    }\n-}\n-\n-impl PartialEq<InternedString> for String {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        other.with(|string| self == string)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a String {\n-    fn eq(&self, other: &InternedString) -> bool {\n-        other.with(|string| *self == string)\n-    }\n-}\n-\n impl fmt::Debug for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.with(|str| fmt::Debug::fmt(&str, f))\n@@ -1276,6 +1240,7 @@ impl Encodable for InternedString {\n mod tests {\n     use super::*;\n     use crate::Globals;\n+    use crate::edition;\n \n     #[test]\n     fn interner_tests() {\n@@ -1300,7 +1265,7 @@ mod tests {\n \n     #[test]\n     fn without_first_quote_test() {\n-        GLOBALS.set(&Globals::new(), || {\n+        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n             let i = Ident::from_str(\"'break\");\n             assert_eq!(i.without_first_quote().name, keywords::Break.name());\n         });"}, {"sha": "49e137549c04978dd97d2192cbbb3403598ccc69", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -105,7 +105,7 @@ fn reject_stmt_parse(es: &str) {\n }\n \n fn main() {\n-    syntax::with_globals(|| run());\n+    syntax::with_default_globals(|| run());\n }\n \n fn run() {"}, {"sha": "096701bd9b3ed4b4a56157d833626f608fb75d9a", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -47,6 +47,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             unstable_feature: None,\n-            edition: hygiene::default_edition(),\n+            edition: reg.sess.edition(),\n         });\n }"}, {"sha": "a0dca9b1da4d277a6ef8c3e00e0815b12bb15901", "filename": "src/test/run-pass-fulldeps/mod_dir_path_canonicalized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -13,7 +13,7 @@ use syntax::parse::{self, ParseSess};\n mod gravy;\n \n pub fn main() {\n-    syntax::with_globals(|| parse());\n+    syntax::with_default_globals(|| parse());\n \n     assert_eq!(gravy::foo(), 10);\n }"}, {"sha": "659de9cf6d51b616ba5597ff428dfd4c23b9a024", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -189,7 +189,7 @@ impl MutVisitor for AddParens {\n }\n \n fn main() {\n-    syntax::with_globals(|| run());\n+    syntax::with_default_globals(|| run());\n }\n \n fn run() {"}, {"sha": "45efa30d9919c5b51977350700233a44d5fe6b90", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -15,7 +15,7 @@ error[E0425]: cannot find value `no` in this scope\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0425`.\n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:319:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:320:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n@@ -24,7 +24,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n-', src/librustdoc/test.rs:341:17\n+', src/librustdoc/test.rs:342:17\n \n \n failures:"}, {"sha": "f31b64fbce36a9833696f4de00917060d1737477", "filename": "src/test/rustdoc-ui/unparseable-doc-test.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -13,7 +13,7 @@ error: unterminated double quote string\n \n error: aborting due to previous error\n \n-thread '$DIR/unparseable-doc-test.rs - foo (line 6)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:319:13\n+thread '$DIR/unparseable-doc-test.rs - foo (line 6)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:320:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n "}, {"sha": "3e7c7ab6379d8433d983a66232a85b01d9eed841", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfe70dfcdb0eab5e1e21f419c718e58cf62029b/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=dbfe70dfcdb0eab5e1e21f419c718e58cf62029b", "patch": "@@ -266,7 +266,7 @@ fn main() {\n         *slot.borrow_mut() = Some((None, String::from(\"https://play.rust-lang.org/\")));\n     });\n     let (format, dst) = parse_args();\n-    let result = syntax::with_globals(move || {\n+    let result = syntax::with_default_globals(move || {\n         main_with_result(format, &dst)\n     });\n     if let Err(e) = result {"}]}