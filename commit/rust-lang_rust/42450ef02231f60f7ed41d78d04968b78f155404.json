{"sha": "42450ef02231f60f7ed41d78d04968b78f155404", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNDUwZWYwMjIzMWY2MGY3ZWQ0MWQ3OGQwNDk2OGI3OGYxNTU0MDQ=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-18T15:27:51Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-19T00:44:08Z"}, "message": "Fix formatting in float implementations", "tree": {"sha": "2abd19e16e44fe3606e53c52a6087ac59c5fa6ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2abd19e16e44fe3606e53c52a6087ac59c5fa6ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42450ef02231f60f7ed41d78d04968b78f155404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42450ef02231f60f7ed41d78d04968b78f155404", "html_url": "https://github.com/rust-lang/rust/commit/42450ef02231f60f7ed41d78d04968b78f155404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42450ef02231f60f7ed41d78d04968b78f155404/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bed70a42ecf0747f924c813b3b375d5fd364ffc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bed70a42ecf0747f924c813b3b375d5fd364ffc3", "html_url": "https://github.com/rust-lang/rust/commit/bed70a42ecf0747f924c813b3b375d5fd364ffc3"}], "stats": {"total": 270, "additions": 198, "deletions": 72}, "files": [{"sha": "7525aa80a39742a382751f46356218257f9aae80", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 99, "deletions": 36, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/42450ef02231f60f7ed41d78d04968b78f155404/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42450ef02231f60f7ed41d78d04968b78f155404/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=42450ef02231f60f7ed41d78d04968b78f155404", "patch": "@@ -14,6 +14,7 @@\n \n use prelude::*;\n \n+use cast;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n@@ -213,12 +214,16 @@ impl Neg<f32> for f32 {\n impl Signed for f32 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f32 { unsafe{intrinsics::fabsf32(*self)} }\n+    fn abs(&self) -> f32 {\n+        unsafe { intrinsics::fabsf32(*self) }\n+    }\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 { unsafe{cmath::fdimf(*self, *other)} }\n+    fn abs_sub(&self, other: &f32) -> f32 {\n+        unsafe { cmath::fdimf(*self, *other) }\n+    }\n \n     /// # Returns\n     ///\n@@ -227,7 +232,9 @@ impl Signed for f32 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f32 {\n-        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf32(1.0, *self)} }\n+        if self.is_nan() { NAN } else {\n+            unsafe { intrinsics::copysignf32(1.0, *self) }\n+        }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -250,7 +257,9 @@ impl Bounded for f32 {\n impl Primitive for f32 {}\n \n impl Float for f32 {\n-    fn powi(self, n: i32) -> f32 { unsafe{intrinsics::powif32(self, n)} }\n+    fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n \n     #[inline]\n     fn max(self, other: f32) -> f32 {\n@@ -302,7 +311,7 @@ impl Float for f32 {\n         static EXP_MASK: u32 = 0x7f800000;\n         static MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe {::cast::transmute(self)};\n+        let bits: u32 = unsafe { cast::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -335,7 +344,9 @@ impl Float for f32 {\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n-    fn ldexp(x: f32, exp: int) -> f32 { unsafe{cmath::ldexpf(x, exp as c_int)} }\n+    fn ldexp(x: f32, exp: int) -> f32 {\n+        unsafe { cmath::ldexpf(x, exp as c_int) }\n+    }\n \n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n@@ -353,28 +364,34 @@ impl Float for f32 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(self) -> f32 { unsafe{cmath::expm1f(self)} }\n+    fn exp_m1(self) -> f32 {\n+        unsafe { cmath::expm1f(self) }\n+    }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(self) -> f32 { unsafe{cmath::log1pf(self)} }\n+    fn ln_1p(self) -> f32 {\n+        unsafe { cmath::log1pf(self) }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 { unsafe{intrinsics::fmaf32(self, a, b)} }\n+    fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(self, other: f32) -> f32 { unsafe{cmath::nextafterf(self, other)} }\n+    fn next_after(self, other: f32) -> f32 {\n+        unsafe { cmath::nextafterf(self, other) }\n+    }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe {\n-            ::cast::transmute(self)\n-        };\n+        let bits: u32 = unsafe { cast::transmute(self) };\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -389,19 +406,27 @@ impl Float for f32 {\n \n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(self) -> f32 { unsafe{intrinsics::floorf32(self)} }\n+    fn floor(self) -> f32 {\n+        unsafe { intrinsics::floorf32(self) }\n+    }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(self) -> f32 { unsafe{intrinsics::ceilf32(self)} }\n+    fn ceil(self) -> f32 {\n+        unsafe { intrinsics::ceilf32(self) }\n+    }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(self) -> f32 { unsafe{intrinsics::roundf32(self)} }\n+    fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(self) -> f32 { unsafe{intrinsics::truncf32(self)} }\n+    fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -485,40 +510,62 @@ impl Float for f32 {\n     fn recip(self) -> f32 { 1.0 / self }\n \n     #[inline]\n-    fn powf(self, n: f32) -> f32 { unsafe{intrinsics::powf32(self, n)} }\n+    fn powf(self, n: f32) -> f32 {\n+        unsafe { intrinsics::powf32(self, n) }\n+    }\n \n     #[inline]\n-    fn sqrt(self) -> f32 { unsafe{intrinsics::sqrtf32(self)} }\n+    fn sqrt(self) -> f32 {\n+        unsafe { intrinsics::sqrtf32(self) }\n+    }\n \n     #[inline]\n     fn rsqrt(self) -> f32 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(self) -> f32 { unsafe{cmath::cbrtf(self)} }\n+    fn cbrt(self) -> f32 {\n+        unsafe { cmath::cbrtf(self) }\n+    }\n \n     #[inline]\n-    fn hypot(self, other: f32) -> f32 { unsafe{cmath::hypotf(self, other)} }\n+    fn hypot(self, other: f32) -> f32 {\n+        unsafe { cmath::hypotf(self, other) }\n+    }\n \n     #[inline]\n-    fn sin(self) -> f32 { unsafe{intrinsics::sinf32(self)} }\n+    fn sin(self) -> f32 {\n+        unsafe { intrinsics::sinf32(self) }\n+    }\n \n     #[inline]\n-    fn cos(self) -> f32 { unsafe{intrinsics::cosf32(self)} }\n+    fn cos(self) -> f32 {\n+        unsafe { intrinsics::cosf32(self) }\n+    }\n \n     #[inline]\n-    fn tan(self) -> f32 { unsafe{cmath::tanf(self)} }\n+    fn tan(self) -> f32 {\n+        unsafe { cmath::tanf(self) }\n+    }\n \n     #[inline]\n-    fn asin(self) -> f32 { unsafe{cmath::asinf(self)} }\n+    fn asin(self) -> f32 {\n+        unsafe { cmath::asinf(self) }\n+    }\n \n     #[inline]\n-    fn acos(self) -> f32 { unsafe{cmath::acosf(self)} }\n+    fn acos(self) -> f32 {\n+        unsafe { cmath::acosf(self) }\n+    }\n \n     #[inline]\n-    fn atan(self) -> f32 { unsafe{cmath::atanf(self)} }\n+    fn atan(self) -> f32 {\n+        unsafe { cmath::atanf(self) }\n+    }\n \n     #[inline]\n-    fn atan2(self, other: f32) -> f32 { unsafe{cmath::atan2f(self, other)} }\n+    fn atan2(self, other: f32) -> f32 {\n+        unsafe { cmath::atan2f(self, other) }\n+    }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n@@ -528,36 +575,52 @@ impl Float for f32 {\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(self) -> f32 { unsafe{intrinsics::expf32(self)} }\n+    fn exp(self) -> f32 {\n+        unsafe { intrinsics::expf32(self) }\n+    }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(self) -> f32 { unsafe{intrinsics::exp2f32(self)} }\n+    fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(self) -> f32 { unsafe{intrinsics::logf32(self)} }\n+    fn ln(self) -> f32 {\n+        unsafe { intrinsics::logf32(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n     fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(self) -> f32 { unsafe{intrinsics::log2f32(self)} }\n+    fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(self) -> f32 { unsafe{intrinsics::log10f32(self)} }\n+    fn log10(self) -> f32 {\n+        unsafe { intrinsics::log10f32(self) }\n+    }\n \n     #[inline]\n-    fn sinh(self) -> f32 { unsafe{cmath::sinhf(self)} }\n+    fn sinh(self) -> f32 {\n+        unsafe { cmath::sinhf(self) }\n+    }\n \n     #[inline]\n-    fn cosh(self) -> f32 { unsafe{cmath::coshf(self)} }\n+    fn cosh(self) -> f32 {\n+        unsafe { cmath::coshf(self) }\n+    }\n \n     #[inline]\n-    fn tanh(self) -> f32 { unsafe{cmath::tanhf(self)} }\n+    fn tanh(self) -> f32 {\n+        unsafe { cmath::tanhf(self) }\n+    }\n \n     /// Inverse hyperbolic sine\n     ///"}, {"sha": "7d0ad1029e7fb4b8bb051e54af34600b6e612eef", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 99, "deletions": 36, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/42450ef02231f60f7ed41d78d04968b78f155404/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42450ef02231f60f7ed41d78d04968b78f155404/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=42450ef02231f60f7ed41d78d04968b78f155404", "patch": "@@ -14,6 +14,7 @@\n \n use prelude::*;\n \n+use cast;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n@@ -221,12 +222,16 @@ impl Neg<f64> for f64 {\n impl Signed for f64 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f64 { unsafe{intrinsics::fabsf64(*self)} }\n+    fn abs(&self) -> f64 {\n+        unsafe { intrinsics::fabsf64(*self) }\n+    }\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 { unsafe{cmath::fdim(*self, *other)} }\n+    fn abs_sub(&self, other: &f64) -> f64 {\n+        unsafe { cmath::fdim(*self, *other) }\n+    }\n \n     /// # Returns\n     ///\n@@ -235,7 +240,9 @@ impl Signed for f64 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f64 {\n-        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf64(1.0, *self)} }\n+        if self.is_nan() { NAN } else {\n+            unsafe { intrinsics::copysignf64(1.0, *self) }\n+        }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -308,7 +315,7 @@ impl Float for f64 {\n         static EXP_MASK: u64 = 0x7ff0000000000000;\n         static MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe {::cast::transmute(self)};\n+        let bits: u64 = unsafe { cast::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -341,7 +348,9 @@ impl Float for f64 {\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n-    fn ldexp(x: f64, exp: int) -> f64 { unsafe{cmath::ldexp(x, exp as c_int)} }\n+    fn ldexp(x: f64, exp: int) -> f64 {\n+        unsafe { cmath::ldexp(x, exp as c_int) }\n+    }\n \n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n@@ -359,28 +368,34 @@ impl Float for f64 {\n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(self) -> f64 { unsafe{cmath::expm1(self)} }\n+    fn exp_m1(self) -> f64 {\n+        unsafe { cmath::expm1(self) }\n+    }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(self) -> f64 { unsafe{cmath::log1p(self)} }\n+    fn ln_1p(self) -> f64 {\n+        unsafe { cmath::log1p(self) }\n+    }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 { unsafe{intrinsics::fmaf64(self, a, b)} }\n+    fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(self, other: f64) -> f64 { unsafe{cmath::nextafter(self, other)} }\n+    fn next_after(self, other: f64) -> f64 {\n+        unsafe { cmath::nextafter(self, other) }\n+    }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe {\n-            ::cast::transmute(self)\n-        };\n+        let bits: u64 = unsafe { cast::transmute(self) };\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -395,19 +410,27 @@ impl Float for f64 {\n \n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(self) -> f64 { unsafe{intrinsics::floorf64(self)} }\n+    fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(self) -> f64 { unsafe{intrinsics::ceilf64(self)} }\n+    fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(self) -> f64 { unsafe{intrinsics::roundf64(self)} }\n+    fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(self) -> f64 { unsafe{intrinsics::truncf64(self)} }\n+    fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -491,43 +514,67 @@ impl Float for f64 {\n     fn recip(self) -> f64 { 1.0 / self }\n \n     #[inline]\n-    fn powf(self, n: f64) -> f64 { unsafe{intrinsics::powf64(self, n)} }\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n \n     #[inline]\n-    fn powi(self, n: i32) -> f64 { unsafe{intrinsics::powif64(self, n)} }\n+    fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n \n     #[inline]\n-    fn sqrt(self) -> f64 { unsafe{intrinsics::sqrtf64(self)} }\n+    fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n \n     #[inline]\n     fn rsqrt(self) -> f64 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(self) -> f64 { unsafe{cmath::cbrt(self)} }\n+    fn cbrt(self) -> f64 {\n+        unsafe { cmath::cbrt(self) }\n+    }\n \n     #[inline]\n-    fn hypot(self, other: f64) -> f64 { unsafe{cmath::hypot(self, other)} }\n+    fn hypot(self, other: f64) -> f64 {\n+        unsafe { cmath::hypot(self, other) }\n+    }\n \n     #[inline]\n-    fn sin(self) -> f64 { unsafe{intrinsics::sinf64(self)} }\n+    fn sin(self) -> f64 {\n+        unsafe { intrinsics::sinf64(self) }\n+    }\n \n     #[inline]\n-    fn cos(self) -> f64 { unsafe{intrinsics::cosf64(self)} }\n+    fn cos(self) -> f64 {\n+        unsafe { intrinsics::cosf64(self) }\n+    }\n \n     #[inline]\n-    fn tan(self) -> f64 { unsafe{cmath::tan(self)} }\n+    fn tan(self) -> f64 {\n+        unsafe { cmath::tan(self) }\n+    }\n \n     #[inline]\n-    fn asin(self) -> f64 { unsafe{cmath::asin(self)} }\n+    fn asin(self) -> f64 {\n+        unsafe { cmath::asin(self) }\n+    }\n \n     #[inline]\n-    fn acos(self) -> f64 { unsafe{cmath::acos(self)} }\n+    fn acos(self) -> f64 {\n+        unsafe { cmath::acos(self) }\n+    }\n \n     #[inline]\n-    fn atan(self) -> f64 { unsafe{cmath::atan(self)} }\n+    fn atan(self) -> f64 {\n+        unsafe { cmath::atan(self) }\n+    }\n \n     #[inline]\n-    fn atan2(self, other: f64) -> f64 { unsafe{cmath::atan2(self, other)} }\n+    fn atan2(self, other: f64) -> f64 {\n+        unsafe { cmath::atan2(self, other) }\n+    }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n@@ -537,36 +584,52 @@ impl Float for f64 {\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(self) -> f64 { unsafe{intrinsics::expf64(self)} }\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(self) -> f64 { unsafe{intrinsics::exp2f64(self)} }\n+    fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(self) -> f64 { unsafe{intrinsics::logf64(self)} }\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n     fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(self) -> f64 { unsafe{intrinsics::log2f64(self)} }\n+    fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(self) -> f64 { unsafe{intrinsics::log10f64(self)} }\n+    fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n \n     #[inline]\n-    fn sinh(self) -> f64 { unsafe{cmath::sinh(self)} }\n+    fn sinh(self) -> f64 {\n+        unsafe { cmath::sinh(self) }\n+    }\n \n     #[inline]\n-    fn cosh(self) -> f64 { unsafe{cmath::cosh(self)} }\n+    fn cosh(self) -> f64 {\n+        unsafe { cmath::cosh(self) }\n+    }\n \n     #[inline]\n-    fn tanh(self) -> f64 { unsafe{cmath::tanh(self)} }\n+    fn tanh(self) -> f64 {\n+        unsafe { cmath::tanh(self) }\n+    }\n \n     /// Inverse hyperbolic sine\n     ///"}]}