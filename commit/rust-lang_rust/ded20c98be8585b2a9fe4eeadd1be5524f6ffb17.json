{"sha": "ded20c98be8585b2a9fe4eeadd1be5524f6ffb17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZDIwYzk4YmU4NTg1YjJhOWZlNGVlYWRkMWJlNTUyNGY2ZmZiMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-12T14:18:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-12T14:18:15Z"}, "message": "Auto merge of #75066 - poliorcetics:document-unsafety-in-core-slice, r=LukasKalbertodt\n\nDocument unsafety in library/core/src/slice/mod.rs\n\nRestart where #73555 left off, helping with #66219.", "tree": {"sha": "b5ff39d76481781669074a3fdd9e24ddadc4db48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5ff39d76481781669074a3fdd9e24ddadc4db48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17", "html_url": "https://github.com/rust-lang/rust/commit/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cee14d8c300feb2ac2a949848911bf4c3b143e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee14d8c300feb2ac2a949848911bf4c3b143e70", "html_url": "https://github.com/rust-lang/rust/commit/cee14d8c300feb2ac2a949848911bf4c3b143e70"}, {"sha": "a308e74e1310fb02bcc4b46c44da769dfe426812", "url": "https://api.github.com/repos/rust-lang/rust/commits/a308e74e1310fb02bcc4b46c44da769dfe426812", "html_url": "https://github.com/rust-lang/rust/commit/a308e74e1310fb02bcc4b46c44da769dfe426812"}], "stats": {"total": 220, "additions": 190, "deletions": 30}, "files": [{"sha": "f511ca8eb7851f207aaa809738fb3683e28231a5", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 190, "deletions": 30, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded20c98be8585b2a9fe4eeadd1be5524f6ffb17/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=ded20c98be8585b2a9fe4eeadd1be5524f6ffb17", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! Slice management and manipulation.\n //!\n@@ -70,6 +69,8 @@ impl<T> [T] {\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n+        // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n         unsafe { crate::ptr::Repr { rust: self }.raw.len }\n     }\n \n@@ -443,7 +444,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_ptr_range(&self) -> Range<*const T> {\n-        // The `add` here is safe, because:\n+        let start = self.as_ptr();\n+        // SAFETY: The `add` here is safe, because:\n         //\n         //   - Both pointers are part of the same object, as pointing directly\n         //     past the object also counts.\n@@ -460,7 +462,6 @@ impl<T> [T] {\n         //     the end of the address space.\n         //\n         // See the documentation of pointer::add.\n-        let start = self.as_ptr();\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -484,8 +485,8 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n     #[inline]\n     pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n-        // See as_ptr_range() above for why `add` here is safe.\n         let start = self.as_mut_ptr();\n+        // SAFETY: See as_ptr_range() above for why `add` here is safe.\n         let end = unsafe { start.add(self.len()) };\n         start..end\n     }\n@@ -511,11 +512,15 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn swap(&mut self, a: usize, b: usize) {\n+        // Can't take two mutable loans from one vector, so instead just cast\n+        // them to their raw pointers to do the swap.\n+        let pa: *mut T = &mut self[a];\n+        let pb: *mut T = &mut self[b];\n+        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n+        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n+        // Note that accessing the elements behind `a` and `b` is checked and will\n+        // panic when out of bounds.\n         unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n             ptr::swap(pa, pb);\n         }\n     }\n@@ -554,6 +559,24 @@ impl<T> [T] {\n             // Use the llvm.bswap intrinsic to reverse u8s in a usize\n             let chunk = mem::size_of::<usize>();\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: There are several things to check here:\n+                //\n+                // - Note that `chunk` is either 4 or 8 due to the cfg check\n+                //   above. So `chunk - 1` is positive.\n+                // - Indexing with index `i` is fine as the loop check guarantees\n+                //   `i + chunk - 1 < ln / 2`\n+                //   <=> `i < ln / 2 - (chunk - 1) < ln / 2 < ln`.\n+                // - Indexing with index `ln - i - chunk = ln - (i + chunk)` is fine:\n+                //   - `i + chunk > 0` is trivially true.\n+                //   - The loop check guarantees:\n+                //     `i + chunk - 1 < ln / 2`\n+                //     <=> `i + chunk \u2264 ln / 2 \u2264 ln`, thus subtraction does not underflow.\n+                // - The `read_unaligned` and `write_unaligned` calls are fine:\n+                //   - `pa` points to index `i` where `i < ln / 2 - (chunk - 1)`\n+                //     (see above) and `pb` points to index `ln - i - chunk`, so\n+                //     both are at least `chunk`\n+                //     many bytes away from the end of `self`.\n+                //   - Any initialized memory is valid `usize`.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -570,6 +593,20 @@ impl<T> [T] {\n             // Use rotate-by-16 to reverse u16s in a u32\n             let chunk = mem::size_of::<u32>() / 2;\n             while i + chunk - 1 < ln / 2 {\n+                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n+                // (and obviously `i < ln`), because each element is 2 bytes and\n+                // we're reading 4.\n+                //\n+                // `i + chunk - 1 < ln / 2` # while condition\n+                // `i + 2 - 1 < ln / 2`\n+                // `i + 1 < ln / 2`\n+                //\n+                // Since it's less than the length divided by 2, then it must be\n+                // in bounds.\n+                //\n+                // This also means that the condition `0 < i + chunk <= ln` is\n+                // always respected, ensuring the `pb` pointer can be used\n+                // safely.\n                 unsafe {\n                     let pa: *mut T = self.get_unchecked_mut(i);\n                     let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n@@ -583,8 +620,13 @@ impl<T> [T] {\n         }\n \n         while i < ln / 2 {\n-            // Unsafe swap to avoid the bounds check in safe swap.\n+            // SAFETY: `i` is inferior to half the length of the slice so\n+            // accessing `i` and `ln - i - 1` is safe (`i` starts at 0 and\n+            // will not go further than `ln / 2 - 1`).\n+            // The resulting pointers `pa` and `pb` are therefore valid and\n+            // aligned, and can be read from and written to.\n             unsafe {\n+                // Unsafe swap to avoid the bounds check in safe swap.\n                 let pa: *mut T = self.get_unchecked_mut(i);\n                 let pb: *mut T = self.get_unchecked_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n@@ -609,8 +651,24 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n+        let ptr = self.as_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -637,8 +695,24 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n+        let ptr = self.as_mut_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_mut_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -1107,6 +1181,8 @@ impl<T> [T] {\n         let len = self.len();\n         let ptr = self.as_mut_ptr();\n \n+        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n+        // fulfills the requirements of `from_raw_parts_mut`.\n         unsafe {\n             assert!(mid <= len);\n \n@@ -1655,14 +1731,14 @@ impl<T> [T] {\n         while size > 1 {\n             let half = size / 2;\n             let mid = base + half;\n-            // mid is always in [0, size), that means mid is >= 0 and < size.\n-            // mid >= 0: by definition\n-            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n+            // SAFETY: the call is made safe by the following inconstants:\n+            // - `mid >= 0`: by definition\n+            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n             let cmp = f(unsafe { s.get_unchecked(mid) });\n             base = if cmp == Greater { base } else { mid };\n             size -= half;\n         }\n-        // base is always in [0, size) because base <= mid.\n+        // SAFETY: base is always in [0, size) because base <= mid.\n         let cmp = f(unsafe { s.get_unchecked(base) });\n         if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n     }\n@@ -2120,6 +2196,21 @@ impl<T> [T] {\n         let mut next_read: usize = 1;\n         let mut next_write: usize = 1;\n \n+        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n+        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n+        // one element before `ptr_write`, but `next_write` starts at 1, so\n+        // `prev_ptr_write` is never less than 0 and is inside the slice.\n+        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n+        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n+        // and `prev_ptr_write.offset(1)`.\n+        //\n+        // `next_write` is also incremented at most once per loop at most meaning\n+        // no element is skipped when it may need to be swapped.\n+        //\n+        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n+        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n+        // The explanation is simply that `next_read >= next_write` is always true,\n+        // thus `next_read > next_write - 1` is too.\n         unsafe {\n             // Avoid bounds checks by using raw pointers.\n             while next_read < len {\n@@ -2203,9 +2294,11 @@ impl<T> [T] {\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n+        let p = self.as_mut_ptr();\n \n+        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n+        // valid for reading and writing, as required by `ptr_rotate`.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2244,9 +2337,11 @@ impl<T> [T] {\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n+        let p = self.as_mut_ptr();\n \n+        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n+        // valid for reading and writing, as required by `ptr_rotate`.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2407,6 +2502,9 @@ impl<T> [T] {\n         T: Copy,\n     {\n         assert_eq!(self.len(), src.len(), \"destination and source slices have different lengths\");\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());\n         }\n@@ -2460,6 +2558,8 @@ impl<T> [T] {\n         assert!(src_end <= self.len(), \"src is out of bounds\");\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n+        // SAFETY: the conditions for `ptr::copy` have all been checked above,\n+        // as have those for `ptr::add`.\n         unsafe {\n             ptr::copy(self.as_ptr().add(src_start), self.as_mut_ptr().add(dest), count);\n         }\n@@ -2515,6 +2615,9 @@ impl<T> [T] {\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n+        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n+        // checked to have the same length. The slices cannot overlap because\n+        // mutable references are exclusive.\n         unsafe {\n             ptr::swap_nonoverlapping(self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n         }\n@@ -2546,6 +2649,8 @@ impl<T> [T] {\n             // iterative stein\u2019s algorithm\n             // We should still make this `const fn` (and revert to recursive algorithm if we do)\n             // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n+\n+            // SAFETY: `a` and `b` are checked to be non-zero values.\n             let (ctz_a, mut ctz_b) = unsafe {\n                 if a == 0 {\n                     return b;\n@@ -2565,6 +2670,7 @@ impl<T> [T] {\n                     mem::swap(&mut a, &mut b);\n                 }\n                 b = b - a;\n+                // SAFETY: `b` is checked to be non-zero.\n                 unsafe {\n                     if b == 0 {\n                         break;\n@@ -2626,6 +2732,7 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n+        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n         let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &[], &[])\n@@ -2685,6 +2792,13 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n+        // SAFETY: Here we are ensuring we will use aligned pointers for U for the\n+        // rest of the method. This is done by passing a pointer to &[T] with an\n+        // alignment targeted for U.\n+        // `crate::ptr::align_offset` is called with a correctly aligned and\n+        // valid pointer `ptr` (it comes from a reference to `self`) and with\n+        // a size that is a power of two (since it comes from the alignement for U),\n+        // satisfying its safety constraints.\n         let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &mut [], &mut [])\n@@ -2810,15 +2924,13 @@ impl<T> [T] {\n \n         while left != right {\n             let mid = left + (right - left) / 2;\n-            // SAFETY:\n-            // When left < right, left <= mid < right.\n-            // Therefore left always increases and right always decreases,\n-            // and eigher of them is selected.\n-            // In both cases left <= right is satisfied.\n-            // Therefore if left < right in a step,\n-            // left <= right is satisfied in the next step.\n-            // Therefore as long as left != right, 0 <= left < right <= len is satisfied\n-            // and if this case 0 <= mid < len is satisfied too.\n+            // SAFETY: When `left < right`, `left <= mid < right`.\n+            // Therefore `left` always increases and `right` always decreases,\n+            // and either of them is selected. In both cases `left <= right` is\n+            // satisfied. Therefore if `left < right` in a step, `left <= right`\n+            // is satisfied in the next step. Therefore as long as `left != right`,\n+            // `0 <= left < right <= len` is satisfied and if this case\n+            // `0 <= mid < len` is satisfied too.\n             let value = unsafe { self.get_unchecked(mid) };\n             if pred(value) {\n                 left = mid + 1;\n@@ -2938,7 +3050,8 @@ fn is_ascii(s: &[u8]) -> bool {\n     // above.\n     debug_assert!(offset_to_aligned <= len);\n \n-    // word_ptr is the (properly aligned) usize ptr we use to read the middle chunk of the slice.\n+    // SAFETY: word_ptr is the (properly aligned) usize ptr we use to read the\n+    // middle chunk of the slice.\n     let mut word_ptr = unsafe { start.add(offset_to_aligned) as *const usize };\n \n     // `byte_pos` is the byte index of `word_ptr`, used for loop end checks.\n@@ -3126,11 +3239,13 @@ unsafe impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        // SAFETY: `self` is checked to be in bounds.\n         if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n@@ -3171,6 +3286,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n@@ -3180,6 +3296,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n             unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n@@ -3208,6 +3325,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3218,6 +3336,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_end_index_len_fail(self.end, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3290,6 +3409,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &*self.get_unchecked(slice) }\n     }\n \n@@ -3298,6 +3418,7 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n         if self.start > slice.len() {\n             slice_start_index_len_fail(self.start, slice.len());\n         }\n+        // SAFETY: `self` is checked to be valid and in bounds above.\n         unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n@@ -3543,6 +3664,9 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n+                // SAFETY: the iterator was created from a slice with pointer\n+                // `self.ptr` and length `len!(self)`. This guarantees that all\n+                // the prerequisites for `from_raw_parts` are fulfilled.\n                 unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n             }\n \n@@ -3601,6 +3725,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer\n+                // must be non-null, and slices over non-ZSTs must also have a\n+                // non-null end pointer. The call to `next_unchecked!` is safe\n+                // since we check if the iterator is empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3634,14 +3763,14 @@ macro_rules! iterator {\n                         // could be (due to wrapping).\n                         self.end = self.ptr.as_ptr();\n                     } else {\n+                        // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                         unsafe {\n-                            // End can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                             self.ptr = NonNull::new_unchecked(self.end as *mut T);\n                         }\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n                     self.post_inc_start(n as isize);\n                     Some(next_unchecked!(self))\n@@ -3748,6 +3877,8 @@ macro_rules! iterator {\n                 let mut i = 0;\n                 while let Some(x) = self.next() {\n                     if predicate(x) {\n+                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n+                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3769,6 +3900,8 @@ macro_rules! iterator {\n                 while let Some(x) = self.next_back() {\n                     i -= 1;\n                     if predicate(x) {\n+                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n+                        // and is only decreasing.\n                         unsafe { assume(i < n) };\n                         return Some(i);\n                     }\n@@ -3784,6 +3917,11 @@ macro_rules! iterator {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n+\n+                // SAFETY: `assume` calls are safe since a slice's start pointer must be non-null,\n+                // and slices over non-ZSTs must also have a non-null end pointer.\n+                // The call to `next_back_unchecked!` is safe since we check if the iterator is\n+                // empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n                     if mem::size_of::<T>() != 0 {\n@@ -3804,7 +3942,7 @@ macro_rules! iterator {\n                     self.end = self.ptr.as_ptr();\n                     return None;\n                 }\n-                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                 unsafe {\n                     self.pre_dec_end(n as isize);\n                     Some(next_back_unchecked!(self))\n@@ -3999,6 +4137,9 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n+        // SAFETY: the iterator was created from a mutable slice with pointer\n+        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n+        // for `from_raw_parts_mut` are fulfilled.\n         unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n     }\n \n@@ -5568,6 +5709,8 @@ impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n         unsafe { self.iter.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n@@ -6288,12 +6431,20 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_ref<T>(s: &T) -> &[T] {\n+    // SAFETY: a reference is guaranteed to be valid for reads. The returned\n+    // reference cannot be mutated as it is an immutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts` is safe.\n     unsafe { from_raw_parts(s, 1) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub fn from_mut<T>(s: &mut T) -> &mut [T] {\n+    // SAFETY: a mutable reference is guaranteed to be valid for writes.\n+    // The reference cannot be accessed by another pointer as it is an mutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts_mut` is safe.\n     unsafe { from_raw_parts_mut(s, 1) }\n }\n \n@@ -6414,6 +6565,8 @@ where\n         if self.as_ptr().guaranteed_eq(other.as_ptr()) {\n             return true;\n         }\n+        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n+        // The two slices have been checked to have the same size above.\n         unsafe {\n             let size = mem::size_of_val(self);\n             memcmp(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n@@ -6516,6 +6669,9 @@ impl SliceOrd for u8 {\n     #[inline]\n     fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n+            // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.\n+            // We use the minimum of both lengths which guarantees that both regions are\n+            // valid for reads in that interval.\n             unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n             left.len().cmp(&right.len())\n@@ -6590,6 +6746,10 @@ impl SliceContains for u8 {\n impl SliceContains for i8 {\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         let byte = *self as u8;\n+        // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`\n+        // as `*const u8` is safe. The `x.as_ptr()` comes from a reference and is thus guaranteed\n+        // to be valid for reads for the length of the slice `x.len()`, which cannot be larger\n+        // than `isize::MAX`. The returned slice is never mutated.\n         let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n         memchr::memchr(byte, bytes).is_some()\n     }"}]}