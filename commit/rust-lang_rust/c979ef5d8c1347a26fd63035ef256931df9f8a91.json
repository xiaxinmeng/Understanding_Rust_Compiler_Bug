{"sha": "c979ef5d8c1347a26fd63035ef256931df9f8a91", "node_id": "C_kwDOAAsO6NoAKGM5NzllZjVkOGMxMzQ3YTI2ZmQ2MzAzNWVmMjU2OTMxZGY5ZjhhOTE", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-22T18:16:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-05-13T17:42:52Z"}, "message": "rustdoc: Remove `ResolutionFailure::MalformedGenerics`\n\nin favor of `PreprocessingError::MalformedGenerics`", "tree": {"sha": "322d17be299753b8cca15fac4351b87a1540626e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322d17be299753b8cca15fac4351b87a1540626e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c979ef5d8c1347a26fd63035ef256931df9f8a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c979ef5d8c1347a26fd63035ef256931df9f8a91", "html_url": "https://github.com/rust-lang/rust/commit/c979ef5d8c1347a26fd63035ef256931df9f8a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c979ef5d8c1347a26fd63035ef256931df9f8a91/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51eda747b1dd5ac9a6afe6006fb26b5cd11b9d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/51eda747b1dd5ac9a6afe6006fb26b5cd11b9d0f", "html_url": "https://github.com/rust-lang/rust/commit/51eda747b1dd5ac9a6afe6006fb26b5cd11b9d0f"}], "stats": {"total": 142, "additions": 61, "deletions": 81}, "files": [{"sha": "ec621a554935f511b4101101b91b159f80f4aa7e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 61, "deletions": 81, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c979ef5d8c1347a26fd63035ef256931df9f8a91/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c979ef5d8c1347a26fd63035ef256931df9f8a91/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c979ef5d8c1347a26fd63035ef256931df9f8a91", "patch": "@@ -181,16 +181,14 @@ enum ResolutionFailure<'a> {\n         /// In `[std::io::Error::x]`, `x` would be unresolved.\n         unresolved: Cow<'a, str>,\n     },\n-    /// This link has malformed generic parameters; e.g., the angle brackets are unbalanced.\n-    MalformedGenerics(MalformedGenerics),\n     /// Used to communicate that this should be ignored, but shouldn't be reported to the user.\n     ///\n     /// This happens when there is no disambiguator and one of the namespaces\n     /// failed to resolve.\n     Dummy,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n enum MalformedGenerics {\n     /// This link has unbalanced angle brackets.\n     ///\n@@ -1088,12 +1086,20 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n enum PreprocessingError {\n     Anchor(AnchorFailure),\n     Disambiguator(Range<usize>, String),\n-    Resolution(ResolutionFailure<'static>, String, Option<Disambiguator>),\n+    MalformedGenerics(MalformedGenerics, String),\n }\n \n-impl From<AnchorFailure> for PreprocessingError {\n-    fn from(err: AnchorFailure) -> Self {\n-        Self::Anchor(err)\n+impl PreprocessingError {\n+    fn report(&self, cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n+        match self {\n+            PreprocessingError::Anchor(err) => anchor_failure(cx, diag_info, *err),\n+            PreprocessingError::Disambiguator(range, msg) => {\n+                disambiguator_error(cx, diag_info, range.clone(), msg)\n+            }\n+            PreprocessingError::MalformedGenerics(err, path_str) => {\n+                report_malformed_generics(cx, diag_info, *err, path_str)\n+            }\n+        }\n     }\n }\n \n@@ -1138,7 +1144,7 @@ fn preprocess_link(\n     let extra_fragment = parts.next();\n     if parts.next().is_some() {\n         // A valid link can't have multiple #'s\n-        return Some(Err(AnchorFailure::MultipleAnchors.into()));\n+        return Some(Err(PreprocessingError::Anchor(AnchorFailure::MultipleAnchors)));\n     }\n \n     // Parse and strip the disambiguator from the link, if present.\n@@ -1166,13 +1172,9 @@ fn preprocess_link(\n     let path_str = if path_str.contains(['<', '>'].as_slice()) {\n         match strip_generics_from_path(path_str) {\n             Ok(path) => path,\n-            Err(err_kind) => {\n+            Err(err) => {\n                 debug!(\"link has malformed generics: {}\", path_str);\n-                return Some(Err(PreprocessingError::Resolution(\n-                    err_kind,\n-                    path_str.to_owned(),\n-                    disambiguator,\n-                )));\n+                return Some(Err(PreprocessingError::MalformedGenerics(err, path_str.to_owned())));\n             }\n         }\n     } else {\n@@ -1222,32 +1224,10 @@ impl LinkCollector<'_, '_> {\n             link_range: ori_link.range.clone(),\n         };\n \n-        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } = match pp_link\n-        {\n-            Ok(x) => x,\n-            Err(err) => {\n-                match err {\n-                    PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, *err),\n-                    PreprocessingError::Disambiguator(range, msg) => {\n-                        disambiguator_error(self.cx, diag_info, range.clone(), msg)\n-                    }\n-                    PreprocessingError::Resolution(err, path_str, disambiguator) => {\n-                        resolution_failure(\n-                            self,\n-                            diag_info,\n-                            path_str,\n-                            *disambiguator,\n-                            smallvec![err.clone()],\n-                        );\n-                    }\n-                }\n-                return None;\n-            }\n-        };\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } =\n+            pp_link.as_ref().map_err(|err| err.report(self.cx, diag_info.clone())).ok()?;\n         let disambiguator = *disambiguator;\n \n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-\n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n         // this module came from an inner comment (//!) then we anchor\n@@ -1259,6 +1239,7 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n+        let inner_docs = item.inner_docs(self.cx.tcx);\n         let base_node =\n             if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n         let module_id = base_node.expect(\"doc link without parent module\");\n@@ -2121,27 +2102,6 @@ fn resolution_failure(\n                             expected_ns.descr()\n                         )\n                     }\n-                    ResolutionFailure::MalformedGenerics(variant) => match variant {\n-                        MalformedGenerics::UnbalancedAngleBrackets => {\n-                            String::from(\"unbalanced angle brackets\")\n-                        }\n-                        MalformedGenerics::MissingType => {\n-                            String::from(\"missing type for generic parameters\")\n-                        }\n-                        MalformedGenerics::HasFullyQualifiedSyntax => {\n-                            diag.note(\"see https://github.com/rust-lang/rust/issues/74563 for more information\");\n-                            String::from(\"fully-qualified syntax is unsupported\")\n-                        }\n-                        MalformedGenerics::InvalidPathSeparator => {\n-                            String::from(\"has invalid path separator\")\n-                        }\n-                        MalformedGenerics::TooManyAngleBrackets => {\n-                            String::from(\"too many angle brackets\")\n-                        }\n-                        MalformedGenerics::EmptyAngleBrackets => {\n-                            String::from(\"empty angle brackets\")\n-                        }\n-                    },\n                 };\n                 if let Some(span) = sp {\n                     diag.span_label(span, &note);\n@@ -2205,6 +2165,40 @@ fn disambiguator_error(\n     });\n }\n \n+fn report_malformed_generics(\n+    cx: &DocContext<'_>,\n+    diag_info: DiagnosticInfo<'_>,\n+    err: MalformedGenerics,\n+    path_str: &str,\n+) {\n+    report_diagnostic(\n+        cx.tcx,\n+        BROKEN_INTRA_DOC_LINKS,\n+        &format!(\"unresolved link to `{}`\", path_str),\n+        &diag_info,\n+        |diag, sp| {\n+            let note = match err {\n+                MalformedGenerics::UnbalancedAngleBrackets => \"unbalanced angle brackets\",\n+                MalformedGenerics::MissingType => \"missing type for generic parameters\",\n+                MalformedGenerics::HasFullyQualifiedSyntax => {\n+                    diag.note(\n+                        \"see https://github.com/rust-lang/rust/issues/74563 for more information\",\n+                    );\n+                    \"fully-qualified syntax is unsupported\"\n+                }\n+                MalformedGenerics::InvalidPathSeparator => \"has invalid path separator\",\n+                MalformedGenerics::TooManyAngleBrackets => \"too many angle brackets\",\n+                MalformedGenerics::EmptyAngleBrackets => \"empty angle brackets\",\n+            };\n+            if let Some(span) = sp {\n+                diag.span_label(span, note);\n+            } else {\n+                diag.note(note);\n+            }\n+        },\n+    );\n+}\n+\n /// Report an ambiguity error, where there were multiple possible resolutions.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n@@ -2340,7 +2334,7 @@ fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n     Some(Res::Primitive(prim))\n }\n \n-fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {\n+fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGenerics> {\n     let mut stripped_segments = vec![];\n     let mut path = path_str.chars().peekable();\n     let mut segment = Vec::new();\n@@ -2355,24 +2349,18 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n                         stripped_segments.push(stripped_segment);\n                     }\n                 } else {\n-                    return Err(ResolutionFailure::MalformedGenerics(\n-                        MalformedGenerics::InvalidPathSeparator,\n-                    ));\n+                    return Err(MalformedGenerics::InvalidPathSeparator);\n                 }\n             }\n             '<' => {\n                 segment.push(chr);\n \n                 match path.next() {\n                     Some('<') => {\n-                        return Err(ResolutionFailure::MalformedGenerics(\n-                            MalformedGenerics::TooManyAngleBrackets,\n-                        ));\n+                        return Err(MalformedGenerics::TooManyAngleBrackets);\n                     }\n                     Some('>') => {\n-                        return Err(ResolutionFailure::MalformedGenerics(\n-                            MalformedGenerics::EmptyAngleBrackets,\n-                        ));\n+                        return Err(MalformedGenerics::EmptyAngleBrackets);\n                     }\n                     Some(chr) => {\n                         segment.push(chr);\n@@ -2400,16 +2388,10 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n \n     let stripped_path = stripped_segments.join(\"::\");\n \n-    if !stripped_path.is_empty() {\n-        Ok(stripped_path)\n-    } else {\n-        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::MissingType))\n-    }\n+    if !stripped_path.is_empty() { Ok(stripped_path) } else { Err(MalformedGenerics::MissingType) }\n }\n \n-fn strip_generics_from_path_segment(\n-    segment: Vec<char>,\n-) -> Result<String, ResolutionFailure<'static>> {\n+fn strip_generics_from_path_segment(segment: Vec<char>) -> Result<String, MalformedGenerics> {\n     let mut stripped_segment = String::new();\n     let mut param_depth = 0;\n \n@@ -2424,9 +2406,7 @@ fn strip_generics_from_path_segment(\n             if latest_generics_chunk.contains(\" as \") {\n                 // The segment tries to use fully-qualified syntax, which is currently unsupported.\n                 // Give a helpful error message instead of completely ignoring the angle brackets.\n-                return Err(ResolutionFailure::MalformedGenerics(\n-                    MalformedGenerics::HasFullyQualifiedSyntax,\n-                ));\n+                return Err(MalformedGenerics::HasFullyQualifiedSyntax);\n             }\n         } else {\n             if param_depth == 0 {\n@@ -2441,6 +2421,6 @@ fn strip_generics_from_path_segment(\n         Ok(stripped_segment)\n     } else {\n         // The segment has unbalanced angle brackets, e.g. `Vec<T` or `Vec<T>>`\n-        Err(ResolutionFailure::MalformedGenerics(MalformedGenerics::UnbalancedAngleBrackets))\n+        Err(MalformedGenerics::UnbalancedAngleBrackets)\n     }\n }"}]}