{"sha": "54c57a2f21193b8a3a6ec1ffd641931bd6da246c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzU3YTJmMjExOTNiOGEzYTZlYzFmZmQ2NDE5MzFiZDZkYTI0NmM=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2019-11-05T13:36:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-05T13:36:55Z"}, "message": "Rollup merge of #65948 - danielhenrymantilla:doc/maybe_uninit_ref_mut, r=RalfJung\n\nImprove MaybeUninit::get_{ref,mut} documentation\n\nAs mentioned in https://github.com/rust-lang/rust/issues/63568#issuecomment-544106668, `MaybeUninit`'s `get_{ref,mut}` documentation is lacking, so this PR attempts to fix that.\n\nThat being said, and as @RalfJung mentions in that thread,\n\n> In particular, we should clarify that all the UB rules for these methods equally apply when calling the raw ptr methods and creating a reference manually.\n\nthese other docs also need to be improved, which I can do in this PR ~~(hence the `[WIP]`)~~.\n\nFinally, since all these documentations are related to clearly establishing when dealing with uninitialized memory which patterns are known to be sound and which patterns are currently UB (that is, until, if ever, the rules around references to unintialized integers get relaxed, this documentation will treat them as UB, and advise against such patterns (_e.g._, it is not possible to use uninitialized buffers with the `Read` API)), I think that adding even more examples to the main documentation of `MaybeUninit` inherent definition wouldn't hurt either.\n\n___\n\n  - [Rendered](http://dreamy-ritchie-99d637.netlify.com/core/mem/union.maybeuninit#method.get_ref)", "tree": {"sha": "74ba8f2fcc8e79911ab2ef06cf26d734d31400fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74ba8f2fcc8e79911ab2ef06cf26d734d31400fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c57a2f21193b8a3a6ec1ffd641931bd6da246c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdwXr4CRBK7hj4Ov3rIwAAdHIIAHBWuPvmacipRGRZUG3ogIln\n/6qHWQCv74hfiYMKBX/7vUIqjoGfbSVTI6VJWC4m0HrsuJJzjrq7TkR5GGwU6SI7\n8leIvJ724cryXq258tQjp7BstsG4et0iY72nyGHkQItpoGgUhK4Nt63jRoiZJV7X\nuanRgjmbBxFEf4XxPE4eJCzbv/Qv/ZEzXySEsxA9tk0XrU/8wihwtoC5fIW8BA9/\naYKw3J+KpllW/RmtZq3Xu0BzTokuu3mQ9+BF50XnQDqGO7syKh9xGsurdtVUqFHL\n1kY0uVfDaiHYR1UHliIU1+UQ/QGb5vkGAvgl0A1lASZv618YglA6UTJI2/Scgbc=\n=8Bg+\n-----END PGP SIGNATURE-----\n", "payload": "tree 74ba8f2fcc8e79911ab2ef06cf26d734d31400fa\nparent d1fff4a4b213b3341c1ff994061b7965a5932c70\nparent 67f2200f4a1836742a605dca551408db56976b69\nauthor Pietro Albini <pietro@pietroalbini.org> 1572961015 +0100\ncommitter GitHub <noreply@github.com> 1572961015 +0100\n\nRollup merge of #65948 - danielhenrymantilla:doc/maybe_uninit_ref_mut, r=RalfJung\n\nImprove MaybeUninit::get_{ref,mut} documentation\n\nAs mentioned in https://github.com/rust-lang/rust/issues/63568#issuecomment-544106668, `MaybeUninit`'s `get_{ref,mut}` documentation is lacking, so this PR attempts to fix that.\n\nThat being said, and as @RalfJung mentions in that thread,\n\n> In particular, we should clarify that all the UB rules for these methods equally apply when calling the raw ptr methods and creating a reference manually.\n\nthese other docs also need to be improved, which I can do in this PR ~~(hence the `[WIP]`)~~.\n\nFinally, since all these documentations are related to clearly establishing when dealing with uninitialized memory which patterns are known to be sound and which patterns are currently UB (that is, until, if ever, the rules around references to unintialized integers get relaxed, this documentation will treat them as UB, and advise against such patterns (_e.g._, it is not possible to use uninitialized buffers with the `Read` API)), I think that adding even more examples to the main documentation of `MaybeUninit` inherent definition wouldn't hurt either.\n\n___\n\n  - [Rendered](http://dreamy-ritchie-99d637.netlify.com/core/mem/union.maybeuninit#method.get_ref)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c57a2f21193b8a3a6ec1ffd641931bd6da246c", "html_url": "https://github.com/rust-lang/rust/commit/54c57a2f21193b8a3a6ec1ffd641931bd6da246c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c57a2f21193b8a3a6ec1ffd641931bd6da246c/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1fff4a4b213b3341c1ff994061b7965a5932c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1fff4a4b213b3341c1ff994061b7965a5932c70", "html_url": "https://github.com/rust-lang/rust/commit/d1fff4a4b213b3341c1ff994061b7965a5932c70"}, {"sha": "67f2200f4a1836742a605dca551408db56976b69", "url": "https://api.github.com/repos/rust-lang/rust/commits/67f2200f4a1836742a605dca551408db56976b69", "html_url": "https://github.com/rust-lang/rust/commit/67f2200f4a1836742a605dca551408db56976b69"}], "stats": {"total": 167, "additions": 159, "deletions": 8}, "files": [{"sha": "51ba260589f622832aed220ad2d8ff173f5c19db", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 159, "deletions": 8, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/54c57a2f21193b8a3a6ec1ffd641931bd6da246c/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c57a2f21193b8a3a6ec1ffd641931bd6da246c/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=54c57a2f21193b8a3a6ec1ffd641931bd6da246c", "patch": "@@ -509,32 +509,183 @@ impl<T> MaybeUninit<T> {\n         self.as_ptr().read()\n     }\n \n-    /// Gets a reference to the contained value.\n+    /// Gets a shared reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// // Initialize `x`:\n+    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n+    /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n+    /// // create a shared reference to it:\n+    /// let x: &Vec<u32> = unsafe {\n+    ///     // Safety: `x` has been initialized.\n+    ///     x.get_ref()\n+    /// };\n+    /// assert_eq!(x, &vec![1, 2, 3]);\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{cell::Cell, mem::MaybeUninit};\n+    ///\n+    /// let b = MaybeUninit::<Cell<bool>>::uninit();\n+    /// // Initialize the `MaybeUninit` using `Cell::set`:\n+    /// unsafe {\n+    ///     b.get_ref().set(true);\n+    ///  // ^^^^^^^^^^^\n+    ///  // Reference to an uninitialized `Cell<bool>`: UB!\n+    /// }\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &*self.value\n     }\n \n-    /// Gets a mutable reference to the contained value.\n+    /// Gets a mutable (unique) reference to the contained value.\n+    ///\n+    /// This can be useful when we want to access a `MaybeUninit` that has been\n+    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n+    /// of `.assume_init()`).\n     ///\n     /// # Safety\n     ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n+    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n+    /// initialize a `MaybeUninit`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ### Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// # unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 2048]) { *buf = [0; 2048] }\n+    /// # #[cfg(FALSE)]\n+    /// extern \"C\" {\n+    ///     /// Initializes *all* the bytes of the input buffer.\n+    ///     fn initialize_buffer(buf: *mut [u8; 2048]);\n+    /// }\n+    ///\n+    /// let mut buf = MaybeUninit::<[u8; 2048]>::uninit();\n+    ///\n+    /// // Initialize `buf`:\n+    /// unsafe { initialize_buffer(buf.as_mut_ptr()); }\n+    /// // Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n+    /// // However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.\n+    /// // To assert our buffer has been initialized without copying it, we upgrade\n+    /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n+    /// let buf: &mut [u8; 2048] = unsafe {\n+    ///     // Safety: `buf` has been initialized.\n+    ///     buf.get_mut()\n+    /// };\n+    ///\n+    /// // Now we can use `buf` as a normal slice:\n+    /// buf.sort_unstable();\n+    /// assert!(\n+    ///     buf.chunks(2).all(|chunk| chunk[0] <= chunk[1]),\n+    ///     \"buffer is sorted\",\n+    /// );\n+    /// ```\n+    ///\n+    /// ### *Incorrect* usages of this method:\n+    ///\n+    /// You cannot use `.get_mut()` to initialize a value:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut b = MaybeUninit::<bool>::uninit();\n+    /// unsafe {\n+    ///     *b.get_mut() = true;\n+    ///     // We have created a (mutable) reference to an uninitialized `bool`!\n+    ///     // This is undefined behavior.\n+    /// }\n+    /// ```\n+    ///\n+    /// For instance, you cannot [`Read`] into an uninitialized buffer:\n+    ///\n+    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{io, mem::MaybeUninit};\n+    ///\n+    /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n+    /// {\n+    ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n+    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n+    ///                             // ^^^^^^^^^^^^^^^^\n+    ///                             // (mutable) reference to uninitialized memory!\n+    ///                             // This is undefined behavior.\n+    ///     Ok(unsafe { buffer.assume_init() })\n+    /// }\n+    /// ```\n+    ///\n+    /// Nor can you use direct field access to do field-by-field gradual initialization:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_ref)]\n+    /// use std::{mem::MaybeUninit, ptr};\n+    ///\n+    /// struct Foo {\n+    ///     a: u32,\n+    ///     b: u8,\n+    /// }\n+    ///\n+    /// let foo: Foo = unsafe {\n+    ///     let mut foo = MaybeUninit::<Foo>::uninit();\n+    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n+    ///                  // ^^^^^^^^^^^^^\n+    ///                  // (mutable) reference to uninitialized memory!\n+    ///                  // This is undefined behavior.\n+    ///     foo.assume_init()\n+    /// };\n+    /// ```\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n+        intrinsics::panic_if_uninhabited::<T>();\n         &mut *self.value\n     }\n "}]}