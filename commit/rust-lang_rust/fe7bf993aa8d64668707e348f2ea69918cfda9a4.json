{"sha": "fe7bf993aa8d64668707e348f2ea69918cfda9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlN2JmOTkzYWE4ZDY0NjY4NzA3ZTM0OGYyZWE2OTkxOGNmZGE5YTQ=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-05-08T15:36:11Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-05-08T16:15:24Z"}, "message": "Implement better handling of divergence\n\nDivergence here means that for some reason, the end of a block will not be\nreached. We tried to model this just using the never type, but that doesn't work\nfully (e.g. in `let x = { loop {}; \"foo\" };` x should still have type `&str`);\nso this introduces a `diverges` flag that the type checker keeps track of, like\nrustc does.", "tree": {"sha": "9d3fc4f969dbd06d982dda6dadc6325a668e7eb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d3fc4f969dbd06d982dda6dadc6325a668e7eb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe7bf993aa8d64668707e348f2ea69918cfda9a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7bf993aa8d64668707e348f2ea69918cfda9a4", "html_url": "https://github.com/rust-lang/rust/commit/fe7bf993aa8d64668707e348f2ea69918cfda9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe7bf993aa8d64668707e348f2ea69918cfda9a4/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "html_url": "https://github.com/rust-lang/rust/commit/d3eb9d8eafbebca7da95fa8a4813b92eb5080500"}], "stats": {"total": 223, "additions": 200, "deletions": 23}, "files": [{"sha": "d3a06626863aa30782e9975d6ea8621cb388d8b0", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -210,6 +210,7 @@ struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    diverges: Diverges,\n }\n \n impl<'a> InferenceContext<'a> {\n@@ -224,6 +225,7 @@ impl<'a> InferenceContext<'a> {\n             owner,\n             body: db.body(owner),\n             resolver,\n+            diverges: Diverges::Maybe,\n         }\n     }\n \n@@ -666,6 +668,44 @@ impl Expectation {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    Maybe,\n+    Always,\n+}\n+\n+impl Diverges {\n+    fn is_always(self) -> bool {\n+        self == Diverges::Always\n+    }\n+}\n+\n+impl std::ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        std::cmp::min(self, other)\n+    }\n+}\n+\n+impl std::ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        std::cmp::max(self, other)\n+    }\n+}\n+\n+impl std::ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl std::ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n mod diagnostics {\n     use hir_def::{expr::ExprId, FunctionId};\n     use hir_expand::diagnostics::DiagnosticSink;"}, {"sha": "f2f9883b2d7ebe8bb5eb1f1ab6a26468a0c25522", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -1,7 +1,7 @@\n //! Type inference for expressions.\n \n use std::iter::{repeat, repeat_with};\n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n use hir_def::{\n     builtin_type::Signedness,\n@@ -21,11 +21,15 @@ use crate::{\n     Ty, TypeCtor, Uncertain,\n };\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch, Diverges};\n \n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n+        if ty.is_never() {\n+            // Any expression that produces a value of type `!` must have diverged\n+            self.diverges = Diverges::Always;\n+        }\n         let could_unify = self.unify(&ty, &expected.ty);\n         if !could_unify {\n             self.result.type_mismatches.insert(\n@@ -64,11 +68,18 @@ impl<'a> InferenceContext<'a> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n+                let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let mut both_arms_diverge = Diverges::Always;\n+\n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n+                both_arms_diverge &= self.diverges;\n+\n+                self.diverges = condition_diverges | both_arms_diverge;\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n@@ -132,10 +143,12 @@ impl<'a> InferenceContext<'a> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n-                let prev_ret_ty = std::mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n                 self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n \n+                self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n \n                 closure_ty\n@@ -165,7 +178,11 @@ impl<'a> InferenceContext<'a> {\n                     self.table.new_type_var()\n                 };\n \n+                let matchee_diverges = self.diverges;\n+                let mut all_arms_diverge = Diverges::Always;\n+\n                 for arm in arms {\n+                    self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n@@ -175,9 +192,12 @@ impl<'a> InferenceContext<'a> {\n                     }\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    all_arms_diverge &= self.diverges;\n                     result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n+                self.diverges = matchee_diverges | all_arms_diverge;\n+\n                 result_ty\n             }\n             Expr::Path(p) => {\n@@ -522,7 +542,6 @@ impl<'a> InferenceContext<'a> {\n         tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        let mut diverges = false;\n         for stmt in statements {\n             match stmt {\n                 Statement::Let { pat, type_ref, initializer } => {\n@@ -544,24 +563,30 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n-                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n-                        diverges = true;\n-                    }\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n \n         let ty = if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n-            self.coerce(&Ty::unit(), expected.coercion_target());\n-            Ty::unit()\n+            // Citing rustc: if there is no explicit tail expression,\n+            // that is typically equivalent to a tail expression\n+            // of `()` -- except if the block diverges. In that\n+            // case, there is no value supplied from the tail\n+            // expression (assuming there are no other breaks,\n+            // this implies that the type of the block will be\n+            // `!`).\n+            if self.diverges.is_always() {\n+                // we don't even make an attempt at coercion\n+                self.table.new_maybe_never_type_var()\n+            } else {\n+                self.coerce(&Ty::unit(), expected.coercion_target());\n+                Ty::unit()\n+            }\n         };\n-        if diverges {\n-            Ty::simple(TypeCtor::Never)\n-        } else {\n-            ty\n-        }\n+        ty\n     }\n \n     fn infer_method_call("}, {"sha": "ac0ef1bfe1fde160c64a4882980973e23f340eb9", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -730,6 +730,13 @@ impl Ty {\n         }\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self {"}, {"sha": "0c3a833bd9e378be9c95f35bbac02fd331d729c2", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -384,7 +384,7 @@ fn foo() -> u32 {\n }\n \"#, true),\n         @r###\"\n-    17..40 '{     ...own; }': !\n+    17..40 '{     ...own; }': u32\n     23..37 'return unknown': !\n     30..37 'unknown': u32\n     \"###\n@@ -514,7 +514,7 @@ fn foo() {\n     27..103 '{     ...     }': &u32\n     37..82 'if tru...     }': ()\n     40..44 'true': bool\n-    45..82 '{     ...     }': !\n+    45..82 '{     ...     }': ()\n     59..71 'return &1u32': !\n     66..71 '&1u32': &u32\n     67..71 '1u32': u32"}, {"sha": "4c6099aa230dc2c9ce49b8fc7b22b0f656f00822", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -197,7 +197,7 @@ fn spam() {\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n-    54..457 '{     ...!(); }': !\n+    54..457 '{     ...!(); }': ()\n     88..109 'spam!(...am!())': {unknown}\n     115..134 'for _ ...!() {}': ()\n     119..120 '_': {unknown}"}, {"sha": "1721f97c5812fe8e893804cb088420e30f490178", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 106, "deletions": 1, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -1,4 +1,6 @@\n-use super::type_at;\n+use insta::assert_snapshot;\n+\n+use super::{infer_with_mismatches, type_at};\n \n #[test]\n fn infer_never1() {\n@@ -261,3 +263,106 @@ fn test(a: i32) {\n     );\n     assert_eq!(t, \"f64\");\n }\n+\n+#[test]\n+fn diverging_expression_1() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    let x: u32 = return;\n+}\n+fn test2() {\n+    let x: u32 = { return; };\n+}\n+fn test3() {\n+    let x: u32 = loop {};\n+}\n+fn test4() {\n+    let x: u32 = { loop {} };\n+}\n+fn test5() {\n+    let x: u32 = { if true { loop {}; } else { loop {}; } };\n+}\n+fn test6() {\n+    let x: u32 = { let y: u32 = { loop {}; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..53 '{     ...urn; }': ()\n+    35..36 'x': u32\n+    44..50 'return': !\n+    65..98 '{     ...; }; }': ()\n+    75..76 'x': u32\n+    84..95 '{ return; }': u32\n+    86..92 'return': !\n+    110..139 '{     ... {}; }': ()\n+    120..121 'x': u32\n+    129..136 'loop {}': !\n+    134..136 '{}': ()\n+    151..184 '{     ...} }; }': ()\n+    161..162 'x': u32\n+    170..181 '{ loop {} }': u32\n+    172..179 'loop {}': !\n+    177..179 '{}': ()\n+    196..260 '{     ...} }; }': ()\n+    206..207 'x': u32\n+    215..257 '{ if t...}; } }': u32\n+    217..255 'if tru... {}; }': u32\n+    220..224 'true': bool\n+    225..237 '{ loop {}; }': u32\n+    227..234 'loop {}': !\n+    232..234 '{}': ()\n+    243..255 '{ loop {}; }': u32\n+    245..252 'loop {}': !\n+    250..252 '{}': ()\n+    272..324 '{     ...; }; }': ()\n+    282..283 'x': u32\n+    291..321 '{ let ...; }; }': u32\n+    297..298 'y': u32\n+    306..318 '{ loop {}; }': u32\n+    308..315 'loop {}': !\n+    313..315 '{}': ()\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_2() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop {}; \"foo\" };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..98 '{     ...\" }; }': ()\n+    68..69 'x': u32\n+    77..95 '{ loop...foo\" }': &str\n+    79..86 'loop {}': !\n+    84..86 '{}': ()\n+    88..93 '\"foo\"': &str\n+    77..95: expected u32, got &str\n+    88..93: expected u32, got &str\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_3_break() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop { break; } };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\"###);\n+}"}, {"sha": "3820175f6c20a009c9b1a6558fb2c314a885a67a", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7bf993aa8d64668707e348f2ea69918cfda9a4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=fe7bf993aa8d64668707e348f2ea69918cfda9a4", "patch": "@@ -179,7 +179,7 @@ fn test(a: u32, b: isize, c: !, d: &str) {\n     17..18 'b': isize\n     27..28 'c': !\n     33..34 'd': &str\n-    42..121 '{     ...f32; }': !\n+    42..121 '{     ...f32; }': ()\n     48..49 'a': u32\n     55..56 'b': isize\n     62..63 'c': !\n@@ -935,7 +935,7 @@ fn foo() {\n     29..33 'true': bool\n     34..51 '{     ...     }': i32\n     44..45 '1': i32\n-    57..80 '{     ...     }': !\n+    57..80 '{     ...     }': i32\n     67..73 'return': !\n     90..93 '_x2': i32\n     96..149 'if tru...     }': i32\n@@ -951,7 +951,7 @@ fn foo() {\n     186..190 'true': bool\n     194..195 '3': i32\n     205..206 '_': bool\n-    210..241 '{     ...     }': !\n+    210..241 '{     ...     }': i32\n     224..230 'return': !\n     257..260 '_x4': i32\n     263..320 'match ...     }': i32\n@@ -1687,7 +1687,7 @@ fn foo() -> u32 {\n     17..59 '{     ...; }; }': ()\n     27..28 'x': || -> usize\n     31..56 '|| -> ...n 1; }': || -> usize\n-    43..56 '{ return 1; }': !\n+    43..56 '{ return 1; }': usize\n     45..53 'return 1': !\n     52..53 '1': usize\n     \"###\n@@ -1706,7 +1706,7 @@ fn foo() -> u32 {\n     17..48 '{     ...; }; }': ()\n     27..28 'x': || -> ()\n     31..45 '|| { return; }': || -> ()\n-    34..45 '{ return; }': !\n+    34..45 '{ return; }': ()\n     36..42 'return': !\n     \"###\n     );"}]}