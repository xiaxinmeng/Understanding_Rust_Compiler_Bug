{"sha": "f1578d37dc844ffeefcabc30960784082c3c54fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNTc4ZDM3ZGM4NDRmZmVlZmNhYmMzMDk2MDc4NDA4MmMzYzU0ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T06:12:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T06:12:57Z"}, "message": "Auto merge of #32428 - nikomatsakis:scopes-in-mir, r=nagisa\n\nScopes in mir\n\nThis PR adds scopes to MIR. There is a tree of scopes (each represented by a `ScopeId`). Every statement, variable, and terminator now has an associated scope and span.  It also adds a `-Z dump-mir` switch one can use to conveniently examine the MIR as optimizations proceed.\n\nThe intention is two-fold. First, to support MIR debug-info. This PR does not attempt to modify trans to make use of the scope information, however.\n\nSecond, in a more temporary capacity, to support the goal of moving regionck and borowck into the MIR. To that end, the PR also constructs a \"scope auxiliary\" table storing the extent of each span (this is kept separate from the main MIR, since it contains node-ids) and the dom/post-dom of the region in the graph where the scope occurs. When we move to non-lexical lifetimes, I expect this auxiliary information to be discarded, but that is still some ways in the future (requires, at minimum, an RFC, and there are some thorny details to work out -- though I've got an in-progress draft).\n\nRight now, I'm just dropping this auxiliary information after it is constructed. I was debating for some time whether to add some sort of sanity tests, but decided to just open this PR instead, because I couldn't figure out what such a test would look like (and we don't have independent tests for this today beyond the regionck and borrowck tests).\n\nI'd prefer not to store the auxiliary data into any kind of \"per-fn\" map. Rather, I'd prefer that we do regionck/borrowck/whatever-else immediately after construction -- that is, we build the MIR for fn X and immediately thereafter do extended correctness checking on it. This will reduce peak memory usage and also ensure that the auxiliary data doesn't exist once optimizations begin. It also clarifies the transition point where static checks are complete and MIR can be more freely optimized.\n\ncc @rust-lang/compiler @nagisa", "tree": {"sha": "1bf89b1b95acf53779def3397327c7423cd93110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf89b1b95acf53779def3397327c7423cd93110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1578d37dc844ffeefcabc30960784082c3c54fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1578d37dc844ffeefcabc30960784082c3c54fa", "html_url": "https://github.com/rust-lang/rust/commit/f1578d37dc844ffeefcabc30960784082c3c54fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1578d37dc844ffeefcabc30960784082c3c54fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40deb279a87e640f799140e9f19b3e64623c30da", "url": "https://api.github.com/repos/rust-lang/rust/commits/40deb279a87e640f799140e9f19b3e64623c30da", "html_url": "https://github.com/rust-lang/rust/commit/40deb279a87e640f799140e9f19b3e64623c30da"}, {"sha": "091a00797ecf91989d901fcbb795869f4c6c7fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/091a00797ecf91989d901fcbb795869f4c6c7fc1", "html_url": "https://github.com/rust-lang/rust/commit/091a00797ecf91989d901fcbb795869f4c6c7fc1"}], "stats": {"total": 1823, "additions": 1370, "deletions": 453}, "files": [{"sha": "47d923cbce359998d7605a4a34d0469c19340211", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 97, "deletions": 10, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -32,6 +32,10 @@ pub struct Mir<'tcx> {\n     /// that indexes into this vector.\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n+    /// List of lexical scopes; these are referenced by statements and\n+    /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n+    pub scopes: Vec<ScopeData>,\n+\n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n@@ -152,9 +156,21 @@ pub enum BorrowKind {\n /// decl, a let, etc.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n+    /// `let mut x` vs `let x`\n     pub mutability: Mutability,\n+\n+    /// name that user gave the variable; not that, internally,\n+    /// mir references variables by index\n     pub name: Name,\n+\n+    /// type inferred for this variable (`let x: ty = ...`)\n     pub ty: Ty<'tcx>,\n+\n+    /// scope in which variable was declared\n+    pub scope: ScopeId,\n+\n+    /// span where variable was declared\n+    pub span: Span,\n }\n \n /// A \"temp\" is a temporary that we place on the stack. They are\n@@ -191,7 +207,7 @@ pub struct ArgDecl<'tcx> {\n /// list of the `Mir`.\n ///\n /// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct BasicBlock(u32);\n \n impl BasicBlock {\n@@ -217,13 +233,35 @@ impl Debug for BasicBlock {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {\n+    /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n+\n+    /// Terminator for this block.\n+    ///\n+    /// NB. This should generally ONLY be `None` during construction.\n+    /// Therefore, you should generally access it via the\n+    /// `terminator()` or `terminator_mut()` methods. The only\n+    /// exception is that certain passes, such as `simplify_cfg`, swap\n+    /// out the terminator temporarily with `None` while they continue\n+    /// to recurse over the set of basic blocks.\n     pub terminator: Option<Terminator<'tcx>>,\n+\n+    /// If true, this block lies on an unwind path. This is used\n+    /// during trans where distinct kinds of basic blocks may be\n+    /// generated (particularly for MSVC cleanup). Unwind blocks must\n+    /// only branch to other unwind blocks.\n     pub is_cleanup: bool,\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct Terminator<'tcx> {\n+    pub span: Span,\n+    pub scope: ScopeId,\n+    pub kind: TerminatorKind<'tcx>\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum Terminator<'tcx> {\n+pub enum TerminatorKind<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto {\n         target: BasicBlock,\n@@ -293,7 +331,17 @@ pub enum Terminator<'tcx> {\n \n impl<'tcx> Terminator<'tcx> {\n     pub fn successors(&self) -> Cow<[BasicBlock]> {\n-        use self::Terminator::*;\n+        self.kind.successors()\n+    }\n+\n+    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n+        self.kind.successors_mut()\n+    }\n+}\n+\n+impl<'tcx> TerminatorKind<'tcx> {\n+    pub fn successors(&self) -> Cow<[BasicBlock]> {\n+        use self::TerminatorKind::*;\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n             If { targets: (b1, b2), .. } => vec![b1, b2].into_cow(),\n@@ -314,7 +362,7 @@ impl<'tcx> Terminator<'tcx> {\n     // FIXME: no mootable cow. I\u2019m honestly not sure what a \u201ccow\u201d between `&mut [BasicBlock]` and\n     // `Vec<&mut BasicBlock>` would look like in the first place.\n     pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n-        use self::Terminator::*;\n+        use self::TerminatorKind::*;\n         match *self {\n             Goto { target: ref mut b } => vec![b],\n             If { targets: (ref mut b1, ref mut b2), .. } => vec![b1, b2],\n@@ -354,7 +402,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n     }\n }\n \n-impl<'tcx> Debug for Terminator<'tcx> {\n+impl<'tcx> Debug for TerminatorKind<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         self.fmt_head(fmt)?;\n         let successors = self.successors();\n@@ -381,12 +429,12 @@ impl<'tcx> Debug for Terminator<'tcx> {\n     }\n }\n \n-impl<'tcx> Terminator<'tcx> {\n+impl<'tcx> TerminatorKind<'tcx> {\n     /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n     /// successor basic block, if any. The only information not inlcuded is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n-        use self::Terminator::*;\n+        use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n             If { cond: ref lv, .. } => write!(fmt, \"if({:?})\", lv),\n@@ -413,7 +461,7 @@ impl<'tcx> Terminator<'tcx> {\n \n     /// Return the list of labels for the edges to the successor basic blocks.\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n-        use self::Terminator::*;\n+        use self::TerminatorKind::*;\n         match *self {\n             Return | Resume => vec![],\n             Goto { .. } => vec![\"\".into()],\n@@ -452,6 +500,7 @@ impl<'tcx> Terminator<'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n     pub span: Span,\n+    pub scope: ScopeId,\n     pub kind: StatementKind<'tcx>,\n }\n \n@@ -468,6 +517,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n         }\n     }\n }\n+\n ///////////////////////////////////////////////////////////////////////////\n // Lvalues\n \n@@ -613,13 +663,50 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Scopes\n+\n+impl Index<ScopeId> for Vec<ScopeData> {\n+    type Output = ScopeData;\n+\n+    #[inline]\n+    fn index(&self, index: ScopeId) -> &ScopeData {\n+        &self[index.index()]\n+    }\n+}\n+\n+impl IndexMut<ScopeId> for Vec<ScopeData> {\n+    #[inline]\n+    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeData {\n+        &mut self[index.index()]\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub struct ScopeId(u32);\n+\n+impl ScopeId {\n+    pub fn new(index: usize) -> ScopeId {\n+        assert!(index < (u32::MAX as usize));\n+        ScopeId(index as u32)\n+    }\n+\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ScopeData {\n+    pub parent_scope: Option<ScopeId>,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n-//\n+\n /// These are values that can appear inside an rvalue (or an index\n /// lvalue). They are intentionally limited to prevent rvalues from\n /// being nested in one another.\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n     Consume(Lvalue<'tcx>),"}, {"sha": "bc0056b0af02f40f6e81b930f43a71236e3d398f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 385, "deletions": 41, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -8,12 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n-use middle::ty::Region;\n+use middle::subst::Substs;\n+use middle::ty::{ClosureSubsts, FnOutput, Region, Ty};\n use mir::repr::*;\n+use rustc_const_eval::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use syntax::codemap::Span;\n \n+// # The MIR Visitor\n+//\n+// ## Overview\n+//\n+// There are two visitors, one for immutable and one for mutable references,\n+// but both are generated by the following macro. The code is written according\n+// to the following conventions:\n+//\n+// - introduce a `visit_foo` and a `super_foo` method for every MIR type\n+// - `visit_foo`, by default, calls `super_foo`\n+// - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n+//\n+// This allows you as a user to override `visit_foo` for types are\n+// interested in, and invoke (within that method) call\n+// `self.super_foo` to get the default behavior. Just as in an OO\n+// language, you should never call `super` methods ordinarily except\n+// in that circumstance.\n+//\n+// For the most part, we do not destructure things external to the\n+// MIR, e.g. types, spans, etc, but simply visit them and stop. This\n+// avoids duplication with other visitors like `TypeFoldable`. But\n+// there is one exception: we do destructure the `FnOutput` to reach\n+// the type within. Just because.\n+//\n+// ## Updating\n+//\n+// The code is written in a very deliberate style intended to minimize\n+// the chance of things being overlooked. You'll notice that we always\n+// use pattern matching to reference fields and we ensure that all\n+// matches are exhaustive.\n+//\n+// For example, the `super_basic_block_data` method begins like this:\n+//\n+// ```rust\n+// fn super_basic_block_data(&mut self,\n+//                           block: BasicBlock,\n+//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//     let BasicBlockData {\n+//         ref $($mutability)* statements,\n+//         ref $($mutability)* terminator,\n+//         is_cleanup: _\n+//     } = *data;\n+//\n+//     for statement in statements {\n+//         self.visit_statement(block, statement);\n+//     }\n+//\n+//     ...\n+// }\n+// ```\n+//\n+// Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n+// rather than writing `data.statements` in the body. This is because if one\n+// adds a new field to `BasicBlockData`, one will be forced to revise this code,\n+// and hence one will (hopefully) invoke the correct visit methods (if any).\n+//\n+// For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n+// That means you never write `..` to skip over fields, nor do you write `_`\n+// to skip over variants in a `match`.\n+//\n+// The only place that `_` is acceptable is to match a field (or\n+// variant argument) that does not require visiting, as in\n+// `is_cleanup` above.\n+\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)*) => {\n         pub trait $visitor_trait_name<'tcx> {\n@@ -30,6 +97,11 @@ macro_rules! make_mir_visitor {\n                 self.super_basic_block_data(block, data);\n             }\n \n+            fn visit_scope_data(&mut self,\n+                                scope_data: & $($mutability)* ScopeData) {\n+                self.super_scope_data(scope_data);\n+            }\n+\n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n@@ -49,6 +121,12 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator(block, terminator);\n             }\n \n+            fn visit_terminator_kind(&mut self,\n+                                     block: BasicBlock,\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n+                self.super_terminator_kind(block, kind);\n+            }\n+\n             fn visit_rvalue(&mut self,\n                             rvalue: & $($mutability)* Rvalue<'tcx>) {\n                 self.super_rvalue(rvalue);\n@@ -65,6 +143,18 @@ macro_rules! make_mir_visitor {\n                 self.super_lvalue(lvalue, context);\n             }\n \n+            fn visit_projection(&mut self,\n+                                lvalue: & $($mutability)* LvalueProjection<'tcx>,\n+                                context: LvalueContext) {\n+                self.super_projection(lvalue, context);\n+            }\n+\n+            fn visit_projection_elem(&mut self,\n+                                     lvalue: & $($mutability)* LvalueElem<'tcx>,\n+                                     context: LvalueContext) {\n+                self.super_projection_elem(lvalue, context);\n+            }\n+\n             fn visit_branch(&mut self,\n                             source: BasicBlock,\n                             target: BasicBlock) {\n@@ -91,35 +181,143 @@ macro_rules! make_mir_visitor {\n                 self.super_span(span);\n             }\n \n+            fn visit_fn_output(&mut self,\n+                               fn_output: & $($mutability)* FnOutput<'tcx>) {\n+                self.super_fn_output(fn_output);\n+            }\n+\n+            fn visit_ty(&mut self,\n+                        ty: & $($mutability)* Ty<'tcx>) {\n+                self.super_ty(ty);\n+            }\n+\n+            fn visit_substs(&mut self,\n+                            substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+                self.super_substs(substs);\n+            }\n+\n+            fn visit_closure_substs(&mut self,\n+                                    substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                self.super_closure_substs(substs);\n+            }\n+\n+            fn visit_const_val(&mut self,\n+                               const_val: & $($mutability)* ConstVal) {\n+                self.super_const_val(const_val);\n+            }\n+\n+            fn visit_const_usize(&mut self,\n+                                 const_usize: & $($mutability)* ConstUsize) {\n+                self.super_const_usize(const_usize);\n+            }\n+\n+            fn visit_typed_const_val(&mut self,\n+                                     val: & $($mutability)* TypedConstVal<'tcx>) {\n+                self.super_typed_const_val(val);\n+            }\n+\n+            fn visit_var_decl(&mut self,\n+                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n+                self.super_var_decl(var_decl);\n+            }\n+\n+            fn visit_temp_decl(&mut self,\n+                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n+                self.super_temp_decl(temp_decl);\n+            }\n+\n+            fn visit_arg_decl(&mut self,\n+                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n+                self.super_arg_decl(arg_decl);\n+            }\n+\n+            fn visit_scope_id(&mut self,\n+                              scope_id: & $($mutability)* ScopeId) {\n+                self.super_scope_id(scope_id);\n+            }\n+\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n-                for block in mir.all_basic_blocks() {\n-                    let data = & $($mutability)* mir[block];\n+                let Mir {\n+                    ref $($mutability)* basic_blocks,\n+                    ref $($mutability)* scopes,\n+                    ref $($mutability)* return_ty,\n+                    ref $($mutability)* var_decls,\n+                    ref $($mutability)* arg_decls,\n+                    ref $($mutability)* temp_decls,\n+                    ref $($mutability)* span,\n+                } = *mir;\n+\n+                for (index, data) in basic_blocks.into_iter().enumerate() {\n+                    let block = BasicBlock::new(index);\n                     self.visit_basic_block_data(block, data);\n                 }\n+\n+                for scope in scopes {\n+                    self.visit_scope_data(scope);\n+                }\n+\n+                self.visit_fn_output(return_ty);\n+\n+                for var_decl in var_decls {\n+                    self.visit_var_decl(var_decl);\n+                }\n+\n+                for arg_decl in arg_decls {\n+                    self.visit_arg_decl(arg_decl);\n+                }\n+\n+                for temp_decl in temp_decls {\n+                    self.visit_temp_decl(temp_decl);\n+                }\n+\n+                self.visit_span(span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n                                       data: & $($mutability)* BasicBlockData<'tcx>) {\n-                for statement in & $($mutability)* data.statements {\n+                let BasicBlockData {\n+                    ref $($mutability)* statements,\n+                    ref $($mutability)* terminator,\n+                    is_cleanup: _\n+                } = *data;\n+\n+                for statement in statements {\n                     self.visit_statement(block, statement);\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = data.terminator {\n+                if let Some(ref $($mutability)* terminator) = *terminator {\n                     self.visit_terminator(block, terminator);\n                 }\n             }\n \n+            fn super_scope_data(&mut self,\n+                                scope_data: & $($mutability)* ScopeData) {\n+                let ScopeData {\n+                    ref $($mutability)* parent_scope,\n+                } = *scope_data;\n+\n+                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                    self.visit_scope_id(parent_scope);\n+                }\n+            }\n+\n             fn super_statement(&mut self,\n                                block: BasicBlock,\n                                statement: & $($mutability)* Statement<'tcx>) {\n-                self.visit_span(& $($mutability)* statement.span);\n-\n-                match statement.kind {\n+                let Statement {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* kind,\n+                } = *statement;\n+\n+                self.visit_span(span);\n+                self.visit_scope_id(scope);\n+                match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, lvalue, rvalue);\n@@ -138,52 +336,72 @@ macro_rules! make_mir_visitor {\n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n                                 terminator: &$($mutability)* Terminator<'tcx>) {\n-                match *terminator {\n-                    Terminator::Goto { target } => {\n+                let Terminator {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* kind,\n+                } = *terminator;\n+\n+                self.visit_span(span);\n+                self.visit_scope_id(scope);\n+                self.visit_terminator_kind(block, kind);\n+            }\n+\n+            fn super_terminator_kind(&mut self,\n+                                     block: BasicBlock,\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n+                match *kind {\n+                    TerminatorKind::Goto { target } => {\n                         self.visit_branch(block, target);\n                     }\n \n-                    Terminator::If { ref $($mutability)* cond,\n-                                     ref $($mutability)* targets } => {\n+                    TerminatorKind::If { ref $($mutability)* cond,\n+                                         ref $($mutability)* targets } => {\n                         self.visit_operand(cond);\n                         for &target in targets.as_slice() {\n                             self.visit_branch(block, target);\n                         }\n                     }\n \n-                    Terminator::Switch { ref $($mutability)* discr,\n-                                         adt_def: _,\n-                                         ref targets } => {\n+                    TerminatorKind::Switch { ref $($mutability)* discr,\n+                                             adt_def: _,\n+                                             ref targets } => {\n                         self.visit_lvalue(discr, LvalueContext::Inspect);\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n                     }\n \n-                    Terminator::SwitchInt { ref $($mutability)* discr,\n-                                            switch_ty: _,\n-                                            values: _,\n-                                            ref targets } => {\n+                    TerminatorKind::SwitchInt { ref $($mutability)* discr,\n+                                                ref $($mutability)* switch_ty,\n+                                                ref $($mutability)* values,\n+                                                ref targets } => {\n                         self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        self.visit_ty(switch_ty);\n+                        for value in values {\n+                            self.visit_const_val(value);\n+                        }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n                     }\n \n-                    Terminator::Resume |\n-                    Terminator::Return => {\n+                    TerminatorKind::Resume |\n+                    TerminatorKind::Return => {\n                     }\n \n-                    Terminator::Drop { ref $($mutability)* value, target, unwind } => {\n+                    TerminatorKind::Drop { ref $($mutability)* value,\n+                                           target,\n+                                           unwind } => {\n                         self.visit_lvalue(value, LvalueContext::Drop);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    Terminator::Call { ref $($mutability)* func,\n-                                       ref $($mutability)* args,\n-                                       ref $($mutability)* destination,\n-                                       cleanup } => {\n+                    TerminatorKind::Call { ref $($mutability)* func,\n+                                           ref $($mutability)* args,\n+                                           ref $($mutability)* destination,\n+                                           cleanup } => {\n                         self.visit_operand(func);\n                         for arg in args {\n                             self.visit_operand(arg);\n@@ -205,8 +423,9 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::Repeat(ref $($mutability)* value,\n-                                   _) => {\n+                                   ref $($mutability)* typed_const_val) => {\n                         self.visit_operand(value);\n+                        self.visit_typed_const_val(typed_const_val);\n                     }\n \n                     Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n@@ -220,34 +439,48 @@ macro_rules! make_mir_visitor {\n                         self.visit_lvalue(path, LvalueContext::Inspect);\n                     }\n \n-                    Rvalue::Cast(_, ref $($mutability)* operand, _) => {\n+                    Rvalue::Cast(_cast_kind,\n+                                 ref $($mutability)* operand,\n+                                 ref $($mutability)* ty) => {\n                         self.visit_operand(operand);\n+                        self.visit_ty(ty);\n                     }\n \n-                    Rvalue::BinaryOp(_,\n+                    Rvalue::BinaryOp(_bin_op,\n                                      ref $($mutability)* lhs,\n                                      ref $($mutability)* rhs) => {\n                         self.visit_operand(lhs);\n                         self.visit_operand(rhs);\n                     }\n \n-                    Rvalue::UnaryOp(_, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n                         self.visit_operand(op);\n                     }\n \n-                    Rvalue::Box(_) => {\n+                    Rvalue::Box(ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n                     }\n \n                     Rvalue::Aggregate(ref $($mutability)* kind,\n                                       ref $($mutability)* operands) => {\n                         match *kind {\n-                            AggregateKind::Closure(ref $($mutability)* def_id, _) => {\n+                            AggregateKind::Vec => {\n+                            }\n+                            AggregateKind::Tuple => {\n+                            }\n+                            AggregateKind::Adt(_adt_def,\n+                                               _variant_index,\n+                                               ref $($mutability)* substs) => {\n+                                self.visit_substs(substs);\n+                            }\n+                            AggregateKind::Closure(ref $($mutability)* def_id,\n+                                                   ref $($mutability)* closure_substs) => {\n                                 self.visit_def_id(def_id);\n+                                self.visit_closure_substs(closure_substs);\n                             }\n-                            _ => { /* nothing to do */ }\n                         }\n \n-                        for operand in & $($mutability)* operands[..] {\n+                        for operand in operands {\n                             self.visit_operand(operand);\n                         }\n                     }\n@@ -262,7 +495,8 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::InlineAsm { ref $($mutability)* outputs,\n-                                        ref $($mutability)* inputs, .. } => {\n+                                        ref $($mutability)* inputs,\n+                                        asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n                             self.visit_lvalue(output, LvalueContext::Store);\n                         }\n@@ -287,7 +521,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            _context: LvalueContext) {\n+                            context: LvalueContext) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n                     Lvalue::Temp(_) |\n@@ -298,12 +532,81 @@ macro_rules! make_mir_visitor {\n                         self.visit_def_id(def_id);\n                     }\n                     Lvalue::Projection(ref $($mutability)* proj) => {\n-                        self.visit_lvalue(& $($mutability)* proj.base,\n-                                          LvalueContext::Projection);\n+                        self.visit_projection(proj, context);\n                     }\n                 }\n             }\n \n+            fn super_projection(&mut self,\n+                                proj: & $($mutability)* LvalueProjection<'tcx>,\n+                                context: LvalueContext) {\n+                let Projection {\n+                    ref $($mutability)* base,\n+                    ref $($mutability)* elem,\n+                } = *proj;\n+                self.visit_lvalue(base, LvalueContext::Projection);\n+                self.visit_projection_elem(elem, context);\n+            }\n+\n+            fn super_projection_elem(&mut self,\n+                                     proj: & $($mutability)* LvalueElem<'tcx>,\n+                                     _context: LvalueContext) {\n+                match *proj {\n+                    ProjectionElem::Deref => {\n+                    }\n+                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n+                    }\n+                    ProjectionElem::Index(ref $($mutability)* operand) => {\n+                        self.visit_operand(operand);\n+                    }\n+                    ProjectionElem::ConstantIndex { offset: _,\n+                                                    min_length: _,\n+                                                    from_end: _ } => {\n+                    }\n+                    ProjectionElem::Downcast(_adt_def, _variant_index) => {\n+                    }\n+                }\n+            }\n+\n+            fn super_var_decl(&mut self,\n+                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n+                let VarDecl {\n+                    mutability: _,\n+                    name: _,\n+                    ref $($mutability)* ty,\n+                    ref $($mutability)* scope,\n+                    ref $($mutability)* span,\n+                } = *var_decl;\n+\n+                self.visit_ty(ty);\n+                self.visit_scope_id(scope);\n+                self.visit_span(span);\n+            }\n+\n+            fn super_temp_decl(&mut self,\n+                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n+                let TempDecl {\n+                    ref $($mutability)* ty,\n+                } = *temp_decl;\n+\n+                self.visit_ty(ty);\n+            }\n+\n+            fn super_arg_decl(&mut self,\n+                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n+                let ArgDecl {\n+                    ref $($mutability)* ty,\n+                    spread: _\n+                } = *arg_decl;\n+\n+                self.visit_ty(ty);\n+            }\n+\n+            fn super_scope_id(&mut self,\n+                              _scope_id: & $($mutability)* ScopeId) {\n+            }\n+\n             fn super_branch(&mut self,\n                             _source: BasicBlock,\n                             _target: BasicBlock) {\n@@ -312,17 +615,32 @@ macro_rules! make_mir_visitor {\n             fn super_constant(&mut self,\n                               constant: & $($mutability)* Constant<'tcx>) {\n                 self.visit_span(& $($mutability)* constant.span);\n+                self.visit_ty(& $($mutability)* constant.ty);\n                 self.visit_literal(& $($mutability)* constant.literal);\n             }\n \n+            fn super_typed_const_val(&mut self,\n+                                     constant: & $($mutability)* TypedConstVal<'tcx>) {\n+                let TypedConstVal {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* ty,\n+                    ref $($mutability)* value,\n+                } = *constant;\n+                self.visit_span(span);\n+                self.visit_ty(ty);\n+                self.visit_const_usize(value);\n+            }\n+\n             fn super_literal(&mut self,\n                              literal: & $($mutability)* Literal<'tcx>) {\n                 match *literal {\n-                    Literal::Item { ref $($mutability)* def_id, .. } => {\n+                    Literal::Item { ref $($mutability)* def_id,\n+                                    ref $($mutability)* substs } => {\n                         self.visit_def_id(def_id);\n+                        self.visit_substs(substs);\n                     },\n-                    Literal::Value { .. } => {\n-                        // Nothing to do\n+                    Literal::Value { ref $($mutability)* value } => {\n+                        self.visit_const_val(value);\n                     }\n                 }\n             }\n@@ -332,6 +650,32 @@ macro_rules! make_mir_visitor {\n \n             fn super_span(&mut self, _span: & $($mutability)* Span) {\n             }\n+\n+            fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n+                match *fn_output {\n+                    FnOutput::FnConverging(ref $($mutability)* ty) => {\n+                        self.visit_ty(ty);\n+                    }\n+                    FnOutput::FnDiverging => {\n+                    }\n+                }\n+            }\n+\n+            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            }\n+\n+            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            }\n+\n+            fn super_closure_substs(&mut self,\n+                                    _substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+            }\n+\n+            fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {\n+            }\n+\n+            fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n+            }\n         }\n     }\n }"}, {"sha": "bf532d9ccf9ed3263aedc2e79c78de71e500e1ef", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -663,6 +663,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print the result of the translation item collection pass\"),\n     mir_opt_level: Option<usize> = (None, parse_opt_uint,\n           \"set the MIR optimization level (0-3)\"),\n+    dump_mir: Option<String> = (None, parse_opt_string,\n+          \"dump MIR state at various points in translation\"),\n     orbit: bool = (false, parse_bool,\n           \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }"}, {"sha": "3c3a60b995ff0037ea632f66c15d59e96c6df616", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -410,29 +410,28 @@ impl<D: BitDenotation> DataflowState<D> {\n         bb: &repr::BasicBlockData,\n         on_return: OnReturn) where OnReturn: Fn(&D, &mut [usize], &repr::Lvalue)\n     {\n-        let term = if let Some(ref term) = bb.terminator { term } else { return };\n-        match *term {\n-            repr::Terminator::Return |\n-            repr::Terminator::Resume => {}\n-            repr::Terminator::Goto { ref target } |\n-            repr::Terminator::Drop { ref target, value: _, unwind: None } => {\n+        match bb.terminator().kind {\n+            repr::TerminatorKind::Return |\n+            repr::TerminatorKind::Resume => {}\n+            repr::TerminatorKind::Goto { ref target } |\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n-            repr::Terminator::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n             }\n-            repr::Terminator::If { ref targets, .. } => {\n+            repr::TerminatorKind::If { ref targets, .. } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n             }\n-            repr::Terminator::Switch { ref targets, .. } |\n-            repr::Terminator::SwitchInt { ref targets, .. } => {\n+            repr::TerminatorKind::Switch { ref targets, .. } |\n+            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 }\n             }\n-            repr::Terminator::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n                 if let Some(ref unwind) = *cleanup {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n                 }"}, {"sha": "46eb3d3ca03e5297c4aeeffe997d7477006bb533", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n \n-use rustc::middle::ty;\n-use rustc::mir::repr::{self, Mir, BasicBlock, Lvalue, Rvalue};\n-use rustc::mir::repr::{StatementKind, Terminator};\n+use rustc::middle::ty::TyCtxt;\n+use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n \n use std::cell::{Cell};\n@@ -361,7 +360,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n     }\n \n     fn lookup_proj(&mut self,\n-                   proj: &repr::LvalueProjection<'tcx>,\n+                   proj: &LvalueProjection<'tcx>,\n                    base: MovePathIndex) -> Lookup<MovePathIndex> {\n         let MovePathLookup { ref mut projections,\n                              ref mut next_index, .. } = *self;\n@@ -484,7 +483,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n }\n \n impl<'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> Self {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> Self {\n         gather_moves(mir, tcx)\n     }\n }\n@@ -495,7 +494,7 @@ enum StmtKind {\n     Aggregate, Drop, CallFn, CallArg, Return,\n }\n \n-fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx> {\n+fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n     let bbs = mir.all_basic_blocks();\n@@ -554,9 +553,9 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n                         Rvalue::Box(ref _ty) => {\n                             // this is creating uninitialized\n                             // memory that needs to be initialized.\n-                            let deref_lval = Lvalue::Projection(Box::new( repr::Projection {\n+                            let deref_lval = Lvalue::Projection(Box::new(Projection {\n                                 base: lval.clone(),\n-                                elem: repr::ProjectionElem::Deref,\n+                                elem: ProjectionElem::Deref,\n                             }));\n                             bb_ctxt.on_move_out_lval(SK::Box, &deref_lval, source);\n                         }\n@@ -577,50 +576,48 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n             }\n         }\n \n-        if let Some(ref term) = bb_data.terminator {\n-            match *term {\n-                Terminator::Goto { target: _ } | Terminator::Resume => { }\n+        match bb_data.terminator().kind {\n+            TerminatorKind::Goto { target: _ } | TerminatorKind::Resume => { }\n \n-                Terminator::Return => {\n-                    let source = Location { block: bb,\n-                                            index: bb_data.statements.len() };\n-                    let lval = &Lvalue::ReturnPointer.deref();\n-                    bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n-                }\n+            TerminatorKind::Return => {\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                let lval = &Lvalue::ReturnPointer.deref();\n+                bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n+            }\n \n-                Terminator::If { ref cond, targets: _ } => {\n-                    // The `cond` is always of (copyable) type `bool`,\n-                    // so there will never be anything to move.\n-                    let _ = cond;\n-                }\n+            TerminatorKind::If { ref cond, targets: _ } => {\n+                // The `cond` is always of (copyable) type `bool`,\n+                // so there will never be anything to move.\n+                let _ = cond;\n+            }\n \n-                Terminator::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n-                Terminator::Switch { adt_def: _, targets: _, ref discr } => {\n-                    // The `discr` is not consumed; that is instead\n-                    // encoded on specific match arms (and for\n-                    // SwitchInt`, it is always a copyable integer\n-                    // type anyway).\n-                    let _ = discr;\n-                }\n+            TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n+            TerminatorKind::Switch { adt_def: _, targets: _, ref discr } => {\n+                // The `discr` is not consumed; that is instead\n+                // encoded on specific match arms (and for\n+                // SwitchInt`, it is always a copyable integer\n+                // type anyway).\n+                let _ = discr;\n+            }\n \n-                Terminator::Drop { value: ref lval, target: _, unwind: _ } => {\n-                    let source = Location { block: bb,\n-                                            index: bb_data.statements.len() };\n-                    bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n-                }\n+            TerminatorKind::Drop { value: ref lval, target: _, unwind: _ } => {\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n+            }\n \n-                Terminator::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                    let source = Location { block: bb,\n-                                            index: bb_data.statements.len() };\n-                    bb_ctxt.on_operand(SK::CallFn, func, source);\n-                    for arg in args {\n-                        bb_ctxt.on_operand(SK::CallArg, arg, source);\n-                    }\n-                    if let Some((ref destination, _bb)) = *destination {\n-                        // Create MovePath for `destination`, then\n-                        // discard returned index.\n-                        bb_ctxt.builder.move_path_for(destination);\n-                    }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                bb_ctxt.on_operand(SK::CallFn, func, source);\n+                for arg in args {\n+                    bb_ctxt.on_operand(SK::CallArg, arg, source);\n+                }\n+                if let Some((ref destination, _bb)) = *destination {\n+                    // Create MovePath for `destination`, then\n+                    // discard returned index.\n+                    bb_ctxt.builder.move_path_for(destination);\n                 }\n             }\n         }\n@@ -670,7 +667,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: &'b ty::TyCtxt<'tcx>,\n+    tcx: &'b TyCtxt<'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n@@ -680,7 +677,7 @@ struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n     fn on_move_out_lval(&mut self,\n                         stmt_kind: StmtKind,\n-                        lval: &repr::Lvalue<'tcx>,\n+                        lval: &Lvalue<'tcx>,\n                         source: Location) {\n         let tcx = self.tcx;\n         let lval_ty = self.builder.mir.lvalue_ty(tcx, lval);\n@@ -726,10 +723,10 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n         self.loc_map_bb[i].push(index);\n     }\n \n-    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &repr::Operand<'tcx>, source: Location) {\n+    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &Operand<'tcx>, source: Location) {\n         match *operand {\n-            repr::Operand::Constant(..) => {} // not-a-move\n-            repr::Operand::Consume(ref lval) => { // a move\n+            Operand::Constant(..) => {} // not-a-move\n+            Operand::Consume(ref lval) => { // a move\n                 self.on_move_out_lval(stmt_kind, lval, source);\n             }\n         }"}, {"sha": "ef48a408e79a79746cf7eb8be65a3a0e005cf3ab", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -20,7 +20,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n-        self.in_scope(extent, block, move |this| {\n+        self.in_scope(extent, block, move |this, _| {\n             // This convoluted structure is to avoid using recursion as we walk down a list\n             // of statements. Basically, the structure we get back is something like:\n             //\n@@ -42,23 +42,24 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let Stmt { span: _, kind } = this.hir.mirror(stmt);\n                 match kind {\n                     StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this| {\n+                        unpack!(block = this.in_scope(scope, block, |this, _| {\n                             let expr = this.hir.mirror(expr);\n+                            let expr_span = expr.span;\n                             let temp = this.temp(expr.ty.clone());\n                             unpack!(block = this.into(&temp, block, expr));\n-                            unpack!(block = this.build_drop(block, temp));\n+                            unpack!(block = this.build_drop(block, expr_span, temp));\n                             block.unit()\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        this.push_scope(remainder_scope);\n+                        let remainder_scope_id = this.push_scope(remainder_scope, block);\n                         let_extent_stack.push(remainder_scope);\n-                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                        unpack!(block = this.in_scope(init_scope, block, move |this, _| {\n                             // FIXME #30046                              ^~~~\n                             if let Some(init) = initializer {\n-                                this.expr_into_pattern(block, remainder_scope, pattern, init)\n+                                this.expr_into_pattern(block, remainder_scope_id, pattern, init)\n                             } else {\n-                                this.declare_bindings(remainder_scope, &pattern);\n+                                this.declare_bindings(remainder_scope_id, &pattern);\n                                 block.unit()\n                             }\n                         }));\n@@ -71,7 +72,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 unpack!(block = this.into(destination, block, expr));\n             } else {\n                 // FIXME(#31472)\n-                this.cfg.push_assign_unit(block, span, destination);\n+                let scope_id = this.innermost_scope_id();\n+                this.cfg.push_assign_unit(block, scope_id, span, destination);\n             }\n             // Finally, we pop all the let scopes before exiting out from the scope of block\n             // itself."}, {"sha": "4859257f291c9767f694b9d4171ddcfeaabb0805", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -13,7 +13,7 @@\n \n //! Routines for manipulating the control-flow graph.\n \n-use build::CFG;\n+use build::{CFG, Location};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n@@ -43,39 +43,55 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n+    pub fn current_location(&mut self, block: BasicBlock) -> Location {\n+        let index = self.block_data(block).statements.len();\n+        Location { block: block, statement_index: index }\n+    }\n+\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n+                       scope: ScopeId,\n                        span: Span,\n                        lvalue: &Lvalue<'tcx>,\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n+            scope: scope,\n             span: span,\n             kind: StatementKind::Assign(lvalue.clone(), rvalue)\n         });\n     }\n \n     pub fn push_assign_constant(&mut self,\n                                 block: BasicBlock,\n+                                scope: ScopeId,\n                                 span: Span,\n                                 temp: &Lvalue<'tcx>,\n                                 constant: Constant<'tcx>) {\n-        self.push_assign(block, span, temp, Rvalue::Use(Operand::Constant(constant)));\n+        self.push_assign(block, scope, span, temp,\n+                         Rvalue::Use(Operand::Constant(constant)));\n     }\n \n     pub fn push_assign_unit(&mut self,\n                             block: BasicBlock,\n+                            scope: ScopeId,\n                             span: Span,\n                             lvalue: &Lvalue<'tcx>) {\n-        self.push_assign(block, span, lvalue, Rvalue::Aggregate(\n+        self.push_assign(block, scope, span, lvalue, Rvalue::Aggregate(\n             AggregateKind::Tuple, vec![]\n         ));\n     }\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n-                     terminator: Terminator<'tcx>) {\n+                     scope: ScopeId,\n+                     span: Span,\n+                     kind: TerminatorKind<'tcx>) {\n         debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n-        self.block_data_mut(block).terminator = Some(terminator);\n+        self.block_data_mut(block).terminator = Some(Terminator {\n+            span: span,\n+            scope: scope,\n+            kind: kind,\n+        });\n     }\n }"}, {"sha": "0c9323f4af3781ccacb2965cb57ab8e561370760", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -34,10 +34,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n+        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n+                this.in_scope(extent, block, |this, _| this.as_lvalue(block, value))\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n@@ -58,16 +59,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n-                this.cfg.push_assign(block, expr_span, // len = len(slice)\n+                this.cfg.push_assign(block, scope_id, expr_span, // len = len(slice)\n                                      &len, Rvalue::Len(slice.clone()));\n-                this.cfg.push_assign(block, expr_span, // lt = idx < len\n+                this.cfg.push_assign(block, scope_id, expr_span, // lt = idx < len\n                                      &lt, Rvalue::BinaryOp(BinOp::Lt,\n                                                            idx.clone(),\n                                                            Operand::Consume(len.clone())));\n \n                 let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n                 this.cfg.terminate(block,\n-                                   Terminator::If {\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::If {\n                                        cond: Operand::Consume(lt),\n                                        targets: (success, failure),\n                                    });"}, {"sha": "661d01ce989cd17595224db55a8b85c7d511d566", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -35,7 +35,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this, _| this.as_operand(block, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "b340d933e64c3f35f764399a378be2f28f0da6a0", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -33,11 +33,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n+        let scope_id = this.innermost_scope_id();\n         let expr_span = expr.span;\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this, _| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {\n                 let outputs = outputs.into_iter().map(|output| {\n@@ -75,8 +76,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                this.cfg.push_assign(block, expr_span, &result, Rvalue::Box(value.ty));\n-                this.in_scope(value_extents, block, |this| {\n+                this.cfg.push_assign(block, scope_id, expr_span, &result, Rvalue::Box(value.ty));\n+                this.in_scope(value_extents, block, |this, _| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n                     // initialize the box contents:"}, {"sha": "30a42bcd709d26db3906523d4b05bf36bc98497b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -30,7 +30,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n+            return this.in_scope(extent, block, |this, _| this.as_temp(block, value));\n         }\n \n         let expr_ty = expr.ty.clone();\n@@ -55,7 +55,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let expr_span = expr.span;\n                 let lvalue = unpack!(block = this.as_lvalue(block, expr));\n                 let rvalue = Rvalue::Use(Operand::Consume(lvalue));\n-                this.cfg.push_assign(block, expr_span, &temp, rvalue);\n+                let scope_id = this.innermost_scope_id();\n+                this.cfg.push_assign(block, scope_id, expr_span, &temp, rvalue);\n             }\n             _ => {\n                 unpack!(block = this.into(&temp, block, expr));"}, {"sha": "30c039cdde0c3e5b5ec13da488b71c02b68c3640", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -36,10 +36,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // just use the name `this` uniformly\n         let this = self;\n         let expr_span = expr.span;\n+        let scope_id = this.innermost_scope_id();\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.into(destination, block, value))\n+                this.in_scope(extent, block, |this, _| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block)\n@@ -52,7 +53,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                this.cfg.terminate(block, Terminator::If {\n+                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::If {\n                     cond: operand,\n                     targets: (then_block, else_block)\n                 });\n@@ -63,13 +64,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n-                    this.cfg.push_assign_unit(else_block, expr_span, destination);\n+                    let scope_id = this.innermost_scope_id();\n+                    this.cfg.push_assign_unit(else_block, scope_id, expr_span, destination);\n                     else_block\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(then_block, Terminator::Goto { target: join_block });\n-                this.cfg.terminate(else_block, Terminator::Goto { target: join_block });\n+                this.cfg.terminate(then_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(else_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n             }\n@@ -95,32 +103,41 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                this.cfg.terminate(block, Terminator::If { cond: lhs, targets: blocks });\n+                this.cfg.terminate(block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::If { cond: lhs, targets: blocks });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n-                this.cfg.terminate(else_block, Terminator::If {\n+                this.cfg.terminate(else_block, scope_id, expr_span, TerminatorKind::If {\n                     cond: rhs,\n                     targets: (true_block, false_block)\n                 });\n \n                 this.cfg.push_assign_constant(\n-                    true_block, expr_span, destination,\n+                    true_block, scope_id, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.true_literal(),\n                     });\n \n                 this.cfg.push_assign_constant(\n-                    false_block, expr_span, destination,\n+                    false_block, scope_id, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         literal: this.hir.false_literal(),\n                     });\n \n-                this.cfg.terminate(true_block, Terminator::Goto { target: join_block });\n-                this.cfg.terminate(false_block, Terminator::Goto { target: join_block });\n+                this.cfg.terminate(true_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(false_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n             }\n@@ -144,7 +161,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let exit_block = this.cfg.start_new_block();\n \n                 // start the loop\n-                this.cfg.terminate(block, Terminator::Goto { target: loop_block });\n+                this.cfg.terminate(block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: loop_block });\n \n                 let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n                     // conduct the test, if necessary\n@@ -157,7 +177,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n                         body_block = this.cfg.start_new_block();\n                         this.cfg.terminate(loop_block_end,\n-                                           Terminator::If {\n+                                           scope_id,\n+                                           expr_span,\n+                                           TerminatorKind::If {\n                                                cond: cond,\n                                                targets: (body_block, exit_block)\n                                            });\n@@ -173,23 +195,28 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n                     let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end, Terminator::Goto { target: loop_block });\n+                    this.cfg.terminate(body_block_end,\n+                                       scope_id,\n+                                       expr_span,\n+                                       TerminatorKind::Goto { target: loop_block });\n                 });\n                 // If the loop may reach its exit_block, we assign an empty tuple to the\n                 // destination to keep the MIR well-formed.\n                 if might_break {\n-                    this.cfg.push_assign_unit(exit_block, expr_span, destination);\n+                    this.cfg.push_assign_unit(exit_block, scope_id, expr_span, destination);\n                 }\n                 exit_block.unit()\n             }\n             ExprKind::Assign { lhs, rhs } => {\n                 // Note: we evaluate assignments right-to-left. This\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n+                let lhs = this.hir.mirror(lhs);\n+                let lhs_span = lhs.span;\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs.clone()));\n-                this.cfg.push_assign(block, expr_span, &lhs, Rvalue::Use(rhs));\n+                unpack!(block = this.build_drop(block, lhs_span, lhs.clone()));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, Rvalue::Use(rhs));\n                 block.unit()\n             }\n             ExprKind::AssignOp { op, lhs, rhs } => {\n@@ -208,7 +235,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, expr_span, &lhs,\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n                                      Rvalue::BinaryOp(op,\n                                                       Operand::Consume(lhs.clone()),\n                                                       rhs));\n@@ -229,11 +256,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 block = match value {\n                     Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n                     None => {\n-                        this.cfg.push_assign_unit(block, expr_span, &Lvalue::ReturnPointer);\n+                        this.cfg.push_assign_unit(block, scope_id,\n+                                                  expr_span, &Lvalue::ReturnPointer);\n                         block\n                     }\n                 };\n-                let extent = this.extent_of_outermost_scope();\n+                let extent = this.extent_of_return_scope();\n                 this.exit_scope(expr_span, extent, block, END_BLOCK);\n                 this.cfg.start_new_block().unit()\n             }\n@@ -252,7 +280,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, Terminator::Call {\n+                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::Call {\n                     func: fun,\n                     args: args,\n                     cleanup: cleanup,\n@@ -293,7 +321,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 });\n \n                 let rvalue = unpack!(block = this.as_rvalue(block, expr));\n-                this.cfg.push_assign(block, expr_span, destination, rvalue);\n+                this.cfg.push_assign(block, scope_id, expr_span, destination, rvalue);\n                 block.unit()\n             }\n         }"}, {"sha": "b1286e935b68434e3831589064b9bbea7446ba13", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -16,7 +16,6 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::{AdtDef, Ty};\n use rustc::mir::repr::*;\n use hair::*;\n@@ -42,9 +41,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // suitable extent for all of the bindings in this match. It's\n         // easiest to do this up front because some of these arms may\n         // be unreachable or reachable multiple times.\n-        let var_extent = self.extent_of_innermost_scope();\n+        let var_scope_id = self.innermost_scope_id();\n         for arm in &arms {\n-            self.declare_bindings(var_extent, &arm.patterns[0]);\n+            self.declare_bindings(var_scope_id, &arm.patterns[0]);\n         }\n \n         let mut arm_blocks = ArmBlocks {\n@@ -72,6 +71,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n+                        span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n@@ -88,7 +88,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // an empty vector to be returned here, but the algorithm is\n         // not entirely precise\n         if !otherwise.is_empty() {\n-            let join_block = self.join_otherwise_blocks(otherwise);\n+            let join_block = self.join_otherwise_blocks(span, otherwise);\n             self.panic(join_block, \"something about matches algorithm not being precise\", span);\n         }\n \n@@ -98,15 +98,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         for (arm_index, arm_body) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n             unpack!(arm_block = self.into(destination, arm_block, arm_body));\n-            self.cfg.terminate(arm_block, Terminator::Goto { target: end_block });\n+            self.cfg.terminate(arm_block,\n+                               var_scope_id,\n+                               span,\n+                               TerminatorKind::Goto { target: end_block });\n         }\n \n         end_block.unit()\n     }\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_extent: CodeExtent, // lifetime of vars\n+                             var_scope_id: ScopeId, // lifetime of vars\n                              irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n@@ -118,7 +121,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                    var,\n                                    ty,\n                                    subpattern: None } => {\n-                let index = self.declare_binding(var_extent,\n+                let index = self.declare_binding(var_scope_id,\n                                                  mutability,\n                                                  name,\n                                                  var,\n@@ -131,22 +134,23 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n-                                 var_extent,\n+                                 var_scope_id,\n                                  irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n-                               var_extent: CodeExtent,\n+                               var_scope_id: ScopeId,\n                                irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n         // first, creating the bindings\n-        self.declare_bindings(var_extent, &irrefutable_pat);\n+        self.declare_bindings(var_scope_id, &irrefutable_pat);\n \n         // create a dummy candidate\n         let mut candidate = Candidate {\n+            span: irrefutable_pat.span,\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             guard: None,\n@@ -170,29 +174,29 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: &Pattern<'tcx>) {\n+    pub fn declare_bindings(&mut self, var_scope_id: ScopeId, pattern: &Pattern<'tcx>) {\n         match *pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n+                self.declare_binding(var_scope_id, mutability, name, var, ty, pattern.span);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.declare_bindings(var_extent, subpattern);\n+                    self.declare_bindings(var_scope_id, subpattern);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.declare_bindings(var_extent, subpattern);\n+                    self.declare_bindings(var_scope_id, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.declare_bindings(var_extent, subpattern);\n+                self.declare_bindings(var_scope_id, subpattern);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_extent, &subpattern.pattern);\n+                    self.declare_bindings(var_scope_id, &subpattern.pattern);\n                 }\n             }\n         }\n@@ -207,6 +211,9 @@ struct ArmBlocks {\n \n #[derive(Clone, Debug)]\n pub struct Candidate<'pat, 'tcx:'pat> {\n+    // span of the original pattern that gave rise to this candidate\n+    span: Span,\n+\n     // all of these must be satisfied...\n     match_pairs: Vec<MatchPair<'pat, 'tcx>>,\n \n@@ -371,20 +378,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n \n         // Otherwise, let's process those remaining candidates.\n-        let join_block = self.join_otherwise_blocks(otherwise);\n+        let join_block = self.join_otherwise_blocks(span, otherwise);\n         self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n     fn join_otherwise_blocks(&mut self,\n+                             span: Span,\n                              otherwise: Vec<BasicBlock>)\n                              -> BasicBlock\n     {\n+        let scope_id = self.innermost_scope_id();\n         if otherwise.len() == 1 {\n             otherwise[0]\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block, Terminator::Goto { target: join_block });\n+                self.cfg.terminate(block,\n+                                   scope_id,\n+                                   span,\n+                                   TerminatorKind::Goto { target: join_block });\n             }\n             join_block\n         }\n@@ -551,16 +563,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n+        let scope_id = self.innermost_scope_id();\n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n+            let guard = self.hir.mirror(guard);\n+            let guard_span = guard.span;\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n-            self.cfg.terminate(block, Terminator::If { cond: cond,\n-                                                       targets: (arm_block, otherwise)});\n+            self.cfg.terminate(block,\n+                               scope_id,\n+                               guard_span,\n+                               TerminatorKind::If { cond: cond,\n+                                                    targets: (arm_block, otherwise)});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block, Terminator::Goto { target: arm_block });\n+            self.cfg.terminate(block,\n+                               scope_id,\n+                               candidate.span,\n+                               TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n@@ -585,30 +606,35 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };\n \n-            self.cfg.push_assign(block, binding.span, &Lvalue::Var(var_index), rvalue);\n+            let scope_id = self.innermost_scope_id();\n+            self.cfg.push_assign(block, scope_id, binding.span,\n+                                 &Lvalue::Var(var_index), rvalue);\n         }\n     }\n \n     fn declare_binding(&mut self,\n-                       var_extent: CodeExtent,\n+                       var_scope_id: ScopeId,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        span: Span)\n                        -> u32\n     {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_extent={:?}, span={:?})\",\n-               var_id, name, var_ty, var_extent, span);\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_scope_id={:?}, span={:?})\",\n+               var_id, name, var_ty, var_scope_id, span);\n \n         let index = self.var_decls.len();\n         self.var_decls.push(VarDecl::<'tcx> {\n+            scope: var_scope_id,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n+            span: span,\n         });\n         let index = index as u32;\n-        self.schedule_drop(span, var_extent, &Lvalue::Var(index), var_ty);\n+        let extent = self.scope_auxiliary[var_scope_id].extent;\n+        self.schedule_drop(span, extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "3211e5849a06c8c213135e3db6c0e395d0288638", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -146,13 +146,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         lvalue: &Lvalue<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n+        let scope_id = self.innermost_scope_id();\n         match test.kind {\n             TestKind::Switch { adt_def } => {\n                 let num_enum_variants = self.hir.num_variants(adt_def);\n                 let target_blocks: Vec<_> =\n                     (0..num_enum_variants).map(|_| self.cfg.start_new_block())\n                                           .collect();\n-                self.cfg.terminate(block, Terminator::Switch {\n+                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Switch {\n                     discr: lvalue.clone(),\n                     adt_def: adt_def,\n                     targets: target_blocks.clone()\n@@ -167,12 +168,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            .map(|_| self.cfg.start_new_block())\n                            .chain(Some(otherwise))\n                            .collect();\n-                self.cfg.terminate(block, Terminator::SwitchInt {\n-                    discr: lvalue.clone(),\n-                    switch_ty: switch_ty,\n-                    values: options.clone(),\n-                    targets: targets.clone(),\n-                });\n+                self.cfg.terminate(block,\n+                                   scope_id,\n+                                   test.span,\n+                                   TerminatorKind::SwitchInt {\n+                                       discr: lvalue.clone(),\n+                                       switch_ty: switch_ty,\n+                                       values: options.clone(),\n+                                       targets: targets.clone(),\n+                                   });\n                 targets\n             }\n \n@@ -189,7 +193,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         if let ty::TyArray(_, _) = mt.ty.sty {\n                             ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n                             let val_slice = self.temp(ty);\n-                            self.cfg.push_assign(block, test.span, &val_slice,\n+                            self.cfg.push_assign(block, scope_id, test.span, &val_slice,\n                                                  Rvalue::Cast(CastKind::Unsize, val, ty));\n                             val = Operand::Consume(val_slice);\n                         }\n@@ -204,7 +208,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     });\n \n                     let slice = self.temp(ty);\n-                    self.cfg.push_assign(block, test.span, &slice,\n+                    self.cfg.push_assign(block, scope_id, test.span, &slice,\n                                          Rvalue::Cast(CastKind::Unsize, array, ty));\n                     Operand::Consume(slice)\n                 } else {\n@@ -225,7 +229,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     let eq_result = self.temp(bool_ty);\n                     let eq_block = self.cfg.start_new_block();\n                     let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, Terminator::Call {\n+                    self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Call {\n                         func: Operand::Constant(Constant {\n                             span: test.span,\n                             ty: mty,\n@@ -238,7 +242,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                     // check the result\n                     let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, Terminator::If {\n+                    self.cfg.terminate(eq_block, scope_id, test.span, TerminatorKind::If {\n                         cond: Operand::Consume(eq_result),\n                         targets: (block, fail),\n                     });\n@@ -268,13 +272,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n \n                 // actual = len(lvalue)\n-                self.cfg.push_assign(block, test.span, &actual, Rvalue::Len(lvalue.clone()));\n+                self.cfg.push_assign(block, scope_id, test.span,\n+                                     &actual, Rvalue::Len(lvalue.clone()));\n \n                 // expected = <N>\n-                let expected = self.push_usize(block, test.span, len);\n+                let expected = self.push_usize(block, scope_id, test.span, len);\n \n                 // result = actual == expected OR result = actual < expected\n                 self.cfg.push_assign(block,\n+                                     scope_id,\n                                      test.span,\n                                      &result,\n                                      Rvalue::BinaryOp(op,\n@@ -284,7 +290,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // branch based on result\n                 let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n                                                  self.cfg.start_new_block()];\n-                self.cfg.terminate(block, Terminator::If {\n+                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::If {\n                     cond: Operand::Consume(result),\n                     targets: (target_blocks[0], target_blocks[1])\n                 });\n@@ -305,11 +311,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let result = self.temp(bool_ty);\n \n         // result = op(left, right)\n-        self.cfg.push_assign(block, span, &result, Rvalue::BinaryOp(op, left, right));\n+        let scope_id = self.innermost_scope_id();\n+        self.cfg.push_assign(block, scope_id, span, &result,\n+                             Rvalue::BinaryOp(op, left, right));\n \n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, Terminator::If {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::If {\n             cond: Operand::Consume(result),\n             targets: (target_block, fail_block)\n         });\n@@ -462,6 +470,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                  .map(|(_, mp)| mp.clone())\n                                  .collect();\n         Candidate {\n+            span: candidate.span,\n             match_pairs: other_match_pairs,\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n@@ -503,6 +512,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n \n         Candidate {\n+            span: candidate.span,\n             match_pairs: all_match_pairs,\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),"}, {"sha": "101d7594309a9a505b2ca2b12187627a37d8468d", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -61,7 +61,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 from_end: suffix_len,\n             };\n             let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n-            self.cfg.push_assign(block, slice.span, &temp, rvalue);\n+            let scope_id = self.innermost_scope_id();\n+            self.cfg.push_assign(block, scope_id, slice.span, &temp, rvalue);\n             match_pairs.push(MatchPair::new(temp, slice));\n         }\n "}, {"sha": "0d1690783301be37dc0efbfdb1aa59112743d4a1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -46,11 +46,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         Operand::Constant(constant)\n     }\n \n-    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: u64) -> Lvalue<'tcx> {\n+    pub fn push_usize(&mut self,\n+                      block: BasicBlock,\n+                      scope_id: ScopeId,\n+                      span: Span,\n+                      value: u64)\n+                      -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant(\n-            block, span, &temp,\n+            block, scope_id, span, &temp,\n             Constant {\n                 span: span,\n                 ty: self.hir.usize_ty(),"}, {"sha": "b79f492179fb9363cbdd583f4a472ea75bf911b8", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 167, "deletions": 51, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -9,30 +9,106 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::ty::{FnOutput, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_front::hir;\n-\n+use std::ops::{Index, IndexMut};\n use syntax::ast;\n use syntax::codemap::Span;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n     cfg: CFG<'tcx>,\n+\n+    fn_span: Span,\n+\n+    // the current set of scopes, updated as we traverse;\n+    // see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n+\n+    // for each scope, a span of blocks that defines it;\n+    // we track these for use in region and borrow checking,\n+    // but these are liable to get out of date once optimization\n+    // begins. They are also hopefully temporary, and will be\n+    // no longer needed when we adopt graph-based regions.\n+    scope_auxiliary: ScopeAuxiliaryVec,\n+\n+    // the current set of loops; see the `scope` module for more\n+    // details\n     loop_scopes: Vec<scope::LoopScope>,\n+\n+    // the vector of all scopes that we have created thus far;\n+    // we track this for debuginfo later\n+    scope_datas: Vec<ScopeData>,\n+\n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n     temp_decls: Vec<TempDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n+\n+    // cached block with a RESUME terminator; we create this at the\n+    // first panic\n+    cached_resume_block: Option<BasicBlock>,\n }\n \n struct CFG<'tcx> {\n     basic_blocks: Vec<BasicBlockData<'tcx>>,\n }\n \n+/// For each scope, we track the extent (from the HIR) and a\n+/// single-entry-multiple-exit subgraph that contains all the\n+/// statements/terminators within it.\n+///\n+/// This information is separated out from the main `ScopeData`\n+/// because it is short-lived. First, the extent contains node-ids,\n+/// so it cannot be saved and re-loaded. Second, any optimization will mess up\n+/// the dominator/postdominator information.\n+///\n+/// The intention is basically to use this information to do\n+/// regionck/borrowck and then throw it away once we are done.\n+pub struct ScopeAuxiliary {\n+    /// extent of this scope from the MIR.\n+    pub extent: CodeExtent,\n+\n+    /// \"entry point\": dominator of all nodes in the scope\n+    pub dom: Location,\n+\n+    /// \"exit points\": mutual postdominators of all nodes in the scope\n+    pub postdoms: Vec<Location>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Location {\n+    /// the location is within this block\n+    pub block: BasicBlock,\n+\n+    /// the location is the start of the this statement; or, if `statement_index`\n+    /// == num-statements, then the start of the terminator.\n+    pub statement_index: usize,\n+}\n+\n+pub struct ScopeAuxiliaryVec {\n+    pub vec: Vec<ScopeAuxiliary>\n+}\n+\n+impl Index<ScopeId> for ScopeAuxiliaryVec {\n+    type Output = ScopeAuxiliary;\n+\n+    #[inline]\n+    fn index(&self, index: ScopeId) -> &ScopeAuxiliary {\n+        &self.vec[index.index()]\n+    }\n+}\n+\n+impl IndexMut<ScopeId> for ScopeAuxiliaryVec {\n+    #[inline]\n+    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeAuxiliary {\n+        &mut self.vec[index.index()]\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n /// The `BlockAnd` \"monad\" packages up the new basic block along with a\n /// produced value (sometimes just unit, of course). The `unpack!`\n@@ -81,86 +157,126 @@ macro_rules! unpack {\n \n pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                           span: Span,\n+                          fn_id: ast::NodeId,\n+                          body_id: ast::NodeId,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n                           explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                          argument_extent: CodeExtent,\n                           return_ty: FnOutput<'tcx>,\n                           ast_block: &'tcx hir::Block)\n-                          -> Mir<'tcx> {\n+                          -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+    let tcx = hir.tcx();\n     let cfg = CFG { basic_blocks: vec![] };\n \n     let mut builder = Builder {\n         hir: hir,\n         cfg: cfg,\n+        fn_span: span,\n         scopes: vec![],\n+        scope_datas: vec![],\n+        scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n         loop_scopes: vec![],\n         temp_decls: vec![],\n         var_decls: vec![],\n         var_indices: FnvHashMap(),\n         unit_temp: None,\n+        cached_resume_block: None,\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n     assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n \n-    let mut block = START_BLOCK;\n-    let arg_decls = unpack!(block = builder.args_and_body(block,\n-                                                          implicit_arguments,\n-                                                          explicit_arguments,\n-                                                          argument_extent,\n-                                                          ast_block));\n-\n-    builder.cfg.terminate(block, Terminator::Goto { target: END_BLOCK });\n-    builder.cfg.terminate(END_BLOCK, Terminator::Return);\n-\n-    Mir {\n-        basic_blocks: builder.cfg.basic_blocks,\n-        var_decls: builder.var_decls,\n-        arg_decls: arg_decls,\n-        temp_decls: builder.temp_decls,\n-        return_ty: return_ty,\n-        span: span\n-    }\n+\n+    let mut arg_decls = None; // assigned to `Some` in closures below\n+    let call_site_extent =\n+        tcx.region_maps.lookup_code_extent(\n+            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n+    let _ = builder.in_scope(call_site_extent, START_BLOCK, |builder, call_site_scope_id| {\n+        let mut block = START_BLOCK;\n+        let arg_extent =\n+            tcx.region_maps.lookup_code_extent(\n+                CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+        unpack!(block = builder.in_scope(arg_extent, block, |builder, arg_scope_id| {\n+            arg_decls = Some(unpack!(block = builder.args_and_body(block,\n+                                                                   implicit_arguments,\n+                                                                   explicit_arguments,\n+                                                                   arg_scope_id,\n+                                                                   ast_block)));\n+            block.unit()\n+        }));\n+\n+        builder.cfg.terminate(block, call_site_scope_id, span,\n+                              TerminatorKind::Goto { target: END_BLOCK });\n+        builder.cfg.terminate(END_BLOCK, call_site_scope_id, span,\n+                              TerminatorKind::Return);\n+\n+        END_BLOCK.unit()\n+    });\n+\n+    assert!(\n+        builder.cfg.basic_blocks\n+                   .iter()\n+                   .enumerate()\n+                   .all(|(index, block)| {\n+                       if block.terminator.is_none() {\n+                           panic!(\"no terminator on block {:?} in fn {:?}\",\n+                               index, fn_id)\n+                       }\n+                       true\n+                   }));\n+\n+    (\n+        Mir {\n+            basic_blocks: builder.cfg.basic_blocks,\n+            scopes: builder.scope_datas,\n+            var_decls: builder.var_decls,\n+            arg_decls: arg_decls.take().expect(\"args never built?\"),\n+            temp_decls: builder.temp_decls,\n+            return_ty: return_ty,\n+            span: span\n+        },\n+        builder.scope_auxiliary,\n+    )\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      implicit_arguments: Vec<Ty<'tcx>>,\n                      explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                     argument_extent: CodeExtent,\n+                     argument_scope_id: ScopeId,\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<Vec<ArgDecl<'tcx>>>\n     {\n-        self.in_scope(argument_extent, block, |this| {\n-            // to start, translate the argument patterns and collect the argument types.\n-            let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n-            let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n+        // to start, translate the argument patterns and collect the argument types.\n+        let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n+        let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n             let arg_decls =\n-                implicits\n-                .chain(explicits)\n-                .enumerate()\n-                .map(|(index, (ty, pattern))| {\n-                    let lvalue = Lvalue::Arg(index as u32);\n-                    if let Some(pattern) = pattern {\n-                        let pattern = this.hir.irrefutable_pat(pattern);\n-                        unpack!(block = this.lvalue_into_pattern(block,\n-                                                                 argument_extent,\n-                                                                 pattern,\n-                                                                 &lvalue));\n-                    }\n-                    // Make sure we drop (parts of) the argument even when not matched on.\n-                    this.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n-                                       argument_extent, &lvalue, ty);\n-                    ArgDecl { ty: ty, spread: false }\n-                })\n-                .collect();\n-\n-            // start the first basic block and translate the body\n-            unpack!(block = this.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n-\n-            block.and(arg_decls)\n-        })\n+            implicits\n+            .chain(explicits)\n+            .enumerate()\n+            .map(|(index, (ty, pattern))| {\n+                let lvalue = Lvalue::Arg(index as u32);\n+                if let Some(pattern) = pattern {\n+                    let pattern = self.hir.irrefutable_pat(pattern);\n+                    unpack!(block = self.lvalue_into_pattern(block,\n+                                                             argument_scope_id,\n+                                                             pattern,\n+                                                             &lvalue));\n+                }\n+\n+                // Make sure we drop (parts of) the argument even when not matched on.\n+                let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n+                self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+                                   argument_extent, &lvalue, ty);\n+\n+                ArgDecl { ty: ty, spread: false }\n+            })\n+            .collect();\n+\n+        // start the first basic block and translate the body\n+        unpack!(block = self.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n+\n+        block.and(arg_decls)\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "f5f6f409eaba4d6ab2725685f8b26ede4a1d4422", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 215, "deletions": 124, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -86,8 +86,8 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use rustc::middle::region::CodeExtent;\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary};\n+use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::middle::subst::{Substs, Subst, VecPerParamSpace};\n use rustc::middle::ty::{self, Ty, TyCtxt};\n@@ -98,35 +98,66 @@ use rustc::middle::const_eval::ConstVal;\n use rustc_const_eval::ConstInt;\n \n pub struct Scope<'tcx> {\n+    /// the scope-id within the scope_datas\n+    id: ScopeId,\n+\n+    /// the extent of this scope within source code; also stored in\n+    /// `ScopeAuxiliary`, but kept here for convenience\n     extent: CodeExtent,\n+\n+    /// set of lvalues to drop when exiting this scope. This starts\n+    /// out empty but grows as variables are declared during the\n+    /// building process. This is a stack, so we always drop from the\n+    /// end of the vector (top of the stack) first.\n     drops: Vec<DropData<'tcx>>,\n-    // A scope may only have one associated free, because:\n-    // 1. We require a `free` to only be scheduled in the scope of `EXPR` in `box EXPR`;\n-    // 2. It only makes sense to have it translated into the diverge-path.\n-    //\n-    // This kind of drop will be run *after* all the regular drops scheduled onto this scope,\n-    // because drops may have dependencies on the allocated memory.\n-    //\n-    // This is expected to go away once `box EXPR` becomes a sugar for placement protocol and gets\n-    // desugared in some earlier stage.\n+\n+    /// A scope may only have one associated free, because:\n+    ///\n+    /// 1. We require a `free` to only be scheduled in the scope of\n+    ///    `EXPR` in `box EXPR`;\n+    /// 2. It only makes sense to have it translated into the diverge-path.\n+    ///\n+    /// This kind of drop will be run *after* all the regular drops\n+    /// scheduled onto this scope, because drops may have dependencies\n+    /// on the allocated memory.\n+    ///\n+    /// This is expected to go away once `box EXPR` becomes a sugar\n+    /// for placement protocol and gets desugared in some earlier\n+    /// stage.\n     free: Option<FreeData<'tcx>>,\n+\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains a block that will just do a RESUME to an appropriate\n+    /// place. This block does not execute any of the drops or free:\n+    /// each of those has their own cached-blocks, which will branch\n+    /// to this point.\n+    cached_block: Option<BasicBlock>\n }\n \n struct DropData<'tcx> {\n+    /// span where drop obligation was incurred (typically where lvalue was declared)\n+    span: Span,\n+\n+    /// lvalue to drop\n     value: Lvalue<'tcx>,\n-    // NB: per-drop \u201ccache\u201d is necessary for the build_scope_drops function below.\n-    /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n-    /// current drop and all the preceding drops (i.e. those having lower index in Drop\u2019s\n-    /// Scope drop array)\n+\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains code to run the current drop and all the preceding\n+    /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n+    /// array)\n     cached_block: Option<BasicBlock>\n }\n \n struct FreeData<'tcx> {\n+    /// span where free obligation was incurred\n     span: Span,\n+\n     /// Lvalue containing the allocated box.\n     value: Lvalue<'tcx>,\n+\n     /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n     item_ty: Ty<'tcx>,\n+\n     /// The cached block containing code to run the free. The block will also execute all the drops\n     /// in the scope.\n     cached_block: Option<BasicBlock>\n@@ -151,6 +182,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     fn invalidate_cache(&mut self) {\n+        self.cached_block = None;\n         for dropdata in &mut self.drops {\n             dropdata.cached_block = None;\n         }\n@@ -205,11 +237,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'tcx>, ScopeId) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent);\n-        let rv = unpack!(block = f(self));\n+        let id = self.push_scope(extent, block);\n+        let rv = unpack!(block = f(self, id));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n@@ -219,26 +251,46 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent) {\n+    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) -> ScopeId {\n         debug!(\"push_scope({:?})\", extent);\n+        let parent_id = self.scopes.last().map(|s| s.id);\n+        let id = ScopeId::new(self.scope_datas.len());\n+        self.scope_datas.push(ScopeData {\n+            parent_scope: parent_id,\n+        });\n         self.scopes.push(Scope {\n-            extent: extent.clone(),\n+            id: id,\n+            extent: extent,\n             drops: vec![],\n-            free: None\n+            free: None,\n+            cached_block: None,\n         });\n+        self.scope_auxiliary.vec.push(ScopeAuxiliary {\n+            extent: extent,\n+            dom: self.cfg.current_location(entry),\n+            postdoms: vec![]\n+        });\n+        id\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n-    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) -> BlockAnd<()> {\n+    pub fn pop_scope(&mut self,\n+                     extent: CodeExtent,\n+                     mut block: BasicBlock)\n+                     -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n         // We need to have `cached_block`s available for all the drops, so we call diverge_cleanup\n         // to make sure all the `cached_block`s are filled in.\n         self.diverge_cleanup();\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.extent, extent);\n-        build_scope_drops(&mut self.cfg, &scope, &self.scopes[..], block)\n+        unpack!(block = build_scope_drops(&mut self.cfg, &scope, &self.scopes, block));\n+        self.scope_auxiliary[scope.id]\n+            .postdoms\n+            .push(self.cfg.current_location(block));\n+        block.unit()\n     }\n \n \n@@ -265,12 +317,24 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                               block));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n-                let free = build_free(self.hir.tcx(), tmp.clone(), free_data, next);\n-                self.cfg.terminate(block, free);\n+                let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n+                self.cfg.terminate(block, scope.id, span, free);\n                 block = next;\n             }\n+            self.scope_auxiliary[scope.id]\n+                .postdoms\n+                .push(self.cfg.current_location(block));\n         }\n-        self.cfg.terminate(block, Terminator::Goto { target: target });\n+\n+        assert!(scope_count < self.scopes.len(),\n+                \"should never use `exit_scope` to pop *ALL* scopes\");\n+        let scope = self.scopes.iter().rev().skip(scope_count)\n+                                            .next()\n+                                            .unwrap();\n+        self.cfg.terminate(block,\n+                           scope.id,\n+                           span,\n+                           TerminatorKind::Goto { target: target });\n     }\n \n     // Finding scopes\n@@ -297,12 +361,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n     }\n \n+    pub fn innermost_scope_id(&self) -> ScopeId {\n+        self.scopes.last().map(|scope| scope.id).unwrap()\n+    }\n+\n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n         self.scopes.last().map(|scope| scope.extent).unwrap()\n     }\n \n-    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n-        self.scopes.first().map(|scope| scope.extent).unwrap()\n+    /// Returns the extent of the scope which should be exited by a\n+    /// return.\n+    pub fn extent_of_return_scope(&self) -> CodeExtent {\n+        // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n+        // We want `scopes[1]`, which is the `ParameterScope`.\n+        assert!(self.scopes.len() >= 2);\n+        assert!(match self.hir.tcx().region_maps.code_extent_data(self.scopes[1].extent) {\n+            CodeExtentData::ParameterScope { .. } => true,\n+            _ => false,\n+        });\n+        self.scopes[1].extent\n     }\n \n     // Scheduling drops\n@@ -322,6 +399,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // No need to invalidate any caches here. The just-scheduled drop will branch into\n                 // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n+                    span: span,\n                     value: lvalue.clone(),\n                     cached_block: None\n                 });\n@@ -378,36 +456,60 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n     pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n-        if self.scopes.is_empty() {\n+        if self.scopes.iter().all(|scope| scope.drops.is_empty() && scope.free.is_none()) {\n             return None;\n         }\n+        assert!(!self.scopes.is_empty()); // or `all` above would be true\n+\n         let unit_temp = self.get_unit_temp();\n-        let Builder { ref mut hir, ref mut cfg, ref mut scopes, .. } = *self;\n-        let mut next_block = None;\n-\n-        // Given an array of scopes, we generate these from the outermost scope to the innermost\n-        // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n-        // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n-        // always ends up at a block with the Resume terminator.\n-        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n-            next_block = Some(build_diverge_scope(hir.tcx(),\n-                                                  cfg,\n-                                                  unit_temp.clone(),\n-                                                  scope,\n-                                                  next_block));\n+        let Builder { ref mut hir, ref mut cfg, ref mut scopes,\n+                      ref mut cached_resume_block, .. } = *self;\n+\n+        // Build up the drops in **reverse** order. The end result will\n+        // look like:\n+        //\n+        //    scopes[n] -> scopes[n-1] -> ... -> scopes[0]\n+        //\n+        // However, we build this in **reverse order**. That is, we\n+        // process scopes[0], then scopes[1], etc, pointing each one at\n+        // the result generates from the one before. Along the way, we\n+        // store caches. If everything is cached, we'll just walk right\n+        // to left reading the cached results but never created anything.\n+\n+        // To start, create the resume terminator.\n+        let mut target = if let Some(target) = *cached_resume_block {\n+            target\n+        } else {\n+            let resumeblk = cfg.start_new_cleanup_block();\n+            cfg.terminate(resumeblk, scopes[0].id, self.fn_span, TerminatorKind::Resume);\n+            *cached_resume_block = Some(resumeblk);\n+            resumeblk\n+        };\n+\n+        for scope in scopes {\n+            target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n-        scopes.iter().rev().flat_map(|x| x.cached_block()).next()\n+\n+        Some(target)\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n-    pub fn build_drop(&mut self, block: BasicBlock, value: Lvalue<'tcx>) -> BlockAnd<()> {\n+    pub fn build_drop(&mut self,\n+                      block: BasicBlock,\n+                      span: Span,\n+                      value: Lvalue<'tcx>)\n+                      -> BlockAnd<()> {\n+        let scope_id = self.innermost_scope_id();\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block, Terminator::Drop {\n-            value: value,\n-            target: next_target,\n-            unwind: diverge_target,\n-        });\n+        self.cfg.terminate(block,\n+                           scope_id,\n+                           span,\n+                           TerminatorKind::Drop {\n+                               value: value,\n+                               target: next_target,\n+                               unwind: diverge_target,\n+                           });\n         next_target.unit()\n     }\n \n@@ -416,10 +518,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     // =========\n     // FIXME: should be moved into their own module\n     pub fn panic_bounds_check(&mut self,\n-                             block: BasicBlock,\n-                             index: Operand<'tcx>,\n-                             len: Operand<'tcx>,\n-                             span: Span) {\n+                              block: BasicBlock,\n+                              index: Operand<'tcx>,\n+                              len: Operand<'tcx>,\n+                              span: Span) {\n         // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n         let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n         let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n@@ -435,16 +537,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n         let (file, line) = self.span_to_fileline_args(span);\n         let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n+        let scope_id = self.innermost_scope_id();\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, span, &tuple, // tuple = (file_arg, line_arg);\n+        self.cfg.push_assign(block, scope_id, span, &tuple, // tuple = (file_arg, line_arg);\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, span, &tuple_ref, // tuple_ref = &tuple;\n+        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, Terminator::Call {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref), index, len],\n             destination: None,\n@@ -476,16 +579,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let elems = vec![Operand::Constant(message),\n                          Operand::Constant(file),\n                          Operand::Constant(line)];\n+        let scope_id = self.innermost_scope_id();\n         // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n         // icache with cold branch code), however to achieve that we either have to rely on rvalue\n         // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, span, &tuple, // tuple = (message_arg, file_arg, line_arg);\n+        self.cfg.push_assign(block, scope_id, span, &tuple, // [1]\n                              Rvalue::Aggregate(AggregateKind::Tuple, elems));\n+        // [1] tuple = (message_arg, file_arg, line_arg);\n         // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, span, &tuple_ref, // tuple_ref = &tuple;\n+        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, Terminator::Call {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n             cleanup: cleanup,\n@@ -544,7 +649,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n         });\n         let next = cfg.start_new_block();\n-        cfg.terminate(block, Terminator::Drop {\n+        cfg.terminate(block, scope.id, drop_data.span, TerminatorKind::Drop {\n             value: drop_data.value.clone(),\n             target: next,\n             unwind: on_diverge\n@@ -556,89 +661,75 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n \n fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n                              cfg: &mut CFG<'tcx>,\n-                             unit_temp: Lvalue<'tcx>,\n+                             unit_temp: &Lvalue<'tcx>,\n                              scope: &mut Scope<'tcx>,\n-                             target: Option<BasicBlock>)\n-                             -> BasicBlock {\n-    debug_assert!(!scope.drops.is_empty() || scope.free.is_some());\n-\n-    // First, we build the drops, iterating the drops array in reverse. We do that so that as soon\n-    // as we find a `cached_block`, we know that we\u2019re finished and don\u2019t need to do anything else.\n-    let mut previous = None;\n-    let mut last_drop_block = None;\n-    for drop_data in scope.drops.iter_mut().rev() {\n-        if let Some(cached_block) = drop_data.cached_block {\n-            if let Some((previous_block, previous_value)) = previous {\n-                cfg.terminate(previous_block, Terminator::Drop {\n-                    value: previous_value,\n-                    target: cached_block,\n-                    unwind: None\n-                });\n-                return last_drop_block.unwrap();\n-            } else {\n-                return cached_block;\n-            }\n-        } else {\n-            let block = cfg.start_new_cleanup_block();\n-            drop_data.cached_block = Some(block);\n-            if let Some((previous_block, previous_value)) = previous {\n-                cfg.terminate(previous_block, Terminator::Drop {\n-                    value: previous_value,\n-                    target: block,\n-                    unwind: None\n-                });\n-            } else {\n-                last_drop_block = Some(block);\n-            }\n-            previous = Some((block, drop_data.value.clone()));\n-        }\n-    }\n-\n-    // Prepare the end target for this chain.\n-    let mut target = target.unwrap_or_else(||{\n-        let b = cfg.start_new_cleanup_block();\n-        cfg.terminate(b, Terminator::Resume);\n-        b\n-    });\n+                             mut target: BasicBlock)\n+                             -> BasicBlock\n+{\n+    // Build up the drops in **reverse** order. The end result will\n+    // look like:\n+    //\n+    //    [drops[n]] -...-> [drops[0]] -> [Free] -> [target]\n+    //    |                                    |\n+    //    +------------------------------------+\n+    //     code for scope\n+    //\n+    // The code in this function reads from right to left. At each\n+    // point, we check for cached blocks representing the\n+    // remainder. If everything is cached, we'll just walk right to\n+    // left reading the cached results but never created anything.\n \n-    // Then, build the free branching into the prepared target.\n+    // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n         target = if let Some(cached_block) = free_data.cached_block {\n             cached_block\n         } else {\n             let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into, build_free(tcx, unit_temp, free_data, target));\n+            cfg.terminate(into,\n+                          scope.id,\n+                          free_data.span,\n+                          build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n             into\n-        }\n-    };\n-\n-    if let Some((previous_block, previous_value)) = previous {\n-        // Finally, branch into that just-built `target` from the `previous_block`.\n-        cfg.terminate(previous_block, Terminator::Drop {\n-            value: previous_value,\n-            target: target,\n-            unwind: None\n-        });\n-        last_drop_block.unwrap()\n-    } else {\n-        // If `previous.is_none()`, there were no drops in this scope \u2013 we return the\n-        // target.\n-        target\n+        };\n+    }\n+\n+    // Next, build up the drops. Here we iterate the vector in\n+    // *forward* order, so that we generate drops[0] first (right to\n+    // left in diagram above).\n+    for drop_data in &mut scope.drops {\n+        target = if let Some(cached_block) = drop_data.cached_block {\n+            cached_block\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            cfg.terminate(block,\n+                          scope.id,\n+                          drop_data.span,\n+                          TerminatorKind::Drop {\n+                              value: drop_data.value.clone(),\n+                              target: target,\n+                              unwind: None\n+                          });\n+            drop_data.cached_block = Some(block);\n+            block\n+        };\n     }\n+\n+    target\n }\n \n fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    unit_temp: Lvalue<'tcx>,\n+                    unit_temp: &Lvalue<'tcx>,\n                     data: &FreeData<'tcx>,\n-                    target: BasicBlock) -> Terminator<'tcx> {\n+                    target: BasicBlock)\n+                    -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n     let substs = tcx.mk_substs(Substs::new(\n         VecPerParamSpace::new(vec![], vec![], vec![data.item_ty]),\n         VecPerParamSpace::new(vec![], vec![], vec![])\n     ));\n-    Terminator::Call {\n+    TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,\n             ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n@@ -648,7 +739,7 @@ fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n             }\n         }),\n         args: vec![Operand::Consume(data.value.clone())],\n-        destination: Some((unit_temp, target)),\n+        destination: Some((unit_temp.clone(), target)),\n         cleanup: None\n     }\n }"}, {"sha": "a5e749ea6870eab568244089fe9a07e29da5e2a6", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -83,7 +83,7 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n     // Terminator head at the bottom, not including the list of successor blocks. Those will be\n     // displayed as labels on the edges between blocks.\n     let mut terminator_head = String::new();\n-    data.terminator().fmt_head(&mut terminator_head).unwrap();\n+    data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n     write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head))?;\n \n     fini(w)?;\n@@ -104,7 +104,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n     let terminator = &mir.basic_block_data(source).terminator();\n-    let labels = terminator.fmt_successor_labels();\n+    let labels = terminator.kind.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().iter().zip(labels) {\n         writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label)?;"}, {"sha": "5a6e2edfdf9e78745df9a95d8822f96237ecfd63", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -22,11 +22,11 @@ extern crate rustc_front;\n use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n+use pretty;\n use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n use rustc::middle::infer;\n-use rustc::middle::region::CodeExtentData;\n use rustc::middle::traits::ProjectionMode;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::util::common::ErrorReported;\n@@ -179,11 +179,15 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n             })\n             .collect();\n \n-    let parameter_scope =\n-        cx.tcx().region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n-    let mut mir = build::construct(cx, span, implicit_arg_tys, arguments,\n-                                  parameter_scope, fn_sig.output, body);\n+    let (mut mir, scope_auxiliary) =\n+        build::construct(cx,\n+                         span,\n+                         fn_id,\n+                         body.id,\n+                         implicit_arg_tys,\n+                         arguments,\n+                         fn_sig.output,\n+                         body);\n \n     match cx.tcx().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n@@ -195,6 +199,13 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n         _ => {}\n     }\n \n+    pretty::dump_mir(cx.tcx(),\n+                     \"mir_map\",\n+                     &0,\n+                     fn_id,\n+                     &mir,\n+                     Some(&scope_auxiliary));\n+\n     Ok(mir)\n }\n "}, {"sha": "834897f8eaee0d77d749a9922a11217a9c101707", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 179, "deletions": 15, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -8,50 +8,214 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build::{Location, ScopeAuxiliaryVec};\n use rustc::mir::repr::*;\n-use rustc::middle::ty;\n+use rustc::middle::ty::{self, TyCtxt};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::fmt::Display;\n+use std::fs;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n \n+/// If the session is properly configured, dumps a human-readable\n+/// representation of the mir into:\n+///\n+/// ```\n+/// rustc.node<node_id>.<pass_name>.<disambiguator>\n+/// ```\n+///\n+/// Output from this function is controlled by passing `-Z dump-mir=<filter>`,\n+/// where `<filter>` takes the following forms:\n+///\n+/// - `all` -- dump MIR for all fns, all passes, all everything\n+/// - `substring1&substring2,...` -- `&`-separated list of substrings\n+///   that can appear in the pass-name or the `item_path_str` for the given\n+///   node-id. If any one of the substrings match, the data is dumped out.\n+pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+                          pass_name: &str,\n+                          disambiguator: &Display,\n+                          node_id: NodeId,\n+                          mir: &Mir<'tcx>,\n+                          auxiliary: Option<&ScopeAuxiliaryVec>) {\n+    let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n+        None => return,\n+        Some(ref filters) => filters,\n+    };\n+    let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n+    let is_matched =\n+        filters.split(\"&\")\n+               .any(|filter| {\n+                   filter == \"all\" ||\n+                       pass_name.contains(filter) ||\n+                       node_path.contains(filter)\n+               });\n+    if !is_matched {\n+        return;\n+    }\n+\n+    let file_name = format!(\"rustc.node{}.{}.{}.mir\",\n+                            node_id, pass_name, disambiguator);\n+    let _ = fs::File::create(&file_name).and_then(|mut file| {\n+        try!(writeln!(file, \"// MIR for `{}`\", node_path));\n+        try!(writeln!(file, \"// node_id = {}\", node_id));\n+        try!(writeln!(file, \"// pass_name = {}\", pass_name));\n+        try!(writeln!(file, \"// disambiguator = {}\", disambiguator));\n+        try!(writeln!(file, \"\"));\n+        try!(write_mir_fn(tcx, node_id, mir, &mut file, auxiliary));\n+        Ok(())\n+    });\n+}\n+\n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n-where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n-    for (&nodeid, mir) in iter {\n-        write_mir_intro(tcx, nodeid, mir, w)?;\n-        // Nodes\n-        for block in mir.all_basic_blocks() {\n-            write_basic_block(block, mir, w)?;\n+pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n+                                     iter: I,\n+                                     w: &mut Write)\n+                                     -> io::Result<()>\n+    where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n+{\n+    for (&node_id, mir) in iter {\n+        write_mir_fn(tcx, node_id, mir, w, None)?;\n+    }\n+    Ok(())\n+}\n+\n+enum Annotation {\n+    EnterScope(ScopeId),\n+    ExitScope(ScopeId),\n+}\n+\n+pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n+                          node_id: NodeId,\n+                          mir: &Mir<'tcx>,\n+                          w: &mut Write,\n+                          auxiliary: Option<&ScopeAuxiliaryVec>)\n+                          -> io::Result<()> {\n+    // compute scope/entry exit annotations\n+    let mut annotations = FnvHashMap();\n+    if let Some(auxiliary) = auxiliary {\n+        for (index, auxiliary) in auxiliary.vec.iter().enumerate() {\n+            let scope_id = ScopeId::new(index);\n+\n+            annotations.entry(auxiliary.dom)\n+                       .or_insert(vec![])\n+                       .push(Annotation::EnterScope(scope_id));\n+\n+            for &loc in &auxiliary.postdoms {\n+                annotations.entry(loc)\n+                           .or_insert(vec![])\n+                           .push(Annotation::ExitScope(scope_id));\n+            }\n         }\n-        writeln!(w, \"}}\")?\n     }\n+\n+    write_mir_intro(tcx, node_id, mir, w)?;\n+    for block in mir.all_basic_blocks() {\n+        write_basic_block(tcx, block, mir, w, &annotations)?;\n+    }\n+\n+    // construct a scope tree and write it out\n+    let mut scope_tree: FnvHashMap<Option<ScopeId>, Vec<ScopeId>> = FnvHashMap();\n+    for (index, scope_data) in mir.scopes.iter().enumerate() {\n+        scope_tree.entry(scope_data.parent_scope)\n+                  .or_insert(vec![])\n+                  .push(ScopeId::new(index));\n+    }\n+    write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1)?;\n+\n+    writeln!(w, \"}}\")?;\n     Ok(())\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+fn write_basic_block(tcx: &TyCtxt,\n+                     block: BasicBlock,\n+                     mir: &Mir,\n+                     w: &mut Write,\n+                     annotations: &FnvHashMap<Location, Vec<Annotation>>)\n+                     -> io::Result<()> {\n     let data = mir.basic_block_data(block);\n \n     // Basic block label at the top.\n     writeln!(w, \"\\n{}{:?}: {{\", INDENT, block)?;\n \n     // List of statements in the middle.\n+    let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n-        writeln!(w, \"{0}{0}{1:?};\", INDENT, statement)?;\n+        if let Some(ref annotations) = annotations.get(&current_location) {\n+            for annotation in annotations.iter() {\n+                match *annotation {\n+                    Annotation::EnterScope(id) =>\n+                        writeln!(w, \"{0}{0}// Enter Scope({1})\",\n+                                 INDENT, id.index())?,\n+                    Annotation::ExitScope(id) =>\n+                        writeln!(w, \"{0}{0}// Exit Scope({1})\",\n+                                 INDENT, id.index())?,\n+                }\n+            }\n+        }\n+\n+        writeln!(w, \"{0}{0}{1:?}; // {2}\",\n+                 INDENT,\n+                 statement,\n+                 comment(tcx, statement.scope, statement.span))?;\n+\n+        current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    writeln!(w, \"{0}{0}{1:?};\", INDENT, data.terminator())?;\n+    writeln!(w, \"{0}{0}{1:?}; // {2}\",\n+             INDENT,\n+             data.terminator().kind,\n+             comment(tcx, data.terminator().scope, data.terminator().span))?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n+fn comment(tcx: &TyCtxt,\n+           scope: ScopeId,\n+           span: Span)\n+           -> String {\n+    format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+}\n+\n+fn write_scope_tree(tcx: &TyCtxt,\n+                    mir: &Mir,\n+                    auxiliary: Option<&ScopeAuxiliaryVec>,\n+                    scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n+                    w: &mut Write,\n+                    parent: Option<ScopeId>,\n+                    depth: usize)\n+                    -> io::Result<()> {\n+    for &child in scope_tree.get(&parent).unwrap_or(&vec![]) {\n+        let indent = depth * INDENT.len();\n+        let data = &mir.scopes[child];\n+        assert_eq!(data.parent_scope, parent);\n+        writeln!(w, \"{0:1$}Scope({2}) {{\", \"\", indent, child.index())?;\n+\n+        let indent = indent + INDENT.len();\n+        if let Some(parent) = parent {\n+            writeln!(w, \"{0:1$}Parent: Scope({2})\", \"\", indent, parent.index())?;\n+        }\n+\n+        if let Some(auxiliary) = auxiliary {\n+            let extent = auxiliary[child].extent;\n+            let data = tcx.region_maps.code_extent_data(extent);\n+            writeln!(w, \"{0:1$}Extent: {2:?}\", \"\", indent, data)?;\n+        }\n+\n+        write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n+                         Some(child), depth + 1)?;\n+    }\n+    Ok(())\n+}\n+\n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n--> io::Result<()> {\n-\n+fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n+                   -> io::Result<()> {\n     write!(w, \"fn {}(\", tcx.map.path_to_string(nid))?;\n \n     // fn argument types."}, {"sha": "d8aa0d9b72503bd97513dfb28beeaa96521cd65e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -58,17 +58,17 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, bb: BasicBlock, terminator: &mut Terminator<'tcx>) {\n-        match *terminator {\n-            Terminator::Goto { .. } |\n-            Terminator::Resume |\n-            Terminator::Return |\n-            Terminator::If { .. } |\n-            Terminator::Switch { .. } |\n-            Terminator::Drop { .. } |\n-            Terminator::Call { .. } => {\n+        match terminator.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Switch { .. } |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::Call { .. } => {\n                 /* nothing to do */\n             },\n-            Terminator::SwitchInt { ref mut switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { ref mut switch_ty, .. } => {\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n         }"}, {"sha": "0e9a18107870eda3c0bdbe7ed2366f0c1908a6ca", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -21,19 +21,19 @@ pub struct NoLandingPads;\n \n impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n     fn visit_terminator(&mut self, bb: BasicBlock, terminator: &mut Terminator<'tcx>) {\n-        match *terminator {\n-            Terminator::Goto { .. } |\n-            Terminator::Resume |\n-            Terminator::Return |\n-            Terminator::If { .. } |\n-            Terminator::Switch { .. } |\n-            Terminator::SwitchInt { .. } => {\n+        match terminator.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Switch { .. } |\n+            TerminatorKind::SwitchInt { .. } => {\n                 /* nothing to do */\n             },\n-            Terminator::Drop { ref mut unwind, .. } => {\n+            TerminatorKind::Drop { ref mut unwind, .. } => {\n                 unwind.take();\n             },\n-            Terminator::Call { ref mut cleanup, .. } => {\n+            TerminatorKind::Call { ref mut cleanup, .. } => {\n                 cleanup.take();\n             },\n         }"}, {"sha": "21b1d022fda60a8d45e2fb824ed05bdf433741d3", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -12,6 +12,7 @@ use rustc::middle::const_eval::ConstVal;\n use rustc::middle::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, Pass};\n+use pretty;\n use syntax::ast::NodeId;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n@@ -30,15 +31,22 @@ impl SimplifyCfg {\n             let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n \n             while mir.basic_block_data(target).statements.is_empty() {\n-                match mir.basic_block_data(target).terminator {\n-                    Some(Terminator::Goto { target: next }) => {\n-                        if seen.contains(&next) {\n-                            return None;\n+                // NB -- terminator may have been swapped with `None`\n+                // below, in which case we have a cycle and just want\n+                // to stop\n+                if let Some(ref terminator) = mir.basic_block_data(target).terminator {\n+                    match terminator.kind {\n+                        TerminatorKind::Goto { target: next } => {\n+                            if seen.contains(&next) {\n+                                return None;\n+                            }\n+                            seen.push(next);\n+                            target = next;\n                         }\n-                        seen.push(next);\n-                        target = next;\n+                        _ => break\n                     }\n-                    _ => break\n+                } else {\n+                    break\n                 }\n             }\n \n@@ -51,6 +59,8 @@ impl SimplifyCfg {\n             let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n                                     .expect(\"invalid terminator state\");\n \n+            debug!(\"remove_goto_chains: bb={:?} terminator={:?}\", bb, terminator);\n+\n             for target in terminator.successors_mut() {\n                 let new_target = match final_target(mir, *target) {\n                     Some(new_target) => new_target,\n@@ -71,27 +81,27 @@ impl SimplifyCfg {\n         for bb in mir.all_basic_blocks() {\n             let basic_block = mir.basic_block_data_mut(bb);\n             let mut terminator = basic_block.terminator_mut();\n-            *terminator = match *terminator {\n-                Terminator::If { ref targets, .. } if targets.0 == targets.1 => {\n+            terminator.kind = match terminator.kind {\n+                TerminatorKind::If { ref targets, .. } if targets.0 == targets.1 => {\n                     changed = true;\n-                    Terminator::Goto { target: targets.0 }\n+                    TerminatorKind::Goto { target: targets.0 }\n                 }\n \n-                Terminator::If { ref targets, cond: Operand::Constant(Constant {\n+                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n                     literal: Literal::Value {\n                         value: ConstVal::Bool(cond)\n                     }, ..\n                 }) } => {\n                     changed = true;\n                     if cond {\n-                        Terminator::Goto { target: targets.0 }\n+                        TerminatorKind::Goto { target: targets.0 }\n                     } else {\n-                        Terminator::Goto { target: targets.1 }\n+                        TerminatorKind::Goto { target: targets.1 }\n                     }\n                 }\n \n-                Terminator::SwitchInt { ref targets, .. }  if targets.len() == 1 => {\n-                    Terminator::Goto { target: targets[0] }\n+                TerminatorKind::SwitchInt { ref targets, .. } if targets.len() == 1 => {\n+                    TerminatorKind::Goto { target: targets[0] }\n                 }\n                 _ => continue\n             }\n@@ -103,8 +113,11 @@ impl SimplifyCfg {\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n     fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+        let mut counter = 0;\n         let mut changed = true;\n         while changed {\n+            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, id, mir, None);\n+            counter += 1;\n             changed = self.simplify_branches(mir);\n             changed |= self.remove_goto_chains(mir);\n             RemoveDeadBlocks.run_pass(tcx, id, mir);"}, {"sha": "c0605ebe6d4a89cee8055f72fedd54b6b1457765", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -376,15 +376,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         term: &Terminator<'tcx>) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n-        match *term {\n-            Terminator::Goto { .. } |\n-            Terminator::Resume |\n-            Terminator::Return |\n-            Terminator::Drop { .. } => {\n+        match term.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Drop { .. } => {\n                 // no checks needed for these\n             }\n \n-            Terminator::If { ref cond, .. } => {\n+            TerminatorKind::If { ref cond, .. } => {\n                 let cond_ty = mir.operand_ty(tcx, cond);\n                 match cond_ty.sty {\n                     ty::TyBool => {}\n@@ -393,7 +393,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            Terminator::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n                 if let Err(terr) = self.mk_subty(self.last_span, discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            Terminator::Switch { ref discr, adt_def, ref targets } => {\n+            TerminatorKind::Switch { ref discr, adt_def, ref targets } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n                 match discr_ty.sty {\n                     ty::TyEnum(def, _)\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            Terminator::Call { ref func, ref args, ref destination, .. } => {\n+            TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n                 let func_ty = mir.operand_ty(tcx, func);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let func_ty = match func_ty.sty {"}, {"sha": "7abaeb44c1c29bfa4e814667069b3a65be952c86", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1578d37dc844ffeefcabc30960784082c3c54fa/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=f1578d37dc844ffeefcabc30960784082c3c54fa", "patch": "@@ -56,8 +56,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         debug!(\"trans_block: terminator: {:?}\", data.terminator());\n \n-        match *data.terminator() {\n-            mir::Terminator::Resume => {\n+        match data.terminator().kind {\n+            mir::TerminatorKind::Resume => {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n@@ -70,18 +70,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::Terminator::Goto { target } => {\n+            mir::TerminatorKind::Goto { target } => {\n                 funclet_br(bcx, self.llblock(target));\n             }\n \n-            mir::Terminator::If { ref cond, targets: (true_bb, false_bb) } => {\n+            mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(&bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n                 let llfalse = self.llblock(false_bb);\n                 bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n-            mir::Terminator::Switch { ref discr, ref adt_def, ref targets } => {\n+            mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, discr);\n                 let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -103,7 +103,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::Terminator::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n+            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n@@ -115,13 +115,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::Terminator::Return => {\n+            mir::TerminatorKind::Return => {\n                 bcx.with_block(|bcx| {\n                     self.fcx.build_return_block(bcx, DebugLoc::None);\n                 })\n             }\n \n-            mir::Terminator::Drop { ref value, target, unwind } => {\n+            mir::TerminatorKind::Drop { ref value, target, unwind } => {\n                 let lvalue = self.trans_lvalue(&bcx, value);\n                 let ty = lvalue.ty.to_ty(bcx.tcx());\n                 // Double check for necessity to drop\n@@ -152,7 +152,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n+            mir::TerminatorKind::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n "}]}