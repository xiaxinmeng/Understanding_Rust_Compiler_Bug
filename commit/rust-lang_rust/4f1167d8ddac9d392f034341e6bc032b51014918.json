{"sha": "4f1167d8ddac9d392f034341e6bc032b51014918", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTE2N2Q4ZGRhYzlkMzkyZjAzNDM0MWU2YmMwMzJiNTEwMTQ5MTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-11T11:37:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-11T11:37:04Z"}, "message": "Merge #5969\n\n5969: Propose module name completion options r=jonas-schievink a=SomeoneToIgnore\n\n<img width=\"539\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/92663009-cb0aec00-f308-11ea-9ef5-1faa91518031.png\">\r\n\r\nCurrently traverses the whole file set every time we try to complete the module, as discussed in https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/mod.3C.7C.3E.20completion\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "f26520ae48d4670aaefd2d62f9de37af30ef5bac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f26520ae48d4670aaefd2d62f9de37af30ef5bac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f1167d8ddac9d392f034341e6bc032b51014918", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfW2FgCRBK7hj4Ov3rIwAAdHIIADbGeS0pVskK0EaBJEREQxjt\nzBawW44PK0XjDSgSj0aMQwNGVcEGgOgE3r6nKIKHTJuLjPVu40MxGV7MMAkYcODI\nyiwv8NWy5121+3GfXSM9PXgcqSG8U2woP4EiZWaq5RILOOGW88lxQOwN0QnGyTNc\n/F57+nl1joDsyT0HRj5/JChUpzhoGpI9xsjulAaQ9GlnfFKPMB6KDc0//TszgltQ\nA5g0NAbkc7bC4qW/BGFLigRXLWzqh57IHNyBjACZW8F1LtqJFyYa9sUynqMeYD03\nB6/dxVHluUq6OGNoaVrtLoSnSW7idLbJeab5xsoDTIxcTM0ql9LhBugPEWvsufE=\n=C61m\n-----END PGP SIGNATURE-----\n", "payload": "tree f26520ae48d4670aaefd2d62f9de37af30ef5bac\nparent eb7136f76d3535fde25dc6f49e3035312f7cc84c\nparent ca698a0b8c78e5ba7738fc0f0f6f77718e70a83e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1599824224 +0000\ncommitter GitHub <noreply@github.com> 1599824224 +0000\n\nMerge #5969\n\n5969: Propose module name completion options r=jonas-schievink a=SomeoneToIgnore\n\n<img width=\"539\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/92663009-cb0aec00-f308-11ea-9ef5-1faa91518031.png\">\r\n\r\nCurrently traverses the whole file set every time we try to complete the module, as discussed in https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/mod.3C.7C.3E.20completion\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1167d8ddac9d392f034341e6bc032b51014918", "html_url": "https://github.com/rust-lang/rust/commit/4f1167d8ddac9d392f034341e6bc032b51014918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f1167d8ddac9d392f034341e6bc032b51014918/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb7136f76d3535fde25dc6f49e3035312f7cc84c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7136f76d3535fde25dc6f49e3035312f7cc84c", "html_url": "https://github.com/rust-lang/rust/commit/eb7136f76d3535fde25dc6f49e3035312f7cc84c"}, {"sha": "ca698a0b8c78e5ba7738fc0f0f6f77718e70a83e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca698a0b8c78e5ba7738fc0f0f6f77718e70a83e", "html_url": "https://github.com/rust-lang/rust/commit/ca698a0b8c78e5ba7738fc0f0f6f77718e70a83e"}], "stats": {"total": 436, "additions": 431, "deletions": 5}, "files": [{"sha": "9a61f1d5660877d40c6215a4fda547f7b59c0be7", "filename": "crates/base_db/src/input.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -12,7 +12,7 @@ use cfg::CfgOptions;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::SmolStr;\n use tt::TokenExpander;\n-use vfs::file_set::FileSet;\n+use vfs::{file_set::FileSet, VfsPath};\n \n pub use vfs::FileId;\n \n@@ -43,6 +43,12 @@ impl SourceRoot {\n     pub fn new_library(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: true, file_set }\n     }\n+    pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n+        self.file_set.path_for_file(file)\n+    }\n+    pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n+        self.file_set.file_for_path(path)\n+    }\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.file_set.iter()\n     }"}, {"sha": "daea2aa9585b187d8b3c5b97b4d11b7db06ae583", "filename": "crates/ide/src/completion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -19,6 +19,7 @@ mod complete_unqualified_path;\n mod complete_postfix;\n mod complete_macro_in_item_position;\n mod complete_trait_impl;\n+mod complete_mod;\n \n use ide_db::RootDatabase;\n \n@@ -124,6 +125,7 @@ pub(crate) fn completions(\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n     complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n+    complete_mod::complete_mod(&mut acc, &ctx);\n \n     Some(acc)\n }"}, {"sha": "f4a9864d10e7aab77d19c932c7c236b4a4be62f1", "filename": "crates/ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -13,6 +13,10 @@ use crate::completion::{\n };\n \n pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    if ctx.mod_declaration_under_caret.is_some() {\n+        return None;\n+    }\n+\n     let attribute = ctx.attribute_under_caret.as_ref()?;\n     match (attribute.path(), attribute.token_tree()) {\n         (Some(path), Some(token_tree)) if path.to_string() == \"derive\" => {"}, {"sha": "3cfc2e13140ae26bc3be9201133d74a6f03fb742", "filename": "crates/ide/src/completion/complete_mod.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -0,0 +1,324 @@\n+//! Completes mod declarations.\n+\n+use base_db::{SourceDatabaseExt, VfsPath};\n+use hir::{Module, ModuleSource};\n+use ide_db::RootDatabase;\n+use rustc_hash::FxHashSet;\n+\n+use crate::{CompletionItem, CompletionItemKind};\n+\n+use super::{\n+    completion_context::CompletionContext, completion_item::CompletionKind,\n+    completion_item::Completions,\n+};\n+\n+/// Complete mod declaration, i.e. `mod <|> ;`\n+pub(super) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let mod_under_caret = match &ctx.mod_declaration_under_caret {\n+        Some(mod_under_caret) if mod_under_caret.item_list().is_some() => return None,\n+        Some(mod_under_caret) => mod_under_caret,\n+        None => return None,\n+    };\n+\n+    let _p = profile::span(\"completion::complete_mod\");\n+\n+    let current_module = ctx.scope.module()?;\n+\n+    let module_definition_file =\n+        current_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n+    let source_root = ctx.db.source_root(ctx.db.file_source_root(module_definition_file));\n+    let directory_to_look_for_submodules = directory_to_look_for_submodules(\n+        current_module,\n+        ctx.db,\n+        source_root.path_for_file(&module_definition_file)?,\n+    )?;\n+\n+    let existing_mod_declarations = current_module\n+        .children(ctx.db)\n+        .filter_map(|module| Some(module.name(ctx.db)?.to_string()))\n+        .collect::<FxHashSet<_>>();\n+\n+    let module_declaration_file =\n+        current_module.declaration_source(ctx.db).map(|module_declaration_source_file| {\n+            module_declaration_source_file.file_id.original_file(ctx.db)\n+        });\n+\n+    source_root\n+        .iter()\n+        .filter(|submodule_candidate_file| submodule_candidate_file != &module_definition_file)\n+        .filter(|submodule_candidate_file| {\n+            Some(submodule_candidate_file) != module_declaration_file.as_ref()\n+        })\n+        .filter_map(|submodule_file| {\n+            let submodule_path = source_root.path_for_file(&submodule_file)?;\n+            let directory_with_submodule = submodule_path.parent()?;\n+            match submodule_path.name_and_extension()? {\n+                (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n+                (\"mod\", Some(\"rs\")) => {\n+                    if directory_with_submodule.parent()? == directory_to_look_for_submodules {\n+                        match directory_with_submodule.name_and_extension()? {\n+                            (directory_name, None) => Some(directory_name.to_owned()),\n+                            _ => None,\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }\n+                (file_name, Some(\"rs\"))\n+                    if directory_with_submodule == directory_to_look_for_submodules =>\n+                {\n+                    Some(file_name.to_owned())\n+                }\n+                _ => None,\n+            }\n+        })\n+        .filter(|name| !existing_mod_declarations.contains(name))\n+        .for_each(|submodule_name| {\n+            let mut label = submodule_name;\n+            if mod_under_caret.semicolon_token().is_none() {\n+                label.push(';')\n+            }\n+            acc.add(\n+                CompletionItem::new(CompletionKind::Magic, ctx.source_range(), &label)\n+                    .kind(CompletionItemKind::Module),\n+            )\n+        });\n+\n+    Some(())\n+}\n+\n+fn directory_to_look_for_submodules(\n+    module: Module,\n+    db: &RootDatabase,\n+    module_file_path: &VfsPath,\n+) -> Option<VfsPath> {\n+    let directory_with_module_path = module_file_path.parent()?;\n+    let base_directory = match module_file_path.name_and_extension()? {\n+        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n+            Some(directory_with_module_path)\n+        }\n+        (regular_rust_file_name, Some(\"rs\")) => {\n+            if matches!(\n+                (\n+                    directory_with_module_path\n+                        .parent()\n+                        .as_ref()\n+                        .and_then(|path| path.name_and_extension()),\n+                    directory_with_module_path.name_and_extension(),\n+                ),\n+                (Some((\"src\", None)), Some((\"bin\", None)))\n+            ) {\n+                // files in /src/bin/ can import each other directly\n+                Some(directory_with_module_path)\n+            } else {\n+                directory_with_module_path.join(regular_rust_file_name)\n+            }\n+        }\n+        _ => None,\n+    }?;\n+\n+    let mut resulting_path = base_directory;\n+    for module in module_chain_to_containing_module_file(module, db) {\n+        if let Some(name) = module.name(db) {\n+            resulting_path = resulting_path.join(&name.to_string())?;\n+        }\n+    }\n+\n+    Some(resulting_path)\n+}\n+\n+fn module_chain_to_containing_module_file(\n+    current_module: Module,\n+    db: &RootDatabase,\n+) -> Vec<Module> {\n+    let mut path = Vec::new();\n+\n+    let mut current_module = Some(current_module);\n+    while let Some(ModuleSource::Module(_)) =\n+        current_module.map(|module| module.definition_source(db).value)\n+    {\n+        if let Some(module) = current_module {\n+            path.insert(0, module);\n+            current_module = module.parent(db);\n+        } else {\n+            current_module = None;\n+        }\n+    }\n+\n+    path\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{test_utils::completion_list, CompletionKind};\n+    use expect_test::{expect, Expect};\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Magic);\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn lib_module_completion() {\n+        check(\n+            r#\"\n+            //- /lib.rs\n+            mod <|>\n+            //- /foo.rs\n+            fn foo() {}\n+            //- /foo/ignored_foo.rs\n+            fn ignored_foo() {}\n+            //- /bar/mod.rs\n+            fn bar() {}\n+            //- /bar/ignored_bar.rs\n+            fn ignored_bar() {}\n+        \"#,\n+            expect![[r#\"\n+                md bar;\n+                md foo;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn no_module_completion_with_module_body() {\n+        check(\n+            r#\"\n+            //- /lib.rs\n+            mod <|> {\n+\n+            }\n+            //- /foo.rs\n+            fn foo() {}\n+        \"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn main_module_completion() {\n+        check(\n+            r#\"\n+            //- /main.rs\n+            mod <|>\n+            //- /foo.rs\n+            fn foo() {}\n+            //- /foo/ignored_foo.rs\n+            fn ignored_foo() {}\n+            //- /bar/mod.rs\n+            fn bar() {}\n+            //- /bar/ignored_bar.rs\n+            fn ignored_bar() {}\n+        \"#,\n+            expect![[r#\"\n+                md bar;\n+                md foo;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn main_test_module_completion() {\n+        check(\n+            r#\"\n+            //- /main.rs\n+            mod tests {\n+                mod <|>;\n+            }\n+            //- /tests/foo.rs\n+            fn foo() {}\n+        \"#,\n+            expect![[r#\"\n+                md foo\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn directly_nested_module_completion() {\n+        check(\n+            r#\"\n+            //- /lib.rs\n+            mod foo;\n+            //- /foo.rs\n+            mod <|>;\n+            //- /foo/bar.rs\n+            fn bar() {}\n+            //- /foo/bar/ignored_bar.rs\n+            fn ignored_bar() {}\n+            //- /foo/baz/mod.rs\n+            fn baz() {}\n+            //- /foo/moar/ignored_moar.rs\n+            fn ignored_moar() {}\n+        \"#,\n+            expect![[r#\"\n+                md bar\n+                md baz\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_in_source_module_completion() {\n+        check(\n+            r#\"\n+            //- /lib.rs\n+            mod foo;\n+            //- /foo.rs\n+            mod bar {\n+                mod <|>\n+            }\n+            //- /foo/bar/baz.rs\n+            fn baz() {}\n+        \"#,\n+            expect![[r#\"\n+                md baz;\n+            \"#]],\n+        );\n+    }\n+\n+    // FIXME binary modules are not supported in tests properly\n+    // Binary modules are a bit special, they allow importing the modules from `/src/bin`\n+    // and that's why are good to test two things:\n+    // * no cycles are allowed in mod declarations\n+    // * no modules from the parent directory are proposed\n+    // Unfortunately, binary modules support is in cargo not rustc,\n+    // hence the test does not work now\n+    //\n+    // #[test]\n+    // fn regular_bin_module_completion() {\n+    //     check(\n+    //         r#\"\n+    //         //- /src/bin.rs\n+    //         fn main() {}\n+    //         //- /src/bin/foo.rs\n+    //         mod <|>\n+    //         //- /src/bin/bar.rs\n+    //         fn bar() {}\n+    //         //- /src/bin/bar/bar_ignored.rs\n+    //         fn bar_ignored() {}\n+    //     \"#,\n+    //         expect![[r#\"\n+    //             md bar;\n+    //         \"#]],\n+    //     );\n+    // }\n+\n+    #[test]\n+    fn already_declared_bin_module_completion_omitted() {\n+        check(\n+            r#\"\n+            //- /src/bin.rs\n+            fn main() {}\n+            //- /src/bin/foo.rs\n+            mod <|>\n+            //- /src/bin/bar.rs\n+            mod foo;\n+            fn bar() {}\n+            //- /src/bin/bar/bar_ignored.rs\n+            fn bar_ignored() {}\n+        \"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+}"}, {"sha": "79de50792782d237d33afe90be5a24df1e8c2fe2", "filename": "crates/ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -13,7 +13,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         None => return,\n     };\n \n-    if ctx.attribute_under_caret.is_some() {\n+    if ctx.attribute_under_caret.is_some() || ctx.mod_declaration_under_caret.is_some() {\n         return;\n     }\n "}, {"sha": "8eda4b64d49aa94d141b2911ea8518ff4bddc490", "filename": "crates/ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -13,6 +13,7 @@ pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     if ctx.record_lit_syntax.is_some()\n         || ctx.record_pat_syntax.is_some()\n         || ctx.attribute_under_caret.is_some()\n+        || ctx.mod_declaration_under_caret.is_some()\n     {\n         return;\n     }"}, {"sha": "161f59c1e48c5b6d7df563dad70b341f40410684", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -77,6 +77,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n     pub(super) attribute_under_caret: Option<ast::Attr>,\n+    pub(super) mod_declaration_under_caret: Option<ast::Module>,\n     pub(super) unsafe_is_prev: bool,\n     pub(super) if_is_prev: bool,\n     pub(super) block_expr_parent: bool,\n@@ -152,6 +153,7 @@ impl<'a> CompletionContext<'a> {\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n             attribute_under_caret: None,\n+            mod_declaration_under_caret: None,\n             unsafe_is_prev: false,\n             in_loop_body: false,\n             ref_pat_parent: false,\n@@ -238,7 +240,10 @@ impl<'a> CompletionContext<'a> {\n         self.trait_as_prev_sibling = has_trait_as_prev_sibling(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n         self.has_item_list_or_source_file_parent =\n-            has_item_list_or_source_file_parent(syntax_element);\n+            has_item_list_or_source_file_parent(syntax_element.clone());\n+        self.mod_declaration_under_caret =\n+            find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n+                .filter(|module| module.item_list().is_none());\n     }\n \n     fn fill("}, {"sha": "b17ddf1338a50b0cf89b470b9a01ccf402e98fc6", "filename": "crates/ide/src/completion/patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -115,6 +115,7 @@ pub(crate) fn if_is_prev(element: SyntaxElement) -> bool {\n         .filter(|it| it.kind() == IF_KW)\n         .is_some()\n }\n+\n #[test]\n fn test_if_is_prev() {\n     check_pattern_is_applicable(r\"if l<|>\", if_is_prev);"}, {"sha": "4aa2d6526be782bc26262922eb766f8669a08fd4", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -23,13 +23,22 @@ impl FileSet {\n         let mut base = self.paths[&anchor].clone();\n         base.pop();\n         let path = base.join(path)?;\n-        let res = self.files.get(&path).copied();\n-        res\n+        self.files.get(&path).copied()\n+    }\n+\n+    pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n+        self.files.get(path)\n     }\n+\n+    pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n+        self.paths.get(file)\n+    }\n+\n     pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n         self.files.insert(path.clone(), file_id);\n         self.paths.insert(file_id, path);\n     }\n+\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.paths.keys().copied()\n     }"}, {"sha": "022a0be1e39240fd9144d809d8afc81f7179c5b9", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1167d8ddac9d392f034341e6bc032b51014918/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=4f1167d8ddac9d392f034341e6bc032b51014918", "patch": "@@ -48,6 +48,24 @@ impl VfsPath {\n             (VfsPathRepr::VirtualPath(_), _) => false,\n         }\n     }\n+    pub fn parent(&self) -> Option<VfsPath> {\n+        let mut parent = self.clone();\n+        if parent.pop() {\n+            Some(parent)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n+        match &self.0 {\n+            VfsPathRepr::PathBuf(p) => Some((\n+                p.file_stem()?.to_str()?,\n+                p.extension().and_then(|extension| extension.to_str()),\n+            )),\n+            VfsPathRepr::VirtualPath(p) => p.name_and_extension(),\n+        }\n+    }\n \n     // Don't make this `pub`\n     pub(crate) fn encode(&self, buf: &mut Vec<u8>) {\n@@ -268,4 +286,60 @@ impl VirtualPath {\n         res.0 = format!(\"{}/{}\", res.0, path);\n         Some(res)\n     }\n+\n+    pub fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n+        let file_path = if self.0.ends_with('/') { &self.0[..&self.0.len() - 1] } else { &self.0 };\n+        let file_name = match file_path.rfind('/') {\n+            Some(position) => &file_path[position + 1..],\n+            None => file_path,\n+        };\n+\n+        if file_name.is_empty() {\n+            None\n+        } else {\n+            let mut file_stem_and_extension = file_name.rsplitn(2, '.');\n+            let extension = file_stem_and_extension.next();\n+            let file_stem = file_stem_and_extension.next();\n+\n+            match (file_stem, extension) {\n+                (None, None) => None,\n+                (None, Some(_)) | (Some(\"\"), Some(_)) => Some((file_name, None)),\n+                (Some(file_stem), extension) => Some((file_stem, extension)),\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn virtual_path_extensions() {\n+        assert_eq!(VirtualPath(\"/\".to_string()).name_and_extension(), None);\n+        assert_eq!(\n+            VirtualPath(\"/directory\".to_string()).name_and_extension(),\n+            Some((\"directory\", None))\n+        );\n+        assert_eq!(\n+            VirtualPath(\"/directory/\".to_string()).name_and_extension(),\n+            Some((\"directory\", None))\n+        );\n+        assert_eq!(\n+            VirtualPath(\"/directory/file\".to_string()).name_and_extension(),\n+            Some((\"file\", None))\n+        );\n+        assert_eq!(\n+            VirtualPath(\"/directory/.file\".to_string()).name_and_extension(),\n+            Some((\".file\", None))\n+        );\n+        assert_eq!(\n+            VirtualPath(\"/directory/.file.rs\".to_string()).name_and_extension(),\n+            Some((\".file\", Some(\"rs\")))\n+        );\n+        assert_eq!(\n+            VirtualPath(\"/directory/file.rs\".to_string()).name_and_extension(),\n+            Some((\"file\", Some(\"rs\")))\n+        );\n+    }\n }"}]}