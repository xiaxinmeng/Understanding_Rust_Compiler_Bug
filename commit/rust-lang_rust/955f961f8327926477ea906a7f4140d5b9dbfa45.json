{"sha": "955f961f8327926477ea906a7f4140d5b9dbfa45", "node_id": "C_kwDOAAsO6NoAKDk1NWY5NjFmODMyNzkyNjQ3N2VhOTA2YTdmNDE0MGQ1YjlkYmZhNDU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-29T21:56:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-29T22:22:30Z"}, "message": "merge two SB test files", "tree": {"sha": "02a38ff098620c37a2fab902548fc49b3fc644ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02a38ff098620c37a2fab902548fc49b3fc644ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/955f961f8327926477ea906a7f4140d5b9dbfa45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/955f961f8327926477ea906a7f4140d5b9dbfa45", "html_url": "https://github.com/rust-lang/rust/commit/955f961f8327926477ea906a7f4140d5b9dbfa45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/955f961f8327926477ea906a7f4140d5b9dbfa45/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4e86e103ec7e7c70376d178369eff084db8d237", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4e86e103ec7e7c70376d178369eff084db8d237", "html_url": "https://github.com/rust-lang/rust/commit/c4e86e103ec7e7c70376d178369eff084db8d237"}], "stats": {"total": 153, "additions": 74, "deletions": 79}, "files": [{"sha": "96ad67505a73e7451805f18e81fb9f6cc373ce54", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/955f961f8327926477ea906a7f4140d5b9dbfa45/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955f961f8327926477ea906a7f4140d5b9dbfa45/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=955f961f8327926477ea906a7f4140d5b9dbfa45", "patch": "@@ -1,5 +1,5 @@\n // compile-flags: -Zmiri-retag-fields\n-use std::cell::{Cell, RefCell, UnsafeCell};\n+use std::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use std::mem::{self, MaybeUninit};\n \n fn main() {\n@@ -9,6 +9,10 @@ fn main() {\n     unsafe_cell_2phase();\n     unsafe_cell_deallocate();\n     unsafe_cell_invalidate();\n+    refcell_basic();\n+    ref_protector();\n+    ref_mut_protector();\n+    rust_issue_68303();\n }\n \n fn aliasing_mut_and_shr() {\n@@ -100,3 +104,72 @@ fn unsafe_cell_invalidate() {\n     // So using raw1 invalidates raw2.\n     f(unsafe { mem::transmute(raw2) }, raw1);\n }\n+\n+fn refcell_basic() {\n+    let c = RefCell::new(42);\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+    {\n+        let mut m = c.borrow_mut();\n+        let _z: i32 = *m;\n+        {\n+            let s: &i32 = &*m;\n+            let _x = *s;\n+        }\n+        *m = 23;\n+        let _z: i32 = *m;\n+    }\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+}\n+\n+// Adding a Stacked Borrows protector for `Ref` would break this\n+fn ref_protector() {\n+    fn break_it(rc: &RefCell<i32>, r: Ref<'_, i32>) {\n+        // `r` has a shared reference, it is passed in as argument and hence\n+        // a protector is added that marks this memory as read-only for the entire\n+        // duration of this function.\n+        drop(r);\n+        // *oops* here we can mutate that memory.\n+        *rc.borrow_mut() = 2;\n+    }\n+\n+    let rc = RefCell::new(0);\n+    break_it(&rc, rc.borrow())\n+}\n+\n+fn ref_mut_protector() {\n+    fn break_it(rc: &RefCell<i32>, r: RefMut<'_, i32>) {\n+        // `r` has a shared reference, it is passed in as argument and hence\n+        // a protector is added that marks this memory as inaccessible for the entire\n+        // duration of this function\n+        drop(r);\n+        // *oops* here we can mutate that memory.\n+        *rc.borrow_mut() = 2;\n+    }\n+\n+    let rc = RefCell::new(0);\n+    break_it(&rc, rc.borrow_mut())\n+}\n+\n+/// Make sure we do not have bad enum layout optimizations.\n+fn rust_issue_68303() {\n+    let optional = Some(RefCell::new(false));\n+    let mut handle = optional.as_ref().unwrap().borrow_mut();\n+    assert!(optional.is_some());\n+    *handle = true;\n+}"}, {"sha": "e9d7f671528802e18c6d65ba363d9d94c7815f0e", "filename": "tests/pass/stacked-borrows/refcell.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e86e103ec7e7c70376d178369eff084db8d237/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs?ref=c4e86e103ec7e7c70376d178369eff084db8d237", "patch": "@@ -1,78 +0,0 @@\n-// compile-flags: -Zmiri-retag-fields\n-use std::cell::{Ref, RefCell, RefMut};\n-\n-fn main() {\n-    basic();\n-    ref_protector();\n-    ref_mut_protector();\n-    rust_issue_68303();\n-}\n-\n-fn basic() {\n-    let c = RefCell::new(42);\n-    {\n-        let s1 = c.borrow();\n-        let _x: i32 = *s1;\n-        let s2 = c.borrow();\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-    }\n-    {\n-        let mut m = c.borrow_mut();\n-        let _z: i32 = *m;\n-        {\n-            let s: &i32 = &*m;\n-            let _x = *s;\n-        }\n-        *m = 23;\n-        let _z: i32 = *m;\n-    }\n-    {\n-        let s1 = c.borrow();\n-        let _x: i32 = *s1;\n-        let s2 = c.borrow();\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-        let _x: i32 = *s1;\n-        let _y: i32 = *s2;\n-    }\n-}\n-\n-// Adding a Stacked Borrows protector for `Ref` would break this\n-fn ref_protector() {\n-    fn break_it(rc: &RefCell<i32>, r: Ref<'_, i32>) {\n-        // `r` has a shared reference, it is passed in as argument and hence\n-        // a protector is added that marks this memory as read-only for the entire\n-        // duration of this function.\n-        drop(r);\n-        // *oops* here we can mutate that memory.\n-        *rc.borrow_mut() = 2;\n-    }\n-\n-    let rc = RefCell::new(0);\n-    break_it(&rc, rc.borrow())\n-}\n-\n-fn ref_mut_protector() {\n-    fn break_it(rc: &RefCell<i32>, r: RefMut<'_, i32>) {\n-        // `r` has a shared reference, it is passed in as argument and hence\n-        // a protector is added that marks this memory as inaccessible for the entire\n-        // duration of this function\n-        drop(r);\n-        // *oops* here we can mutate that memory.\n-        *rc.borrow_mut() = 2;\n-    }\n-\n-    let rc = RefCell::new(0);\n-    break_it(&rc, rc.borrow_mut())\n-}\n-\n-/// Make sure we do not have bad enum layout optimizations.\n-fn rust_issue_68303() {\n-    let optional = Some(RefCell::new(false));\n-    let mut handle = optional.as_ref().unwrap().borrow_mut();\n-    assert!(optional.is_some());\n-    *handle = true;\n-}"}]}