{"sha": "0e166bb217463a26028ad9b1724e686d54ba1415", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMTY2YmIyMTc0NjNhMjYwMjhhZDliMTcyNGU2ODZkNTRiYTE0MTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-01T14:47:06Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-29T16:17:13Z"}, "message": "Remove a lot of methods from *TypeMethods", "tree": {"sha": "b25776fc7a5ade4cd72d39068ad06183a6b657a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25776fc7a5ade4cd72d39068ad06183a6b657a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e166bb217463a26028ad9b1724e686d54ba1415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e166bb217463a26028ad9b1724e686d54ba1415", "html_url": "https://github.com/rust-lang/rust/commit/0e166bb217463a26028ad9b1724e686d54ba1415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e166bb217463a26028ad9b1724e686d54ba1415/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0ee1f7f99c1190d51ecdb592e23b868f488a346", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0ee1f7f99c1190d51ecdb592e23b868f488a346", "html_url": "https://github.com/rust-lang/rust/commit/b0ee1f7f99c1190d51ecdb592e23b868f488a346"}], "stats": {"total": 206, "additions": 92, "deletions": 114}, "files": [{"sha": "bcd90aeceb647fb346613ed996dbeb4c27dfde57", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 84, "deletions": 36, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=0e166bb217463a26028ad9b1724e686d54ba1415", "patch": "@@ -11,8 +11,9 @@ use rustc_codegen_ssa::traits::*;\n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n use crate::abi::{LlvmType, FnTypeExt};\n+use syntax::ast;\n use rustc::ty::Ty;\n-use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc_target::abi::call::{CastTarget, FnType, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::common::TypeKind;\n@@ -50,21 +51,99 @@ impl CodegenCx<'ll, 'tcx> {\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n-}\n \n-impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn type_void(&self) -> &'ll Type {\n+    crate fn type_void(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVoidTypeInContext(self.llcx)\n         }\n     }\n \n-    fn type_metadata(&self) -> &'ll Type {\n+    crate fn type_metadata(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustMetadataTypeInContext(self.llcx)\n         }\n     }\n \n+    ///x Creates an integer type with the given number of bits, e.g., i24\n+    crate fn type_ix(&self, num_bits: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n+        }\n+    }\n+\n+    crate fn type_x86_mmx(&self) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMX86MMXTypeInContext(self.llcx)\n+        }\n+    }\n+\n+    crate fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMVectorType(ty, len as c_uint)\n+        }\n+    }\n+\n+    crate fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n+        unsafe {\n+            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n+            let mut args = Vec::with_capacity(n_args);\n+            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n+            args.set_len(n_args);\n+            args\n+        }\n+    }\n+\n+    crate fn type_bool(&self) -> &'ll Type {\n+        self.type_i8()\n+    }\n+\n+    crate fn type_int_from_ty(&self, t: ast::IntTy) -> &'ll Type {\n+        match t {\n+            ast::IntTy::Isize => self.type_isize(),\n+            ast::IntTy::I8 => self.type_i8(),\n+            ast::IntTy::I16 => self.type_i16(),\n+            ast::IntTy::I32 => self.type_i32(),\n+            ast::IntTy::I64 => self.type_i64(),\n+            ast::IntTy::I128 => self.type_i128(),\n+        }\n+    }\n+\n+    crate fn type_uint_from_ty(&self, t: ast::UintTy) -> &'ll Type {\n+        match t {\n+            ast::UintTy::Usize => self.type_isize(),\n+            ast::UintTy::U8 => self.type_i8(),\n+            ast::UintTy::U16 => self.type_i16(),\n+            ast::UintTy::U32 => self.type_i32(),\n+            ast::UintTy::U64 => self.type_i64(),\n+            ast::UintTy::U128 => self.type_i128(),\n+        }\n+    }\n+\n+    crate fn type_float_from_ty(&self, t: ast::FloatTy) -> &'ll Type {\n+        match t {\n+            ast::FloatTy::F32 => self.type_f32(),\n+            ast::FloatTy::F64 => self.type_f64(),\n+        }\n+    }\n+\n+    crate fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n+        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n+        let ity = layout::Integer::approximate_align(self, align);\n+        self.type_from_integer(ity)\n+    }\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// and exactly the required size, as a best-effort padding array.\n+    crate fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+        let unit = layout::Integer::approximate_align(self, align);\n+        let size = size.bytes();\n+        let unit_size = unit.size().bytes();\n+        assert_eq!(size % unit_size, 0);\n+        self.type_array(self.type_from_integer(unit), size / unit_size)\n+    }\n+}\n+\n+impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn type_i1(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt1TypeInContext(self.llcx)\n@@ -102,12 +181,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_ix(&self, num_bits: u64) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n-        }\n-    }\n-\n     fn type_isize(&self) -> &'ll Type {\n         self.isize_ty\n     }\n@@ -124,12 +197,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_x86_mmx(&self) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMX86MMXTypeInContext(self.llcx)\n-        }\n-    }\n-\n     fn type_func(\n         &self,\n         args: &[&'ll Type],\n@@ -171,12 +238,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMVectorType(ty, len as c_uint)\n-        }\n-    }\n-\n     fn type_kind(&self, ty: &'ll Type) -> TypeKind {\n         unsafe {\n             llvm::LLVMRustGetTypeKind(ty).to_generic()\n@@ -201,16 +262,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n-        unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n-            let mut args = Vec::with_capacity(n_args);\n-            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n-            args.set_len(n_args);\n-            args\n-        }\n-    }\n-\n     fn float_width(&self, ty: &'ll Type) -> usize {\n         match self.type_kind(ty) {\n             TypeKind::Float => 32,\n@@ -288,9 +339,6 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n-    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n-        ty.llvm_type(self)\n-    }\n     fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n         ty.ptr_to_llvm_type(self)\n     }"}, {"sha": "0e1885fe29ba6f8efbfe06b6c299d99c028ea6d8", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=0e166bb217463a26028ad9b1724e686d54ba1415", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types, non_snake_case)]\n \n-use rustc::ty::{self, Ty, TyCtxt};\n-use syntax_pos::{DUMMY_SP, Span};\n+use rustc::ty::{Ty, TyCtxt};\n+use syntax_pos::Span;\n \n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n@@ -11,18 +11,6 @@ use crate::traits::*;\n use rustc::hir;\n use crate::traits::BuilderMethods;\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all())\n-}\n-\n-pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n-}\n-\n pub enum IntPredicate {\n     IntEQ,\n     IntNE,"}, {"sha": "8d7f225d9950b143ebb2d830fbcfaffc5532b56f", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 6, "deletions": 64, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e166bb217463a26028ad9b1724e686d54ba1415/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=0e166bb217463a26028ad9b1724e686d54ba1415", "patch": "@@ -1,46 +1,38 @@\n use super::misc::MiscMethods;\n use super::Backend;\n use super::HasCodegen;\n-use crate::common::{self, TypeKind};\n+use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n-use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, TyLayout};\n use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n-use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n // `LayoutOf` or `HasTyCtxt`. This way, they don't have to add a constraint on it themselves.\n pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n-    fn type_void(&self) -> Self::Type;\n-    fn type_metadata(&self) -> Self::Type;\n     fn type_i1(&self) -> Self::Type;\n     fn type_i8(&self) -> Self::Type;\n     fn type_i16(&self) -> Self::Type;\n     fn type_i32(&self) -> Self::Type;\n     fn type_i64(&self) -> Self::Type;\n     fn type_i128(&self) -> Self::Type;\n-\n-    // Creates an integer type with the given number of bits, e.g., i24\n-    fn type_ix(&self, num_bits: u64) -> Self::Type;\n     fn type_isize(&self) -> Self::Type;\n \n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n-    fn type_x86_mmx(&self) -> Self::Type;\n \n     fn type_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn type_variadic_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn type_array(&self, ty: Self::Type, len: u64) -> Self::Type;\n-    fn type_vector(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n \n     /// Returns the number of elements in `self` if it is a LLVM vector type.\n     fn vector_length(&self, ty: Self::Type) -> usize;\n \n-    fn func_params_types(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n \n     /// Retrieves the bit width of the integer type `self`.\n@@ -50,10 +42,6 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n }\n \n pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n-    fn type_bool(&self) -> Self::Type {\n-        self.type_i8()\n-    }\n-\n     fn type_i8p(&self) -> Self::Type {\n         self.type_ptr_to(self.type_i8())\n     }\n@@ -67,35 +55,6 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_int_from_ty(&self, t: ast::IntTy) -> Self::Type {\n-        match t {\n-            ast::IntTy::Isize => self.type_isize(),\n-            ast::IntTy::I8 => self.type_i8(),\n-            ast::IntTy::I16 => self.type_i16(),\n-            ast::IntTy::I32 => self.type_i32(),\n-            ast::IntTy::I64 => self.type_i64(),\n-            ast::IntTy::I128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_uint_from_ty(&self, t: ast::UintTy) -> Self::Type {\n-        match t {\n-            ast::UintTy::Usize => self.type_isize(),\n-            ast::UintTy::U8 => self.type_i8(),\n-            ast::UintTy::U16 => self.type_i16(),\n-            ast::UintTy::U32 => self.type_i32(),\n-            ast::UintTy::U64 => self.type_i64(),\n-            ast::UintTy::U128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_float_from_ty(&self, t: ast::FloatTy) -> Self::Type {\n-        match t {\n-            ast::FloatTy::F32 => self.type_f32(),\n-            ast::FloatTy::F64 => self.type_f64(),\n-        }\n-    }\n-\n     fn type_from_integer(&self, i: layout::Integer) -> Self::Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n@@ -107,32 +66,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n     }\n \n-    fn type_pointee_for_align(&self, align: Align) -> Self::Type {\n-        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_align(self, align);\n-        self.type_from_integer(ity)\n-    }\n-\n-    /// Return a LLVM type that has at most the required alignment,\n-    /// and exactly the required size, as a best-effort padding array.\n-    fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type {\n-        let unit = layout::Integer::approximate_align(self, align);\n-        let size = size.bytes();\n-        let unit_size = unit.size().bytes();\n-        assert_eq!(size % unit_size, 0);\n-        self.type_array(self.type_from_integer(unit), size / unit_size)\n-    }\n-\n     fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_needs_drop(self.tcx(), ty)\n+        ty.needs_drop(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_sized(self.tcx(), ty)\n+        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_freeze(self.tcx(), ty)\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all(), DUMMY_SP)\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n@@ -155,7 +98,6 @@ impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscM\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n-    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n     fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;"}]}