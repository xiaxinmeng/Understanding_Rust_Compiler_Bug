{"sha": "8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "node_id": "C_kwDOAAsO6NoAKDhmZTViNTZiNjZlYmQxYTEyNTI3NWI2MjE5MzAxY2Y3OTdmYzVmZjk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-03-31T20:32:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-31T20:32:48Z"}, "message": "Rollup merge of #109104 - GuillaumeGomez:fix-invalid-suggestion-ambiguous-intra-doc2, r=oli-obk,notriddle\n\nrustdoc: Fix invalid suggestions on ambiguous intra doc links v2\n\nFixes https://github.com/rust-lang/rust/issues/108653.\n\nThis is another approach to fixing the same issue. This time, we keep the computed information around instead of re-computing it.\n\nStrangely enough, the order for ambiguities seem to have been changed. Not an issue but it creates a lot of diff...\n\nSo which version do you prefer?\n\nr? `@notriddle`", "tree": {"sha": "e0a11c2952fb8b2ed780e14a851b80165e30325e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a11c2952fb8b2ed780e14a851b80165e30325e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkJ0NwCRBK7hj4Ov3rIwAAXrgIAAzR5NWh7hRtKwuTt8Bg4Pvi\nqZrEUi6wSPm51tw8ERs+t9WMU2ufbivoZLzZh7x5t2gH9kZL3lezQ8DKKbSF9BIU\no09+EEKhUaEEzR75Tz6i5Om4IokkPLWbtaxwconOXxPTHuhiCI+cVRlnh7pMs7gB\nm+Z++JZN0dRB9Ya0sME5V4C5wweUBf2kQ304+F/9bDBCjxh7RTgECKi2B0O0DwLZ\nr+Yg3hlMPaVzAxth9CnzYrQKO3kRodm6IG/4hLlcSgkgzbTQmQeDecX9qm/2iZGl\nGDjmmy7tpWKiP92QclaHW6twxzS2zujyaWnPydama2YSFTm0Ru6j41AlFSW6slE=\n=WzgT\n-----END PGP SIGNATURE-----\n", "payload": "tree e0a11c2952fb8b2ed780e14a851b80165e30325e\nparent 480068c2359ea65df4481788b5ce717a548ce171\nparent 415a3ca909084e83441306b21db5232ee8952fc4\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1680294768 +0200\ncommitter GitHub <noreply@github.com> 1680294768 +0200\n\nRollup merge of #109104 - GuillaumeGomez:fix-invalid-suggestion-ambiguous-intra-doc2, r=oli-obk,notriddle\n\nrustdoc: Fix invalid suggestions on ambiguous intra doc links v2\n\nFixes https://github.com/rust-lang/rust/issues/108653.\n\nThis is another approach to fixing the same issue. This time, we keep the computed information around instead of re-computing it.\n\nStrangely enough, the order for ambiguities seem to have been changed. Not an issue but it creates a lot of diff...\n\nSo which version do you prefer?\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "html_url": "https://github.com/rust-lang/rust/commit/8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "480068c2359ea65df4481788b5ce717a548ce171", "url": "https://api.github.com/repos/rust-lang/rust/commits/480068c2359ea65df4481788b5ce717a548ce171", "html_url": "https://github.com/rust-lang/rust/commit/480068c2359ea65df4481788b5ce717a548ce171"}, {"sha": "415a3ca909084e83441306b21db5232ee8952fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/415a3ca909084e83441306b21db5232ee8952fc4", "html_url": "https://github.com/rust-lang/rust/commit/415a3ca909084e83441306b21db5232ee8952fc4"}], "stats": {"total": 891, "additions": 702, "deletions": 189}, "files": [{"sha": "64397574df6090932d6eebaf522afc401056294c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 242, "deletions": 142, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -47,7 +47,18 @@ fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     krate\n }\n \n-#[derive(Copy, Clone, Debug, Hash)]\n+fn filter_assoc_items_by_name_and_namespace<'a>(\n+    tcx: TyCtxt<'a>,\n+    assoc_items_of: DefId,\n+    ident: Ident,\n+    ns: Namespace,\n+) -> impl Iterator<Item = &ty::AssocItem> + 'a {\n+    tcx.associated_items(assoc_items_of).filter_by_name_unhygienic(ident.name).filter(move |item| {\n+        item.kind.namespace() == ns && tcx.hygienic_eq(ident, item.ident(tcx), assoc_items_of)\n+    })\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq)]\n enum Res {\n     Def(DefKind, DefId),\n     Primitive(PrimitiveType),\n@@ -59,7 +70,7 @@ impl Res {\n     fn descr(self) -> &'static str {\n         match self {\n             Res::Def(kind, id) => ResolveRes::Def(kind, id).descr(),\n-            Res::Primitive(_) => \"builtin type\",\n+            Res::Primitive(_) => \"primitive type\",\n         }\n     }\n \n@@ -317,14 +328,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty.impls(tcx).find_map(|impl_| {\n-            tcx.associated_items(impl_)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+        prim_ty\n+            .impls(tcx)\n+            .flat_map(|impl_| {\n+                filter_assoc_items_by_name_and_namespace(\n+                    tcx,\n+                    impl_,\n+                    Ident::with_dummy_span(item_name),\n+                    ns,\n+                )\n                 .map(|item| (Res::Primitive(prim_ty), item.def_id))\n-        })\n+            })\n+            .collect::<Vec<_>>()\n     }\n \n     fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: DefId) -> Option<Res> {\n@@ -394,14 +412,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         item_id: DefId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n+    ) -> Result<Vec<(Res, Option<DefId>)>, UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             return Ok(match res {\n                 Res::Def(\n                     DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Variant,\n                     def_id,\n-                ) => (Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id)),\n-                _ => (res, None),\n+                ) => {\n+                    vec![(Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id))]\n+                }\n+                _ => vec![(res, None)],\n             });\n         } else if ns == MacroNS {\n             return Err(UnresolvedPath {\n@@ -436,14 +456,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n         // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n         // primitives.\n-        resolve_primitive(&path_root, TypeNS)\n+        match resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n-                self.resolve_associated_item(ty_res, item_name, ns, module_id).map(Ok)\n-            })\n-            .unwrap_or_else(|| {\n+                let candidates = self\n+                    .resolve_associated_item(ty_res, item_name, ns, module_id)\n+                    .into_iter()\n+                    .map(|(res, def_id)| (res, Some(def_id)))\n+                    .collect::<Vec<_>>();\n+                if !candidates.is_empty() { Some(candidates) } else { None }\n+            }) {\n+            Some(r) => Ok(r),\n+            None => {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, item_id, module_id)\n+                        .map(|(res, def_id)| vec![(res, Some(def_id))])\n                 } else {\n                     Err(UnresolvedPath {\n                         item_id,\n@@ -452,8 +479,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         unresolved: path_root.into(),\n                     })\n                 }\n-            })\n-            .map(|(res, def_id)| (res, Some(def_id)))\n+            }\n+        }\n     }\n \n     /// Convert a DefId to a Res, where possible.\n@@ -535,24 +562,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n             Res::Primitive(prim) => {\n-                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                let items = self.resolve_primitive_associated_item(prim, ns, item_name);\n+                if !items.is_empty() {\n+                    items\n+                // Inherent associated items take precedence over items that come from trait impls.\n+                } else {\n                     self.primitive_type_to_ty(prim)\n-                        .and_then(|ty| {\n+                        .map(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                                .iter()\n+                                .map(|item| (root_res, item.def_id))\n+                                .collect::<Vec<_>>()\n                         })\n-                        .map(|item| (root_res, item.def_id))\n-                })\n+                        .unwrap_or(Vec::new())\n+                }\n             }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n                 // it will show up on its documentation page, we should link there instead.\n-                let res = self.def_id_to_res(did)?;\n+                let Some(res) = self.def_id_to_res(did) else { return Vec::new() };\n                 self.resolve_associated_item(res, item_name, ns, module_id)\n             }\n             Res::Def(\n@@ -566,7 +600,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n-                                    return Some((root_res, variant.def_id));\n+                                    return vec![(root_res, variant.def_id)];\n                                 }\n                             }\n                         }\n@@ -575,43 +609,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n \n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = tcx\n+                let mut assoc_items: Vec<_> = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                        filter_assoc_items_by_name_and_namespace(\n                             tcx,\n+                            imp,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n-                            imp,\n                         )\n                     })\n-                    .copied()\n-                    // There should only ever be one associated item that matches from any inherent impl\n-                    .next()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect();\n+\n+                if assoc_items.is_empty() {\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n                     // FIXME(#74563): This gives precedence to `impl SomeItem`:\n                     // Although having both would be ambiguous, use impl version for compatibility's sake.\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                    .or_else(|| {\n-                        resolve_associated_trait_item(\n-                            tcx.type_of(did).subst_identity(),\n-                            module_id,\n-                            item_name,\n-                            ns,\n-                            self.cx,\n-                        )\n-                    });\n+                    assoc_items = resolve_associated_trait_item(\n+                        tcx.type_of(did).subst_identity(),\n+                        module_id,\n+                        item_name,\n+                        ns,\n+                        self.cx,\n+                    )\n+                    .into_iter()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect::<Vec<_>>();\n+                }\n \n-                debug!(\"got associated item {:?}\", assoc_item);\n+                debug!(\"got associated item {:?}\", assoc_items);\n \n-                if let Some(item) = assoc_item {\n-                    return Some((root_res, item.def_id));\n+                if !assoc_items.is_empty() {\n+                    return assoc_items;\n                 }\n \n                 if ns != Namespace::ValueNS {\n-                    return None;\n+                    return Vec::new();\n                 }\n                 debug!(\"looking for fields named {} for {:?}\", item_name, did);\n                 // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n@@ -631,20 +668,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // field syntax) and are handled by the compiler's resolver.\n                 let def = match tcx.type_of(did).subst_identity().kind() {\n                     ty::Adt(def, _) if !def.is_enum() => def,\n-                    _ => return None,\n+                    _ => return Vec::new(),\n                 };\n-                let field =\n-                    def.non_enum_variant().fields.iter().find(|item| item.name == item_name)?;\n-                Some((root_res, field.did))\n+                def.non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .filter(|field| field.name == item_name)\n+                    .map(|field| (root_res, field.did))\n+                    .collect::<Vec<_>>()\n             }\n-            Res::Def(DefKind::Trait, did) => tcx\n-                .associated_items(did)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n-                .map(|item| {\n-                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, item.def_id)\n-                }),\n-            _ => None,\n+            Res::Def(DefKind::Trait, did) => filter_assoc_items_by_name_and_namespace(\n+                tcx,\n+                did,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(|item| {\n+                let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                (res, item.def_id)\n+            })\n+            .collect::<Vec<_>>(),\n+            _ => Vec::new(),\n         }\n     }\n }\n@@ -664,27 +708,34 @@ fn resolve_associated_trait_item<'a>(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &mut DocContext<'a>,\n-) -> Option<ty::AssocItem> {\n+) -> Vec<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n     let traits = trait_impls_for(cx, ty, module);\n+    let tcx = cx.tcx;\n     debug!(\"considering traits {:?}\", traits);\n-    let mut candidates = traits.iter().filter_map(|&(impl_, trait_)| {\n-        cx.tcx\n-            .associated_items(trait_)\n-            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-            .map(|trait_assoc| {\n-                trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n+    let candidates = traits\n+        .iter()\n+        .flat_map(|&(impl_, trait_)| {\n+            filter_assoc_items_by_name_and_namespace(\n+                cx.tcx,\n+                trait_,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(move |trait_assoc| {\n+                trait_assoc_to_impl_assoc_item(tcx, impl_, trait_assoc.def_id)\n                     .unwrap_or(*trait_assoc)\n             })\n-    });\n+        })\n+        .collect::<Vec<_>>();\n     // FIXME(#74563): warn about ambiguity\n-    debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next()\n+    debug!(\"the candidates were {:?}\", candidates);\n+    candidates\n }\n \n /// Find the associated item in the impl `impl_id` that corresponds to the\n@@ -758,15 +809,15 @@ fn trait_impls_for<'a>(\n /// Check for resolve collisions between a trait and its derive.\n ///\n /// These are common and we should just resolve to the trait in that case.\n-fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    matches!(\n-        *ns,\n-        PerNS {\n-            type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n-            macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n-            ..\n-        }\n-    )\n+fn is_derive_trait_collision<T>(ns: &PerNS<Result<Vec<(Res, T)>, ResolutionFailure<'_>>>) -> bool {\n+    if let (&Ok(ref type_ns), &Ok(ref macro_ns)) = (&ns.type_ns, &ns.macro_ns) {\n+        type_ns.iter().any(|(res, _)| matches!(res, Res::Def(DefKind::Trait, _)))\n+            && macro_ns\n+                .iter()\n+                .any(|(res, _)| matches!(res, Res::Def(DefKind::Macro(MacroKind::Derive), _)))\n+    } else {\n+        false\n+    }\n }\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n@@ -987,15 +1038,15 @@ impl LinkCollector<'_, '_> {\n                     res = prim;\n                 } else {\n                     // `[char]` when a `char` module is in scope\n-                    let candidates = vec![res, prim];\n-                    ambiguity_error(self.cx, diag_info, path_str, candidates);\n+                    let candidates = &[(res, res.def_id(self.cx.tcx)), (prim, None)];\n+                    ambiguity_error(self.cx, &diag_info, path_str, candidates);\n                     return None;\n                 }\n             }\n         }\n \n         match res {\n-            Res::Primitive(prim) => {\n+            Res::Primitive(_) => {\n                 if let Some(UrlFragment::Item(id)) = fragment {\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n@@ -1015,15 +1066,6 @@ impl LinkCollector<'_, '_> {\n                         item,\n                         &diag_info,\n                     )?;\n-\n-                    // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n-                    // However I'm not sure how to check that across crates.\n-                    if prim == PrimitiveType::RawPointer\n-                        && item.item_id.is_local()\n-                        && !self.cx.tcx.features().intra_doc_pointers\n-                    {\n-                        self.report_rawptr_assoc_feature_gate(dox, ori_link, item);\n-                    }\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n@@ -1144,10 +1186,9 @@ impl LinkCollector<'_, '_> {\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n-        let span =\n-            super::source_span_for_markdown_range(self.cx.tcx, dox, &ori_link.range, &item.attrs)\n-                .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n+        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n+            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1172,7 +1213,31 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n+        let mut candidates = self.resolve_with_disambiguator(&key, diag.clone());\n+\n+        // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n+        // However I'm not sure how to check that across crates.\n+        if let Some(candidate) = candidates.get(0) &&\n+            candidate.0 == Res::Primitive(PrimitiveType::RawPointer) &&\n+            key.path_str.contains(\"::\") // We only want to check this if this is an associated item.\n+        {\n+            if key.item_id.is_local() && !self.cx.tcx.features().intra_doc_pointers {\n+                self.report_rawptr_assoc_feature_gate(diag.dox, &diag.link_range, diag.item);\n+                return None;\n+            } else {\n+                candidates = vec![candidates[0]];\n+            }\n+        }\n+\n+        // If there are multiple items with the same \"kind\" (for example, both \"associated types\")\n+        // and after removing duplicated kinds, only one remains, the `ambiguity_error` function\n+        // won't emit an error. So at this point, we can just take the first candidate as it was\n+        // the first retrieved and use it to generate the link.\n+        if candidates.len() > 1 && !ambiguity_error(self.cx, &diag, &key.path_str, &candidates) {\n+            candidates = vec![candidates[0]];\n+        }\n+\n+        if let &[(res, def_id)] = candidates.as_slice() {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n                     report_anchor_conflict(self.cx, diag, def_id);\n@@ -1182,13 +1247,15 @@ impl LinkCollector<'_, '_> {\n                 (None, Some(def_id)) => Some(UrlFragment::Item(def_id)),\n                 (None, None) => None,\n             };\n-            Some((res, fragment))\n-        });\n+            let r = Some((res, fragment));\n+            self.visited_links.insert(key, r.clone());\n+            return r;\n+        }\n \n-        if res.is_some() || cache_errors {\n-            self.visited_links.insert(key, res.clone());\n+        if cache_errors {\n+            self.visited_links.insert(key, None);\n         }\n-        res\n+        None\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1197,7 +1264,7 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<DefId>)> {\n+    ) -> Vec<(Res, Option<DefId>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n@@ -1206,7 +1273,7 @@ impl LinkCollector<'_, '_> {\n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n                 match self.resolve(path_str, expected_ns, item_id, module_id) {\n-                    Ok(res) => Some(res),\n+                    Ok(candidates) => candidates,\n                     Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n@@ -1215,10 +1282,11 @@ impl LinkCollector<'_, '_> {\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n                                 if let Ok(res) =\n-                                    self.resolve(path_str, other_ns, item_id, module_id)\n+                                    self.resolve(path_str, other_ns, item_id, module_id) &&\n+                                    !res.is_empty()\n                                 {\n                                     err = ResolutionFailure::WrongNamespace {\n-                                        res: full_res(self.cx.tcx, res),\n+                                        res: full_res(self.cx.tcx, res[0]),\n                                         expected_ns,\n                                     };\n                                     break;\n@@ -1239,18 +1307,26 @@ impl LinkCollector<'_, '_> {\n                 let candidates = PerNS {\n                     macro_ns: candidate(MacroNS),\n                     type_ns: candidate(TypeNS),\n-                    value_ns: candidate(ValueNS).and_then(|(res, def_id)| {\n-                        match res {\n-                            // Constructors are picked up in the type namespace.\n-                            Res::Def(DefKind::Ctor(..), _) => {\n-                                Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n+                    value_ns: candidate(ValueNS).and_then(|v_res| {\n+                        for (res, _) in v_res.iter() {\n+                            match res {\n+                                // Constructors are picked up in the type namespace.\n+                                Res::Def(DefKind::Ctor(..), _) => {\n+                                    return Err(ResolutionFailure::WrongNamespace {\n+                                        res: *res,\n+                                        expected_ns: TypeNS,\n+                                    });\n+                                }\n+                                _ => {}\n                             }\n-                            _ => Ok((res, def_id)),\n                         }\n+                        Ok(v_res)\n                     }),\n                 };\n \n-                let len = candidates.iter().filter(|res| res.is_ok()).count();\n+                let len = candidates\n+                    .iter()\n+                    .fold(0, |acc, res| if let Ok(res) = res { acc + res.len() } else { acc });\n \n                 if len == 0 {\n                     return resolution_failure(\n@@ -1260,22 +1336,21 @@ impl LinkCollector<'_, '_> {\n                         disambiguator,\n                         candidates.into_iter().filter_map(|res| res.err()).collect(),\n                     );\n-                }\n-\n-                if len == 1 {\n-                    Some(candidates.into_iter().find_map(|res| res.ok()).unwrap())\n-                } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                    Some(candidates.type_ns.unwrap())\n+                } else if len == 1 {\n+                    candidates.into_iter().filter_map(|res| res.ok()).flatten().collect::<Vec<_>>()\n                 } else {\n-                    let ignore_macro = is_derive_trait_collision(&candidates);\n-                    // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                    let mut candidates =\n-                        candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                    if ignore_macro {\n-                        candidates.macro_ns = None;\n+                    let has_derive_trait_collision = is_derive_trait_collision(&candidates);\n+                    if len == 2 && has_derive_trait_collision {\n+                        candidates.type_ns.unwrap()\n+                    } else {\n+                        // If we're reporting an ambiguity, don't mention the namespaces that failed\n+                        let mut candidates = candidates.map(|candidate| candidate.ok());\n+                        // If there a collision between a trait and a derive, we ignore the derive.\n+                        if has_derive_trait_collision {\n+                            candidates.macro_ns = None;\n+                        }\n+                        candidates.into_iter().filter_map(|res| res).flatten().collect::<Vec<_>>()\n                     }\n-                    ambiguity_error(self.cx, diag, path_str, candidates.present_items().collect());\n-                    None\n                 }\n             }\n         }\n@@ -1563,7 +1638,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n-) -> Option<(Res, Option<DefId>)> {\n+) -> Vec<(Res, Option<DefId>)> {\n     let tcx = collector.cx.tcx;\n     let mut recovered_res = None;\n     report_diagnostic(\n@@ -1622,11 +1697,13 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Ok(res) = collector.resolve(start, ns, item_id, module_id) {\n-                                debug!(\"found partial_res={:?}\", res);\n-                                *partial_res = Some(full_res(collector.cx.tcx, res));\n-                                *unresolved = end.into();\n-                                break 'outer;\n+                            if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n+                                debug!(\"found partial_res={:?}\", v_res);\n+                                if !v_res.is_empty() {\n+                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *unresolved = end.into();\n+                                    break 'outer;\n+                                }\n                             }\n                         }\n                         *unresolved = end.into();\n@@ -1774,7 +1851,10 @@ fn resolution_failure(\n         },\n     );\n \n-    recovered_res\n+    match recovered_res {\n+        Some(r) => vec![r],\n+        None => Vec::new(),\n+    }\n }\n \n fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n@@ -1859,28 +1939,47 @@ fn report_malformed_generics(\n }\n \n /// Report an ambiguity error, where there were multiple possible resolutions.\n+///\n+/// If all `candidates` have the same kind, it's not possible to disambiguate so in this case,\n+/// the function won't emit an error and will return `false`. Otherwise, it'll emit the error and\n+/// return `true`.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n-    diag_info: DiagnosticInfo<'_>,\n+    diag_info: &DiagnosticInfo<'_>,\n     path_str: &str,\n-    candidates: Vec<Res>,\n-) {\n-    let mut msg = format!(\"`{}` is \", path_str);\n+    candidates: &[(Res, Option<DefId>)],\n+) -> bool {\n+    let mut descrs = FxHashSet::default();\n+    let kinds = candidates\n+        .iter()\n+        .map(\n+            |(res, def_id)| {\n+                if let Some(def_id) = def_id { Res::from_def_id(cx.tcx, *def_id) } else { *res }\n+            },\n+        )\n+        .filter(|res| descrs.insert(res.descr()))\n+        .collect::<Vec<_>>();\n+    if descrs.len() == 1 {\n+        // There is no way for users to disambiguate at this point, so better return the first\n+        // candidate and not show a warning.\n+        return false;\n+    }\n \n-    match candidates.as_slice() {\n-        [first_def, second_def] => {\n+    let mut msg = format!(\"`{}` is \", path_str);\n+    match kinds.as_slice() {\n+        [res1, res2] => {\n             msg += &format!(\n                 \"both {} {} and {} {}\",\n-                first_def.article(),\n-                first_def.descr(),\n-                second_def.article(),\n-                second_def.descr(),\n+                res1.article(),\n+                res1.descr(),\n+                res2.article(),\n+                res2.descr()\n             );\n         }\n         _ => {\n-            let mut candidates = candidates.iter().peekable();\n-            while let Some(res) = candidates.next() {\n-                if candidates.peek().is_some() {\n+            let mut kinds = kinds.iter().peekable();\n+            while let Some(res) = kinds.next() {\n+                if kinds.peek().is_some() {\n                     msg += &format!(\"{} {}, \", res.article(), res.descr());\n                 } else {\n                     msg += &format!(\"and {} {}\", res.article(), res.descr());\n@@ -1889,17 +1988,18 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n             diag.note(\"ambiguous link\");\n         }\n \n-        for res in candidates {\n+        for res in kinds {\n             suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n         }\n     });\n+    true\n }\n \n /// In case of an ambiguity or mismatched disambiguator, suggest the correct"}, {"sha": "0290b8582042c0628ce3b2d545b18e405439e374", "filename": "tests/rustdoc-ui/intra-doc/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -35,6 +35,6 @@ pub mod foo {\n /// Ambiguous non-implied shortcut link [`foo::bar`]. //~ERROR `foo::bar`\n pub struct Docs {}\n \n-/// [true] //~ ERROR `true` is both a module and a builtin type\n+/// [true] //~ ERROR `true` is both a module and a primitive type\n /// [primitive@true]\n pub mod r#true {}"}, {"sha": "47853e0b5899d10c3ae3792adac6af311a3b8d33", "filename": "tests/rustdoc-ui/intra-doc/ambiguity.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -1,4 +1,4 @@\n-error: `true` is both a module and a builtin type\n+error: `true` is both a module and a primitive type\n   --> $DIR/ambiguity.rs:38:6\n    |\n LL | /// [true]\n@@ -13,89 +13,89 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@true]\n    |      ++++\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@true]\n    |      +++++\n \n-error: `ambiguous` is both a struct and a function\n+error: `ambiguous` is both a function and a struct\n   --> $DIR/ambiguity.rs:27:7\n    |\n LL | /// [`ambiguous`] is ambiguous.\n    |       ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [`struct@ambiguous`] is ambiguous.\n-   |       +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [`ambiguous()`] is ambiguous.\n    |                ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [`struct@ambiguous`] is ambiguous.\n+   |       +++++++\n \n-error: `ambiguous` is both a struct and a function\n+error: `ambiguous` is both a function and a struct\n   --> $DIR/ambiguity.rs:29:6\n    |\n LL | /// [ambiguous] is ambiguous.\n    |      ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [struct@ambiguous] is ambiguous.\n-   |      +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [ambiguous()] is ambiguous.\n    |               ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [struct@ambiguous] is ambiguous.\n+   |      +++++++\n \n-error: `multi_conflict` is a struct, a function, and a macro\n+error: `multi_conflict` is a function, a struct, and a macro\n   --> $DIR/ambiguity.rs:31:7\n    |\n LL | /// [`multi_conflict`] is a three-way conflict.\n    |       ^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [`struct@multi_conflict`] is a three-way conflict.\n-   |       +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [`multi_conflict()`] is a three-way conflict.\n    |                     ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [`struct@multi_conflict`] is a three-way conflict.\n+   |       +++++++\n help: to link to the macro, add an exclamation mark\n    |\n LL | /// [`multi_conflict!`] is a three-way conflict.\n    |                     +\n \n-error: `type_and_value` is both a module and a constant\n+error: `type_and_value` is both a constant and a module\n   --> $DIR/ambiguity.rs:33:16\n    |\n LL | /// Ambiguous [type_and_value].\n    |                ^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the module, prefix with `mod@`\n-   |\n-LL | /// Ambiguous [mod@type_and_value].\n-   |                ++++\n help: to link to the constant, prefix with `const@`\n    |\n LL | /// Ambiguous [const@type_and_value].\n    |                ++++++\n+help: to link to the module, prefix with `mod@`\n+   |\n+LL | /// Ambiguous [mod@type_and_value].\n+   |                ++++\n \n-error: `foo::bar` is both an enum and a function\n+error: `foo::bar` is both a function and an enum\n   --> $DIR/ambiguity.rs:35:43\n    |\n LL | /// Ambiguous non-implied shortcut link [`foo::bar`].\n    |                                           ^^^^^^^^ ambiguous link\n    |\n-help: to link to the enum, prefix with `enum@`\n-   |\n-LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n-   |                                           +++++\n help: to link to the function, add parentheses\n    |\n LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n    |                                                   ++\n+help: to link to the enum, prefix with `enum@`\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n+   |                                           +++++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "f37f49c24ccc5c70619ef06eaf41fbe355520a0e", "filename": "tests/rustdoc-ui/intra-doc/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -54,11 +54,11 @@\n \n /// [u8::not_found]\n //~^ ERROR unresolved link\n-//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+//~| NOTE the primitive type `u8` has no associated item named `not_found`\n \n /// [std::primitive::u8::not_found]\n //~^ ERROR unresolved link\n-//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+//~| NOTE the primitive type `u8` has no associated item named `not_found`\n \n /// [type@Vec::into_iter]\n //~^ ERROR unresolved link"}, {"sha": "a982bba0095915134c46ea5b2601e09adc28cf42", "filename": "tests/rustdoc-ui/intra-doc/errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -80,13 +80,13 @@ error: unresolved link to `u8::not_found`\n   --> $DIR/errors.rs:55:6\n    |\n LL | /// [u8::not_found]\n-   |      ^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+   |      ^^^^^^^^^^^^^ the primitive type `u8` has no associated item named `not_found`\n \n error: unresolved link to `std::primitive::u8::not_found`\n   --> $DIR/errors.rs:59:6\n    |\n LL | /// [std::primitive::u8::not_found]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the primitive type `u8` has no associated item named `not_found`\n \n error: unresolved link to `Vec::into_iter`\n   --> $DIR/errors.rs:63:6"}, {"sha": "464c5f0d5439c4ee60f51f309021aedf9165a2c7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-10.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+// This test ensures that this warning doesn't show up:\n+// warning: `PartialEq` is both a trait and a derive macro\n+//  --> tests/rustdoc-ui/intra-doc/issue-108653-associated-items-10.rs:1:7\n+//   |\n+// 1 | //! [`PartialEq`]\n+//   |       ^^^^^^^^^ ambiguous link\n+//   |\n+//   = note: `#[warn(rustdoc::broken_intra_doc_links)]` on by default\n+// help: to link to the trait, prefix with `trait@`\n+//   |\n+// 1 | //! [`trait@PartialEq`]\n+//   |       ++++++\n+// help: to link to the derive macro, prefix with `derive@`\n+//   |\n+// 1 | //! [`derive@PartialEq`]\n+//   |       +++++++\n+\n+// check-pass\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+//! [`PartialEq`]"}, {"sha": "cbe60f746b682a42febea1f0ea41e22bb1673250", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,17 @@\n+// This is ensuring that the UI output for associated items is as expected.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+/// [`Trait::IDENT`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait Trait {\n+    type IDENT;\n+    const IDENT: usize;\n+}\n+\n+/// [`Trait2::IDENT`]\n+//~^ ERROR both an associated function and an associated type\n+pub trait Trait2 {\n+    type IDENT;\n+    fn IDENT() {}\n+}"}, {"sha": "952392548da8a34a6de94a6696b92d1045a50da6", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-2.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,37 @@\n+error: `Trait::IDENT` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-2.rs:5:7\n+   |\n+LL | /// [`Trait::IDENT`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-2.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait::IDENT`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait::IDENT`]\n+   |       +++++\n+\n+error: `Trait2::IDENT` is both an associated function and an associated type\n+  --> $DIR/issue-108653-associated-items-2.rs:12:7\n+   |\n+LL | /// [`Trait2::IDENT`]\n+   |       ^^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Trait2::IDENT()`]\n+   |                    ++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait2::IDENT`]\n+   |       +++++\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7ffd0a40e7cfe15d5d452b97822cacf8fd4f0a65", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,16 @@\n+// This is ensuring that the UI output for associated items works when it's being documented\n+// from another item.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type Trait;\n+    const Trait: usize;\n+}\n+\n+/// [`Trait`]\n+//~^ ERROR both a constant and a trait\n+/// [`Trait::Trait`]\n+//~^ ERROR both an associated constant and an associated type\n+pub const Trait: usize = 0;"}, {"sha": "6401dacb57a8e02d9f0564896fdbc15c7adeaac7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-3.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,37 @@\n+error: `Trait` is both a constant and a trait\n+  --> $DIR/issue-108653-associated-items-3.rs:12:7\n+   |\n+LL | /// [`Trait`]\n+   |       ^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-3.rs:4:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait`]\n+   |       ++++++\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@Trait`]\n+   |       ++++++\n+\n+error: `Trait::Trait` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-3.rs:14:7\n+   |\n+LL | /// [`Trait::Trait`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait::Trait`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait::Trait`]\n+   |       +++++\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "537d61364bb1a19b1b7ce828fc661b2d3c4f6f89", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,21 @@\n+// This is ensuring that the UI output for associated items works when it's being documented\n+// from another item.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type Trait;\n+}\n+\n+/// [`Struct::Trait`]\n+//~^ ERROR both an associated constant and an associated type\n+pub struct Struct;\n+\n+impl Trait for Struct {\n+    type Trait = Struct;\n+}\n+\n+impl Struct {\n+    pub const Trait: usize = 0;\n+}"}, {"sha": "a8dc91204c0836887959ec0d487d03cfce4ca226", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-4.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+error: `Struct::Trait` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-4.rs:11:7\n+   |\n+LL | /// [`Struct::Trait`]\n+   |       ^^^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-4.rs:4:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Struct::Trait`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Struct::Trait`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "bc28bc5442181c0a47a386aca23304b2e6e82df4", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-5.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,8 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and a trait\n+pub mod u32 {\n+    pub trait MAX {}\n+}"}, {"sha": "7430044ac3f1bc698364f7731774c343a313ab15", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-5.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and a trait\n+  --> $DIR/issue-108653-associated-items-5.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-5.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@u32::MAX`]\n+   |       ++++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "8fde74d0ddb47ea326251c30ec50b2d6e6f5c69e", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-6.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,8 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and a primitive type\n+pub mod u32 {\n+    pub use std::primitive::u32 as MAX;\n+}"}, {"sha": "fe2d8cafa30262b04cb6d29337be3404c1bd9b04", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-6.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and a primitive type\n+  --> $DIR/issue-108653-associated-items-6.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-6.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the primitive type, prefix with `prim@`\n+   |\n+LL | /// [`prim@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "6e99f4365a78d0dcc580d1f8a09da3042b7b87c5", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-7.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,12 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type MAX;\n+}\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and an associated type\n+impl Trait for u32 {\n+    type MAX = u32;\n+}"}, {"sha": "1d302ff42e86f1b89e5f5adffc7160ce25f8e9e7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-7.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-7.rs:8:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-7.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "2f8ee1566bd4e76cf3dc2c21f87b8fbd08b752f6", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-8.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,12 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait T {\n+    type MAX;\n+}\n+\n+impl T for u32 {\n+    type MAX = ();\n+}"}, {"sha": "efed0e2ce0ff54fdda62860991725ef899582bee", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-8.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-8.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-8.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "3357ccf2460d819a21344a491b253e55efa25d44", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-9.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![deny(warnings)]\n+\n+//! [usize::Item]\n+\n+pub trait Foo { type Item; }\n+pub trait Bar { type Item; }\n+\n+impl Foo for usize { type Item = u32; }\n+impl Bar for usize { type Item = i32; }"}, {"sha": "0a393e26d6a96ee2f3007593f9fbeb8dcde3a95a", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,35 @@\n+// This is ensuring that the UI output for associated items is as expected.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+pub enum Enum {\n+    IDENT,\n+}\n+\n+/// [`Self::IDENT`]\n+//~^ ERROR both an associated function and an associated type\n+pub trait Trait {\n+    type IDENT;\n+    fn IDENT();\n+}\n+\n+/// [`Self::IDENT`]\n+//~^ ERROR both an associated function and a variant\n+impl Trait for Enum {\n+    type IDENT = usize;\n+    fn IDENT() {}\n+}\n+\n+/// [`Self::IDENT2`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait Trait2 {\n+    type IDENT2;\n+    const IDENT2: usize;\n+}\n+\n+/// [`Self::IDENT2`]\n+//~^ ERROR both an associated constant and an associated type\n+impl Trait2 for Enum {\n+    type IDENT2 = usize;\n+    const IDENT2: usize = 0;\n+}"}, {"sha": "084aefc97c8348f72f4f91e616fd4f26669330fb", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -0,0 +1,67 @@\n+error: `Self::IDENT` is both an associated function and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:9:7\n+   |\n+LL | /// [`Self::IDENT`]\n+   |       ^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Self::IDENT()`]\n+   |                  ++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT`]\n+   |       +++++\n+\n+error: `Self::IDENT2` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:23:7\n+   |\n+LL | /// [`Self::IDENT2`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Self::IDENT2`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT2`]\n+   |       +++++\n+\n+error: `Self::IDENT2` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:30:7\n+   |\n+LL | /// [`Self::IDENT2`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Self::IDENT2`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT2`]\n+   |       +++++\n+\n+error: `Self::IDENT` is both an associated function and a variant\n+  --> $DIR/issue-108653-associated-items.rs:16:7\n+   |\n+LL | /// [`Self::IDENT`]\n+   |       ^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Self::IDENT()`]\n+   |                  ++\n+help: to link to the variant, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT`]\n+   |       +++++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6e08a923963c4e1cb70988d420c41b8ab140231f", "filename": "tests/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -39,25 +39,25 @@ error: unresolved link to `unit::eq`\n   --> $DIR/non-path-primitives.rs:28:6\n    |\n LL | //! [unit::eq]\n-   |      ^^^^^^^^ the builtin type `unit` has no associated item named `eq`\n+   |      ^^^^^^^^ the primitive type `unit` has no associated item named `eq`\n \n error: unresolved link to `tuple::eq`\n   --> $DIR/non-path-primitives.rs:29:6\n    |\n LL | //! [tuple::eq]\n-   |      ^^^^^^^^^ the builtin type `tuple` has no associated item named `eq`\n+   |      ^^^^^^^^^ the primitive type `tuple` has no associated item named `eq`\n \n error: unresolved link to `fn::eq`\n   --> $DIR/non-path-primitives.rs:30:6\n    |\n LL | //! [fn::eq]\n-   |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n+   |      ^^^^^^ the primitive type `fn` has no associated item named `eq`\n \n error: unresolved link to `reference::deref`\n   --> $DIR/non-path-primitives.rs:34:6\n    |\n LL | //! [reference::deref]\n-   |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n+   |      ^^^^^^^^^^^^^^^^ the primitive type `reference` has no associated item named `deref`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "e87ce095cd4341c949adabe86f111f94ce5dc398", "filename": "tests/rustdoc-ui/intra-doc/prim-conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -2,16 +2,16 @@\n //~^ NOTE lint level is defined\n \n /// [char]\n-//~^ ERROR both a module and a builtin type\n+//~^ ERROR both a module and a primitive type\n //~| NOTE ambiguous link\n //~| HELP to link to the module\n-//~| HELP to link to the builtin type\n+//~| HELP to link to the primitive type\n \n /// [type@char]\n-//~^ ERROR both a module and a builtin type\n+//~^ ERROR both a module and a primitive type\n //~| NOTE ambiguous link\n //~| HELP to link to the module\n-//~| HELP to link to the builtin type\n+//~| HELP to link to the primitive type\n \n /// [mod@char] // ok\n /// [prim@char] // ok\n@@ -26,5 +26,5 @@ pub mod inner {\n     //! [struct@char]\n     //~^ ERROR incompatible link\n     //~| HELP prefix with `prim@`\n-    //~| NOTE resolved to a builtin type\n+    //~| NOTE resolved to a primitive type\n }"}, {"sha": "03ce8f15f0a5e8699b5d231f0596b4ea00554c2a", "filename": "tests/rustdoc-ui/intra-doc/prim-conflict.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fe5b56b66ebd1a125275b6219301cf797fc5ff9/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr?ref=8fe5b56b66ebd1a125275b6219301cf797fc5ff9", "patch": "@@ -1,4 +1,4 @@\n-error: `char` is both a module and a builtin type\n+error: `char` is both a module and a primitive type\n   --> $DIR/prim-conflict.rs:4:6\n    |\n LL | /// [char]\n@@ -13,12 +13,12 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ++++\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      +++++\n \n-error: `char` is both a module and a builtin type\n+error: `char` is both a module and a primitive type\n   --> $DIR/prim-conflict.rs:10:6\n    |\n LL | /// [type@char]\n@@ -28,7 +28,7 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ~~~~\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      ~~~~~\n@@ -48,9 +48,9 @@ error: incompatible link kind for `char`\n   --> $DIR/prim-conflict.rs:26:10\n    |\n LL |     //! [struct@char]\n-   |          ^^^^^^^^^^^ this link resolved to a builtin type, which is not a struct\n+   |          ^^^^^^^^^^^ this link resolved to a primitive type, which is not a struct\n    |\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL |     //! [prim@char]\n    |          ~~~~~"}]}