{"sha": "8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZTBmNjY1YmNkYTlmNWU0MDc3ZDBiZTZlYmM2YWEzODJlNzIzMTk=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-14T23:39:57Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-15T20:58:08Z"}, "message": "De-mode pipes", "tree": {"sha": "c1820b0f614cafa74e4081000105aed998d56087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1820b0f614cafa74e4081000105aed998d56087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "html_url": "https://github.com/rust-lang/rust/commit/8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8be0f665bcda9f5e4077d0be6ebc6aa382e72319/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51d98d9c7bcdfad2daec697739b25193adc09ced", "url": "https://api.github.com/repos/rust-lang/rust/commits/51d98d9c7bcdfad2daec697739b25193adc09ced", "html_url": "https://github.com/rust-lang/rust/commit/51d98d9c7bcdfad2daec697739b25193adc09ced"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "ba8ac5cae8711e3615c60cea78a33c9ccce34eb9", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8be0f665bcda9f5e4077d0be6ebc6aa382e72319/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be0f665bcda9f5e4077d0be6ebc6aa382e72319/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "patch": "@@ -72,6 +72,10 @@ bounded and unbounded protocols allows for less code duplication.\n \n */\n \n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import unsafe::{forget, reinterpret_cast, transmute};\n import either::{either, left, right};\n import option::unwrap;\n@@ -143,15 +147,15 @@ struct packet_header {\n     // Returns the old state.\n     unsafe fn mark_blocked(this: *rust_task) -> state {\n         rustrt::rust_task_ref(this);\n-        let old_task = swap_task(self.blocked_task, this);\n+        let old_task = swap_task(&mut self.blocked_task, this);\n         assert old_task.is_null();\n-        swap_state_acq(self.state, blocked)\n+        swap_state_acq(&mut self.state, blocked)\n     }\n \n     unsafe fn unblock() {\n-        let old_task = swap_task(self.blocked_task, ptr::null());\n+        let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() { rustrt::rust_task_deref(old_task) }\n-        match swap_state_acq(self.state, empty) {\n+        match swap_state_acq(&mut self.state, empty) {\n           empty | blocked => (),\n           terminated => self.state = terminated,\n           full => self.state = full\n@@ -224,7 +228,7 @@ fn packet<T: send>() -> *packet<T> {\n \n #[doc(hidden)]\n fn entangle_buffer<T: send, Tstart: send>(\n-    -buffer: ~buffer<T>,\n+    +buffer: ~buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *packet<Tstart>)\n     -> (send_packet_buffered<Tstart, T>, recv_packet_buffered<Tstart, T>)\n {\n@@ -247,27 +251,27 @@ extern mod rusti {\n // If I call the rusti versions directly from a polymorphic function,\n // I get link errors. This is a bug that needs investigated more.\n #[doc(hidden)]\n-fn atomic_xchng_rel(&dst: int, src: int) -> int {\n-    rusti::atomic_xchng_rel(dst, src)\n+fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n+    rusti::atomic_xchng_rel(*dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_add_acq(&dst: int, src: int) -> int {\n-    rusti::atomic_add_acq(dst, src)\n+fn atomic_add_acq(dst: &mut int, src: int) -> int {\n+    rusti::atomic_add_acq(*dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_sub_rel(&dst: int, src: int) -> int {\n-    rusti::atomic_sub_rel(dst, src)\n+fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n+    rusti::atomic_sub_rel(*dst, src)\n }\n \n #[doc(hidden)]\n-fn swap_task(&dst: *rust_task, src: *rust_task) -> *rust_task {\n+fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng(\n-            *(ptr::mut_addr_of(dst) as *mut int),\n+            *(ptr::mut_addr_of(*dst) as *mut int),\n             src as int))\n     }\n }\n@@ -302,19 +306,19 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n }\n \n #[doc(hidden)]\n-fn swap_state_acq(&dst: state, src: state) -> state {\n+fn swap_state_acq(dst: &mut state, src: state) -> state {\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng_acq(\n-            *(ptr::mut_addr_of(dst) as *mut int),\n+            *(ptr::mut_addr_of(*dst) as *mut int),\n             src as int))\n     }\n }\n \n #[doc(hidden)]\n-fn swap_state_rel(&dst: state, src: state) -> state {\n+fn swap_state_rel(dst: &mut state, src: state) -> state {\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng_rel(\n-            *(ptr::mut_addr_of(dst) as *mut int),\n+            *(ptr::mut_addr_of(*dst) as *mut int),\n             src as int))\n     }\n }\n@@ -329,15 +333,15 @@ struct buffer_resource<T: send> {\n     new(+b: ~buffer<T>) {\n         //let p = ptr::addr_of(*b);\n         //error!{\"take %?\", p};\n-        atomic_add_acq(b.header.ref_count, 1);\n+        atomic_add_acq(&mut b.header.ref_count, 1);\n         self.buffer = b;\n     }\n \n     drop unsafe {\n         let b = move_it!{self.buffer};\n         //let p = ptr::addr_of(*b);\n         //error!{\"drop %?\", p};\n-        let old_count = atomic_sub_rel(b.header.ref_count, 1);\n+        let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n         //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n         if old_count == 1 {\n             // The new count is 0.\n@@ -351,15 +355,15 @@ struct buffer_resource<T: send> {\n }\n \n #[doc(hidden)]\n-fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n-                                -payload: T) -> bool {\n+fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n+                                +payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(p.header) == header;\n     assert p.payload == none;\n     p.payload <- some(payload);\n-    let old_state = swap_state_rel(p.header.state, full);\n+    let old_state = swap_state_rel(&mut p.header.state, full);\n     match old_state {\n         empty => {\n             // Yay, fastpath.\n@@ -371,7 +375,7 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n         full => fail ~\"duplicate send\",\n         blocked => {\n             debug!{\"waking up task for %?\", p_};\n-            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::task_signal_event(\n                     old_task, ptr::addr_of(p.header) as *libc::c_void);\n@@ -395,7 +399,7 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-fn recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>) -> T {\n+fn recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(p), \"connection closed\")\n }\n \n@@ -405,7 +409,7 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `some(T)` if a message was received.\n \n */\n-fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n+fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n     -> option<T>\n {\n     let p_ = p.unwrap();\n@@ -417,7 +421,8 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n         drop {\n             if task::failing() {\n                 self.p.state = terminated;\n-                let old_task = swap_task(self.p.blocked_task, ptr::null());\n+                let old_task = swap_task(&mut self.p.blocked_task,\n+                                         ptr::null());\n                 if !old_task.is_null() {\n                     rustrt::rust_task_deref(old_task);\n                 }\n@@ -443,13 +448,13 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n     rustrt::rust_task_ref(this);\n-    let old_task = swap_task(p.header.blocked_task, this);\n+    let old_task = swap_task(&mut p.header.blocked_task, this);\n     assert old_task.is_null();\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n         rustrt::task_clear_event_reject(this);\n-        let old_state = swap_state_acq(p.header.state,\n+        let old_state = swap_state_acq(&mut p.header.state,\n                                        blocked);\n         match old_state {\n           empty => {\n@@ -474,7 +479,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n           full => {\n             let mut payload = none;\n             payload <-> p.payload;\n-            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::rust_task_deref(old_task);\n             }\n@@ -486,7 +491,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n             // casted too big of a number to a state.\n             assert old_state == terminated;\n \n-            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::rust_task_deref(old_task);\n             }\n@@ -498,7 +503,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: send, Tb: send>(p: recv_packet_buffered<T, Tb>) -> bool {\n+pure fn peek<T: send, Tb: send>(p: &recv_packet_buffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       empty => false,\n       blocked => fail ~\"peeking on blocked packet\",\n@@ -508,20 +513,20 @@ pure fn peek<T: send, Tb: send>(p: recv_packet_buffered<T, Tb>) -> bool {\n \n impl<T: send, Tb: send> recv_packet_buffered<T, Tb> {\n     pure fn peek() -> bool {\n-        peek(self)\n+        peek(&self)\n     }\n }\n \n #[doc(hidden)]\n fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n-    match swap_state_rel(p.header.state, terminated) {\n+    match swap_state_rel(&mut p.header.state, terminated) {\n       empty => {\n         // The receiver will eventually clean up.\n       }\n       blocked => {\n         // wake up the target\n-        let old_task = swap_task(p.header.blocked_task, ptr::null());\n+        let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::task_signal_event(\n                 old_task,\n@@ -544,13 +549,13 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n #[doc(hidden)]\n fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n-    match swap_state_rel(p.header.state, terminated) {\n+    match swap_state_rel(&mut p.header.state, terminated) {\n       empty => {\n         assert p.header.blocked_task.is_null();\n         // the sender will clean up\n       }\n       blocked => {\n-        let old_task = swap_task(p.header.blocked_task, ptr::null());\n+        let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::rust_task_deref(old_task);\n             assert old_task == rustrt::rust_get_task();\n@@ -682,7 +687,7 @@ fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n+fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> either<(), ()> {\n     match wait_many([a.header(), b.header()]/_) {\n       0 => left(()),\n       1 => right(()),\n@@ -1004,7 +1009,7 @@ impl<T: send> port<T>: recv<T> {\n         let mut endp = none;\n         endp <-> self.endp;\n         let peek = match endp {\n-          some(endp) => pipes::peek(endp),\n+          some(endp) => pipes::peek(&endp),\n           none => fail ~\"peeking empty stream\"\n         };\n         self.endp <-> endp;\n@@ -1122,7 +1127,7 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n \n     fn select() -> either<T, U> {\n         match self {\n-          (lp, rp) => match select2i(lp, rp) {\n+          (lp, rp) => match select2i(&lp, &rp) {\n             left(()) => left (lp.recv()),\n             right(()) => right(rp.recv())\n           }\n@@ -1131,7 +1136,7 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n \n     fn try_select() -> either<option<T>, option<U>> {\n         match self {\n-          (lp, rp) => match select2i(lp, rp) {\n+          (lp, rp) => match select2i(&lp, &rp) {\n             left(()) => left (lp.try_recv()),\n             right(()) => right(rp.try_recv())\n           }"}, {"sha": "f9f05056a6687e8e4ce8594c2a9fc315f4eda41d", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8be0f665bcda9f5e4077d0be6ebc6aa382e72319/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8be0f665bcda9f5e4077d0be6ebc6aa382e72319/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=8be0f665bcda9f5e4077d0be6ebc6aa382e72319", "patch": "@@ -13,9 +13,9 @@ proto! oneshot {\n fn main() {\n     let (c, p) = oneshot::init();\n \n-    assert !pipes::peek(p);\n+    assert !pipes::peek(&p);\n \n     oneshot::client::signal(c);\n \n-    assert pipes::peek(p);\n+    assert pipes::peek(&p);\n }"}]}