{"sha": "9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MDZkOGY2MDIyZDNlNGY0ZTJhMjQ3YTEwYzM0MDhkNGZjYjg0NGM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-13T18:09:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-11-19T04:24:34Z"}, "message": "rustc: middle: rename `ty::t` to `Ty` and use it unqualified everywhere.", "tree": {"sha": "de640fdcab8c447f7ae2b54de732fde29998a29c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de640fdcab8c447f7ae2b54de732fde29998a29c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "html_url": "https://github.com/rust-lang/rust/commit/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21da75066340bc36ac5086f849e959df9ae67dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/21da75066340bc36ac5086f849e959df9ae67dba", "html_url": "https://github.com/rust-lang/rust/commit/21da75066340bc36ac5086f849e959df9ae67dba"}], "stats": {"total": 2220, "additions": 1108, "deletions": 1112}, "files": [{"sha": "126d4c00f2867ea40636acffa63a47859d69834e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -28,9 +28,10 @@ use self::MethodContext::*;\n \n use metadata::csearch;\n use middle::def::*;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::ast_ty_to_ty;\n-use middle::typeck::infer;\n-use middle::{typeck, ty, def, pat_util, stability};\n+use middle::typeck::{mod, infer};\n+use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n@@ -473,7 +474,7 @@ declare_lint!(BOX_POINTERS, Allow,\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n+    fn check_heap_type(&self, cx: &Context, span: Span, ty: Ty) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {"}, {"sha": "a519683b351bb030819a87aacbba260eb34a9635", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -27,7 +27,7 @@ use self::TargetLint::*;\n \n use middle::privacy::ExportedItems;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n use session::{early_error, Session};\n@@ -554,22 +554,22 @@ impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n         ty::lookup_trait_def(self.tcx, id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> ty::t {\n+    fn ty_infer(&self, _span: Span) -> Ty {\n         infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n                                            -> bool {\n         // FIXME(pcwalton): This is wrong.\n         true\n     }\n \n     fn associated_type_binding(&self,\n                                _: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         // FIXME(pcwalton): This is wrong.\n         let trait_def = self.get_trait_def(trait_id);\n         let index = ty::associated_type_parameter_index(self.tcx,"}, {"sha": "b45f57eae96713a19cbb9a302d791aee239c42cb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -29,7 +29,7 @@ use middle::lang_items;\n use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n@@ -224,7 +224,7 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     })\n }\n \n-fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> Ty {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n@@ -237,7 +237,7 @@ fn doc_method_fty(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n }\n \n pub fn item_type(_item_id: ast::DefId, item: rbml::Doc,\n-                 tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+                 tcx: &ty::ctxt, cdata: Cmd) -> Ty {\n     doc_type(item, tcx, cdata)\n }\n "}, {"sha": "a1e4cd97dac22c583084401f0119df8cd7d2db27", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -22,7 +22,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{lookup_item_type};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::stability;\n use middle;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -172,7 +172,7 @@ pub fn write_closure_type(ecx: &EncodeContext,\n \n pub fn write_type(ecx: &EncodeContext,\n                   rbml_w: &mut Encoder,\n-                  typ: ty::t) {\n+                  typ: Ty) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -223,7 +223,7 @@ fn encode_bounds(rbml_w: &mut Encoder,\n \n fn encode_type(ecx: &EncodeContext,\n                rbml_w: &mut Encoder,\n-               typ: ty::t) {\n+               typ: Ty) {\n     rbml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, rbml_w, typ);\n     rbml_w.end_tag();\n@@ -2167,7 +2167,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n+pub fn encoded_ty(tcx: &ty::ctxt, t: Ty) -> String {\n     let mut wr = SeekableMemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "6215f7ea77448dbb80e7f561924a37f300438051", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -20,7 +20,7 @@ pub use self::DefIdSource::*;\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n \n use std::rc::Rc;\n use std::str;\n@@ -29,7 +29,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;\n \n-// Compact string representation for ty::t values. API ty_str &\n+// Compact string representation for Ty values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n@@ -150,7 +150,7 @@ pub fn parse_ty_closure_data(data: &[u8],\n }\n \n pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                     conv: conv_did) -> ty::t {\n+                     conv: conv_did) -> Ty {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n@@ -359,7 +359,7 @@ fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n+fn parse_ty(st: &mut PState, conv: conv_did) -> Ty {\n     match next(st) {\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),"}, {"sha": "7c929a1fbcdd4f4843649bb88faa66426573d14a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -18,7 +18,7 @@ use std::cell::RefCell;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::ParamTy;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::nodemap::FnvHashMap;\n \n use syntax::abi::Abi;\n@@ -46,9 +46,9 @@ pub struct ty_abbrev {\n     s: String\n }\n \n-pub type abbrev_map = RefCell<FnvHashMap<ty::t, ty_abbrev>>;\n+pub type abbrev_map = RefCell<FnvHashMap<Ty, ty_abbrev>>;\n \n-pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n+pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: Ty) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}"}, {"sha": "cd65334d6645f91361f2aa102b23541b1bae0b62", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -26,8 +26,8 @@ use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n-use middle::{ty, typeck};\n+use middle::typeck::{mod, MethodCall, MethodCallee, MethodOrigin};\n+use middle::ty::{mod, Ty};\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n@@ -831,8 +831,8 @@ trait rbml_writer_helpers {\n     fn emit_method_origin(&mut self,\n                           ecx: &e::EncodeContext,\n                           method_origin: &typeck::MethodOrigin);\n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: Ty);\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[Ty]);\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n@@ -915,11 +915,11 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n+    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: Ty) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n+    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[Ty]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n@@ -1327,8 +1327,8 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n \n trait rbml_decoder_decoder_helpers {\n     fn read_method_origin(&mut self, dcx: &DecodeContext) -> typeck::MethodOrigin;\n-    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> Ty;\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<Ty>;\n     fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef>;\n     fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef;\n@@ -1351,18 +1351,18 @@ trait rbml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> Ty;\n     fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty>;\n     fn read_substs_nodcx(&mut self, tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n                          -> subst::Substs;\n }\n \n impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> Ty {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n                 doc.data,\n@@ -1375,7 +1375,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n@@ -1468,7 +1468,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n \n-    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> Ty {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1496,7 +1496,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t> {\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<Ty> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n "}, {"sha": "45bab842bca1086dc9b54c11570b8f1a53a89ea4", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -24,7 +24,7 @@ use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::rc::Rc;\n@@ -586,7 +586,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msgs: (&'static str, &'static str))\n+        fn move_suggestion(tcx: &ty::ctxt, ty: Ty, default_msgs: (&'static str, &'static str))\n                           -> (&'static str, &'static str) {\n             match ty::get(ty).sty {\n                 ty::ty_closure(box ty::ClosureTy {"}, {"sha": "bb118dcb349fff6aab8aa3525b9b430e01dea282", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -21,7 +21,7 @@ use middle::expr_use_visitor::{WriteAndRead};\n use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n@@ -403,7 +403,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: struct X { a: (bool, &'static str), b: uint}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<&Pat>, left_ty: ty::t) -> P<Pat> {\n+                     pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n@@ -483,7 +483,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n+                       left_ty: Ty, max_slice_length: uint) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n@@ -496,7 +496,7 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n+fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: uint) -> Vec<Constructor> {\n     match ty::get(left_ty).sty {\n         ty::ty_bool =>\n@@ -616,7 +616,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n }\n \n fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n-                         v: &[&Pat], ctor: Constructor, lty: ty::t,\n+                         v: &[&Pat], ctor: Constructor, lty: Ty,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n@@ -638,7 +638,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n-                    left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n+                    left_ty: Ty, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n         ast::PatIdent(..) =>\n@@ -695,7 +695,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n+pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_uniq(_) => 1u,"}, {"sha": "fe52e85142f9b6d003fbfeba0772ea01c80b13f9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -18,7 +18,7 @@ use metadata::csearch;\n use middle::astencode;\n use middle::def;\n use middle::pat_util::def_to_path;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv;\n use middle::typeck::check;\n use util::nodemap::{DefIdMap};"}, {"sha": "54dcc845fef375d99ec0deb3d93073e3409d0682", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,7 +13,7 @@\n use self::UnsafeContext::*;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::MethodCall;\n use util::ppaux;\n \n@@ -30,7 +30,7 @@ enum UnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-fn type_is_unsafe_function(ty: ty::t) -> bool {\n+fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_bare_fn(ref f) => f.fn_style == ast::UnsafeFn,\n         ty::ty_closure(ref f) => f.fn_style == ast::UnsafeFn,"}, {"sha": "494d678ea382621109fcec37f58c9aacbeca695e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -24,7 +24,7 @@ use middle::mem_categorization as mc;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n@@ -999,7 +999,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     }\n }\n \n-fn copy_or_move(tcx: &ty::ctxt, ty: ty::t, move_reason: MoveReason) -> ConsumeMode {\n+fn copy_or_move(tcx: &ty::ctxt, ty: Ty, move_reason: MoveReason) -> ConsumeMode {\n     if ty::type_moves_by_default(tcx, ty) { Move(move_reason) } else { Copy }\n }\n "}, {"sha": "2f451bfa4e0081ebb08ea97284ed02e7f0cf04be", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use syntax::ast;\n \n use self::SimplifiedType::*;\n@@ -34,7 +34,7 @@ pub enum SimplifiedType {\n }\n \n pub fn simplify_type(tcx: &ty::ctxt,\n-                     ty: ty::t,\n+                     ty: Ty,\n                      can_simplify_params: bool)\n                      -> Option<SimplifiedType>\n {"}, {"sha": "913995a33251413df25be419d9631f3be3e920bb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -12,7 +12,7 @@ use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::Subst;\n use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n@@ -23,7 +23,7 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n+fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: Ty)\n                                             -> bool {\n     let mut result = false;\n     ty::maybe_walk_ty(typ, |typ| {\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty, to: Ty, id: ast::NodeId) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute from a type that contains type parameters\");"}, {"sha": "572059e99fc63d86e1efd25ddf650dc29385db8e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -74,7 +74,7 @@ pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n@@ -180,7 +180,7 @@ pub struct cmt_ {\n     pub span: Span,                // span of same expr/pat\n     pub cat: categorization,       // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    pub ty: ty::t,                 // type of the expr (*see WARNING above*)\n+    pub ty: Ty,                    // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n }\n \n@@ -196,7 +196,7 @@ pub enum deref_kind {\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n+pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n@@ -232,7 +232,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     }\n }\n \n-pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n+pub fn deref_kind(tcx: &ty::ctxt, t: Ty) -> deref_kind {\n     debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n@@ -285,8 +285,8 @@ pub type McResult<T> = Result<T, ()>;\n  */\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty>;\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -393,22 +393,22 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n                          self.typer.adjustments().borrow().get(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<ty::t> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty> {\n         self.typer.node_ty(pat.id)\n     }\n \n@@ -546,7 +546,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n-                   expr_ty: ty::t,\n+                   expr_ty: Ty,\n                    def: def::Def)\n                    -> McResult<cmt> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n@@ -804,7 +804,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n-                           expr_ty: ty::t)\n+                           expr_ty: Ty)\n                            -> cmt {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n@@ -823,7 +823,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n-                      expr_ty: ty::t) -> cmt {\n+                      expr_ty: Ty) -> cmt {\n         Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n@@ -838,7 +838,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Name,\n-                                 f_ty: ty::t)\n+                                 f_ty: Ty)\n                                  -> cmt {\n         Rc::new(cmt_ {\n             id: node.id(),\n@@ -854,7 +854,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                      node: &N,\n                                      base_cmt: cmt,\n                                      f_idx: uint,\n-                                     f_ty: ty::t)\n+                                     f_ty: Ty)\n                                      -> cmt {\n         Rc::new(cmt_ {\n             id: node.id(),\n@@ -909,7 +909,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     deref_cnt: uint,\n-                                    deref_ty: ty::t,\n+                                    deref_ty: Ty,\n                                     implicit: bool)\n                                     -> cmt {\n         let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n@@ -990,9 +990,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         fn interior<N: ast_node>(elt: &N,\n                                  of_cmt: cmt,\n-                                 vec_ty: ty::t,\n+                                 vec_ty: Ty,\n                                  mutbl: MutabilityCategory,\n-                                 element_ty: ty::t) -> cmt\n+                                 element_ty: Ty) -> cmt\n         {\n             Rc::new(cmt_ {\n                 id:elt.id(),\n@@ -1060,7 +1060,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n                           pat: &ast::Pat,\n-                          slice_ty: ty::t)\n+                          slice_ty: Ty)\n                           -> (ast::Mutability, ty::Region) {\n             /*!\n              * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -1086,7 +1086,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n                                         base_cmt: cmt,\n-                                        interior_ty: ty::t,\n+                                        interior_ty: Ty,\n                                         interior: InteriorKind)\n                                         -> cmt {\n         Rc::new(cmt_ {\n@@ -1102,7 +1102,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n-                                    downcast_ty: ty::t)\n+                                    downcast_ty: Ty)\n                                     -> cmt {\n         Rc::new(cmt_ {\n             id: node.id(),\n@@ -1531,7 +1531,7 @@ impl Repr for InteriorKind {\n     }\n }\n \n-fn element_kind(t: ty::t) -> ElementKind {\n+fn element_kind(t: Ty) -> ElementKind {\n     match ty::get(t).sty {\n         ty::ty_rptr(_, ty::mt{ty, ..}) |\n         ty::ty_uniq(ty) => match ty::get(ty).sty {"}, {"sha": "0b097c63710ad8b24e9992b8cdbdd90830af85d0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -19,7 +19,7 @@ use std::mem::replace;\n use metadata::csearch;\n use middle::def;\n use middle::resolve;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{NodeMap, NodeSet};"}, {"sha": "0c0861eda3e7a997128152d8655cdbedc41f8328", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -23,7 +23,7 @@ Most of the documentation on regions can be found in\n \n use session::Session;\n use middle::ty::{FreeRegion};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n use util::common::can_reach;\n "}, {"sha": "7222806e4844207f2d1b4284f868610daea48edc", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,7 +13,7 @@\n pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n@@ -32,7 +32,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n  */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct Substs {\n-    pub types: VecPerParamSpace<ty::t>,\n+    pub types: VecPerParamSpace<Ty>,\n     pub regions: RegionSubsts,\n }\n \n@@ -47,32 +47,32 @@ pub enum RegionSubsts {\n }\n \n impl Substs {\n-    pub fn new(t: VecPerParamSpace<ty::t>,\n+    pub fn new(t: VecPerParamSpace<Ty>,\n                r: VecPerParamSpace<ty::Region>)\n                -> Substs\n     {\n         Substs { types: t, regions: NonerasedRegions(r) }\n     }\n \n-    pub fn new_type(t: Vec<ty::t>,\n+    pub fn new_type(t: Vec<Ty>,\n                     r: Vec<ty::Region>)\n                     -> Substs\n     {\n         Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn new_trait(t: Vec<ty::t>,\n+    pub fn new_trait(t: Vec<Ty>,\n                      r: Vec<ty::Region>,\n-                     a: Vec<ty::t>,\n-                     s: ty::t)\n+                     a: Vec<Ty>,\n+                     s: Ty)\n                     -> Substs\n     {\n         Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n+    pub fn erased(t: VecPerParamSpace<Ty>) -> Substs\n     {\n         Substs { types: t, regions: ErasedRegions }\n     }\n@@ -111,11 +111,11 @@ impl Substs {\n         }\n     }\n \n-    pub fn self_ty(&self) -> Option<ty::t> {\n+    pub fn self_ty(&self) -> Option<Ty> {\n         self.types.get_self().map(|&t| t)\n     }\n \n-    pub fn with_self_ty(&self, self_ty: ty::t) -> Substs {\n+    pub fn with_self_ty(&self, self_ty: Ty) -> Substs {\n         assert!(self.self_ty().is_none());\n         let mut s = (*self).clone();\n         s.types.push(SelfSpace, self_ty);\n@@ -154,7 +154,7 @@ impl Substs {\n     }\n \n     pub fn with_method(self,\n-                       m_types: Vec<ty::t>,\n+                       m_types: Vec<Ty>,\n                        m_regions: Vec<ty::Region>)\n                        -> Substs\n     {\n@@ -575,7 +575,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     span: Option<Span>,\n \n     // The root type that is being substituted, if available.\n-    root_ty: Option<ty::t>,\n+    root_ty: Option<Ty>,\n \n     // Depth of type stack\n     ty_stack_depth: uint,\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         if !ty::type_needs_subst(t) {\n             return t;\n         }\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n }\n \n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n-    fn ty_for_param(&self, p: ty::ParamTy, source_ty: ty::t) -> ty::t {\n+    fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty) -> Ty {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n         let ty = match opt_ty {\n@@ -684,7 +684,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n         self.shift_regions_through_binders(ty)\n     }\n \n-    fn shift_regions_through_binders(&self, ty: ty::t) -> ty::t {\n+    fn shift_regions_through_binders(&self, ty: Ty) -> Ty {\n         /*!\n          * It is sometimes necessary to adjust the debruijn indices\n          * during substitution. This occurs when we are substituting a"}, {"sha": "fa469dc734759ae2622499e74b74bc87693559a0", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -16,7 +16,7 @@ use super::util;\n \n use middle::subst;\n use middle::subst::Subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{mod, InferCtxt};\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n@@ -76,10 +76,7 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n-pub fn ty_is_local(tcx: &ty::ctxt,\n-                   ty: ty::t)\n-                   -> bool\n-{\n+pub fn ty_is_local(tcx: &ty::ctxt, ty: Ty) -> bool {\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n     match ty::get(ty).sty {"}, {"sha": "d821c447eb8ac87c3a2a382bcc3f132e52ddda89", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -19,7 +19,7 @@ pub use self::ObligationCauseCode::*;\n \n use middle::mem_categorization::Typer;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::InferCtxt;\n use std::rc::Rc;\n use std::slice::Items;\n@@ -75,7 +75,7 @@ pub enum ObligationCauseCode {\n     ItemObligation(ast::DefId),\n \n     /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ ty::t),\n+    ObjectCastObligation(/* Object type */ Ty),\n \n     /// To implement drop, type must be sendable.\n     DropTrait,\n@@ -231,7 +231,7 @@ pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                      typer: &Typer<'tcx>,\n                                      cause: ObligationCause,\n                                      impl_def_id: ast::DefId,\n-                                     self_ty: ty::t)\n+                                     self_ty: Ty)\n                                      -> SelectionResult<VtableImplData<Obligation>>\n {\n     /*!\n@@ -284,7 +284,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n                                 generic_bounds: &ty::GenericBounds,\n-                                type_substs: &subst::VecPerParamSpace<ty::t>)\n+                                type_substs: &subst::VecPerParamSpace<Ty>)\n                                 -> subst::VecPerParamSpace<Obligation>\n {\n     /*!\n@@ -307,7 +307,7 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n \n pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,\n                                     cause: ObligationCause,\n-                                    source_ty: ty::t,\n+                                    source_ty: Ty,\n                                     builtin_bound: ty::BuiltinBound)\n                                     -> Result<Obligation, ErrorReported>\n {\n@@ -325,7 +325,7 @@ impl Obligation {\n         Obligation::new(ObligationCause::misc(span), trait_ref)\n     }\n \n-    pub fn self_ty(&self) -> ty::t {\n+    pub fn self_ty(&self) -> Ty {\n         self.trait_ref.self_ty()\n     }\n }"}, {"sha": "6ff405f19fb9021203707bde2c4b83a724d33019", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -30,7 +30,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n@@ -142,7 +142,7 @@ struct CandidateSet {\n }\n \n enum BuiltinBoundConditions {\n-    If(Vec<ty::t>),\n+    If(Vec<Ty>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -221,7 +221,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn select_inherent_impl(&mut self,\n                                 impl_def_id: ast::DefId,\n                                 obligation_cause: ObligationCause,\n-                                obligation_self_ty: ty::t)\n+                                obligation_self_ty: Ty)\n                                 -> SelectionResult<VtableImplData<Obligation>>\n     {\n         debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n@@ -271,7 +271,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_builtin_bound_recursively(&mut self,\n                                           bound: ty::BuiltinBound,\n                                           previous_stack: &ObligationStack,\n-                                          ty: ty::t)\n+                                          ty: Ty)\n                                           -> EvaluationResult\n     {\n         let obligation =\n@@ -434,8 +434,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // the algorithm.\n \n     pub fn evaluate_method_obligation(&mut self,\n-                                      rcvr_ty: ty::t,\n-                                      xform_self_ty: ty::t,\n+                                      rcvr_ty: Ty,\n+                                      xform_self_ty: Ty,\n                                       obligation: &Obligation)\n                                       -> MethodMatchResult\n     {\n@@ -562,8 +562,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn confirm_method_match(&mut self,\n-                                rcvr_ty: ty::t,\n-                                xform_self_ty: ty::t,\n+                                rcvr_ty: Ty,\n+                                xform_self_ty: Ty,\n                                 obligation: &Obligation,\n                                 data: MethodMatchedData)\n     {\n@@ -596,8 +596,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_method_precise(&mut self,\n-                            rcvr_ty: ty::t,\n-                            xform_self_ty: ty::t,\n+                            rcvr_ty: Ty,\n+                            xform_self_ty: Ty,\n                             obligation: &Obligation)\n                             -> Result<(),()>\n     {\n@@ -622,8 +622,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_method_candidates_from_impls(&mut self,\n-                                             rcvr_ty: ty::t,\n-                                             xform_self_ty: ty::t,\n+                                             rcvr_ty: Ty,\n+                                             xform_self_ty: Ty,\n                                              obligation: &Obligation)\n                                              -> Vec<ast::DefId>\n     {\n@@ -650,8 +650,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_method_coerce(&mut self,\n                            impl_def_id: ast::DefId,\n-                           rcvr_ty: ty::t,\n-                           xform_self_ty: ty::t,\n+                           rcvr_ty: Ty,\n+                           xform_self_ty: Ty,\n                            obligation: &Obligation)\n                            -> Result<Substs, ()>\n     {\n@@ -683,8 +683,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn winnow_method_impl(&mut self,\n                           impl_def_id: ast::DefId,\n-                          rcvr_ty: ty::t,\n-                          xform_self_ty: ty::t,\n+                          rcvr_ty: Ty,\n+                          xform_self_ty: Ty,\n                           obligation: &Obligation)\n                           -> bool\n     {\n@@ -1227,7 +1227,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n-                     self_ty: ty::t)\n+                     self_ty: Ty)\n                      -> Result<BuiltinBoundConditions,SelectionError>\n     {\n         let self_ty = self.infcx.shallow_resolve(self_ty);\n@@ -1443,7 +1443,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n \n                     Some(freevars) => {\n-                        let tys: Vec<ty::t> =\n+                        let tys: Vec<Ty> =\n                             freevars\n                             .iter()\n                             .map(|freevar| {\n@@ -1458,7 +1458,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_struct(def_id, ref substs) => {\n-                let types: Vec<ty::t> =\n+                let types: Vec<Ty> =\n                     ty::struct_fields(self.tcx(), def_id, substs)\n                     .iter()\n                     .map(|f| f.mt.ty)\n@@ -1467,7 +1467,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_enum(def_id, ref substs) => {\n-                let types: Vec<ty::t> =\n+                let types: Vec<Ty> =\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n                     .flat_map(|variant| variant.args.iter())\n@@ -1508,7 +1508,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         fn nominal(this: &mut SelectionContext,\n                    bound: ty::BuiltinBound,\n                    def_id: ast::DefId,\n-                   types: Vec<ty::t>)\n+                   types: Vec<Ty>)\n                    -> Result<BuiltinBoundConditions,SelectionError>\n         {\n             // First check for markers and other nonsense.\n@@ -1635,7 +1635,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn vtable_builtin_data(&mut self,\n                            obligation: &Obligation,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<ty::t>)\n+                           nested: Vec<Ty>)\n                            -> VtableBuiltinData<Obligation>\n     {\n         let obligations = nested.iter().map(|&t| {\n@@ -1829,7 +1829,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n-                           obligation_self_ty: ty::t)\n+                           obligation_self_ty: Ty)\n                            -> Result<Substs,()>\n     {\n         /*!\n@@ -1878,10 +1878,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         cause: ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n-                        provided_self_ty: ty::t,\n+                        provided_self_ty: Ty,\n \n                         // The self type the obligation is for:\n-                        required_self_ty: ty::t)\n+                        required_self_ty: Ty)\n                         -> Result<(),()>\n     {\n         // FIXME(#5781) -- equating the types is stronger than"}, {"sha": "41cdbc0948fd1ce579de5ccdca5e45ee650c713e", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -12,7 +12,7 @@\n use middle::subst;\n use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n@@ -174,7 +174,7 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n                                 recursion_depth: uint,\n                                 generic_bounds: &ty::GenericBounds,\n-                                type_substs: &VecPerParamSpace<ty::t>)\n+                                type_substs: &VecPerParamSpace<Ty>)\n                                 -> VecPerParamSpace<Obligation>\n {\n     /*! See `super::obligations_for_generics` */\n@@ -207,7 +207,7 @@ fn push_obligations_for_param_bounds(\n     space: subst::ParamSpace,\n     index: uint,\n     param_bounds: &ty::ParamBounds,\n-    param_type_substs: &VecPerParamSpace<ty::t>,\n+    param_type_substs: &VecPerParamSpace<Ty>,\n     obligations: &mut VecPerParamSpace<Obligation>)\n {\n     let param_ty = *param_type_substs.get(space, index);\n@@ -235,7 +235,7 @@ fn push_obligations_for_param_bounds(\n pub fn trait_ref_for_builtin_bound(\n     tcx: &ty::ctxt,\n     builtin_bound: ty::BuiltinBound,\n-    param_ty: ty::t)\n+    param_ty: Ty)\n     -> Option<Rc<ty::TraitRef>>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n@@ -257,7 +257,7 @@ pub fn obligation_for_builtin_bound(\n     cause: ObligationCause,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: uint,\n-    param_ty: ty::t)\n+    param_ty: Ty)\n     -> Result<Obligation, ErrorReported>\n {\n     let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);"}, {"sha": "8a1bbe017f23eb8a4d1e3068d7733adc46b466fb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 272, "deletions": 269, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -223,7 +223,7 @@ pub struct AssociatedType {\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct mt {\n-    pub ty: t,\n+    pub ty: Ty,\n     pub mutbl: ast::Mutability,\n }\n \n@@ -280,7 +280,7 @@ impl<W:Writer> Hash<W> for intern_key {\n \n pub enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n-    atttce_resolved(t)  /* resolved to a type, irrespective of region */\n+    atttce_resolved(Ty)  /* resolved to a type, irrespective of region */\n }\n \n #[deriving(Clone, PartialEq, Decodable, Encodable)]\n@@ -310,7 +310,7 @@ pub enum UnsizeKind {\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n     UnsizeStruct(Box<UnsizeKind>, uint),\n-    UnsizeVtable(TyTrait, /* the self type of the trait */ ty::t)\n+    UnsizeVtable(TyTrait, /* the self type of the trait */ Ty)\n }\n \n #[deriving(Clone, Show)]\n@@ -397,8 +397,8 @@ pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n \n // If possible, returns the type expected from the given adjustment. This is not\n // possible if the adjustment depends on the type of the adjusted expression.\n-pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n-    fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n+pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<Ty> {\n+    fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<Ty> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n                 &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n@@ -414,13 +414,13 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n             },\n             &AutoPtr(r, m, Some(box ref autoref)) => {\n                 match type_of_autoref(cx, autoref) {\n-                    Some(t) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: t})),\n+                    Some(ty) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: ty})),\n                     None => None\n                 }\n             }\n             &AutoUnsafe(m, Some(box ref autoref)) => {\n                 match type_of_autoref(cx, autoref) {\n-                    Some(t) => Some(mk_ptr(cx, mt {mutbl: m, ty: t})),\n+                    Some(ty) => Some(mk_ptr(cx, mt {mutbl: m, ty: ty})),\n                     None => None\n                 }\n             }\n@@ -444,9 +444,9 @@ pub struct TransmuteRestriction {\n     /// The span from whence the restriction comes.\n     pub span: Span,\n     /// The type being transmuted from.\n-    pub from: t,\n+    pub from: Ty,\n     /// The type being transmuted to.\n-    pub to: t,\n+    pub to: Ty,\n     /// NodeIf of the transmute intrinsic.\n     pub id: ast::NodeId,\n }\n@@ -471,7 +471,7 @@ pub struct ctxt<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: RefCell<NodeMap<t>>,\n+    pub node_types: RefCell<NodeMap<Ty>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n@@ -498,18 +498,18 @@ pub struct ctxt<'tcx> {\n     pub object_cast_map: typeck::ObjectCastMap,\n \n     pub map: ast_map::Map<'tcx>,\n-    pub intrinsic_defs: RefCell<DefIdMap<t>>,\n+    pub intrinsic_defs: RefCell<DefIdMap<Ty>>,\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<Polytype>>,\n-    pub rcache: RefCell<FnvHashMap<creader_cache_key, t>>,\n-    pub short_names_cache: RefCell<FnvHashMap<t, String>>,\n-    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<t, bool>>,\n-    pub tc_cache: RefCell<FnvHashMap<t, TypeContents>>,\n+    pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty>>,\n+    pub short_names_cache: RefCell<FnvHashMap<Ty, String>>,\n+    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty, bool>>,\n+    pub tc_cache: RefCell<FnvHashMap<Ty, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n     pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n-    pub normalized_cache: RefCell<FnvHashMap<t, t>>,\n+    pub normalized_cache: RefCell<FnvHashMap<Ty, Ty>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n@@ -641,44 +641,48 @@ impl fmt::Show for TypeFlags {\n // To reduce refcounting cost, we're representing types as unsafe pointers\n // throughout the compiler. These are simply casted t_box values. Use ty::get\n // to cast them back to a box. (Without the cast, compiler performance suffers\n-// ~15%.) This does mean that a t value relies on the ctxt to keep its box\n+// ~15%.) This does mean that a Ty value relies on the ctxt to keep its box\n // alive, and using ty::get is unsafe when the ctxt is no longer alive.\n enum t_opaque {}\n \n #[allow(raw_pointer_deriving)]\n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct t { inner: *const t_opaque }\n+pub struct Ty { inner: *const t_opaque }\n \n-impl fmt::Show for t {\n+impl fmt::Show for Ty {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", get(*self))\n     }\n }\n \n-pub fn get(t: t) -> t_box {\n+pub fn get(ty: Ty) -> t_box {\n     unsafe {\n-        let t2: t_box = mem::transmute(t);\n+        let t2: t_box = mem::transmute(ty);\n         t2\n     }\n }\n \n fn tbox_has_flag(tb: t_box, flag: TypeFlags) -> bool {\n     tb.flags.intersects(flag)\n }\n-pub fn type_has_params(t: t) -> bool {\n-    tbox_has_flag(get(t), HAS_PARAMS)\n+pub fn type_has_params(ty: Ty) -> bool {\n+    tbox_has_flag(get(ty), HAS_PARAMS)\n }\n-pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), HAS_SELF) }\n-pub fn type_has_ty_infer(t: t) -> bool { tbox_has_flag(get(t), HAS_TY_INFER) }\n-pub fn type_needs_infer(t: t) -> bool {\n-    tbox_has_flag(get(t), HAS_TY_INFER | HAS_RE_INFER)\n+pub fn type_has_self(ty: Ty) -> bool {\n+    tbox_has_flag(get(ty), HAS_SELF)\n+}\n+pub fn type_has_ty_infer(ty: Ty) -> bool {\n+    tbox_has_flag(get(ty), HAS_TY_INFER)\n+}\n+pub fn type_needs_infer(ty: Ty) -> bool {\n+    tbox_has_flag(get(ty), HAS_TY_INFER | HAS_RE_INFER)\n }\n \n-pub fn type_has_late_bound_regions(ty: t) -> bool {\n+pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n     get(ty).flags.intersects(HAS_RE_LATE_BOUND)\n }\n \n-pub fn type_has_escaping_regions(t: t) -> bool {\n+pub fn type_has_escaping_regions(ty: Ty) -> bool {\n     /*!\n      * An \"escaping region\" is a bound region whose binder is not part of `t`.\n      *\n@@ -711,11 +715,11 @@ pub fn type_has_escaping_regions(t: t) -> bool {\n      * this processing has not yet been done.\n      */\n \n-    type_escapes_depth(t, 0)\n+    type_escapes_depth(ty, 0)\n }\n \n-pub fn type_escapes_depth(t: t, depth: uint) -> bool {\n-    get(t).region_depth > depth\n+pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n+    get(ty).region_depth > depth\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -737,12 +741,12 @@ pub struct ClosureTy {\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub enum FnOutput {\n-    FnConverging(ty::t),\n+    FnConverging(Ty),\n     FnDiverging\n }\n \n impl FnOutput {\n-    pub fn unwrap(&self) -> ty::t {\n+    pub fn unwrap(&self) -> Ty {\n         match *self {\n             ty::FnConverging(ref t) => *t,\n             ty::FnDiverging => unreachable!()\n@@ -764,7 +768,7 @@ impl FnOutput {\n  */\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig {\n-    pub inputs: Vec<t>,\n+    pub inputs: Vec<Ty>,\n     pub output: FnOutput,\n     pub variadic: bool\n }\n@@ -1073,20 +1077,20 @@ pub enum sty {\n     /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n     /// well.`\n     ty_enum(DefId, Substs),\n-    ty_uniq(t),\n+    ty_uniq(Ty),\n     ty_str,\n-    ty_vec(t, Option<uint>), // Second field is length.\n+    ty_vec(Ty, Option<uint>), // Second field is length.\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n     ty_closure(Box<ClosureTy>),\n     ty_trait(Box<TyTrait>),\n     ty_struct(DefId, Substs),\n     ty_unboxed_closure(DefId, Region, Substs),\n-    ty_tup(Vec<t>),\n+    ty_tup(Vec<Ty>),\n \n     ty_param(ParamTy), // type parameter\n-    ty_open(t),  // A deref'ed fat pointer, i.e., a dynamically sized value\n+    ty_open(Ty), // A deref'ed fat pointer, i.e., a dynamically sized value\n                  // and its size. Only ever used in trans. It is not necessary\n                  // earlier since we don't need to distinguish a DST with its\n                  // size (e.g., in a deref) vs a DST with the size elsewhere (\n@@ -1188,7 +1192,7 @@ pub enum type_err {\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n-    terr_sorts(expected_found<t>),\n+    terr_sorts(expected_found<Ty>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n     terr_float_mismatch(expected_found<ast::FloatTy>),\n@@ -1376,7 +1380,7 @@ pub struct TypeParameterDef {\n     pub index: uint,\n     pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds,\n-    pub default: Option<ty::t>,\n+    pub default: Option<Ty>,\n }\n \n #[deriving(Encodable, Decodable, Clone, Show)]\n@@ -1462,11 +1466,11 @@ impl TraitRef {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n-    pub fn self_ty(&self) -> ty::t {\n+    pub fn self_ty(&self) -> Ty {\n         self.substs.self_ty().unwrap()\n     }\n \n-    pub fn input_types(&self) -> &[ty::t] {\n+    pub fn input_types(&self) -> &[Ty] {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -1638,7 +1642,7 @@ impl ParameterEnvironment {\n #[deriving(Clone, Show)]\n pub struct Polytype {\n     pub generics: Generics,\n-    pub ty: t\n+    pub ty: Ty\n }\n \n /// As `Polytype` but for a trait ref.\n@@ -1768,8 +1772,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n // Type constructors\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n-// and returns the box as cast to an unsafe ptr (see comments for t above).\n-pub fn mk_t(cx: &ctxt, st: sty) -> t {\n+// and returns the box as cast to an unsafe ptr (see comments for Ty above).\n+pub fn mk_t(cx: &ctxt, st: sty) -> Ty {\n     // Check for primitive types.\n     match st {\n         ty_err => return mk_err(),\n@@ -1784,28 +1788,28 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     let key = intern_key { sty: &st };\n \n     match cx.interner.borrow().get(&key) {\n-        Some(t) => unsafe { return mem::transmute(&t.sty); },\n+        Some(ty) => unsafe { return mem::transmute(&ty.sty); },\n         _ => ()\n     }\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let t = cx.type_arena.alloc(t_box_ {\n+    let ty = cx.type_arena.alloc(t_box_ {\n         sty: st,\n         flags: flags.flags,\n         region_depth: flags.depth,\n     });\n \n-    let sty_ptr = &t.sty as *const sty;\n+    let sty_ptr = &ty.sty as *const sty;\n \n     let key = intern_key {\n         sty: sty_ptr,\n     };\n \n-    cx.interner.borrow_mut().insert(key, t);\n+    cx.interner.borrow_mut().insert(key, ty);\n \n     unsafe {\n-        mem::transmute::<*const sty, t>(sty_ptr)\n+        mem::transmute::<*const sty, Ty>(sty_ptr)\n     }\n }\n \n@@ -1938,13 +1942,13 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_ty(&mut self, t: t) {\n-        let t_box = get(t);\n+    fn add_ty(&mut self, ty: Ty) {\n+        let t_box = get(ty);\n         self.add_flags(t_box.flags);\n         self.add_depth(t_box.region_depth);\n     }\n \n-    fn add_tys(&mut self, tys: &[t]) {\n+    fn add_tys(&mut self, tys: &[Ty]) {\n         for &ty in tys.iter() {\n             self.add_ty(ty);\n         }\n@@ -1992,55 +1996,55 @@ impl FlagComputation {\n }\n \n #[inline]\n-pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n+pub fn mk_prim_t(primitive: &'static t_box_) -> Ty {\n     unsafe {\n-        mem::transmute::<&'static t_box_, t>(primitive)\n+        mem::transmute::<&'static t_box_, Ty>(primitive)\n     }\n }\n \n #[inline]\n-pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n+pub fn mk_err() -> Ty { mk_prim_t(&primitives::TY_ERR) }\n \n #[inline]\n-pub fn mk_bool() -> t { mk_prim_t(&primitives::TY_BOOL) }\n+pub fn mk_bool() -> Ty { mk_prim_t(&primitives::TY_BOOL) }\n \n #[inline]\n-pub fn mk_int() -> t { mk_prim_t(&primitives::TY_INT) }\n+pub fn mk_int() -> Ty { mk_prim_t(&primitives::TY_INT) }\n \n #[inline]\n-pub fn mk_i8() -> t { mk_prim_t(&primitives::TY_I8) }\n+pub fn mk_i8() -> Ty { mk_prim_t(&primitives::TY_I8) }\n \n #[inline]\n-pub fn mk_i16() -> t { mk_prim_t(&primitives::TY_I16) }\n+pub fn mk_i16() -> Ty { mk_prim_t(&primitives::TY_I16) }\n \n #[inline]\n-pub fn mk_i32() -> t { mk_prim_t(&primitives::TY_I32) }\n+pub fn mk_i32() -> Ty { mk_prim_t(&primitives::TY_I32) }\n \n #[inline]\n-pub fn mk_i64() -> t { mk_prim_t(&primitives::TY_I64) }\n+pub fn mk_i64() -> Ty { mk_prim_t(&primitives::TY_I64) }\n \n #[inline]\n-pub fn mk_f32() -> t { mk_prim_t(&primitives::TY_F32) }\n+pub fn mk_f32() -> Ty { mk_prim_t(&primitives::TY_F32) }\n \n #[inline]\n-pub fn mk_f64() -> t { mk_prim_t(&primitives::TY_F64) }\n+pub fn mk_f64() -> Ty { mk_prim_t(&primitives::TY_F64) }\n \n #[inline]\n-pub fn mk_uint() -> t { mk_prim_t(&primitives::TY_UINT) }\n+pub fn mk_uint() -> Ty { mk_prim_t(&primitives::TY_UINT) }\n \n #[inline]\n-pub fn mk_u8() -> t { mk_prim_t(&primitives::TY_U8) }\n+pub fn mk_u8() -> Ty { mk_prim_t(&primitives::TY_U8) }\n \n #[inline]\n-pub fn mk_u16() -> t { mk_prim_t(&primitives::TY_U16) }\n+pub fn mk_u16() -> Ty { mk_prim_t(&primitives::TY_U16) }\n \n #[inline]\n-pub fn mk_u32() -> t { mk_prim_t(&primitives::TY_U32) }\n+pub fn mk_u32() -> Ty { mk_prim_t(&primitives::TY_U32) }\n \n #[inline]\n-pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n+pub fn mk_u64() -> Ty { mk_prim_t(&primitives::TY_U64) }\n \n-pub fn mk_mach_int(tm: ast::IntTy) -> t {\n+pub fn mk_mach_int(tm: ast::IntTy) -> Ty {\n     match tm {\n         ast::TyI    => mk_int(),\n         ast::TyI8   => mk_i8(),\n@@ -2050,7 +2054,7 @@ pub fn mk_mach_int(tm: ast::IntTy) -> t {\n     }\n }\n \n-pub fn mk_mach_uint(tm: ast::UintTy) -> t {\n+pub fn mk_mach_uint(tm: ast::UintTy) -> Ty {\n     match tm {\n         ast::TyU    => mk_uint(),\n         ast::TyU8   => mk_u8(),\n@@ -2060,90 +2064,90 @@ pub fn mk_mach_uint(tm: ast::UintTy) -> t {\n     }\n }\n \n-pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n+pub fn mk_mach_float(tm: ast::FloatTy) -> Ty {\n     match tm {\n         ast::TyF32  => mk_f32(),\n         ast::TyF64  => mk_f64(),\n     }\n }\n \n #[inline]\n-pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n+pub fn mk_char() -> Ty { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: &ctxt) -> t {\n+pub fn mk_str(cx: &ctxt) -> Ty {\n     mk_t(cx, ty_str)\n }\n \n-pub fn mk_str_slice(cx: &ctxt, r: Region, m: ast::Mutability) -> t {\n+pub fn mk_str_slice(cx: &ctxt, r: Region, m: ast::Mutability) -> Ty {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_t(cx, ty_str),\n                 mutbl: m\n             })\n }\n \n-pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: Substs) -> t {\n+pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: Substs) -> Ty {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_uniq(cx: &ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n+pub fn mk_uniq(cx: &ctxt, ty: Ty) -> Ty { mk_t(cx, ty_uniq(ty)) }\n \n-pub fn mk_ptr(cx: &ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr(cx: &ctxt, tm: mt) -> Ty { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr(cx: &ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n+pub fn mk_rptr(cx: &ctxt, r: Region, tm: mt) -> Ty { mk_t(cx, ty_rptr(r, tm)) }\n \n-pub fn mk_mut_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n+pub fn mk_mut_rptr(cx: &ctxt, r: Region, ty: Ty) -> Ty {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n+pub fn mk_imm_rptr(cx: &ctxt, r: Region, ty: Ty) -> Ty {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_mut_ptr(cx: &ctxt, ty: t) -> t {\n+pub fn mk_mut_ptr(cx: &ctxt, ty: Ty) -> Ty {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n }\n \n-pub fn mk_imm_ptr(cx: &ctxt, ty: t) -> t {\n+pub fn mk_imm_ptr(cx: &ctxt, ty: Ty) -> Ty {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_nil_ptr(cx: &ctxt) -> t {\n+pub fn mk_nil_ptr(cx: &ctxt) -> Ty {\n     mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, t: t, sz: Option<uint>) -> t {\n-    mk_t(cx, ty_vec(t, sz))\n+pub fn mk_vec(cx: &ctxt, ty: Ty, sz: Option<uint>) -> Ty {\n+    mk_t(cx, ty_vec(ty, sz))\n }\n \n-pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n+pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> Ty {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_vec(cx, tm.ty, None),\n                 mutbl: tm.mutbl\n             })\n }\n \n-pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t {\n+pub fn mk_tup(cx: &ctxt, ts: Vec<Ty>) -> Ty {\n     mk_t(cx, ty_tup(ts))\n }\n \n-pub fn mk_nil(cx: &ctxt) -> t {\n+pub fn mk_nil(cx: &ctxt) -> Ty {\n     mk_tup(cx, Vec::new())\n }\n \n-pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n+pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> Ty {\n     mk_t(cx, ty_closure(box fty))\n }\n \n-pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n+pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> Ty {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n pub fn mk_ctor_fn(cx: &ctxt,\n-                  input_tys: &[ty::t],\n-                  output: ty::t) -> t {\n-    let input_args = input_tys.iter().map(|t| *t).collect();\n+                  input_tys: &[Ty],\n+                  output: Ty) -> Ty {\n+    let input_args = input_tys.iter().map(|ty| *ty).collect();\n     mk_bare_fn(cx,\n                BareFnTy {\n                    fn_style: ast::NormalFn,\n@@ -2160,7 +2164,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n pub fn mk_trait(cx: &ctxt,\n                 principal: ty::TraitRef,\n                 bounds: ExistentialBounds)\n-                -> t {\n+                -> Ty {\n     // take a copy of substs so that we own the vectors inside\n     let inner = box TyTrait {\n         principal: principal,\n@@ -2169,43 +2173,43 @@ pub fn mk_trait(cx: &ctxt,\n     mk_t(cx, ty_trait(inner))\n }\n \n-pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> t {\n+pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> Ty {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId, region: Region, substs: Substs)\n-                          -> t {\n+                          -> Ty {\n     mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n }\n \n-pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n+pub fn mk_var(cx: &ctxt, v: TyVid) -> Ty { mk_infer(cx, TyVar(v)) }\n \n-pub fn mk_int_var(cx: &ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n+pub fn mk_int_var(cx: &ctxt, v: IntVid) -> Ty { mk_infer(cx, IntVar(v)) }\n \n-pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n+pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> Ty { mk_infer(cx, FloatVar(v)) }\n \n-pub fn mk_infer(cx: &ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: &ctxt, it: InferTy) -> Ty { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_param(cx: &ctxt, space: subst::ParamSpace, n: uint, k: DefId) -> t {\n+pub fn mk_param(cx: &ctxt, space: subst::ParamSpace, n: uint, k: DefId) -> Ty {\n     mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n }\n \n-pub fn mk_self_type(cx: &ctxt, did: ast::DefId) -> t {\n+pub fn mk_self_type(cx: &ctxt, did: ast::DefId) -> Ty {\n     mk_param(cx, subst::SelfSpace, 0, did)\n }\n \n-pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> t {\n+pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> Ty {\n     mk_param(cx, def.space, def.index, def.def_id)\n }\n \n-pub fn mk_open(cx: &ctxt, t: t) -> t { mk_t(cx, ty_open(t)) }\n+pub fn mk_open(cx: &ctxt, ty: Ty) -> Ty { mk_t(cx, ty_open(ty)) }\n \n-pub fn walk_ty(ty: t, f: |t|) {\n-    maybe_walk_ty(ty, |t| { f(t); true });\n+pub fn walk_ty(ty: Ty, f: |Ty|) {\n+    maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n-pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n+pub fn maybe_walk_ty(ty: Ty, f: |Ty| -> bool) {\n     if !f(ty) {\n         return;\n     }\n@@ -2245,7 +2249,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: &ctxt, t0: t, fldop: |t| -> t) -> t {\n+pub fn fold_ty(cx: &ctxt, t0: Ty, fldop: |Ty| -> Ty) -> Ty {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n@@ -2266,7 +2270,7 @@ impl ParamTy {\n         ParamTy::new(def.space, def.index, def.def_id)\n     }\n \n-    pub fn to_ty(self, tcx: &ty::ctxt) -> ty::t {\n+    pub fn to_ty(self, tcx: &ty::ctxt) -> Ty {\n         ty::mk_param(tcx, self.space, self.idx, self.def_id)\n     }\n \n@@ -2297,42 +2301,42 @@ impl ParamBounds {\n \n // Type utilities\n \n-pub fn type_is_nil(ty: t) -> bool {\n+pub fn type_is_nil(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_tup(ref tys) => tys.is_empty(),\n         _ => false\n     }\n }\n \n-pub fn type_is_error(ty: t) -> bool {\n+pub fn type_is_error(ty: Ty) -> bool {\n     get(ty).flags.intersects(HAS_TY_ERR)\n }\n \n-pub fn type_needs_subst(ty: t) -> bool {\n+pub fn type_needs_subst(ty: Ty) -> bool {\n     tbox_has_flag(get(ty), NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.types.any(|&t| type_is_error(t))\n+    tref.substs.types.any(|&ty| type_is_error(ty))\n }\n \n-pub fn type_is_ty_var(ty: t) -> bool {\n+pub fn type_is_ty_var(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_infer(TyVar(_)) => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n+pub fn type_is_bool(ty: Ty) -> bool { get(ty).sty == ty_bool }\n \n-pub fn type_is_self(ty: t) -> bool {\n+pub fn type_is_self(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_param(ref p) => p.space == subst::SelfSpace,\n         _ => false\n     }\n }\n \n-fn type_is_slice(ty: t) -> bool {\n+fn type_is_slice(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_ptr(mt) | ty_rptr(_, mt) => match get(mt.ty).sty {\n             ty_vec(_, None) | ty_str => true,\n@@ -2342,34 +2346,34 @@ fn type_is_slice(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_vec(ty: t) -> bool {\n+pub fn type_is_vec(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_vec(..) => true,\n-        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n-        ty_uniq(t) => match get(t).sty {\n+        ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..}) |\n+        ty_uniq(ty) => match get(ty).sty {\n             ty_vec(_, None) => true,\n             _ => false\n         },\n         _ => false\n     }\n }\n \n-pub fn type_is_structural(ty: t) -> bool {\n+pub fn type_is_structural(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) |\n       ty_vec(_, Some(_)) | ty_unboxed_closure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n \n-pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n+pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n     }\n }\n \n-pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n+pub fn sequence_element_type(cx: &ctxt, ty: Ty) -> Ty {\n     match get(ty).sty {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(ast::TyU8),\n@@ -2379,7 +2383,7 @@ pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     }\n }\n \n-pub fn simd_type(cx: &ctxt, ty: t) -> t {\n+pub fn simd_type(cx: &ctxt, ty: Ty) -> Ty {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -2389,7 +2393,7 @@ pub fn simd_type(cx: &ctxt, ty: t) -> t {\n     }\n }\n \n-pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n+pub fn simd_size(cx: &ctxt, ty: Ty) -> uint {\n     match get(ty).sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -2399,21 +2403,21 @@ pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n     }\n }\n \n-pub fn type_is_region_ptr(ty: t) -> bool {\n+pub fn type_is_region_ptr(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_rptr(..) => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_unsafe_ptr(ty: t) -> bool {\n+pub fn type_is_unsafe_ptr(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pub fn type_is_unique(ty: t) -> bool {\n+pub fn type_is_unique(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) => match get(ty).sty {\n             ty_trait(..) => false,\n@@ -2423,7 +2427,7 @@ pub fn type_is_unique(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n+pub fn type_is_fat_ptr(cx: &ctxt, ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n         | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n@@ -2436,7 +2440,7 @@ pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n  contents are abstract to rustc.)\n */\n-pub fn type_is_scalar(ty: t) -> bool {\n+pub fn type_is_scalar(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n@@ -2447,27 +2451,27 @@ pub fn type_is_scalar(ty: t) -> bool {\n }\n \n /// Returns true if this type is a floating point type and false otherwise.\n-pub fn type_is_floating_point(ty: t) -> bool {\n+pub fn type_is_floating_point(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_float(_) => true,\n         _ => false,\n     }\n }\n \n-pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n+pub fn type_needs_drop(cx: &ctxt, ty: Ty) -> bool {\n     type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n+pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: Ty) -> bool {\n     return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n         type_needs_unwind_cleanup_(cx, ty, &mut FnvHashSet::new())\n     });\n \n-    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut FnvHashSet<t>) -> bool {\n+    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: Ty, tycache: &mut FnvHashSet<Ty>) -> bool {\n         // Prevent infinite recursion\n         if !tycache.insert(ty) {\n             return false;\n@@ -2651,7 +2655,7 @@ impl TypeContents {\n     }\n \n     pub fn union<T>(v: &[T], f: |&T| -> TypeContents) -> TypeContents {\n-        v.iter().fold(TC::None, |tc, t| tc | f(t))\n+        v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n \n     pub fn has_dtor(&self) -> bool {\n@@ -2683,18 +2687,18 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).interior_unsafe()\n+pub fn type_interior_is_unsafe(cx: &ctxt, ty: Ty) -> bool {\n+    type_contents(cx, ty).interior_unsafe()\n }\n \n-pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n+pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n     return memoized(&cx.tc_cache, ty, |ty| {\n         tc_ty(cx, ty, &mut FnvHashMap::new())\n     });\n \n     fn tc_ty(cx: &ctxt,\n-             ty: t,\n-             cache: &mut FnvHashMap<t, TypeContents>) -> TypeContents\n+             ty: Ty,\n+             cache: &mut FnvHashMap<Ty, TypeContents>) -> TypeContents\n     {\n         // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n         // private cache for this walk.  This is needed in the case of cyclic\n@@ -2767,12 +2771,12 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_vec(t, Some(_)) => {\n-                tc_ty(cx, t, cache)\n+            ty_vec(ty, Some(_)) => {\n+                tc_ty(cx, ty, cache)\n             }\n \n-            ty_vec(t, None) => {\n-                tc_ty(cx, t, cache) | TC::Nonsized\n+            ty_vec(ty, None) => {\n+                tc_ty(cx, ty, cache) | TC::Nonsized\n             }\n             ty_str => TC::Nonsized,\n \n@@ -2884,8 +2888,8 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 TC::All\n             }\n \n-            ty_open(t) => {\n-                let result = tc_ty(cx, t, cache);\n+            ty_open(ty) => {\n+                let result = tc_ty(cx, ty, cache);\n                 assert!(!result.is_sized(cx))\n                 result.unsafe_pointer() | TC::Nonsized\n             }\n@@ -2901,7 +2905,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n     fn tc_mt(cx: &ctxt,\n              mt: mt,\n-             cache: &mut FnvHashMap<t, TypeContents>) -> TypeContents\n+             cache: &mut FnvHashMap<Ty, TypeContents>) -> TypeContents\n     {\n         let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n         mc | tc_ty(cx, mt.ty, cache)\n@@ -3005,18 +3009,18 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     }\n }\n \n-pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n+pub fn type_moves_by_default(cx: &ctxt, ty: Ty) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n-pub fn is_ffi_safe(cx: &ctxt, ty: t) -> bool {\n+pub fn is_ffi_safe(cx: &ctxt, ty: Ty) -> bool {\n     !type_contents(cx, ty).intersects(TC::ReachesFfiUnsafe)\n }\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n+pub fn is_instantiable(cx: &ctxt, r_ty: Ty) -> bool {\n     fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n-                     r_ty: t, ty: t) -> bool {\n+                     r_ty: Ty, ty: Ty) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n@@ -3034,7 +3038,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n     }\n \n     fn subtypes_require(cx: &ctxt, seen: &mut Vec<DefId>,\n-                        r_ty: t, ty: t) -> bool {\n+                        r_ty: Ty, ty: Ty) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n@@ -3093,7 +3097,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             }\n \n             ty_tup(ref ts) => {\n-                ts.iter().any(|t| type_requires(cx, seen, r_ty, *t))\n+                ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n             }\n \n             ty_enum(ref did, _) if seen.contains(did) => {\n@@ -3143,20 +3147,20 @@ pub enum Representability {\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n+pub fn is_type_representable(cx: &ctxt, sp: Span, ty: Ty) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, sp: Span, seen: &mut Vec<t>,\n+    fn find_nonrepresentable<It: Iterator<Ty>>(cx: &ctxt, sp: Span, seen: &mut Vec<Ty>,\n                                               mut iter: It) -> Representability {\n         iter.fold(Representable,\n                   |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n     }\n \n     fn are_inner_types_recursive(cx: &ctxt, sp: Span,\n-                                 seen: &mut Vec<t>, ty: t) -> Representability {\n+                                 seen: &mut Vec<Ty>, ty: Ty) -> Representability {\n         match get(ty).sty {\n             ty_tup(ref ts) => {\n-                find_nonrepresentable(cx, sp, seen, ts.iter().map(|t| *t))\n+                find_nonrepresentable(cx, sp, seen, ts.iter().map(|ty| *ty))\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n@@ -3183,7 +3187,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n         }\n     }\n \n-    fn same_struct_or_enum_def_id(ty: t, did: DefId) -> bool {\n+    fn same_struct_or_enum_def_id(ty: Ty, did: DefId) -> bool {\n         match get(ty).sty {\n             ty_struct(ty_did, _) | ty_enum(ty_did, _) => {\n                  ty_did == did\n@@ -3192,7 +3196,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n         }\n     }\n \n-    fn same_type(a: t, b: t) -> bool {\n+    fn same_type(a: Ty, b: Ty) -> bool {\n         match (&get(a).sty, &get(b).sty) {\n             (&ty_struct(did_a, ref substs_a), &ty_struct(did_b, ref substs_b)) |\n             (&ty_enum(did_a, ref substs_a), &ty_enum(did_b, ref substs_b)) => {\n@@ -3215,8 +3219,8 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn is_type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<t>,\n-                                      ty: t) -> Representability {\n+    fn is_type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<Ty>,\n+                                      ty: Ty) -> Representability {\n         debug!(\"is_type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_string(cx, ty));\n \n@@ -3285,18 +3289,18 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n-    let mut seen: Vec<t> = Vec::new();\n+    let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n     debug!(\"is_type_representable: {} is {}\",\n            ::util::ppaux::ty_to_string(cx, ty), r);\n     r\n }\n \n-pub fn type_is_trait(ty: t) -> bool {\n+pub fn type_is_trait(ty: Ty) -> bool {\n     type_trait_info(ty).is_some()\n }\n \n-pub fn type_trait_info(ty: t) -> Option<&'static TyTrait> {\n+pub fn type_trait_info(ty: Ty) -> Option<&'static TyTrait> {\n     match get(ty).sty {\n         ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n             ty_trait(ref t) => Some(&**t),\n@@ -3307,61 +3311,61 @@ pub fn type_trait_info(ty: t) -> Option<&'static TyTrait> {\n     }\n }\n \n-pub fn type_is_integral(ty: t) -> bool {\n+pub fn type_is_integral(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) => true,\n       _ => false\n     }\n }\n \n-pub fn type_is_skolemized(ty: t) -> bool {\n+pub fn type_is_skolemized(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_infer(SkolemizedTy(_)) => true,\n       ty_infer(SkolemizedIntTy(_)) => true,\n       _ => false\n     }\n }\n \n-pub fn type_is_uint(ty: t) -> bool {\n+pub fn type_is_uint(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n       _ => false\n     }\n }\n \n-pub fn type_is_char(ty: t) -> bool {\n+pub fn type_is_char(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_char => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_bare_fn(ty: t) -> bool {\n+pub fn type_is_bare_fn(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_bare_fn(..) => true,\n         _ => false\n     }\n }\n \n-pub fn type_is_fp(ty: t) -> bool {\n+pub fn type_is_fp(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_infer(FloatVar(_)) | ty_float(_) => true,\n       _ => false\n     }\n }\n \n-pub fn type_is_numeric(ty: t) -> bool {\n+pub fn type_is_numeric(ty: Ty) -> bool {\n     return type_is_integral(ty) || type_is_fp(ty);\n }\n \n-pub fn type_is_signed(ty: t) -> bool {\n+pub fn type_is_signed(ty: Ty) -> bool {\n     match get(ty).sty {\n       ty_int(_) => true,\n       _ => false\n     }\n }\n \n-pub fn type_is_machine(ty: t) -> bool {\n+pub fn type_is_machine(ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_int(ast::TyI) | ty_uint(ast::TyU) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n@@ -3370,21 +3374,21 @@ pub fn type_is_machine(ty: t) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-pub fn type_is_sized(cx: &ctxt, ty: t) -> bool {\n+pub fn type_is_sized(cx: &ctxt, ty: Ty) -> bool {\n     type_contents(cx, ty).is_sized(cx)\n }\n \n-pub fn lltype_is_sized(cx: &ctxt, ty: t) -> bool {\n+pub fn lltype_is_sized(cx: &ctxt, ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_open(_) => true,\n         _ => type_contents(cx, ty).is_sized(cx)\n     }\n }\n \n-// Return the smallest part of t which is unsized. Fails if t is sized.\n+// Return the smallest part of ty which is unsized. Fails if ty is sized.\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n-pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n+pub fn unsized_part_of_type(cx: &ctxt, ty: Ty) -> Ty {\n     match get(ty).sty {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n         ty_struct(def_id, ref substs) => {\n@@ -3405,7 +3409,7 @@ pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n \n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n-pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n+pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n     match get(ty).sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n@@ -3419,12 +3423,12 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-// Returns the type and mutability of *t.\n+// Returns the type and mutability of *ty.\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-pub fn deref(t: t, explicit: bool) -> Option<mt> {\n-    match get(t).sty {\n+pub fn deref(ty: Ty, explicit: bool) -> Option<mt> {\n+    match get(ty).sty {\n         ty_uniq(ty) => {\n             Some(mt {\n                 ty: ty,\n@@ -3437,83 +3441,82 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     }\n }\n \n-pub fn deref_or_dont(t: t) -> t {\n-    match get(t).sty {\n+pub fn deref_or_dont(ty: Ty) -> Ty {\n+    match get(ty).sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n-        _ => t\n+        _ => ty\n     }\n }\n \n-pub fn close_type(cx: &ctxt, t: t) -> t {\n-    match get(t).sty {\n-        ty_open(t) => mk_rptr(cx, ReStatic, mt {ty: t, mutbl:ast::MutImmutable}),\n+pub fn close_type(cx: &ctxt, ty: Ty) -> Ty {\n+    match get(ty).sty {\n+        ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, t)).as_slice())\n+                                 ty_to_string(cx, ty)).as_slice())\n     }\n }\n \n-pub fn type_content(t: t) -> t {\n-    match get(t).sty {\n+pub fn type_content(ty: Ty) -> Ty {\n+    match get(ty).sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n-        _ => t\n+        _ => ty\n     }\n-\n }\n \n-// Extract the unsized type in an open type (or just return t if it is not open).\n-pub fn unopen_type(t: t) -> t {\n-    match get(t).sty {\n-        ty_open(t) => t,\n-        _ => t\n+// Extract the unsized type in an open type (or just return ty if it is not open).\n+pub fn unopen_type(ty: Ty) -> Ty {\n+    match get(ty).sty {\n+        ty_open(ty) => ty,\n+        _ => ty\n     }\n }\n \n-// Returns the type of t[i]\n-pub fn index(ty: t) -> Option<t> {\n+// Returns the type of ty[i]\n+pub fn index(ty: Ty) -> Option<Ty> {\n     match get(ty).sty {\n-        ty_vec(t, _) => Some(t),\n+        ty_vec(ty, _) => Some(ty),\n         _ => None\n     }\n }\n \n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty(t: t) -> Option<t> {\n-    match get(t).sty {\n-        ty_vec(t, _) => Some(t),\n+pub fn array_element_ty(ty: Ty) -> Option<Ty> {\n+    match get(ty).sty {\n+        ty_vec(ty, _) => Some(ty),\n         ty_str => Some(mk_u8()),\n         _ => None\n     }\n }\n \n pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n     match cx.trait_refs.borrow().get(&id) {\n-        Some(t) => t.clone(),\n+        Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n                     cx.map.node_to_string(id)).as_slice())\n     }\n }\n \n-pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<Ty> {\n     cx.node_types.borrow().get(&id).cloned()\n }\n \n-pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n+pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Ty {\n     match try_node_id_to_type(cx, id) {\n-       Some(t) => t,\n+       Some(ty) => ty,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n                    cx.map.node_to_string(id)).as_slice())\n     }\n }\n \n-pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<Ty> {\n     match cx.node_types.borrow().get(&id) {\n-       Some(&t) => Some(t),\n+       Some(&ty) => Some(ty),\n        None => None\n     }\n }\n@@ -3525,7 +3528,7 @@ pub fn node_id_item_substs(cx: &ctxt, id: ast::NodeId) -> ItemSubsts {\n     }\n }\n \n-pub fn fn_is_variadic(fty: t) -> bool {\n+pub fn fn_is_variadic(fty: Ty) -> bool {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.variadic,\n         ty_closure(ref f) => f.sig.variadic,\n@@ -3535,7 +3538,7 @@ pub fn fn_is_variadic(fty: t) -> bool {\n     }\n }\n \n-pub fn ty_fn_sig(fty: t) -> FnSig {\n+pub fn ty_fn_sig(fty: Ty) -> FnSig {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n@@ -3546,7 +3549,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n }\n \n /// Returns the ABI of the given function.\n-pub fn ty_fn_abi(fty: t) -> abi::Abi {\n+pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.abi,\n         ty_closure(ref f) => f.abi,\n@@ -3555,7 +3558,7 @@ pub fn ty_fn_abi(fty: t) -> abi::Abi {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args(fty: t) -> Vec<t> {\n+pub fn ty_fn_args(fty: Ty) -> Vec<Ty> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n@@ -3565,7 +3568,7 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n     }\n }\n \n-pub fn ty_closure_store(fty: t) -> TraitStore {\n+pub fn ty_closure_store(fty: Ty) -> TraitStore {\n     match get(fty).sty {\n         ty_closure(ref f) => f.store,\n         ty_unboxed_closure(..) => {\n@@ -3579,7 +3582,7 @@ pub fn ty_closure_store(fty: t) -> TraitStore {\n     }\n }\n \n-pub fn ty_fn_ret(fty: t) -> FnOutput {\n+pub fn ty_fn_ret(fty: Ty) -> FnOutput {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n@@ -3589,7 +3592,7 @@ pub fn ty_fn_ret(fty: t) -> FnOutput {\n     }\n }\n \n-pub fn is_fn_ty(fty: t) -> bool {\n+pub fn is_fn_ty(fty: Ty) -> bool {\n     match get(fty).sty {\n         ty_bare_fn(_) => true,\n         ty_closure(_) => true,\n@@ -3599,7 +3602,7 @@ pub fn is_fn_ty(fty: t) -> bool {\n \n pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n-                 ty: t) -> Region {\n+                 ty: Ty) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n         ref s => {\n@@ -3621,7 +3624,7 @@ pub fn free_region_from_def(free_id: ast::NodeId, def: &RegionParameterDef)\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n+pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> Ty {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -3635,16 +3638,16 @@ pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n //\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(t) -> T with T = int\".\n-pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> t {\n+// instead of \"fn(ty) -> T with T = int\".\n+pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> Ty {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<t> {\n+pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<Ty> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> t {\n+pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> Ty {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -3706,10 +3709,10 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n pub fn adjust_ty(cx: &ctxt,\n                  span: Span,\n                  expr_id: ast::NodeId,\n-                 unadjusted_ty: ty::t,\n+                 unadjusted_ty: Ty,\n                  adjustment: Option<&AutoAdjustment>,\n-                 method_type: |typeck::MethodCall| -> Option<ty::t>)\n-                 -> ty::t {\n+                 method_type: |typeck::MethodCall| -> Option<Ty>)\n+                 -> Ty {\n     /*! See `expr_ty_adjusted` */\n \n     match get(unadjusted_ty).sty {\n@@ -3785,9 +3788,9 @@ pub fn adjust_ty(cx: &ctxt,\n \n pub fn adjust_ty_for_autoref(cx: &ctxt,\n                              span: Span,\n-                             ty: ty::t,\n+                             ty: Ty,\n                              autoref: Option<&AutoRef>)\n-                             -> ty::t\n+                             -> Ty\n {\n     match autoref {\n         None => ty,\n@@ -3820,15 +3823,15 @@ pub fn adjust_ty_for_autoref(cx: &ctxt,\n // Take a sized type and a sizing adjustment and produce an unsized version of\n // the type.\n pub fn unsize_ty(cx: &ctxt,\n-                 ty: ty::t,\n+                 ty: Ty,\n                  kind: &UnsizeKind,\n                  span: Span)\n-                 -> ty::t {\n+                 -> Ty {\n     match kind {\n         &UnsizeLength(len) => match get(ty).sty {\n-            ty_vec(t, Some(n)) => {\n+            ty_vec(ty, Some(n)) => {\n                 assert!(len == n);\n-                mk_vec(cx, t, None)\n+                mk_vec(cx, ty, None)\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n@@ -3991,8 +3994,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprCast(..) => {\n             match tcx.node_types.borrow().get(&expr.id) {\n-                Some(&t) => {\n-                    if type_is_trait(t) {\n+                Some(&ty) => {\n+                    if type_is_trait(ty) {\n                         RvalueDpsExpr\n                     } else {\n                         RvalueDatumExpr\n@@ -4084,13 +4087,13 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n-pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n-    match get(t).sty {\n+pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n+    match get(ty).sty {\n         ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n-            ::util::ppaux::ty_to_string(cx, t)\n+            ::util::ppaux::ty_to_string(cx, ty)\n         }\n-        ty_tup(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, t),\n+        ty_tup(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, ty),\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_uniq(_) => \"box\".to_string(),\n@@ -4521,7 +4524,7 @@ pub fn try_add_builtin_trait(\n     }\n }\n \n-pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n+pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match get(ty).sty {\n         ty_trait(ref tt) =>\n             Some(tt.principal.def_id),\n@@ -4537,9 +4540,9 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n // Enum information\n #[deriving(Clone)]\n pub struct VariantInfo {\n-    pub args: Vec<t>,\n-    pub arg_names: Option<Vec<ast::Ident> >,\n-    pub ctor_ty: Option<t>,\n+    pub args: Vec<Ty>,\n+    pub arg_names: Option<Vec<ast::Ident>>,\n+    pub ctor_ty: Option<Ty>,\n     pub name: ast::Name,\n     pub id: ast::DefId,\n     pub disr_val: Disr,\n@@ -4676,8 +4679,8 @@ pub fn enum_is_univariant(cx: &ctxt, id: ast::DefId) -> bool {\n     enum_variants(cx, id).len() == 1\n }\n \n-pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n-    match ty::get(t).sty {\n+pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n+    match ty::get(ty).sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n@@ -4944,8 +4947,8 @@ pub fn lookup_field_type(tcx: &ctxt,\n                          struct_id: DefId,\n                          id: DefId,\n                          substs: &Substs)\n-                      -> ty::t {\n-    let t = if id.krate == ast::LOCAL_CRATE {\n+                      -> Ty {\n+    let ty = if id.krate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n@@ -4955,7 +4958,7 @@ pub fn lookup_field_type(tcx: &ctxt,\n         };\n         pty.ty\n     };\n-    t.subst(tcx, substs)\n+    ty.subst(tcx, substs)\n }\n \n // Look up the list of field names and IDs for a given struct.\n@@ -4998,7 +5001,7 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n \n // Returns a list of fields corresponding to the tuple's items. trans uses\n // this.\n-pub fn tup_fields(v: &[t]) -> Vec<field> {\n+pub fn tup_fields(v: &[Ty]) -> Vec<field> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n             name: token::intern(i.to_string().as_slice()),\n@@ -5013,7 +5016,7 @@ pub fn tup_fields(v: &[t]) -> Vec<field> {\n pub struct UnboxedClosureUpvar {\n     pub def: def::Def,\n     pub span: Span,\n-    pub ty: t,\n+    pub ty: Ty,\n }\n \n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n@@ -5053,7 +5056,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     }\n }\n \n-pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n+pub fn is_binopable(cx: &ctxt, ty: Ty, op: ast::BinOp) -> bool {\n     #![allow(non_upper_case_globals)]\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n@@ -5095,7 +5098,7 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n         }\n     }\n \n-    fn tycat(cx: &ctxt, ty: t) -> int {\n+    fn tycat(cx: &ctxt, ty: Ty) -> int {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -5126,23 +5129,23 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n-    let u = TypeNormalizer(cx).fold_ty(t);\n+pub fn normalize_ty(cx: &ctxt, ty: Ty) -> Ty {\n+    let u = TypeNormalizer(cx).fold_ty(ty);\n     return u;\n \n     struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n \n     impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n         fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n-        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            match self.tcx().normalized_cache.borrow().get(&t).cloned() {\n+        fn fold_ty(&mut self, ty: Ty) -> Ty {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n                 None => {}\n                 Some(u) => return u\n             }\n \n-            let t_norm = ty_fold::super_fold_ty(self, t);\n-            self.tcx().normalized_cache.borrow_mut().insert(t, t_norm);\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n             return t_norm;\n         }\n \n@@ -5285,7 +5288,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n     }\n }\n \n-pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n+pub fn get_tydesc_ty(tcx: &ctxt) -> Result<Ty, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n             .expect(\"Failed to resolve TyDesc\")\n@@ -5491,9 +5494,9 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n     }\n }\n \n-/// Creates a hash of the type `t` which will be the same no matter what crate\n+/// Creates a hash of the type `Ty` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n+pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n@@ -5524,8 +5527,8 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     let mt = |state: &mut sip::SipState, mt: mt| {\n         mt.mutbl.hash(state);\n     };\n-    ty::walk_ty(t, |t| {\n-        match ty::get(t).sty {\n+    ty::walk_ty(ty, |ty| {\n+        match ty::get(ty).sty {\n             ty_bool => byte!(2),\n             ty_char => byte!(3),\n             ty_int(i) => {\n@@ -5723,7 +5726,7 @@ pub fn construct_parameter_environment(\n     }\n \n     fn push_types_from_defs(tcx: &ty::ctxt,\n-                            types: &mut subst::VecPerParamSpace<ty::t>,\n+                            types: &mut subst::VecPerParamSpace<Ty>,\n                             space: subst::ParamSpace,\n                             defs: &[TypeParameterDef]) {\n         for (i, def) in defs.iter().enumerate() {\n@@ -5810,11 +5813,11 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n         Ok(ty::node_id_to_type(self, id))\n     }\n \n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty> {\n         self.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n@@ -5859,9 +5862,9 @@ pub enum ExplicitSelfCategory {\n /// in a list of type substitutions. This does *not* traverse into nominal\n /// types, nor does it resolve fictitious types.\n pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n-                                    typ: t) {\n-    walk_ty(typ, |typ| {\n-        match get(typ).sty {\n+                                    ty: Ty) {\n+    walk_ty(ty, |ty| {\n+        match get(ty).sty {\n             ty_rptr(region, _) => {\n                 accumulator.push(region)\n             }"}, {"sha": "e09cf55437c389e00719f6d26919e5705119c1c6", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -38,7 +38,7 @@\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n@@ -73,7 +73,7 @@ pub trait TypeFolder<'tcx> {\n     /// track the Debruijn index nesting level.\n     fn exit_region_binder(&mut self) { }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         super_fold_ty(self, t)\n     }\n \n@@ -231,8 +231,8 @@ impl TypeFoldable for ty::TraitStore {\n     }\n }\n \n-impl TypeFoldable for ty::t {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::t {\n+impl TypeFoldable for Ty {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty {\n         folder.fold_ty(*self)\n     }\n }\n@@ -487,8 +487,8 @@ impl TypeFoldable for traits::VtableParamData {\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                t: ty::t)\n-                                                -> ty::t {\n+                                                t: Ty)\n+                                                -> Ty {\n     let sty = ty::get(t).sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n@@ -736,13 +736,13 @@ impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n \n pub struct BottomUpFolder<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub fldop: |ty::t|: 'a -> ty::t,\n+    pub fldop: |Ty|: 'a -> Ty,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, ty: Ty) -> Ty {\n         let t1 = super_fold_ty(self, ty);\n         (self.fldop)(t1)\n     }\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// Folds over the substructure of a type, visiting its component\n /// types and all regions that occur *free* within it.\n ///\n-/// That is, `ty::t` can contain function or method types that bind\n+/// That is, `Ty` can contain function or method types that bind\n /// regions at the call site (`ReLateBound`), and occurrences of\n /// regions (aka \"lifetimes\") that are bound within a type are not\n /// visited by this folder; only regions that occur free will be"}, {"sha": "b3e2c88ef63b40b7d69cd9f6513626bc63aeb451", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -53,7 +53,7 @@ use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n                              ShiftedRscope, BindingRscope};\n@@ -75,22 +75,22 @@ pub trait AstConv<'tcx> {\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self, span: Span) -> ty::t;\n+    fn ty_infer(&self, span: Span) -> Ty;\n \n     /// Returns true if associated types from the given trait and type are\n     /// allowed to be used here and false otherwise.\n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool;\n \n     /// Returns the binding of the given associated type for some type.\n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t;\n+                               -> Ty;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -206,8 +206,8 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n-    self_ty: Option<ty::t>,\n-    associated_ty: Option<ty::t>,\n+    self_ty: Option<Ty>,\n+    associated_ty: Option<Ty>,\n     path: &ast::Path)\n     -> Substs\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -252,10 +252,10 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     span: Span,\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n-    self_ty: Option<ty::t>,\n-    types: Vec<ty::t>,\n+    self_ty: Option<Ty>,\n+    types: Vec<Ty>,\n     regions: Vec<ty::Region>,\n-    associated_ty: Option<ty::t>)\n+    associated_ty: Option<Ty>)\n     -> Substs\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -377,7 +377,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>, Vec<ty::t>)\n+                                                    -> (Vec<ty::Region>, Vec<Ty>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -395,7 +395,7 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n \n fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                                              data: &ast::ParenthesizedParameterData)\n-                                             -> Vec<ty::t>\n+                                             -> Vec<Ty>\n     where AC: AstConv<'tcx>\n {\n     let binding_rscope = BindingRscope::new();\n@@ -417,8 +417,8 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<ty::t>,\n-    associated_type: Option<ty::t>)\n+    self_ty: Option<Ty>,\n+    associated_type: Option<Ty>)\n     -> Rc<ty::TraitRef>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -428,8 +428,8 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<ty::t>,\n-                                         associated_type: Option<ty::t>)\n+                                         self_ty: Option<Ty>,\n+                                         associated_type: Option<Ty>)\n                                          -> Rc<ty::TraitRef>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n@@ -462,8 +462,8 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n-    self_ty: Option<ty::t>,\n-    associated_type: Option<ty::t>,\n+    self_ty: Option<Ty>,\n+    associated_type: Option<Ty>,\n     path: &ast::Path)\n     -> ty::TraitRef\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -589,7 +589,7 @@ fn check_path_args(tcx: &ty::ctxt,\n     }\n }\n \n-pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n+pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<Ty> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -641,7 +641,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         ast_ty: &ast::Ty)\n-        -> Option<ty::t> {\n+        -> Option<Ty> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n         Some(typ) => return Some(typ),\n         None => {}\n@@ -697,8 +697,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_mutbl: ast::Mutability,\n         a_seq_ty: &ast::Ty,\n         region: ty::Region,\n-        constr: |ty::t| -> ty::t)\n-        -> ty::t\n+        constr: |Ty| -> Ty)\n+        -> Ty\n {\n     let tcx = this.tcx();\n \n@@ -755,7 +755,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    for_ast_type: &ast::Ty,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n-                                   -> ty::t\n+                                   -> Ty\n                                    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n@@ -811,7 +811,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1060,8 +1060,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n                                                            a: &ast::Arg,\n-                                                           expected_ty: Option<ty::t>)\n-                                                           -> ty::t {\n+                                                           expected_ty: Option<Ty>)\n+                                                           -> Ty {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -1070,14 +1070,14 @@ pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &R\n }\n \n struct SelfInfo<'a> {\n-    untransformed_self_ty: ty::t,\n+    untransformed_self_ty: Ty,\n     explicit_self: &'a ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     fn_style: ast::FnStyle,\n-                    untransformed_self_ty: ty::t,\n+                    untransformed_self_ty: Ty,\n                     explicit_self: &ast::ExplicitSelf,\n                     decl: &ast::FnDecl,\n                     abi: abi::Abi)\n@@ -1163,7 +1163,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     let input_pats: Vec<String> = input_params.iter()\n                                               .map(|a| pprust::pat_to_string(&*a.pat))\n                                               .collect();\n-    let self_and_input_tys: Vec<ty::t> =\n+    let self_and_input_tys: Vec<Ty> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n     let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n@@ -1302,7 +1302,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n         }\n     };\n \n-    fn count_modifiers(ty: ty::t) -> uint {\n+    fn count_modifiers(ty: Ty) -> uint {\n         match ty::get(ty).sty {\n             ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n             ty::ty_uniq(t) => count_modifiers(t) + 1,\n@@ -1402,7 +1402,7 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     rscope: &RS,\n     span: Span,\n     ast_bounds: &[ast::TyParamBound])\n-    -> ty::t\n+    -> Ty\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let ast_bounds: Vec<&ast::TyParamBound> = ast_bounds.iter().collect();"}, {"sha": "17b2e51a42807b41a1ffadfa26b8c59359c98d4d", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -11,7 +11,7 @@\n use middle::def;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Subst, Substs};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::{check_expr, check_expr_has_type, demand, FnCtxt};\n use middle::typeck::check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use middle::typeck::infer::{mod, resolve};\n@@ -27,7 +27,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n+pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: Ty) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -207,7 +207,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     }\n }\n \n-pub fn check_dereferencable(pcx: &pat_ctxt, span: Span, expected: ty::t,\n+pub fn check_dereferencable(pcx: &pat_ctxt, span: Span, expected: Ty,\n                             inner: &ast::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -292,7 +292,7 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n \n pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n                         path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n-                        etc: bool, expected: ty::t) {\n+                        etc: bool, expected: Ty) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -351,7 +351,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n \n pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n                       path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n-                      expected: ty::t) {\n+                      expected: Ty) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;"}, {"sha": "4d31275e45dbf385173702ad3f03077676fcf1b5", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::FnCtxt;\n use middle::typeck::infer;\n use middle::typeck::infer::resolve_type;\n@@ -23,22 +23,22 @@ use util::ppaux::Repr;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn subtype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n pub fn suptype_with_fn(fcx: &FnCtxt,\n                        sp: Span,\n                        b_is_expected: bool,\n-                       ty_a: ty::t,\n-                       ty_b: ty::t,\n-                       handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n+                       ty_a: Ty,\n+                       ty_b: Ty,\n+                       handle_err: |Span, Ty, Ty, &ty::type_err|) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n@@ -49,7 +49,7 @@ pub fn suptype_with_fn(fcx: &FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -59,7 +59,7 @@ pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n+pub fn coerce(fcx: &FnCtxt, sp: Span, expected: Ty, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),"}, {"sha": "9c138499b424ae80e19e095652ef62a3fc0dfea1", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,7 +13,7 @@ use super::probe;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n@@ -57,9 +57,9 @@ struct InstantiatedMethodSig {\n pub fn confirm(fcx: &FnCtxt,\n                span: Span,\n                self_expr: &ast::Expr,\n-               unadjusted_self_ty: ty::t,\n+               unadjusted_self_ty: Ty,\n                pick: probe::Pick,\n-               supplied_method_types: Vec<ty::t>)\n+               supplied_method_types: Vec<Ty>)\n                -> MethodCallee\n {\n     debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n@@ -81,9 +81,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn confirm(&mut self,\n-               unadjusted_self_ty: ty::t,\n+               unadjusted_self_ty: Ty,\n                pick: probe::Pick,\n-               supplied_method_types: Vec<ty::t>)\n+               supplied_method_types: Vec<Ty>)\n                -> MethodCallee\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n@@ -136,9 +136,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     // ADJUSTMENTS\n \n     fn adjust_self_ty(&mut self,\n-                      unadjusted_self_ty: ty::t,\n+                      unadjusted_self_ty: Ty,\n                       adjustment: &probe::PickAdjustment)\n-                      -> ty::t\n+                      -> Ty\n     {\n         // Construct the actual adjustment and write it into the table\n         let auto_deref_ref = self.create_ty_adjustment(adjustment);\n@@ -191,7 +191,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     //\n \n     fn fresh_receiver_substs(&mut self,\n-                             self_ty: ty::t,\n+                             self_ty: Ty,\n                              pick: &probe::Pick)\n                              -> (subst::Substs, MethodOrigin)\n     {\n@@ -292,8 +292,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn extract_trait_ref<R>(&mut self,\n-                            self_ty: ty::t,\n-                            closure: |&mut ConfirmContext<'a,'tcx>, ty::t, &ty::TyTrait| -> R)\n+                            self_ty: Ty,\n+                            closure: |&mut ConfirmContext<'a,'tcx>, Ty, &ty::TyTrait| -> R)\n                             -> R\n     {\n         // If we specified that this is an object method, then the\n@@ -324,8 +324,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick,\n-                                 supplied_method_types: Vec<ty::t>)\n-                                 -> (Vec<ty::t>, Vec<ty::Region>)\n+                                 supplied_method_types: Vec<Ty>)\n+                                 -> (Vec<Ty>, Vec<ty::Region>)\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -361,8 +361,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn unify_receivers(&mut self,\n-                       self_ty: ty::t,\n-                       method_self_ty: ty::t)\n+                       self_ty: Ty,\n+                       method_self_ty: Ty)\n     {\n         match self.fcx.mk_subty(false, infer::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}"}, {"sha": "f96384adc26720cd7a90f408509a4cb75c7794a0", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -59,7 +59,7 @@ type MethodIndex = uint; // just for doc purposes\n pub fn exists(fcx: &FnCtxt,\n               span: Span,\n               method_name: ast::Name,\n-              self_ty: ty::t,\n+              self_ty: Ty,\n               call_expr_id: ast::NodeId)\n               -> bool\n {\n@@ -77,8 +77,8 @@ pub fn exists(fcx: &FnCtxt,\n pub fn lookup(fcx: &FnCtxt,\n               span: Span,\n               method_name: ast::Name,\n-              self_ty: ty::t,\n-              supplied_method_types: Vec<ty::t>,\n+              self_ty: Ty,\n+              supplied_method_types: Vec<Ty>,\n               call_expr_id: ast::NodeId,\n               self_expr: &ast::Expr)\n               -> Result<MethodCallee, MethodError>\n@@ -115,8 +115,8 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                  self_expr: Option<&'a ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n-                                 self_ty: ty::t,\n-                                 opt_input_types: Option<Vec<ty::t>>)\n+                                 self_ty: Ty,\n+                                 opt_input_types: Option<Vec<Ty>>)\n                                  -> Option<MethodCallee>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n@@ -130,8 +130,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n                                           autoderefref: ty::AutoDerefRef,\n-                                          self_ty: ty::t,\n-                                          opt_input_types: Option<Vec<ty::t>>)\n+                                          self_ty: Ty,\n+                                          opt_input_types: Option<Vec<Ty>>)\n                                           -> Option<MethodCallee>\n {\n     /*!\n@@ -310,7 +310,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n pub fn report_error(fcx: &FnCtxt,\n                     span: Span,\n-                    rcvr_ty: ty::t,\n+                    rcvr_ty: Ty,\n                     method_name: ast::Name,\n                     error: MethodError)\n {"}, {"sha": "1a1c19ddb1d9a70263673fc4d552af59b5f18074", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -16,7 +16,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::HigherRankedFoldable;\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference};\n@@ -46,12 +46,12 @@ struct ProbeContext<'a, 'tcx:'a> {\n }\n \n struct CandidateStep {\n-    self_ty: ty::t,\n+    self_ty: Ty,\n     adjustment: PickAdjustment,\n }\n \n struct Candidate {\n-    xform_self_ty: ty::t,\n+    xform_self_ty: Ty,\n     method_ty: Rc<ty::Method>,\n     kind: CandidateKind,\n }\n@@ -108,7 +108,7 @@ pub enum PickAdjustment {\n pub fn probe(fcx: &FnCtxt,\n              span: Span,\n              method_name: ast::Name,\n-             self_ty: ty::t,\n+             self_ty: Ty,\n              call_expr_id: ast::NodeId)\n              -> PickResult\n {\n@@ -157,7 +157,7 @@ pub fn probe(fcx: &FnCtxt,\n     })\n }\n \n-fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep> {\n+fn create_steps(fcx: &FnCtxt, span: Span, self_ty: Ty) -> Vec<CandidateStep> {\n     let mut steps = Vec::new();\n \n     let (fully_dereferenced_ty, dereferences, _) =\n@@ -182,7 +182,7 @@ fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep>\n \n     return steps;\n \n-    fn consider_reborrow(t: ty::t, d: uint) -> PickAdjustment {\n+    fn consider_reborrow(t: Ty, d: uint) -> PickAdjustment {\n         // Insert a `&*` or `&mut *` if this is a reference type:\n         match ty::get(t).sty {\n             ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n@@ -230,7 +230,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn assemble_probe(&mut self, self_ty: ty::t) {\n+    fn assemble_probe(&mut self, self_ty: Ty) {\n         debug!(\"assemble_probe: self_ty={}\",\n                self_ty.repr(self.tcx()));\n \n@@ -293,7 +293,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n-                                                self_ty: ty::t,\n+                                                self_ty: Ty,\n                                                 principal: &ty::TraitRef,\n                                                 _bounds: ty::ExistentialBounds) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n@@ -353,7 +353,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self,\n-                                           _rcvr_ty: ty::t,\n+                                           _rcvr_ty: Ty,\n                                            param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n@@ -671,7 +671,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn search_mutabilities(&mut self,\n                            mk_adjustment: |ast::Mutability| -> PickAdjustment,\n-                           mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty)\n                            -> Option<PickResult>\n     {\n         // In general, during probing we erase regions. See\n@@ -700,7 +700,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn pick_method(&mut self, self_ty: ty::t) -> Option<PickResult> {\n+    fn pick_method(&mut self, self_ty: Ty) -> Option<PickResult> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n@@ -715,7 +715,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.consider_candidates(self_ty, self.extension_candidates[])\n     }\n \n-    fn consider_candidates(&self, self_ty: ty::t, probes: &[Candidate]) -> Option<PickResult> {\n+    fn consider_candidates(&self, self_ty: Ty, probes: &[Candidate]) -> Option<PickResult> {\n         let mut applicable_candidates: Vec<_> =\n             probes.iter()\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n@@ -741,7 +741,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn consider_probe(&self, self_ty: ty::t, probe: &Candidate) -> bool {\n+    fn consider_probe(&self, self_ty: Ty, probe: &Candidate) -> bool {\n         debug!(\"consider_probe: self_ty={} probe={}\",\n                self_ty.repr(self.tcx()),\n                probe.repr(self.tcx()));\n@@ -844,7 +844,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn make_sub_ty(&self, sub: ty::t, sup: ty::t) -> infer::ures {\n+    fn make_sub_ty(&self, sub: Ty, sup: Ty) -> infer::ures {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n@@ -874,7 +874,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.static_candidates.push(source);\n     }\n \n-    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n+    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> Ty {\n         debug!(\"xform_self_ty(self_ty={}, substs={})\",\n                method.fty.sig.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));"}, {"sha": "92518aada27daf12217b424fb75780190150bfc1", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -96,7 +96,7 @@ use middle::traits;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -160,11 +160,11 @@ pub mod wf;\n /// share the inherited fields.\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n-    locals: RefCell<NodeMap<ty::t>>,\n+    locals: RefCell<NodeMap<Ty>>,\n     param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n-    node_types: RefCell<NodeMap<ty::t>>,\n+    node_types: RefCell<NodeMap<Ty>>,\n     item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n     method_map: MethodMap,\n@@ -175,7 +175,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n     // one is never copied into the tcx: it is only used by regionck.\n-    fn_sig_map: RefCell<NodeMap<Vec<ty::t>>>,\n+    fn_sig_map: RefCell<NodeMap<Vec<Ty>>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -209,7 +209,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n struct RegionObligation {\n     sub_region: ty::Region,\n-    sup_type: ty::t,\n+    sup_type: Ty,\n     origin: infer::SubregionOrigin,\n }\n \n@@ -220,10 +220,10 @@ enum Expectation {\n     NoExpectation,\n \n     /// This expression should have the type given (or some subtype)\n-    ExpectHasType(ty::t),\n+    ExpectHasType(Ty),\n \n-    /// This expression will be cast to the `ty::t`\n-    ExpectCastableToType(ty::t),\n+    /// This expression will be cast to the `Ty`\n+    ExpectCastableToType(Ty),\n }\n \n #[deriving(Clone)]\n@@ -295,11 +295,11 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty> {\n         Ok(self.node_ty(id))\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n-                      -> Option<ty::t> {\n+                      -> Option<Ty> {\n         self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n@@ -398,7 +398,7 @@ fn check_bare_fn(ccx: &CrateCtxt,\n                  decl: &ast::FnDecl,\n                  body: &ast::Block,\n                  id: ast::NodeId,\n-                 fty: ty::t,\n+                 fty: Ty,\n                  param_env: ty::ParameterEnvironment) {\n     // Compute the fty from point of view of inside fn\n     // (replace any type-scheme with a type)\n@@ -425,7 +425,7 @@ struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<ty::t>) -> ty::t {\n+    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty>) -> Ty {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n@@ -551,7 +551,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     };\n \n     // Remember return type so that regionck can access it later.\n-    let mut fn_sig_tys: Vec<ty::t> =\n+    let mut fn_sig_tys: Vec<Ty> =\n         arg_tys.iter()\n         .map(|&ty| ty)\n         .collect();\n@@ -1515,7 +1515,7 @@ fn check_cast(fcx: &FnCtxt,\n             \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n         fn types_compatible(fcx: &FnCtxt, sp: Span,\n-                            t1: ty::t, t2: ty::t) -> bool {\n+                            t1: Ty, t2: Ty) -> bool {\n             match ty::get(t1).sty {\n                 ty::ty_vec(_, Some(_)) => {}\n                 _ => return false\n@@ -1588,21 +1588,21 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> ty::t {\n+    fn ty_infer(&self, _span: Span) -> Ty {\n         self.infcx().next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n                                            -> bool {\n         false\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n         ty::mk_err()\n     }\n@@ -1642,7 +1642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty {\n         match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -1663,7 +1663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_string(self.tcx(), ty), self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n@@ -1833,7 +1833,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_meets(&self,\n-                              ty: ty::t,\n+                              ty: Ty,\n                               span: Span,\n                               code: traits::ObligationCauseCode,\n                               bound: ty::BuiltinBound)\n@@ -1850,7 +1850,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_is_sized(&self,\n-                                 ty: ty::t,\n+                                 ty: Ty,\n                                  span: Span,\n                                  code: traits::ObligationCauseCode)\n     {\n@@ -1875,7 +1875,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .register_obligation(self.tcx(), obligation);\n     }\n \n-    pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty {\n         let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n@@ -1891,7 +1891,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat.repr(self.tcx())\n     }\n \n-    pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1901,7 +1901,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> ty::t {\n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty {\n         /*!\n          * Fetch type of `expr` after applying adjustments that\n          * have been recorded in the fcx.\n@@ -1915,7 +1915,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn adjust_expr_ty(&self,\n                           expr: &ast::Expr,\n                           adjustment: Option<&ty::AutoAdjustment>)\n-                          -> ty::t\n+                          -> Ty\n     {\n         /*!\n          * Apply `adjustment` to the type of `expr`\n@@ -1933,7 +1933,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                        .map(|method| method.ty))\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n+    pub fn node_ty(&self, id: ast::NodeId) -> Ty {\n         match self.inh.node_types.borrow().get(&id) {\n             Some(&t) => t,\n             None => {\n@@ -1961,26 +1961,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n                     origin: infer::TypeOrigin,\n-                    sub: ty::t,\n-                    sup: ty::t)\n+                    sub: Ty,\n+                    sup: Ty)\n                     -> Result<(), ty::type_err> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn can_mk_subty(&self, sub: ty::t, sup: ty::t)\n+    pub fn can_mk_subty(&self, sub: Ty, sup: Ty)\n                         -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    pub fn can_mk_eqty(&self, sub: ty::t, sup: ty::t)\n+    pub fn can_mk_eqty(&self, sub: Ty, sup: Ty)\n                        -> Result<(), ty::type_err> {\n         infer::can_mk_eqty(self.infcx(), sub, sup)\n     }\n \n     pub fn mk_assignty(&self,\n                        expr: &ast::Expr,\n-                       sub: ty::t,\n-                       sup: ty::t)\n+                       sub: Ty,\n+                       sup: Ty)\n                        -> Result<(), ty::type_err> {\n         match infer::mk_coercety(self.infcx(),\n                                  false,\n@@ -1999,8 +1999,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,\n-                   sub: ty::t,\n-                   sup: ty::t)\n+                   sub: Ty,\n+                   sup: Ty)\n                    -> Result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n@@ -2015,22 +2015,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: ty::t,\n+                              actual_ty: Ty,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n-                                   e: ty::t,\n-                                   a: ty::t,\n+                                   e: Ty,\n+                                   a: Ty,\n                                    err: &ty::type_err) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n     pub fn register_region_obligation(&self,\n                                       origin: infer::SubregionOrigin,\n-                                      ty: ty::t,\n+                                      ty: Ty,\n                                       r: ty::Region)\n     {\n         /*!\n@@ -2129,7 +2129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn add_region_obligations_for_type_parameter(&self,\n                                                  span: Span,\n                                                  param_bound: &ty::ParamBounds,\n-                                                 ty: ty::t)\n+                                                 ty: Ty)\n     {\n         // For each declared region bound `T:r`, `T` must outlive `r`.\n         let region_bounds =\n@@ -2164,11 +2164,11 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n+pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: Ty,\n                     expr_id: Option<ast::NodeId>,\n                     mut lvalue_pref: LvaluePreference,\n-                    should_stop: |ty::t, uint| -> Option<T>)\n-                    -> (ty::t, uint, Option<T>) {\n+                    should_stop: |Ty, uint| -> Option<T>)\n+                    -> (Ty, uint, Option<T>) {\n     /*!\n      * Executes an autoderef loop for the type `t`. At each step, invokes\n      * `should_stop` to decide whether to terminate the loop. Returns\n@@ -2219,12 +2219,12 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call<'a>(fcx: &FnCtxt,\n-                           call_expression: &ast::Expr,\n-                           callee: &ast::Expr,\n-                           callee_type: ty::t,\n-                           args: &[&'a P<ast::Expr>])\n-                           -> bool {\n+fn try_overloaded_call(fcx: &FnCtxt,\n+                       call_expression: &ast::Expr,\n+                       callee: &ast::Expr,\n+                       callee_type: Ty,\n+                       args: &[&P<ast::Expr>])\n+                       -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match *structure_of(fcx, callee.span, callee_type) {\n@@ -2282,7 +2282,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n                         span: Span,\n                         method_call: Option<MethodCall>,\n                         base_expr: Option<&ast::Expr>,\n-                        base_ty: ty::t,\n+                        base_ty: Ty,\n                         lvalue_pref: LvaluePreference)\n                         -> Option<ty::mt>\n {\n@@ -2347,9 +2347,9 @@ fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n \n fn autoderef_for_index<T>(fcx: &FnCtxt,\n                           base_expr: &ast::Expr,\n-                          base_ty: ty::t,\n+                          base_ty: Ty,\n                           lvalue_pref: LvaluePreference,\n-                          step: |ty::t, ty::AutoDerefRef| -> Option<T>)\n+                          step: |Ty, ty::AutoDerefRef| -> Option<T>)\n                           -> Option<T>\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n@@ -2387,11 +2387,11 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                         method_call: MethodCall,\n                         expr: &ast::Expr,\n                         base_expr: &ast::Expr,\n-                        base_ty: ty::t,\n+                        base_ty: Ty,\n                         start_expr: &Option<P<ast::Expr>>,\n                         end_expr: &Option<P<ast::Expr>>,\n                         mutbl: ast::Mutability)\n-                        -> Option<ty::t> // return type is result of slice\n+                        -> Option<Ty> // return type is result of slice\n {\n     /*!\n      * Autoderefs `base_expr`, looking for a `Slice` impl. If it\n@@ -2443,12 +2443,12 @@ fn try_overloaded_slice_step(fcx: &FnCtxt,\n                              method_call: MethodCall,\n                              expr: &ast::Expr,\n                              base_expr: &ast::Expr,\n-                             base_ty: ty::t, // autoderef'd type\n+                             base_ty: Ty, // autoderef'd type\n                              autoderefref: ty::AutoDerefRef,\n                              mutbl: ast::Mutability,\n                              start_expr: &Option<P<ast::Expr>>,\n                              end_expr: &Option<P<ast::Expr>>)\n-                             -> Option<ty::t> // result type is type of method being called\n+                             -> Option<Ty> // result type is type of method being called\n {\n     /*!\n      * Checks for a `Slice` (or `SliceMut`) impl at the relevant level\n@@ -2516,10 +2516,10 @@ fn try_index_step(fcx: &FnCtxt,\n                   method_call: MethodCall,\n                   expr: &ast::Expr,\n                   base_expr: &ast::Expr,\n-                  adjusted_ty: ty::t,\n+                  adjusted_ty: Ty,\n                   adjustment: ty::AutoDerefRef,\n                   lvalue_pref: LvaluePreference)\n-                  -> Option<(/*index type*/ ty::t, /*element type*/ ty::t)>\n+                  -> Option<(/*index type*/ Ty, /*element type*/ Ty)>\n {\n     /*!\n      * To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n@@ -2594,7 +2594,7 @@ fn try_index_step(fcx: &FnCtxt,\n fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                               iterator_expr: &ast::Expr,\n                               loop_id: ast::NodeId)\n-                              -> ty::t {\n+                              -> Ty {\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n@@ -2672,14 +2672,14 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     }\n }\n \n-fn check_method_argument_types<'a>(fcx: &FnCtxt,\n-                                   sp: Span,\n-                                   method_fn_ty: ty::t,\n-                                   callee_expr: &ast::Expr,\n-                                   args_no_rcvr: &[&'a P<ast::Expr>],\n-                                   deref_args: DerefArgs,\n-                                   tuple_arguments: TupleArgumentsFlag)\n-                                   -> ty::FnOutput {\n+fn check_method_argument_types(fcx: &FnCtxt,\n+                               sp: Span,\n+                               method_fn_ty: Ty,\n+                               callee_expr: &ast::Expr,\n+                               args_no_rcvr: &[&P<ast::Expr>],\n+                               deref_args: DerefArgs,\n+                               tuple_arguments: TupleArgumentsFlag)\n+                               -> ty::FnOutput {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2713,14 +2713,14 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n     }\n }\n \n-fn check_argument_types<'a>(fcx: &FnCtxt,\n-                            sp: Span,\n-                            fn_inputs: &[ty::t],\n-                            _callee_expr: &ast::Expr,\n-                            args: &[&'a P<ast::Expr>],\n-                            deref_args: DerefArgs,\n-                            variadic: bool,\n-                            tuple_arguments: TupleArgumentsFlag) {\n+fn check_argument_types(fcx: &FnCtxt,\n+                        sp: Span,\n+                        fn_inputs: &[Ty],\n+                        _callee_expr: &ast::Expr,\n+                        args: &[&P<ast::Expr>],\n+                        deref_args: DerefArgs,\n+                        variadic: bool,\n+                        tuple_arguments: TupleArgumentsFlag) {\n     /*!\n      *\n      * Generic function that factors out common logic from\n@@ -2891,7 +2891,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n     }\n }\n \n-fn err_args(len: uint) -> Vec<ty::t> {\n+fn err_args(len: uint) -> Vec<Ty> {\n     Vec::from_fn(len, |_| ty::mk_err())\n }\n \n@@ -2906,7 +2906,7 @@ fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::FnOutput) {\n fn check_lit(fcx: &FnCtxt,\n              lit: &ast::Lit,\n              expected: Expectation)\n-             -> ty::t\n+             -> Ty\n {\n     let tcx = fcx.ccx.tcx;\n \n@@ -2960,21 +2960,21 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n \n pub fn check_expr_has_type(fcx: &FnCtxt,\n                            expr: &ast::Expr,\n-                           expected: ty::t) {\n+                           expected: Ty) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n fn check_expr_coercable_to_type(fcx: &FnCtxt,\n                                 expr: &ast::Expr,\n-                                expected: ty::t) {\n+                                expected: Ty) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n-fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: Ty) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || ())\n@@ -3035,7 +3035,7 @@ pub fn lookup_field_ty(tcx: &ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n                        fieldname: ast::Name,\n-                       substs: &subst::Substs) -> Option<ty::t> {\n+                       substs: &subst::Substs) -> Option<Ty> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n@@ -3045,7 +3045,7 @@ pub fn lookup_tup_field_ty(tcx: &ty::ctxt,\n                            class_id: ast::DefId,\n                            items: &[ty::field_ty],\n                            idx: uint,\n-                           substs: &subst::Substs) -> Option<ty::t> {\n+                           substs: &subst::Substs) -> Option<Ty> {\n \n     let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n@@ -3271,12 +3271,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                   op_ex: &ast::Expr,\n-                                  lhs_ty: ty::t,\n+                                  lhs_ty: Ty,\n                                   opname: ast::Name,\n                                   trait_did: Option<ast::DefId>,\n                                   lhs: &'a ast::Expr,\n                                   rhs: Option<&P<ast::Expr>>,\n-                                  unbound_method: ||) -> ty::t {\n+                                  unbound_method: ||) -> Ty {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 // We do eager coercions to make using operators\n@@ -3457,9 +3457,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n                         lhs_expr: &ast::Expr,\n-                        lhs_resolved_t: ty::t,\n+                        lhs_resolved_t: Ty,\n                         op: ast::BinOp,\n-                        rhs: &P<ast::Expr>) -> ty::t {\n+                        rhs: &P<ast::Expr>) -> Ty {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -3500,7 +3500,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n                        rhs_expr: &ast::Expr,\n-                       rhs_t: ty::t) -> ty::t {\n+                       rhs_t: Ty) -> Ty {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, rhs_expr, None, || {\n             fcx.type_error_message(ex.span, |actual| {\n@@ -3800,7 +3800,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     }\n \n     fn check_struct_or_variant_fields(fcx: &FnCtxt,\n-                                      struct_ty: ty::t,\n+                                      struct_ty: Ty,\n                                       span: Span,\n                                       class_id: ast::DefId,\n                                       node_id: ast::NodeId,\n@@ -3975,7 +3975,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n     }\n \n-    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n+    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, Ty);\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n@@ -4394,7 +4394,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 uty\n             }\n             None => {\n-                let t: ty::t = fcx.infcx().next_ty_var();\n+                let t: Ty = fcx.infcx().next_ty_var();\n                 for e in args.iter() {\n                     check_expr_has_type(fcx, &**e, t);\n                 }\n@@ -4424,7 +4424,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 (uty, uty)\n             }\n             None => {\n-                let t: ty::t = fcx.infcx().next_ty_var();\n+                let t: Ty = fcx.infcx().next_ty_var();\n                 check_expr_has_type(fcx, &**element, t);\n                 (fcx.expr_ty(&**element), t)\n             }\n@@ -4927,7 +4927,7 @@ fn check_block_with_expected(fcx: &FnCtxt,\n /// extended to type-level numeric literals.\n pub fn check_const_in_type(tcx: &ty::ctxt,\n                            expr: &ast::Expr,\n-                           expected_type: ty::t) {\n+                           expected_type: Ty) {\n     // Synthesize a crate context. The trait map is not needed here (though I\n     // imagine it will be if we have associated statics --pcwalton), so we\n     // leave it blank.\n@@ -4954,7 +4954,7 @@ pub fn check_const(ccx: &CrateCtxt,\n pub fn check_const_with_ty(fcx: &FnCtxt,\n                            _: Span,\n                            e: &ast::Expr,\n-                           declty: ty::t) {\n+                           declty: Ty) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly\n@@ -5581,7 +5581,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                       type_count);\n         }\n \n-        let input_tys: Vec<ty::t> =\n+        let input_tys: Vec<Ty> =\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n         let tuple_ty =\n@@ -5591,7 +5591,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             substs.types.push(space, tuple_ty);\n         }\n \n-        let output_ty: Option<ty::t> =\n+        let output_ty: Option<Ty> =\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n@@ -5707,7 +5707,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: ty::t) -> ty::t {\n+pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: Ty) -> Ty {\n     // If `ty` is a type variable, see whether we already know what it is.\n     ty = fcx.infcx().shallow_resolve(ty);\n \n@@ -5736,7 +5736,7 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: ty::t) -> ty::\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: Ty)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n@@ -5768,7 +5768,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n pub fn check_bounds_are_used(ccx: &CrateCtxt,\n                              span: Span,\n                              tps: &OwnedSlice<ast::TyParam>,\n-                             ty: ty::t) {\n+                             ty: Ty) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n@@ -5796,7 +5796,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n }\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param(ccx: &CrateCtxt, n: uint) -> ty::t {\n+    fn param(ccx: &CrateCtxt, n: uint) -> Ty {\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n "}, {"sha": "2c71be2bbc6aa01b451d2b19f699f69ad3c0559f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -122,7 +122,7 @@ use middle::def;\n use middle::mem_categorization as mc;\n use middle::traits;\n use middle::ty::{ReScope};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip;\n@@ -178,7 +178,7 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n \n pub fn regionck_ensure_component_tys_wf(fcx: &FnCtxt,\n                                         span: Span,\n-                                        component_tys: &[ty::t]) {\n+                                        component_tys: &[Ty]) {\n     /*!\n      * Checks that the types in `component_tys` are well-formed.\n      * This will add constraints into the region graph.\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         old_scope\n     }\n \n-    pub fn resolve_type(&self, unresolved_ty: ty::t) -> ty::t {\n+    pub fn resolve_type(&self, unresolved_ty: Ty) -> Ty {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -319,19 +319,19 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&self, id: ast::NodeId) -> Ty {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n+    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty> {\n         let method_ty = self.fcx.inh.method_map.borrow()\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) {\n             ty_unadjusted\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn relate_free_regions(&mut self,\n-                           fn_sig_tys: &[ty::t],\n+                           fn_sig_tys: &[Ty],\n                            body_id: ast::NodeId) {\n         /*!\n          * This method populates the region map's `free_region_map`.\n@@ -457,12 +457,12 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n         let t = self.resolve_node_type(id);\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty> {\n         self.resolve_method_type(method_call)\n     }\n \n@@ -809,8 +809,8 @@ fn constrain_cast(rcx: &mut Rcx,\n \n     fn walk_cast(rcx: &mut Rcx,\n                  cast_expr: &ast::Expr,\n-                 from_ty: ty::t,\n-                 to_ty: ty::t) {\n+                 from_ty: Ty,\n+                 to_ty: Ty) {\n         debug!(\"walk_cast(from_ty={}, to_ty={})\",\n                from_ty.repr(rcx.tcx()),\n                to_ty.repr(rcx.tcx()));\n@@ -1185,7 +1185,7 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n fn constrain_autoderefs(rcx: &mut Rcx,\n                         deref_expr: &ast::Expr,\n                         derefs: uint,\n-                        mut derefd_ty: ty::t) {\n+                        mut derefd_ty: Ty) {\n     /*!\n      * Invoked on any auto-dereference that occurs.  Checks that if\n      * this is a region pointer being dereferenced, the lifetime of\n@@ -1260,7 +1260,7 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n \n fn constrain_index(rcx: &mut Rcx,\n                    index_expr: &ast::Expr,\n-                   indexed_ty: ty::t)\n+                   indexed_ty: Ty)\n {\n     /*!\n      * Invoked on any index expression that occurs.  Checks that if\n@@ -1912,7 +1912,7 @@ fn adjust_upvar_borrow_kind(rcx: &Rcx,\n \n fn type_must_outlive(rcx: &mut Rcx,\n                      origin: infer::SubregionOrigin,\n-                     ty: ty::t,\n+                     ty: Ty,\n                      region: ty::Region)\n {\n     /*!"}, {"sha": "af4917fb868b2508d454d31e3ccd41130453991d", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,7 +13,7 @@\n pub use self::WfConstraint::*;\n \n use middle::subst::{ParamSpace, Subst, Substs};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{TypeFolder};\n \n use syntax::ast;\n@@ -23,19 +23,19 @@ use util::ppaux::Repr;\n // Helper functions related to manipulating region types.\n \n pub enum WfConstraint {\n-    RegionSubRegionConstraint(Option<ty::t>, ty::Region, ty::Region),\n-    RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),\n+    RegionSubRegionConstraint(Option<Ty>, ty::Region, ty::Region),\n+    RegionSubParamConstraint(Option<Ty>, ty::Region, ty::ParamTy),\n }\n \n struct Wf<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    stack: Vec<(ty::Region, Option<ty::t>)>,\n+    stack: Vec<(ty::Region, Option<Ty>)>,\n     out: Vec<WfConstraint>,\n }\n \n pub fn region_wf_constraints(\n     tcx: &ty::ctxt,\n-    ty: ty::t,\n+    ty: Ty,\n     outer_region: ty::Region)\n     -> Vec<WfConstraint>\n {\n@@ -55,7 +55,7 @@ pub fn region_wf_constraints(\n }\n \n impl<'a, 'tcx> Wf<'a, 'tcx> {\n-    fn accumulate_from_ty(&mut self, ty: ty::t) {\n+    fn accumulate_from_ty(&mut self, ty: Ty) {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));\n \n@@ -146,9 +146,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_rptr(&mut self,\n-                            ty: ty::t,\n+                            ty: Ty,\n                             r_b: ty::Region,\n-                            ty_b: ty::t) {\n+                            ty_b: Ty) {\n         // We are walking down a type like this, and current\n         // position is indicated by caret:\n         //\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn push_sub_region_constraint(&mut self,\n-                                  opt_ty: Option<ty::t>,\n+                                  opt_ty: Option<Ty>,\n                                   r_a: ty::Region,\n                                   r_b: ty::Region) {\n         /*! Pushes a constraint that `r_a <= r_b`, due to `opt_ty` */\n@@ -213,14 +213,14 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n     fn push_param_constraint(&mut self,\n                              region: ty::Region,\n-                             opt_ty: Option<ty::t>,\n+                             opt_ty: Option<Ty>,\n                              param_ty: ty::ParamTy) {\n         /*! Pushes a constraint that `region <= param_ty`, due to `opt_ty` */\n         self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n     }\n \n     fn accumulate_from_adt(&mut self,\n-                           ty: ty::t,\n+                           ty: Ty,\n                            def_id: ast::DefId,\n                            substs: &Substs)\n     {\n@@ -322,7 +322,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_closure_ty(&mut self,\n-                                  ty: ty::t,\n+                                  ty: Ty,\n                                   c: &ty::ClosureTy)\n     {\n         match c.store {\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_object_ty(&mut self,\n-                                 ty: ty::t,\n+                                 ty: Ty,\n                                  bounds: &ty::ExistentialBounds)\n     {\n         // Imagine a type like this:"}, {"sha": "3de059a408674c1614826b11ee3d266e27d0f0f5", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -14,7 +14,7 @@ use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unim\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n use middle::traits::{ObligationCause};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::{FnCtxt,\n                             structurally_resolved_type};\n use middle::typeck::infer;\n@@ -26,7 +26,7 @@ use util::ppaux::{UserString, Repr, ty_to_string};\n pub fn check_object_cast(fcx: &FnCtxt,\n                          cast_expr: &ast::Expr,\n                          source_expr: &ast::Expr,\n-                         target_object_ty: ty::t)\n+                         target_object_ty: Ty)\n {\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n            cast_expr.repr(fcx.tcx()),\n@@ -99,7 +99,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     // Because we currently give unsound lifetimes to the \"t_box\", I\n     // could have written &'static ty::TyTrait here, but it seems\n     // gratuitously unsafe.\n-    fn object_trait<'a>(t: &'a ty::t) -> &'a ty::TyTrait {\n+    fn object_trait<'a>(t: &'a Ty) -> &'a ty::TyTrait {\n         match ty::get(*t).sty {\n             ty::ty_trait(ref ty_trait) => &**ty_trait,\n             _ => panic!(\"expected ty_trait\")\n@@ -116,7 +116,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     fn push_cast_obligation(fcx: &FnCtxt,\n                             cast_expr: &ast::Expr,\n                             object_trait: &ty::TyTrait,\n-                            referent_ty: ty::t) {\n+                            referent_ty: Ty) {\n         let object_trait_ref =\n             register_object_cast_obligations(fcx,\n                                              cast_expr.span,\n@@ -234,7 +234,7 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n pub fn register_object_cast_obligations(fcx: &FnCtxt,\n                                         span: Span,\n                                         object_trait: &ty::TyTrait,\n-                                        referent_ty: ty::t)\n+                                        referent_ty: Ty)\n                                         -> Rc<ty::TraitRef>\n {\n     // This is just for better error reporting. Kinda goofy. The object type stuff\n@@ -300,7 +300,7 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n }\n \n fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n-                     -> (Rc<ty::TraitRef>, ty::t)\n+                     -> (Rc<ty::TraitRef>, Ty)\n {\n     let trait_ref =\n         fcx.infcx().resolve_type_vars_in_trait_ref_if_possible("}, {"sha": "b07b7526fe4a1f54558f9c815fba2114fb9fcdd9", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -11,7 +11,7 @@\n use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n@@ -29,7 +29,7 @@ use syntax::visit::Visitor;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    cache: HashSet<ty::t>\n+    cache: HashSet<Ty>\n }\n \n impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n@@ -139,7 +139,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            let field_tys: Vec<ty::t> =\n+            let field_tys: Vec<Ty> =\n                 variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n \n             regionck::regionck_ensure_component_tys_wf(\n@@ -256,14 +256,14 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     span: Span,\n     scope_id: ast::NodeId,\n     binding_count: uint,\n-    cache: Option<&'cx mut HashSet<ty::t>>,\n+    cache: Option<&'cx mut HashSet<Ty>>,\n }\n \n impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n                span: Span,\n                scope_id: ast::NodeId,\n-               cache: Option<&'cx mut HashSet<ty::t>>)\n+               cache: Option<&'cx mut HashSet<Ty>>)\n                -> BoundsChecker<'cx,'tcx> {\n         BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n                         cache: cache, binding_count: 0 }\n@@ -300,11 +300,11 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         }\n     }\n \n-    pub fn check_ty(&mut self, ty: ty::t) {\n+    pub fn check_ty(&mut self, ty: Ty) {\n         ty.fold_with(self);\n     }\n \n-    fn check_traits_in_ty(&mut self, ty: ty::t) {\n+    fn check_traits_in_ty(&mut self, ty: Ty) {\n         // When checking types outside of a type def'n, we ignore\n         // region obligations. See discussion below in fold_ty().\n         self.binding_count += 1;\n@@ -318,7 +318,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         debug!(\"BoundsChecker t={}\",\n                t.repr(self.tcx()));\n \n@@ -406,7 +406,7 @@ struct AdtVariant {\n }\n \n struct AdtField {\n-    ty: ty::t,\n+    ty: Ty,\n     span: Span,\n }\n \n@@ -459,7 +459,7 @@ fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n \n fn check_struct_safe_for_destructor(fcx: &FnCtxt,\n                                     span: Span,\n-                                    self_ty: ty::t,\n+                                    self_ty: Ty,\n                                     struct_did: ast::DefId) {\n     let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n     if !struct_tpt.generics.has_type_params(subst::TypeSpace)"}, {"sha": "4f3fd4fae98b91ca1a16b6bdc7146d4221453afd", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -15,7 +15,7 @@ use self::ResolveReason::*;\n \n use middle::def;\n use middle::pat_util;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n@@ -465,7 +465,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         if !ty::type_needs_infer(t) {\n             return t;\n         }"}, {"sha": "12a0e0d01f05975370f5dd2f29949a7a65e07dd7", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -23,7 +23,7 @@ use middle::subst::{Substs};\n use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n-use middle::ty::{t, ty_bool, ty_char, ty_enum, ty_err};\n+use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -57,8 +57,8 @@ mod overlap;\n \n fn get_base_type(inference_context: &InferCtxt,\n                  span: Span,\n-                 original_type: t)\n-                 -> Option<t> {\n+                 original_type: Ty)\n+                 -> Option<Ty> {\n     let resolved_type = match resolve_type(inference_context,\n                                            Some(span),\n                                            original_type,\n@@ -97,7 +97,7 @@ fn get_base_type(inference_context: &InferCtxt,\n // Returns the def ID of the base type, if there is one.\n fn get_base_type_def_id(inference_context: &InferCtxt,\n                         span: Span,\n-                        original_type: t)\n+                        original_type: Ty)\n                         -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n         None => None,\n@@ -489,7 +489,7 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n      * intact.\n      */\n \n-    let meth_tps: Vec<ty::t> =\n+    let meth_tps: Vec<Ty> =\n         method.generics.types.get_slice(subst::FnSpace)\n               .iter()\n               .map(|def| ty::mk_param_from_def(tcx, def))"}, {"sha": "f011c36f782d394f872a9d1e95f8cfe2938b9873", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -40,7 +40,7 @@ use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{Polytype};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty, ast_region_to_region};\n@@ -137,17 +137,17 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n // Utility types and common code for the above passes.\n \n pub trait ToTy {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty;\n }\n \n impl<'a,'tcx> ToTy for ImplCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n impl<'a,'tcx> ToTy for CrateCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n@@ -181,31 +181,31 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n         get_trait_def(self, id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         span_err!(self.tcx.sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures.\");\n         ty::mk_err()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n                                            -> bool {\n         false\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         self.tcx().sess.span_err(span, \"associated types may not be \\\n                                         referenced here\");\n         ty::mk_err()\n     }\n }\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n-                              enum_ty: ty::t,\n+                              enum_ty: Ty,\n                               variants: &[P<ast::Variant>],\n                               generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n@@ -519,7 +519,7 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                          convert_method_context: ConvertMethodContext,\n                          container: ImplOrTraitItemContainer,\n                          mut ms: I,\n-                         untransformed_rcvr_ty: ty::t,\n+                         untransformed_rcvr_ty: Ty,\n                          rcvr_ty_generics: &ty::Generics,\n                          rcvr_visibility: ast::Visibility)\n                          where I: Iterator<&'a ast::Method> {\n@@ -568,7 +568,7 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                     convert_method_context: ConvertMethodContext,\n                     container: ImplOrTraitItemContainer,\n                     m: &ast::Method,\n-                    untransformed_rcvr_ty: ty::t,\n+                    untransformed_rcvr_ty: Ty,\n                     rcvr_ty_generics: &ty::Generics,\n                     rcvr_visibility: ast::Visibility)\n                     -> ty::Method {\n@@ -659,7 +659,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-fn is_associated_type_valid_for_param(ty: ty::t,\n+fn is_associated_type_valid_for_param(ty: Ty,\n                                       trait_id: ast::DefId,\n                                       generics: &ty::Generics)\n                                       -> bool {\n@@ -681,10 +681,10 @@ fn is_associated_type_valid_for_param(ty: ty::t,\n \n fn find_associated_type_in_generics(tcx: &ty::ctxt,\n                                     span: Span,\n-                                    ty: Option<ty::t>,\n+                                    ty: Option<Ty>,\n                                     associated_type_id: ast::DefId,\n                                     generics: &ty::Generics)\n-                                    -> ty::t {\n+                                    -> Ty {\n     let ty = match ty {\n         None => {\n             tcx.sess.span_bug(span,\n@@ -721,7 +721,7 @@ fn find_associated_type_in_generics(tcx: &ty::ctxt,\n     }\n }\n \n-fn type_is_self(ty: ty::t) -> bool {\n+fn type_is_self(ty: Ty) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n         _ => false,\n@@ -748,12 +748,12 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is the trait we're\n@@ -774,10 +774,10 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t\n+                               -> Ty\n     {\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n@@ -837,12 +837,12 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -852,10 +852,10 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         debug!(\"collect::FnCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -886,23 +886,23 @@ impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -935,12 +935,12 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is this trait.\n@@ -955,10 +955,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n \n         // If this is one of our own associated types, return it.\n@@ -1015,12 +1015,12 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n         self.chain.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty {\n         self.chain.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -1032,10 +1032,10 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty {\n         debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -2138,7 +2138,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n fn check_method_self_type<RS:RegionScope>(\n     crate_context: &CrateCtxt,\n     rs: &RS,\n-    required_type: ty::t,\n+    required_type: Ty,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {"}, {"sha": "bc520e264d1374e502999ae639074b0d9344dbaa", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -67,7 +67,7 @@ we may want to adjust precisely when coercions occur.\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n@@ -88,7 +88,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n-    pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+    pub fn tys(&self, a: Ty, b: Ty) -> CoerceResult {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n@@ -190,14 +190,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+    pub fn subtype(&self, a: Ty, b: Ty) -> CoerceResult {\n         match Sub(self.get_ref().clone()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n     }\n \n-    pub fn unpack_actual_value<T>(&self, a: ty::t, f: |&ty::sty| -> T)\n+    pub fn unpack_actual_value<T>(&self, a: Ty, f: |&ty::sty| -> T)\n                                   -> T {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n@@ -215,9 +215,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n-                                   a: ty::t,\n+                                   a: Ty,\n                                    sty_a: &ty::sty,\n-                                   b: ty::t,\n+                                   b: Ty,\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult {\n         debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n@@ -258,9 +258,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &mut [T, ..n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n-                      a: ty::t,\n+                      a: Ty,\n                       sty_a: &ty::sty,\n-                      b: ty::t)\n+                      b: Ty)\n                       -> CoerceResult {\n         debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n@@ -349,10 +349,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // performed to unsize it.\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n-                 ty_a: ty::t,\n+                 ty_a: Ty,\n                  sty_a: &ty::sty,\n-                 ty_b: ty::t)\n-                 -> Option<(ty::t, ty::UnsizeKind)> {\n+                 ty_b: Ty)\n+                 -> Option<(Ty, ty::UnsizeKind)> {\n         debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n@@ -425,9 +425,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_borrowed_object(&self,\n-                              a: ty::t,\n+                              a: Ty,\n                               sty_a: &ty::sty,\n-                              b: ty::t,\n+                              b: Ty,\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -445,9 +445,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_unsafe_object(&self,\n-                            a: ty::t,\n+                            a: Ty,\n                             sty_a: &ty::sty,\n-                            b: ty::t,\n+                            b: Ty,\n                             b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -462,11 +462,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_object(&self,\n-                     a: ty::t,\n+                     a: Ty,\n                      sty_a: &ty::sty,\n-                     b: ty::t,\n+                     b: Ty,\n                      b_mutbl: ast::Mutability,\n-                     mk_ty: |ty::t| -> ty::t,\n+                     mk_ty: |Ty| -> Ty,\n                      mk_adjust: || -> ty::AutoRef) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -494,9 +494,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_borrowed_fn(&self,\n-                              a: ty::t,\n+                              a: Ty,\n                               sty_a: &ty::sty,\n-                              b: ty::t)\n+                              b: Ty)\n                               -> CoerceResult {\n         debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n@@ -512,7 +512,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    fn coerce_from_bare_fn(&self, a: ty::t, fn_ty_a: &ty::BareFnTy, b: ty::t)\n+    fn coerce_from_bare_fn(&self, a: Ty, fn_ty_a: &ty::BareFnTy, b: Ty)\n                            -> CoerceResult {\n         /*!\n          *\n@@ -546,9 +546,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_unsafe_ptr(&self,\n-                             a: ty::t,\n+                             a: Ty,\n                              sty_a: &ty::sty,\n-                             b: ty::t,\n+                             b: Ty,\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\","}, {"sha": "c0258c0c651a3a9aa70168eab234cf0cc50af482", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -38,7 +38,7 @@ use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n@@ -70,14 +70,14 @@ pub trait Combine<'tcx> {\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty>;\n+    fn tys(&self, a: Ty, b: Ty) -> cres<Ty>;\n \n     fn tps(&self,\n            _: subst::ParamSpace,\n-           as_: &[ty::t],\n-           bs: &[ty::t])\n-           -> cres<Vec<ty::t>> {\n+           as_: &[Ty],\n+           bs: &[Ty])\n+           -> cres<Vec<Ty>> {\n         // FIXME -- In general, we treat variance a bit wrong\n         // here. For historical reasons, we treat tps and Self\n         // as invariant. This is overly conservative.\n@@ -90,7 +90,7 @@ pub trait Combine<'tcx> {\n \n         try!(as_.iter().zip(bs.iter())\n                 .map(|(a, b)| self.equate().tys(*a, *b))\n-                .collect::<cres<Vec<ty::t>>>());\n+                .collect::<cres<Vec<Ty>>>());\n         Ok(as_.to_vec())\n     }\n \n@@ -237,7 +237,7 @@ pub trait Combine<'tcx> {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n \n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn args(&self, a: Ty, b: Ty) -> cres<Ty> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n@@ -323,7 +323,7 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n     }\n }\n \n-pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: Ty, b: Ty) -> cres<Ty> {\n \n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n@@ -513,7 +513,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n-        val: ty::IntVarValue) -> cres<ty::t>\n+        val: ty::IntVarValue) -> cres<Ty>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n@@ -526,7 +526,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n-        val: ast::FloatTy) -> cres<ty::t>\n+        val: ast::FloatTy) -> cres<Ty>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n@@ -550,7 +550,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     pub fn instantiate(&self,\n-                       a_ty: ty::t,\n+                       a_ty: Ty,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n                        -> cres<()>\n@@ -640,10 +640,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     fn generalize(&self,\n-                  ty: ty::t,\n+                  ty: Ty,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> cres<ty::t>\n+                  -> cres<Ty>\n     {\n         /*!\n          * Attempts to generalize `ty` for the type variable\n@@ -681,7 +681,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         // Check to see whether the type we are genealizing references\n         // `vid`. At the same time, also update any type variables to\n         // the values that they are bound to. This is needed to truly"}, {"sha": "88afbf0307ca6c4af777e0ffd4325c38dfb57984", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::TyVar;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres};\n@@ -43,7 +43,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         self.tys(a, b)\n     }\n \n@@ -103,7 +103,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }"}, {"sha": "2274a7fecac1aedbbf2499a5c20f62bc31ac1861", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -63,7 +63,7 @@ use self::FreshOrKept::*;\n use std::collections::HashSet;\n use middle::def;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n@@ -1679,8 +1679,8 @@ pub trait Resolvable {\n     fn contains_error(&self) -> bool;\n }\n \n-impl Resolvable for ty::t {\n-    fn resolve(&self, infcx: &InferCtxt) -> ty::t {\n+impl Resolvable for Ty {\n+    fn resolve(&self, infcx: &InferCtxt) -> Ty {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "940bcf22df506f93e40aaedb30492c12907a1040", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::equate::Equate;\n@@ -77,7 +77,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         self.lub().tys(a, b)\n     }\n \n@@ -118,7 +118,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         self.lub().regions(a, b)\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         super_lattice_tys(self, a, b)\n     }\n "}, {"sha": "abe82eb1d9a913be8a84c24e27722475126955da", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,8 +13,7 @@\n  * the end of the file for details.\n  */\n \n-use middle::ty;\n-use middle::ty::replace_late_bound_regions;\n+use middle::ty::{mod, Ty, replace_late_bound_regions};\n use middle::typeck::infer::{mod, combine, cres, InferCtxt};\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::region_inference::{RegionMark};\n@@ -375,9 +374,9 @@ impl HigherRankedCombineable for ty::FnSig {\n \n \n         fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[ty::t],\n-                                           b_args: &[ty::t])\n-                                           -> cres<Vec<ty::t>>\n+                                           a_args: &[Ty],\n+                                           b_args: &[Ty])\n+                                           -> cres<Vec<Ty>>\n         {\n             if a_args.len() == b_args.len() {\n                 a_args.iter().zip(b_args.iter())"}, {"sha": "2df42002fa70940f2d3ab25c1ab2116b5357c7f6", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -32,7 +32,7 @@\n  */\n \n use middle::ty::{TyVar};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n@@ -42,11 +42,11 @@ use util::ppaux::Repr;\n pub trait LatticeDir {\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n+    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()>;\n }\n \n impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()> {\n         let sub = self.sub();\n         try!(sub.tys(a, v));\n         try!(sub.tys(b, v));\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()> {\n         let sub = self.sub();\n         try!(sub.tys(v, a));\n         try!(sub.tys(v, b));\n@@ -64,9 +64,9 @@ impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n }\n \n pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n-                                                           a: ty::t,\n-                                                           b: ty::t)\n-                                                           -> cres<ty::t>\n+                                                           a: Ty,\n+                                                           b: Ty)\n+                                                           -> cres<Ty>\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),"}, {"sha": "2ed8b9c73807f68d96a31157cf4f28dd28e702fd", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n@@ -72,7 +72,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         self.glb().tys(a, b)\n     }\n \n@@ -117,7 +117,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         self.higher_ranked_lub(a, b)\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         super_lattice_tys(self, a, b)\n     }\n "}, {"sha": "539b220a0227c94e5a700b4fae8ba4b684a228ae", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -32,7 +32,7 @@ use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty::replace_late_bound_regions;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n@@ -80,7 +80,7 @@ pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n-    // We instantiate UnificationTable with bounds<ty::t> because the\n+    // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n     type_variables: RefCell<type_variable::TypeVariableTable>,\n@@ -135,7 +135,7 @@ pub enum TypeOrigin {\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n pub enum ValuePairs {\n-    Types(ty::expected_found<ty::t>),\n+    Types(ty::expected_found<Ty>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n }\n \n@@ -182,19 +182,19 @@ pub enum SubregionOrigin {\n \n     // When closing over a variable in a closure/proc, ensure that the\n     // type of the variable outlives the lifetime bound.\n-    RelateProcBound(Span, ast::NodeId, ty::t),\n+    RelateProcBound(Span, ast::NodeId, Ty),\n \n     // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n-    RelateParamBound(Span, ty::t),\n+    RelateParamBound(Span, Ty),\n \n     // The given region parameter was instantiated with a region\n     // that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n     // A bound placed on type parameters that states that must outlive\n     // the moment of their instantiation.\n-    RelateDefaultParamBound(Span, ty::t),\n+    RelateDefaultParamBound(Span, Ty),\n \n     // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n@@ -203,10 +203,10 @@ pub enum SubregionOrigin {\n     ReborrowUpvar(Span, ty::UpvarId),\n \n     // (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(ty::t, Span),\n+    ReferenceOutlivesReferent(Ty, Span),\n \n     // The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(ty::t, Span),\n+    ExprTypeIsNotInScope(Ty, Span),\n \n     // A `ref b` whose region does not enclose the decl site\n     BindingTypeIsNotValidAtDecl(Span),\n@@ -308,9 +308,9 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n pub fn common_supertype(cx: &InferCtxt,\n                         origin: TypeOrigin,\n                         a_is_expected: bool,\n-                        a: ty::t,\n-                        b: ty::t)\n-                        -> ty::t\n+                        a: Ty,\n+                        b: Ty)\n+                        -> Ty\n {\n     /*!\n      * Computes the least upper-bound of `a` and `b`. If this is\n@@ -339,8 +339,8 @@ pub fn common_supertype(cx: &InferCtxt,\n pub fn mk_subty(cx: &InferCtxt,\n                 a_is_expected: bool,\n                 origin: TypeOrigin,\n-                a: ty::t,\n-                b: ty::t)\n+                a: Ty,\n+                b: Ty)\n                 -> ures\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n@@ -349,7 +349,7 @@ pub fn mk_subty(cx: &InferCtxt,\n     })\n }\n \n-pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -360,7 +360,7 @@ pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n     })\n }\n \n-pub fn can_mk_eqty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_eqty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -397,8 +397,8 @@ pub fn verify_param_bound(cx: &InferCtxt,\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n-               a: ty::t,\n-               b: ty::t)\n+               a: Ty,\n+               b: Ty)\n             -> ures\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n@@ -434,8 +434,8 @@ fn expected_found<T>(a_is_expected: bool,\n pub fn mk_coercety(cx: &InferCtxt,\n                    a_is_expected: bool,\n                    origin: TypeOrigin,\n-                   a: ty::t,\n-                   b: ty::t)\n+                   a: Ty,\n+                   b: Ty)\n                 -> CoerceResult {\n     debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n@@ -452,9 +452,9 @@ pub fn mk_coercety(cx: &InferCtxt,\n // See comment on the type `resolve_state` below\n pub fn resolve_type(cx: &InferCtxt,\n                     span: Option<Span>,\n-                    a: ty::t,\n+                    a: Ty,\n                     modes: uint)\n-                    -> fres<ty::t> {\n+                    -> fres<Ty> {\n     let mut resolver = resolver(cx, modes, span);\n     cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n }\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.skolemizer())\n     }\n \n-    pub fn type_var_diverges(&'a self, ty: ty::t) -> bool {\n+    pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty::get(ty).sty {\n             ty::ty_infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n@@ -651,8 +651,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n                      origin: TypeOrigin,\n-                     a: ty::t,\n-                     b: ty::t)\n+                     a: Ty,\n+                     b: Ty)\n                      -> ures\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n@@ -668,8 +668,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     origin: TypeOrigin,\n-                    a: ty::t,\n-                    b: ty::t)\n+                    a: Ty,\n+                    b: Ty)\n                     -> ures\n     {\n         self.commit_if_ok(|| {\n@@ -709,15 +709,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_var(diverging)\n     }\n \n-    pub fn next_ty_var(&self) -> ty::t {\n+    pub fn next_ty_var(&self) -> Ty {\n         ty::mk_var(self.tcx, self.next_ty_var_id(false))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> ty::t {\n+    pub fn next_diverging_ty_var(&self) -> Ty {\n         ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {\n+    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty> {\n         Vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n@@ -769,7 +769,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn fresh_substs_for_trait(&self,\n                                   span: Span,\n                                   generics: &ty::Generics,\n-                                  self_ty: ty::t)\n+                                  self_ty: Ty)\n                                   -> subst::Substs\n     {\n         /*!\n@@ -805,12 +805,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_string(&self, t: ty::t) -> String {\n+    pub fn ty_to_string(&self, t: Ty) -> String {\n         ty_to_string(self.tcx,\n                      self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_string(&self, ts: &[ty::t]) -> String {\n+    pub fn tys_to_string(&self, ts: &[Ty]) -> String {\n         let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n@@ -820,7 +820,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n-    pub fn contains_unbound_type_variables(&self, typ: ty::t) -> ty::t {\n+    pub fn contains_unbound_type_variables(&self, typ: Ty) -> Ty {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve(&self, typ: ty::t) -> ty::t {\n+    pub fn shallow_resolve(&self, typ: Ty) -> Ty {\n         match ty::get(typ).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.type_variables.borrow()\n@@ -853,7 +853,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(&self, typ: Ty) -> Ty {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 mk_msg: |Option<String>,\n                                                          String|\n                                                          -> String,\n-                                                expected_ty: Option<ty::t>,\n+                                                expected_ty: Option<Ty>,\n                                                 actual_ty: String,\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n@@ -938,7 +938,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: ty::t,\n+                              actual_ty: Ty,\n                               err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n@@ -952,8 +952,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_mismatched_types(&self,\n                                    span: Span,\n-                                   expected: ty::t,\n-                                   actual: ty::t,\n+                                   expected: Ty,\n+                                   actual: Ty,\n                                    err: &ty::type_err) {\n         let trace = TypeTrace {\n             origin: Misc(span),"}, {"sha": "94b8485834fe9607db4dd6fc89090702db8c5517", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -50,7 +50,7 @@\n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::typeck::infer::{fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         self.resolve_type(t)\n     }\n \n@@ -112,10 +112,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         (self.modes & mode) == mode\n     }\n \n-    pub fn resolve_type_chk(&mut self,\n-                            typ: ty::t)\n-                            -> fres<ty::t>\n-    {\n+    pub fn resolve_type_chk(&mut self, typ: Ty) -> fres<Ty> {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -151,7 +148,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type(&mut self, typ: Ty) -> Ty {\n         debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n \n         if !ty::type_needs_infer(typ) {\n@@ -203,7 +200,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n+    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty {\n         let tcx = self.infcx.tcx;\n         let tv = self.infcx.type_variables.borrow();\n         match tv.probe(vid) {\n@@ -219,7 +216,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {\n+    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n@@ -240,7 +237,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_float_var(&mut self, vid: FloatVid) -> ty::t {\n+    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }"}, {"sha": "e8630b8ae82b74e7c884a69681caeab1e0f7c0b6", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -40,7 +40,7 @@\n  * it is reasonable to ask what the type inferencer knows \"so far\".\n  */\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n@@ -52,7 +52,7 @@ use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     skolemization_count: uint,\n-    skolemization_map: hash_map::HashMap<ty::InferTy, ty::t>,\n+    skolemization_map: hash_map::HashMap<ty::InferTy, Ty>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n@@ -65,10 +65,10 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     }\n \n     fn skolemize(&mut self,\n-                 opt_ty: Option<ty::t>,\n+                 opt_ty: Option<Ty>,\n                  key: ty::InferTy,\n                  skolemizer: |uint| -> ty::InferTy)\n-                 -> ty::t\n+                 -> Ty\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty) -> Ty {\n         match ty::get(t).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.skolemize(self.infcx.type_variables.borrow().probe(v),"}, {"sha": "1a3b626e1f5edf6767b6957901bf77ce3ef9722b", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::TyVar;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n@@ -47,7 +47,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         Sub(self.fields.switch_expected()).tys(b, a)\n     }\n \n@@ -119,7 +119,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }"}, {"sha": "1bda448990e30c6f343d202f6ffb327335f653f9", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -12,7 +12,7 @@ pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::mem;\n use util::snapshot_vec as sv;\n \n@@ -26,7 +26,7 @@ struct TypeVariableData {\n }\n \n enum TypeVariableValue {\n-    Known(ty::t),\n+    Known(Ty),\n     Bounded(Vec<Relation>),\n }\n \n@@ -89,8 +89,8 @@ impl TypeVariableTable {\n     pub fn instantiate_and_push(\n         &mut self,\n         vid: ty::TyVid,\n-        ty: ty::t,\n-        stack: &mut Vec<(ty::t, RelationDir, ty::TyVid)>)\n+        ty: Ty,\n+        stack: &mut Vec<(Ty, RelationDir, ty::TyVid)>)\n     {\n         /*!\n          * Instantiates `vid` with the type `ty` and then pushes an\n@@ -125,14 +125,14 @@ impl TypeVariableTable {\n         ty::TyVid { index: index }\n     }\n \n-    pub fn probe(&self, vid: ty::TyVid) -> Option<ty::t> {\n+    pub fn probe(&self, vid: ty::TyVid) -> Option<Ty> {\n         match self.values.get(vid.index).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n     }\n \n-    pub fn replace_if_possible(&self, t: ty::t) -> ty::t {\n+    pub fn replace_if_possible(&self, t: Ty) -> Ty {\n         match ty::get(t).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 match self.probe(v) {"}, {"sha": "8596be7f536faafd2a4f1dc7c160649bf0ea1164", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -13,7 +13,7 @@ pub use self::VarValue::*;\n use std::kinds::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{uok, ures};\n use middle::typeck::infer::InferCtxt;\n use std::cell::RefCell;\n@@ -260,7 +260,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n  * relationship.\n  */\n pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n-    fn to_type(&self) -> ty::t;\n+    fn to_type(&self) -> Ty;\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n@@ -289,7 +289,7 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n                     a_id: K,\n                     b: V)\n                     -> ures;\n-    fn probe_var(&self, a_id: K) -> Option<ty::t>;\n+    fn probe_var(&self, a_id: K) -> Option<Ty>;\n }\n \n impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n@@ -375,7 +375,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<ty::t> {\n+    fn probe_var(&self, a_id: K) -> Option<Ty> {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n         let node_a = table.borrow_mut().get(tcx, a_id);\n@@ -407,7 +407,7 @@ impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n }\n \n impl SimplyUnifiable for IntVarValue {\n-    fn to_type(&self) -> ty::t {\n+    fn to_type(&self) -> Ty {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(i),\n             ty::UintType(i) => ty::mk_mach_uint(i),\n@@ -443,7 +443,7 @@ impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl SimplyUnifiable for ast::FloatTy {\n-    fn to_type(&self) -> ty::t {\n+    fn to_type(&self) -> Ty {\n         ty::mk_mach_float(*self)\n     }\n "}, {"sha": "da1ff84f718c2fed2834c4cd5cd352d1ae0c8f93", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -69,7 +69,7 @@ use middle::def;\n use middle::resolve;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config;\n use util::common::time;\n use util::ppaux::Repr;\n@@ -146,7 +146,7 @@ pub struct MethodObject {\n #[deriving(Clone)]\n pub struct MethodCallee {\n     pub origin: MethodOrigin,\n-    pub ty: ty::t,\n+    pub ty: Ty,\n     pub substs: subst::Substs\n }\n \n@@ -179,7 +179,7 @@ pub enum ExprAdjustment {\n \n pub struct TypeAndSubsts {\n     pub substs: subst::Substs,\n-    pub ty: ty::t,\n+    pub ty: Ty,\n }\n \n impl MethodCall {\n@@ -285,7 +285,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n+pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: Ty) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.borrow_mut().insert(node_id, ty);\n@@ -318,7 +318,7 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-pub fn no_params(t: ty::t) -> ty::Polytype {\n+pub fn no_params(t: Ty) -> ty::Polytype {\n     ty::Polytype {\n         generics: ty::Generics {types: VecPerParamSpace::empty(),\n                                 regions: VecPerParamSpace::empty()},\n@@ -330,8 +330,8 @@ pub fn require_same_types(tcx: &ty::ctxt,\n                           maybe_infcx: Option<&infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n-                          t1: ty::t,\n-                          t2: ty::t,\n+                          t1: Ty,\n+                          t2: Ty,\n                           msg: || -> String)\n                           -> bool {\n     let result = match maybe_infcx {"}, {"sha": "e3df42c2adad3b6b976a0b480d897401b7307705", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -199,7 +199,7 @@ use arena::Arena;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               ty: ty::t,\n+                               ty: Ty,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n "}, {"sha": "28ddec69781a26ef6bcb7df2c9be6c34bc4c0164", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -16,7 +16,7 @@ use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, t, ParamTy};\n+use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n@@ -259,7 +259,7 @@ pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n     trait_ref.user_string(cx).to_string()\n }\n \n-pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n+pub fn ty_to_string(cx: &ctxt, typ: Ty) -> String {\n     fn bare_fn_to_string(cx: &ctxt,\n                          fn_style: ast::FnStyle,\n                          abi: abi::Abi,\n@@ -539,7 +539,7 @@ pub fn parameterized(cx: &ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: &ctxt, typ: t) -> String {\n+pub fn ty_to_short_str(cx: &ctxt, typ: Ty) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n         s = s.as_slice().slice(0u, 32u).to_string();\n@@ -652,7 +652,7 @@ impl Repr for ty::RegionParameterDef {\n     }\n }\n \n-impl Repr for ty::t {\n+impl Repr for Ty {\n     fn repr(&self, tcx: &ctxt) -> String {\n         ty_to_string(tcx, *self)\n     }\n@@ -1188,7 +1188,7 @@ impl UserString for ty::TraitRef {\n     }\n }\n \n-impl UserString for ty::t {\n+impl UserString for Ty {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         ty_to_string(tcx, *self)\n     }"}, {"sha": "264756ccf1ee9a0ae2f4608f12aa52114e970409", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -22,7 +22,7 @@ use metadata::common::LinkMeta;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use trans::context::CrateContext;\n use trans::common::gensym_name;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n@@ -198,7 +198,7 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n // This calculates STH for a symbol, as defined above\n fn symbol_hash(tcx: &ty::ctxt,\n                symbol_hasher: &mut Sha256,\n-               t: ty::t,\n+               t: Ty,\n                link_meta: &LinkMeta)\n                -> String {\n     // NB: do *not* use abbrevs here as we want the symbol names\n@@ -219,7 +219,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n     hash\n }\n \n-fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n+fn get_symbol_hash(ccx: &CrateContext, t: Ty) -> String {\n     match ccx.type_hashcodes().borrow().get(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n@@ -321,7 +321,7 @@ pub fn exported_name(path: PathElems, hash: &str) -> String {\n }\n \n pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n-                            t: ty::t, id: ast::NodeId) -> String {\n+                            t: Ty, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n     // Paths can be completely identical for different nodes,\n@@ -346,7 +346,7 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n-                                            t: ty::t,\n+                                            t: Ty,\n                                             name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n     let path = [PathName(token::intern(s.as_slice())),"}, {"sha": "68c6459820ce1682e6dba7a61ac43ab3f2413c7e", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -31,7 +31,7 @@ use driver::driver::CrateAnalysis;\n use session::Session;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n \n use std::cell::Cell;"}, {"sha": "897cd3cc542245fc5e15654d611e08d4f4ef8173", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -24,7 +24,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use middle::subst;\n use middle::subst::Subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer;\n use middle::typeck::infer::lub::Lub;\n@@ -215,60 +215,59 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n-    pub fn make_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+    pub fn make_subtype(&self, a: Ty, b: Ty) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n-    pub fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+    pub fn is_subtype(&self, a: Ty, b: Ty) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n             Err(_) => false\n         }\n     }\n \n-    pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_subtype(&self, a: Ty, b: Ty) {\n         if !self.is_subtype(a, b) {\n             panic!(\"{} is not a subtype of {}, but it should be\",\n                   self.ty_to_string(a),\n                   self.ty_to_string(b));\n         }\n     }\n \n-    pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_eq(&self, a: Ty, b: Ty) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_string(&self, a: ty::t) -> String {\n+    pub fn ty_to_string(&self, a: Ty) -> String {\n         ty_to_string(self.infcx.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n-                input_tys: &[ty::t],\n-                output_ty: ty::t)\n-                -> ty::t\n+                input_tys: &[Ty],\n+                output_ty: Ty)\n+                -> Ty\n     {\n         ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n     }\n \n-    pub fn t_nil(&self) -> ty::t {\n+    pub fn t_nil(&self) -> Ty {\n         ty::mk_nil(self.infcx.tcx)\n     }\n \n-    pub fn t_pair(&self, ty1: ty::t, ty2: ty::t) -> ty::t\n-    {\n+    pub fn t_pair(&self, ty1: Ty, ty2: Ty) -> Ty {\n         ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n     }\n \n     pub fn t_closure(&self,\n-                     input_tys: &[ty::t],\n-                     output_ty: ty::t,\n+                     input_tys: &[Ty],\n+                     output_ty: Ty,\n                      region_bound: ty::Region)\n-                     -> ty::t\n+                     -> Ty\n     {\n         ty::mk_closure(self.infcx.tcx, ty::ClosureTy {\n             fn_style: ast::NormalFn,\n@@ -284,7 +283,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         })\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> ty::t {\n+    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> Ty {\n         ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n     }\n \n@@ -302,23 +301,23 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         ty::ReLateBound(debruijn, ty::BrAnon(id))\n     }\n \n-    pub fn t_rptr(&self, r: ty::Region) -> ty::t {\n+    pub fn t_rptr(&self, r: ty::Region) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, id: uint) -> ty::t {\n+    pub fn t_rptr_late_bound(&self, id: uint) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::t {\n+    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, debruijn),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n+    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n     }\n \n@@ -327,11 +326,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                                    bound_region: ty::BrAnon(id)})\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n+    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n     }\n \n-    pub fn t_rptr_static(&self) -> ty::t {\n+    pub fn t_rptr_static(&self) -> Ty {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n     }\n \n@@ -349,7 +348,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n+    pub fn make_lub_ty(&self, t1: Ty, t2: Ty) -> Ty {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n@@ -358,7 +357,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n-    pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n+    pub fn check_lub(&self, t1: Ty, t2: Ty, t_lub: Ty) {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -371,7 +370,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n-    pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n+    pub fn check_glb(&self, t1: Ty, t2: Ty, t_glb: Ty) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),"}, {"sha": "5c90f64f298d7089897be446ebd6d67adf8e8259", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -217,7 +217,7 @@ use trans::expr::{mod, Dest};\n use trans::tvec;\n use trans::type_of;\n use trans::debuginfo;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config::FullDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n@@ -339,7 +339,7 @@ pub struct BindingInfo {\n     pub trmode: TransBindingMode,\n     pub id: ast::NodeId,\n     pub span: Span,\n-    pub ty: ty::t,\n+    pub ty: Ty,\n }\n \n type BindingsMap = FnvHashMap<Ident, BindingInfo>;\n@@ -620,7 +620,7 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(val: ValueRef, left_ty: ty::t) -> Datum<Lvalue> {\n+fn match_datum(val: ValueRef, left_ty: Ty) -> Datum<Lvalue> {\n     /*!\n      * Helper for converting from the ValueRef that we pass around in\n      * the match code, which is always an lvalue, into a Datum. Eventually\n@@ -655,7 +655,7 @@ fn bind_subslice_pat(bcx: Block,\n }\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 left_ty: ty::t,\n+                                 left_ty: Ty,\n                                  before: uint,\n                                  after: uint,\n                                  val: ValueRef)\n@@ -790,12 +790,12 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              rhs_t: ty::t)\n+                              rhs_t: Ty)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                lhs: ValueRef,\n                                rhs: ValueRef,\n-                               rhs_t: ty::t)\n+                               rhs_t: Ty)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n@@ -1560,7 +1560,7 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n                                     ident: &ast::Ident,\n                                     cleanup_scope: cleanup::ScopeId,\n                                     arg: A,\n-                                    populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty|\n                                               -> Block<'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {\n     let var_ty = node_id_type(bcx, p_id);"}, {"sha": "195808f2419cbc7c34c8a85ed855573ee22a87a4", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -64,7 +64,7 @@ use trans::datum;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -105,8 +105,8 @@ pub enum Repr {\n      */\n     RawNullablePointer {\n         nndiscr: Disr,\n-        nnty: ty::t,\n-        nullfields: Vec<ty::t>\n+        nnty: Ty,\n+        nullfields: Vec<Ty>\n     },\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -123,7 +123,7 @@ pub enum Repr {\n         nonnull: Struct,\n         nndiscr: Disr,\n         ptrfield: PointerField,\n-        nullfields: Vec<ty::t>,\n+        nullfields: Vec<Ty>,\n     }\n }\n \n@@ -136,20 +136,20 @@ pub struct Struct {\n     pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n-    pub fields: Vec<ty::t>\n+    pub fields: Vec<Ty>\n }\n \n /**\n  * Convenience for `represent_type`.  There should probably be more or\n- * these, for places in trans where the `ty::t` isn't directly\n+ * these, for places in trans where the `Ty` isn't directly\n  * available.\n  */\n pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n+pub fn represent_type(cx: &CrateContext, t: Ty) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n@@ -162,7 +162,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     repr\n }\n \n-fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n+fn represent_type_uncached(cx: &CrateContext, t: Ty) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n             return Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n@@ -287,7 +287,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n // this should probably all be in ty\n struct Case {\n     discr: Disr,\n-    tys: Vec<ty::t>\n+    tys: Vec<Ty>\n }\n \n \n@@ -298,7 +298,7 @@ pub enum PointerField {\n }\n \n impl Case {\n-    fn is_zerolen(&self, cx: &CrateContext, scapegoat: ty::t) -> bool {\n+    fn is_zerolen(&self, cx: &CrateContext, scapegoat: Ty) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n@@ -345,7 +345,7 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -> Struct {\n+fn mk_struct(cx: &CrateContext, tys: &[Ty], packed: bool, scapegoat: Ty) -> Struct {\n     let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n         tys.iter()\n@@ -450,7 +450,7 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-pub fn ty_of_inttype(ity: IntType) -> ty::t {\n+pub fn ty_of_inttype(ity: IntType) -> Ty {\n     match ity {\n         attr::SignedInt(t) => ty::mk_mach_int(t),\n         attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n@@ -461,7 +461,7 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n fn ensure_struct_fits_in_address_space(ccx: &CrateContext,\n                                        fields: &[Type],\n                                        packed: bool,\n-                                       scapegoat: ty::t) {\n+                                       scapegoat: Ty) {\n     let mut offset = 0;\n     for &llty in fields.iter() {\n         // Invariant: offset < ccx.max_obj_size() <= 1<<61\n@@ -489,7 +489,7 @@ fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n                                      discr: IntType,\n                                      fields: &[Struct],\n-                                     scapegoat: ty::t) {\n+                                     scapegoat: Ty) {\n     let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n     let (field_size, field_align) = union_size_and_align(fields);\n "}, {"sha": "fdb19605b76296cd39a59e98726cc69840c3c25d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -17,10 +17,10 @@\n //\n // Hopefully useful general knowledge about trans:\n //\n-//   * There's no way to find out the ty::t type of a ValueRef.  Doing so\n+//   * There's no way to find out the Ty type of a ValueRef.  Doing so\n //     would be \"trying to get the eggs out of an omelette\" (credit:\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//     but one TypeRef corresponds to many `ty::t`s; for instance, tup(int, int,\n+//     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n #![allow(non_camel_case_types)]\n@@ -41,7 +41,7 @@ use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::Subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config::{mod, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n-           ty: Type, output: ty::FnOutput) -> ValueRef {\n+               ty: Type, output: ty::FnOutput) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n@@ -203,7 +203,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n-                     output: ty::t) -> ValueRef {\n+                     output: Ty) -> ValueRef {\n     decl_fn(ccx, name, llvm::CCallConv, ty, ty::FnConverging(output))\n }\n \n@@ -213,7 +213,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n                      name: &str,\n                      cc: llvm::CallConv,\n                      ty: Type,\n-                     output: ty::t)\n+                     output: Ty)\n                      -> ValueRef {\n     match externs.get(name) {\n         Some(n) => return *n,\n@@ -224,7 +224,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n+fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n@@ -242,8 +242,8 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n \n pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n                                      closure_id: ast::DefId,\n-                                     fn_ty: ty::t)\n-                                     -> ty::t {\n+                                     fn_ty: Ty)\n+                                     -> Ty {\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n@@ -263,7 +263,7 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n     (*unboxed_closures)[closure_id].kind\n }\n \n-pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n+pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n         ty::ty_bare_fn(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n@@ -297,14 +297,14 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n+pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, fn_ty, name);\n     llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n-                        t: ty::t) -> ValueRef {\n+                        t: Ty) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n@@ -335,15 +335,15 @@ pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-pub fn at_box_body(bcx: Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n+pub fn at_box_body(bcx: Block, body_t: Ty, boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, &[0u, abi::box_field_body])\n }\n \n-fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n+fn require_alloc_fn(bcx: Block, info_ty: Ty, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -359,7 +359,7 @@ fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n \n pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   llty_ptr: Type,\n-                                  info_ty: ty::t,\n+                                  info_ty: Ty,\n                                   size: ValueRef,\n                                   align: ValueRef)\n                                   -> Result<'blk, 'tcx> {\n@@ -374,7 +374,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Result<'blk, 'tcx> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty) -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n@@ -399,7 +399,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n+pub fn get_tydesc(ccx: &CrateContext, t: Ty) -> Rc<tydesc_info> {\n     match ccx.tydescs().borrow().get(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n@@ -496,7 +496,7 @@ pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n \n pub fn get_res_dtor(ccx: &CrateContext,\n                     did: ast::DefId,\n-                    t: ty::t,\n+                    t: Ty,\n                     parent_id: ast::DefId,\n                     substs: &subst::Substs)\n                  -> ValueRef {\n@@ -549,7 +549,7 @@ pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n-                                        t: ty::t,\n+                                        t: Ty,\n                                         op: ast::BinOp)\n                                         -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n@@ -631,7 +631,7 @@ pub fn compare_simd_types(\n                     cx: Block,\n                     lhs: ValueRef,\n                     rhs: ValueRef,\n-                    t: ty::t,\n+                    t: Ty,\n                     size: uint,\n                     op: ast::BinOp)\n                     -> ValueRef {\n@@ -666,12 +666,12 @@ pub fn compare_simd_types(\n }\n \n pub type val_and_ty_fn<'a, 'blk, 'tcx> =\n-    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n+    |Block<'blk, 'tcx>, ValueRef, Ty|: 'a -> Block<'blk, 'tcx>;\n \n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                           av: ValueRef,\n-                                          t: ty::t,\n+                                          t: Ty,\n                                           f: val_and_ty_fn<'a, 'blk, 'tcx>)\n                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n@@ -855,7 +855,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 divrem: ast::BinOp,\n                                 lhs: ValueRef,\n                                 rhs: ValueRef,\n-                                rhs_t: ty::t)\n+                                rhs_t: Ty)\n                                 -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n         (\"attempted to divide by zero\",\n@@ -922,7 +922,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     }\n }\n \n-pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n+pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: Ty) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -951,7 +951,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: Vec<ValueRef> ,\n-                          fn_ty: ty::t,\n+                          fn_ty: Ty,\n                           call_info: Option<NodeInfo>,\n                           // FIXME(15064) is_lang_item is a horrible hack, please remove it\n                           // at the soonest opportunity.\n@@ -1028,13 +1028,13 @@ pub fn need_invoke(bcx: Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate(cx: Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: Block, v: ValueRef, t: Ty) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n-pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_ty(cx: Block, ptr: ValueRef, t: Ty) -> ValueRef {\n     /*!\n      * Helper for loading values from memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values. Also\n@@ -1054,7 +1054,7 @@ pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     }\n }\n \n-pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: Ty) {\n     /*!\n      * Helper for storing values in memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values.\n@@ -1148,7 +1148,7 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: Ty) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1161,7 +1161,7 @@ pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: Block, llptr: ValueRef, t: Ty) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1173,7 +1173,7 @@ pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n+fn memzero(b: &Builder, llptr: ValueRef, ty: Ty) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n@@ -1194,7 +1194,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     b.call(llintrinsicfn, &[llptr, llzeroval, size, align, volatile], None);\n }\n \n-pub fn alloc_ty(bcx: Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: Block, t: Ty, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1220,7 +1220,7 @@ pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: Block, ty: ty::t, name: &str) -> ValueRef {\n+pub fn alloca_zeroed(cx: Block, ty: Ty, name: &str) -> ValueRef {\n     let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1248,7 +1248,7 @@ pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n }\n \n // Creates the alloca slot which holds the pointer to the slot for the final return value\n-pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> ValueRef {\n+pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: Ty) -> ValueRef {\n     let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n \n     // We create an alloca to hold a pointer of type `output_type`\n@@ -1499,7 +1499,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-pub fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n+pub fn arg_kind(cx: &FunctionContext, t: Ty) -> datum::Rvalue {\n     use trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {\n@@ -1515,7 +1515,7 @@ pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n // incoming function arguments. These will later be stored into\n // appropriate lvalue datums.\n pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n-                                 arg_tys: &[ty::t])\n+                                 arg_tys: &[Ty])\n                                  -> Vec<RvalueDatum> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n@@ -1535,7 +1535,7 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n fn create_datums_for_fn_args_under_call_abi(\n         mut bcx: Block,\n         arg_scope: cleanup::CustomScopeIndex,\n-        arg_tys: &[ty::t])\n+        arg_tys: &[Ty])\n         -> Vec<RvalueDatum> {\n     let mut result = Vec::new();\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n@@ -1630,7 +1630,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                         arg_scope: cleanup::CustomScopeIndex,\n                                         args: &[ast::Arg],\n                                         arg_datums: Vec<RvalueDatum>,\n-                                        monomorphized_arg_types: &[ty::t])\n+                                        monomorphized_arg_types: &[Ty])\n                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n@@ -1957,7 +1957,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n }\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                                 ctor_ty: ty::t,\n+                                                 ctor_ty: Ty,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n@@ -2374,7 +2374,7 @@ fn register_fn(ccx: &CrateContext,\n                sp: Span,\n                sym: String,\n                node_id: ast::NodeId,\n-               node_type: ty::t)\n+               node_type: Ty)\n                -> ValueRef {\n     match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n@@ -2388,7 +2388,7 @@ fn register_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n+pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: Ty)\n                               -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n@@ -2665,7 +2665,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n }\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n-                 ty: ty::t, attrs: &[ast::Attribute]) -> String {\n+                 ty: Ty, attrs: &[ast::Attribute]) -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);"}, {"sha": "574ead622c3b1f980284ff2b69f5ec366326ad9c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -50,7 +50,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -671,7 +671,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     call_info: Option<NodeInfo>,\n-                                    callee_ty: ty::t,\n+                                    callee_ty: Ty,\n                                     get_callee: |bcx: Block<'blk, 'tcx>,\n                                                 arg_cleanup_scope: cleanup::ScopeId|\n                                                 -> Callee<'blk, 'tcx>,\n@@ -913,7 +913,7 @@ pub enum CallArgs<'a> {\n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[P<ast::Expr>],\n-                             fn_ty: ty::t,\n+                             fn_ty: Ty,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n@@ -973,7 +973,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n fn trans_overloaded_call_args<'blk, 'tcx>(\n                               mut bcx: Block<'blk, 'tcx>,\n                               arg_exprs: Vec<&ast::Expr>,\n-                              fn_ty: ty::t,\n+                              fn_ty: Ty,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool)\n@@ -1018,7 +1018,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n \n pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               args: CallArgs,\n-                              fn_ty: ty::t,\n+                              fn_ty: Ty,\n                               llargs: &mut Vec<ValueRef> ,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool,\n@@ -1108,7 +1108,7 @@ pub enum AutorefArg {\n }\n \n pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   formal_arg_ty: ty::t,\n+                                   formal_arg_ty: Ty,\n                                    arg_datum: Datum<Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n                                    autoref_arg: AutorefArg)"}, {"sha": "94b32c9b3af849c341ea5d5548ff86876b8ec8be", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -27,7 +27,7 @@ use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n use trans::type_::Type;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -307,7 +307,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: ty::t) {\n+                         ty: Ty) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is a pointer to an\n          * instance of `ty`\n@@ -333,7 +333,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: ty::t) {\n+                                  ty: Ty) {\n         /*!\n          * Schedules a (deep) drop and zero-ing of `val`, which is a pointer\n          * to an instance of `ty`\n@@ -360,7 +360,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: ty::t) {\n+                               ty: Ty) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is an instance of `ty`\n          */\n@@ -386,7 +386,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: ty::t) {\n+                           content_ty: Ty) {\n         /*!\n          * Schedules a call to `free(val)`. Note that this is a shallow\n          * operation.\n@@ -959,7 +959,7 @@ pub struct DropValue {\n     is_immediate: bool,\n     must_unwind: bool,\n     val: ValueRef,\n-    ty: ty::t,\n+    ty: Ty,\n     zero: bool\n }\n \n@@ -1000,7 +1000,7 @@ pub enum Heap {\n pub struct FreeValue {\n     ptr: ValueRef,\n     heap: Heap,\n-    content_ty: ty::t\n+    content_ty: Ty\n }\n \n impl Cleanup for FreeValue {\n@@ -1166,20 +1166,20 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: ty::t);\n+                         ty: Ty);\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: ty::t);\n+                                  ty: Ty);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: ty::t);\n+                               ty: Ty);\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: ty::t);\n+                           content_ty: Ty);\n     fn schedule_free_slice(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,"}, {"sha": "f6a4e4bcf94252ed803d5e360bf5f39ea1950a3f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -25,7 +25,7 @@ use trans::expr;\n use trans::monomorphize::MonoId;\n use trans::type_of::*;\n use trans::type_::Type;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::subst::{Subst, Substs};\n use session::config::FullDebugInfo;\n use util::ppaux::Repr;\n@@ -115,7 +115,7 @@ impl EnvValue {\n // Given a closure ty, emits a corresponding tuple ty\n pub fn mk_closure_tys(tcx: &ty::ctxt,\n                       bound_values: &[EnvValue])\n-                   -> ty::t {\n+                   -> Ty {\n     // determine the types of the values in the env.  Note that this\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n@@ -131,14 +131,14 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     return cdata_ty;\n }\n \n-fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n+fn tuplify_box_ty(tcx: &ty::ctxt, t: Ty) -> Ty {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              store: ty::TraitStore,\n-                             cdata_ty: ty::t)\n+                             cdata_ty: Ty)\n                              -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n@@ -158,7 +158,7 @@ fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub struct ClosureResult<'blk, 'tcx: 'blk> {\n     llbox: ValueRef,    // llvalue of ptr to closure\n-    cdata_ty: ty::t,    // type of the closure data\n+    cdata_ty: Ty,    // type of the closure data\n     bcx: Block<'blk, 'tcx>  // final bcx\n }\n \n@@ -248,7 +248,7 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: ty::t,\n+                                cdata_ty: Ty,\n                                 freevars: &Vec<ty::Freevar>,\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n@@ -553,7 +553,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n }\n \n pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n-                               closure_ty: ty::t,\n+                               closure_ty: Ty,\n                                def: def::Def,\n                                fn_ptr: ValueRef,\n                                is_local: bool) -> ValueRef {\n@@ -647,7 +647,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n }\n \n pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                             closure_ty: ty::t,\n+                                             closure_ty: Ty,\n                                              def: def::Def,\n                                              fn_ptr: ValueRef)\n                                              -> DatumBlock<'blk, 'tcx, Expr>  {"}, {"sha": "fe867ed7039c4b15f37ecac1c36433668661ef33", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -32,7 +32,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n@@ -55,7 +55,7 @@ use syntax::parse::token;\n \n pub use trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n+fn type_is_newtype_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n@@ -68,7 +68,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n     use trans::machine::llsize_of_alloc;\n     use trans::type_of::sizing_type_of;\n \n@@ -93,7 +93,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_zero_size(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_zero_size(ccx: &CrateContext, ty: Ty) -> bool {\n     /*!\n      * Identify types which have size zero at runtime.\n      */\n@@ -104,7 +104,7 @@ pub fn type_is_zero_size(ccx: &CrateContext, ty: ty::t) -> bool {\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n     /*!\n      * Identifies types which we declare to be equivalent to `void`\n      * in C for the purpose of function return types. These are\n@@ -126,7 +126,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n }\n \n pub struct tydesc_info {\n-    pub ty: ty::t,\n+    pub ty: Ty,\n     pub tydesc: ValueRef,\n     pub size: ValueRef,\n     pub align: ValueRef,\n@@ -495,7 +495,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.ccx().tn().type_to_string(ty)\n     }\n \n-    pub fn ty_to_string(&self, t: ty::t) -> String {\n+    pub fn ty_to_string(&self, t: Ty) -> String {\n         t.repr(self.tcx())\n     }\n \n@@ -509,11 +509,11 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n         Ok(node_id_type(self, id))\n     }\n \n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty> {\n         self.tcx()\n             .method_map\n             .borrow()\n@@ -788,21 +788,21 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: &BlockS, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &BlockS, t: Ty) -> Ty {\n     t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n-pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> Ty {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> Ty {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> Ty {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n "}, {"sha": "2100e57b1909ab932b1135a07085858ff04f6599", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -29,7 +29,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::debuginfo;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n@@ -133,14 +133,14 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: Ty)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, &*repr, v, 0, 0)\n }\n \n-fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n-    -> (ValueRef, ty::t) {\n+fn const_deref(cx: &CrateContext, v: ValueRef, t: Ty, explicit: bool)\n+    -> (ValueRef, Ty) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n             match ty::get(t).sty {\n@@ -187,7 +187,7 @@ pub fn get_const_val(cx: &CrateContext,\n     cx.const_values().borrow()[def_id.node].clone()\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, Ty) {\n     let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let ety = ty::expr_ty(cx.tcx(), e);\n@@ -725,7 +725,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     }\n }\n \n-fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: ty::t) -> ValueRef {\n+fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: Ty) -> ValueRef {\n     if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n     base::trans_external_path(ccx, did, ty)\n }"}, {"sha": "1e1dd399f3e1cd5735a9521a1a559a2db5fa721d", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -22,7 +22,7 @@ use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n use util::ppaux::Repr;\n@@ -70,7 +70,7 @@ pub struct SharedCrateContext<'tcx> {\n     stats: Stats,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<ty::t, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<Ty, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -84,8 +84,8 @@ pub struct LocalCrateContext {\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<ty::t, ValueRef>>,\n-    tydescs: RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>>,\n+    drop_glues: RefCell<FnvHashMap<Ty, ValueRef>>,\n+    tydescs: RefCell<FnvHashMap<Ty, Rc<tydesc_info>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n     finished_tydescs: Cell<bool>,\n@@ -98,7 +98,7 @@ pub struct LocalCrateContext {\n     monomorphized: RefCell<FnvHashMap<MonoId, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty, Rc<ty::TraitRef>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -126,10 +126,10 @@ pub struct LocalCrateContext {\n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n-    lltypes: RefCell<FnvHashMap<ty::t, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<ty::t, Type>>,\n-    adt_reprs: RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>>,\n-    type_hashcodes: RefCell<FnvHashMap<ty::t, String>>,\n+    lltypes: RefCell<FnvHashMap<Ty, Type>>,\n+    llsizingtypes: RefCell<FnvHashMap<Ty, Type>>,\n+    adt_reprs: RefCell<FnvHashMap<Ty, Rc<adt::Repr>>>,\n+    type_hashcodes: RefCell<FnvHashMap<Ty, String>>,\n     all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n@@ -574,11 +574,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>> {\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Rc<tydesc_info>>> {\n         &self.local.tydescs\n     }\n \n@@ -602,7 +602,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty, Rc<ty::TraitRef>), ValueRef>> {\n         &self.local.vtables\n     }\n \n@@ -635,23 +635,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Type>> {\n         &self.local.lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Type>> {\n         &self.local.llsizingtypes\n     }\n \n-    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>> {\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Rc<adt::Repr>>> {\n         &self.local.adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, String>> {\n         &self.local.type_hashcodes\n     }\n \n@@ -667,7 +667,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n+    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, String>> {\n         &self.shared.available_drop_glues\n     }\n \n@@ -707,7 +707,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         1<<31 /* FIXME #18069: select based on architecture */\n     }\n \n-    pub fn report_overbig_object(&self, obj: ty::t) -> ! {\n+    pub fn report_overbig_object(&self, obj: Ty) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n                     obj.repr(self.tcx())).as_slice())"}, {"sha": "c778bc7eb27c8af98a31e291af0de87a94d4af50", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -25,7 +25,7 @@ use trans::cleanup::CleanupMethods;\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{ty_to_string};\n \n use std::fmt;\n@@ -44,7 +44,7 @@ pub struct Datum<K> {\n     pub val: ValueRef,\n \n     /// The rust type of the value.\n-    pub ty: ty::t,\n+    pub ty: Ty,\n \n     /// Indicates whether this is by-ref or by-value.\n     pub kind: K,\n@@ -95,20 +95,20 @@ pub enum RvalueMode {\n     ByValue,\n }\n \n-pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum<Rvalue> {\n+pub fn immediate_rvalue(val: ValueRef, ty: Ty) -> Datum<Rvalue> {\n     return Datum::new(val, ty, Rvalue::new(ByValue));\n }\n \n pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         val: ValueRef,\n-                                        ty: ty::t)\n+                                        ty: Ty)\n                                         -> DatumBlock<'blk, 'tcx, Rvalue> {\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n \n pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                           ty: ty::t,\n+                                           ty: Ty,\n                                            name: &str,\n                                            zero: bool,\n                                            scope: cleanup::ScopeId,\n@@ -141,7 +141,7 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn rvalue_scratch_datum(bcx: Block,\n-                            ty: ty::t,\n+                            ty: Ty,\n                             name: &str)\n                             -> Datum<Rvalue> {\n     /*!\n@@ -159,7 +159,7 @@ pub fn rvalue_scratch_datum(bcx: Block,\n     Datum::new(scratch, ty, Rvalue::new(ByRef))\n }\n \n-pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: ty::t) -> RvalueMode {\n+pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: Ty) -> RvalueMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -177,7 +177,7 @@ fn add_rvalue_clean(mode: RvalueMode,\n                     fcx: &FunctionContext,\n                     scope: cleanup::ScopeId,\n                     val: ValueRef,\n-                    ty: ty::t) {\n+                    ty: Ty) {\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -196,7 +196,7 @@ pub trait KindOps {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: ty::t)\n+                              ty: Ty)\n                               -> Block<'blk, 'tcx>;\n \n     /**\n@@ -216,7 +216,7 @@ impl KindOps for Rvalue {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               _val: ValueRef,\n-                              _ty: ty::t)\n+                              _ty: Ty)\n                               -> Block<'blk, 'tcx> {\n         // No cleanup is scheduled for an rvalue, so we don't have\n         // to do anything after a move to cancel or duplicate it.\n@@ -236,7 +236,7 @@ impl KindOps for Lvalue {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: ty::t)\n+                              ty: Ty)\n                               -> Block<'blk, 'tcx> {\n         /*!\n          * If an lvalue is moved, we must zero out the memory in which\n@@ -266,7 +266,7 @@ impl KindOps for Expr {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: ty::t)\n+                              ty: Ty)\n                               -> Block<'blk, 'tcx> {\n         match *self {\n             LvalueExpr => Lvalue.post_store(bcx, val, ty),\n@@ -515,7 +515,7 @@ impl Datum<Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element(&self, bcx: Block, ty: ty::t,\n+    pub fn get_element(&self, bcx: Block, ty: Ty,\n                        gep: |ValueRef| -> ValueRef)\n                        -> Datum<Lvalue> {\n         let val = match ty::get(self.ty).sty {\n@@ -546,7 +546,7 @@ impl Datum<Lvalue> {\n  * Generic methods applicable to any sort of datum.\n  */\n impl<K: KindOps + fmt::Show> Datum<K> {\n-    pub fn new(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n+    pub fn new(val: ValueRef, ty: Ty, kind: K) -> Datum<K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n "}, {"sha": "6e8b3b2d915f4297443d6a57a4422357482a3613", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -172,9 +172,9 @@ to always map crate and node IDs back to the original crate context.\n \n As a side-effect these unique type IDs also help to solve a problem arising from\n lifetime parameters. Since lifetime parameters are completely omitted in\n-debuginfo, more than one `ty::t` instance may map to the same debuginfo type\n+debuginfo, more than one `Ty` instance may map to the same debuginfo type\n metadata, that is, some struct `Struct<'a>` may have N instantiations with\n-different concrete substitutions for `'a`, and thus there will be N `ty::t`\n+different concrete substitutions for `'a`, and thus there will be N `Ty`\n instances for the type `Struct<'a>` even though it is not generic otherwise.\n Unfortunately this means that we cannot use `ty::type_id()` as cheap identifier\n for type metadata---we have done this in the past, but it led to unnecessary\n@@ -204,7 +204,7 @@ use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::type_of;\n use trans::type_::Type;\n use trans;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::pat_util;\n use session::config::{mod, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n@@ -258,17 +258,17 @@ struct UniqueTypeId(ast::Name);\n \n // The TypeMap is where the CrateDebugContext holds the type metadata nodes\n // created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n-// faster lookup, also by ty::t. The TypeMap is responsible for creating\n+// faster lookup, also by Ty. The TypeMap is responsible for creating\n // UniqueTypeIds.\n struct TypeMap {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner<Rc<String>>,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<ty::t, DIType>,\n+    type_to_metadata: FnvHashMap<Ty, DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<ty::t, UniqueTypeId>\n+    type_to_unique_id: FnvHashMap<Ty, UniqueTypeId>\n }\n \n impl TypeMap {\n@@ -282,14 +282,14 @@ impl TypeMap {\n         }\n     }\n \n-    // Adds a ty::t to metadata mapping to the TypeMap. The method will fail if\n+    // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n     fn register_type_with_metadata(&mut self,\n                                    cx: &CrateContext,\n-                                   type_: ty::t,\n+                                   type_: Ty,\n                                    metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n+            cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n                                    ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n         }\n     }\n@@ -307,7 +307,7 @@ impl TypeMap {\n         }\n     }\n \n-    fn find_metadata_for_type(&self, type_: ty::t) -> Option<DIType> {\n+    fn find_metadata_for_type(&self, type_: Ty) -> Option<DIType> {\n         self.type_to_metadata.get(&type_).cloned()\n     }\n \n@@ -325,7 +325,7 @@ impl TypeMap {\n     // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n     // type has been requested before, this is just a table lookup. Otherwise an\n     // ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type(&mut self, cx: &CrateContext, type_: ty::t) -> UniqueTypeId {\n+    fn get_unique_type_id_of_type(&mut self, cx: &CrateContext, type_: Ty) -> UniqueTypeId {\n \n         // basic type           -> {:name of the type:}\n         // tuple                -> {tuple_(:param-uid:)*}\n@@ -621,7 +621,7 @@ impl TypeMap {\n     // UniqueTypeId for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant(&mut self,\n                                           cx: &CrateContext,\n-                                          enum_type: ty::t,\n+                                          enum_type: Ty,\n                                           variant_name: &str)\n                                        -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n@@ -886,7 +886,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_captured_var_metadata(bcx: Block,\n                                     node_id: ast::NodeId,\n-                                    env_data_type: ty::t,\n+                                    env_data_type: Ty,\n                                     env_pointer: ValueRef,\n                                     env_index: uint,\n                                     closure_store: ty::TraitStore,\n@@ -1592,7 +1592,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n \n fn declare_local(bcx: Block,\n                  variable_ident: ast::Ident,\n-                 variable_type: ty::t,\n+                 variable_type: Ty,\n                  scope_metadata: DIScope,\n                  variable_access: VariableAccess,\n                  variable_kind: VariableKind,\n@@ -1739,7 +1739,7 @@ fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n     })\n }\n \n-fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n+fn basic_type_metadata(cx: &CrateContext, t: Ty) -> DIType {\n \n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n@@ -1786,7 +1786,7 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n }\n \n fn pointer_type_metadata(cx: &CrateContext,\n-                         pointer_type: ty::t,\n+                         pointer_type: Ty,\n                          pointee_type_metadata: DIType)\n                       -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n@@ -1861,7 +1861,7 @@ impl MemberDescriptionFactory {\n // section on Recursive Types at the top of this file for more information.\n enum RecursiveTypeDescription {\n     UnfinishedMetadata {\n-        unfinished_type: ty::t,\n+        unfinished_type: Ty,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n@@ -1872,7 +1872,7 @@ enum RecursiveTypeDescription {\n \n fn create_and_register_recursive_type_forward_declaration(\n     cx: &CrateContext,\n-    unfinished_type: ty::t,\n+    unfinished_type: Ty,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n     llvm_type: Type,\n@@ -1989,7 +1989,7 @@ impl StructMemberDescriptionFactory {\n \n \n fn prepare_struct_metadata(cx: &CrateContext,\n-                           struct_type: ty::t,\n+                           struct_type: Ty,\n                            def_id: ast::DefId,\n                            substs: &subst::Substs,\n                            unique_type_id: UniqueTypeId,\n@@ -2029,7 +2029,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n \n // Creates MemberDescriptions for the fields of a tuple\n struct TupleMemberDescriptionFactory {\n-    component_types: Vec<ty::t> ,\n+    component_types: Vec<Ty> ,\n     span: Span,\n }\n \n@@ -2049,8 +2049,8 @@ impl TupleMemberDescriptionFactory {\n }\n \n fn prepare_tuple_metadata(cx: &CrateContext,\n-                          tuple_type: ty::t,\n-                          component_types: &[ty::t],\n+                          tuple_type: Ty,\n+                          component_types: &[Ty],\n                           unique_type_id: UniqueTypeId,\n                           span: Span)\n                        -> RecursiveTypeDescription {\n@@ -2085,7 +2085,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n // will produce one MemberDescription (all with no name and a fixed offset of\n // zero bytes).\n struct EnumMemberDescriptionFactory {\n-    enum_type: ty::t,\n+    enum_type: Ty,\n     type_rep: Rc<adt::Repr>,\n     variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n     discriminant_type_metadata: Option<DIType>,\n@@ -2287,7 +2287,7 @@ impl EnumMemberDescriptionFactory {\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory {\n-    args: Vec<(String, ty::t)> ,\n+    args: Vec<(String, Ty)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n@@ -2320,7 +2320,7 @@ enum EnumDiscriminantInfo {\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n fn describe_enum_variant(cx: &CrateContext,\n-                         enum_type: ty::t,\n+                         enum_type: Ty,\n                          struct_def: &adt::Struct,\n                          variant_info: &ty::VariantInfo,\n                          discriminant_info: EnumDiscriminantInfo,\n@@ -2369,7 +2369,7 @@ fn describe_enum_variant(cx: &CrateContext,\n     };\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(String, ty::t)> = arg_names.iter()\n+    let args: Vec<(String, Ty)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n         .map(|(s, &t)| (s.to_string(), t))\n         .collect();\n@@ -2390,7 +2390,7 @@ fn describe_enum_variant(cx: &CrateContext,\n }\n \n fn prepare_enum_metadata(cx: &CrateContext,\n-                         enum_type: ty::t,\n+                         enum_type: Ty,\n                          enum_def_id: ast::DefId,\n                          unique_type_id: UniqueTypeId,\n                          span: Span)\n@@ -2677,7 +2677,7 @@ fn create_struct_stub(cx: &CrateContext,\n \n fn fixed_vec_metadata(cx: &CrateContext,\n                       unique_type_id: UniqueTypeId,\n-                      element_type: ty::t,\n+                      element_type: Ty,\n                       len: uint,\n                       span: Span)\n                    -> MetadataCreationResult {\n@@ -2709,8 +2709,8 @@ fn fixed_vec_metadata(cx: &CrateContext,\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n-                      vec_type: ty::t,\n-                      element_type: ty::t,\n+                      vec_type: Ty,\n+                      element_type: Ty,\n                       unique_type_id: UniqueTypeId,\n                       span: Span)\n                    -> MetadataCreationResult {\n@@ -2764,7 +2764,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     fn slice_layout_is_correct(cx: &CrateContext,\n                                member_llvm_types: &[Type],\n-                               element_type: ty::t)\n+                               element_type: Ty)\n                             -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n@@ -2812,8 +2812,8 @@ fn subroutine_type_metadata(cx: &CrateContext,\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n fn trait_pointer_metadata(cx: &CrateContext,\n-                          trait_type: ty::t,\n-                          trait_object_type: Option<ty::t>,\n+                          trait_type: Ty,\n+                          trait_object_type: Option<Ty>,\n                           unique_type_id: UniqueTypeId)\n                        -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n@@ -2849,7 +2849,7 @@ fn trait_pointer_metadata(cx: &CrateContext,\n }\n \n fn type_metadata(cx: &CrateContext,\n-                 t: ty::t,\n+                 t: Ty,\n                  usage_site_span: Span)\n               -> DIType {\n     // Get the unique type id of this type.\n@@ -2862,15 +2862,15 @@ fn type_metadata(cx: &CrateContext,\n                 return metadata;\n             },\n             None => {\n-                // The ty::t is not in the TypeMap but maybe we have already seen\n+                // The Ty is not in the TypeMap but maybe we have already seen\n                 // an equivalent type (e.g. only differing in region arguments).\n                 // In order to find out, generate the unique type id and look\n                 // that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n                 match type_map.find_metadata_for_unique_id(unique_type_id) {\n                     Some(metadata) => {\n                         // There is already an equivalent type in the TypeMap.\n-                        // Register this ty::t as an alias in the cache and\n+                        // Register this Ty as an alias in the cache and\n                         // return the cached metadata.\n                         type_map.register_type_with_metadata(cx, t, metadata);\n                         return metadata;\n@@ -2986,7 +2986,7 @@ fn type_metadata(cx: &CrateContext,\n                     let error_message = format!(\"Expected type metadata for unique \\\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n-                                                 was not. (ty::t = {})\",\n+                                                 was not. (Ty = {})\",\n                                                 unique_type_id_str.as_slice(),\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n                     cx.sess().span_bug(usage_site_span, error_message.as_slice());\n@@ -2998,10 +2998,10 @@ fn type_metadata(cx: &CrateContext,\n                     if metadata != metadata_for_uid {\n                         let unique_type_id_str =\n                             type_map.get_unique_type_id_as_string(unique_type_id);\n-                        let error_message = format!(\"Mismatch between ty::t and \\\n+                        let error_message = format!(\"Mismatch between Ty and \\\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n-                                                     UniqueTypeId={}, ty::t={}\",\n+                                                     UniqueTypeId={}, Ty={}\",\n                             unique_type_id_str.as_slice(),\n                             ppaux::ty_to_string(cx.tcx(), t));\n                         cx.sess().span_bug(usage_site_span, error_message.as_slice());\n@@ -3667,7 +3667,7 @@ fn populate_scope_map(cx: &CrateContext,\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e. type parameters) are always fully qualified.\n fn compute_debuginfo_type_name(cx: &CrateContext,\n-                               t: ty::t,\n+                               t: Ty,\n                                qualified: bool)\n                             -> String {\n     let mut result = String::with_capacity(64);\n@@ -3678,7 +3678,7 @@ fn compute_debuginfo_type_name(cx: &CrateContext,\n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n fn push_debuginfo_type_name(cx: &CrateContext,\n-                            t: ty::t,\n+                            t: Ty,\n                             qualified: bool,\n                             output: &mut String) {\n     match ty::get(t).sty {"}, {"sha": "a5281e582f13651e9771e2f9b7a0d7d4f847184e", "filename": "src/librustc_trans/trans/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -40,7 +40,7 @@ up expressions into:\n ## The Datum module\n \n A `Datum` encapsulates the result of evaluating a Rust expression.  It\n-contains a `ValueRef` indicating the result, a `ty::t` describing\n+contains a `ValueRef` indicating the result, a `Ty` describing\n the Rust type, but also a *kind*. The kind indicates whether the datum\n has cleanup scheduled (lvalue) or not (rvalue) and -- in the case of\n rvalues -- whether or not the value is \"by ref\" or \"by value\"."}, {"sha": "abf1718b49886b95c474db5da6264368fee46a7d", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -68,7 +68,7 @@ use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n use middle::ty::{AutoPtr};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use middle::typeck::MethodCall;\n use util::common::indenter;\n@@ -314,8 +314,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 kind: &ty::UnsizeKind,\n                                 id: ast::NodeId,\n-                                unsized_ty: ty::t,\n-                                mk_ty: |ty::t| -> ty::t) -> ValueRef {\n+                                unsized_ty: Ty,\n+                                mk_ty: |Ty| -> Ty) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n             &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n@@ -391,7 +391,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 expr: &ast::Expr,\n                                 datum: Datum<Expr>,\n-                                dest_ty: ty::t,\n+                                dest_ty: Ty,\n                                 base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n                                 info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n                                 -> DatumBlock<'blk, 'tcx, Expr> {\n@@ -566,7 +566,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: ty::t)\n+    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: Ty)\n                        -> DatumBlock<'blk, 'tcx, Expr> {\n         let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n         let datum = immediate_rvalue(llval, ty);\n@@ -858,7 +858,7 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n-                                   const_ty: ty::t) -> ValueRef {\n+                                   const_ty: Ty) -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n                     // Case 1.\n@@ -1267,7 +1267,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn with_field_tys<R>(tcx: &ty::ctxt,\n-                         ty: ty::t,\n+                         ty: Ty,\n                          node_id_opt: Option<ast::NodeId>,\n                          op: |ty::Disr, (&[ty::field])| -> R)\n                          -> R {\n@@ -1393,7 +1393,7 @@ pub struct StructBaseInfo<'a> {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, ty::t)>\n+    fields: Vec<(uint, Ty)>\n }\n \n /**\n@@ -1407,7 +1407,7 @@ pub struct StructBaseInfo<'a> {\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             ty: ty::t,\n+                             ty: Ty,\n                              discr: ty::Disr,\n                              fields: &[(uint, &ast::Expr)],\n                              optbase: Option<StructBaseInfo>,\n@@ -1572,9 +1572,9 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               box_ty: ty::t,\n+                               box_ty: Ty,\n                                contents: &ast::Expr,\n-                               contents_ty: ty::t)\n+                               contents_ty: Ty)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n@@ -1635,11 +1635,11 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // and the other not.\n fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  binop_expr: &ast::Expr,\n-                                 binop_ty: ty::t,\n+                                 binop_ty: Ty,\n                                  op: ast::BinOp,\n-                                 lhs_t: ty::t,\n+                                 lhs_t: Ty,\n                                  lhs: ValueRef,\n-                                 rhs_t: ty::t,\n+                                 rhs_t: Ty,\n                                  rhs: ValueRef)\n                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n@@ -1907,7 +1907,7 @@ pub enum cast_kind {\n     cast_other,\n }\n \n-pub fn cast_type_kind(tcx: &ty::ctxt, t: ty::t) -> cast_kind {\n+pub fn cast_type_kind(tcx: &ty::ctxt, t: Ty) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n@@ -1927,7 +1927,7 @@ pub fn cast_type_kind(tcx: &ty::ctxt, t: ty::t) -> cast_kind {\n     }\n }\n \n-fn cast_is_noop(t_in: ty::t, t_out: ty::t) -> bool {\n+fn cast_is_noop(t_in: Ty, t_out: Ty) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n@@ -2196,7 +2196,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn deref_owned_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        expr: &ast::Expr,\n                                        datum: Datum<Expr>,\n-                                       content_ty: ty::t)\n+                                       content_ty: Ty)\n                                        -> DatumBlock<'blk, 'tcx, Expr> {\n         /*!\n          * We microoptimize derefs of owned pointers a bit here."}, {"sha": "78a0fc08fbced0cf49b24070d874e5ea264417cb", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -23,7 +23,7 @@ use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n use middle::ty::FnSig;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::subst::Subst;\n use std::cmp;\n use libc::c_uint;\n@@ -161,7 +161,7 @@ pub fn register_static(ccx: &CrateContext,\n     }\n }\n \n-pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n+pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: Ty,\n                                 name: &str) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n@@ -201,11 +201,11 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n }\n \n pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     callee_ty: ty::t,\n+                                     callee_ty: Ty,\n                                      llfn: ValueRef,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<ty::t> )\n+                                     passed_arg_tys: Vec<Ty> )\n                                      -> Block<'blk, 'tcx> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n@@ -484,7 +484,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n // correct code in the first place, but this is much simpler.\n \n pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n-                                     t: ty::t,\n+                                     t: Ty,\n                                      name: &str)\n                                      -> ValueRef {\n     let tys = foreign_types_for_fn_ty(ccx, t);\n@@ -593,7 +593,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                             llrustfn: ValueRef,\n                             llwrapfn: ValueRef,\n                             tys: &ForeignTypes,\n-                            t: ty::t) {\n+                            t: Ty) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx();\n@@ -832,7 +832,7 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n     }\n }\n \n-fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n+fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[Ty])\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -862,7 +862,7 @@ fn foreign_types_for_id(ccx: &CrateContext,\n }\n \n fn foreign_types_for_fn_ty(ccx: &CrateContext,\n-                           ty: ty::t) -> ForeignTypes {\n+                           ty: Ty) -> ForeignTypes {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n@@ -934,7 +934,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     }\n }\n \n-pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n+pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: Ty) -> Type {\n     lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n }\n "}, {"sha": "ea17f65dd65e0e92837e08de572e97a69cf7746c", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -34,7 +34,7 @@ use trans::machine::*;\n use trans::tvec;\n use trans::type_::Type;\n use trans::type_of::{type_of, sizing_type_of, align_of};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n@@ -62,7 +62,7 @@ pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n }\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n-                                          content_ty: ty::t) -> Block<'blk, 'tcx> {\n+                                          content_ty: Ty) -> Block<'blk, 'tcx> {\n     assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -76,7 +76,7 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n     }\n }\n \n-pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n+pub fn get_drop_glue_type(ccx: &CrateContext, t: Ty) -> Ty {\n     let tcx = ccx.tcx();\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n@@ -103,7 +103,7 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n \n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n-                           t: ty::t,\n+                           t: Ty,\n                            source_location: Option<NodeInfo>)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n@@ -131,7 +131,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n-                                     t: ty::t,\n+                                     t: Ty,\n                                      source_location: Option<NodeInfo>)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n@@ -140,7 +140,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     drop_ty(bcx, vp, t, source_location)\n }\n \n-pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n+pub fn get_drop_glue(ccx: &CrateContext, t: Ty) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -185,7 +185,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n }\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                      t: ty::t,\n+                                      t: Ty,\n                                       v0: ValueRef,\n                                       dtor_did: ast::DefId,\n                                       class_did: ast::DefId,\n@@ -205,7 +205,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 t: ty::t,\n+                                 t: Ty,\n                                  v0: ValueRef,\n                                  dtor_did: ast::DefId,\n                                  class_did: ast::DefId,\n@@ -297,7 +297,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n+fn size_and_align_of_dst(bcx: Block, t :Ty, info: ValueRef) -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n@@ -352,7 +352,7 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n@@ -477,7 +477,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n+pub fn declare_tydesc(ccx: &CrateContext, t: Ty) -> tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n     assert!(!ccx.finished_tydescs().get());\n@@ -514,7 +514,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> tydesc_info {\n     }\n }\n \n-fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n+fn declare_generic_glue(ccx: &CrateContext, t: Ty, llfnty: Type,\n                         name: &str) -> (String, ValueRef) {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n@@ -527,9 +527,9 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n }\n \n fn make_generic_glue(ccx: &CrateContext,\n-                     t: ty::t,\n+                     t: Ty,\n                      llfn: ValueRef,\n-                     helper: for<'blk, 'tcx> |Block<'blk, 'tcx>, ValueRef, ty::t|\n+                     helper: for<'blk, 'tcx> |Block<'blk, 'tcx>, ValueRef, Ty|\n                                               -> Block<'blk, 'tcx>,\n                      name: &str)\n                      -> ValueRef {"}, {"sha": "8a523525ce1302dcc4972eec62807f3e4374d91a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -28,7 +28,7 @@ use trans::type_of;\n use trans::machine;\n use trans::machine::llsize_of;\n use trans::type_::Type;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n@@ -136,7 +136,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n }\n \n pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::NodeId,\n-                                        callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n+                                        callee_ty: Ty, cleanup_scope: cleanup::CustomScopeIndex,\n                                         args: callee::CallArgs, dest: expr::Dest,\n                                         substs: subst::Substs, call_info: NodeInfo)\n                                         -> Result<'blk, 'tcx> {\n@@ -554,7 +554,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n }\n \n fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n-                  tp_ty: ty::t, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n+                  tp_ty: Ty, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -582,7 +582,7 @@ fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n                       C_bool(ccx, volatile)], None)\n }\n \n-fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: ty::t,\n+fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: Ty,\n                     dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -607,7 +607,7 @@ fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> Value\n     Call(bcx, llfn, &[val, y], None)\n }\n \n-fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: ty::t,\n+fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: Ty,\n                            a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n "}, {"sha": "ae36a7a26227f0d01ca6fa71e24733191a7ce6b7", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -30,7 +30,7 @@ use trans::glue;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -424,7 +424,7 @@ fn combine_impl_and_methods_tps(bcx: Block,\n }\n \n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  method_ty: ty::t,\n+                                  method_ty: Ty,\n                                   n_method: uint,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n@@ -468,7 +468,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 callee_ty: ty::t,\n+                                                 callee_ty: Ty,\n                                                  n_method: uint,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n@@ -527,7 +527,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n /// This will hopefully change now that DST is underway.\n pub fn get_vtable(bcx: Block,\n-                  box_ty: ty::t,\n+                  box_ty: Ty,\n                   trait_ref: Rc<ty::TraitRef>)\n                   -> ValueRef\n {"}, {"sha": "3dfa3e10e2601eadbd5761f7fcdd14f4b6e35b42", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -20,7 +20,7 @@ use trans::base::{trans_fn, decl_internal_rust_fn};\n use trans::base;\n use trans::common::*;\n use trans::foreign;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -286,5 +286,5 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n #[deriving(PartialEq, Eq, Hash, Show)]\n pub struct MonoId {\n     pub def: ast::DefId,\n-    pub params: subst::VecPerParamSpace<ty::t>\n+    pub params: subst::VecPerParamSpace<Ty>\n }"}, {"sha": "1d34ad29a23114781cd9d987b12fb65806975c6d", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -27,7 +27,7 @@ use trans::machine;\n use trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::ty_to_string;\n \n use syntax::ast;\n@@ -52,7 +52,7 @@ pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef\n \n pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           vptr: ValueRef,\n-                                          unit_ty: ty::t,\n+                                          unit_ty: Ty,\n                                           should_deallocate: bool)\n                                           -> Block<'blk, 'tcx> {\n     let not_null = IsNotNull(bcx, vptr);\n@@ -90,7 +90,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub struct VecTypes {\n-    pub unit_ty: ty::t,\n+    pub unit_ty: Ty,\n     pub llunit_ty: Type,\n     pub llunit_size: ValueRef,\n     pub llunit_alloc_size: u64\n@@ -342,7 +342,7 @@ pub fn vec_types_from_expr(bcx: Block, vec_expr: &ast::Expr) -> VecTypes {\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types(bcx: Block, unit_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: Block, unit_ty: Ty) -> VecTypes {\n     let ccx = bcx.ccx();\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n@@ -404,7 +404,7 @@ fn get_slice_base_and_len(bcx: Block,\n \n pub fn get_base_and_len(bcx: Block,\n                         llval: ValueRef,\n-                        vec_ty: ty::t)\n+                        vec_ty: Ty)\n                         -> (ValueRef, ValueRef) {\n     /*!\n      * Converts a vector into the slice pair.  The vector should be\n@@ -437,7 +437,7 @@ pub fn get_base_and_len(bcx: Block,\n }\n \n pub type iter_vec_block<'a, 'blk, 'tcx> =\n-    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n+    |Block<'blk, 'tcx>, ValueRef, Ty|: 'a -> Block<'blk, 'tcx>;\n \n pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      data_ptr: ValueRef,\n@@ -497,7 +497,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     data_ptr: ValueRef,\n-                                    unit_ty: ty::t,\n+                                    unit_ty: Ty,\n                                     len: ValueRef,\n                                     f: iter_vec_block<'a, 'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {"}, {"sha": "b466aecf7bbde4f7b3895687450fc6c426cb046a", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -17,7 +17,7 @@ use trans::adt;\n use trans::common::*;\n use trans::foreign;\n use trans::machine;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux;\n use util::ppaux::Repr;\n \n@@ -31,23 +31,23 @@ use syntax::ast;\n fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n                                       llet: Type,\n                                       size: machine::llsize,\n-                                      scapegoat: ty::t) {\n+                                      scapegoat: Ty) {\n     let esz = machine::llsize_of_alloc(ccx, llet);\n     match esz.checked_mul(size) {\n         Some(n) if n < ccx.max_obj_size() => {}\n         _ => { ccx.report_overbig_object(scapegoat) }\n     }\n }\n \n-pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: Ty) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n \n-pub fn return_uses_outptr(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn return_uses_outptr(ccx: &CrateContext, ty: Ty) -> bool {\n     !type_is_immediate(ccx, ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n+pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: Ty) -> Type {\n     let llty = arg_type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n@@ -60,9 +60,9 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n /// functions, these are simply the types of the arguments. For functions with\n /// the `RustCall` ABI, however, this untuples the arguments of the function.\n pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n-                                      inputs: &[ty::t],\n+                                      inputs: &[Ty],\n                                       abi: abi::Abi)\n-                                      -> Vec<ty::t> {\n+                                      -> Vec<Ty> {\n     if abi != abi::RustCall {\n         return inputs.iter().map(|x| (*x).clone()).collect()\n     }\n@@ -96,7 +96,7 @@ pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n \n pub fn type_of_rust_fn(cx: &CrateContext,\n                        llenvironment_type: Option<Type>,\n-                       inputs: &[ty::t],\n+                       inputs: &[Ty],\n                        output: ty::FnOutput,\n                        abi: abi::Abi)\n                        -> Type {\n@@ -138,7 +138,7 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, fty: Ty) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx,\n@@ -175,7 +175,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     type behind pointers. This can help prevent infinite loops for\n //     recursive types. For example, enum types rely on this behavior.\n \n-pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n+pub fn sizing_type_of(cx: &CrateContext, t: Ty) -> Type {\n     match cx.llsizingtypes().borrow().get(&t).cloned() {\n         Some(t) => return t,\n         None => ()\n@@ -247,7 +247,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     llsizingty\n }\n \n-pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n+pub fn arg_type_of(cx: &CrateContext, t: Ty) -> Type {\n     if ty::type_is_bool(t) {\n         Type::i1(cx)\n     } else {\n@@ -256,8 +256,8 @@ pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    fn type_of_unsize_info(cx: &CrateContext, t: ty::t) -> Type {\n+pub fn type_of(cx: &CrateContext, t: Ty) -> Type {\n+    fn type_of_unsize_info(cx: &CrateContext, t: Ty) -> Type {\n         // It is possible to end up here with a sized type. This happens with a\n         // struct which might be unsized, but is monomorphised to a sized type.\n         // In this case we'll fake a fat pointer with no unsize info (we use 0).\n@@ -433,7 +433,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     return llty;\n }\n \n-pub fn align_of(cx: &CrateContext, t: ty::t) -> machine::llalign {\n+pub fn align_of(cx: &CrateContext, t: Ty) -> machine::llalign {\n     let llty = sizing_type_of(cx, t);\n     machine::llalign_of_min(cx, llty)\n }\n@@ -448,7 +448,7 @@ pub enum named_ty {\n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::DefId,\n-                      tps: &[ty::t])\n+                      tps: &[Ty])\n                       -> String\n {\n     let name = match what {\n@@ -472,7 +472,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     }\n }\n \n-pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n+pub fn type_of_dtor(ccx: &CrateContext, self_ty: Ty) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n     Type::func(&[self_ty], &Type::void(ccx))\n }"}, {"sha": "48cec8bfecbee3db89540f353640c2e982ede3ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9706d8f6022d3e4f4e2a247a10c3408d4fcb844c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9706d8f6022d3e4f4e2a247a10c3408d4fcb844c", "patch": "@@ -1257,7 +1257,7 @@ impl Clean<Type> for ast::Ty {\n     }\n }\n \n-impl Clean<Type> for ty::t {\n+impl Clean<Type> for Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n             ty::ty_bool => Primitive(Bool),\n@@ -2255,7 +2255,7 @@ impl Clean<Item> for ast::Typedef {\n }\n \n fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n-               t: ty::t, name: &str,\n+               t: Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {\n     let did = match did {\n         Some(did) => did,"}]}