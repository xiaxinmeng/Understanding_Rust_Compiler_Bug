{"sha": "ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMzIxMzc0N2QxYmNkNzIyZTdhMTIzNmNkNTI4Y2QzMmUxYmFmY2I=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-04-15T14:14:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-04-15T14:14:25Z"}, "message": "Merge pull request #1467 from philipturnbull/option_map_nil_fn\n\nLint `Option.map(f)` where f returns unit", "tree": {"sha": "85dd9f467b5be447a778baf44816512626367504", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85dd9f467b5be447a778baf44816512626367504"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa015BCRBK7hj4Ov3rIwAAdHIIADdRXKB1r/oEVKGuX66YuncF\nXZeUt82gVGcVlICZNd5Qac3uLc4l/G3ClfKDfrvhYdzTVx+akWXxXxK7wnsiGzv7\n1tgEocW7FtF/u4q0u/dDQ0rdbu5+Pi77b4mBsoCZiQoSqFr6BNekVmL3itKbNrq4\nSY8KfMaJXvV6kN5r+Py7cHFZiLt7e3gBxdCYG01sZbwEBHuhMXlmcFI8fqkS7b8J\nMSpVLGRiysbOp4btW2eCPf37E+812LsX+eubNaxSLBLL/HGoqAd7lMiA9/P+47aX\n8dgIYjwCdiCh4fRaErO+SRic0A5vzHz0iWTar4Q+/dPHKpDPim3WlOHQGAl38hY=\n=n3NK\n-----END PGP SIGNATURE-----\n", "payload": "tree 85dd9f467b5be447a778baf44816512626367504\nparent 9dc9487567e7e1be7319c190401135d174ff35a8\nparent 26b9911e079cc1e8fa076ff704ab4785f02aa53d\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1523801665 +0200\ncommitter GitHub <noreply@github.com> 1523801665 +0200\n\nMerge pull request #1467 from philipturnbull/option_map_nil_fn\n\nLint `Option.map(f)` where f returns unit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "html_url": "https://github.com/rust-lang/rust/commit/ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dc9487567e7e1be7319c190401135d174ff35a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc9487567e7e1be7319c190401135d174ff35a8", "html_url": "https://github.com/rust-lang/rust/commit/9dc9487567e7e1be7319c190401135d174ff35a8"}, {"sha": "26b9911e079cc1e8fa076ff704ab4785f02aa53d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b9911e079cc1e8fa076ff704ab4785f02aa53d", "html_url": "https://github.com/rust-lang/rust/commit/26b9911e079cc1e8fa076ff704ab4785f02aa53d"}], "stats": {"total": 1080, "additions": 1076, "deletions": 4}, "files": [{"sha": "1d69de699968fd84cac2d8453c7803e11b2e09aa", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -710,6 +710,7 @@ All notable changes to this project will be documented in this file.\n [`nonsensical_open_options`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#ok_expect\n+[`map_unit_fn`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#map_unit_fn\n [`op_ref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#op_ref\n [`option_map_or_none`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unwrap_or`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_unwrap_or"}, {"sha": "bdbdff92d3c35f5c1527cc17e60fd3ccf0181e1a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -145,6 +145,7 @@ pub mod lifetimes;\n pub mod literal_representation;\n pub mod loops;\n pub mod map_clone;\n+pub mod map_unit_fn;\n pub mod matches;\n pub mod mem_forget;\n pub mod methods;\n@@ -405,6 +406,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box question_mark::QuestionMarkPass);\n     reg.register_late_lint_pass(box suspicious_trait_impl::SuspiciousImpl);\n     reg.register_late_lint_pass(box redundant_field_names::RedundantFieldNames);\n+    reg.register_late_lint_pass(box map_unit_fn::Pass);\n \n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n@@ -441,6 +443,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         if_not_else::IF_NOT_ELSE,\n         infinite_iter::MAYBE_INFINITE_ITER,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n+        map_unit_fn::OPTION_MAP_UNIT_FN,\n+        map_unit_fn::RESULT_MAP_UNIT_FN,\n         matches::SINGLE_MATCH_ELSE,\n         methods::FILTER_MAP,\n         methods::OPTION_MAP_UNWRAP_OR,"}, {"sha": "7defccf4697c4b0840b936db8fb675ee9a68dfe9", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,251 @@\n+use rustc::hir;\n+use rustc::lint::*;\n+use rustc::ty;\n+use syntax::codemap::Span;\n+use utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n+use utils::paths;\n+\n+#[derive(Clone)]\n+pub struct Pass;\n+\n+/// **What it does:** Checks for usage of `option.map(f)` where f is a function\n+/// or closure that returns the unit type.\n+///\n+/// **Why is this bad?** Readability, this can be written more clearly with\n+/// an if let statement\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let x: Option<&str> = do_stuff();\n+/// x.map(log_err_msg);\n+/// x.map(|msg| log_err_msg(format_msg(msg)))\n+/// ```\n+///\n+/// The correct use would be:\n+///\n+/// ```rust\n+/// let x: Option<&str> = do_stuff();\n+/// if let Some(msg) = x {\n+///     log_err_msg(msg)\n+/// }\n+/// if let Some(msg) = x {\n+///     log_err_msg(format_msg(msg))\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub OPTION_MAP_UNIT_FN,\n+    complexity,\n+    \"using `option.map(f)`, where f is a function or closure that returns ()\"\n+}\n+\n+/// **What it does:** Checks for usage of `result.map(f)` where f is a function\n+/// or closure that returns the unit type.\n+///\n+/// **Why is this bad?** Readability, this can be written more clearly with\n+/// an if let statement\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let x: Result<&str, &str> = do_stuff();\n+/// x.map(log_err_msg);\n+/// x.map(|msg| log_err_msg(format_msg(msg)))\n+/// ```\n+///\n+/// The correct use would be:\n+///\n+/// ```rust\n+/// let x: Result<&str, &str> = do_stuff();\n+/// if let Ok(msg) = x {\n+///     log_err_msg(msg)\n+/// }\n+/// if let Ok(msg) = x {\n+///     log_err_msg(format_msg(msg))\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub RESULT_MAP_UNIT_FN,\n+    complexity,\n+    \"using `result.map(f)`, where f is a function or closure that returns ()\"\n+}\n+\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN)\n+    }\n+}\n+\n+fn is_unit_type(ty: ty::Ty) -> bool {\n+    match ty.sty {\n+        ty::TyTuple(slice) => slice.is_empty(),\n+        ty::TyNever => true,\n+        _ => false,\n+    }\n+}\n+\n+fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n+    let ty = cx.tables.expr_ty(expr);\n+\n+    if let ty::TyFnDef(id, _) = ty.sty {\n+        if let Some(fn_type) = cx.tcx.fn_sig(id).no_late_bound_regions() {\n+            return is_unit_type(fn_type.output());\n+        }\n+    }\n+    false\n+}\n+\n+fn is_unit_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+    is_unit_type(cx.tables.expr_ty(expr))\n+}\n+\n+/// The expression inside a closure may or may not have surrounding braces and\n+/// semicolons, which causes problems when generating a suggestion. Given an\n+/// expression that evaluates to '()' or '!', recursively remove useless braces\n+/// and semi-colons until is suitable for including in the suggestion template\n+fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n+    if !is_unit_expression(cx, expr) {\n+        return None;\n+    }\n+\n+    match expr.node {\n+        hir::ExprCall(_, _) |\n+        hir::ExprMethodCall(_, _, _) => {\n+            // Calls can't be reduced any more\n+            Some(expr.span)\n+        },\n+        hir::ExprBlock(ref block) => {\n+            match (&block.stmts[..], block.expr.as_ref()) {\n+                (&[], Some(inner_expr)) => {\n+                    // If block only contains an expression,\n+                    // reduce `{ X }` to `X`\n+                    reduce_unit_expression(cx, inner_expr)\n+                },\n+                (&[ref inner_stmt], None) => {\n+                    // If block only contains statements,\n+                    // reduce `{ X; }` to `X` or `X;`\n+                    match inner_stmt.node {\n+                        hir::StmtDecl(ref d, _) => Some(d.span),\n+                        hir::StmtExpr(ref e, _) => Some(e.span),\n+                        hir::StmtSemi(_, _) => Some(inner_stmt.span),\n+                    }\n+                },\n+                _ => {\n+                    // For closures that contain multiple statements\n+                    // it's difficult to get a correct suggestion span\n+                    // for all cases (multi-line closures specifically)\n+                    //\n+                    // We do not attempt to build a suggestion for those right now.\n+                    None\n+                }\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n+    if let hir::ExprClosure(_, ref decl, inner_expr_id, _, _) = expr.node {\n+        let body = cx.tcx.hir.body(inner_expr_id);\n+        let body_expr = &body.value;\n+\n+        if_chain! {\n+            if decl.inputs.len() == 1;\n+            if is_unit_expression(cx, body_expr);\n+            if let Some(binding) = iter_input_pats(&decl, body).next();\n+            then {\n+                return Some((binding, body_expr));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Builds a name for the let binding variable (var_arg)\n+///\n+/// `x.field` => `x_field`\n+/// `y` => `_y`\n+///\n+/// Anything else will return `_`.\n+fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n+    match &var_arg.node {\n+        hir::ExprField(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n+        hir::ExprPath(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n+        _ => \"_\".to_string()\n+    }\n+}\n+\n+fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n+    format!(\n+        \"called `map(f)` on an {0} value where `f` is a unit {1}\",\n+        map_type,\n+        function_type\n+    )\n+}\n+\n+fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+    let var_arg = &map_args[0];\n+    let fn_arg = &map_args[1];\n+\n+    let (map_type, variant, lint) =\n+        if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n+            (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n+        } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n+            (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n+        } else {\n+            return\n+        };\n+\n+    if is_unit_function(cx, fn_arg) {\n+        let msg = suggestion_msg(\"function\", map_type);\n+        let suggestion = format!(\"if let {0}({1}) = {2} {{ {3}(...) }}\",\n+                                 variant,\n+                                 let_binding_name(cx, var_arg),\n+                                 snippet(cx, var_arg.span, \"_\"),\n+                                 snippet(cx, fn_arg.span, \"_\"));\n+\n+        span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n+            db.span_approximate_suggestion(stmt.span, \"try this\", suggestion);\n+        });\n+    } else if let Some((binding, closure_expr)) = unit_closure(cx, fn_arg) {\n+        let msg = suggestion_msg(\"closure\", map_type);\n+\n+        span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n+            if let Some(reduced_expr_span) = reduce_unit_expression(cx, closure_expr) {\n+                let suggestion = format!(\"if let {0}({1}) = {2} {{ {3} }}\",\n+                                        variant,\n+                                        snippet(cx, binding.pat.span, \"_\"),\n+                                        snippet(cx, var_arg.span, \"_\"),\n+                                        snippet(cx, reduced_expr_span, \"_\"));\n+                db.span_suggestion(stmt.span, \"try this\", suggestion);\n+            } else {\n+                let suggestion = format!(\"if let {0}({1}) = {2} {{ ... }}\",\n+                                        variant,\n+                                        snippet(cx, binding.pat.span, \"_\"),\n+                                        snippet(cx, var_arg.span, \"_\"));\n+                db.span_approximate_suggestion(stmt.span, \"try this\", suggestion);\n+            }\n+        });\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+        if in_macro(stmt.span) {\n+            return;\n+        }\n+\n+        if let hir::StmtSemi(ref expr, _) = stmt.node {\n+            if let hir::ExprMethodCall(_, _, _) = expr.node {\n+                if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n+                    lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "797a871d72b8d14923a2e7e2683a4ceaab3e53f7", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -432,16 +432,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n-        path.segments.last().map(|seg| {\n+        if let Some(seg) = path.segments.last() {\n             if seg.name == \"NAN\" {\n                 span_lint(\n                     cx,\n                     CMP_NAN,\n                     expr.span,\n                     \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n-                );\n+                    );\n             }\n-        });\n+        }\n     }\n }\n "}, {"sha": "be84f44bfb10e80f970aaf83dd4095a30717f1e3", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(unknown_lints, unused, no_effect, redundant_closure_call, many_single_char_names, needless_pass_by_value)]\n+#![allow(unknown_lints, unused, no_effect, redundant_closure_call, many_single_char_names, needless_pass_by_value, option_map_unit_fn)]\n #![warn(redundant_closure, needless_borrow)]\n \n fn main() {"}, {"sha": "c4ee0ce9238047830cce9f17dd8a34b81da5d764", "filename": "tests/ui/map_unit_fn.stderr", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fmap_unit_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fmap_unit_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_unit_fn.stderr?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,210 @@\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:33:5\n+   |\n+33 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { do_nothing(...) }`\n+   |\n+   = note: `-D option-map-unit-fn` implied by `-D warnings`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:35:5\n+   |\n+35 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { do_nothing(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:37:5\n+   |\n+37 |     x.field.map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:43:5\n+   |\n+43 |     x.field.map(|value| x.do_option_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { x.do_option_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:45:5\n+   |\n+45 |     x.field.map(|value| { x.do_option_plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { x.do_option_plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:48:5\n+   |\n+48 |     x.field.map(|value| do_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:50:5\n+   |\n+50 |     x.field.map(|value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:52:5\n+   |\n+52 |     x.field.map(|value| { do_nothing(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:54:5\n+   |\n+54 |     x.field.map(|value| { { do_nothing(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:57:5\n+   |\n+57 |     x.field.map(|value| diverge(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:59:5\n+   |\n+59 |     x.field.map(|value| { diverge(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:61:5\n+   |\n+61 |     x.field.map(|value| { diverge(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:63:5\n+   |\n+63 |     x.field.map(|value| { { diverge(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:68:5\n+   |\n+68 |     x.field.map(|value| { let y = plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { let y = plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:70:5\n+   |\n+70 |     x.field.map(|value| { plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:72:5\n+   |\n+72 |     x.field.map(|value| { { plus_one(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:75:5\n+   |\n+75 |     x.field.map(|ref value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(ref value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:78:5\n+   |\n+78 |     x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:80:5\n+   |\n+80 |     x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:84:5\n+   |\n+84 |        x.field.map(|value| {\n+   |   _____^\n+   |  |_____|\n+   | ||\n+85 | ||         do_nothing(value);\n+86 | ||         do_nothing(value)\n+87 | ||     });\n+   | ||______^- help: try this: `if let Some(value) = x.field { ... }`\n+   | |_______|\n+   | \n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/map_unit_fn.rs:88:5\n+   |\n+88 |     x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:91:5\n+   |\n+91 |     Some(42).map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = Some(42) { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:92:5\n+   |\n+92 |     \"12\".parse::<i32>().ok().map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = \"12\".parse::<i32>().ok() { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:93:5\n+   |\n+93 |     Some(plus_one(1)).map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = Some(plus_one(1)) { do_nothing(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/map_unit_fn.rs:97:5\n+   |\n+97 |     y.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_y) = y { do_nothing(...) }`\n+\n+error: aborting due to 25 previous errors\n+"}, {"sha": "06531e29032601ea2dd197034039afd4cf04ee4d", "filename": "tests/ui/option_map_unit_fn.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Foption_map_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Foption_map_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unit_fn.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,100 @@\n+#![warn(option_map_unit_fn)]\n+#![allow(unused)]\n+\n+fn do_nothing<T>(_: T) {}\n+\n+fn diverge<T>(_: T) -> ! {\n+    panic!()\n+}\n+\n+fn plus_one(value: usize) -> usize {\n+    value + 1\n+}\n+\n+struct HasOption {\n+    field: Option<usize>,\n+}\n+\n+impl HasOption {\n+    fn do_option_nothing(self: &Self, value: usize) {}\n+\n+    fn do_option_plus_one(self: &Self, value: usize) -> usize {\n+        value + 1\n+    }\n+}\n+\n+fn option_map_unit_fn() {\n+    let x = HasOption { field: Some(10) };\n+\n+    x.field.map(plus_one);\n+    let _ : Option<()> = x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(diverge);\n+\n+    let captured = 10;\n+    if let Some(value) = x.field { do_nothing(value + captured) };\n+    let _ : Option<()> = x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| x.do_option_nothing(value + captured));\n+\n+    x.field.map(|value| { x.do_option_plus_one(value + captured); });\n+\n+\n+    x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| { do_nothing(value + captured) });\n+\n+    x.field.map(|value| { do_nothing(value + captured); });\n+\n+    x.field.map(|value| { { do_nothing(value + captured); } });\n+\n+\n+    x.field.map(|value| diverge(value + captured));\n+\n+    x.field.map(|value| { diverge(value + captured) });\n+\n+    x.field.map(|value| { diverge(value + captured); });\n+\n+    x.field.map(|value| { { diverge(value + captured); } });\n+\n+\n+    x.field.map(|value| plus_one(value + captured));\n+    x.field.map(|value| { plus_one(value + captured) });\n+    x.field.map(|value| { let y = plus_one(value + captured); });\n+\n+    x.field.map(|value| { plus_one(value + captured); });\n+\n+    x.field.map(|value| { { plus_one(value + captured); } });\n+\n+\n+    x.field.map(|ref value| { do_nothing(value + captured) });\n+\n+\n+    x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+\n+    x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+\n+    // Suggestion for the let block should be `{ ... }` as it's too difficult to build a\n+    // proper suggestion for these cases\n+    x.field.map(|value| {\n+        do_nothing(value);\n+        do_nothing(value)\n+    });\n+    x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+\n+    // The following should suggest `if let Some(_X) ...` as it's difficult to generate a proper let variable name for them\n+    Some(42).map(diverge);\n+    \"12\".parse::<i32>().ok().map(diverge);\n+    Some(plus_one(1)).map(do_nothing);\n+\n+    // Should suggest `if let Some(_y) ...` to not override the existing foo variable\n+    let y = Some(42);\n+    y.map(do_nothing);\n+}\n+\n+fn main() {\n+}"}, {"sha": "3ca57a65b3f3263fc4ccfb7cc1224174b0d7a6d3", "filename": "tests/ui/option_map_unit_fn.stderr", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Foption_map_unit_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Foption_map_unit_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unit_fn.stderr?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,210 @@\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:32:5\n+   |\n+32 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { do_nothing(...) }`\n+   |\n+   = note: `-D option-map-unit-fn` implied by `-D warnings`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:34:5\n+   |\n+34 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { do_nothing(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:36:5\n+   |\n+36 |     x.field.map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(x_field) = x.field { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:42:5\n+   |\n+42 |     x.field.map(|value| x.do_option_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { x.do_option_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:44:5\n+   |\n+44 |     x.field.map(|value| { x.do_option_plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { x.do_option_plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:47:5\n+   |\n+47 |     x.field.map(|value| do_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:49:5\n+   |\n+49 |     x.field.map(|value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:51:5\n+   |\n+51 |     x.field.map(|value| { do_nothing(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:53:5\n+   |\n+53 |     x.field.map(|value| { { do_nothing(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:56:5\n+   |\n+56 |     x.field.map(|value| diverge(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:58:5\n+   |\n+58 |     x.field.map(|value| { diverge(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:60:5\n+   |\n+60 |     x.field.map(|value| { diverge(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:62:5\n+   |\n+62 |     x.field.map(|value| { { diverge(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:67:5\n+   |\n+67 |     x.field.map(|value| { let y = plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { let y = plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:69:5\n+   |\n+69 |     x.field.map(|value| { plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:71:5\n+   |\n+71 |     x.field.map(|value| { { plus_one(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:74:5\n+   |\n+74 |     x.field.map(|ref value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(ref value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:77:5\n+   |\n+77 |     x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:79:5\n+   |\n+79 |     x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:83:5\n+   |\n+83 |        x.field.map(|value| {\n+   |   _____^\n+   |  |_____|\n+   | ||\n+84 | ||         do_nothing(value);\n+85 | ||         do_nothing(value)\n+86 | ||     });\n+   | ||______^- help: try this: `if let Some(value) = x.field { ... }`\n+   | |_______|\n+   | \n+\n+error: called `map(f)` on an Option value where `f` is a unit closure\n+  --> $DIR/option_map_unit_fn.rs:87:5\n+   |\n+87 |     x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:90:5\n+   |\n+90 |     Some(42).map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = Some(42) { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:91:5\n+   |\n+91 |     \"12\".parse::<i32>().ok().map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = \"12\".parse::<i32>().ok() { diverge(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:92:5\n+   |\n+92 |     Some(plus_one(1)).map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_) = Some(plus_one(1)) { do_nothing(...) }`\n+\n+error: called `map(f)` on an Option value where `f` is a unit function\n+  --> $DIR/option_map_unit_fn.rs:96:5\n+   |\n+96 |     y.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Some(_y) = y { do_nothing(...) }`\n+\n+error: aborting due to 25 previous errors\n+"}, {"sha": "8f3c1579987dcfe3a4e9c623362f44abfc13e0b9", "filename": "tests/ui/result_map_unit_fn.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fresult_map_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fresult_map_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn.rs?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,102 @@\n+#![warn(result_map_unit_fn)]\n+#![allow(unused)]\n+\n+fn do_nothing<T>(_: T) {}\n+\n+fn diverge<T>(_: T) -> ! {\n+    panic!()\n+}\n+\n+fn plus_one(value: usize) -> usize {\n+    value + 1\n+}\n+\n+struct HasResult {\n+    field: Result<usize, usize>,\n+}\n+\n+impl HasResult {\n+    fn do_result_nothing(self: &Self, value: usize) {}\n+\n+    fn do_result_plus_one(self: &Self, value: usize) -> usize {\n+        value + 1\n+    }\n+}\n+\n+fn result_map_unit_fn() {\n+    let x = HasResult { field: Ok(10) };\n+\n+    x.field.map(plus_one);\n+    let _ : Result<(), usize> = x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(diverge);\n+\n+    let captured = 10;\n+    if let Ok(value) = x.field { do_nothing(value + captured) };\n+    let _ : Result<(), usize> = x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| x.do_result_nothing(value + captured));\n+\n+    x.field.map(|value| { x.do_result_plus_one(value + captured); });\n+\n+\n+    x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| { do_nothing(value + captured) });\n+\n+    x.field.map(|value| { do_nothing(value + captured); });\n+\n+    x.field.map(|value| { { do_nothing(value + captured); } });\n+\n+\n+    x.field.map(|value| diverge(value + captured));\n+\n+    x.field.map(|value| { diverge(value + captured) });\n+\n+    x.field.map(|value| { diverge(value + captured); });\n+\n+    x.field.map(|value| { { diverge(value + captured); } });\n+\n+\n+    x.field.map(|value| plus_one(value + captured));\n+    x.field.map(|value| { plus_one(value + captured) });\n+    x.field.map(|value| { let y = plus_one(value + captured); });\n+\n+    x.field.map(|value| { plus_one(value + captured); });\n+\n+    x.field.map(|value| { { plus_one(value + captured); } });\n+\n+\n+    x.field.map(|ref value| { do_nothing(value + captured) });\n+\n+\n+    x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+\n+    x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+\n+    // Suggestion for the let block should be `{ ... }` as it's too difficult to build a\n+    // proper suggestion for these cases\n+    x.field.map(|value| {\n+        do_nothing(value);\n+        do_nothing(value)\n+    });\n+    x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+\n+    // The following should suggest `if let Ok(_X) ...` as it's difficult to generate a proper let variable name for them\n+    let res: Result<!, usize> = Ok(42).map(diverge);\n+    \"12\".parse::<i32>().map(diverge);\n+\n+    let res: Result<(), usize> = Ok(plus_one(1)).map(do_nothing);\n+\n+    // Should suggest `if let Ok(_y) ...` to not override the existing foo variable\n+    let y: Result<usize, usize> = Ok(42);\n+    y.map(do_nothing);\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "199f5e7cf97eb118b11a0f99ccc6401532cccb7f", "filename": "tests/ui/result_map_unit_fn.stderr", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fresult_map_unit_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae3213747d1bcd722e7a1236cd528cd32e1bafcb/tests%2Fui%2Fresult_map_unit_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn.stderr?ref=ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "patch": "@@ -0,0 +1,194 @@\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:32:5\n+   |\n+32 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { do_nothing(...) }`\n+   |\n+   = note: `-D result-map-unit-fn` implied by `-D warnings`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:34:5\n+   |\n+34 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { do_nothing(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:36:5\n+   |\n+36 |     x.field.map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { diverge(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:42:5\n+   |\n+42 |     x.field.map(|value| x.do_result_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { x.do_result_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:44:5\n+   |\n+44 |     x.field.map(|value| { x.do_result_plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { x.do_result_plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:47:5\n+   |\n+47 |     x.field.map(|value| do_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:49:5\n+   |\n+49 |     x.field.map(|value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:51:5\n+   |\n+51 |     x.field.map(|value| { do_nothing(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:53:5\n+   |\n+53 |     x.field.map(|value| { { do_nothing(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:56:5\n+   |\n+56 |     x.field.map(|value| diverge(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:58:5\n+   |\n+58 |     x.field.map(|value| { diverge(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:60:5\n+   |\n+60 |     x.field.map(|value| { diverge(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:62:5\n+   |\n+62 |     x.field.map(|value| { { diverge(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:67:5\n+   |\n+67 |     x.field.map(|value| { let y = plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { let y = plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:69:5\n+   |\n+69 |     x.field.map(|value| { plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:71:5\n+   |\n+71 |     x.field.map(|value| { { plus_one(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:74:5\n+   |\n+74 |     x.field.map(|ref value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(ref value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:77:5\n+   |\n+77 |     x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:79:5\n+   |\n+79 |     x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:83:5\n+   |\n+83 |        x.field.map(|value| {\n+   |   _____^\n+   |  |_____|\n+   | ||\n+84 | ||         do_nothing(value);\n+85 | ||         do_nothing(value)\n+86 | ||     });\n+   | ||______^- help: try this: `if let Ok(value) = x.field { ... }`\n+   | |_______|\n+   | \n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:87:5\n+   |\n+87 |     x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:91:5\n+   |\n+91 |     \"12\".parse::<i32>().map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(_) = \"12\".parse::<i32>() { diverge(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:97:5\n+   |\n+97 |     y.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(_y) = y { do_nothing(...) }`\n+\n+error: aborting due to 23 previous errors\n+"}]}