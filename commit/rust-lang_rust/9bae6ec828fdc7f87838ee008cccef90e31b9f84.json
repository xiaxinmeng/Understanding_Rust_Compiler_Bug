{"sha": "9bae6ec828fdc7f87838ee008cccef90e31b9f84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYWU2ZWM4MjhmZGM3Zjg3ODM4ZWUwMDhjY2NlZjkwZTMxYjlmODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T06:06:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:16:14Z"}, "message": "core: Inherit possible string functionality\n\nThis moves as much allocation as possible from teh std::str module into\ncore::str. This includes essentially all non-allocating functionality, mostly\niterators and slicing and such.\n\nThis primarily splits the Str trait into only having the as_slice() method,\nadding a new StrAllocating trait to std::str which contains the relevant new\nallocation methods. This is a breaking change if any of the methods of \"trait\nStr\" were overriden. The old functionality can be restored by implementing both\nthe Str and StrAllocating traits.\n\n[breaking-change]", "tree": {"sha": "97ae34844c9949ff5a49a6b99ff70dd2f0cbf6c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97ae34844c9949ff5a49a6b99ff70dd2f0cbf6c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bae6ec828fdc7f87838ee008cccef90e31b9f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bae6ec828fdc7f87838ee008cccef90e31b9f84", "html_url": "https://github.com/rust-lang/rust/commit/9bae6ec828fdc7f87838ee008cccef90e31b9f84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bae6ec828fdc7f87838ee008cccef90e31b9f84/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544d90940166a9a83194801437dd37c0b1872c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/544d90940166a9a83194801437dd37c0b1872c86", "html_url": "https://github.com/rust-lang/rust/commit/544d90940166a9a83194801437dd37c0b1872c86"}], "stats": {"total": 4020, "additions": 2027, "deletions": 1993}, "files": [{"sha": "e89f51814025b740f455a31571de8f362cd66fa3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -71,4 +71,5 @@ pub mod option;\n pub mod raw;\n pub mod char;\n pub mod slice;\n+pub mod str;\n pub mod tuple;"}, {"sha": "9d9e12d0ad594c52629bc5e34bf3c9680ab201e9", "filename": "src/libcore/str.rs", "status": "added", "additions": 1861, "deletions": 0, "changes": 1861, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -0,0 +1,1861 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! String manipulation\n+//!\n+//! For more details, see std::str\n+\n+use cast::transmute;\n+use cast;\n+use char;\n+use clone::Clone;\n+use cmp::{Eq, TotalEq};\n+use container::Container;\n+use default::Default;\n+use iter::{Filter, Map, Iterator};\n+use iter::{Rev, DoubleEndedIterator, ExactSize};\n+use num::Saturating;\n+use option::{None, Option, Some};\n+use raw::Repr;\n+use slice::{ImmutableVector, Vector};\n+use slice;\n+\n+/*\n+Section: Creating a string\n+*/\n+\n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// returned as a '&str' instead of a '&[u8]'\n+///\n+/// Returns None if the slice is not utf-8.\n+pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n+    if is_utf8(v) {\n+        Some(unsafe { raw::from_utf8(v) })\n+    } else { None }\n+}\n+\n+/// Something that can be used to compare against a character\n+pub trait CharEq {\n+    /// Determine if the splitter should split at the given character\n+    fn matches(&mut self, char) -> bool;\n+    /// Indicate if this is only concerned about ASCII characters,\n+    /// which can allow for a faster implementation.\n+    fn only_ascii(&self) -> bool;\n+}\n+\n+impl CharEq for char {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+}\n+\n+impl<'a> CharEq for |char|: 'a -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl CharEq for extern \"Rust\" fn(char) -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl<'a> CharEq for &'a [char] {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&mut m| m.matches(c))\n+    }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n+/*\n+Section: Iterators\n+*/\n+\n+/// External iterator for a string's characters.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct Chars<'a> {\n+    /// The slice remaining to be iterated\n+    string: &'a str,\n+}\n+\n+impl<'a> Iterator<char> for Chars<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        // Decode the next codepoint, then update\n+        // the slice to be just the remaining part\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at(0);\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n+            }\n+            Some(ch)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, 0, next);\n+            }\n+            Some(ch)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// External iterator for a string's characters and their byte offsets.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct CharOffsets<'a> {\n+    /// The original string to be iterated\n+    string: &'a str,\n+    iter: Chars<'a>,\n+}\n+\n+impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, char)> {\n+        // Compute the byte offset by using the pointer offset between\n+        // the original string slice and the iterator's remaining part\n+        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n+        self.iter.next().map(|ch| (offset, ch))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(uint, char)> {\n+        self.iter.next_back().map(|ch| {\n+            let offset = self.iter.string.len() +\n+                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n+            (offset, ch)\n+        })\n+    }\n+}\n+\n+#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n+pub type RevChars<'a> = Rev<Chars<'a>>;\n+\n+#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n+pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n+\n+/// External iterator for a string's bytes.\n+/// Use with the `std::iter` module.\n+pub type Bytes<'a> =\n+    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n+\n+#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n+pub type RevBytes<'a> = Rev<Bytes<'a>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`.\n+#[deriving(Clone)]\n+pub struct CharSplits<'a, Sep> {\n+    /// The slice remaining to be iterated\n+    string: &'a str,\n+    sep: Sep,\n+    /// Whether an empty string at the end is allowed\n+    allow_trailing_empty: bool,\n+    only_ascii: bool,\n+    finished: bool,\n+}\n+\n+#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n+pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// splitting at most `count` times.\n+#[deriving(Clone)]\n+pub struct CharSplitsN<'a, Sep> {\n+    iter: CharSplits<'a, Sep>,\n+    /// The number of splits remaining\n+    count: uint,\n+    invert: bool,\n+}\n+\n+/// An iterator over the words of a string, separated by a sequence of whitespace\n+pub type Words<'a> =\n+    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+\n+/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n+pub type AnyLines<'a> =\n+    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n+\n+impl<'a, Sep> CharSplits<'a, Sep> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+            self.finished = true;\n+            Some(self.string)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let mut next_split = None;\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.bytes().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (idx, ch) in self.string.char_indices() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, 0, a);\n+                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n+for CharSplits<'a, Sep> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => if self.finished { return None }\n+            }\n+        }\n+        let len = self.string.len();\n+        let mut next_split = None;\n+\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.bytes().enumerate().rev() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (idx, ch) in self.string.char_indices().rev() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, b, len);\n+                self.string = raw::slice_unchecked(self.string, 0, a);\n+                Some(elt)\n+            },\n+            None => { self.finished = true; Some(self.string) }\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        } else {\n+            self.iter.get_end()\n+        }\n+    }\n+}\n+\n+/// An iterator over the start and end indices of the matches of a\n+/// substring within a larger string\n+#[deriving(Clone)]\n+pub struct MatchIndices<'a> {\n+    haystack: &'a str,\n+    needle: &'a str,\n+    position: uint,\n+}\n+\n+/// An iterator over the substrings of a string separated by a given\n+/// search string\n+#[deriving(Clone)]\n+pub struct StrSplits<'a> {\n+    it: MatchIndices<'a>,\n+    last_end: uint,\n+    finished: bool\n+}\n+\n+impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        // See Issue #1932 for why this is a naive search\n+        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n+        let mut match_start = 0;\n+        let mut match_i = 0;\n+\n+        while self.position < h_len {\n+            if self.haystack[self.position] == self.needle[match_i] {\n+                if match_i == 0 { match_start = self.position; }\n+                match_i += 1;\n+                self.position += 1;\n+\n+                if match_i == n_len {\n+                    // found a match!\n+                    return Some((match_start, self.position));\n+                }\n+            } else {\n+                // failed match, backtrack\n+                if match_i > 0 {\n+                    match_i = 0;\n+                    self.position = match_start;\n+                }\n+                self.position += 1;\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a> Iterator<&'a str> for StrSplits<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None; }\n+\n+        match self.it.next() {\n+            Some((from, to)) => {\n+                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                self.last_end = to;\n+                ret\n+            }\n+            None => {\n+                self.finished = true;\n+                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+            }\n+        }\n+    }\n+}\n+\n+/*\n+Section: Comparing strings\n+*/\n+\n+// share the implementation of the lang-item vs. non-lang-item\n+// eq_slice.\n+#[inline]\n+fn eq_slice_(a: &str, b: &str) -> bool {\n+    #[allow(ctypes)]\n+    extern { fn memcmp(s1: *i8, s2: *i8, n: uint) -> i32; }\n+    a.len() == b.len() && unsafe {\n+        memcmp(a.as_ptr() as *i8,\n+               b.as_ptr() as *i8,\n+               a.len()) == 0\n+    }\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(not(test))]\n+#[lang=\"str_eq\"]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    eq_slice_(a, b)\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(test)]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    eq_slice_(a, b)\n+}\n+\n+/// Bytewise string equality\n+#[cfg(not(test))]\n+#[lang=\"uniq_str_eq\"]\n+#[inline]\n+pub fn eq(a: &~str, b: &~str) -> bool {\n+    eq_slice(*a, *b)\n+}\n+\n+#[cfg(test)]\n+#[inline]\n+pub fn eq(a: &~str, b: &~str) -> bool {\n+    eq_slice(*a, *b)\n+}\n+\n+/*\n+Section: Misc\n+*/\n+\n+/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n+/// returning `true` in that case, or, if it is invalid, `false` with\n+/// `iter` reset such that it is pointing at the first byte in the\n+/// invalid sequence.\n+#[inline(always)]\n+fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n+    loop {\n+        // save the current thing we're pointing at.\n+        let old = *iter;\n+\n+        // restore the iterator we had at the start of this codepoint.\n+        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! next ( () => {\n+                match iter.next() {\n+                    Some(a) => *a,\n+                    // we needed data, but there was none: error!\n+                    None => err!()\n+                }\n+            });\n+\n+        let first = match iter.next() {\n+            Some(&b) => b,\n+            // we're at the end of the iterator and a codepoint\n+            // boundary at the same time, so this string is valid.\n+            None => return true\n+        };\n+\n+        // ASCII characters are always valid, so only large\n+        // bytes need more examination.\n+        if first >= 128 {\n+            let w = utf8_char_width(first);\n+            let second = next!();\n+            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //        first  E0 A0 80     last EF BF BF\n+            //   excluding surrogates codepoints  \\ud800 to  \\udfff\n+            //               ED A0 80 to       ED BF BF\n+            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            match w {\n+                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                3 => {\n+                    match (first, second, next!() & 192) {\n+                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n+                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                4 => {\n+                    match (first, second, next!() & 192, next!() & 192) {\n+                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                _ => err!()\n+            }\n+        }\n+    }\n+}\n+\n+/// Determines if a vector of bytes contains valid UTF-8.\n+pub fn is_utf8(v: &[u8]) -> bool {\n+    run_utf8_validation_iterator(&mut v.iter())\n+}\n+\n+/// Determines if a vector of `u16` contains valid UTF-16\n+pub fn is_utf16(v: &[u16]) -> bool {\n+    let mut it = v.iter();\n+    macro_rules! next ( ($ret:expr) => {\n+            match it.next() { Some(u) => *u, None => return $ret }\n+        }\n+    )\n+    loop {\n+        let u = next!(true);\n+\n+        match char::from_u32(u as u32) {\n+            Some(_) => {}\n+            None => {\n+                let u2 = next!(false);\n+                if u < 0xD7FF || u > 0xDBFF ||\n+                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from a vector\n+/// of `u16`s.\n+#[deriving(Clone)]\n+pub struct UTF16Items<'a> {\n+    iter: slice::Items<'a, u16>\n+}\n+/// The possibilities for values decoded from a `u16` stream.\n+#[deriving(Eq, TotalEq, Clone)]\n+pub enum UTF16Item {\n+    /// A valid codepoint.\n+    ScalarValue(char),\n+    /// An invalid surrogate without its pair.\n+    LoneSurrogate(u16)\n+}\n+\n+impl UTF16Item {\n+    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n+    /// replacement character (U+FFFD).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        match *self {\n+            ScalarValue(c) => c,\n+            LoneSurrogate(_) => '\\uFFFD'\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n+    fn next(&mut self) -> Option<UTF16Item> {\n+        let u = match self.iter.next() {\n+            Some(u) => *u,\n+            None => return None\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(LoneSurrogate(u))\n+        } else {\n+            // preserve state for rewinding.\n+            let old = self.iter;\n+\n+            let u2 = match self.iter.next() {\n+                Some(u2) => *u2,\n+                // eof\n+                None => return Some(LoneSurrogate(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.iter = old;\n+                return Some(LoneSurrogate(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(ScalarValue(unsafe {cast::transmute(c)}))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n+/// returning invalid surrogates as `LoneSurrogate`s.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// use std::str::{ScalarValue, LoneSurrogate};\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n+///            ~[ScalarValue('\ud834\udd1e'),\n+///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///              LoneSurrogate(0xDD1E),\n+///              ScalarValue('i'), ScalarValue('c'),\n+///              LoneSurrogate(0xD834)]);\n+/// ```\n+pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n+    UTF16Items { iter : v.iter() }\n+}\n+\n+/// Return a slice of `v` ending at (and not including) the first NUL\n+/// (0).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \"abcd\"\n+/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n+/// // no NULs so no change\n+/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n+///\n+/// // \"ab\\0d\"\n+/// v[2] = 0;\n+/// assert_eq!(str::truncate_utf16_at_nul(v),\n+///            &['a' as u16, 'b' as u16]);\n+/// ```\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => v.slice_to(i),\n+        None => v\n+    }\n+}\n+\n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n+0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n+];\n+\n+/// Given a first byte, determine how many bytes are in this UTF-8 character\n+#[inline]\n+pub fn utf8_char_width(b: u8) -> uint {\n+    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+}\n+\n+/// Struct that contains a `char` and the index of the first byte of\n+/// the next `char` in a string.  This can be used as a data structure\n+/// for iterating over the UTF-8 bytes of a string.\n+pub struct CharRange {\n+    /// Current `char`\n+    pub ch: char,\n+    /// Index of the first byte of the next `char`\n+    pub next: uint,\n+}\n+\n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n+)\n+\n+static TAG_CONT_U8: u8 = 128u8;\n+\n+/// Unsafe operations\n+pub mod raw {\n+    use cast;\n+    use container::Container;\n+    use iter::Iterator;\n+    use ptr::RawPtr;\n+    use raw::Slice;\n+    use slice::{ImmutableVector};\n+    use str::{is_utf8, StrSlice};\n+\n+    /// Converts a slice of bytes to a string slice without checking\n+    /// that the string contains valid UTF-8.\n+    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n+        cast::transmute(v)\n+    }\n+\n+    /// Form a slice from a C string. Unsafe because the caller must ensure the\n+    /// C string has the static lifetime, or else the return value may be\n+    /// invalidated later.\n+    pub unsafe fn c_str_to_static_slice(s: *i8) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s;\n+        let mut len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = s.offset(len as int);\n+        }\n+        let v = Slice { data: s, len: len };\n+        assert!(is_utf8(::cast::transmute(v)));\n+        ::cast::transmute(v)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Failure\n+    ///\n+    /// If begin is greater than end.\n+    /// If end is greater than the length of the string.\n+    #[inline]\n+    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n+        assert!(begin <= end);\n+        assert!(end <= s.len());\n+        slice_unchecked(s, begin, end)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check slice boundaries!\n+    #[inline]\n+    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n+        cast::transmute(Slice {\n+                data: s.as_ptr().offset(begin as int),\n+                len: end - begin,\n+            })\n+    }\n+}\n+\n+/*\n+Section: Trait implementations\n+*/\n+\n+#[cfg(not(test))]\n+#[allow(missing_doc)]\n+pub mod traits {\n+    use container::Container;\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use iter::Iterator;\n+    use option::{Some, None};\n+    use str::{Str, StrSlice, eq_slice};\n+\n+    impl<'a> TotalOrd for &'a str {\n+        #[inline]\n+        fn cmp(&self, other: & &'a str) -> Ordering {\n+            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    impl TotalOrd for ~str {\n+        #[inline]\n+        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'a> Eq for &'a str {\n+        #[inline]\n+        fn eq(&self, other: & &'a str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for ~str {\n+        #[inline]\n+        fn eq(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl<'a> TotalEq for &'a str {}\n+\n+    impl TotalEq for ~str {}\n+\n+    impl<'a> Ord for &'a str {\n+        #[inline]\n+        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n+    }\n+\n+    impl Ord for ~str {\n+        #[inline]\n+        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n+    }\n+\n+    impl<'a, S: Str> Equiv<S> for &'a str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'a, S: Str> Equiv<S> for ~str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub mod traits {}\n+\n+/// Any string that can be represented as a slice\n+pub trait Str {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a str;\n+}\n+\n+impl<'a> Str for &'a str {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str { *self }\n+}\n+\n+impl<'a> Str for ~str {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str { let s: &'a str = *self; s }\n+}\n+\n+impl<'a> Container for &'a str {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.repr().len\n+    }\n+}\n+\n+impl Container for ~str {\n+    #[inline]\n+    fn len(&self) -> uint { self.as_slice().len() }\n+}\n+\n+/// Methods for string slices\n+pub trait StrSlice<'a> {\n+    /// Returns true if one string contains another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The string to look for\n+    fn contains<'a>(&self, needle: &'a str) -> bool;\n+\n+    /// Returns true if a string contains a char.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The char to look for\n+    fn contains_char(&self, needle: char) -> bool;\n+\n+    /// An iterator over the characters of `self`. Note, this iterates\n+    /// over unicode code-points, not unicode graphemes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ```\n+    fn chars(&self) -> Chars<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>>;\n+\n+    /// An iterator over the bytes of `self`\n+    fn bytes(&self) -> Bytes<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    fn char_indices(&self) -> CharOffsets<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, restricted to splitting at most `count`\n+    /// times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n+    /// ```\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    ///\n+    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n+    ///\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+\n+    /// An iterator over the start and end indices of the disjoint\n+    /// matches of `sep` within `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies\n+    /// `self.slice(start, end) == sep`. For matches of `sep` within\n+    /// `self` that overlap, only the indicies corresponding to the\n+    /// first match are returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, ~[(1,4), (4,7)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n+    /// ```\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n+\n+    /// An iterator over the substrings of `self` separated by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n+    /// ```\n+    fn split_str(&self, &'a str) -> StrSplits<'a>;\n+\n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`). This does not include the empty string after a\n+    /// trailing `\\n`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    fn lines(&self) -> CharSplits<'a, char>;\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n+    /// empty trailing line.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines_any().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    fn lines_any(&self) -> AnyLines<'a>;\n+\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: ~[&str] = some_words.words().collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    fn words(&self) -> Words<'a>;\n+\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc\".is_whitespace());\n+    /// ```\n+    fn is_whitespace(&self) -> bool;\n+\n+    /// Returns true if the string contains only alphanumeric code\n+    /// points.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n+    fn is_alphanumeric(&self) -> bool;\n+\n+    /// Returns the number of Unicode code points (`char`) that a\n+    /// string holds.\n+    ///\n+    /// This does not perform any normalization, and is `O(n)`, since\n+    /// UTF-8 is a variable width encoding of code points.\n+    ///\n+    /// *Warning*: The number of code points in a string does not directly\n+    /// correspond to the number of visible characters or width of the\n+    /// visible text due to composing characters, and double- and\n+    /// zero-width ones.\n+    ///\n+    /// See also `.len()` for the byte length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// // composed forms of `\u00f6` and `\u00e9`\n+    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n+    /// // decomposed forms of `\u00f6` and `\u00e9`\n+    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n+    ///\n+    /// assert_eq!(c.char_len(), 15);\n+    /// assert_eq!(d.char_len(), 17);\n+    ///\n+    /// assert_eq!(c.len(), 21);\n+    /// assert_eq!(d.len(), 23);\n+    ///\n+    /// // the two strings *look* the same\n+    /// println!(\"{}\", c);\n+    /// println!(\"{}\", d);\n+    /// ```\n+    fn char_len(&self) -> uint;\n+\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Fails when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// See also `slice_to` and `slice_from` for slicing prefixes and\n+    /// suffixes of strings, and `slice_chars` for slicing based on\n+    /// code point counts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice(0, 1), \"L\");\n+    ///\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n+    ///\n+    /// // these will fail:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // s.slice(2, 3);\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // s.slice(1, 8);\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // s.slice(3, 100);\n+    /// ```\n+    fn slice(&self, begin: uint, end: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self.slice(begin, self.len())`.\n+    ///\n+    /// Fails when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_to` and `slice_chars`.\n+    fn slice_from(&self, begin: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self.slice(0, end)`.\n+    ///\n+    /// Fails when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_from` and `slice_chars`.\n+    fn slice_to(&self, end: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from the character range\n+    /// [`begin`..`end`).\n+    ///\n+    /// That is, start at the `begin`-th code point of the string and\n+    /// continue to the `end`-th code point. This does not detect or\n+    /// handle edge cases such as leaving a combining character as the\n+    /// first code point of the string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end)`.\n+    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n+    /// variants that use byte indices rather than code point\n+    /// indices.\n+    ///\n+    /// Fails if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// ```\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n+\n+    /// Returns true if `needle` is a prefix of the string.\n+    fn starts_with(&self, needle: &str) -> bool;\n+\n+    /// Returns true if `needle` is a suffix of the string.\n+    fn ends_with(&self, needle: &str) -> bool;\n+\n+    /// Returns a string with leading and trailing whitespace removed.\n+    fn trim(&self) -> &'a str;\n+\n+    /// Returns a string with leading whitespace removed.\n+    fn trim_left(&self) -> &'a str;\n+\n+    /// Returns a string with trailing whitespace removed.\n+    fn trim_right(&self) -> &'a str;\n+\n+    /// Returns a string with characters that match `to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n+    /// ```\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n+    /// ```\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n+    /// ```\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`)\n+    /// are considered to be boundaries.\n+    ///\n+    /// Fails if `index` is greater than `self.len()`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    fn is_char_boundary(&self, index: uint) -> bool;\n+\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// This example manually iterate through the characters of a\n+    /// string; this should normally by done by `.chars()` or\n+    /// `.char_indices`.\n+    ///\n+    /// ```rust\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// ## Output\n+    ///\n+    /// ```ignore\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next unicode character.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    fn char_range_at(&self, start: uint) -> CharRange;\n+\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n+\n+    /// Plucks the character starting at the `i`th byte of a string\n+    fn char_at(&self, i: uint) -> char;\n+\n+    /// Plucks the character ending at the `i`th byte of a string\n+    fn char_at_reverse(&self, i: uint) -> char;\n+\n+    /// Work with the byte buffer of a string as a byte slice.\n+    fn as_bytes(&self) -> &'a [u8];\n+\n+    /// Returns the byte index of the first character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// // the first space\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    ///\n+    /// // neither are found\n+    /// assert_eq!(s.find(&['1', '2']), None);\n+    /// ```\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    ///\n+    /// // the second space\n+    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    ///\n+    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// assert_eq!(s.rfind(&['1', '2']), None);\n+    /// ```\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n+    fn find_str(&self, &str) -> Option<uint>;\n+\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted. If the string does not contain any characters,\n+    /// a tuple of None and an empty string is returned instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char();\n+    /// assert_eq!(c, Some('L'));\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.slice_shift_char();\n+    /// assert_eq!(c, Some('\u00f6'));\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Fails if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"a\\nb\\nc\";\n+    /// let lines: ~[&str] = string.lines().collect();\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    fn subslice_offset(&self, inner: &str) -> uint;\n+\n+    /// Return an unsafe pointer to the strings buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    fn as_ptr(&self) -> *u8;\n+}\n+\n+impl<'a> StrSlice<'a> for &'a str {\n+    #[inline]\n+    fn contains<'a>(&self, needle: &'a str) -> bool {\n+        self.find_str(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn contains_char(&self, needle: char) -> bool {\n+        self.find(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn chars(&self) -> Chars<'a> {\n+        Chars{string: *self}\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> RevChars<'a> {\n+        self.chars().rev()\n+    }\n+\n+    #[inline]\n+    fn bytes(&self) -> Bytes<'a> {\n+        self.as_bytes().iter().map(|&b| b)\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> RevBytes<'a> {\n+        self.bytes().rev()\n+    }\n+\n+    #[inline]\n+    fn char_indices(&self) -> CharOffsets<'a> {\n+        CharOffsets{string: *self, iter: self.chars()}\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n+        self.char_indices().rev()\n+    }\n+\n+    #[inline]\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n+        CharSplits {\n+            string: *self,\n+            only_ascii: sep.only_ascii(),\n+            sep: sep,\n+            allow_trailing_empty: true,\n+            finished: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n+            iter: self.split(sep),\n+            count: count,\n+            invert: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n+        -> CharSplits<'a, Sep> {\n+        CharSplits {\n+            allow_trailing_empty: false,\n+            ..self.split(sep)\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n+        self.split(sep).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n+            iter: self.split(sep),\n+            count: count,\n+            invert: true,\n+        }\n+    }\n+\n+    #[inline]\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n+        assert!(!sep.is_empty())\n+        MatchIndices {\n+            haystack: *self,\n+            needle: sep,\n+            position: 0\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n+        StrSplits {\n+            it: self.match_indices(sep),\n+            last_end: 0,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn lines(&self) -> CharSplits<'a, char> {\n+        self.split_terminator('\\n')\n+    }\n+\n+    fn lines_any(&self) -> AnyLines<'a> {\n+        self.lines().map(|line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        })\n+    }\n+\n+    #[inline]\n+    fn words(&self) -> Words<'a> {\n+        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n+\n+    #[inline]\n+    fn char_len(&self) -> uint { self.chars().len() }\n+\n+    #[inline]\n+    fn slice(&self, begin: uint, end: uint) -> &'a str {\n+        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, begin, end) }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, begin: uint) -> &'a str {\n+        self.slice(begin, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a str {\n+        assert!(self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, 0, end) }\n+    }\n+\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n+        assert!(begin <= end);\n+        let mut count = 0;\n+        let mut begin_byte = None;\n+        let mut end_byte = None;\n+\n+        // This could be even more efficient by not decoding,\n+        // only finding the char boundaries\n+        for (idx, _) in self.char_indices() {\n+            if count == begin { begin_byte = Some(idx); }\n+            if count == end { end_byte = Some(idx); break; }\n+            count += 1;\n+        }\n+        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n+        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n+\n+        match (begin_byte, end_byte) {\n+            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn starts_with<'a>(&self, needle: &'a str) -> bool {\n+        let n = needle.len();\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+    }\n+\n+    #[inline]\n+    fn ends_with(&self, needle: &str) -> bool {\n+        let (m, n) = (self.len(), needle.len());\n+        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+    }\n+\n+    #[inline]\n+    fn trim(&self) -> &'a str {\n+        self.trim_left().trim_right()\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &'a str {\n+        self.trim_left_chars(char::is_whitespace)\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &'a str {\n+        self.trim_right_chars(char::is_whitespace)\n+    }\n+\n+    #[inline]\n+    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n+        };\n+        match cur.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => {\n+                let right = cur.char_range_at(i).next;\n+                unsafe { raw::slice_bytes(cur, 0, right) }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        match self.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(last) => {\n+                let next = self.char_range_at(last).next;\n+                unsafe { raw::slice_bytes(*self, 0u, next) }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_char_boundary(&self, index: uint) -> bool {\n+        if index == self.len() { return true; }\n+        let b = self[index];\n+        return b < 128u8 || b >= 192u8;\n+    }\n+\n+    #[inline]\n+    fn char_range_at(&self, i: uint) -> CharRange {\n+        if self[i] < 128u8 {\n+            return CharRange {ch: self[i] as char, next: i + 1 };\n+        }\n+\n+        // Multibyte case is a fn to allow char_range_at to inline cleanly\n+        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n+            let mut val = s[i] as u32;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            assert!((w != 0));\n+\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+\n+            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n+        }\n+\n+        return multibyte_char_range_at(*self, i);\n+    }\n+\n+    #[inline]\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+        let mut prev = start;\n+\n+        prev = prev.saturating_sub(1);\n+        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n+\n+        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+            // while there is a previous byte == 10......\n+            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n+                i -= 1u;\n+            }\n+\n+            let mut val = s[i] as u32;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            assert!((w != 0));\n+\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+\n+            return CharRange {ch: unsafe { transmute(val) }, next: i};\n+        }\n+\n+        return multibyte_char_range_at_reverse(*self, prev);\n+    }\n+\n+    #[inline]\n+    fn char_at(&self, i: uint) -> char {\n+        self.char_range_at(i).ch\n+    }\n+\n+    #[inline]\n+    fn char_at_reverse(&self, i: uint) -> char {\n+        self.char_range_at_reverse(i).ch\n+    }\n+\n+    #[inline]\n+    fn as_bytes(&self) -> &'a [u8] {\n+        unsafe { cast::transmute(*self) }\n+    }\n+\n+    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n+        if search.only_ascii() {\n+            self.bytes().position(|b| search.matches(b as char))\n+        } else {\n+            for (index, c) in self.char_indices() {\n+                if search.matches(c) { return Some(index); }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n+        if search.only_ascii() {\n+            self.bytes().rposition(|b| search.matches(b as char))\n+        } else {\n+            for (index, c) in self.char_indices().rev() {\n+                if search.matches(c) { return Some(index); }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n+        if needle.is_empty() {\n+            Some(0)\n+        } else {\n+            self.match_indices(needle)\n+                .next()\n+                .map(|(start, _end)| start)\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n+        if self.is_empty() {\n+            return (None, *self);\n+        } else {\n+            let CharRange {ch, next} = self.char_range_at(0u);\n+            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+            return (Some(ch), next_s);\n+        }\n+    }\n+\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        let a_start = self.as_ptr() as uint;\n+        let a_end = a_start + self.len();\n+        let b_start = inner.as_ptr() as uint;\n+        let b_end = b_start + inner.len();\n+\n+        assert!(a_start <= b_start);\n+        assert!(b_end <= a_end);\n+        b_start - a_start\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *u8 {\n+        self.repr().data\n+    }\n+}\n+\n+impl<'a> Default for &'a str {\n+    fn default() -> &'a str { \"\" }\n+}"}, {"sha": "9f683e45678bda3235e91a3aa34deaa3c936465b", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -493,11 +493,11 @@ use io;\n use iter;\n use iter::{Iterator, range};\n use num::Signed;\n-use option::{Option,Some,None};\n+use option::{Option, Some, None};\n use owned::Box;\n use repr;\n-use result::{Ok, Err};\n-use str::StrSlice;\n+use result::{Ok, Err, ResultUnwrap};\n+use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n use str;\n use slice::{Vector, ImmutableVector};\n use slice;\n@@ -1359,5 +1359,20 @@ impl Show for cmp::Ordering {\n     }\n }\n \n+impl<T: Copy + Show> Show for Cell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n+    }\n+}\n+\n+impl Show for UTF16Item {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            ScalarValue(c) => write!(f.buf, \"ScalarValue({})\", c),\n+            LoneSurrogate(u) => write!(f.buf, \"LoneSurrogate({})\", u),\n+        }\n+    }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "12adcee2f0fc81e15d8ac12d04d319f9e6205447", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use str::StrSlice;\n+    use str::StrAllocating;\n \n     #[test]\n     fn test_radix_base() {"}, {"sha": "58e0f4c717dedee7b0215058988737e33d0ccf2d", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -362,7 +362,7 @@ mod tests {\n     use prelude::*;\n     use num::ToStrRadix;\n     use option::{Some, None};\n-    use str::{Str,StrSlice};\n+    use str::Str;\n     use strbuf::StrBuf;\n     use slice::{Vector, ImmutableVector};\n     use self::test::Bencher;"}, {"sha": "cd069ddc1ea40df9ccecadd5d7f9008912528558", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -230,7 +230,7 @@ use option::{Option, Some, None};\n use owned::Box;\n use path::Path;\n use result::{Ok, Err, Result};\n-use str::StrSlice;\n+use str::{StrSlice, StrAllocating};\n use str;\n use uint;\n use unstable::finally::try_finally;"}, {"sha": "74f6944f102eab95ae3bee120607eaedf00ef07c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -428,7 +428,6 @@ impl Drop for Process {\n mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n-    use str::StrSlice;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n "}, {"sha": "da738a387b2cdbec8c416c96dad7c57468d1ce93", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -357,7 +357,6 @@ mod tests {\n     use super::*;\n     use owned::Box;\n     use task;\n-    use str::StrSlice;\n \n     #[test]\n     fn test_tls_multitask() {"}, {"sha": "47d316f75ab17e4e6c3045eb36670aca883731c5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -38,7 +38,7 @@ use ops::Drop;\n use result::{Err, Ok, Result};\n use ptr;\n use str;\n-use str::{Str, StrSlice};\n+use str::{Str, StrSlice, StrAllocating};\n use fmt;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use path::{Path, GenericPath};"}, {"sha": "f21fbe1b6e669d2ad8423e15b3e02bda21040eb1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -21,7 +21,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n-use str::{CharSplits, Str, StrVector, StrSlice};\n+use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n use strbuf::StrBuf;\n use vec::Vec;\n \n@@ -684,7 +684,7 @@ impl Path {\n         }\n     }\n \n-    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, StrBuf) {\n+    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, StrBuf) {\n         // make borrowck happy\n         let (prefix, val) = {\n             let prefix = parse_prefix(s.as_slice());\n@@ -842,7 +842,7 @@ impl Path {\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n-        let (prefix, path) = Path::normalize_(s);\n+        let (prefix, path) = Path::normalize_(s.as_slice());\n         self.repr = path;\n         self.prefix = prefix;\n         self.update_sepidx();"}, {"sha": "a8e26845c1b5c69ba7516c28115cbcdd3f2b0343", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -70,6 +70,7 @@ pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n+pub use str::{StrAllocating};\n pub use to_str::{ToStr, IntoStr};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};"}, {"sha": "380951772aeaaefd061849eab2859d164affca2d", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -606,6 +606,7 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n \n pub fn repr_to_str<T>(t: &T) -> ~str {\n     use str;\n+    use str::StrAllocating;\n     use io;\n \n     let mut result = io::MemWriter::new();"}, {"sha": "ac1692e6bb33ab327bebdbb2285ef976e01cfa56", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -70,7 +70,6 @@ mod imp {\n     use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n-    #[cfg(not(test))] use str::StrSlice;\n     #[cfg(not(test))] use ptr::RawPtr;\n \n     static mut global_args_ptr: uint = 0;"}, {"sha": "666c0a58b3351b1d2b37473a4491de3312661f80", "filename": "src/libstd/str.rs", "status": "modified", "additions": 133, "deletions": 1972, "changes": 2105, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -83,22 +83,24 @@ use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::Container;\n use fmt;\n use io::Writer;\n-use iter::{Iterator, FromIterator, Extendable, range};\n-use iter::{Filter, AdditiveIterator, Map};\n-use iter::{Rev, DoubleEndedIterator, ExactSize};\n-use libc;\n-use num::Saturating;\n+use iter::{Iterator, range, AdditiveIterator};\n use option::{None, Option, Some};\n use ptr;\n use from_str::FromStr;\n-use slice;\n use slice::{OwnedVector, ImmutableVector, MutableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n-use raw::Repr;\n use strbuf::StrBuf;\n \n+pub use core::str::{from_utf8, CharEq, Chars, CharOffsets, RevChars};\n+pub use core::str::{RevCharOffsets, Bytes, RevBytes, CharSplits, RevCharSplits};\n+pub use core::str::{CharSplitsN, Words, AnyLines, MatchIndices, StrSplits};\n+pub use core::str::{eq_slice, eq, is_utf8, is_utf16, UTF16Items};\n+pub use core::str::{UTF16Item, ScalarValue, LoneSurrogate, utf16_items};\n+pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n+pub use core::str::{Str, StrSlice};\n+\n /*\n Section: Creating a string\n */\n@@ -113,18 +115,6 @@ pub fn from_utf8_owned(vv: ~[u8]) -> Option<~str> {\n     }\n }\n \n-/// Converts a vector to a string slice without performing any allocations.\n-///\n-/// Once the slice has been validated as utf-8, it is transmuted in-place and\n-/// returned as a '&str' instead of a '&[u8]'\n-///\n-/// Returns None if the slice is not utf-8.\n-pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n-    if is_utf8(v) {\n-        Some(unsafe { raw::from_utf8(v) })\n-    } else { None }\n-}\n-\n impl FromStr for ~str {\n     #[inline]\n     fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }\n@@ -214,348 +204,10 @@ impl<'a, S: Str> StrVector for Vec<S> {\n     }\n }\n \n-/// Something that can be used to compare against a character\n-pub trait CharEq {\n-    /// Determine if the splitter should split at the given character\n-    fn matches(&mut self, char) -> bool;\n-    /// Indicate if this is only concerned about ASCII characters,\n-    /// which can allow for a faster implementation.\n-    fn only_ascii(&self) -> bool;\n-}\n-\n-impl CharEq for char {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { *self == c }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n-}\n-\n-impl<'a> CharEq for |char|: 'a -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl CharEq for extern \"Rust\" fn(char) -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl<'a> CharEq for &'a [char] {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&mut m| m.matches(c))\n-    }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool {\n-        self.iter().all(|m| m.only_ascii())\n-    }\n-}\n-\n /*\n Section: Iterators\n */\n \n-/// External iterator for a string's characters.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct Chars<'a> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n-}\n-\n-impl<'a> Iterator<char> for Chars<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        // Decode the next codepoint, then update\n-        // the slice to be just the remaining part\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at(0);\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n-            }\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, 0, next);\n-            }\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// External iterator for a string's characters and their byte offsets.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct CharOffsets<'a> {\n-    /// The original string to be iterated\n-    string: &'a str,\n-    iter: Chars<'a>,\n-}\n-\n-impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n-        // Compute the byte offset by using the pointer offset between\n-        // the original string slice and the iterator's remaining part\n-        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-        self.iter.next().map(|ch| (offset, ch))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let offset = self.iter.string.len() +\n-                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-            (offset, ch)\n-        })\n-    }\n-}\n-\n-#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n-pub type RevChars<'a> = Rev<Chars<'a>>;\n-\n-#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n-pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n-\n-/// External iterator for a string's bytes.\n-/// Use with the `std::iter` module.\n-pub type Bytes<'a> =\n-    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n-\n-#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n-pub type RevBytes<'a> = Rev<Bytes<'a>>;\n-\n-/// An iterator over the substrings of a string, separated by `sep`.\n-#[deriving(Clone)]\n-pub struct CharSplits<'a, Sep> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n-    sep: Sep,\n-    /// Whether an empty string at the end is allowed\n-    allow_trailing_empty: bool,\n-    only_ascii: bool,\n-    finished: bool,\n-}\n-\n-#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n-pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n-\n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// splitting at most `count` times.\n-#[deriving(Clone)]\n-pub struct CharSplitsN<'a, Sep> {\n-    iter: CharSplits<'a, Sep>,\n-    /// The number of splits remaining\n-    count: uint,\n-    invert: bool,\n-}\n-\n-/// An iterator over the words of a string, separated by a sequence of whitespace\n-pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n-\n-/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLines<'a> =\n-    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n-\n-impl<'a, Sep> CharSplits<'a, Sep> {\n-    #[inline]\n-    fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n-            self.finished = true;\n-            Some(self.string)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n-\n-        let mut next_split = None;\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n-            Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, 0, a);\n-                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n-for CharSplits<'a, Sep> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => if self.finished { return None }\n-            }\n-        }\n-        let len = self.string.len();\n-        let mut next_split = None;\n-\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate().rev() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices().rev() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n-            Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, b, len);\n-                self.string = raw::slice_unchecked(self.string, 0, a);\n-                Some(elt)\n-            },\n-            None => { self.finished = true; Some(self.string) }\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n-        } else {\n-            self.iter.get_end()\n-        }\n-    }\n-}\n-\n-/// An iterator over the start and end indices of the matches of a\n-/// substring within a larger string\n-#[deriving(Clone)]\n-pub struct MatchIndices<'a> {\n-    haystack: &'a str,\n-    needle: &'a str,\n-    position: uint,\n-}\n-\n-/// An iterator over the substrings of a string separated by a given\n-/// search string\n-#[deriving(Clone)]\n-pub struct StrSplits<'a> {\n-    it: MatchIndices<'a>,\n-    last_end: uint,\n-    finished: bool\n-}\n-\n-impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        // See Issue #1932 for why this is a naive search\n-        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n-        let mut match_start = 0;\n-        let mut match_i = 0;\n-\n-        while self.position < h_len {\n-            if self.haystack[self.position] == self.needle[match_i] {\n-                if match_i == 0 { match_start = self.position; }\n-                match_i += 1;\n-                self.position += 1;\n-\n-                if match_i == n_len {\n-                    // found a match!\n-                    return Some((match_start, self.position));\n-                }\n-            } else {\n-                // failed match, backtrack\n-                if match_i > 0 {\n-                    match_i = 0;\n-                    self.position = match_start;\n-                }\n-                self.position += 1;\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'a> Iterator<&'a str> for StrSplits<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None; }\n-\n-        match self.it.next() {\n-            Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n-                self.last_end = to;\n-                ret\n-            }\n-            None => {\n-                self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n-            }\n-        }\n-    }\n-}\n-\n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n     use iter::range;\n@@ -675,294 +327,10 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     result.into_owned()\n }\n \n-/*\n-Section: Comparing strings\n-*/\n-\n-// share the implementation of the lang-item vs. non-lang-item\n-// eq_slice.\n-#[inline]\n-fn eq_slice_(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && unsafe {\n-        libc::memcmp(a.as_ptr() as *libc::c_void,\n-                     b.as_ptr() as *libc::c_void,\n-                     a.len() as libc::size_t) == 0\n-    }\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(not(test))]\n-#[lang=\"str_eq\"]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(test)]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n-/// Bytewise string equality\n-#[cfg(not(test))]\n-#[lang=\"uniq_str_eq\"]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n-#[cfg(test)]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n /*\n Section: Misc\n */\n \n-/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n-/// returning `true` in that case, or, if it is invalid, `false` with\n-/// `iter` reset such that it is pointing at the first byte in the\n-/// invalid sequence.\n-#[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n-    loop {\n-        // save the current thing we're pointing at.\n-        let old = *iter;\n-\n-        // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err ( () => { {*iter = old; return false} });\n-        macro_rules! next ( () => {\n-                match iter.next() {\n-                    Some(a) => *a,\n-                    // we needed data, but there was none: error!\n-                    None => err!()\n-                }\n-            });\n-\n-        let first = match iter.next() {\n-            Some(&b) => b,\n-            // we're at the end of the iterator and a codepoint\n-            // boundary at the same time, so this string is valid.\n-            None => return true\n-        };\n-\n-        // ASCII characters are always valid, so only large\n-        // bytes need more examination.\n-        if first >= 128 {\n-            let w = utf8_char_width(first);\n-            let second = next!();\n-            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n-            //        first  C2 80        last DF BF\n-            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n-            //        first  E0 A0 80     last EF BF BF\n-            //   excluding surrogates codepoints  \\ud800 to  \\udfff\n-            //               ED A0 80 to       ED BF BF\n-            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n-            //        first  F0 90 80 80  last F4 8F BF BF\n-            //\n-            // Use the UTF-8 syntax from the RFC\n-            //\n-            // https://tools.ietf.org/html/rfc3629\n-            // UTF8-1      = %x00-7F\n-            // UTF8-2      = %xC2-DF UTF8-tail\n-            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n-            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n-            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n-            //               %xF4 %x80-8F 2( UTF8-tail )\n-            match w {\n-                2 => if second & 192 != TAG_CONT_U8 {err!()},\n-                3 => {\n-                    match (first, second, next!() & 192) {\n-                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n-                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n-                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n-                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n-                        _ => err!()\n-                    }\n-                }\n-                4 => {\n-                    match (first, second, next!() & 192, next!() & 192) {\n-                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n-                        _ => err!()\n-                    }\n-                }\n-                _ => err!()\n-            }\n-        }\n-    }\n-}\n-\n-/// Determines if a vector of bytes contains valid UTF-8.\n-pub fn is_utf8(v: &[u8]) -> bool {\n-    run_utf8_validation_iterator(&mut v.iter())\n-}\n-\n-#[inline(always)]\n-fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n-    let mut it = v.iter();\n-\n-    let ok = run_utf8_validation_iterator(&mut it);\n-    if ok {\n-        None\n-    } else {\n-        // work out how many valid bytes we've consumed\n-        // (run_utf8_validation_iterator resets the iterator to just\n-        // after the last good byte), which we can do because the\n-        // vector iterator size_hint is exact.\n-        let (remaining, _) = it.size_hint();\n-        Some(v.len() - remaining)\n-    }\n-}\n-\n-/// Determines if a vector of `u16` contains valid UTF-16\n-pub fn is_utf16(v: &[u16]) -> bool {\n-    let mut it = v.iter();\n-    macro_rules! next ( ($ret:expr) => {\n-            match it.next() { Some(u) => *u, None => return $ret }\n-        }\n-    )\n-    loop {\n-        let u = next!(true);\n-\n-        match char::from_u32(u as u32) {\n-            Some(_) => {}\n-            None => {\n-                let u2 = next!(false);\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator that decodes UTF-16 encoded codepoints from a vector\n-/// of `u16`s.\n-#[deriving(Clone)]\n-pub struct UTF16Items<'a> {\n-    iter: slice::Items<'a, u16>\n-}\n-/// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Eq, TotalEq, Clone, Show)]\n-pub enum UTF16Item {\n-    /// A valid codepoint.\n-    ScalarValue(char),\n-    /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16)\n-}\n-\n-impl UTF16Item {\n-    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n-    /// replacement character (U+FFFD).\n-    #[inline]\n-    pub fn to_char_lossy(&self) -> char {\n-        match *self {\n-            ScalarValue(c) => c,\n-            LoneSurrogate(_) => '\\uFFFD'\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n-    fn next(&mut self) -> Option<UTF16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter;\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n-                return Some(LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(ScalarValue(unsafe {cast::transmute(c)}))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n-/// returning invalid surrogates as `LoneSurrogate`s.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// use std::str::{ScalarValue, LoneSurrogate};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n-///            ~[ScalarValue('\ud834\udd1e'),\n-///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///              LoneSurrogate(0xDD1E),\n-///              ScalarValue('i'), ScalarValue('c'),\n-///              LoneSurrogate(0xD834)]);\n-/// ```\n-pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n-    UTF16Items { iter : v.iter() }\n-}\n-\n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \"abcd\"\n-/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n-/// // no NULs so no change\n-/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n-///\n-/// // \"ab\\0d\"\n-/// v[2] = 0;\n-/// assert_eq!(str::truncate_utf16_at_nul(v),\n-///            &['a' as u16, 'b' as u16]);\n-/// ```\n-pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-    match v.iter().position(|c| *c == 0) {\n-        // don't include the 0\n-        Some(i) => v.slice_to(i),\n-        None => v\n-    }\n-}\n-\n /// Decode a UTF-16 encoded vector `v` into a string, returning `None`\n /// if `v` contains any invalid data.\n ///\n@@ -1010,42 +378,6 @@ pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n-// https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8, ..256] = [\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n-0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n-3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n-4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n-];\n-\n-/// Given a first byte, determine how many bytes are in this UTF-8 character\n-#[inline]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n-}\n-\n-/// Struct that contains a `char` and the index of the first byte of\n-/// the next `char` in a string.  This can be used as a data structure\n-/// for iterating over the UTF-8 bytes of a string.\n-pub struct CharRange {\n-    /// Current `char`\n-    pub ch: char,\n-    /// Index of the first byte of the next `char`\n-    pub next: uint,\n-}\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -1071,13 +403,12 @@ static TAG_CONT_U8: u8 = 128u8;\n /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    let firstbad = match first_non_utf8_index(v) {\n-        None => return Slice(unsafe { cast::transmute(v) }),\n-        Some(i) => i\n-    };\n+    if is_utf8(v) {\n+        return Slice(unsafe { cast::transmute(v) })\n+    }\n \n     static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n-    let mut i = firstbad;\n+    let mut i = 0;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n         unsafe { *xs.unsafe_ref(i) }\n@@ -1101,7 +432,7 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n     // subseqidx is the index of the first byte of the subsequence we're looking at.\n     // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n     // them one by one.\n-    let mut subseqidx = firstbad;\n+    let mut subseqidx = 0;\n \n     while i < total {\n         let i_ = i;\n@@ -1282,7 +613,9 @@ impl<'a> Str for MaybeOwned<'a> {\n             Owned(ref s) => s.as_slice()\n         }\n     }\n+}\n \n+impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n     fn into_owned(self) -> ~str {\n         match self {\n@@ -1335,16 +668,17 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n /// Unsafe operations\n pub mod raw {\n     use cast;\n-    use container::Container;\n     use iter::Iterator;\n     use libc;\n     use ptr::RawPtr;\n     use ptr;\n-    use raw::Slice;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector, Vector};\n-    use str::{is_utf8, StrSlice};\n+    use slice::{MutableVector, OwnedVector, Vector};\n+    use str::{is_utf8};\n     use vec::Vec;\n \n+    pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n+    pub use core::str::raw::{slice_unchecked};\n+\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v = Vec::with_capacity(len);\n@@ -1373,12 +707,6 @@ pub mod raw {\n         from_buf_len(buf as *u8, i as uint)\n     }\n \n-    /// Converts a slice of bytes to a string slice without checking\n-    /// that the string contains valid UTF-8.\n-    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-        cast::transmute(v)\n-    }\n-\n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n     #[inline]\n@@ -1389,1317 +717,158 @@ pub mod raw {\n     /// Converts a byte to a string.\n     pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(box [u]) }\n \n-    /// Form a slice from a C string. Unsafe because the caller must ensure the\n-    /// C string has the static lifetime, or else the return value may be\n-    /// invalidated later.\n-    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n-        let s = s as *u8;\n-        let mut curr = s;\n-        let mut len = 0u;\n-        while *curr != 0u8 {\n-            len += 1u;\n-            curr = s.offset(len as int);\n-        }\n-        let v = Slice { data: s, len: len };\n-        assert!(is_utf8(::cast::transmute(v)));\n-        ::cast::transmute(v)\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Failure\n-    ///\n-    /// If begin is greater than end.\n-    /// If end is greater than the length of the string.\n-    #[inline]\n-    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        assert!(begin <= end);\n-        assert!(end <= s.len());\n-        slice_unchecked(s, begin, end)\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// Caller must check slice boundaries!\n-    #[inline]\n-    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        cast::transmute(Slice {\n-                data: s.as_ptr().offset(begin as int),\n-                len: end - begin,\n-            })\n-    }\n-\n-    /// Access the str in its vector representation.\n-    /// The caller must preserve the valid UTF-8 property when modifying.\n-    #[inline]\n-    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n-        cast::transmute(s)\n-    }\n-\n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    #[test]\n-    fn test_from_buf_len() {\n-        unsafe {\n-            let a = box [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = a.as_ptr();\n-            let c = from_buf_len(b, 3u);\n-            assert_eq!(c, \"AAA\".to_owned());\n-        }\n-    }\n-}\n-\n-/*\n-Section: Trait implementations\n-*/\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use container::Container;\n-    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n-    use iter::Iterator;\n-    use ops::Add;\n-    use option::{Some, None};\n-    use str::{Str, StrSlice, eq_slice};\n-    use strbuf::StrBuf;\n-\n-    impl<'a> Add<&'a str,~str> for &'a str {\n-        #[inline]\n-        fn add(&self, rhs: & &'a str) -> ~str {\n-            let mut ret = StrBuf::from_owned_str(self.to_owned());\n-            ret.push_str(*rhs);\n-            ret.into_owned()\n-        }\n-    }\n-\n-    impl<'a> TotalOrd for &'a str {\n-        #[inline]\n-        fn cmp(&self, other: & &'a str) -> Ordering {\n-            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n-                match s_b.cmp(&o_b) {\n-                    Greater => return Greater,\n-                    Less => return Less,\n-                    Equal => ()\n-                }\n-            }\n-\n-            self.len().cmp(&other.len())\n-        }\n-    }\n-\n-    impl TotalOrd for ~str {\n-        #[inline]\n-        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n-    impl<'a> Eq for &'a str {\n-        #[inline]\n-        fn eq(&self, other: & &'a str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-        #[inline]\n-        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n-    }\n-\n-    impl Eq for ~str {\n-        #[inline]\n-        fn eq(&self, other: &~str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-    }\n-\n-    impl<'a> TotalEq for &'a str {}\n-\n-    impl TotalEq for ~str {}\n-\n-    impl<'a> Ord for &'a str {\n-        #[inline]\n-        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n-    }\n-\n-    impl Ord for ~str {\n-        #[inline]\n-        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n-    }\n-\n-    impl<'a, S: Str> Equiv<S> for &'a str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n-\n-    impl<'a, S: Str> Equiv<S> for ~str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-/// Any string that can be represented as a slice\n-pub trait Str {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a str;\n-\n-    /// Convert `self` into a ~str, not making a copy if possible.\n-    fn into_owned(self) -> ~str;\n-\n-    /// Convert `self` into a `StrBuf`.\n-    #[inline]\n-    fn to_strbuf(&self) -> StrBuf {\n-        StrBuf::from_str(self.as_slice())\n-    }\n-\n-    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n-    #[inline]\n-    fn into_strbuf(self) -> StrBuf {\n-        StrBuf::from_owned_str(self.into_owned())\n-    }\n-}\n-\n-impl<'a> Str for &'a str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str { *self }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str { self.to_owned() }\n-}\n-\n-impl<'a> Str for ~str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = *self; s\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str { self }\n-}\n-\n-impl<'a> Container for &'a str {\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-impl Container for ~str {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n-/// Methods for string slices\n-pub trait StrSlice<'a> {\n-    /// Returns true if one string contains another\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The string to look for\n-    fn contains<'a>(&self, needle: &'a str) -> bool;\n-\n-    /// Returns true if a string contains a char.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The char to look for\n-    fn contains_char(&self, needle: char) -> bool;\n-\n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over unicode code-points, not unicode graphemes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ```\n-    fn chars(&self) -> Chars<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .chars().rev()\"]\n-    fn chars_rev(&self) -> Rev<Chars<'a>>;\n-\n-    /// An iterator over the bytes of `self`\n-    fn bytes(&self) -> Bytes<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .bytes().rev()\"]\n-    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n-\n-    /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices(&self) -> CharOffsets<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .char_indices().rev()\"]\n-    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, restricted to splitting at most `count`\n-    /// times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n-    /// ```\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"B\"]);\n-    ///\n-    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n-    ///\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .split(sep).rev()\"]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, starting from the end of the string.\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n-    /// ```\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of `sep` within `self`.\n-    ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indicies corresponding to the\n-    /// first match are returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n-    ///\n-    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(1,4), (4,7)]);\n-    ///\n-    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n-    /// ```\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n-\n-    /// An iterator over the substrings of `self` separated by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n-    /// ```\n-    fn split_str(&self, &'a str) -> StrSplits<'a>;\n-\n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines(&self) -> CharSplits<'a, char>;\n-\n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines_any().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines_any(&self) -> AnyLines<'a>;\n-\n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: ~[&str] = some_words.words().collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    fn words(&self) -> Words<'a>;\n-\n-    /// An Iterator over the string in Unicode Normalization Form D\n-    /// (canonical decomposition).\n-    fn nfd_chars(&self) -> Normalizations<'a>;\n-\n-    /// An Iterator over the string in Unicode Normalization Form KD\n-    /// (compatibility decomposition).\n-    fn nfkd_chars(&self) -> Normalizations<'a>;\n-\n-    /// Returns true if the string contains only whitespace.\n-    ///\n-    /// Whitespace characters are determined by `char::is_whitespace`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\" \\t\\n\".is_whitespace());\n-    /// assert!(\"\".is_whitespace());\n-    ///\n-    /// assert!( !\"abc\".is_whitespace());\n-    /// ```\n-    fn is_whitespace(&self) -> bool;\n-\n-    /// Returns true if the string contains only alphanumeric code\n-    /// points.\n-    ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n-    /// assert!(\"\".is_alphanumeric());\n-    ///\n-    /// assert!( !\" &*~\".is_alphanumeric());\n-    /// ```\n-    fn is_alphanumeric(&self) -> bool;\n-\n-    /// Returns the number of Unicode code points (`char`) that a\n-    /// string holds.\n-    ///\n-    /// This does not perform any normalization, and is `O(n)`, since\n-    /// UTF-8 is a variable width encoding of code points.\n-    ///\n-    /// *Warning*: The number of code points in a string does not directly\n-    /// correspond to the number of visible characters or width of the\n-    /// visible text due to composing characters, and double- and\n-    /// zero-width ones.\n-    ///\n-    /// See also `.len()` for the byte length.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// // composed forms of `\u00f6` and `\u00e9`\n-    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n-    /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n-    ///\n-    /// assert_eq!(c.char_len(), 15);\n-    /// assert_eq!(d.char_len(), 17);\n-    ///\n-    /// assert_eq!(c.len(), 21);\n-    /// assert_eq!(d.len(), 23);\n-    ///\n-    /// // the two strings *look* the same\n-    /// println!(\"{}\", c);\n-    /// println!(\"{}\", d);\n-    /// ```\n-    fn char_len(&self) -> uint;\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Fails when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will fail:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n-    fn slice(&self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Fails when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n-    fn slice_from(&self, begin: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Fails when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n-    fn slice_to(&self, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n-    ///\n-    /// Fails if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns true if `needle` is a prefix of the string.\n-    fn starts_with(&self, needle: &str) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the string.\n-    fn ends_with(&self, needle: &str) -> bool;\n-\n-    /// Escape each char in `s` with `char::escape_default`.\n-    fn escape_default(&self) -> ~str;\n-\n-    /// Escape each char in `s` with `char::escape_unicode`.\n-    fn escape_unicode(&self) -> ~str;\n-\n-    /// Returns a string with leading and trailing whitespace removed.\n-    fn trim(&self) -> &'a str;\n-\n-    /// Returns a string with leading whitespace removed.\n-    fn trim_left(&self) -> &'a str;\n-\n-    /// Returns a string with trailing whitespace removed.\n-    fn trim_right(&self) -> &'a str;\n-\n-    /// Returns a string with characters that match `to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n-    /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with leading `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n-    /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with trailing `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n-    /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Replace all occurrences of one string with another.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `from` - The string to replace\n-    /// * `to` - The replacement string\n-    ///\n-    /// # Return value\n-    ///\n-    /// The original string with all occurrences of `from` replaced with `to`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"Do you know the muffin man,\n-    /// The muffin man, the muffin man, ...\".to_owned();\n-    ///\n-    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n-    ///            \"Do you know the little lamb,\n-    /// The little lamb, the little lamb, ...\".to_owned());\n-    ///\n-    /// // not found, so no change.\n-    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n-    /// ```\n-    fn replace(&self, from: &str, to: &str) -> ~str;\n-\n-    /// Copy a slice into a new owned str.\n-    fn to_owned(&self) -> ~str;\n-\n-    /// Converts to a vector of `u16` encoded as UTF-16.\n-    fn to_utf16(&self) -> ~[u16];\n-\n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n-    ///\n-    /// Fails if `index` is greater than `self.len()`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-\n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n-    ///\n-    /// This function can be used to iterate over the unicode characters of a\n-    /// string.\n-    ///\n-    /// # Example\n-    ///\n-    /// This example manually iterate through the characters of a\n-    /// string; this should normally by done by `.chars()` or\n-    /// `.char_indices`.\n-    ///\n-    /// ```rust\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// ## Output\n-    ///\n-    /// ```ignore\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n-    /// index of the next unicode character.\n-    ///\n-    /// # Failure\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-\n-    /// Given a byte position and a str, return the previous char and its position.\n-    ///\n-    /// This function can be used to iterate over a unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-\n-    /// Plucks the character starting at the `i`th byte of a string\n-    fn char_at(&self, i: uint) -> char;\n-\n-    /// Plucks the character ending at the `i`th byte of a string\n-    fn char_at_reverse(&self, i: uint) -> char;\n-\n-    /// Work with the byte buffer of a string as a byte slice.\n-    fn as_bytes(&self) -> &'a [u8];\n-\n-    /// Returns the byte index of the first character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    ///\n-    /// // the first space\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n-    ///\n-    /// // neither are found\n-    /// assert_eq!(s.find(&['1', '2']), None);\n-    /// ```\n-    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the last character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    ///\n-    /// // the second space\n-    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n-    ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// assert_eq!(s.rfind(&['1', '2']), None);\n-    /// ```\n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the first matching substring\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `needle` - The string to search for\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n-    fn find_str(&self, &str) -> Option<uint>;\n-\n-    /// Given a string, make a new string with repeated copies of it.\n-    fn repeat(&self, nn: uint) -> ~str;\n-\n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// a tuple of None and an empty string is returned instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char();\n-    /// assert_eq!(c, Some('L'));\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char();\n-    /// assert_eq!(c, Some('\u00f6'));\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n-    /// ```\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n-\n-    /// Levenshtein Distance between two strings.\n-    fn lev_distance(&self, t: &str) -> uint;\n-\n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// Fails if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: ~[&str] = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n-    fn subslice_offset(&self, inner: &str) -> uint;\n-\n-    /// Return an unsafe pointer to the strings buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n-    fn as_ptr(&self) -> *u8;\n-}\n-\n-impl<'a> StrSlice<'a> for &'a str {\n-    #[inline]\n-    fn contains<'a>(&self, needle: &'a str) -> bool {\n-        self.find_str(needle).is_some()\n-    }\n-\n-    #[inline]\n-    fn contains_char(&self, needle: char) -> bool {\n-        self.find(needle).is_some()\n-    }\n-\n-    #[inline]\n-    fn chars(&self) -> Chars<'a> {\n-        Chars{string: *self}\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .chars().rev()\"]\n-    fn chars_rev(&self) -> Rev<Chars<'a>> {\n-        self.chars().rev()\n-    }\n-\n-    #[inline]\n-    fn bytes(&self) -> Bytes<'a> {\n-        self.as_bytes().iter().map(|&b| b)\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .bytes().rev()\"]\n-    fn bytes_rev(&self) -> Rev<Bytes<'a>> {\n-        self.bytes().rev()\n-    }\n-\n-    #[inline]\n-    fn char_indices(&self) -> CharOffsets<'a> {\n-        CharOffsets{string: *self, iter: self.chars()}\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .char_indices().rev()\"]\n-    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>> {\n-        self.char_indices().rev()\n-    }\n-\n-    #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n-        CharSplits {\n-            string: *self,\n-            only_ascii: sep.only_ascii(),\n-            sep: sep,\n-            allow_trailing_empty: true,\n-            finished: false,\n-        }\n-    }\n-\n-    #[inline]\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitsN<'a, Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n-            count: count,\n-            invert: false,\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplits<'a, Sep> {\n-        CharSplits {\n-            allow_trailing_empty: false,\n-            ..self.split(sep)\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .split(sep).rev()\"]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>> {\n-        self.split(sep).rev()\n-    }\n-\n-    #[inline]\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitsN<'a, Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n-            count: count,\n-            invert: true,\n-        }\n-    }\n-\n-    #[inline]\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n-        assert!(!sep.is_empty())\n-        MatchIndices {\n-            haystack: *self,\n-            needle: sep,\n-            position: 0\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n-        StrSplits {\n-            it: self.match_indices(sep),\n-            last_end: 0,\n-            finished: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn lines(&self) -> CharSplits<'a, char> {\n-        self.split_terminator('\\n')\n-    }\n-\n-    fn lines_any(&self) -> AnyLines<'a> {\n-        self.lines().map(|line| {\n-            let l = line.len();\n-            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n-            else { line }\n-        })\n-    }\n-\n+    /// Access the str in its vector representation.\n+    /// The caller must preserve the valid UTF-8 property when modifying.\n     #[inline]\n-    fn words(&self) -> Words<'a> {\n-        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n+    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n+        cast::transmute(s)\n     }\n \n-    #[inline]\n-    fn nfd_chars(&self) -> Normalizations<'a> {\n-        Normalizations {\n-            iter: self.chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: NFD\n-        }\n-    }\n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n+    #[test]\n+    fn test_from_buf_len() {\n+        use slice::ImmutableVector;\n+        use str::StrAllocating;\n \n-    #[inline]\n-    fn nfkd_chars(&self) -> Normalizations<'a> {\n-        Normalizations {\n-            iter: self.chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: NFKD\n+        unsafe {\n+            let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = a.as_ptr();\n+            let c = from_buf_len(b, 3u);\n+            assert_eq!(c, \"AAA\".to_owned());\n         }\n     }\n+}\n \n-    #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n-\n-    #[inline]\n-    fn char_len(&self) -> uint { self.chars().len() }\n-\n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, begin, end) }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &'a str {\n-        self.slice(begin, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, 0, end) }\n-    }\n-\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(begin <= end);\n-        let mut count = 0;\n-        let mut begin_byte = None;\n-        let mut end_byte = None;\n-\n-        // This could be even more efficient by not decoding,\n-        // only finding the char boundaries\n-        for (idx, _) in self.char_indices() {\n-            if count == begin { begin_byte = Some(idx); }\n-            if count == end { end_byte = Some(idx); break; }\n-            count += 1;\n-        }\n-        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n-        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n+/*\n+Section: Trait implementations\n+*/\n \n-        match (begin_byte, end_byte) {\n-            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n-            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n-            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n-        }\n-    }\n+/// Any string that can be represented as a slice\n+pub trait StrAllocating: Str {\n+    /// Convert `self` into a ~str, not making a copy if possible.\n+    fn into_owned(self) -> ~str;\n \n+    /// Convert `self` into a `StrBuf`.\n     #[inline]\n-    fn starts_with<'a>(&self, needle: &'a str) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+    fn to_strbuf(&self) -> StrBuf {\n+        StrBuf::from_str(self.as_slice())\n     }\n \n+    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n     #[inline]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+    fn into_strbuf(self) -> StrBuf {\n+        StrBuf::from_owned_str(self.into_owned())\n     }\n \n+    /// Escape each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> ~str {\n-        let mut out = StrBuf::with_capacity(self.len());\n-        for c in self.chars() {\n+        let me = self.as_slice();\n+        let mut out = StrBuf::with_capacity(me.len());\n+        for c in me.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n         out.into_owned()\n     }\n \n+    /// Escape each char in `s` with `char::escape_unicode`.\n     fn escape_unicode(&self) -> ~str {\n-        let mut out = StrBuf::with_capacity(self.len());\n-        for c in self.chars() {\n+        let me = self.as_slice();\n+        let mut out = StrBuf::with_capacity(me.len());\n+        for c in me.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n         out.into_owned()\n     }\n \n-    #[inline]\n-    fn trim(&self) -> &'a str {\n-        self.trim_left().trim_right()\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &'a str {\n-        self.trim_left_chars(char::is_whitespace)\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &'a str {\n-        self.trim_right_chars(char::is_whitespace)\n-    }\n-\n-    #[inline]\n-    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n-        };\n-        match cur.rfind(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(i) => {\n-                let right = cur.char_range_at(i).next;\n-                unsafe { raw::slice_bytes(cur, 0, right) }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        match self.find(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        match self.rfind(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(*self, 0u, next) }\n-            }\n-        }\n-    }\n-\n+    /// Replace all occurrences of one string with another.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `from` - The string to replace\n+    /// * `to` - The replacement string\n+    ///\n+    /// # Return value\n+    ///\n+    /// The original string with all occurrences of `from` replaced with `to`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"Do you know the muffin man,\n+    /// The muffin man, the muffin man, ...\".to_owned();\n+    ///\n+    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n+    ///            \"Do you know the little lamb,\n+    /// The little lamb, the little lamb, ...\".to_owned());\n+    ///\n+    /// // not found, so no change.\n+    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// ```\n     fn replace(&self, from: &str, to: &str) -> ~str {\n+        let me = self.as_slice();\n         let mut result = StrBuf::new();\n         let mut last_end = 0;\n-        for (start, end) in self.match_indices(from) {\n-            result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n+        for (start, end) in me.match_indices(from) {\n+            result.push_str(unsafe{raw::slice_bytes(me, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n         }\n-        result.push_str(unsafe{raw::slice_bytes(*self, last_end, self.len())});\n+        result.push_str(unsafe{raw::slice_bytes(me, last_end, me.len())});\n         result.into_owned()\n     }\n \n+    /// Copy a slice into a new owned str.\n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        let len = self.len();\n+        let me = self.as_slice();\n+        let len = me.len();\n         unsafe {\n             let mut v = Vec::with_capacity(len);\n \n-            ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n+            ptr::copy_memory(v.as_mut_ptr(), me.as_ptr(), len);\n             v.set_len(len);\n             ::cast::transmute(v.move_iter().collect::<~[u8]>())\n         }\n     }\n \n+    /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n+        let me = self.as_slice();\n         let mut u = Vec::new();;\n-        for ch in self.chars() {\n+        for ch in me.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n         u.move_iter().collect()\n     }\n \n-    #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n-        if index == self.len() { return true; }\n-        let b = self[index];\n-        return b < 128u8 || b >= 192u8;\n-    }\n-\n-    #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n-        if self[i] < 128u8 {\n-            return CharRange {ch: self[i] as char, next: i + 1 };\n-        }\n-\n-        // Multibyte case is a fn to allow char_range_at to inline cleanly\n-        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n-\n-            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n-        }\n-\n-        return multibyte_char_range_at(*self, i);\n-    }\n-\n-    #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        let mut prev = start;\n-\n-        prev = prev.saturating_sub(1);\n-        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n-\n-        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n-            // while there is a previous byte == 10......\n-            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n-                i -= 1u;\n-            }\n-\n-            let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n-\n-            return CharRange {ch: unsafe { transmute(val) }, next: i};\n-        }\n-\n-        return multibyte_char_range_at_reverse(*self, prev);\n-    }\n-\n-    #[inline]\n-    fn char_at(&self, i: uint) -> char {\n-        self.char_range_at(i).ch\n-    }\n-\n-    #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n-        self.char_range_at_reverse(i).ch\n-    }\n-\n-    #[inline]\n-    fn as_bytes(&self) -> &'a [u8] {\n-        unsafe { cast::transmute(*self) }\n-    }\n-\n-    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().position(|b| search.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices() {\n-                if search.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().rposition(|b| search.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices().rev() {\n-                if search.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn find_str(&self, needle: &str) -> Option<uint> {\n-        if needle.is_empty() {\n-            Some(0)\n-        } else {\n-            self.match_indices(needle)\n-                .next()\n-                .map(|(start, _end)| start)\n-        }\n-    }\n-\n+    /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        let mut ret = StrBuf::with_capacity(nn * self.len());\n+        let me = self.as_slice();\n+        let mut ret = StrBuf::with_capacity(nn * me.len());\n         for _ in range(0, nn) {\n-            ret.push_str(*self);\n+            ret.push_str(me);\n         }\n         ret.into_owned()\n     }\n \n-    #[inline]\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n-        if self.is_empty() {\n-            return (None, *self);\n-        } else {\n-            let CharRange {ch, next} = self.char_range_at(0u);\n-            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n-            return (Some(ch), next_s);\n-        }\n-    }\n-\n+    /// Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint {\n-        let slen = self.len();\n+        let me = self.as_slice();\n+        let slen = me.len();\n         let tlen = t.len();\n \n         if slen == 0 { return tlen; }\n         if tlen == 0 { return slen; }\n \n         let mut dcol = Vec::from_fn(tlen + 1, |x| x);\n \n-        for (i, sc) in self.chars().enumerate() {\n+        for (i, sc) in me.chars().enumerate() {\n \n             let mut current = i;\n             *dcol.get_mut(0) = current + 1;\n@@ -2723,23 +892,41 @@ impl<'a> StrSlice<'a> for &'a str {\n         return *dcol.get(tlen);\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n-        let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n-        let b_end = b_start + inner.len();\n-\n-        assert!(a_start <= b_start);\n-        assert!(b_end <= a_end);\n-        b_start - a_start\n+    /// An Iterator over the string in Unicode Normalization Form D\n+    /// (canonical decomposition).\n+    #[inline]\n+    fn nfd_chars<'a>(&'a self) -> Normalizations<'a> {\n+        Normalizations {\n+            iter: self.as_slice().chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: NFD\n+        }\n     }\n \n+    /// An Iterator over the string in Unicode Normalization Form KD\n+    /// (compatibility decomposition).\n     #[inline]\n-    fn as_ptr(&self) -> *u8 {\n-        self.repr().data\n+    fn nfkd_chars<'a>(&'a self) -> Normalizations<'a> {\n+        Normalizations {\n+            iter: self.as_slice().chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: NFKD\n+        }\n     }\n }\n \n+impl<'a> StrAllocating for &'a str {\n+    #[inline]\n+    fn into_owned(self) -> ~str { self.to_owned() }\n+}\n+\n+impl<'a> StrAllocating for ~str {\n+    #[inline]\n+    fn into_owned(self) -> ~str { self }\n+}\n+\n /// Methods for owned strings\n pub trait OwnedStr {\n     /// Consumes the string, returning the underlying byte buffer.\n@@ -2765,32 +952,6 @@ impl OwnedStr for ~str {\n     }\n }\n \n-impl Clone for ~str {\n-    #[inline]\n-    fn clone(&self) -> ~str {\n-        self.to_owned()\n-    }\n-}\n-\n-impl FromIterator<char> for ~str {\n-    #[inline]\n-    fn from_iter<T: Iterator<char>>(iterator: T) -> ~str {\n-        let (lower, _) = iterator.size_hint();\n-        let mut buf = StrBuf::with_capacity(lower);\n-        buf.extend(iterator);\n-        buf.into_owned()\n-    }\n-}\n-\n-// This works because every lifetime is a sub-lifetime of 'static\n-impl<'a> Default for &'a str {\n-    fn default() -> &'a str { \"\" }\n-}\n-\n-impl Default for ~str {\n-    fn default() -> ~str { \"\".to_owned() }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use iter::AdditiveIterator;"}, {"sha": "ad703b8054b0bcf6e1c25201527e41ed2d41ab6b", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -20,8 +20,8 @@ use iter::{Extendable, FromIterator, Iterator, range};\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use slice::{OwnedVector, Vector};\n+use str::{OwnedStr, Str, StrSlice, StrAllocating};\n use str;\n-use str::{OwnedStr, Str, StrSlice};\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -268,7 +268,9 @@ impl Str for StrBuf {\n             cast::transmute(self.vec.as_slice())\n         }\n     }\n+}\n \n+impl StrAllocating for StrBuf {\n     #[inline]\n     fn into_owned(self) -> ~str {\n         let StrBuf {"}, {"sha": "23831e40a8b43682e003394bffd35a3d2fc590ad", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -49,7 +49,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use result;\n-#[cfg(test)] use str::StrSlice;\n+#[cfg(test)] use str::StrAllocating;\n \n /// Indicates the manner in which a task exited.\n ///"}, {"sha": "4132c8a5b5a3332c80d3ace6a07d834b7f8e0b96", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -35,7 +35,7 @@ impl<T: fmt::Show> ToStr for T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use str::StrSlice;\n+    use str::StrAllocating;\n \n     #[test]\n     fn test_simple_types() {"}, {"sha": "d705da7b72b6301ce9db1a0fe44e2e8ead484652", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=9bae6ec828fdc7f87838ee008cccef90e31b9f84", "patch": "@@ -109,11 +109,6 @@ impl Str for RcStr {\n         let s: &'a str = *self.string;\n         s\n     }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str {\n-        self.string.to_owned()\n-    }\n }\n \n impl fmt::Show for RcStr {"}]}