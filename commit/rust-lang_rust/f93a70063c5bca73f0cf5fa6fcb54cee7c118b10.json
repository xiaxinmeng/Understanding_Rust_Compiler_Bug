{"sha": "f93a70063c5bca73f0cf5fa6fcb54cee7c118b10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5M2E3MDA2M2M1YmNhNzNmMGNmNWZhNmZjYjU0Y2VlN2MxMThiMTA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:39:31Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:39:31Z"}, "message": "Introduce IntRange constructor", "tree": {"sha": "363a0f1c7b115dbf8330b742f39dc4d070d0adaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/363a0f1c7b115dbf8330b742f39dc4d070d0adaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10", "html_url": "https://github.com/rust-lang/rust/commit/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1909e3f2bf9287e959721229af3680d386ee567b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1909e3f2bf9287e959721229af3680d386ee567b", "html_url": "https://github.com/rust-lang/rust/commit/1909e3f2bf9287e959721229af3680d386ee567b"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "ce0e12eb95cd0993a695f51dcbcd8e4e66ef890d", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93a70063c5bca73f0cf5fa6fcb54cee7c118b10/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f93a70063c5bca73f0cf5fa6fcb54cee7c118b10", "patch": "@@ -590,7 +590,10 @@ enum Constructor<'tcx> {\n     Variant(DefId),\n     /// Literal values.\n     ConstantValue(&'tcx ty::Const<'tcx>, Span),\n-    /// Ranges of literal values (`2..=5` and `2..5`).\n+    /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n+    IntRange(IntRange<'tcx>),\n+    // TODO: non-integer\n+    /// Ranges of literal values (`2.0..=5.2`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length `n`.\n     FixedLenSlice(u64),\n@@ -612,6 +615,7 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n                 Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n                 Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n             ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n+            (Constructor::IntRange(a), Constructor::IntRange(b)) => a == b,\n             (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n             (\n                 Constructor::VarLenSlice(a_prefix, a_suffix),\n@@ -634,6 +638,7 @@ impl<'tcx> Constructor<'tcx> {\n         let ty = match self {\n             ConstantValue(value, _) => value.ty,\n             ConstantRange(_, _, ty, _, _) => ty,\n+            IntRange(_) => return true,\n             _ => return false,\n         };\n         IntRange::is_integral(ty)\n@@ -743,7 +748,7 @@ impl<'tcx> Constructor<'tcx> {\n \n                 remaining_ctors\n             }\n-            ConstantRange(..) | ConstantValue(..) => {\n+            IntRange(..) | ConstantRange(..) | ConstantValue(..) => {\n                 if let Some(self_range) = IntRange::from_ctor(tcx, param_env, self) {\n                     let mut remaining_ranges = vec![self_range.clone()];\n                     let other_ranges = other_ctors\n@@ -767,7 +772,7 @@ impl<'tcx> Constructor<'tcx> {\n                     }\n \n                     // Convert the ranges back into constructors\n-                    remaining_ranges.into_iter().map(|range| range.into_ctor(tcx)).collect()\n+                    remaining_ranges.into_iter().map(IntRange).collect()\n                 } else {\n                     if other_ctors.iter().any(|c| {\n                         c == self\n@@ -855,7 +860,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n-            ConstantValue(..) | ConstantRange(..) | NonExhaustive => vec![],\n+            ConstantValue(..) | ConstantRange(..) | IntRange(..) | NonExhaustive => vec![],\n         }\n     }\n \n@@ -880,7 +885,7 @@ impl<'tcx> Constructor<'tcx> {\n             },\n             FixedLenSlice(length) => *length,\n             VarLenSlice(prefix, suffix) => prefix + suffix,\n-            ConstantValue(..) | ConstantRange(..) | NonExhaustive => 0,\n+            ConstantValue(..) | ConstantRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n \n@@ -949,6 +954,10 @@ impl<'tcx> Constructor<'tcx> {\n                 hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                 end,\n             }),\n+            IntRange(range) => {\n+                // TODO: do it more directly\n+                return range.clone().into_ctor(cx.tcx).apply(cx, ty, None.into_iter());\n+            }\n             NonExhaustive => PatKind::Wild,\n         };\n \n@@ -1145,7 +1154,14 @@ fn all_constructors<'a, 'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    let make_range = |start, end| ConstantRange(start, end, pcx.ty, RangeEnd::Included, pcx.span);\n+    let make_range = |start, end| {\n+        IntRange(\n+            // `unwrap()` is ok because we know the type is an integer and the range is\n+            // well-formed.\n+            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included, pcx.span)\n+                .unwrap(),\n+        )\n+    };\n     match pcx.ty.kind {\n         ty::Bool => [true, false]\n             .iter()\n@@ -1356,6 +1372,7 @@ impl<'tcx> IntRange<'tcx> {\n         match ctor {\n             ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n             ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n+            IntRange(range) => Some(range.clone()),\n             _ => None,\n         }\n     }\n@@ -1381,6 +1398,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     /// Converts an `IntRange` to a `ConstantValue` or inclusive `ConstantRange`.\n+    /// TODO: Deprecated\n     fn into_ctor(self, tcx: TyCtxt<'tcx>) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, self.ty);\n         let (lo, hi) = self.range.into_inner();\n@@ -1889,7 +1907,9 @@ fn split_grouped_constructors<'p, 'tcx>(\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            ConstantRange(..) if IntRange::should_treat_range_exhaustively(tcx, ty) => {\n+            IntRange(..) | ConstantRange(..)\n+                if IntRange::should_treat_range_exhaustively(tcx, ty) =>\n+            {\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n                 // `NotUseful`, which is the default case anyway, and can be ignored.\n@@ -1968,7 +1988,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                             }\n                             (Border::AfterMax, _) => None,\n                         })\n-                        .map(|range| range.into_ctor(tcx)),\n+                        .map(IntRange),\n                 );\n             }\n             VarLenSlice(self_prefix, self_suffix) => {"}]}