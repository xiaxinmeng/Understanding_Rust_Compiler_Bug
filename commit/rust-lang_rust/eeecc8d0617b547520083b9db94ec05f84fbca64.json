{"sha": "eeecc8d0617b547520083b9db94ec05f84fbca64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZWNjOGQwNjE3YjU0NzUyMDA4M2I5ZGI5NGVjMDVmODRmYmNhNjQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-02T03:03:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-02T03:03:47Z"}, "message": "rustc: Add stub support for tag constructors in trans", "tree": {"sha": "f175cb07047adaab21529180bd4ae2e0a9b65a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f175cb07047adaab21529180bd4ae2e0a9b65a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeecc8d0617b547520083b9db94ec05f84fbca64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeecc8d0617b547520083b9db94ec05f84fbca64", "html_url": "https://github.com/rust-lang/rust/commit/eeecc8d0617b547520083b9db94ec05f84fbca64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeecc8d0617b547520083b9db94ec05f84fbca64/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98a63bd1f9fda47fc34b16d9f0782022e1022277", "url": "https://api.github.com/repos/rust-lang/rust/commits/98a63bd1f9fda47fc34b16d9f0782022e1022277", "html_url": "https://github.com/rust-lang/rust/commit/98a63bd1f9fda47fc34b16d9f0782022e1022277"}], "stats": {"total": 140, "additions": 139, "deletions": 1}, "files": [{"sha": "15fc68e4b7fdbe53b8f6fd7107ce6ea55f90d8e5", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=eeecc8d0617b547520083b9db94ec05f84fbca64", "patch": "@@ -1106,6 +1106,19 @@ obj builder(BuilderRef B) {\n     }\n }\n \n+/* Memory-managed object interface to type handles. */\n+\n+obj type_handle_dtor(TypeHandleRef TH) {\n+    drop { llvm.LLVMDisposeTypeHandle(TH); }\n+}\n+\n+type type_handle = rec(TypeHandleRef llth, type_handle_dtor dtor);\n+\n+fn mk_type_handle() -> type_handle {\n+    auto th = llvm.LLVMCreateTypeHandle(llvm.LLVMOpaqueType());\n+    ret rec(llth=th, dtor=type_handle_dtor(th));\n+}\n+\n fn type_to_str(TypeRef ty) -> str {\n     let int kind = llvm.LLVMGetTypeKind(ty);\n "}, {"sha": "03b57024cce798c760512310ef4d7a64f8a57d5f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=eeecc8d0617b547520083b9db94ec05f84fbca64", "patch": "@@ -20,9 +20,12 @@ import util.common.new_str_hash;\n \n import lib.llvm.llvm;\n import lib.llvm.builder;\n+import lib.llvm.type_handle;\n+import lib.llvm.mk_type_handle;\n import lib.llvm.llvm.ModuleRef;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.llvm.TypeRef;\n+import lib.llvm.llvm.TypeHandleRef;\n import lib.llvm.llvm.BuilderRef;\n import lib.llvm.llvm.BasicBlockRef;\n \n@@ -41,13 +44,18 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef exit_task_glue,\n                     vec[ValueRef] upcall_glues);\n \n+type tag_info = rec(type_handle th,\n+                    hashmap[ast.def_id, uint] variant_indices,\n+                    hashmap[ast.def_id, uint] n_ary_variant_indices);\n+\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] fn_names,\n                             hashmap[ast.def_id, ValueRef] fn_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n+                            hashmap[ast.def_id, tag_info] tags,\n                             @glue_fns glues,\n                             namegen names,\n                             str path);\n@@ -177,6 +185,11 @@ fn T_struct(vec[TypeRef] elts) -> TypeRef {\n                             False);\n }\n \n+fn T_union(vec[TypeRef] elts) -> TypeRef {\n+    ret llvm.LLVMUnionType(_vec.buf[TypeRef](elts),\n+                           _vec.len[TypeRef](elts));\n+}\n+\n fn T_opaque() -> TypeRef {\n     ret llvm.LLVMOpaqueType();\n }\n@@ -267,6 +280,9 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n         }\n         case (typeck.ty_char) { ret T_char(); }\n         case (typeck.ty_str) { ret T_ptr(T_str()); }\n+        case (typeck.ty_tag(?tag_id)) {\n+            ret llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n+        }\n         case (typeck.ty_box(?t)) {\n             ret T_ptr(T_box(type_of(cx, t)));\n         }\n@@ -1114,6 +1130,19 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n                     ret tup(res(cx, cx.fcx.ccx.fn_ids.get(did)),\n                             false);\n                 }\n+                case (ast.def_variant(?tid, ?vid)) {\n+                    check (cx.fcx.ccx.tags.contains_key(tid));\n+                    auto info = cx.fcx.ccx.tags.get(tid);\n+                    if (info.n_ary_variant_indices.contains_key(vid)) {\n+                        cx.fcx.ccx.sess.unimpl(\"n-ary tag constructors in \" +\n+                                               \"trans\");\n+                    } else {\n+                        // Nullary tag variant case.\n+                        auto idx = info.variant_indices.get(vid);\n+                        auto elems = vec(C_int(idx as int));\n+                        ret tup(res(cx, C_struct(elems)), false);\n+                    }\n+                }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n                 }\n@@ -1645,6 +1674,15 @@ impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     }\n }\n \n+fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n+                     &ast.variant variant) {\n+    if (_vec.len[@ast.ty](variant.args) == 0u) {\n+        ret;    // nullary constructors are just constants\n+    }\n+\n+    // TODO\n+}\n+\n impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n@@ -1655,6 +1693,12 @@ impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n             trans_mod(sub_cx, m);\n         }\n+        case (ast.item_tag(?name, ?variants, _, ?tag_id)) {\n+            auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n+            for (ast.variant variant in variants) {\n+                trans_tag_variant(sub_cx, tag_id, variant);\n+            }\n+        }\n         case (_) { /* fall through */ }\n     }\n }\n@@ -1666,6 +1710,60 @@ impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n }\n \n \n+fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+    alt (i.node) {\n+        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n+            let vec[TypeRef] variant_tys = vec();\n+\n+            auto info = cx.tags.get(tag_id);\n+            auto variant_indices = info.variant_indices;\n+            auto n_ary_variant_indices = info.n_ary_variant_indices;\n+\n+            auto tag_ty;\n+            if (_vec.len[ast.variant](variants) == 0u) {\n+                tag_ty = T_struct(vec(T_int()));\n+            } else {\n+                auto variant_idx = 0u;\n+                auto n_ary_variant_idx = 0u;\n+\n+                for (ast.variant variant in variants) {\n+                    if (_vec.len[@ast.ty](variant.args) > 0u) {\n+                        let vec[TypeRef] lltys = vec();\n+\n+                        alt (typeck.ann_to_type(variant.ann).struct) {\n+                            case (typeck.ty_fn(?args, _)) {\n+                                for (typeck.arg arg in args) {\n+                                    lltys += vec(type_of(cx, arg.ty));\n+                                }\n+                            }\n+                            case (_) { fail; }\n+                        }\n+\n+                        variant_tys += vec(T_struct(lltys));\n+\n+                        n_ary_variant_indices.insert(variant.id,\n+                                                     n_ary_variant_idx);\n+                        n_ary_variant_idx += 1u;\n+                    }\n+\n+                    variant_indices.insert(variant.id, variant_idx);\n+                    variant_idx += 1u;\n+                }\n+\n+                tag_ty = T_struct(vec(T_int(), T_union(variant_tys)));\n+            }\n+\n+            auto th = cx.tags.get(tag_id).th.llth;\n+            llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n+        }\n+        case (_) {\n+            // fall through\n+        }\n+    }\n+\n+    ret cx;\n+}\n+\n fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n@@ -1680,6 +1778,15 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         case (ast.item_mod(?name, ?m, ?mid)) {\n             cx.items.insert(mid, i);\n         }\n+\n+        case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n+            auto vi = new_def_hash[uint]();\n+            auto navi = new_def_hash[uint]();\n+            cx.tags.insert(tag_id, rec(th=mk_type_handle(),\n+                                       variant_indices=vi,\n+                                       n_ary_variant_indices=navi));\n+        }\n+\n         case (_) { /* fall through */ }\n     }\n     ret cx;\n@@ -1697,6 +1804,16 @@ fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n     fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n+fn resolve_tag_types(@crate_ctxt cx, @ast.crate crate) {\n+    let fold.ast_fold[@crate_ctxt] fld =\n+        fold.new_identity_fold[@crate_ctxt]();\n+\n+    fld = @rec( update_env_for_item = bind resolve_tag_types_for_item(_,_)\n+                with *fld );\n+\n+    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n+}\n+\n fn p2i(ValueRef v) -> ValueRef {\n     ret llvm.LLVMConstPtrToInt(v, T_int());\n }\n@@ -1856,11 +1973,14 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n                    fn_names = new_str_hash[ValueRef](),\n                    fn_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n+                   tags = new_def_hash[tag_info](),\n                    glues = glues,\n                    names = namegen(0),\n                    path = \"_rust\");\n \n     collect_items(cx, crate);\n+    resolve_tag_types(cx, crate);\n+\n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n     trans_main_fn(cx, crate_constant(cx));"}, {"sha": "94bd41a674fa6b7fd4f217ad99c09d026c65b1fd", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeecc8d0617b547520083b9db94ec05f84fbca64/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=eeecc8d0617b547520083b9db94ec05f84fbca64", "patch": "@@ -203,6 +203,11 @@ fn ty_to_str(&@ty typ) -> str {\n             s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n+        case (ty_tag(_)) {\n+            // The user should never see this if the cname is set properly!\n+            s = \"<tag>\";\n+        }\n+\n         case (ty_fn(?inputs, ?output)) {\n             auto f = fn_input_to_str;\n             s = \"fn(\" + _str.connect(_vec.map[arg,str](f, inputs),\n@@ -550,9 +555,9 @@ fn type_is_nil(@ty t) -> bool {\n \n fn type_is_structural(@ty t) -> bool {\n     alt (t.struct) {\n-        // FIXME: cover tag when we support it.\n         case (ty_tup(_)) { ret true; }\n         case (ty_rec(_)) { ret true; }\n+        case (ty_tag(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;"}]}