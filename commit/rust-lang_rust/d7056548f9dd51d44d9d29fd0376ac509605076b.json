{"sha": "d7056548f9dd51d44d9d29fd0376ac509605076b", "node_id": "C_kwDOAAsO6NoAKGQ3MDU2NTQ4ZjlkZDUxZDQ0ZDlkMjlmZDAzNzZhYzUwOTYwNTA3NmI", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-05T13:28:25Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-05T13:49:48Z"}, "message": "Yeet `owning_ref`\n\nTurns out\n- `owning_ref` is unsound due to `Box` aliasing stuff\n- `rustc` doesn't need 99% of the `owning_ref` API\n- `rustc` can use a far simpler abstraction that is `OwnedSlice`", "tree": {"sha": "3765a4eff01a1ae775b645b89622c934aad35562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3765a4eff01a1ae775b645b89622c934aad35562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7056548f9dd51d44d9d29fd0376ac509605076b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7056548f9dd51d44d9d29fd0376ac509605076b", "html_url": "https://github.com/rust-lang/rust/commit/d7056548f9dd51d44d9d29fd0376ac509605076b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7056548f9dd51d44d9d29fd0376ac509605076b/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4", "html_url": "https://github.com/rust-lang/rust/commit/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4"}], "stats": {"total": 1972, "additions": 1, "deletions": 1971}, "files": [{"sha": "47d8c84ba205939e0366772d6e910683ac99c5cb", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=d7056548f9dd51d44d9d29fd0376ac509605076b", "patch": "@@ -61,7 +61,6 @@ pub mod intern;\n pub mod jobserver;\n pub mod macros;\n pub mod obligation_forest;\n-pub mod owning_ref;\n pub mod sip128;\n pub mod small_c_str;\n pub mod small_str;"}, {"sha": "1556873f59765c0cac66770a826877e03cfd03d7", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=d7056548f9dd51d44d9d29fd0376ac509605076b", "patch": "@@ -2,9 +2,7 @@ use std::fs::File;\n use std::io;\n use std::ops::{Deref, DerefMut};\n \n-use crate::owning_ref::StableAddress;\n-\n-/// A trivial wrapper for [`memmap2::Mmap`] that implements [`StableAddress`].\n+/// A trivial wrapper for [`memmap2::Mmap`] (or `Vec<u8>` on WASM).\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct Mmap(memmap2::Mmap);\n \n@@ -46,12 +44,6 @@ impl AsRef<[u8]> for Mmap {\n     }\n }\n \n-// SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n-// memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n-// export any function that can cause the `Vec` to be re-allocated. As such the address of the\n-// bytes inside this `Vec` is stable.\n-unsafe impl StableAddress for Mmap {}\n-\n #[cfg(not(target_arch = \"wasm32\"))]\n pub struct MmapMut(memmap2::MmapMut);\n "}, {"sha": "dff72d1e43251989d52b6bec53c8588f7f4df47b", "filename": "compiler/rustc_data_structures/src/owning_ref/LICENSE", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE?ref=c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4", "patch": "@@ -1,21 +0,0 @@\n-The MIT License (MIT)\n-\n-Copyright (c) 2015 Marvin L\u00f6bel\n-\n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to deal\n-in the Software without restriction, including without limitation the rights\n-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included in all\n-copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-SOFTWARE."}, {"sha": "d1d92b905b82e0b9da4db953f10c263d8bce4838", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "removed", "additions": 0, "deletions": 1211, "changes": 1211, "blob_url": "https://github.com/rust-lang/rust/blob/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4", "patch": "@@ -1,1211 +0,0 @@\n-#![warn(missing_docs)]\n-\n-/*!\n-# An owning reference.\n-\n-This crate provides the _owning reference_ types `OwningRef` and `OwningRefMut`\n-that enables it to bundle a reference together with the owner of the data it points to.\n-This allows moving and dropping of an `OwningRef` without needing to recreate the reference.\n-\n-This can sometimes be useful because Rust borrowing rules normally prevent\n-moving a type that has been moved from. For example, this kind of code gets rejected:\n-\n-```compile_fail,E0515\n-fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {\n-    let v = vec![1, 2, 3, 4];\n-    let s = &v[1..3];\n-    (v, s)\n-}\n-```\n-\n-Even though, from a memory-layout point of view, this can be entirely safe\n-if the new location of the vector still lives longer than the lifetime `'a`\n-of the reference because the backing allocation of the vector does not change.\n-\n-This library enables this safe usage by keeping the owner and the reference\n-bundled together in a wrapper type that ensure that lifetime constraint:\n-\n-```\n-# use rustc_data_structures::owning_ref::OwningRef;\n-# fn main() {\n-fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {\n-    let v = vec![1, 2, 3, 4];\n-    let or = OwningRef::new(v);\n-    let or = or.map(|v| &v[1..3]);\n-    or\n-}\n-# }\n-```\n-\n-It works by requiring owner types to dereference to stable memory locations\n-and preventing mutable access to root containers, which in practice requires heap allocation\n-as provided by `Box<T>`, `Rc<T>`, etc.\n-\n-Also provided are typedefs for common owner type combinations,\n-which allow for less verbose type signatures.\n-For example, `BoxRef<T>` instead of `OwningRef<Box<T>, T>`.\n-\n-The crate also provides the more advanced `OwningHandle` type,\n-which allows more freedom in bundling a dependent handle object\n-along with the data it depends on, at the cost of some unsafe needed in the API.\n-See the documentation around `OwningHandle` for more details.\n-\n-# Examples\n-\n-## Basics\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    // Create an array owned by a Box.\n-    let arr = Box::new([1, 2, 3, 4]) as Box<[i32]>;\n-\n-    // Transfer into a BoxRef.\n-    let arr: BoxRef<[i32]> = BoxRef::new(arr);\n-    assert_eq!(&*arr, &[1, 2, 3, 4]);\n-\n-    // We can slice the array without losing ownership or changing type.\n-    let arr: BoxRef<[i32]> = arr.map(|arr| &arr[1..3]);\n-    assert_eq!(&*arr, &[2, 3]);\n-\n-    // Also works for Arc, Rc, String and Vec!\n-}\n-```\n-\n-## Caching a reference to a struct field\n-\n-```\n-use rustc_data_structures::owning_ref::BoxRef;\n-\n-fn main() {\n-    struct Foo {\n-        tag: u32,\n-        x: u16,\n-        y: u16,\n-        z: u16,\n-    }\n-    let foo = Foo { tag: 1, x: 100, y: 200, z: 300 };\n-\n-    let or = BoxRef::new(Box::new(foo)).map(|foo| {\n-        match foo.tag {\n-            0 => &foo.x,\n-            1 => &foo.y,\n-            2 => &foo.z,\n-            _ => panic!(),\n-        }\n-    });\n-\n-    assert_eq!(*or, 200);\n-}\n-```\n-\n-## Caching a reference to an entry in a vector\n-\n-```\n-use rustc_data_structures::owning_ref::VecRef;\n-\n-fn main() {\n-    let v = VecRef::new(vec![1, 2, 3, 4, 5]).map(|v| &v[3]);\n-    assert_eq!(*v, 4);\n-}\n-```\n-\n-## Caching a subslice of a String\n-\n-```\n-use rustc_data_structures::owning_ref::StringRef;\n-\n-fn main() {\n-    let s = StringRef::new(\"hello world\".to_owned())\n-        .map(|s| s.split(' ').nth(1).unwrap());\n-\n-    assert_eq!(&*s, \"world\");\n-}\n-```\n-\n-## Reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::RcRef;\n-use std::rc::Rc;\n-\n-fn main() {\n-    let rc: RcRef<[i32]> = RcRef::new(Rc::new([1, 2, 3, 4]) as Rc<[i32]>);\n-    assert_eq!(&*rc, &[1, 2, 3, 4]);\n-\n-    let rc_a: RcRef<[i32]> = rc.clone().map(|s| &s[0..2]);\n-    let rc_b = rc.clone().map(|s| &s[1..3]);\n-    let rc_c = rc.clone().map(|s| &s[2..4]);\n-    assert_eq!(&*rc_a, &[1, 2]);\n-    assert_eq!(&*rc_b, &[2, 3]);\n-    assert_eq!(&*rc_c, &[3, 4]);\n-\n-    let rc_c_a = rc_c.clone().map(|s| &s[1]);\n-    assert_eq!(&*rc_c_a, &4);\n-}\n-```\n-\n-## Atomic reference counted slices that share ownership of the backing storage\n-\n-```\n-use rustc_data_structures::owning_ref::ArcRef;\n-use std::sync::Arc;\n-\n-fn main() {\n-    use std::thread;\n-\n-    fn par_sum(rc: ArcRef<[i32]>) -> i32 {\n-        if rc.len() == 0 {\n-            return 0;\n-        } else if rc.len() == 1 {\n-            return rc[0];\n-        }\n-        let mid = rc.len() / 2;\n-        let left = rc.clone().map(|s| &s[..mid]);\n-        let right = rc.map(|s| &s[mid..]);\n-\n-        let left = thread::spawn(move || par_sum(left));\n-        let right = thread::spawn(move || par_sum(right));\n-\n-        left.join().unwrap() + right.join().unwrap()\n-    }\n-\n-    let rc: Arc<[i32]> = Arc::new([1, 2, 3, 4]);\n-    let rc: ArcRef<[i32]> = rc.into();\n-\n-    assert_eq!(par_sum(rc), 10);\n-}\n-```\n-\n-## References into RAII locks\n-\n-```\n-use rustc_data_structures::owning_ref::RefRef;\n-use std::cell::{RefCell, Ref};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-    // Also works with Mutex and RwLock\n-\n-    let refref = {\n-        let refref = RefRef::new(refcell.borrow()).map(|x| &x.3);\n-        assert_eq!(*refref, 4);\n-\n-        // We move the RAII lock and the reference to one of\n-        // the subfields in the data it guards here:\n-        refref\n-    };\n-\n-    assert_eq!(*refref, 4);\n-\n-    drop(refref);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 4));\n-}\n-```\n-\n-## Mutable reference\n-\n-When the owned container implements `DerefMut`, it is also possible to make\n-a _mutable owning reference_. (e.g., with `Box`, `RefMut`, `MutexGuard`)\n-\n-```\n-use rustc_data_structures::owning_ref::RefMutRefMut;\n-use std::cell::{RefCell, RefMut};\n-\n-fn main() {\n-    let refcell = RefCell::new((1, 2, 3, 4));\n-\n-    let mut refmut_refmut = {\n-        let mut refmut_refmut = RefMutRefMut::new(refcell.borrow_mut()).map_mut(|x| &mut x.3);\n-        assert_eq!(*refmut_refmut, 4);\n-        *refmut_refmut *= 2;\n-\n-        refmut_refmut\n-    };\n-\n-    assert_eq!(*refmut_refmut, 8);\n-    *refmut_refmut *= 2;\n-\n-    drop(refmut_refmut);\n-\n-    assert_eq!(*refcell.borrow(), (1, 2, 3, 16));\n-}\n-```\n-*/\n-\n-pub use stable_deref_trait::{\n-    CloneStableDeref as CloneStableAddress, StableDeref as StableAddress,\n-};\n-use std::mem;\n-\n-/// An owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRef<O, T: ?Sized> {\n-    owner: O,\n-    reference: *const T,\n-}\n-\n-/// An mutable owning reference.\n-///\n-/// This wraps an owner `O` and a reference `&mut T` pointing\n-/// at something reachable from `O::Target` while keeping\n-/// the ability to move `self` around.\n-///\n-/// The owner is usually a pointer that points at some base type.\n-///\n-/// For more details and examples, see the module and method docs.\n-pub struct OwningRefMut<O, T: ?Sized> {\n-    owner: O,\n-    reference: *mut T,\n-}\n-\n-/// Helper trait for an erased concrete type an owner dereferences to.\n-/// This is used in form of a trait object for keeping\n-/// something around to (virtually) call the destructor.\n-pub trait Erased {}\n-impl<T> Erased for T {}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErased<'a> {\n-    /// Owner with the dereference type substituted to `Erased`.\n-    type Erased;\n-    /// Performs the type erasure.\n-    fn into_erased(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSend<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send`.\n-    type Erased: Send;\n-    /// Performs the type erasure.\n-    fn into_erased_send(self) -> Self::Erased;\n-}\n-\n-/// Helper trait for erasing the concrete type of what an owner dereferences to,\n-/// for example `Box<T> -> Box<Erased + Send + Sync>`. This would be unneeded with\n-/// higher kinded types support in the language.\n-#[allow(unused_lifetimes)]\n-pub unsafe trait IntoErasedSendSync<'a> {\n-    /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n-    type Erased: Send + Sync;\n-    /// Performs the type erasure.\n-    fn into_erased_send_sync(self) -> Self::Erased;\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningRef\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<O, T: ?Sized> OwningRef<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref, 42);\n-    /// }\n-    /// ```\n-    pub fn new(o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(o: O) -> Self\n-    where\n-        O: Deref<Target = T>,\n-    {\n-        OwningRef { reference: &*o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new owning reference that points at something reachable\n-    /// from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> &U,\n-    {\n-        OwningRef { reference: f(&self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRef;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRef<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRef { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRef<O, T>`\n-    /// to an `OwningRef<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRef<Box<O>, T> {\n-        OwningRef { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRef, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRef::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRef::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_a.map(|a| &a[0]);\n-    ///\n-    ///     let owning_ref_b: OwningRef<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_b.map(|a| &a[1].0);\n-    ///\n-    ///     let owning_refs: [OwningRef<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_a.erase_owner(), owning_ref_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs[0], 1);\n-    ///     assert_eq!(*owning_refs[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object which implements `Send`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSend<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send() }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object\n-    /// which implements `Send` and `Sync`.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    pub fn erase_send_sync_owner<'a>(self) -> OwningRef<O::Erased, T>\n-    where\n-        O: IntoErasedSendSync<'a>,\n-    {\n-        OwningRef { reference: self.reference, owner: self.owner.into_erased_send_sync() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-impl<O, T: ?Sized> OwningRefMut<O, T> {\n-    /// Creates a new owning reference from an owner\n-    /// initialized to the direct dereference of it.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new(42));\n-    ///     assert_eq!(*owning_ref_mut, 42);\n-    /// }\n-    /// ```\n-    pub fn new(mut o: O) -> Self\n-    where\n-        O: StableAddress,\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Like `new`, but doesn\u2019t require `O` to implement the `StableAddress` trait.\n-    /// Instead, the caller is responsible to make the same promises as implementing the trait.\n-    ///\n-    /// This is useful for cases where coherence rules prevents implementing the trait\n-    /// without adding a dependency to this crate in a third-party library.\n-    pub unsafe fn new_assert_stable_address(mut o: O) -> Self\n-    where\n-        O: DerefMut<Target = T>,\n-    {\n-        OwningRefMut { reference: &mut *o, owner: o }\n-    }\n-\n-    /// Converts `self` into a new _shared_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.map(|array| &array[2]);\n-    ///     assert_eq!(*owning_ref, 3);\n-    /// }\n-    /// ```\n-    pub fn map<F, U: ?Sized>(mut self, f: F) -> OwningRef<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &U,\n-    {\n-        OwningRef { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Converts `self` into a new _mutable_ owning reference that points at\n-    /// something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.map_mut(|array| &mut array[2]);\n-    ///     assert_eq!(*owning_ref_mut, 3);\n-    /// }\n-    /// ```\n-    pub fn map_mut<F, U: ?Sized>(mut self, f: F) -> OwningRefMut<O, U>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> &mut U,\n-    {\n-        OwningRefMut { reference: f(&mut self), owner: self.owner }\n-    }\n-\n-    /// Tries to convert `self` into a new _shared_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref = owning_ref_mut.try_map(|array| {\n-    ///         if array[2] == 3 { Ok(&array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRef<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&U, E>,\n-    {\n-        Ok(OwningRef { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Tries to convert `self` into a new _mutable_ owning reference that points\n-    /// at something reachable from the previous one.\n-    ///\n-    /// This can be a reference to a field of `U`, something reachable from a field of\n-    /// `U`, or even something unrelated with a `'static` lifetime.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::OwningRefMut;\n-    ///\n-    /// fn main() {\n-    ///     let owning_ref_mut = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     // create an owning reference that points at the\n-    ///     // third element of the array.\n-    ///     let owning_ref_mut = owning_ref_mut.try_map_mut(|array| {\n-    ///         if array[2] == 3 { Ok(&mut array[2]) } else { Err(()) }\n-    ///     });\n-    ///     assert_eq!(*owning_ref_mut.unwrap(), 3);\n-    /// }\n-    /// ```\n-    pub fn try_map_mut<F, U: ?Sized, E>(mut self, f: F) -> Result<OwningRefMut<O, U>, E>\n-    where\n-        O: StableAddress,\n-        F: FnOnce(&mut T) -> Result<&mut U, E>,\n-    {\n-        Ok(OwningRefMut { reference: f(&mut self)?, owner: self.owner })\n-    }\n-\n-    /// Converts `self` into a new owning reference with a different owner type.\n-    ///\n-    /// The new owner type needs to still contain the original owner in some way\n-    /// so that the reference into it remains valid. This function is marked unsafe\n-    /// because the user needs to manually uphold this guarantee.\n-    pub unsafe fn map_owner<F, P>(self, f: F) -> OwningRefMut<P, T>\n-    where\n-        O: StableAddress,\n-        P: StableAddress,\n-        F: FnOnce(O) -> P,\n-    {\n-        OwningRefMut { reference: self.reference, owner: f(self.owner) }\n-    }\n-\n-    /// Converts `self` into a new owning reference where the owner is wrapped\n-    /// in an additional `Box<O>`.\n-    ///\n-    /// This can be used to safely erase the owner of any `OwningRefMut<O, T>`\n-    /// to an `OwningRefMut<Box<Erased>, T>`.\n-    pub fn map_owner_box(self) -> OwningRefMut<Box<O>, T> {\n-        OwningRefMut { reference: self.reference, owner: Box::new(self.owner) }\n-    }\n-\n-    /// Erases the concrete base type of the owner with a trait object.\n-    ///\n-    /// This allows mixing of owned references with different owner base types.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// use rustc_data_structures::owning_ref::{OwningRefMut, Erased};\n-    ///\n-    /// fn main() {\n-    ///     // N.B., using the concrete types here for explicitness.\n-    ///     // For less verbose code type aliases like `BoxRef` are provided.\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>\n-    ///         = OwningRefMut::new(Box::new([1, 2, 3, 4]));\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, Vec<(i32, bool)>>\n-    ///         = OwningRefMut::new(Box::new(vec![(0, false), (1, true)]));\n-    ///\n-    ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, i32>\n-    ///         = owning_ref_mut_a.map_mut(|a| &mut a[0]);\n-    ///\n-    ///     let owning_ref_mut_b: OwningRefMut<Box<Vec<(i32, bool)>>, i32>\n-    ///         = owning_ref_mut_b.map_mut(|a| &mut a[1].0);\n-    ///\n-    ///     let owning_refs_mut: [OwningRefMut<Box<dyn Erased>, i32>; 2]\n-    ///         = [owning_ref_mut_a.erase_owner(), owning_ref_mut_b.erase_owner()];\n-    ///\n-    ///     assert_eq!(*owning_refs_mut[0], 1);\n-    ///     assert_eq!(*owning_refs_mut[1], 1);\n-    /// }\n-    /// ```\n-    pub fn erase_owner<'a>(self) -> OwningRefMut<O::Erased, T>\n-    where\n-        O: IntoErased<'a>,\n-    {\n-        OwningRefMut { reference: self.reference, owner: self.owner.into_erased() }\n-    }\n-\n-    // UNIMPLEMENTED: wrap_owner\n-\n-    // FIXME: Naming convention?\n-    /// A getter for the underlying owner.\n-    pub fn owner(&self) -> &O {\n-        &self.owner\n-    }\n-\n-    // FIXME: Naming convention?\n-    /// Discards the reference and retrieves the owner.\n-    pub fn into_inner(self) -> O {\n-        self.owner\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// OwningHandle\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::ops::{Deref, DerefMut};\n-\n-/// `OwningHandle` is a complement to `OwningRef`. Where `OwningRef` allows\n-/// consumers to pass around an owned object and a dependent reference,\n-/// `OwningHandle` contains an owned object and a dependent _object_.\n-///\n-/// `OwningHandle` can encapsulate a `RefMut` along with its associated\n-/// `RefCell`, or an `RwLockReadGuard` along with its associated `RwLock`.\n-/// However, the API is completely generic and there are no restrictions on\n-/// what types of owning and dependent objects may be used.\n-///\n-/// `OwningHandle` is created by passing an owner object (which dereferences\n-/// to a stable address) along with a callback which receives a pointer to\n-/// that stable location. The callback may then dereference the pointer and\n-/// mint a dependent object, with the guarantee that the returned object will\n-/// not outlive the referent of the pointer.\n-///\n-/// Since the callback needs to dereference a raw pointer, it requires `unsafe`\n-/// code. To avoid forcing this unsafety on most callers, the `ToHandle` trait is\n-/// implemented for common data structures. Types that implement `ToHandle` can\n-/// be wrapped into an `OwningHandle` without passing a callback.\n-pub struct OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    handle: H,\n-    _owner: O,\n-}\n-\n-impl<O, H> Deref for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    type Target = H::Target;\n-    fn deref(&self) -> &H::Target {\n-        self.handle.deref()\n-    }\n-}\n-\n-unsafe impl<O, H> StableAddress for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: StableAddress,\n-{\n-}\n-\n-impl<O, H> DerefMut for OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: DerefMut,\n-{\n-    fn deref_mut(&mut self) -> &mut H::Target {\n-        self.handle.deref_mut()\n-    }\n-}\n-\n-/// Trait to implement the conversion of owner to handle for common types.\n-pub trait ToHandle {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type Handle: Deref;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle;\n-}\n-\n-/// Trait to implement the conversion of owner to mutable handle for common types.\n-pub trait ToHandleMut {\n-    /// The type of handle to be encapsulated by the OwningHandle.\n-    type HandleMut: DerefMut;\n-\n-    /// Given an appropriately-long-lived pointer to ourselves, create a\n-    /// mutable handle to be encapsulated by the `OwningHandle`.\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut;\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandle<Handle = H>>,\n-    H: Deref,\n-{\n-    /// Creates a new `OwningHandle` for a type that implements `ToHandle`. For types\n-    /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n-    /// a callback to perform the conversion.\n-    pub fn new(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress<Target: ToHandleMut<HandleMut = H>>,\n-    H: DerefMut,\n-{\n-    /// Creates a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n-    pub fn new_mut(o: O) -> Self {\n-        OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle_mut(x) })\n-    }\n-}\n-\n-impl<O, H> OwningHandle<O, H>\n-where\n-    O: StableAddress,\n-    H: Deref,\n-{\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn new_with_fn<F>(o: O, f: F) -> Self\n-    where\n-        F: FnOnce(*const O::Target) -> H,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target);\n-        }\n-\n-        OwningHandle { handle: h, _owner: o }\n-    }\n-\n-    /// Creates a new OwningHandle. The provided callback will be invoked with\n-    /// a pointer to the object owned by `o`, and the returned value is stored\n-    /// as the object to which this `OwningHandle` will forward `Deref` and\n-    /// `DerefMut`.\n-    pub fn try_new<F, E>(o: O, f: F) -> Result<Self, E>\n-    where\n-        F: FnOnce(*const O::Target) -> Result<H, E>,\n-    {\n-        let h: H;\n-        {\n-            h = f(o.deref() as *const O::Target)?;\n-        }\n-\n-        Ok(OwningHandle { handle: h, _owner: o })\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std traits\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::borrow::Borrow;\n-use std::cmp::Ordering;\n-use std::fmt::{self, Debug};\n-use std::hash::{Hash, Hasher};\n-\n-impl<O, T: ?Sized> Deref for OwningRef<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> Deref for OwningRefMut<O, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        unsafe { &*self.reference }\n-    }\n-}\n-\n-impl<O, T: ?Sized> DerefMut for OwningRefMut<O, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n-    fn as_ref(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n-    fn as_mut(&mut self) -> &mut T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n-    fn borrow(&self) -> &T {\n-        self\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: Deref<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRef::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<O> for OwningRefMut<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(owner: O) -> Self {\n-        OwningRefMut::new(owner)\n-    }\n-}\n-\n-impl<O, T: ?Sized> From<OwningRefMut<O, T>> for OwningRef<O, T>\n-where\n-    O: StableAddress,\n-    O: DerefMut<Target = T>,\n-{\n-    fn from(other: OwningRefMut<O, T>) -> Self {\n-        OwningRef { owner: other.owner, reference: other.reference }\n-    }\n-}\n-\n-// ^ FIXME: Is an Into impl for calling into_inner() possible as well?\n-\n-impl<O, T: ?Sized> Debug for OwningRef<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRef {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Debug for OwningRefMut<O, T>\n-where\n-    O: Debug,\n-    T: Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"OwningRefMut {{ owner: {:?}, reference: {:?} }}\", self.owner(), &**self)\n-    }\n-}\n-\n-impl<O, T: ?Sized> Clone for OwningRef<O, T>\n-where\n-    O: CloneStableAddress,\n-{\n-    fn clone(&self) -> Self {\n-        OwningRef { owner: self.owner.clone(), reference: self.reference }\n-    }\n-}\n-\n-unsafe impl<O, T: ?Sized> CloneStableAddress for OwningRef<O, T> where O: CloneStableAddress {}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRef<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRef<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a T: Sync,\n-{\n-}\n-\n-unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n-where\n-    O: Send,\n-    for<'a> &'a mut T: Send,\n-{\n-}\n-unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n-where\n-    O: Sync,\n-    for<'a> &'a mut T: Sync,\n-{\n-}\n-\n-impl Debug for dyn Erased {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<Erased>\",)\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRef<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRef<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRef<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRef<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRef<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-impl<O, T: ?Sized> PartialEq for OwningRefMut<O, T>\n-where\n-    T: PartialEq,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.deref().eq(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Eq for OwningRefMut<O, T> where T: Eq {}\n-\n-impl<O, T: ?Sized> PartialOrd for OwningRefMut<O, T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.deref().partial_cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Ord for OwningRefMut<O, T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.deref().cmp(other.deref())\n-    }\n-}\n-\n-impl<O, T: ?Sized> Hash for OwningRefMut<O, T>\n-where\n-    T: Hash,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.deref().hash(state);\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// std types integration and convenience type defs\n-/////////////////////////////////////////////////////////////////////////////\n-\n-use std::cell::{Ref, RefCell, RefMut};\n-use std::rc::Rc;\n-use std::sync::Arc;\n-use std::sync::{MutexGuard, RwLockReadGuard, RwLockWriteGuard};\n-\n-impl<T: 'static> ToHandle for RefCell<T> {\n-    type Handle = Ref<'static, T>;\n-    unsafe fn to_handle(x: *const Self) -> Self::Handle {\n-        (*x).borrow()\n-    }\n-}\n-\n-impl<T: 'static> ToHandleMut for RefCell<T> {\n-    type HandleMut = RefMut<'static, T>;\n-    unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut {\n-        (*x).borrow_mut()\n-    }\n-}\n-\n-// N.B., implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n-// about which handle creation to use (i.e., read() vs try_read()) as well as\n-// what to do with error results.\n-\n-/// Typedef of an owning reference that uses a `Box` as the owner.\n-pub type BoxRef<T, U = T> = OwningRef<Box<T>, U>;\n-/// Typedef of an owning reference that uses a `Vec` as the owner.\n-pub type VecRef<T, U = T> = OwningRef<Vec<T>, U>;\n-/// Typedef of an owning reference that uses a `String` as the owner.\n-pub type StringRef = OwningRef<String, str>;\n-\n-/// Typedef of an owning reference that uses an `Rc` as the owner.\n-pub type RcRef<T, U = T> = OwningRef<Rc<T>, U>;\n-/// Typedef of an owning reference that uses an `Arc` as the owner.\n-pub type ArcRef<T, U = T> = OwningRef<Arc<T>, U>;\n-\n-/// Typedef of an owning reference that uses a `Ref` as the owner.\n-pub type RefRef<'a, T, U = T> = OwningRef<Ref<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRef<'a, T, U = T> = OwningRef<RefMut<'a, T>, U>;\n-/// Typedef of an owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRef<'a, T, U = T> = OwningRef<MutexGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockReadGuard` as the owner.\n-pub type RwLockReadGuardRef<'a, T, U = T> = OwningRef<RwLockReadGuard<'a, T>, U>;\n-/// Typedef of an owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRef<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-/// Typedef of a mutable owning reference that uses a `Box` as the owner.\n-pub type BoxRefMut<T, U = T> = OwningRefMut<Box<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `Vec` as the owner.\n-pub type VecRefMut<T, U = T> = OwningRefMut<Vec<T>, U>;\n-/// Typedef of a mutable owning reference that uses a `String` as the owner.\n-pub type StringRefMut = OwningRefMut<String, str>;\n-\n-/// Typedef of a mutable owning reference that uses a `RefMut` as the owner.\n-pub type RefMutRefMut<'a, T, U = T> = OwningRefMut<RefMut<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses a `MutexGuard` as the owner.\n-pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n-/// Typedef of a mutable owning reference that uses an `RwLockWriteGuard` as the owner.\n-pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n-\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Rc<T> {\n-    type Erased = Rc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + 'a>;\n-    fn into_erased(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSend<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Send + 'a>;\n-    fn into_erased_send(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n-    type Erased = Box<dyn Erased + Sync + Send + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        let result: Box<dyn Erased + Send + 'a> = self;\n-        // This is safe since Erased can always implement Sync\n-        // Only the destructor is available and it takes &mut self\n-        unsafe { mem::transmute(result) }\n-    }\n-}\n-\n-unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n-    type Erased = Arc<dyn Erased + Send + Sync + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n-        self\n-    }\n-}\n-\n-/// Typedef of an owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Rc` as the owner.\n-pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n-/// Typedef of an owning reference that uses an erased `Arc` as the owner.\n-pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n-\n-/// Typedef of a mutable owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "a9b187c4ce0a79f979ae4c562ebe56ab598c40bb", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "removed", "additions": 0, "deletions": 711, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=c0ceefdfaf9a1e131bfbf4849bbaaac23af621a4", "patch": "@@ -1,711 +0,0 @@\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref {\n-    use super::super::OwningRef;\n-    use super::super::{BoxRef, Erased, ErasedBoxRef, RcRef};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-    use std::rc::Rc;\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRef<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRef<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_chained() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n-        let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRef::new(Box::new(example().1)).map(|x| &x[..5]).map(|x| &x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRef<String> = Box::new(example().1).into();\n-        let or = or.map(|x| &x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example())).map(|x| &x.1[..]);\n-\n-        let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1)).map(|x| &x[..]);\n-\n-        let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n-        use super::super::{RefMutRef, RefRef};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefRef::new(a.borrow());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRef::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRef::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockReadGuardRef::new(a.read().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRef::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key.clone().map(|s| &s[..3]), 42);\n-        hash.insert(key.clone().map(|s| &s[4..]), 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe { a.map_owner(Rc::new) };\n-        let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Rc::new) };\n-\n-        let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n-        let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n-\n-        let _g = e.clone();\n-        let _h = f.clone();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRef<Vec<u8>, [u8]> = OwningRef::new(vec![]).map(|x| &x[..]);\n-        let b: OwningRef<Box<[u8]>, [u8]> =\n-            OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-        let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-}\n-\n-mod owning_handle {\n-    use super::super::OwningHandle;\n-    use super::super::RcRef;\n-    use std::cell::RefCell;\n-    use std::rc::Rc;\n-    use std::sync::Arc;\n-    use std::sync::RwLock;\n-\n-    #[test]\n-    fn owning_handle() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle =\n-            OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_ok() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            Ok(unsafe { x.as_ref() }.unwrap().borrow_mut())\n-        })\n-        .unwrap();\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn try_owning_handle_err() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-            if false {\n-                return Ok(unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            }\n-            Err(())\n-        });\n-        assert!(handle.is_err());\n-    }\n-\n-    #[test]\n-    fn nested() {\n-        use std::cell::RefCell;\n-        use std::sync::{Arc, RwLock};\n-\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let handle = OwningHandle::new(cell_ref);\n-        assert_eq!(*handle, 2);\n-    }\n-\n-    #[test]\n-    fn owning_handle_mut_safe() {\n-        use std::cell::RefCell;\n-        let cell = Rc::new(RefCell::new(2));\n-        let cell_ref = RcRef::new(cell);\n-        let mut handle = OwningHandle::new_mut(cell_ref);\n-        assert_eq!(*handle, 2);\n-        *handle = 3;\n-        assert_eq!(*handle, 3);\n-    }\n-\n-    #[test]\n-    fn owning_handle_safe_2() {\n-        let result = {\n-            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-            let curr = RcRef::new(complex);\n-            let curr =\n-                OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            let mut curr = OwningHandle::new_with_fn(curr, |x| {\n-                unsafe { x.as_ref() }.unwrap().try_write().unwrap()\n-            });\n-            assert_eq!(*curr, \"someString\");\n-            *curr = \"someOtherString\";\n-            curr\n-        };\n-        assert_eq!(*result, \"someOtherString\");\n-    }\n-}\n-\n-// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n-#[cfg(not(miri))]\n-mod owning_ref_mut {\n-    use super::super::BoxRef;\n-    use super::super::{BoxRefMut, Erased, ErasedBoxRefMut, OwningRefMut};\n-    use std::cmp::Ordering;\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::collections::HashMap;\n-    use std::hash::{Hash, Hasher};\n-\n-    #[derive(Debug, PartialEq)]\n-    struct Example(u32, String, [u8; 3]);\n-    fn example() -> Example {\n-        Example(42, \"hello world\".to_string(), [1, 2, 3])\n-    }\n-\n-    #[test]\n-    fn new_deref() {\n-        let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn new_deref_mut() {\n-        let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-        assert_eq!(&mut *or, &mut ());\n-    }\n-\n-    #[test]\n-    fn mutate() {\n-        let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n-        assert_eq!(&*or, &0);\n-        *or = 1;\n-        assert_eq!(&*or, &1);\n-    }\n-\n-    #[test]\n-    fn into() {\n-        let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    #[test]\n-    fn map_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_static_ref() {\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_offset_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n-        assert_eq!(&*or, &42);\n-\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n-        assert_eq!(&*or, &2);\n-    }\n-\n-    #[test]\n-    fn map_mut_heap_ref() {\n-        let or: BoxRefMut<Example> = Box::new(example()).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n-        assert_eq!(&*or, \"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_static_ref() {\n-        static mut MUT_S: [u8; 5] = *b\"hello\";\n-\n-        let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n-        assert_eq!(&*or, b\"hello\");\n-    }\n-\n-    #[test]\n-    fn map_mut_chained() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n-        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn map_chained_inference() {\n-        let or = BoxRefMut::new(Box::new(example().1))\n-            .map_mut(|x| &mut x[..5])\n-            .map_mut(|x| &mut x[1..3]);\n-        assert_eq!(&*or, \"el\");\n-    }\n-\n-    #[test]\n-    fn try_map_mut() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n-        assert_eq!(&*or.unwrap(), \"ello\");\n-\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n-        assert!(or.is_err());\n-    }\n-\n-    #[test]\n-    fn owner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        assert_eq!(&**or.owner(), \"hello world\");\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        assert_eq!(&*or, \"hello\");\n-        let s = *or.into_inner();\n-        assert_eq!(&s, \"hello world\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug() {\n-        let or: BoxRefMut<String> = Box::new(example().1).into();\n-        let or = or.map_mut(|x| &mut x[..5]);\n-        let s = format!(\"{:?}\", or);\n-        assert_eq!(&s, \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-    }\n-\n-    #[test]\n-    fn erased_owner() {\n-        let o1: BoxRefMut<Example, str> =\n-            BoxRefMut::new(Box::new(example())).map_mut(|x| &mut x.1[..]);\n-\n-        let o2: BoxRefMut<String, str> =\n-            BoxRefMut::new(Box::new(example().1)).map_mut(|x| &mut x[..]);\n-\n-        let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-    }\n-\n-    #[test]\n-    fn raii_locks() {\n-        use super::super::RefMutRefMut;\n-        use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n-        use std::cell::RefCell;\n-        use std::sync::{Mutex, RwLock};\n-\n-        {\n-            let a = RefCell::new(1);\n-            let a = {\n-                let a = RefMutRefMut::new(a.borrow_mut());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = Mutex::new(1);\n-            let a = {\n-                let a = MutexGuardRefMut::new(a.lock().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-        {\n-            let a = RwLock::new(1);\n-            let a = {\n-                let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n-                assert_eq!(*a, 1);\n-                a\n-            };\n-            assert_eq!(*a, 1);\n-            drop(a);\n-        }\n-    }\n-\n-    #[test]\n-    fn eq() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.eq(&or2), true);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        assert_eq!(or1.cmp(&or2), Ordering::Less);\n-    }\n-\n-    #[test]\n-    fn partial_cmp() {\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-    }\n-\n-    #[test]\n-    fn hash() {\n-        let mut h1 = DefaultHasher::new();\n-        let mut h2 = DefaultHasher::new();\n-\n-        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-\n-        or1.hash(&mut h1);\n-        or2.hash(&mut h2);\n-\n-        assert_eq!(h1.finish(), h2.finish());\n-    }\n-\n-    #[test]\n-    fn borrow() {\n-        let mut hash = HashMap::new();\n-        let key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n-        let key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n-\n-        hash.insert(key1, 42);\n-        hash.insert(key2, 23);\n-\n-        assert_eq!(hash.get(\"foo\"), Some(&42));\n-        assert_eq!(hash.get(\"bar\"), Some(&23));\n-    }\n-\n-    #[test]\n-    fn total_erase() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe { a.map_owner(Box::new) };\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe { b.map_owner(Box::new) };\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn total_erase_box() {\n-        let a: OwningRefMut<Vec<u8>, [u8]> = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-        let b: OwningRefMut<Box<[u8]>, [u8]> =\n-            OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-    }\n-\n-    #[test]\n-    fn try_map1() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map2() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn try_map3() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-    }\n-\n-    #[test]\n-    fn try_map4() {\n-        use std::any::Any;\n-\n-        let x = Box::new(123_i32);\n-        let y: Box<dyn Any> = x;\n-\n-        assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-    }\n-\n-    #[test]\n-    fn into_owning_ref() {\n-        use super::super::BoxRef;\n-\n-        let or: BoxRefMut<()> = Box::new(()).into();\n-        let or: BoxRef<()> = or.into();\n-        assert_eq!(&*or, &());\n-    }\n-\n-    struct Foo {\n-        u: u32,\n-    }\n-    struct Bar {\n-        f: Foo,\n-    }\n-\n-    #[test]\n-    fn ref_mut() {\n-        use std::cell::RefCell;\n-\n-        let a = RefCell::new(Bar { f: Foo { u: 42 } });\n-        let mut b = OwningRefMut::new(a.borrow_mut());\n-        assert_eq!(b.f.u, 42);\n-        b.f.u = 43;\n-        let mut c = b.map_mut(|x| &mut x.f);\n-        assert_eq!(c.u, 43);\n-        c.u = 44;\n-        let mut d = c.map_mut(|x| &mut x.u);\n-        assert_eq!(*d, 44);\n-        *d = 45;\n-        assert_eq!(*d, 45);\n-    }\n-}"}, {"sha": "215b80887415f6ae74df5082e9481e6cdd77ad43", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7056548f9dd51d44d9d29fd0376ac509605076b/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=d7056548f9dd51d44d9d29fd0376ac509605076b", "patch": "@@ -7,9 +7,6 @@\n //! while the serial versions degenerate straightforwardly to serial execution.\n //! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n-//! serial version and `Erased + Send + Sync` for the parallel version.\n-//!\n //! Types\n //! -----\n //! The parallel versions of types provide various kinds of synchronization,\n@@ -60,12 +57,6 @@ cfg_if! {\n         pub unsafe auto trait Send {}\n         pub unsafe auto trait Sync {}\n \n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {\n-                $v.erase_owner()\n-            }\n-        }\n         unsafe impl<T> Send for T {}\n         unsafe impl<T> Sync for T {}\n \n@@ -376,15 +367,6 @@ cfg_if! {\n         /// This makes locks panic if they are already held.\n         /// It is only useful when you are running in a single thread\n         const ERROR_CHECKING: bool = false;\n-\n-        #[macro_export]\n-        macro_rules! rustc_erase_owner {\n-            ($v:expr) => {{\n-                let v = $v;\n-                ::rustc_data_structures::sync::assert_send_val(&v);\n-                v.erase_send_sync_owner()\n-            }}\n-        }\n     }\n }\n "}]}