{"sha": "79a57625f5900a67cb76732c4bb7634778f066ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YTU3NjI1ZjU5MDBhNjdjYjc2NzMyYzRiYjc2MzQ3NzhmMDY2YWU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-10-24T15:37:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-08T16:29:48Z"}, "message": "Move DepNodeExt outside of the macro.", "tree": {"sha": "98846967dfcfd9c6888de23c0ad1d0e910777b56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98846967dfcfd9c6888de23c0ad1d0e910777b56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79a57625f5900a67cb76732c4bb7634778f066ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79a57625f5900a67cb76732c4bb7634778f066ae", "html_url": "https://github.com/rust-lang/rust/commit/79a57625f5900a67cb76732c4bb7634778f066ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79a57625f5900a67cb76732c4bb7634778f066ae/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c496de374407c0937cf5257d89230b5358d053", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c496de374407c0937cf5257d89230b5358d053", "html_url": "https://github.com/rust-lang/rust/commit/b5c496de374407c0937cf5257d89230b5358d053"}], "stats": {"total": 186, "additions": 91, "deletions": 95}, "files": [{"sha": "2a9d6b00db1135ce9a5dd41bb3556ca46806c661", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 91, "deletions": 95, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/79a57625f5900a67cb76732c4bb7634778f066ae/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a57625f5900a67cb76732c4bb7634778f066ae/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=79a57625f5900a67cb76732c4bb7634778f066ae", "patch": "@@ -191,101 +191,10 @@ macro_rules! define_dep_nodes {\n             )*\n         }\n \n-        pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n-\n-        // We keep a lot of `DepNode`s in memory during compilation. It's not\n-        // required that their size stay the same, but we don't want to change\n-        // it inadvertently. This assert just ensures we're aware of any change.\n-        #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-        static_assert_size!(DepNode, 17);\n-\n-        #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-        static_assert_size!(DepNode, 24);\n-\n-        pub trait DepNodeExt: Sized {\n-            /// Construct a DepNode from the given DepKind and DefPathHash. This\n-            /// method will assert that the given DepKind actually requires a\n-            /// single DefId/DefPathHash parameter.\n-            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n-\n-            /// Extracts the DefId corresponding to this DepNode. This will work\n-            /// if two conditions are met:\n-            ///\n-            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-            /// 2. the item that the DefPath refers to exists in the current tcx.\n-            ///\n-            /// Condition (1) is determined by the DepKind variant of the\n-            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-            /// refers to something from the previous compilation session that\n-            /// has been removed.\n-            fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n-\n-            /// Used in testing\n-            fn from_label_string(label: &str, def_path_hash: DefPathHash)\n-                -> Result<Self, ()>;\n-\n-            /// Used in testing\n-            fn has_label_string(label: &str) -> bool;\n-        }\n-\n-        impl DepNodeExt for DepNode {\n-            /// Construct a DepNode from the given DepKind and DefPathHash. This\n-            /// method will assert that the given DepKind actually requires a\n-            /// single DefId/DefPathHash parameter.\n-            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: def_path_hash.0.into(),\n-                }\n-            }\n-\n-            /// Extracts the DefId corresponding to this DepNode. This will work\n-            /// if two conditions are met:\n-            ///\n-            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n-            /// 2. the item that the DefPath refers to exists in the current tcx.\n-            ///\n-            /// Condition (1) is determined by the DepKind variant of the\n-            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n-            /// refers to something from the previous compilation session that\n-            /// has been removed.\n-            fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-                if self.kind.can_reconstruct_query_key() {\n-                    tcx.queries.on_disk_cache.as_ref()?.def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            /// Used in testing\n-            fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n-                let kind = match label {\n-                    $(\n-                        stringify!($variant) => DepKind::$variant,\n-                    )*\n-                    _ => return Err(()),\n-                };\n-\n-                if !kind.can_reconstruct_query_key() {\n-                    return Err(());\n-                }\n-\n-                if kind.has_params() {\n-                    Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n-                } else {\n-                    Ok(DepNode::new_no_params(kind))\n-                }\n-            }\n-\n-            /// Used in testing\n-            fn has_label_string(label: &str) -> bool {\n-                match label {\n-                    $(\n-                        stringify!($variant) => true,\n-                    )*\n-                    _ => false,\n-                }\n+        fn dep_kind_from_label_string(label: &str) -> Result<DepKind, ()> {\n+            match label {\n+                $(stringify!($variant) => Ok(DepKind::$variant),)*\n+                _ => Err(()),\n             }\n         }\n \n@@ -312,6 +221,93 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n+pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n+\n+// We keep a lot of `DepNode`s in memory during compilation. It's not\n+// required that their size stay the same, but we don't want to change\n+// it inadvertently. This assert just ensures we're aware of any change.\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+static_assert_size!(DepNode, 17);\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+static_assert_size!(DepNode, 24);\n+\n+pub trait DepNodeExt: Sized {\n+    /// Construct a DepNode from the given DepKind and DefPathHash. This\n+    /// method will assert that the given DepKind actually requires a\n+    /// single DefId/DefPathHash parameter.\n+    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n+\n+    /// Used in testing\n+    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<Self, ()>;\n+\n+    /// Used in testing\n+    fn has_label_string(label: &str) -> bool;\n+}\n+\n+impl DepNodeExt for DepNode {\n+    /// Construct a DepNode from the given DepKind and DefPathHash. This\n+    /// method will assert that the given DepKind actually requires a\n+    /// single DefId/DefPathHash parameter.\n+    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n+        debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+        DepNode { kind, hash: def_path_hash.0.into() }\n+    }\n+\n+    /// Extracts the DefId corresponding to this DepNode. This will work\n+    /// if two conditions are met:\n+    ///\n+    /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+    /// 2. the item that the DefPath refers to exists in the current tcx.\n+    ///\n+    /// Condition (1) is determined by the DepKind variant of the\n+    /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+    /// refers to something from the previous compilation session that\n+    /// has been removed.\n+    fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+        if self.kind.can_reconstruct_query_key() {\n+            tcx.queries\n+                .on_disk_cache\n+                .as_ref()?\n+                .def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Used in testing\n+    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n+        let kind = dep_kind_from_label_string(label)?;\n+\n+        if !kind.can_reconstruct_query_key() {\n+            return Err(());\n+        }\n+\n+        if kind.has_params() {\n+            Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n+        } else {\n+            Ok(DepNode::new_no_params(kind))\n+        }\n+    }\n+\n+    /// Used in testing\n+    fn has_label_string(label: &str) -> bool {\n+        dep_kind_from_label_string(label).is_ok()\n+    }\n+}\n+\n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     #[inline]\n     fn can_reconstruct_query_key() -> bool {"}]}