{"sha": "07c415c2154f29d6dce8da0154ef41c8a5497fbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YzQxNWMyMTU0ZjI5ZDZkY2U4ZGEwMTU0ZWY0MWM4YTU0OTdmYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-25T22:18:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-25T22:18:27Z"}, "message": "Auto merge of #51033 - coryshrmn:master, r=dtolnay\n\nstabilize RangeBounds collections_range #30877\n\nThe FCP for #30877 closed last month, with the decision to:\n1. move from `collections::range::RangeArgument` to `ops::RangeBounds`, and\n2. rename `start()` and `end()` to `start_bounds()` and `end_bounds()`.\n\nSimon Sapin already moved it to `ops::RangeBounds` in #49163.\n\nI renamed the functions, and removed the old `collections::range::RangeArgument` alias.\n\nThis is my first Rust PR, please let me know if I can improve anything. This passes all tests for me, except the `clippy` tool (which uses `RangeArgument::start()`).\n\nI considered deprecating `start()` and `end()` instead of removing them, but the contribution guidelines indicate we can break `clippy` temporarily. I thought it was best to remove the functions, since we're worried about name collisions with `Range::start` and `end`.\n\nCloses #30877.", "tree": {"sha": "28953c14cf6541f651c295f9815ae4c2aa5614d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28953c14cf6541f651c295f9815ae4c2aa5614d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07c415c2154f29d6dce8da0154ef41c8a5497fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07c415c2154f29d6dce8da0154ef41c8a5497fbf", "html_url": "https://github.com/rust-lang/rust/commit/07c415c2154f29d6dce8da0154ef41c8a5497fbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07c415c2154f29d6dce8da0154ef41c8a5497fbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "990d8aa743b1dda3cc0f68fe09524486261812c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/990d8aa743b1dda3cc0f68fe09524486261812c6", "html_url": "https://github.com/rust-lang/rust/commit/990d8aa743b1dda3cc0f68fe09524486261812c6"}, {"sha": "f7c4a33f32b8139778b8c6792b9e55c74770a234", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c4a33f32b8139778b8c6792b9e55c74770a234", "html_url": "https://github.com/rust-lang/rust/commit/f7c4a33f32b8139778b8c6792b9e55c74770a234"}], "stats": {"total": 176, "additions": 68, "deletions": 108}, "files": [{"sha": "28c42144b2af540f6e3905325bd309964717946c", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -1834,7 +1834,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n      Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n         where Q: Ord, K: Borrow<Q>\n {\n-    match (range.start(), range.end()) {\n+    match (range.start_bound(), range.end_bound()) {\n         (Excluded(s), Excluded(e)) if s==e =>\n             panic!(\"range start and end are equal and excluded in BTreeMap\"),\n         (Included(s), Included(e)) |\n@@ -1852,7 +1852,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start()) {\n+        let min_edge = match (min_found, range.start_bound()) {\n             (false, Included(key)) => match search::search_linear(&min_node, key) {\n                 (i, true) => { min_found = true; i },\n                 (i, false) => i,\n@@ -1866,7 +1866,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n             (true, Excluded(_)) => 0,\n         };\n \n-        let max_edge = match (max_found, range.end()) {\n+        let max_edge = match (max_found, range.end_bound()) {\n             (false, Included(key)) => match search::search_linear(&max_node, key) {\n                 (i, true) => { max_found = true; i+1 },\n                 (i, false) => i,"}, {"sha": "a988b6a26d9df9e2038c6425581ad38d45c29db5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -1493,12 +1493,12 @@ impl String {\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded => len,\n@@ -1551,12 +1551,12 @@ impl String {\n         // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n-        match range.start() {\n+        match range.start_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n)),\n              Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n              Unbounded => {},\n         };\n-        match range.end() {\n+        match range.end_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n + 1)),\n              Excluded(&n) => assert!(self.is_char_boundary(n)),\n              Unbounded => {},"}, {"sha": "b5739e1a825538ceffa016bd3f2a550d5e39ae28", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -1166,12 +1166,12 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "e917a65c9c5ad51c8c7e6576245a0f7c65ae28c0", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -980,12 +980,12 @@ impl<T> VecDeque<T> {\n         // and the head/tail values will be restored correctly.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "01e279589da98453c32a0293493164b4b25dc215", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 53, "deletions": 85, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -588,14 +588,12 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n /// `Bound`s are range endpoints:\n ///\n /// ```\n-/// #![feature(collections_range)]\n-///\n /// use std::ops::Bound::*;\n /// use std::ops::RangeBounds;\n ///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n+/// assert_eq!((..100).start_bound(), Unbounded);\n+/// assert_eq!((1..12).start_bound(), Included(&1));\n+/// assert_eq!((1..12).end_bound(), Excluded(&12));\n /// ```\n ///\n /// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n@@ -632,9 +630,7 @@ pub enum Bound<T> {\n     Unbounded,\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b` or `c..d`.\n pub trait RangeBounds<T: ?Sized> {\n@@ -645,17 +641,16 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections_range)]\n-    ///\n     /// # fn main() {\n     /// use std::ops::Bound::*;\n     /// use std::ops::RangeBounds;\n     ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n+    /// assert_eq!((..10).start_bound(), Unbounded);\n+    /// assert_eq!((3..10).start_bound(), Included(&3));\n     /// # }\n     /// ```\n-    fn start(&self) -> Bound<&T>;\n+    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+    fn start_bound(&self) -> Bound<&T>;\n \n     /// End index bound.\n     ///\n@@ -664,17 +659,16 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(collections_range)]\n-    ///\n     /// # fn main() {\n     /// use std::ops::Bound::*;\n     /// use std::ops::RangeBounds;\n     ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// assert_eq!((3..).end_bound(), Unbounded);\n+    /// assert_eq!((3..10).end_bound(), Excluded(&10));\n     /// # }\n     /// ```\n-    fn end(&self) -> Bound<&T>;\n+    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+    fn end_bound(&self) -> Bound<&T>;\n \n \n     /// Returns `true` if `item` is contained in the range.\n@@ -699,13 +693,13 @@ pub trait RangeBounds<T: ?Sized> {\n         T: PartialOrd<U>,\n         U: ?Sized + PartialOrd<T>,\n     {\n-        (match self.start() {\n+        (match self.start_bound() {\n             Included(ref start) => *start <= item,\n             Excluded(ref start) => *start < item,\n             Unbounded => true,\n         })\n         &&\n-        (match self.end() {\n+        (match self.end_bound() {\n             Included(ref end) => item <= *end,\n             Excluded(ref end) => item < *end,\n             Unbounded => true,\n@@ -715,91 +709,77 @@ pub trait RangeBounds<T: ?Sized> {\n \n use self::Bound::{Excluded, Included, Unbounded};\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T: ?Sized> RangeBounds<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(&self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n             (Excluded(ref start), _) => Excluded(start),\n             (Unbounded, _)           => Unbounded,\n         }\n     }\n \n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         match *self {\n             (_, Included(ref end)) => Included(end),\n             (_, Excluded(ref end)) => Excluded(end),\n@@ -808,75 +788,63 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n \n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         self.1\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeFrom<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeTo<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for Range<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Excluded(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeInclusive<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(self.end)\n     }\n }\n \n-#[unstable(feature = \"collections_range\",\n-           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n-           issue = \"30877\")]\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n impl<'a, T> RangeBounds<T> for RangeToInclusive<&'a T> {\n-    fn start(&self) -> Bound<&T> {\n+    fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n-    fn end(&self) -> Bound<&T> {\n+    fn end_bound(&self) -> Bound<&T> {\n         Included(self.end)\n     }\n }"}, {"sha": "56bb961324210620f35a50afd74f51a34cd14d15", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -119,12 +119,12 @@ impl<A: Array> ArrayVec<A> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,"}, {"sha": "92b0bffd7529b3346ad26fd7526eee4a18785fee", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -215,7 +215,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     fn range_slice_indices<R>(&self, range: R) -> (usize, usize)\n         where R: RangeBounds<K>\n     {\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Bound::Included(ref k) => {\n                 match self.lookup_index_for(k) {\n                     Ok(index) | Err(index) => index\n@@ -230,7 +230,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n             Bound::Unbounded => 0,\n         };\n \n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Bound::Included(ref k) => {\n                 match self.lookup_index_for(k) {\n                     Ok(index) => index + 1,"}, {"sha": "d8e79b97970d2ecb277b782fe56dc3de65170be2", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07c415c2154f29d6dce8da0154ef41c8a5497fbf/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=07c415c2154f29d6dce8da0154ef41c8a5497fbf", "patch": "@@ -437,14 +437,6 @@ pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n-#[unstable(feature = \"collections_range\", issue = \"30877\")]\n-#[rustc_deprecated(reason = \"renamed and moved to `std::ops::RangeBounds`\", since = \"1.26.0\")]\n-#[doc(hidden)]\n-/// Range syntax\n-pub mod range {\n-    pub use ops::RangeBounds as RangeArgument;\n-}\n-\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n pub use heap::CollectionAllocErr;\n "}]}