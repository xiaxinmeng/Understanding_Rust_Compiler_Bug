{"sha": "80d6b569547cfb14e6fd8671599da205f7860652", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZDZiNTY5NTQ3Y2ZiMTRlNmZkODY3MTU5OWRhMjA1Zjc4NjA2NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T17:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T17:47:51Z"}, "message": "Auto merge of #1745 - hyd-dev:unsup-foreign-calls-are-not-ub, r=RalfJung\n\nImprove error message of calling unsupported non-\"C\"/\"system\"-ABI foreign function\n\nMiri currently reports the following `foo()` call has ABI-mismatch UB:\n```rust\n#[cfg(unix)]\nextern \"Rust\" { // or any non-\"C\" ABI\n    fn foo();\n}\n\n#[cfg(windows)]\nextern \"C\" { // or any non-\"system\" ABI\n    fn foo();\n}\n\nfn main() {\n    unsafe {\n        foo();\n    }\n}\n```\n[Output when targeting Linux](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=72afc3bd4d9fdab962422cfc2c5a2166) (and maybe also macOS):\n```\nerror: Undefined Behavior: calling a function with ABI C using caller ABI Rust\n  --> src/main.rs:13:9\n   |\n13 |         foo();\n   |         ^^^^^ calling a function with ABI C using caller ABI Rust\n   |\n   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavio\n```\nOutput when targeting Windows:\n```\nerror: Undefined Behavior: calling a function with ABI system using caller ABI C\n  --> <anon>:13:9\n   |\n13 |         foo();\n   |         ^^^^^ calling a function with ABI system using caller ABI C\n   |\n   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n```\n\nHowever, to my knowledge, that's not UB -- it's just unsupported by Miri (and Miri can't assume the function has `\"C\"` or `\"system\"` ABI since Miri doesn't know about it). I believe that is because of the overzealous `check_abi()` call before the long `match` in `src/shims/{posix,windows}/foreign_items.rs`. The ABI is checked to match the system one (`\"system\"` on Windows, `\"C\"` otherwise) no matter the callee is recognized as a shim or an unsupported foreign function.\n\nTherefore, this PR removes the `check_abi()` call before the `match` and inserts a `check_abi()` call to each non-wildcard match.", "tree": {"sha": "86d65bae69700ef2cfa3bf85a217b6d0d5c267b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86d65bae69700ef2cfa3bf85a217b6d0d5c267b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80d6b569547cfb14e6fd8671599da205f7860652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80d6b569547cfb14e6fd8671599da205f7860652", "html_url": "https://github.com/rust-lang/rust/commit/80d6b569547cfb14e6fd8671599da205f7860652", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80d6b569547cfb14e6fd8671599da205f7860652/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0788188c7b586289edb878f1f5b4e23700671978", "url": "https://api.github.com/repos/rust-lang/rust/commits/0788188c7b586289edb878f1f5b4e23700671978", "html_url": "https://github.com/rust-lang/rust/commit/0788188c7b586289edb878f1f5b4e23700671978"}, {"sha": "7ec919daa4c3e211dd2ef56014a11f967c583013", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec919daa4c3e211dd2ef56014a11f967c583013", "html_url": "https://github.com/rust-lang/rust/commit/7ec919daa4c3e211dd2ef56014a11f967c583013"}], "stats": {"total": 160, "additions": 152, "deletions": 8}, "files": [{"sha": "b3d53cdc10dede24408cae257e1d11c8110de4cc", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=80d6b569547cfb14e6fd8671599da205f7860652", "patch": "@@ -22,48 +22,54 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n \n-        check_abi(abi, Abi::C { unwind: false })?;\n-\n         match link_name {\n             // Environment related shims\n             \"getenv\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name, ref value, ref overwrite] = check_arg_count(args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref flag, ref mode] = check_arg_count(args)?;\n                 let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let result = this.fcntl(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref count] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -72,6 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref n] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -82,59 +89,70 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref target, ref linkpath] = check_arg_count(args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref oldpath, ref newpath] = check_arg_count(args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref mode] = check_arg_count(args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp] = check_arg_count(args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref whence] = check_arg_count(args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref pathname, ref buf, ref bufsize] = check_arg_count(args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ret, ref align, ref size] = check_arg_count(args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -165,6 +183,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref handle, ref symbol] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n@@ -179,6 +198,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n@@ -204,6 +224,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref dtor] = check_arg_count(args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n@@ -232,20 +253,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n@@ -258,148 +282,177 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref kind] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex, ref abstime] = check_arg_count(args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref attr, ref start, ref arg] = check_arg_count(args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref retval] = check_arg_count(args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref req, ref rem] = check_arg_count(args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n@@ -409,6 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref prepare, ref parent, ref child] = check_arg_count(args)?;\n                 this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n@@ -421,6 +475,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref _attr, ref guard_size] = check_arg_count(args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n@@ -433,33 +488,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"pthread_attr_setstacksize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n             | \"signal\"\n             | \"sigaltstack\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"sigaction\"\n             | \"mprotect\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[_, _, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n             // Platform-specific shims\n             _ => {\n                 match this.tcx.sess.target.os.as_str() {\n-                    \"linux\" => return shims::posix::linux::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest, ret),\n-                    \"macos\" => return shims::posix::macos::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest, ret),\n+                    \"linux\" => return shims::posix::linux::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n+                    \"macos\" => return shims::posix::macos::foreign_items::EvalContextExt::emulate_foreign_item_by_name(this, link_name, abi, args, dest, ret),\n                     _ => unreachable!(),\n                 }\n             }"}, {"sha": "fe989b5924dfdea874642581a655a75b75171dfe", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=80d6b569547cfb14e6fd8671599da205f7860652", "patch": "@@ -1,7 +1,8 @@\n use rustc_middle::mir;\n+use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use crate::helpers::check_arg_count;\n+use crate::helpers::{check_abi, check_arg_count};\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::linux::sync::futex;\n use shims::posix::sync::EvalContextExt as _;\n@@ -12,6 +13,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: &str,\n+        abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n@@ -21,6 +23,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__errno_location\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n@@ -30,27 +33,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref len, ref advice] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n@@ -60,13 +68,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref nbytes, ref flags] = check_arg_count(args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a POSIX function but it has only been tested on linux.\n                 let &[ref clk_id, ref tp] = check_arg_count(args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n@@ -75,6 +85,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n                 let &[ref attr_place, ref addr_place, ref size_place] = check_arg_count(args)?;\n                 this.deref_operand(attr_place)?;\n@@ -96,23 +107,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] = check_arg_count(args)?;\n                 let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n                 // extra arguments are simply ignored. However, all arguments need to be scalars;\n                 // other types might be treated differently by the calling convention.\n@@ -167,10 +182,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref pid, ref cpusetsize, ref mask] = check_arg_count(args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n@@ -184,6 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_getattr_np\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref _thread, ref _attr] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "dce9eea668e6304401f99e65adc54c2751cdfe2f", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=80d6b569547cfb14e6fd8671599da205f7860652", "patch": "@@ -1,7 +1,8 @@\n use rustc_middle::mir;\n+use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_arg_count;\n+use helpers::{check_abi, check_arg_count};\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::thread::EvalContextExt as _;\n \n@@ -10,6 +11,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: &str,\n+        abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n@@ -19,84 +21,99 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__error\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref result] = check_arg_count(args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n             }\n \n             // Time related shims\n             \"gettimeofday\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref tv, ref tz] = check_arg_count(args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref info] = check_arg_count(args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             },\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref dtor, ref data] = check_arg_count(args)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n@@ -107,12 +124,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n@@ -121,6 +140,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"pthread_setname_np\" => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.check_init()?;\n                 this.pthread_setname_np(name)?;\n@@ -129,6 +149,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n                 let &[ref addr, _, _, _, _, _] = check_arg_count(args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;"}, {"sha": "72b776380b99a5cfec5876c956243c62899aebdd", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6b569547cfb14e6fd8671599da205f7860652/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=80d6b569547cfb14e6fd8671599da205f7860652", "patch": "@@ -20,8 +20,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n \n-        check_abi(abi, Abi::System { unwind: false })?;\n-\n         // Windows API stubs.\n         // HANDLE = isize\n         // DWORD = ULONG = u32\n@@ -30,45 +28,53 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref value] = check_arg_count(args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref env_block] = check_arg_count(args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref size, ref buf] = check_arg_count(args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref which] = check_arg_count(args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] = check_arg_count(args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n@@ -104,6 +110,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -113,6 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -121,6 +129,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -132,18 +141,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref error] = check_arg_count(args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref system_info] = check_arg_count(args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n@@ -159,6 +171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"TlsAlloc\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n@@ -167,13 +180,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n@@ -186,6 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n@@ -195,17 +211,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref LPFILETIME] = check_arg_count(args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpPerformanceCount] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpFrequency] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n@@ -214,34 +233,41 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n@@ -256,6 +282,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscellaneous\n             \"SystemFunction036\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 // The actual name of 'RtlGenRandom'\n                 let &[ref ptr, ref len] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n@@ -264,6 +291,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 // `term` needs this, so we fake it.\n                 let &[ref console, ref buffer_info] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -273,6 +301,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"GetConsoleMode\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n                 let &[ref console, ref mode] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -282,6 +311,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n@@ -290,29 +320,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 throw_unsup_format!(\"Miri does not support concurrency on Windows\");\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n             \"AddVectoredExceptionHandler\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _First, ref _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n             \"SetThreadStackGuarantee\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[_StackSizeInBytes] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n@@ -323,6 +358,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"LeaveCriticalSection\"\n             | \"DeleteCriticalSection\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n@@ -332,6 +368,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"TryEnterCriticalSection\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");"}, {"sha": "b7f4d9038ec6192699d552b0092c4ef944f70bca", "filename": "tests/compile-fail/unsupported_foreign_function.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80d6b569547cfb14e6fd8671599da205f7860652/tests%2Fcompile-fail%2Funsupported_foreign_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6b569547cfb14e6fd8671599da205f7860652/tests%2Fcompile-fail%2Funsupported_foreign_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funsupported_foreign_function.rs?ref=80d6b569547cfb14e6fd8671599da205f7860652", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    extern \"Rust\" {\n+        fn foo();\n+    }\n+\n+    unsafe {\n+        foo(); //~ ERROR unsupported operation: can't call foreign function: foo\n+    }\n+}"}]}