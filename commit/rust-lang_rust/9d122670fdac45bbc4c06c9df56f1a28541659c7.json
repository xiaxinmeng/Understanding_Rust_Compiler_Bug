{"sha": "9d122670fdac45bbc4c06c9df56f1a28541659c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMTIyNjcwZmRhYzQ1YmJjNGMwNmM5ZGY1NmYxYTI4NTQxNjU5Yzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-26T16:56:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-26T16:56:41Z"}, "message": "Rollup merge of #62692 - eddyb:precompute-niches, r=oli-obk\n\nrustc: precompute the largest Niche and store it in LayoutDetails.\n\nSince we only ever can use at most one niche, it makes sense to just store that in the layout, for the simplest caching (especially as it's almost trivial to compute).\n\nThere might be a speedup from this, but even if it's marginal now, the caching would be a more significant benefit for future optimization attempts.", "tree": {"sha": "1e30ca5f6a76e41822db62e3682d447102be30c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e30ca5f6a76e41822db62e3682d447102be30c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d122670fdac45bbc4c06c9df56f1a28541659c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOzDKCRBK7hj4Ov3rIwAAdHIIAIgTqp7DbqPIsCC+PP+iJ8Cc\nYazqNkr1zUG6pq4g8TV2EP1ELbZHmESWYWF/8WVrtWTKMLu19gRRvimZF9oclnY/\nFp6LscYKC9mdqYcqwwBLtUXipQCHOSEOq3C7nkM2pjBcpB27hSZQJ//HeGUUsdQZ\njEcVJxMzloOlMFpyvHG+J2CjZqMhTkK27eEv3bH/gjI+/Y0HntA+t015jr0ClJOB\nacnWgF+oYo6OXUQDBGM7SoF5+2jQ8EQNxgQ9xSfVHTRxjCSXG4iGzzPHsP2dvsO8\n/XsgrpaopwPmtvN9Ud5IsaqlCrHxSpC9Nb2wR3d88cfeArsPZEDL8Sc1RzmSmTA=\n=2Lld\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e30ca5f6a76e41822db62e3682d447102be30c2\nparent d1f86c13e4363e981c7d52312d24d00a24f6bd7f\nparent 88eced596199548a7653aaf835cda0a93fec36fd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564160201 +0200\ncommitter GitHub <noreply@github.com> 1564160201 +0200\n\nRollup merge of #62692 - eddyb:precompute-niches, r=oli-obk\n\nrustc: precompute the largest Niche and store it in LayoutDetails.\n\nSince we only ever can use at most one niche, it makes sense to just store that in the layout, for the simplest caching (especially as it's almost trivial to compute).\n\nThere might be a speedup from this, but even if it's marginal now, the caching would be a more significant benefit for future optimization attempts.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d122670fdac45bbc4c06c9df56f1a28541659c7", "html_url": "https://github.com/rust-lang/rust/commit/9d122670fdac45bbc4c06c9df56f1a28541659c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d122670fdac45bbc4c06c9df56f1a28541659c7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f86c13e4363e981c7d52312d24d00a24f6bd7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f86c13e4363e981c7d52312d24d00a24f6bd7f", "html_url": "https://github.com/rust-lang/rust/commit/d1f86c13e4363e981c7d52312d24d00a24f6bd7f"}, {"sha": "88eced596199548a7653aaf835cda0a93fec36fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88eced596199548a7653aaf835cda0a93fec36fd", "html_url": "https://github.com/rust-lang/rust/commit/88eced596199548a7653aaf835cda0a93fec36fd"}], "stats": {"total": 298, "additions": 171, "deletions": 127}, "files": [{"sha": "3b4b814c92a90fff9d37846b58db408df5af67bc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 100, "deletions": 127, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/9d122670fdac45bbc4c06c9df56f1a28541659c7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d122670fdac45bbc4c06c9df56f1a28541659c7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9d122670fdac45bbc4c06c9df56f1a28541659c7", "patch": "@@ -246,13 +246,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n         let b_offset = a.value.size(dl).align_to(b_align.abi);\n         let size = (b_offset + b.value.size(dl)).align_to(align.abi);\n+\n+        // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+        // returns the last maximum.\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b.clone())\n+            .into_iter()\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a.clone()))\n+            .max_by_key(|niche| niche.available(dl));\n+\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1]\n             },\n             abi: Abi::ScalarPair(a, b),\n+            largest_niche,\n             align,\n             size\n         }\n@@ -321,6 +330,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n \n         let mut offset = Size::ZERO;\n+        let mut largest_niche = None;\n+        let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n             let prefix_align = if packed {\n@@ -355,6 +366,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n+            if let Some(mut niche) = field.largest_niche.clone() {\n+                let available = niche.available(dl);\n+                if available > largest_niche_available {\n+                    largest_niche_available = available;\n+                    niche.offset += offset;\n+                    largest_niche = Some(niche);\n+                }\n+            }\n+\n             offset = offset.checked_add(field.size, dl)\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n@@ -466,6 +486,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 memory_index\n             },\n             abi,\n+            largest_niche,\n             align,\n             size\n         })\n@@ -525,6 +546,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -583,13 +605,20 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     Abi::Aggregate { sized: true }\n                 };\n \n+                let largest_niche = if count != 0 {\n+                    element.largest_niche.clone()\n+                } else {\n+                    None\n+                };\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n                     },\n                     abi,\n+                    largest_niche,\n                     align: element.align,\n                     size\n                 })\n@@ -603,6 +632,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: element.align,\n                     size: Size::ZERO\n                 })\n@@ -615,6 +645,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         count: 0\n                     },\n                     abi: Abi::Aggregate { sized: false },\n+                    largest_niche: None,\n                     align: dl.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -683,6 +714,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         element: scalar,\n                         count\n                     },\n+                    largest_niche: element.largest_niche.clone(),\n                     size,\n                     align,\n                 })\n@@ -768,6 +800,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n                         abi,\n+                        largest_niche: None,\n                         align,\n                         size: size.align_to(align.abi)\n                     }));\n@@ -829,14 +862,38 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             // `#[rustc_layout_scalar_valid_range(n)]`\n                             // attribute to widen the range of anything as that would probably\n                             // result in UB somewhere\n+                            // FIXME(eddyb) the asserts are probably not needed,\n+                            // as larger validity ranges would result in missed\n+                            // optimizations, *not* wrongly assuming the inner\n+                            // value is valid. e.g. unions enlarge validity ranges,\n+                            // because the values may be uninitialized.\n                             if let Bound::Included(start) = start {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.start() <= start);\n                                 scalar.valid_range = start..=*scalar.valid_range.end();\n                             }\n                             if let Bound::Included(end) = end {\n+                                // FIXME(eddyb) this might be incorrect - it doesn't\n+                                // account for wrap-around (end < start) ranges.\n                                 assert!(*scalar.valid_range.end() >= end);\n                                 scalar.valid_range = *scalar.valid_range.start()..=end;\n                             }\n+\n+                            // Update `largest_niche` if we have introduced a larger niche.\n+                            let niche = Niche::from_scalar(dl, Size::ZERO, scalar.clone());\n+                            if let Some(niche) = niche {\n+                                match &st.largest_niche {\n+                                    Some(largest_niche) => {\n+                                        // Replace the existing niche even if they're equal,\n+                                        // because this one is at a lower offset.\n+                                        if largest_niche.available(dl) <= niche.available(dl) {\n+                                            st.largest_niche = Some(niche);\n+                                        }\n+                                    }\n+                                    None => st.largest_niche = Some(niche),\n+                                }\n+                            }\n                         }\n                         _ => assert!(\n                             start == Bound::Unbounded && end == Bound::Unbounded,\n@@ -845,6 +902,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             st,\n                         ),\n                     }\n+\n                     return Ok(tcx.intern_layout(st));\n                 }\n \n@@ -886,8 +944,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         let count = (\n                             niche_variants.end().as_u32() - niche_variants.start().as_u32() + 1\n                         ) as u128;\n+                        // FIXME(#62691) use the largest niche across all fields,\n+                        // not just the first one.\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n-                            let niche = match self.find_niche(field)? {\n+                            let niche = match &field.largest_niche {\n                                 Some(niche) => niche,\n                                 _ => continue,\n                             };\n@@ -937,6 +997,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 abi = Abi::Uninhabited;\n                             }\n \n+\n+                            let largest_niche =\n+                                Niche::from_scalar(dl, offset, niche_scalar.clone());\n+\n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::Multiple {\n                                     discr: niche_scalar,\n@@ -953,6 +1017,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     memory_index: vec![0]\n                                 },\n                                 abi,\n+                                largest_niche,\n                                 size,\n                                 align,\n                             }));\n@@ -1164,6 +1229,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi = Abi::Uninhabited;\n                 }\n \n+                let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Multiple {\n                         discr: tag,\n@@ -1175,6 +1242,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         offsets: vec![Size::ZERO],\n                         memory_index: vec![0]\n                     },\n+                    largest_niche,\n                     abi,\n                     align,\n                     size\n@@ -1332,16 +1400,31 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n         let discr_index = substs.prefix_tys(def_id, tcx).count();\n-        let promoted_tys =\n-            ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n-        let prefix_tys = substs.prefix_tys(def_id, tcx)\n-            .chain(iter::once(substs.discr_ty(tcx)))\n-            .chain(promoted_tys);\n-        let prefix = self.univariant_uninterned(\n+        // FIXME(eddyb) set the correct vaidity range for the discriminant.\n+        let discr_layout = self.layout_of(substs.discr_ty(tcx))?;\n+        let discr = match &discr_layout.abi {\n+            Abi::Scalar(s) => s.clone(),\n+            _ => bug!(),\n+        };\n+        // FIXME(eddyb) wrap each promoted type in `MaybeUninit` so that they\n+        // don't poison the `largest_niche` or `abi` fields of `prefix`.\n+        let promoted_layouts = ineligible_locals.iter()\n+            .map(|local| subst_field(info.field_tys[local]))\n+            .map(|ty| self.layout_of(ty));\n+        let prefix_layouts = substs.prefix_tys(def_id, tcx)\n+            .map(|ty| self.layout_of(ty))\n+            .chain(iter::once(Ok(discr_layout)))\n+            .chain(promoted_layouts)\n+            .collect::<Result<Vec<_>, _>>()?;\n+        let mut prefix = self.univariant_uninterned(\n             ty,\n-            &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+            &prefix_layouts,\n             &ReprOptions::default(),\n-            StructKind::AlwaysSized)?;\n+            StructKind::AlwaysSized,\n+        )?;\n+        // FIXME(eddyb) need `MaybeUninit` around promoted types (see above).\n+        prefix.largest_niche = None;\n+\n         let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n \n         // Split the prefix layout into the \"outer\" fields (upvars and\n@@ -1463,10 +1546,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         } else {\n             Abi::Aggregate { sized: true }\n         };\n-        let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n-            Abi::Scalar(s) => s.clone(),\n-            _ => bug!(),\n-        };\n \n         let layout = tcx.intern_layout(LayoutDetails {\n             variants: Variants::Multiple {\n@@ -1477,6 +1556,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             },\n             fields: outer_fields,\n             abi,\n+            largest_niche: prefix.largest_niche,\n             size,\n             align,\n         });\n@@ -1950,6 +2030,7 @@ where\n                     variants: Variants::Single { index: variant_index },\n                     fields: FieldPlacement::Union(fields),\n                     abi: Abi::Uninhabited,\n+                    largest_niche: None,\n                     align: tcx.data_layout.i8_align,\n                     size: Size::ZERO\n                 })\n@@ -2222,120 +2303,6 @@ where\n     }\n }\n \n-struct Niche {\n-    offset: Size,\n-    scalar: Scalar,\n-    available: u128,\n-}\n-\n-impl Niche {\n-    fn reserve<'tcx>(\n-        &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-        count: u128,\n-    ) -> Option<(u128, Scalar)> {\n-        if count > self.available {\n-            return None;\n-        }\n-        let Scalar { value, valid_range: ref v } = self.scalar;\n-        let bits = value.size(cx).bits();\n-        assert!(bits <= 128);\n-        let max_value = !0u128 >> (128 - bits);\n-        let start = v.end().wrapping_add(1) & max_value;\n-        let end = v.end().wrapping_add(count) & max_value;\n-        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n-    }\n-}\n-\n-impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n-    /// Find the offset of a niche leaf field, starting from\n-    /// the given type and recursing through aggregates.\n-    // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche(&self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n-        let scalar_niche = |scalar: &Scalar, offset| {\n-            let Scalar { value, valid_range: ref v } = *scalar;\n-\n-            let bits = value.size(self).bits();\n-            assert!(bits <= 128);\n-            let max_value = !0u128 >> (128 - bits);\n-\n-            // Find out how many values are outside the valid range.\n-            let available = if v.start() <= v.end() {\n-                v.start() + (max_value - v.end())\n-            } else {\n-                v.start() - v.end() - 1\n-            };\n-\n-            // Give up if there is no niche value available.\n-            if available == 0 {\n-                return None;\n-            }\n-\n-            Some(Niche { offset, scalar: scalar.clone(), available })\n-        };\n-\n-        // Locals variables which live across yields are stored\n-        // in the generator type as fields. These may be uninitialized\n-        // so we don't look for niches there.\n-        if let ty::Generator(..) = layout.ty.sty {\n-            return Ok(None);\n-        }\n-\n-        match layout.abi {\n-            Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_niche(scalar, Size::ZERO));\n-            }\n-            Abi::ScalarPair(ref a, ref b) => {\n-                // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n-                // returns the last maximum.\n-                let niche = iter::once(\n-                    (b, a.value.size(self).align_to(b.value.align(self).abi))\n-                )\n-                    .chain(iter::once((a, Size::ZERO)))\n-                    .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n-                    .max_by_key(|niche| niche.available);\n-                return Ok(niche);\n-            }\n-            Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_niche(element, Size::ZERO));\n-            }\n-            _ => {}\n-        }\n-\n-        // Perhaps one of the fields is non-zero, let's recurse and find out.\n-        if let FieldPlacement::Union(_) = layout.fields {\n-            // Only Rust enums have safe-to-inspect fields\n-            // (a discriminant), other unions are unsafe.\n-            if let Variants::Single { .. } = layout.variants {\n-                return Ok(None);\n-            }\n-        }\n-        if let FieldPlacement::Array { count: original_64_bit_count, .. } = layout.fields {\n-            // rust-lang/rust#57038: avoid ICE within FieldPlacement::count when count too big\n-            if original_64_bit_count > usize::max_value() as u64 {\n-                return Err(LayoutError::SizeOverflow(layout.ty));\n-            }\n-            if layout.fields.count() > 0 {\n-                return self.find_niche(layout.field(self, 0)?);\n-            } else {\n-                return Ok(None);\n-            }\n-        }\n-        let mut niche = None;\n-        let mut available = 0;\n-        for i in 0..layout.fields.count() {\n-            if let Some(mut c) = self.find_niche(layout.field(self, i)?)? {\n-                if c.available > available {\n-                    available = c.available;\n-                    c.offset += layout.fields.offset(i);\n-                    niche = Some(c);\n-                }\n-            }\n-        }\n-        Ok(niche)\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -2456,10 +2423,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     }\n }\n \n+impl_stable_hash_for!(struct crate::ty::layout::Niche {\n+    offset,\n+    scalar\n+});\n+\n impl_stable_hash_for!(struct crate::ty::layout::LayoutDetails {\n     variants,\n     fields,\n     abi,\n+    largest_niche,\n     size,\n     align\n });"}, {"sha": "4a4c6799c005e0f5d35326aeea4b8b8c8ed800c2", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9d122670fdac45bbc4c06c9df56f1a28541659c7/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d122670fdac45bbc4c06c9df56f1a28541659c7/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=9d122670fdac45bbc4c06c9df56f1a28541659c7", "patch": "@@ -878,23 +878,94 @@ pub enum DiscriminantKind {\n     },\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Niche {\n+    pub offset: Size,\n+    pub scalar: Scalar,\n+}\n+\n+impl Niche {\n+    pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n+        let niche = Niche {\n+            offset,\n+            scalar,\n+        };\n+        if niche.available(cx) > 0 {\n+            Some(niche)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+\n+        // Find out how many values are outside the valid range.\n+        let niche = v.end().wrapping_add(1)..*v.start();\n+        niche.end.wrapping_sub(niche.start) & max_value\n+    }\n+\n+    pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n+        assert!(count > 0);\n+\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+\n+        if count > max_value {\n+            return None;\n+        }\n+\n+        // Compute the range of invalid values being reserved.\n+        let start = v.end().wrapping_add(1) & max_value;\n+        let end = v.end().wrapping_add(count) & max_value;\n+\n+        // If the `end` of our range is inside the valid range,\n+        // then we ran out of invalid values.\n+        // FIXME(eddyb) abstract this with a wraparound range type.\n+        let valid_range_contains = |x| {\n+            if v.start() <= v.end() {\n+                *v.start() <= x && x <= *v.end()\n+            } else {\n+                *v.start() <= x || x <= *v.end()\n+            }\n+        };\n+        if valid_range_contains(end) {\n+            return None;\n+        }\n+\n+        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct LayoutDetails {\n     pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n+\n+    /// The leaf scalar with the largest number of invalid values\n+    /// (i.e. outside of its `valid_range`), if it exists.\n+    pub largest_niche: Option<Niche>,\n+\n     pub align: AbiAndPrefAlign,\n     pub size: Size\n }\n \n impl LayoutDetails {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n+        let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar.clone());\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n         LayoutDetails {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldPlacement::Union(0),\n             abi: Abi::Scalar(scalar),\n+            largest_niche,\n             size,\n             align,\n         }"}]}