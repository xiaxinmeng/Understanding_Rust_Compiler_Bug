{"sha": "ddc53f809b89001c08296b5b49fe1fcad1e566d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYzUzZjgwOWI4OTAwMWMwODI5NmI1YjQ5ZmUxZmNhZDFlNTY2ZDU=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-04-04T07:09:56Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-04-04T09:42:32Z"}, "message": "Allow clobbering unsupported registers in asm!\n\nPreviously registers could only be marked as clobbered if the target feature for that register was enabled. This restriction is now removed.", "tree": {"sha": "064fd17eabd790a99427a207b22ac20434c7b598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064fd17eabd790a99427a207b22ac20434c7b598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc53f809b89001c08296b5b49fe1fcad1e566d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc53f809b89001c08296b5b49fe1fcad1e566d5", "html_url": "https://github.com/rust-lang/rust/commit/ddc53f809b89001c08296b5b49fe1fcad1e566d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc53f809b89001c08296b5b49fe1fcad1e566d5/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbd6ec760453b333e86aac106f47fe9132498924", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd6ec760453b333e86aac106f47fe9132498924", "html_url": "https://github.com/rust-lang/rust/commit/cbd6ec760453b333e86aac106f47fe9132498924"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "d5a9d7ee6e3666f3fb3800ddc4afa3f081441611", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ddc53f809b89001c08296b5b49fe1fcad1e566d5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc53f809b89001c08296b5b49fe1fcad1e566d5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=ddc53f809b89001c08296b5b49fe1fcad1e566d5", "patch": "@@ -1499,46 +1499,64 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // previous iteration.\n                 required_features.clear();\n \n-                // Validate register classes against currently enabled target\n-                // features. We check that at least one type is available for\n-                // the current target.\n                 let reg_class = reg.reg_class();\n                 if reg_class == asm::InlineAsmRegClass::Err {\n                     continue;\n                 }\n-                for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                    if let Some(feature) = feature {\n-                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+\n+                // We ignore target feature requirements for clobbers: if the\n+                // feature is disabled then the compiler doesn't care what we\n+                // do with the registers.\n+                //\n+                // Note that this is only possible for explicit register\n+                // operands, which cannot be used in the asm string.\n+                let is_clobber = matches!(\n+                    op,\n+                    hir::InlineAsmOperand::Out {\n+                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n+                        late: _,\n+                        expr: None\n+                    }\n+                );\n+\n+                if !is_clobber {\n+                    // Validate register classes against currently enabled target\n+                    // features. We check that at least one type is available for\n+                    // the current target.\n+                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n+                        if let Some(feature) = feature {\n+                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                                required_features.clear();\n+                                break;\n+                            } else {\n+                                required_features.push(feature);\n+                            }\n+                        } else {\n                             required_features.clear();\n                             break;\n-                        } else {\n-                            required_features.push(feature);\n                         }\n-                    } else {\n-                        required_features.clear();\n-                        break;\n                     }\n-                }\n-                // We are sorting primitive strs here and can use unstable sort here\n-                required_features.sort_unstable();\n-                required_features.dedup();\n-                match &required_features[..] {\n-                    [] => {}\n-                    [feature] => {\n-                        let msg = format!(\n-                            \"register class `{}` requires the `{}` target feature\",\n-                            reg_class.name(),\n-                            feature\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n-                    }\n-                    features => {\n-                        let msg = format!(\n-                            \"register class `{}` requires at least one target feature: {}\",\n-                            reg_class.name(),\n-                            features.join(\", \")\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    required_features.sort_unstable();\n+                    required_features.dedup();\n+                    match &required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one target feature: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n                     }\n                 }\n "}, {"sha": "84b091d8d4d79ec4d15710ad20356a9bd21f658b", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddc53f809b89001c08296b5b49fe1fcad1e566d5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc53f809b89001c08296b5b49fe1fcad1e566d5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=ddc53f809b89001c08296b5b49fe1fcad1e566d5", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug};\n-use rustc_span::{Pos, Span};\n+use rustc_span::{Pos, Span, Symbol};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -125,15 +125,39 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Collect the types of output operands\n         let mut constraints = vec![];\n+        let mut clobbers = vec![];\n         let mut output_types = vec![];\n         let mut op_idx = FxHashMap::default();\n         for (idx, op) in operands.iter().enumerate() {\n             match *op {\n                 InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let is_target_supported = |reg_class: InlineAsmRegClass| {\n+                        for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                            if let Some(feature) = feature {\n+                                if self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                {\n+                                    return true;\n+                                }\n+                            } else {\n+                                // Register class is unconditionally supported\n+                                return true;\n+                            }\n+                        }\n+                        false\n+                    };\n+\n                     let mut layout = None;\n                     let ty = if let Some(ref place) = place {\n                         layout = Some(&place.layout);\n                         llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else if !is_target_supported(reg.reg_class()) {\n+                        // We turn discarded outputs into clobber constraints\n+                        // if the target feature needed by the register class is\n+                        // disabled. This is necessary otherwise LLVM will try\n+                        // to actually allocate a register for the dummy output.\n+                        assert!(matches!(reg, InlineAsmRegOrRegClass::Reg(_)));\n+                        clobbers.push(format!(\"~{}\", reg_to_llvm(reg, None)));\n+                        continue;\n                     } else {\n                         // If the output is discarded, we don't really care what\n                         // type is used. We're just using this to tell LLVM to\n@@ -244,6 +268,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n+        constraints.append(&mut clobbers);\n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n             match asm_arch {\n                 InlineAsmArch::AArch64 | InlineAsmArch::Arm => {"}, {"sha": "f637cdcd2344057c1c6b62edfee93befc38a2098", "filename": "src/test/codegen/asm-target-clobbers.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ddc53f809b89001c08296b5b49fe1fcad1e566d5/src%2Ftest%2Fcodegen%2Fasm-target-clobbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc53f809b89001c08296b5b49fe1fcad1e566d5/src%2Ftest%2Fcodegen%2Fasm-target-clobbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-target-clobbers.rs?ref=ddc53f809b89001c08296b5b49fe1fcad1e566d5", "patch": "@@ -0,0 +1,21 @@\n+// only-x86_64\n+// revisions: base avx512\n+// [avx512]compile-flags: -C target-feature=+avx512f\n+\n+#![crate_type = \"rlib\"]\n+#![feature(asm)]\n+\n+// CHECK-LABEL: @avx512_clobber\n+// base: call void asm sideeffect inteldialect \"\", \"~{xmm31}\"()\n+// avx512: call float asm sideeffect inteldialect \"\", \"=&{xmm31}\"()\n+#[no_mangle]\n+pub unsafe fn avx512_clobber() {\n+    asm!(\"\", out(\"zmm31\") _, options(nostack, nomem, preserves_flags));\n+}\n+\n+// CHECK-LABEL: @eax_clobber\n+// CHECK: call i32 asm sideeffect inteldialect \"\", \"=&{ax}\"()\n+#[no_mangle]\n+pub unsafe fn eax_clobber() {\n+    asm!(\"\", out(\"eax\") _, options(nostack, nomem, preserves_flags));\n+}"}]}