{"sha": "439a513efb77b956ed318cef6a4af421054d29e8", "node_id": "C_kwDOAAsO6NoAKDQzOWE1MTNlZmI3N2I5NTZlZDMxOGNlZjZhNGFmNDIxMDU0ZDI5ZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T18:28:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T18:28:08Z"}, "message": "Auto merge of #12597 - Veykril:completions, r=Veykril\n\nfix: Fix auto-ref completions inserting into wrong locations\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/8058", "tree": {"sha": "15360b009e754fa14b58d3a699a81d4ccd2d7872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15360b009e754fa14b58d3a699a81d4ccd2d7872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439a513efb77b956ed318cef6a4af421054d29e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439a513efb77b956ed318cef6a4af421054d29e8", "html_url": "https://github.com/rust-lang/rust/commit/439a513efb77b956ed318cef6a4af421054d29e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439a513efb77b956ed318cef6a4af421054d29e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fdfa9f0ed47eeb729cd9256d70297eb6ba45011", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdfa9f0ed47eeb729cd9256d70297eb6ba45011", "html_url": "https://github.com/rust-lang/rust/commit/9fdfa9f0ed47eeb729cd9256d70297eb6ba45011"}, {"sha": "8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0", "html_url": "https://github.com/rust-lang/rust/commit/8b078986dc2453f0dbe27f0e77fe8f8a511fe4c0"}], "stats": {"total": 564, "additions": 352, "deletions": 212}, "files": [{"sha": "147563ef103d57aad5dcc46e93e1fa87b5358c28", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -36,9 +36,9 @@ use crate::{\n         const_::render_const,\n         function::{render_fn, render_method},\n         literal::{render_struct_literal, render_variant_lit},\n-        macro_::render_macro,\n+        macro_::{render_macro, render_macro_pat},\n         pattern::{render_struct_pat, render_variant_pat},\n-        render_field, render_path_resolution, render_resolution_simple, render_tuple_field,\n+        render_field, render_path_resolution, render_pattern_resolution, render_tuple_field,\n         type_alias::{render_type_alias, render_type_alias_with_eq},\n         union_literal::render_union_literal,\n         RenderContext,\n@@ -134,10 +134,14 @@ impl Completions {\n         item.add_to(self);\n     }\n \n-    pub(crate) fn add_crate_roots(&mut self, ctx: &CompletionContext) {\n+    pub(crate) fn add_crate_roots(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n+    ) {\n         ctx.process_all_names(&mut |name, res| match res {\n             ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n-                self.add_module(ctx, m, name);\n+                self.add_module(ctx, path_ctx, m, name);\n             }\n             _ => (),\n         });\n@@ -160,25 +164,36 @@ impl Completions {\n         );\n     }\n \n-    pub(crate) fn add_resolution_simple(\n+    pub(crate) fn add_pattern_resolution(\n         &mut self,\n         ctx: &CompletionContext,\n+        pattern_ctx: &PatternContext,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n     ) {\n         if ctx.is_scope_def_hidden(resolution) {\n+            cov_mark::hit!(qualified_path_doc_hidden);\n             return;\n         }\n-        self.add(render_resolution_simple(RenderContext::new(ctx), local_name, resolution).build());\n+        self.add(\n+            render_pattern_resolution(RenderContext::new(ctx), pattern_ctx, local_name, resolution)\n+                .build(),\n+        );\n     }\n \n     pub(crate) fn add_module(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         module: hir::Module,\n         local_name: hir::Name,\n     ) {\n-        self.add_resolution_simple(ctx, local_name, hir::ScopeDef::ModuleDef(module.into()));\n+        self.add_path_resolution(\n+            ctx,\n+            path_ctx,\n+            local_name,\n+            hir::ScopeDef::ModuleDef(module.into()),\n+        );\n     }\n \n     pub(crate) fn add_macro(\n@@ -204,6 +219,29 @@ impl Completions {\n         );\n     }\n \n+    pub(crate) fn add_macro_pat(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        pattern_ctx: &PatternContext,\n+        mac: hir::Macro,\n+        local_name: hir::Name,\n+    ) {\n+        let is_private_editable = match ctx.is_visible(&mac) {\n+            Visible::Yes => false,\n+            Visible::Editable => true,\n+            Visible::No => return,\n+        };\n+        self.add(\n+            render_macro_pat(\n+                RenderContext::new(ctx).private_editable(is_private_editable),\n+                pattern_ctx,\n+                local_name,\n+                mac,\n+            )\n+            .build(),\n+        );\n+    }\n+\n     pub(crate) fn add_function(\n         &mut self,\n         ctx: &CompletionContext,\n@@ -341,6 +379,7 @@ impl Completions {\n     pub(crate) fn add_field(\n         &mut self,\n         ctx: &CompletionContext,\n+        dot_access: &DotAccess,\n         receiver: Option<hir::Name>,\n         field: hir::Field,\n         ty: &hir::Type,\n@@ -352,6 +391,7 @@ impl Completions {\n         };\n         let item = render_field(\n             RenderContext::new(ctx).private_editable(is_private_editable),\n+            dot_access,\n             receiver,\n             field,\n             ty,"}, {"sha": "154c096f4d5982c271394cbdca2dbc9ef232682f", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -95,22 +95,24 @@ pub(crate) fn complete_attribute_path(\n                         acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        acc.add_module(ctx, m, name)\n+                        acc.add_module(ctx, path_ctx, m, name)\n                     }\n                     _ => (),\n                 }\n             }\n             return;\n         }\n         // fresh use tree with leading colon2, only show crate roots\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         // only show modules in a fresh UseTree\n         Qualified::No => {\n             ctx.process_all_names(&mut |name, def| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n                     acc.add_macro(ctx, path_ctx, m, name)\n                 }\n-                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                    acc.add_module(ctx, path_ctx, m, name)\n+                }\n                 _ => (),\n             });\n             acc.add_nameref_keywords_with_colon(ctx);"}, {"sha": "48eb76029ff755734098639c878e73516d37901c", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -35,12 +35,14 @@ pub(crate) fn complete_derive_path(\n                     {\n                         acc.add_macro(ctx, path_ctx, mac, name)\n                     }\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                        acc.add_module(ctx, path_ctx, m, name)\n+                    }\n                     _ => (),\n                 }\n             }\n         }\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         // only show modules in a fresh UseTree\n         Qualified::No => {\n             ctx.process_all_names(&mut |name, def| {\n@@ -51,7 +53,7 @@ pub(crate) fn complete_derive_path(\n                         mac\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        return acc.add_module(ctx, m, name);\n+                        return acc.add_module(ctx, path_ctx, m, name);\n                     }\n                     _ => return,\n                 };"}, {"sha": "bf0bce2198c1083faf44bf0ddb03742e62d82eb4", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext, dot_a\n             acc,\n             ctx,\n             &receiver_ty,\n-            |acc, field, ty| acc.add_field(ctx, None, field, &ty),\n+            |acc, field, ty| acc.add_field(ctx, dot_access, None, field, &ty),\n             |acc, field, ty| acc.add_tuple_field(ctx, None, field, &ty),\n         );\n     }\n@@ -64,7 +64,19 @@ pub(crate) fn complete_undotted_self(\n         acc,\n         ctx,\n         &ty,\n-        |acc, field, ty| acc.add_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n+        |acc, field, ty| {\n+            acc.add_field(\n+                ctx,\n+                &DotAccess {\n+                    receiver: None,\n+                    receiver_ty: None,\n+                    kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },\n+                },\n+                Some(hir::known::SELF_PARAM),\n+                field,\n+                &ty,\n+            )\n+        },\n         |acc, field, ty| acc.add_tuple_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n     );\n     complete_methods(ctx, &ty, |func| {"}, {"sha": "6b36801205af777bf74361ec494ad59b7a265511", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -152,7 +152,7 @@ pub(crate) fn complete_expr_path(\n                 _ => (),\n             }\n         }\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n             acc.add_nameref_keywords_with_colon(ctx);\n             if let Some(adt) ="}, {"sha": "fa8c0eb77ace133979e302fbd73a2df19200b1a4", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -12,7 +12,7 @@ use crate::{\n         CompletionContext, DotAccess, PathCompletionCtx, PathKind, PatternContext, Qualified,\n         TypeLocation,\n     },\n-    render::{render_resolution_with_import, RenderContext},\n+    render::{render_resolution_with_import, render_resolution_with_import_pat, RenderContext},\n };\n \n use super::Completions;\n@@ -149,30 +149,22 @@ pub(crate) fn import_on_the_fly_path(\n pub(crate) fn import_on_the_fly_pat(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    pat_ctx: &PatternContext,\n+    pattern_ctx: &PatternContext,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    if let PatternContext { record_pat: Some(_), .. } = pat_ctx {\n+    if let PatternContext { record_pat: Some(_), .. } = pattern_ctx {\n         return None;\n     }\n \n     let potential_import_name = import_name(ctx);\n     let import_assets = import_assets_for_path(ctx, &potential_import_name, None)?;\n \n-    import_on_the_fly(\n+    import_on_the_fly_pat2(\n         acc,\n         ctx,\n-        &PathCompletionCtx {\n-            has_call_parens: false,\n-            has_macro_bang: false,\n-            qualified: Qualified::No,\n-            parent: None,\n-            kind: crate::context::PathKind::Pat { pat_ctx: pat_ctx.clone() },\n-            has_type_args: false,\n-            use_tree_parent: false,\n-        },\n+        pattern_ctx,\n         import_assets,\n         ctx.original_token.parent()?,\n         potential_import_name,\n@@ -287,6 +279,50 @@ fn import_on_the_fly(\n     Some(())\n }\n \n+fn import_on_the_fly_pat2(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    pattern_ctx: &PatternContext,\n+    import_assets: ImportAssets,\n+    position: SyntaxNode,\n+    potential_import_name: String,\n+) -> Option<()> {\n+    let _p = profile::span(\"import_on_the_fly_pat\").detail(|| potential_import_name.clone());\n+\n+    if ImportScope::find_insert_use_container(&position, &ctx.sema).is_none() {\n+        return None;\n+    }\n+\n+    let ns_filter = |import: &LocatedImport| match import.original_item {\n+        ItemInNs::Macros(mac) => mac.is_fn_like(ctx.db),\n+        ItemInNs::Types(_) => true,\n+        ItemInNs::Values(def) => matches!(def, hir::ModuleDef::Const(_)),\n+    };\n+    let user_input_lowercased = potential_import_name.to_lowercase();\n+\n+    acc.add_all(\n+        import_assets\n+            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .into_iter()\n+            .filter(ns_filter)\n+            .filter(|import| {\n+                !ctx.is_item_hidden(&import.item_to_import)\n+                    && !ctx.is_item_hidden(&import.original_item)\n+            })\n+            .sorted_by_key(|located_import| {\n+                compute_fuzzy_completion_order_key(\n+                    &located_import.import_path,\n+                    &user_input_lowercased,\n+                )\n+            })\n+            .filter_map(|import| {\n+                render_resolution_with_import_pat(RenderContext::new(ctx), pattern_ctx, import)\n+            })\n+            .map(|builder| builder.build()),\n+    );\n+    Some(())\n+}\n+\n fn import_on_the_fly_method(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n@@ -295,7 +331,7 @@ fn import_on_the_fly_method(\n     position: SyntaxNode,\n     potential_import_name: String,\n ) -> Option<()> {\n-    let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.clone());\n+    let _p = profile::span(\"import_on_the_fly_method\").detail(|| potential_import_name.clone());\n \n     if ImportScope::find_insert_use_container(&position, &ctx.sema).is_none() {\n         return None;"}, {"sha": "4a32e0ebf58ba8382e111e247786545eb1fa8117", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn complete_item_list(\n                         acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        acc.add_module(ctx, m, name)\n+                        acc.add_module(ctx, path_ctx, m, name)\n                     }\n                     _ => (),\n                 }\n@@ -55,13 +55,15 @@ pub(crate) fn complete_item_list(\n                 acc.add_keyword(ctx, \"super::\");\n             }\n         }\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No if ctx.qualifier_ctx.none() => {\n             ctx.process_all_names(&mut |name, def| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n                     acc.add_macro(ctx, path_ctx, m, name)\n                 }\n-                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n+                hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n+                    acc.add_module(ctx, path_ctx, m, name)\n+                }\n                 _ => (),\n             });\n             acc.add_nameref_keywords_with_colon(ctx);"}, {"sha": "4ea80a50777c86b41ae1be1c6006494b9dfd372a", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -82,20 +82,7 @@ pub(crate) fn complete_pattern(\n                 hir::ModuleDef::Const(..) => refutable,\n                 hir::ModuleDef::Module(..) => true,\n                 hir::ModuleDef::Macro(mac) if mac.is_fn_like(ctx.db) => {\n-                    return acc.add_macro(\n-                        ctx,\n-                        &PathCompletionCtx {\n-                            has_call_parens: false,\n-                            has_macro_bang: false,\n-                            qualified: Qualified::No,\n-                            parent: None,\n-                            kind: crate::context::PathKind::Pat { pat_ctx: pattern_ctx.clone() },\n-                            has_type_args: false,\n-                            use_tree_parent: false,\n-                        },\n-                        mac,\n-                        name,\n-                    )\n+                    return acc.add_macro_pat(ctx, pattern_ctx, mac, name);\n                 }\n                 _ => false,\n             },\n@@ -116,7 +103,7 @@ pub(crate) fn complete_pattern(\n             | ScopeDef::Unknown => false,\n         };\n         if add_simple_path {\n-            acc.add_resolution_simple(ctx, name, res);\n+            acc.add_pattern_resolution(ctx, pattern_ctx, name, res);\n         }\n     });\n }\n@@ -205,7 +192,7 @@ pub(crate) fn complete_pattern_path(\n             }\n         }\n         // qualifier can only be none here if we are in a TuplePat or RecordPat in which case special characters have to follow the path\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n             ctx.process_all_names(&mut |name, res| {\n                 // FIXME: properly filter here"}, {"sha": "8cef3a70182b090c23e049d8c4ea3fa841e27969", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -3,7 +3,7 @@ use ide_db::SymbolKind;\n use syntax::ast::{self, Expr};\n \n use crate::{\n-    context::{ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n+    context::{DotAccess, DotAccessKind, ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n     CompletionRelevancePostfixMatch, Completions,\n };\n@@ -107,7 +107,17 @@ fn complete_fields(\n     missing_fields: Vec<(hir::Field, hir::Type)>,\n ) {\n     for (field, ty) in missing_fields {\n-        acc.add_field(ctx, None, field, &ty);\n+        acc.add_field(\n+            ctx,\n+            &DotAccess {\n+                receiver: None,\n+                receiver_ty: None,\n+                kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal: false },\n+            },\n+            None,\n+            field,\n+            &ty,\n+        );\n     }\n }\n "}, {"sha": "c5b65d36ae8f9571d8a0dd47db6ff57636188323", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -141,7 +141,7 @@ pub(crate) fn complete_type_path(\n                 _ => (),\n             }\n         }\n-        Qualified::Absolute => acc.add_crate_roots(ctx),\n+        Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n             acc.add_nameref_keywords_with_colon(ctx);\n             if let TypeLocation::TypeBound = location {"}, {"sha": "c98590f1361c00ea84fc34499dfb57d815c13d96", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -89,15 +89,15 @@ pub(crate) fn complete_use_path(\n         // fresh use tree with leading colon2, only show crate roots\n         Qualified::Absolute => {\n             cov_mark::hit!(use_tree_crate_roots_only);\n-            acc.add_crate_roots(ctx);\n+            acc.add_crate_roots(ctx, path_ctx);\n         }\n         // only show modules and non-std enum in a fresh UseTree\n         Qualified::No => {\n             cov_mark::hit!(unqualified_path_selected_only);\n             ctx.process_all_names(&mut |name, res| {\n                 match res {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(module)) => {\n-                        acc.add_module(ctx, module, name);\n+                        acc.add_module(ctx, path_ctx, module, name);\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n                         // exclude prelude enum"}, {"sha": "6621aafe4bd6c2569c762aa80fabe6efbc639df8", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -8,7 +8,7 @@ use crate::{\n pub(crate) fn complete_vis_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &has_in_token: &bool,\n ) {\n     match qualified {\n@@ -23,7 +23,7 @@ pub(crate) fn complete_vis_path(\n             if let Some(next) = next_towards_current {\n                 if let Some(name) = next.name(ctx.db) {\n                     cov_mark::hit!(visibility_qualified);\n-                    acc.add_module(ctx, next, name);\n+                    acc.add_module(ctx, path_ctx, next, name);\n                 }\n             }\n "}, {"sha": "8ea03358aebc0920261e5002d741ec178380a8ab", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -61,6 +61,8 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) qualified: Qualified,\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n+    /// The path of which we are completing the segment\n+    pub(super) path: ast::Path,\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,"}, {"sha": "e13950d56a961789f1d4644ccb418472c178c797", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -556,6 +556,7 @@ impl<'a> CompletionContext<'a> {\n             has_macro_bang: false,\n             qualified: Qualified::No,\n             parent: path.parent_path(),\n+            path: path.clone(),\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n             use_tree_parent: false,"}, {"sha": "2b10dccb8008fd1353dc22ea655cbbcdf9fc35cd", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -6,7 +6,7 @@ use hir::{Documentation, Mutability};\n use ide_db::{imports::import_assets::LocatedImport, SnippetCap, SymbolKind};\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n-use syntax::{SmolStr, TextRange};\n+use syntax::{SmolStr, TextRange, TextSize};\n use text_edit::TextEdit;\n \n use crate::{\n@@ -68,7 +68,7 @@ pub struct CompletionItem {\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n-    ref_match: Option<Mutability>,\n+    ref_match: Option<(Mutability, TextSize)>,\n \n     /// The import data to add to completion's edits.\n     import_to_add: SmallVec<[LocatedImport; 1]>,\n@@ -104,8 +104,8 @@ impl fmt::Debug for CompletionItem {\n             s.field(\"relevance\", &self.relevance);\n         }\n \n-        if let Some(mutability) = &self.ref_match {\n-            s.field(\"ref_match\", &format!(\"&{}\", mutability.as_keyword_for_ref()));\n+        if let Some((mutability, offset)) = &self.ref_match {\n+            s.field(\"ref_match\", &format!(\"&{}@{offset:?}\", mutability.as_keyword_for_ref()));\n         }\n         if self.trigger_call_info {\n             s.field(\"trigger_call_info\", &true);\n@@ -395,14 +395,14 @@ impl CompletionItem {\n         self.trigger_call_info\n     }\n \n-    pub fn ref_match(&self) -> Option<(Mutability, CompletionRelevance)> {\n+    pub fn ref_match(&self) -> Option<(Mutability, TextSize, CompletionRelevance)> {\n         // Relevance of the ref match should be the same as the original\n         // match, but with exact type match set because self.ref_match\n         // is only set if there is an exact type match.\n         let mut relevance = self.relevance;\n         relevance.type_match = Some(CompletionRelevanceTypeMatch::Exact);\n \n-        self.ref_match.map(|mutability| (mutability, relevance))\n+        self.ref_match.map(|(mutability, offset)| (mutability, offset, relevance))\n     }\n \n     pub fn imports_to_add(&self) -> &[LocatedImport] {\n@@ -428,7 +428,7 @@ pub(crate) struct Builder {\n     deprecated: bool,\n     trigger_call_info: bool,\n     relevance: CompletionRelevance,\n-    ref_match: Option<Mutability>,\n+    ref_match: Option<(Mutability, TextSize)>,\n }\n \n impl Builder {\n@@ -548,8 +548,8 @@ impl Builder {\n         self.imports_to_add.push(import_to_add);\n         self\n     }\n-    pub(crate) fn ref_match(&mut self, mutability: Mutability) -> &mut Builder {\n-        self.ref_match = Some(mutability);\n+    pub(crate) fn ref_match(&mut self, mutability: Mutability, offset: TextSize) -> &mut Builder {\n+        self.ref_match = Some((mutability, offset));\n         self\n     }\n }"}, {"sha": "6571e673527dbe2cc14947cfca5e3462f959661d", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 107, "deletions": 66, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -14,12 +14,16 @@ use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{\n     helpers::item_name, imports::import_assets::LocatedImport, RootDatabase, SnippetCap, SymbolKind,\n };\n-use syntax::{SmolStr, SyntaxKind, TextRange};\n+use syntax::{AstNode, SmolStr, SyntaxKind, TextRange};\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind},\n+    context::{DotAccess, PathCompletionCtx, PathKind, PatternContext},\n     item::{Builder, CompletionRelevanceTypeMatch},\n-    render::{function::render_fn, literal::render_variant_lit, macro_::render_macro},\n+    render::{\n+        function::render_fn,\n+        literal::render_variant_lit,\n+        macro_::{render_macro, render_macro_pat},\n+    },\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n };\n /// Interface for data and methods required for items rendering.\n@@ -106,6 +110,7 @@ impl<'a> RenderContext<'a> {\n \n pub(crate) fn render_field(\n     ctx: RenderContext<'_>,\n+    dot_access: &DotAccess,\n     receiver: Option<hir::Name>,\n     field: hir::Field,\n     ty: &hir::Type,\n@@ -130,10 +135,10 @@ pub(crate) fn render_field(\n     if is_keyword && !matches!(name.as_str(), \"self\" | \"crate\" | \"super\" | \"Self\") {\n         item.insert_text(format!(\"r#{}\", name));\n     }\n-    if let Some(_ref_match) = compute_ref_match(ctx.completion, ty) {\n-        // FIXME\n-        // For now we don't properly calculate the edits for ref match\n-        // completions on struct fields, so we've disabled them. See #8058.\n+    if let Some(receiver) = &dot_access.receiver {\n+        if let Some(ref_match) = compute_ref_match(ctx.completion, ty) {\n+            item.ref_match(ref_match, receiver.syntax().text_range().start());\n+        }\n     }\n     item.build()\n }\n@@ -153,21 +158,29 @@ pub(crate) fn render_tuple_field(\n     item.build()\n }\n \n+pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext) -> CompletionItem {\n+    let mut builder =\n+        CompletionItem::new(CompletionItemKind::InferredType, ctx.source_range(), ty_string);\n+    builder.set_relevance(CompletionRelevance { is_definite: true, ..Default::default() });\n+    builder.build()\n+}\n+\n pub(crate) fn render_path_resolution(\n     ctx: RenderContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     local_name: hir::Name,\n     resolution: ScopeDef,\n ) -> Builder {\n-    render_resolution_(ctx, path_ctx, local_name, None, resolution)\n+    render_resolution_path(ctx, path_ctx, local_name, None, resolution)\n }\n \n-pub(crate) fn render_resolution_simple(\n+pub(crate) fn render_pattern_resolution(\n     ctx: RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n     local_name: hir::Name,\n     resolution: ScopeDef,\n ) -> Builder {\n-    render_resolution_simple_(ctx, local_name, None, resolution)\n+    render_resolution_pat(ctx, pattern_ctx, local_name, None, resolution)\n }\n \n pub(crate) fn render_resolution_with_import(\n@@ -176,23 +189,56 @@ pub(crate) fn render_resolution_with_import(\n     import_edit: LocatedImport,\n ) -> Option<Builder> {\n     let resolution = ScopeDef::from(import_edit.original_item);\n-    let local_name = match resolution {\n+    let local_name = scope_def_to_name(resolution, &ctx, &import_edit)?;\n+\n+    Some(render_resolution_path(ctx, path_ctx, local_name, Some(import_edit), resolution))\n+}\n+\n+pub(crate) fn render_resolution_with_import_pat(\n+    ctx: RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n+    import_edit: LocatedImport,\n+) -> Option<Builder> {\n+    let resolution = ScopeDef::from(import_edit.original_item);\n+    let local_name = scope_def_to_name(resolution, &ctx, &import_edit)?;\n+    Some(render_resolution_pat(ctx, pattern_ctx, local_name, Some(import_edit), resolution))\n+}\n+\n+fn scope_def_to_name(\n+    resolution: ScopeDef,\n+    ctx: &RenderContext,\n+    import_edit: &LocatedImport,\n+) -> Option<hir::Name> {\n+    Some(match resolution {\n         ScopeDef::ModuleDef(hir::ModuleDef::Function(f)) => f.name(ctx.completion.db),\n         ScopeDef::ModuleDef(hir::ModuleDef::Const(c)) => c.name(ctx.completion.db)?,\n         ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.original_item)?,\n-    };\n-    Some(render_resolution_(ctx, path_ctx, local_name, Some(import_edit), resolution))\n+    })\n }\n \n-pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext) -> CompletionItem {\n-    let mut builder =\n-        CompletionItem::new(CompletionItemKind::InferredType, ctx.source_range(), ty_string);\n-    builder.set_relevance(CompletionRelevance { is_definite: true, ..Default::default() });\n-    builder.build()\n+fn render_resolution_pat(\n+    ctx: RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n+    local_name: hir::Name,\n+    import_to_add: Option<LocatedImport>,\n+    resolution: ScopeDef,\n+) -> Builder {\n+    let _p = profile::span(\"render_resolution\");\n+    use hir::ModuleDef::*;\n+\n+    match resolution {\n+        ScopeDef::ModuleDef(Macro(mac)) => {\n+            let ctx = ctx.import_to_add(import_to_add);\n+            return render_macro_pat(ctx, pattern_ctx, local_name, mac);\n+        }\n+        _ => (),\n+    }\n+\n+    render_resolution_simple_(ctx, local_name, import_to_add, resolution)\n }\n \n-fn render_resolution_(\n+fn render_resolution_path(\n     ctx: RenderContext<'_>,\n     path_ctx: &PathCompletionCtx,\n     local_name: hir::Name,\n@@ -221,19 +267,12 @@ fn render_resolution_(\n         }\n         _ => (),\n     }\n-    render_resolution_simple_type(ctx, path_ctx, local_name, import_to_add, resolution)\n-}\n \n-fn render_resolution_simple_type(\n-    ctx: RenderContext<'_>,\n-    path_ctx: &PathCompletionCtx,\n-    local_name: hir::Name,\n-    import_to_add: Option<LocatedImport>,\n-    resolution: ScopeDef,\n-) -> Builder {\n+    let completion = ctx.completion;\n     let cap = ctx.snippet_cap();\n-    let db = ctx.completion.db;\n-    let config = ctx.completion.config;\n+    let db = completion.db;\n+    let config = completion.config;\n+\n     let name = local_name.to_smol_str();\n     let mut item = render_resolution_simple_(ctx, local_name, import_to_add, resolution);\n     // Add `<>` for generic types\n@@ -250,6 +289,7 @@ fn render_resolution_simple_type(\n                 }\n                 _ => false,\n             };\n+\n             if has_non_default_type_params {\n                 cov_mark::hit!(inserts_angle_brackets_for_generics);\n                 item.lookup_by(name.clone())\n@@ -259,6 +299,23 @@ fn render_resolution_simple_type(\n             }\n         }\n     }\n+    if let ScopeDef::Local(local) = resolution {\n+        let ty = local.ty(db);\n+        if !ty.is_unknown() {\n+            item.detail(ty.display(db).to_string());\n+        }\n+\n+        item.set_relevance(CompletionRelevance {\n+            type_match: compute_type_match(completion, &ty),\n+            exact_name_match: compute_exact_name_match(completion, &name),\n+            is_local: true,\n+            ..CompletionRelevance::default()\n+        });\n+\n+        if let Some(ref_match) = compute_ref_match(completion, &ty) {\n+            item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n+        }\n+    };\n     item\n }\n \n@@ -269,11 +326,25 @@ fn render_resolution_simple_(\n     resolution: ScopeDef,\n ) -> Builder {\n     let _p = profile::span(\"render_resolution\");\n-    use hir::ModuleDef::*;\n \n     let db = ctx.db();\n     let ctx = ctx.import_to_add(import_to_add);\n-    let kind = match resolution {\n+    let kind = res_to_kind(resolution);\n+\n+    let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.to_smol_str());\n+    item.set_relevance(ctx.completion_relevance())\n+        .set_documentation(scope_def_docs(db, resolution))\n+        .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n+\n+    if let Some(import_to_add) = ctx.import_to_add {\n+        item.add_import(import_to_add);\n+    }\n+    item\n+}\n+\n+fn res_to_kind(resolution: ScopeDef) -> CompletionItemKind {\n+    use hir::ModuleDef::*;\n+    match resolution {\n         ScopeDef::Unknown => CompletionItemKind::UnresolvedReference,\n         ScopeDef::ModuleDef(Function(_)) => CompletionItemKind::SymbolKind(SymbolKind::Function),\n         ScopeDef::ModuleDef(Variant(_)) => CompletionItemKind::SymbolKind(SymbolKind::Variant),\n@@ -299,36 +370,7 @@ fn render_resolution_simple_(\n         ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => {\n             CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n         }\n-    };\n-\n-    let local_name = local_name.to_smol_str();\n-    let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.clone());\n-    item.set_relevance(ctx.completion_relevance());\n-    if let ScopeDef::Local(local) = resolution {\n-        let ty = local.ty(db);\n-        if !ty.is_unknown() {\n-            item.detail(ty.display(db).to_string());\n-        }\n-\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(ctx.completion, &ty),\n-            exact_name_match: compute_exact_name_match(ctx.completion, &local_name),\n-            is_local: true,\n-            ..CompletionRelevance::default()\n-        });\n-\n-        if let Some(ref_match) = compute_ref_match(ctx.completion, &ty) {\n-            item.ref_match(ref_match);\n-        }\n-    };\n-\n-    item.set_documentation(scope_def_docs(db, resolution))\n-        .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n-\n-    if let Some(import_to_add) = ctx.import_to_add {\n-        item.add_import(import_to_add);\n     }\n-    item\n }\n \n fn scope_def_docs(db: &RootDatabase, resolution: ScopeDef) -> Option<hir::Documentation> {\n@@ -455,7 +497,7 @@ mod tests {\n                 let relevance = display_relevance(it.relevance());\n                 items.push(format!(\"{} {} {}\\n\", tag, it.label(), relevance));\n \n-                if let Some((mutability, relevance)) = it.ref_match() {\n+                if let Some((mutability, _offset, relevance)) = it.ref_match() {\n                     let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n                     let relevance = display_relevance(relevance);\n \n@@ -1494,9 +1536,6 @@ impl Foo { fn baz(&self) -> u32 { 0 } }\n fn foo(f: Foo) { let _: &u32 = f.b$0 }\n \"#,\n             &[CompletionItemKind::Method, CompletionItemKind::SymbolKind(SymbolKind::Field)],\n-            // FIXME\n-            // Ideally we'd also suggest &f.bar and &f.baz() as exact\n-            // type matches. See #8058.\n             expect![[r#\"\n                 [\n                     CompletionItem {\n@@ -1507,6 +1546,7 @@ fn foo(f: Foo) { let _: &u32 = f.b$0 }\n                         kind: Method,\n                         lookup: \"baz\",\n                         detail: \"fn(&self) -> u32\",\n+                        ref_match: \"&@96\",\n                     },\n                     CompletionItem {\n                         label: \"bar\",\n@@ -1517,6 +1557,7 @@ fn foo(f: Foo) { let _: &u32 = f.b$0 }\n                             Field,\n                         ),\n                         detail: \"u32\",\n+                        ref_match: \"&@96\",\n                     },\n                 ]\n             \"#]],\n@@ -1525,7 +1566,6 @@ fn foo(f: Foo) { let _: &u32 = f.b$0 }\n \n     #[test]\n     fn qualified_path_ref() {\n-        // disabled right now because it doesn't render correctly, #8058\n         check_kinds(\n             r#\"\n struct S;\n@@ -1554,6 +1594,7 @@ fn main() {\n                         ),\n                         lookup: \"foo\",\n                         detail: \"fn() -> S\",\n+                        ref_match: \"&@92\",\n                     },\n                 ]\n             \"#]],"}, {"sha": "37486e4d93e957747cae252416b5af116af91620", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -4,20 +4,19 @@ use hir::{db::HirDatabase, AsAssocItem, HirDisplay};\n use ide_db::{SnippetCap, SymbolKind};\n use itertools::Itertools;\n use stdx::{format_to, to_lower_snake_case};\n-use syntax::SmolStr;\n+use syntax::{AstNode, SmolStr};\n \n use crate::{\n-    context::{\n-        CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind, Qualified,\n-    },\n+    context::{CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n     CallableSnippets,\n };\n \n-enum FuncKind {\n-    Function,\n-    Method(Option<hir::Name>),\n+#[derive(Debug)]\n+enum FuncKind<'ctx> {\n+    Function(&'ctx PathCompletionCtx),\n+    Method(&'ctx DotAccess, Option<hir::Name>),\n }\n \n pub(crate) fn render_fn(\n@@ -27,29 +26,7 @@ pub(crate) fn render_fn(\n     func: hir::Function,\n ) -> Builder {\n     let _p = profile::span(\"render_fn\");\n-    let func_kind = FuncKind::Function;\n-    let params = match ctx.completion.config.snippet_cap {\n-        Some(_) => {\n-            if !matches!(\n-                path_ctx,\n-                PathCompletionCtx { kind: PathKind::Expr { .. }, has_call_parens: true, .. }\n-                    | PathCompletionCtx { kind: PathKind::Use | PathKind::Type { .. }, .. }\n-            ) {\n-                params(ctx.completion, func, &func_kind, false)\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None,\n-    };\n-    render(\n-        ctx,\n-        local_name,\n-        func,\n-        func_kind,\n-        params,\n-        matches!(path_ctx.qualified, Qualified::With { .. }),\n-    )\n+    render(ctx, local_name, func, FuncKind::Function(path_ctx))\n }\n \n pub(crate) fn render_method(\n@@ -60,32 +37,21 @@ pub(crate) fn render_method(\n     func: hir::Function,\n ) -> Builder {\n     let _p = profile::span(\"render_method\");\n-    let func_kind = FuncKind::Method(receiver);\n-    let params = match ctx.completion.config.snippet_cap {\n-        Some(_) => match dot_access {\n-            DotAccess { kind: DotAccessKind::Method { has_parens: true }, .. } => None,\n-            _ => params(ctx.completion, func, &func_kind, true),\n-        },\n-        _ => None,\n-    };\n-\n-    render(ctx, local_name, func, func_kind, params, false)\n+    render(ctx, local_name, func, FuncKind::Method(dot_access, receiver))\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n     func_kind: FuncKind,\n-    params: Option<(Option<hir::SelfParam>, Vec<hir::Param>)>,\n-    qualified_path: bool,\n ) -> Builder {\n     let db = completion.db;\n \n     let name = local_name.unwrap_or_else(|| func.name(db));\n \n     let call = match &func_kind {\n-        FuncKind::Method(Some(receiver)) => format!(\"{}.{}\", receiver, &name).into(),\n+        FuncKind::Method(_, Some(receiver)) => format!(\"{}.{}\", receiver, &name).into(),\n         _ => name.to_smol_str(),\n     };\n     let mut item = CompletionItem::new(\n@@ -111,11 +77,14 @@ fn render(\n     });\n \n     if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n-        // FIXME For now we don't properly calculate the edits for ref match\n-        // completions on methods or qualified paths, so we've disabled them.\n-        // See #8058.\n-        if matches!(func_kind, FuncKind::Function) && !qualified_path {\n-            item.ref_match(ref_match);\n+        match func_kind {\n+            FuncKind::Function(path_ctx) => {\n+                item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n+            }\n+            FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n+                item.ref_match(ref_match, receiver.syntax().text_range().start());\n+            }\n+            _ => (),\n         }\n     }\n \n@@ -124,12 +93,34 @@ fn render(\n         .detail(detail(db, func))\n         .lookup_by(name.to_smol_str());\n \n-    match completion.config.snippet_cap.zip(params) {\n-        Some((cap, (self_param, params))) => {\n-            add_call_parens(&mut item, completion, cap, call, self_param, params);\n+    match ctx.completion.config.snippet_cap {\n+        Some(cap) => {\n+            let complete_params = match func_kind {\n+                FuncKind::Function(PathCompletionCtx {\n+                    kind: PathKind::Expr { .. },\n+                    has_call_parens: false,\n+                    ..\n+                }) => Some(false),\n+                FuncKind::Method(\n+                    DotAccess {\n+                        kind:\n+                            DotAccessKind::Method { has_parens: false } | DotAccessKind::Field { .. },\n+                        ..\n+                    },\n+                    _,\n+                ) => Some(true),\n+                _ => None,\n+            };\n+            if let Some(has_dot_receiver) = complete_params {\n+                if let Some((self_param, params)) =\n+                    params(ctx.completion, func, &func_kind, has_dot_receiver)\n+                {\n+                    add_call_parens(&mut item, completion, cap, call, self_param, params);\n+                }\n+            }\n         }\n         _ => (),\n-    }\n+    };\n \n     match ctx.import_to_add {\n         Some(import_to_add) => {\n@@ -291,7 +282,7 @@ fn params(\n         }\n     }\n \n-    let self_param = if has_dot_receiver || matches!(func_kind, FuncKind::Method(Some(_))) {\n+    let self_param = if has_dot_receiver || matches!(func_kind, FuncKind::Method(_, Some(_))) {\n         None\n     } else {\n         func.self_param(ctx.db)"}, {"sha": "7b0555d5a4ce62d15c63580dd77089980ed4cccd", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -2,6 +2,7 @@\n \n use hir::{db::HirDatabase, Documentation, HasAttrs, StructKind};\n use ide_db::SymbolKind;\n+use syntax::AstNode;\n \n use crate::{\n     context::{CompletionContext, PathCompletionCtx, PathKind},\n@@ -117,7 +118,7 @@ fn render(\n         ..ctx.completion_relevance()\n     });\n     if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-        item.ref_match(ref_match);\n+        item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n     }\n \n     if let Some(import_to_add) = ctx.import_to_add {"}, {"sha": "ac2091eca981fe8bcb78ff5cf613e366ae7cf9b0", "filename": "crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -5,24 +5,37 @@ use ide_db::SymbolKind;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind},\n+    context::{PathCompletionCtx, PathKind, PatternContext},\n     item::{Builder, CompletionItem},\n     render::RenderContext,\n };\n \n pub(crate) fn render_macro(\n     ctx: RenderContext<'_>,\n-    path_ctx: &PathCompletionCtx,\n+    PathCompletionCtx { kind, has_macro_bang, has_call_parens, .. }: &PathCompletionCtx,\n+\n+    name: hir::Name,\n+    macro_: hir::Macro,\n+) -> Builder {\n+    let _p = profile::span(\"render_macro\");\n+    render(ctx, *kind == PathKind::Use, *has_macro_bang, *has_call_parens, name, macro_)\n+}\n+\n+pub(crate) fn render_macro_pat(\n+    ctx: RenderContext<'_>,\n+    _pattern_ctx: &PatternContext,\n     name: hir::Name,\n     macro_: hir::Macro,\n ) -> Builder {\n     let _p = profile::span(\"render_macro\");\n-    render(ctx, path_ctx, name, macro_)\n+    render(ctx, false, false, false, name, macro_)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n-    PathCompletionCtx { kind, has_macro_bang, has_call_parens, .. }: &PathCompletionCtx,\n+    is_use_path: bool,\n+    has_macro_bang: bool,\n+    has_call_parens: bool,\n     name: hir::Name,\n     macro_: hir::Macro,\n ) -> Builder {\n@@ -39,7 +52,7 @@ fn render(\n     let is_fn_like = macro_.is_fn_like(completion.db);\n     let (bra, ket) = if is_fn_like { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n-    let needs_bang = is_fn_like && *kind != PathKind::Use && !has_macro_bang;\n+    let needs_bang = is_fn_like && !is_use_path && !has_macro_bang;\n \n     let mut item = CompletionItem::new(\n         SymbolKind::from(macro_.kind(completion.db)),"}, {"sha": "8953f1b2fdf7cd5dda28c51075f919ee0a59863e", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -399,6 +399,7 @@ fn foo() {\n \n #[test]\n fn completes_no_delims_if_existing() {\n+    // FIXME: We should not complete functions here\n     check_empty(\n         r#\"\n struct Bar(u32);\n@@ -409,7 +410,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            fn foo()   fn()\n+            fn foo     fn()\n             st Bar\n             bt u32\n             kw crate::\n@@ -427,7 +428,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n-            fn foo()   fn()\n+            fn foo     fn()\n             st Foo\n             bt u32\n             kw crate::"}, {"sha": "cdd152ccf566a600071081936bcb877cd83fb61e", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439a513efb77b956ed318cef6a4af421054d29e8/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=439a513efb77b956ed318cef6a4af421054d29e8", "patch": "@@ -224,6 +224,7 @@ fn completion_item(\n     max_relevance: u32,\n     item: CompletionItem,\n ) {\n+    let insert_replace_support = config.insert_replace_support().then(|| tdpp.position);\n     let mut additional_text_edits = Vec::new();\n \n     // LSP does not allow arbitrary edits in completion, so we have to do a\n@@ -233,7 +234,6 @@ fn completion_item(\n         let source_range = item.source_range();\n         for indel in item.text_edit().iter() {\n             if indel.delete.contains_range(source_range) {\n-                let insert_replace_support = config.insert_replace_support().then(|| tdpp.position);\n                 text_edit = Some(if indel.delete == source_range {\n                     self::completion_text_edit(line_index, insert_replace_support, indel.clone())\n                 } else {\n@@ -254,6 +254,14 @@ fn completion_item(\n         text_edit.unwrap()\n     };\n \n+    let insert_text_format = item.is_snippet().then(|| lsp_types::InsertTextFormat::SNIPPET);\n+    let tags = item.deprecated().then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n+    let command = if item.trigger_call_info() && config.client_commands().trigger_parameter_hints {\n+        Some(command::trigger_parameter_hints())\n+    } else {\n+        None\n+    };\n+\n     let mut lsp_item = lsp_types::CompletionItem {\n         label: item.label().to_string(),\n         detail: item.detail().map(|it| it.to_string()),\n@@ -263,22 +271,14 @@ fn completion_item(\n         additional_text_edits: Some(additional_text_edits),\n         documentation: item.documentation().map(documentation),\n         deprecated: Some(item.deprecated()),\n+        tags,\n+        command,\n+        insert_text_format,\n         ..Default::default()\n     };\n \n     set_score(&mut lsp_item, max_relevance, item.relevance());\n \n-    if item.deprecated() {\n-        lsp_item.tags = Some(vec![lsp_types::CompletionItemTag::DEPRECATED])\n-    }\n-\n-    if item.trigger_call_info() && config.client_commands().trigger_parameter_hints {\n-        lsp_item.command = Some(command::trigger_parameter_hints());\n-    }\n-\n-    if item.is_snippet() {\n-        lsp_item.insert_text_format = Some(lsp_types::InsertTextFormat::SNIPPET);\n-    }\n     if config.completion().enable_imports_on_the_fly {\n         if let imports @ [_, ..] = item.imports_to_add() {\n             let imports: Vec<_> = imports\n@@ -299,18 +299,17 @@ fn completion_item(\n         }\n     }\n \n-    if let Some((mutability, relevance)) = item.ref_match() {\n+    if let Some((mutability, offset, relevance)) = item.ref_match() {\n         let mut lsp_item_with_ref = lsp_item.clone();\n         set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n         lsp_item_with_ref.label =\n             format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n-        if let Some(it) = &mut lsp_item_with_ref.text_edit {\n-            let new_text = match it {\n-                lsp_types::CompletionTextEdit::Edit(it) => &mut it.new_text,\n-                lsp_types::CompletionTextEdit::InsertAndReplace(it) => &mut it.new_text,\n-            };\n-            *new_text = format!(\"&{}{}\", mutability.as_keyword_for_ref(), new_text);\n-        }\n+        lsp_item_with_ref.additional_text_edits.get_or_insert_with(Default::default).push(\n+            self::text_edit(\n+                line_index,\n+                Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n+            ),\n+        );\n \n         acc.push(lsp_item_with_ref);\n     };"}]}