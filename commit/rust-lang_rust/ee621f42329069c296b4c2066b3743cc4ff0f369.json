{"sha": "ee621f42329069c296b4c2066b3743cc4ff0f369", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNjIxZjQyMzI5MDY5YzI5NmI0YzIwNjZiMzc0M2NjNGZmMGYzNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-14T01:10:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-14T01:10:57Z"}, "message": "Auto merge of #59950 - Centril:rollup-hpmr62i, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #59776 (Apply resource-suffix to search-index and source-files scripts as well)\n - #59784 (Suggest importing macros from the crate root)\n - #59812 (Exclude profiler-generated symbols from MSVC __imp_-symbol workaround.)\n - #59874 (Clean up handling of `-Z pgo-gen` commandline option.)\n - #59890 (Don't generate empty json variables)\n - #59911 (Revert \"compile crates under test w/ -Zemit-stack-sizes\")\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "583edd675d7c015afd2548a3f60e5143c1ebadec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/583edd675d7c015afd2548a3f60e5143c1ebadec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee621f42329069c296b4c2066b3743cc4ff0f369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee621f42329069c296b4c2066b3743cc4ff0f369", "html_url": "https://github.com/rust-lang/rust/commit/ee621f42329069c296b4c2066b3743cc4ff0f369", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee621f42329069c296b4c2066b3743cc4ff0f369/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00856722bad5e9d96048319fb41f4b7e249820cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/00856722bad5e9d96048319fb41f4b7e249820cd", "html_url": "https://github.com/rust-lang/rust/commit/00856722bad5e9d96048319fb41f4b7e249820cd"}, {"sha": "a6b8097586efe41b58e15ddb203f63f54a42aa71", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b8097586efe41b58e15ddb203f63f54a42aa71", "html_url": "https://github.com/rust-lang/rust/commit/a6b8097586efe41b58e15ddb203f63f54a42aa71"}], "stats": {"total": 1078, "additions": 880, "deletions": 198}, "files": [{"sha": "a76584093fc760acd40ba40dee4574a9e58973d7", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -187,33 +187,6 @@ fn main() {\n             cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n         }\n \n-        // Build all crates in the `std` facade with `-Z emit-stack-sizes` to add stack usage\n-        // information.\n-        //\n-        // When you use this `-Z` flag with Cargo you get stack usage information on all crates\n-        // compiled from source, and when you are using LTO you also get information on pre-compiled\n-        // crates like `core` and `std`, even if they were not compiled with `-Z emit-stack-sizes`.\n-        // However, there's an exception: `compiler_builtins`. This crate is special and doesn't\n-        // participate in LTO because it's always linked as a separate object file. For this reason\n-        // it's impossible to get stack usage information about `compiler-builtins` using\n-        // `RUSTFLAGS` + Cargo, or `cargo rustc`.\n-        //\n-        // To make the stack usage information of all crates under the `std` facade available to\n-        // Cargo based stack usage analysis tools, in both LTO and non-LTO mode, we compile them\n-        // with the `-Z emit-stack-sizes` flag. The `RUSTC_EMIT_STACK_SIZES` var helps us apply this\n-        // flag only to the crates in the `std` facade. The `-Z` flag is known to currently work\n-        // with targets that produce ELF files so we limit its use flag to those targets.\n-        //\n-        // NOTE(japaric) if this ever causes problem with an LLVM upgrade or any PR feel free to\n-        // remove it or comment it out\n-        if env::var_os(\"RUSTC_EMIT_STACK_SIZES\").is_some()\n-            && (target.contains(\"-linux-\")\n-                || target.contains(\"-none-eabi\")\n-                || target.ends_with(\"-none-elf\"))\n-        {\n-            cmd.arg(\"-Zemit-stack-sizes\");\n-        }\n-\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }"}, {"sha": "66443d472d334718ce0b8bd3d8a05dcf4738139f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -97,8 +97,6 @@ impl Step for Std {\n         let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n-        // compile with `-Z emit-stack-sizes`; see bootstrap/src/rustc.rs for more details\n-        cargo.env(\"RUSTC_EMIT_STACK_SIZES\", \"1\");\n         run_cargo(builder,\n                   &mut cargo,\n                   &libstd_stamp(builder, compiler, target),\n@@ -397,8 +395,6 @@ impl Step for Test {\n         let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n-        // compile with `-Z emit-stack-sizes`; see bootstrap/src/rustc.rs for more details\n-        cargo.env(\"RUSTC_EMIT_STACK_SIZES\", \"1\");\n         run_cargo(builder,\n                   &mut cargo,\n                   &libtest_stamp(builder, compiler, target),"}, {"sha": "7c0eab26b09b633b420fdd1a62144d0b4cc57347", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -113,6 +113,21 @@ impl LinkerPluginLto {\n     }\n }\n \n+#[derive(Clone, PartialEq, Hash)]\n+pub enum PgoGenerate {\n+    Enabled(Option<PathBuf>),\n+    Disabled,\n+}\n+\n+impl PgoGenerate {\n+    pub fn enabled(&self) -> bool {\n+        match *self {\n+            PgoGenerate::Enabled(_) => true,\n+            PgoGenerate::Disabled => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfo {\n     None,\n@@ -826,13 +841,15 @@ macro_rules! options {\n         pub const parse_linker_plugin_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n+        pub const parse_pgo_generate: Option<&str> =\n+            Some(\"an optional path to the profiling data output directory\");\n         pub const parse_merge_functions: Option<&str> =\n             Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, PgoGenerate};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1087,6 +1104,14 @@ macro_rules! options {\n             true\n         }\n \n+        fn parse_pgo_generate(slot: &mut PgoGenerate, v: Option<&str>) -> bool {\n+            *slot = match v {\n+                None => PgoGenerate::Enabled(None),\n+                Some(path) => PgoGenerate::Enabled(Some(PathBuf::from(path))),\n+            };\n+            true\n+        }\n+\n         fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n             match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n                 Some(mergefunc) => *slot = Some(mergefunc),\n@@ -1363,7 +1388,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"extra arguments to prepend to the linker invocation (space separated)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n                      \"insert profiling code\"),\n-    pgo_gen: Option<String> = (None, parse_opt_string, [TRACKED],\n+    pgo_gen: PgoGenerate = (PgoGenerate::Disabled, parse_pgo_generate, [TRACKED],\n         \"Generate PGO profile data, to a given file, or to the default location if it's empty.\"),\n     pgo_use: String = (String::new(), parse_string, [TRACKED],\n         \"Use PGO profile data from the given profile file.\"),\n@@ -1980,7 +2005,7 @@ pub fn build_session_options_and_crate_config(\n         );\n     }\n \n-    if debugging_opts.pgo_gen.is_some() && !debugging_opts.pgo_use.is_empty() {\n+    if debugging_opts.pgo_gen.enabled() && !debugging_opts.pgo_use.is_empty() {\n         early_error(\n             error_format,\n             \"options `-Z pgo-gen` and `-Z pgo-use` are exclusive\",\n@@ -2490,7 +2515,7 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, LinkerPluginLto};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto, PgoGenerate};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2558,6 +2583,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n+    impl_dep_tracking_hash_via_hash!(PgoGenerate);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2625,7 +2651,7 @@ mod tests {\n         build_session_options_and_crate_config,\n         to_crate_config\n     };\n-    use crate::session::config::{LtoCli, LinkerPluginLto};\n+    use crate::session::config::{LtoCli, LinkerPluginLto, PgoGenerate};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n@@ -3124,7 +3150,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.debugging_opts.pgo_gen = Some(String::from(\"abc\"));\n+        opts.debugging_opts.pgo_gen = PgoGenerate::Enabled(None);\n         assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "b15a64c966b1b34376ea4c98ca06f92605922b43", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -104,7 +104,7 @@ pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n \n     // probestack doesn't play nice either with pgo-gen.\n-    if cx.sess().opts.debugging_opts.pgo_gen.is_some() {\n+    if cx.sess().opts.debugging_opts.pgo_gen.enabled() {\n         return;\n     }\n "}, {"sha": "6a3c2adc856188527db92e97cee6230b69eb560e", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -1014,7 +1014,7 @@ fn link_args(cmd: &mut dyn Linker,\n         cmd.build_static_executable();\n     }\n \n-    if sess.opts.debugging_opts.pgo_gen.is_some() {\n+    if sess.opts.debugging_opts.pgo_gen.enabled() {\n         cmd.pgo_gen();\n     }\n "}, {"sha": "d803f10746e3f7c9db6c25b7c88ad60b010bff41", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -13,7 +13,7 @@ use crate::LlvmCodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, run_assembler};\n use rustc_codegen_ssa::traits::*;\n-use rustc::session::config::{self, OutputType, Passes, Lto};\n+use rustc::session::config::{self, OutputType, Passes, Lto, PgoGenerate};\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n@@ -25,7 +25,7 @@ use errors::{Handler, FatalError};\n use std::ffi::{CString, CStr};\n use std::fs;\n use std::io::{self, Write};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::Arc;\n use std::slice;\n@@ -706,10 +706,20 @@ pub unsafe fn with_llvm_pmb(llmod: &llvm::Module,\n         .unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n-    let pgo_gen_path = config.pgo_gen.as_ref().map(|s| {\n-        let s = if s.is_empty() { \"default_%m.profraw\" } else { s };\n-        CString::new(s.as_bytes()).unwrap()\n-    });\n+    let pgo_gen_path = match config.pgo_gen {\n+        PgoGenerate::Enabled(ref opt_dir_path) => {\n+            let path = if let Some(dir_path) = opt_dir_path {\n+                dir_path.join(\"default_%m.profraw\")\n+            } else {\n+                PathBuf::from(\"default_%m.profraw\")\n+            };\n+\n+            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n+        }\n+        PgoGenerate::Disabled => {\n+            None\n+        }\n+    };\n \n     let pgo_use_path = if config.pgo_use.is_empty() {\n         None\n@@ -793,21 +803,31 @@ fn create_msvc_imps(\n     } else {\n         \"\\x01__imp_\"\n     };\n+\n     unsafe {\n         let i8p_ty = Type::i8p_llcx(llcx);\n         let globals = base::iter_globals(llmod)\n             .filter(|&val| {\n                 llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&\n                     llvm::LLVMIsDeclaration(val) == 0\n             })\n-            .map(move |val| {\n+            .filter_map(|val| {\n+                // Exclude some symbols that we know are not Rust symbols.\n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                if ignored(name.to_bytes()) {\n+                    None\n+                } else {\n+                    Some((val, name))\n+                }\n+            })\n+            .map(move |(val, name)| {\n                 let mut imp_name = prefix.as_bytes().to_vec();\n                 imp_name.extend(name.to_bytes());\n                 let imp_name = CString::new(imp_name).unwrap();\n                 (imp_name, val)\n             })\n             .collect::<Vec<_>>();\n+\n         for (imp_name, val) in globals {\n             let imp = llvm::LLVMAddGlobal(llmod,\n                                           i8p_ty,\n@@ -816,4 +836,10 @@ fn create_msvc_imps(\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n         }\n     }\n+\n+    // Use this function to exclude certain symbols from `__imp` generation.\n+    fn ignored(symbol_name: &[u8]) -> bool {\n+        // These are symbols generated by LLVM's profiling instrumentation\n+        symbol_name.starts_with(b\"__llvm_profile_\")\n+    }\n }"}, {"sha": "a55f783df43a372b43294353c813199b5e1f1dcb", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -209,7 +209,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    if tcx.sess.opts.debugging_opts.pgo_gen.is_some() {\n+    if tcx.sess.opts.debugging_opts.pgo_gen.enabled() {\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them."}, {"sha": "4b02425d40d6550f040c403ab797047e0845cec1", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -12,7 +12,8 @@ use rustc_incremental::{copy_cgu_workproducts_to_incr_comp_cache_dir,\n use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n use rustc::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitizer, Lto};\n+use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Lto,\n+                             Sanitizer, PgoGenerate};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -55,7 +56,7 @@ pub struct ModuleConfig {\n     /// Some(level) to optimize binary size, or None to not affect program size.\n     pub opt_size: Option<config::OptLevel>,\n \n-    pub pgo_gen: Option<String>,\n+    pub pgo_gen: PgoGenerate,\n     pub pgo_use: String,\n \n     // Flags indicating which outputs to produce.\n@@ -93,7 +94,7 @@ impl ModuleConfig {\n             opt_level: None,\n             opt_size: None,\n \n-            pgo_gen: None,\n+            pgo_gen: PgoGenerate::Disabled,\n             pgo_use: String::new(),\n \n             emit_no_opt_bc: false,"}, {"sha": "66daa4518bef6becdc8f5ffba921ec7ee2d88c63", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -862,7 +862,7 @@ impl<'a> CrateLoader<'a> {\n \n     fn inject_profiler_runtime(&mut self) {\n         if self.sess.opts.debugging_opts.profile ||\n-            self.sess.opts.debugging_opts.pgo_gen.is_some()\n+            self.sess.opts.debugging_opts.pgo_gen.enabled()\n         {\n             info!(\"loading profiler\");\n "}, {"sha": "931bce91d7d43afe158de1308d053b4d0d8a9cd9", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 297, "deletions": 16, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -4,16 +4,17 @@ use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::session::config::nightly_options;\n-use syntax::ast::{Expr, ExprKind};\n-use syntax::symbol::keywords;\n-use syntax_pos::Span;\n+use rustc::session::{Session, config::nightly_options};\n+use syntax::ast::{Expr, ExprKind, Ident};\n+use syntax::ext::base::MacroKind;\n+use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::{BytePos, Span};\n \n use crate::macros::ParentScope;\n-use crate::resolve_imports::ImportResolver;\n+use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment};\n+            PathSource, Resolver, Segment, Suggestion};\n \n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n@@ -428,7 +429,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n         match (path.get(0), path.get(1)) {\n@@ -463,13 +464,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -487,19 +488,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n                 path,\n-                Some(\n+                vec![\n                     \"`use` statements changed in Rust 2018; read more at \\\n                      <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n                      clarity.html>\".to_string()\n-                ),\n+                ],\n             ))\n         } else {\n             None\n@@ -518,13 +519,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -545,7 +546,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         if path[1].ident.span.rust_2015() {\n             return None;\n         }\n@@ -564,10 +565,290 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n-                return Some((path, None));\n+                return Some((path, Vec::new()));\n             }\n         }\n \n         None\n     }\n+\n+    /// Suggests importing a macro from the root of the crate rather than a module within\n+    /// the crate.\n+    ///\n+    /// ```\n+    /// help: a macro with this name exists at the root of the crate\n+    ///    |\n+    /// LL | use issue_59764::makro;\n+    ///    |     ^^^^^^^^^^^^^^^^^^\n+    ///    |\n+    ///    = note: this could be because a macro annotated with `#[macro_export]` will be exported\n+    ///            at the root of the crate instead of the module where it is defined\n+    /// ```\n+    pub(crate) fn check_for_module_export_macro(\n+        &self,\n+        directive: &'b ImportDirective<'b>,\n+        module: ModuleOrUniformRoot<'b>,\n+        ident: Ident,\n+    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+        let mut crate_module = if let ModuleOrUniformRoot::Module(module) = module {\n+            module\n+        } else {\n+            return None;\n+        };\n+\n+        while let Some(parent) = crate_module.parent {\n+            crate_module = parent;\n+        }\n+\n+        if ModuleOrUniformRoot::same_def(ModuleOrUniformRoot::Module(crate_module), module) {\n+            // Don't make a suggestion if the import was already from the root of the\n+            // crate.\n+            return None;\n+        }\n+\n+        let resolutions = crate_module.resolutions.borrow();\n+        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let binding = resolution.borrow().binding()?;\n+        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+            let module_name = crate_module.kind.name().unwrap();\n+            let import = match directive.subclass {\n+                ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>\n+                    format!(\"{} as {}\", source, target),\n+                _ => format!(\"{}\", ident),\n+            };\n+\n+            let mut corrections: Vec<(Span, String)> = Vec::new();\n+            if !directive.is_nested() {\n+                // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n+                // intermediate segments.\n+                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+            } else {\n+                // Find the binding span (and any trailing commas and spaces).\n+                //   ie. `use a::b::{c, d, e};`\n+                //                      ^^^\n+                let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n+                    self.resolver.session, directive.span, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n+                       found_closing_brace, binding_span);\n+\n+                let mut removal_span = binding_span;\n+                if found_closing_brace {\n+                    // If the binding span ended with a closing brace, as in the below example:\n+                    //   ie. `use a::b::{c, d};`\n+                    //                      ^\n+                    // Then expand the span of characters to remove to include the previous\n+                    // binding's trailing comma.\n+                    //   ie. `use a::b::{c, d};`\n+                    //                    ^^^\n+                    if let Some(previous_span) = extend_span_to_previous_binding(\n+                        self.resolver.session, binding_span,\n+                    ) {\n+                        debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n+                        removal_span = removal_span.with_lo(previous_span.lo());\n+                    }\n+                }\n+                debug!(\"check_for_module_export_macro: removal_span={:?}\", removal_span);\n+\n+                // Remove the `removal_span`.\n+                corrections.push((removal_span, \"\".to_string()));\n+\n+                // Find the span after the crate name and if it has nested imports immediatately\n+                // after the crate name already.\n+                //   ie. `use a::b::{c, d};`\n+                //               ^^^^^^^^^\n+                //   or  `use a::{b, c, d}};`\n+                //               ^^^^^^^^^^^\n+                let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n+                    self.resolver.session, module_name, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n+                       has_nested, after_crate_name);\n+\n+                let source_map = self.resolver.session.source_map();\n+\n+                // Add the import to the start, with a `{` if required.\n+                let start_point = source_map.start_point(after_crate_name);\n+                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n+                    corrections.push((\n+                        start_point,\n+                        if has_nested {\n+                            // In this case, `start_snippet` must equal '{'.\n+                            format!(\"{}{}, \", start_snippet, import)\n+                        } else {\n+                            // In this case, add a `{`, then the moved import, then whatever\n+                            // was there before.\n+                            format!(\"{{{}, {}\", import, start_snippet)\n+                        }\n+                    ));\n+                }\n+\n+                // Add a `};` to the end if nested, matching the `{` added at the start.\n+                if !has_nested {\n+                    corrections.push((source_map.end_point(after_crate_name),\n+                                     \"};\".to_string()));\n+                }\n+            }\n+\n+            let suggestion = Some((\n+                corrections,\n+                String::from(\"a macro with this name exists at the root of the crate\"),\n+                Applicability::MaybeIncorrect,\n+            ));\n+            let note = vec![\n+                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+                 at the root of the crate instead of the module where it is defined\".to_string(),\n+            ];\n+            Some((suggestion, note))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Given a `binding_span` of a binding within a use statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^\n+/// ```\n+///\n+/// then return the span until the next binding or the end of the statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^^^\n+/// ```\n+pub(crate) fn find_span_of_binding_until_next_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    let source_map = sess.source_map();\n+\n+    // Find the span of everything after the binding.\n+    //   ie. `a, e};` or `a};`\n+    let binding_until_end = binding_span.with_hi(use_span.hi());\n+\n+    // Find everything after the binding but not including the binding.\n+    //   ie. `, e};` or `};`\n+    let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n+\n+    // Keep characters in the span until we encounter something that isn't a comma or\n+    // whitespace.\n+    //   ie. `, ` or ``.\n+    //\n+    // Also note whether a closing brace character was encountered. If there\n+    // was, then later go backwards to remove any trailing commas that are left.\n+    let mut found_closing_brace = false;\n+    let after_binding_until_next_binding = source_map.span_take_while(\n+        after_binding_until_end,\n+        |&ch| {\n+            if ch == '}' { found_closing_brace = true; }\n+            ch == ' ' || ch == ','\n+        }\n+    );\n+\n+    // Combine the two spans.\n+    //   ie. `a, ` or `a`.\n+    //\n+    // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n+    let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n+\n+    (found_closing_brace, span)\n+}\n+\n+/// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n+/// binding.\n+///\n+/// ```\n+/// use foo::a::{a, b, c};\n+///               ^^--- binding span\n+///               |\n+///               returned span\n+///\n+/// use foo::{a, b, c};\n+///           --- binding span\n+/// ```\n+pub(crate) fn extend_span_to_previous_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+) -> Option<Span> {\n+    let source_map = sess.source_map();\n+\n+    // `prev_source` will contain all of the source that came before the span.\n+    // Then split based on a command and take the first (ie. closest to our span)\n+    // snippet. In the example, this is a space.\n+    let prev_source = source_map.span_to_prev_source(binding_span).ok()?;\n+\n+    let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n+    let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n+    if prev_comma.len() <= 1 || prev_starting_brace.len() <= 1 {\n+        return None;\n+    }\n+\n+    let prev_comma = prev_comma.first().unwrap();\n+    let prev_starting_brace = prev_starting_brace.first().unwrap();\n+\n+    // If the amount of source code before the comma is greater than\n+    // the amount of source code before the starting brace then we've only\n+    // got one item in the nested item (eg. `issue_52891::{self}`).\n+    if prev_comma.len() > prev_starting_brace.len() {\n+        return None;\n+    }\n+\n+    Some(binding_span.with_lo(BytePos(\n+        // Take away the number of bytes for the characters we've found and an\n+        // extra for the comma.\n+        binding_span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n+    )))\n+}\n+\n+/// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n+/// it is a nested use tree.\n+///\n+/// ```\n+/// use foo::a::{b, c};\n+///          ^^^^^^^^^^ // false\n+///\n+/// use foo::{a, b, c};\n+///          ^^^^^^^^^^ // true\n+///\n+/// use foo::{a, b::{c, d}};\n+///          ^^^^^^^^^^^^^^^ // true\n+/// ```\n+fn find_span_immediately_after_crate_name(\n+    sess: &Session,\n+    module_name: Symbol,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    debug!(\"find_span_immediately_after_crate_name: module_name={:?} use_span={:?}\",\n+           module_name, use_span);\n+    let source_map = sess.source_map();\n+\n+    // Using `use issue_59764::foo::{baz, makro};` as an example throughout..\n+    let mut num_colons = 0;\n+    // Find second colon.. `use issue_59764:`\n+    let until_second_colon = source_map.span_take_while(use_span, |c| {\n+        if *c == ':' { num_colons += 1; }\n+        match c {\n+            ':' if num_colons == 2 => false,\n+            _ => true,\n+        }\n+    });\n+    // Find everything after the second colon.. `foo::{baz, makro};`\n+    let from_second_colon = use_span.with_lo(until_second_colon.hi() + BytePos(1));\n+\n+    let mut found_a_non_whitespace_character = false;\n+    // Find the first non-whitespace character in `from_second_colon`.. `f`\n+    let after_second_colon = source_map.span_take_while(from_second_colon, |c| {\n+        if found_a_non_whitespace_character { return false; }\n+        if !c.is_whitespace() { found_a_non_whitespace_character = true; }\n+        true\n+    });\n+\n+    // Find the first `{` in from_second_colon.. `foo::{`\n+    let next_left_bracket = source_map.span_through_char(from_second_colon, '{');\n+\n+    (next_left_bracket == after_second_colon, from_second_colon)\n }"}, {"sha": "b34786d8f129a0a0cab872a0d2bcda80969410a6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 69, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -50,7 +50,7 @@ use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n-use syntax_pos::{BytePos, Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use log::debug;\n@@ -62,6 +62,7 @@ use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n \n+use error_reporting::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n@@ -138,8 +139,8 @@ impl Ord for BindingError {\n     }\n }\n \n-/// A span, message, replacement text, and applicability.\n-type Suggestion = (Span, String, String, Applicability);\n+/// A vector of spans and replacements, a message and applicability.\n+type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n@@ -389,8 +390,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                            \"failed to resolve: {}\", &label);\n             err.span_label(span, label);\n \n-            if let Some((span, msg, suggestion, applicability)) = suggestion {\n-                err.span_suggestion(span, &msg, suggestion, applicability);\n+            if let Some((suggestions, msg, applicability)) = suggestion {\n+                err.multipart_suggestion(&msg, suggestions, applicability);\n             }\n \n             err\n@@ -1091,6 +1092,16 @@ enum ModuleKind {\n     Def(Def, Name),\n }\n \n+impl ModuleKind {\n+    /// Get name of the module.\n+    pub fn name(&self) -> Option<Name> {\n+        match self {\n+            ModuleKind::Block(..) => None,\n+            ModuleKind::Def(_, name) => Some(*name),\n+        }\n+    }\n+}\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -3770,9 +3781,8 @@ impl<'a> Resolver<'a> {\n                             (\n                                 String::from(\"unresolved import\"),\n                                 Some((\n-                                    ident.span,\n+                                    vec![(ident.span, candidate.path.to_string())],\n                                     String::from(\"a similar path exists\"),\n-                                    candidate.path.to_string(),\n                                     Applicability::MaybeIncorrect,\n                                 )),\n                             )\n@@ -5141,7 +5151,6 @@ impl<'a> Resolver<'a> {\n     ) {\n         assert!(directive.is_nested());\n         let message = \"remove unnecessary import\";\n-        let source_map = self.session.source_map();\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n@@ -5150,73 +5159,24 @@ impl<'a> Resolver<'a> {\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n         //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n \n-        // Find the span of everything after the binding.\n-        //   ie. `a, e};` or `a};`\n-        let binding_until_end = binding_span.with_hi(directive.use_span.hi());\n-\n-        // Find everything after the binding but not including the binding.\n-        //   ie. `, e};` or `};`\n-        let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n-\n-        // Keep characters in the span until we encounter something that isn't a comma or\n-        // whitespace.\n-        //   ie. `, ` or ``.\n-        //\n-        // Also note whether a closing brace character was encountered. If there\n-        // was, then later go backwards to remove any trailing commas that are left.\n-        let mut found_closing_brace = false;\n-        let after_binding_until_next_binding = source_map.span_take_while(\n-            after_binding_until_end,\n-            |&ch| {\n-                if ch == '}' { found_closing_brace = true; }\n-                ch == ' ' || ch == ','\n-            }\n+        let (found_closing_brace, span) = find_span_of_binding_until_next_binding(\n+            self.session, binding_span, directive.use_span,\n         );\n \n-        // Combine the two spans.\n-        //   ie. `a, ` or `a`.\n-        //\n-        // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n-        let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n-\n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Ok(prev_source) = source_map.span_to_prev_source(span) {\n-                // `prev_source` will contain all of the source that came before the span.\n-                // Then split based on a command and take the first (ie. closest to our span)\n-                // snippet. In the example, this is a space.\n-                let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n-                let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n-                if prev_comma.len() > 1 && prev_starting_brace.len() > 1 {\n-                    let prev_comma = prev_comma.first().unwrap();\n-                    let prev_starting_brace = prev_starting_brace.first().unwrap();\n-\n-                    // If the amount of source code before the comma is greater than\n-                    // the amount of source code before the starting brace then we've only\n-                    // got one item in the nested item (eg. `issue_52891::{self}`).\n-                    if prev_comma.len() > prev_starting_brace.len() {\n-                        // So just remove the entire line...\n-                        err.span_suggestion(\n-                            directive.use_span_with_attributes,\n-                            message,\n-                            String::new(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return;\n-                    }\n-\n-                    let span = span.with_lo(BytePos(\n-                        // Take away the number of bytes for the characters we've found and an\n-                        // extra for the comma.\n-                        span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n-                    ));\n-                    err.tool_only_span_suggestion(\n-                        span, message, String::new(), Applicability::MaybeIncorrect,\n-                    );\n-                    return;\n-                }\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(span, message, String::new(),\n+                                              Applicability::MaybeIncorrect);\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates a\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(directive.use_span_with_attributes, message, String::new(),\n+                                    Applicability::MaybeIncorrect);\n             }\n+\n+            return;\n         }\n \n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);"}, {"sha": "62af6e19603c4beeb29a184c5705ab8783857c54", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -145,7 +145,7 @@ pub struct NameResolution<'a> {\n \n impl<'a> NameResolution<'a> {\n     // Returns the binding for the name if it is known or None if it not known.\n-    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+    pub(crate) fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| {\n             if !binding.is_glob_import() ||\n                self.single_imports.is_empty() { Some(binding) } else { None }\n@@ -636,7 +636,7 @@ impl<'a> Resolver<'a> {\n struct UnresolvedImportError {\n     span: Span,\n     label: Option<String>,\n-    note: Option<String>,\n+    note: Vec<String>,\n     suggestion: Option<Suggestion>,\n }\n \n@@ -756,8 +756,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         /// Upper limit on the number of `span_label` messages.\n         const MAX_LABEL_COUNT: usize = 10;\n \n-        let (span, msg, note) = if errors.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string(), None)\n+        let (span, msg) = if errors.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n         } else {\n             let span = MultiSpan::from_spans(\n                 errors\n@@ -766,11 +766,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     .collect(),\n             );\n \n-            let note = errors\n-                .iter()\n-                .filter_map(|(_, err)| err.note.as_ref())\n-                .last();\n-\n             let paths = errors\n                 .iter()\n                 .map(|(path, _)| format!(\"`{}`\", path))\n@@ -782,22 +777,24 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 paths.join(\", \"),\n             );\n \n-            (span, msg, note)\n+            (span, msg)\n         };\n \n         let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n \n-        if let Some(note) = &note {\n-            diag.note(note);\n+        if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n+            for message in note {\n+                diag.note(&message);\n+            }\n         }\n \n         for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n             if let Some(label) = err.label {\n                 diag.span_label(err.span, label);\n             }\n \n-            if let Some((span, msg, suggestion, applicability)) = err.suggestion {\n-                diag.span_suggestion(span, &msg, suggestion, applicability);\n+            if let Some((suggestions, msg, applicability)) = err.suggestion {\n+                diag.multipart_suggestion(&msg, suggestions, applicability);\n             }\n         }\n \n@@ -950,9 +947,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 label: None,\n                                 note,\n                                 suggestion: Some((\n-                                    span,\n+                                    vec![(span, Segment::names_to_string(&suggestion))],\n                                     String::from(\"a similar path exists\"),\n-                                    Segment::names_to_string(&suggestion),\n                                     Applicability::MaybeIncorrect,\n                                 )),\n                             }\n@@ -961,7 +957,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             UnresolvedImportError {\n                                 span,\n                                 label: Some(label),\n-                                note: None,\n+                                note: Vec::new(),\n                                 suggestion,\n                             }\n                         }\n@@ -1006,7 +1002,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         return Some(UnresolvedImportError {\n                             span: directive.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n+                            note: Vec::new(),\n                             suggestion: None,\n                         });\n                     }\n@@ -1114,15 +1110,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     }\n                 });\n \n-                let lev_suggestion =\n-                    find_best_match_for_name(names, &ident.as_str(), None).map(|suggestion| {\n-                        (\n-                            ident.span,\n-                            String::from(\"a similar name exists in the module\"),\n-                            suggestion.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                    });\n+                let lev_suggestion = find_best_match_for_name(names, &ident.as_str(), None)\n+                   .map(|suggestion|\n+                        (vec![(ident.span, suggestion.to_string())],\n+                         String::from(\"a similar name exists in the module\"),\n+                         Applicability::MaybeIncorrect)\n+                    );\n+\n+                let (suggestion, note) = match self.check_for_module_export_macro(\n+                    directive, module, ident,\n+                ) {\n+                    Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n+                    _ => (lev_suggestion, Vec::new()),\n+                };\n \n                 let label = match module {\n                     ModuleOrUniformRoot::Module(module) => {\n@@ -1143,11 +1143,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         }\n                     }\n                 };\n+\n                 Some(UnresolvedImportError {\n                     span: directive.span,\n                     label: Some(label),\n-                    note: None,\n-                    suggestion: lev_suggestion,\n+                    note,\n+                    suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error."}, {"sha": "acf019fd2254dfd52bf7804a66a708bfec525845", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -157,11 +157,11 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n         window.rootPath = \\\"{root_path}\\\";\\\n         window.currentCrate = \\\"{krate}\\\";\\\n     </script>\\\n-    <script src=\\\"{root_path}aliases.js\\\"></script>\\\n+    <script src=\\\"{root_path}aliases{suffix}.js\\\"></script>\\\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n     {static_extra_scripts}\\\n     {extra_scripts}\\\n-    <script defer src=\\\"{root_path}search-index.js\\\"></script>\\\n+    <script defer src=\\\"{root_path}search-index{suffix}.js\\\"></script>\\\n </body>\\\n </html>\",\n     css_extension = if css_file_extension {"}, {"sha": "3ee131d8f5c8c6186d063c37545203f2632258b4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -1013,7 +1013,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                 })\n     }\n \n-    let dst = cx.dst.join(\"aliases.js\");\n+    let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n         let mut w = try_err!(File::create(&dst), &dst);\n@@ -1064,11 +1064,22 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                                         .expect(\"invalid osstring conversion\")))\n                                       .collect::<Vec<_>>();\n             files.sort_unstable_by(|a, b| a.cmp(b));\n-            // FIXME(imperio): we could avoid to generate \"dirs\" and \"files\" if they're empty.\n-            format!(\"{{\\\"name\\\":\\\"{name}\\\",\\\"dirs\\\":[{subs}],\\\"files\\\":[{files}]}}\",\n+            let subs = subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\");\n+            let dirs = if subs.is_empty() {\n+                String::new()\n+            } else {\n+                format!(\",\\\"dirs\\\":[{}]\", subs)\n+            };\n+            let files = files.join(\",\");\n+            let files = if files.is_empty() {\n+                String::new()\n+            } else {\n+                format!(\",\\\"files\\\":[{}]\", files)\n+            };\n+            format!(\"{{\\\"name\\\":\\\"{name}\\\"{dirs}{files}}}\",\n                     name=self.elem.to_str().expect(\"invalid osstring conversion\"),\n-                    subs=subs.iter().map(|s| s.to_json_string()).collect::<Vec<_>>().join(\",\"),\n-                    files=files.join(\",\"))\n+                    dirs=dirs,\n+                    files=files)\n         }\n     }\n \n@@ -1099,7 +1110,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             }\n         }\n \n-        let dst = cx.dst.join(\"source-files.js\");\n+        let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n         let (mut all_sources, _krates, _) = try_err!(collect(&dst, &krate.name, \"sourcesIndex\",\n                                                              false),\n                                                      &dst);\n@@ -1115,7 +1126,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     }\n \n     // Update the search index\n-    let dst = cx.dst.join(\"search-index.js\");\n+    let dst = cx.dst.join(&format!(\"search-index{}.js\", cx.shared.resource_suffix));\n     let (mut all_indexes, mut krates, variables) = try_err!(collect(&dst,\n                                                                     &krate.name,\n                                                                     \"searchIndex\",\n@@ -1483,7 +1494,7 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n             resource_suffix: &self.scx.resource_suffix,\n-            extra_scripts: &[\"source-files\"],\n+            extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n             static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n         };\n         layout::render(&mut w, &self.scx.layout,"}, {"sha": "567022b4139adaf7b97c9f203d0ac734b89d39c1", "filename": "src/librustdoc/html/static/source-script.js", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fsource-script.js?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -39,28 +39,32 @@ function createDirEntry(elem, parent, fullPath, currentFile, hasFoundFile) {\n     children.className = \"children\";\n     var folders = document.createElement(\"div\");\n     folders.className = \"folders\";\n-    for (var i = 0; i < elem.dirs.length; ++i) {\n-        if (createDirEntry(elem.dirs[i], folders, fullPath, currentFile,\n-                           hasFoundFile) === true) {\n-            addClass(name, \"expand\");\n-            hasFoundFile = true;\n+    if (elem.dirs) {\n+        for (var i = 0; i < elem.dirs.length; ++i) {\n+            if (createDirEntry(elem.dirs[i], folders, fullPath, currentFile,\n+                               hasFoundFile) === true) {\n+                addClass(name, \"expand\");\n+                hasFoundFile = true;\n+            }\n         }\n     }\n     children.appendChild(folders);\n \n     var files = document.createElement(\"div\");\n     files.className = \"files\";\n-    for (i = 0; i < elem.files.length; ++i) {\n-        var file = document.createElement(\"a\");\n-        file.innerText = elem.files[i];\n-        file.href = window.rootPath + \"src/\" + fullPath + elem.files[i] + \".html\";\n-        if (hasFoundFile === false &&\n-                currentFile === fullPath + elem.files[i]) {\n-            file.className = \"selected\";\n-            addClass(name, \"expand\");\n-            hasFoundFile = true;\n+    if (elem.files) {\n+        for (i = 0; i < elem.files.length; ++i) {\n+            var file = document.createElement(\"a\");\n+            file.innerText = elem.files[i];\n+            file.href = window.rootPath + \"src/\" + fullPath + elem.files[i] + \".html\";\n+            if (hasFoundFile === false &&\n+                    currentFile === fullPath + elem.files[i]) {\n+                file.className = \"selected\";\n+                addClass(name, \"expand\");\n+                hasFoundFile = true;\n+            }\n+            files.appendChild(file);\n         }\n-        files.appendChild(file);\n     }\n     search.fullPath = fullPath;\n     children.appendChild(files);"}, {"sha": "7c19961b1e420b3b1f2cb29f619e1c09e5c8a2af", "filename": "src/test/run-make-fulldeps/pgo-gen-lto/Makefile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -1,10 +1,8 @@\n -include ../tools.mk\n \n-# ignore-windows\n-\n all:\n ifeq ($(PROFILER_SUPPORT),1)\n-\t$(RUSTC) -Copt-level=3 -Clto=fat -Z pgo-gen=\"$(TMPDIR)/test.profraw\" test.rs\n+\t$(RUSTC) -Copt-level=3 -Clto=fat -Z pgo-gen=\"$(TMPDIR)\" test.rs\n \t$(call RUN,test) || exit 1\n-\t[ -e \"$(TMPDIR)/test.profraw\" ] || (echo \"No .profraw file\"; exit 1)\n+\t[ -e \"$(TMPDIR)\"/default_*.profraw ] || (echo \"No .profraw file\"; exit 1)\n endif"}, {"sha": "dc52e91317a5ae1b7c678171560c1321e67c81a1", "filename": "src/test/run-make-fulldeps/pgo-gen-no-imp-symbols/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+all:\n+ifeq ($(PROFILER_SUPPORT),1)\n+\t$(RUSTC) -O -Ccodegen-units=1 -Z pgo-gen=\"$(TMPDIR)/test.profraw\" --emit=llvm-ir test.rs\n+\t# We expect symbols starting with \"__llvm_profile_\".\n+\t$(CGREP) \"__llvm_profile_\" < $(TMPDIR)/test.ll\n+\t# We do NOT expect the \"__imp_\" version of these symbols.\n+\t$(CGREP) -v \"__imp___llvm_profile_\" < $(TMPDIR)/test.ll # 64 bit\n+\t$(CGREP) -v \"__imp____llvm_profile_\" < $(TMPDIR)/test.ll # 32 bit\n+endif"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/run-make-fulldeps/pgo-gen-no-imp-symbols/test.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2Ftest.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -0,0 +1 @@\n+fn main() {}"}, {"sha": "0469c4443d85aa0ccadb57cf0f8c671386db9801", "filename": "src/test/run-make-fulldeps/pgo-gen/Makefile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -1,10 +1,8 @@\n -include ../tools.mk\n \n-# ignore-windows\n-\n all:\n ifeq ($(PROFILER_SUPPORT),1)\n-\t$(RUSTC) -g -Z pgo-gen=\"$(TMPDIR)/test.profraw\" test.rs\n+\t$(RUSTC) -g -Z pgo-gen=\"$(TMPDIR)\" test.rs\n \t$(call RUN,test) || exit 1\n-\t[ -e \"$(TMPDIR)/test.profraw\" ] || (echo \"No .profraw file\"; exit 1)\n+\t[ -e \"$(TMPDIR)\"/default_*.profraw ] || (echo \"No .profraw file\"; exit 1)\n endif"}, {"sha": "a92eed968d0607b7a1e1e0f81f0e43cc3e2ec79f", "filename": "src/test/ui/auxiliary/issue-59764.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -0,0 +1,18 @@\n+pub mod foo {\n+    #[macro_export]\n+    macro_rules! makro {\n+        ($foo:ident) => {\n+            fn $foo() { }\n+        }\n+    }\n+\n+    pub fn baz() {}\n+\n+    pub fn foobar() {}\n+\n+    pub mod barbaz {\n+        pub fn barfoo() {}\n+    }\n+}\n+\n+pub fn foobaz() {}"}, {"sha": "09dee8c2732681e4f2298b3a1a51b58872c5ee9d", "filename": "src/test/ui/issue-59764.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.rs?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -0,0 +1,136 @@\n+// aux-build:issue-59764.rs\n+// compile-flags:--extern issue_59764\n+// edition:2018\n+\n+#![allow(warnings)]\n+\n+// This tests the suggestion to import macros from the root of a crate. This aims to capture\n+// the case where a user attempts to import a macro from the definition location instead of the\n+// root of the crate and the macro is annotated with `#![macro_export]`.\n+\n+// Edge cases..\n+\n+mod multiple_imports_same_line_at_end {\n+    use issue_59764::foo::{baz, makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_at_end_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_multiline_at_end {\n+    use issue_59764::foo::{\n+        baz,\n+        makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_same_line_in_middle {\n+    use issue_59764::foo::{baz, makro, foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_in_middle_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar,\n+    };\n+}\n+\n+mod multiple_imports_multiline_in_middle {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar\n+    };\n+}\n+\n+mod nested_imports {\n+    use issue_59764::{foobaz, foo::makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiline_multiple_imports_trailing_comma {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        },\n+    };\n+}\n+\n+mod nested_multiline_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        }\n+    };\n+}\n+\n+mod doubly_nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod doubly_multiline_nested_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+            barbaz::{\n+                barfoo,\n+            }\n+        }\n+    };\n+}\n+\n+mod renamed_import {\n+    use issue_59764::foo::makro as baz;\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod renamed_multiple_imports {\n+    use issue_59764::foo::{baz, makro as foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod lots_of_whitespace {\n+    use\n+        issue_59764::{\n+\n+            foobaz,\n+\n+\n+            foo::{baz,\n+\n+                makro as foobar} //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+\n+        };\n+}\n+\n+// Simple case..\n+\n+use issue_59764::foo::makro;\n+//~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+\n+makro!(bar);\n+//~^ ERROR cannot determine resolution for the macro `makro`\n+\n+fn main() {\n+    bar();\n+    //~^ ERROR cannot find function `bar` in this scope [E0425]\n+}"}, {"sha": "924e69f5f97033fb32a1d9368e62ff71b5cc98ff", "filename": "src/test/ui/issue-59764.stderr", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fissue-59764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee621f42329069c296b4c2066b3743cc4ff0f369/src%2Ftest%2Fui%2Fissue-59764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.stderr?ref=ee621f42329069c296b4c2066b3743cc4ff0f369", "patch": "@@ -0,0 +1,241 @@\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:14:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz}};\n+   |                      ^^^^^^^^^       --^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:21:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:28:9\n+   |\n+LL |         makro\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:33:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro, foobar};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz, foobar}};\n+   |                      ^^^^^^^^^         --      ^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:40:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar,\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:48:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:54:31\n+   |\n+LL |     use issue_59764::{foobaz, foo::makro};\n+   |                               ^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz};\n+   |                      ^^^^^^^      --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:59:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz}};\n+   |                      ^^^^^^^                 --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:68:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:78:13\n+   |\n+LL |             makro\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:84:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz, barbaz::{barfoo}}};\n+   |                      ^^^^^^^                   --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:93:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:102:9\n+   |\n+LL |     use issue_59764::foo::makro as baz;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::makro as baz;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:107:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro as foobar};\n+   |                                 ^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro as foobar, foo::{baz}};\n+   |                      ^^^^^^^^^^^^^^^^^^^       --^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:120:17\n+   |\n+LL |                 makro as foobar}\n+   |                 ^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |         issue_59764::{makro as foobar, \n+LL | \n+LL |             foobaz,\n+LL | \n+LL | \n+LL |             foo::{baz}\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:127:5\n+   |\n+LL | use issue_59764::foo::makro;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL | use issue_59764::makro;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: cannot determine resolution for the macro `makro`\n+  --> $DIR/issue-59764.rs:130:1\n+   |\n+LL | makro!(bar);\n+   | ^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error[E0425]: cannot find function `bar` in this scope\n+  --> $DIR/issue-59764.rs:134:5\n+   |\n+LL |     bar();\n+   |     ^^^ not found in this scope\n+\n+error: aborting due to 18 previous errors\n+\n+Some errors occurred: E0425, E0432.\n+For more information about an error, try `rustc --explain E0425`."}]}