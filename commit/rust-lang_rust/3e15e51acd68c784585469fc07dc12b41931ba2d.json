{"sha": "3e15e51acd68c784585469fc07dc12b41931ba2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTVlNTFhY2Q2OGM3ODQ1ODU0NjlmYzA3ZGMxMmI0MTkzMWJhMmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-03T02:08:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-03T02:08:11Z"}, "message": "Rollup merge of #63678 - Aaron1011:fix/hrtb-leak, r=nikomatsakis\n\nImprove HRTB error span when -Zno-leak-check is used\n\nAs described in #57374, NLL currently produces unhelpful higher-ranked\ntrait bound (HRTB) errors when '-Zno-leak-check' is enabled.\n\nThis PR tackles one half of this issue - making the error message point\nat the proper span. The error message itself is still the very generic\n\"higher-ranked subtype error\", but this can be improved in a follow-up\nPR.\n\nThe root cause of the bad spans lies in how NLL attempts to compute the\n'blamed' region, for which it will retrieve a span for.\nConsider the following code, which (correctly) does not compile:\n\n```rust\nlet my_val: u8 = 25;\nlet a: &u8 = &my_val;\nlet b = a;\nlet c = b;\nlet d: &'static u8 = c;\n```\n\nThis will cause NLL to generate the following subtype constraints:\n\nd :< c\nc :< b\nb <: a\n\nSince normal Rust lifetimes are covariant, this results in the following\nregion constraints (I'm using 'd to denote the lifetime of 'd',\n'c to denote the lifetime of 'c, etc.):\n\n'c: 'd\n'b: 'c\n'a: 'b\n\nFrom this, we can derive that 'a: 'd holds, which implies that 'a: 'static\nmust hold. However, this is not the case, since 'a refers to 'my_val',\nwhich does not outlive the current function.\n\nWhen NLL attempts to infer regions for this code, it will see that the\nregion 'a has grown 'too large' - it will be inferred to outlive\n'static, despite the fact that is not declared as outliving 'static\nWe can find the region responsible, 'd, by starting at the *end* of\nthe 'constraint chain' we generated above. This works because for normal\n(non-higher-ranked) lifetimes, we generally build up a 'chain' of\nlifetime constraints *away* from the original variable/lifetime.\nThat is, our original lifetime 'a is required to outlive progressively\nmore regions. If it ends up living for too long, we can look at the\n'end' of this chain to determine the 'most recent' usage that caused\nthe lifetime to grow too large.\n\nHowever, this logic does not work correctly when higher-ranked trait\nbounds (HRTBs) come into play. This is because HRTBs have\n*contravariance* with respect to their bound regions. For example,\nthis code snippet compiles:\n\n```rust\nlet a: for<'a> fn(&'a ()) = |_| {};\nlet b: fn(&'static ()) = a;\n```\n\nHere, we require that 'a' is a subtype of 'b'. Because of\ncontravariance, we end up with the region constraint 'static: 'a,\n*not* 'a: 'static\n\nThis means that our 'constraint chains' grow in the opposite direction\nof 'normal lifetime' constraint chains. As we introduce subtypes, our\nlifetime ends up being outlived by other lifetimes, rather than\noutliving other lifetimes. Therefore, starting at the end of the\n'constraint chain' will cause us to 'blame' a lifetime close to the original\ndefinition of a variable, instead of close to where the bad lifetime\nconstraint is introduced.\n\nThis PR improves how we select the region to blame for 'too large'\nuniversal lifetimes, when bound lifetimes are involved. If the region\nwe're checking is a 'placeholder' region (e.g. the region 'a' in\nfor<'a>, or the implicit region in fn(&())), we start traversing the\nconstraint chain from the beginning, rather than the end.\n\nThere are two (maybe more) different ways we generate region constraints for NLL:\nrequirements generated from trait queries, and requirements generated\nfrom MIR subtype constraints. While the former always use explicit\nplaceholder regions, the latter is more tricky. In order to implement\ncontravariance for HRTBs, TypeRelating replaces placeholder regions with\nexistential regions. This requires us to keep track of whether or not an\nexistential region was originally a placeholder region. When we look for\na region to blame, we check if our starting region is either a\nplaceholder region or is an existential region created from a\nplaceholder region. If so, we start iterating from the beginning of the\nconstraint chain, rather than the end.", "tree": {"sha": "8371e48699c7926497f7684d90f7c253dfce3d7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8371e48699c7926497f7684d90f7c253dfce3d7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e15e51acd68c784585469fc07dc12b41931ba2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdlVgLCRBK7hj4Ov3rIwAAdHIIAByxA6U4aokNMC7bRL0sVqjP\n3fjq8N3FC9d9ZnheVE9QuSKBVrcXKYWB9rjccRdC0OjX5Z6zx0p/bR54SItwaZsS\nApDMX2wkDp8xgHY+8SMVP8fv5QHsEstz5+mgKsOAcIt+XuKgRETfyRnoF7KSw1eQ\nrx3BtqRKFDH6jcKThPy5kUCUVui98t0QojlqgWmzwXYHJeCU3VNH+ksk0qk2zul3\n5fNrgr//0xIQjaLD7o0XlMm95xOM+7hAH87e5PHGyX8J0BHA8Q4K9s+vo4Pvcl1J\n2NAsYcd9JFNGtjZTksvC6/r3DapjfGNnz0dFhB1CS49U6tGoLroq58dT/wOcTuc=\n=CCJj\n-----END PGP SIGNATURE-----\n", "payload": "tree 8371e48699c7926497f7684d90f7c253dfce3d7a\nparent 2daa404e9a151a2e8262cbd6d8c209fd067aca16\nparent ba54ef8110db16475b19ff9a1eaa46c696fa9584\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570068491 +0200\ncommitter GitHub <noreply@github.com> 1570068491 +0200\n\nRollup merge of #63678 - Aaron1011:fix/hrtb-leak, r=nikomatsakis\n\nImprove HRTB error span when -Zno-leak-check is used\n\nAs described in #57374, NLL currently produces unhelpful higher-ranked\ntrait bound (HRTB) errors when '-Zno-leak-check' is enabled.\n\nThis PR tackles one half of this issue - making the error message point\nat the proper span. The error message itself is still the very generic\n\"higher-ranked subtype error\", but this can be improved in a follow-up\nPR.\n\nThe root cause of the bad spans lies in how NLL attempts to compute the\n'blamed' region, for which it will retrieve a span for.\nConsider the following code, which (correctly) does not compile:\n\n```rust\nlet my_val: u8 = 25;\nlet a: &u8 = &my_val;\nlet b = a;\nlet c = b;\nlet d: &'static u8 = c;\n```\n\nThis will cause NLL to generate the following subtype constraints:\n\nd :< c\nc :< b\nb <: a\n\nSince normal Rust lifetimes are covariant, this results in the following\nregion constraints (I'm using 'd to denote the lifetime of 'd',\n'c to denote the lifetime of 'c, etc.):\n\n'c: 'd\n'b: 'c\n'a: 'b\n\nFrom this, we can derive that 'a: 'd holds, which implies that 'a: 'static\nmust hold. However, this is not the case, since 'a refers to 'my_val',\nwhich does not outlive the current function.\n\nWhen NLL attempts to infer regions for this code, it will see that the\nregion 'a has grown 'too large' - it will be inferred to outlive\n'static, despite the fact that is not declared as outliving 'static\nWe can find the region responsible, 'd, by starting at the *end* of\nthe 'constraint chain' we generated above. This works because for normal\n(non-higher-ranked) lifetimes, we generally build up a 'chain' of\nlifetime constraints *away* from the original variable/lifetime.\nThat is, our original lifetime 'a is required to outlive progressively\nmore regions. If it ends up living for too long, we can look at the\n'end' of this chain to determine the 'most recent' usage that caused\nthe lifetime to grow too large.\n\nHowever, this logic does not work correctly when higher-ranked trait\nbounds (HRTBs) come into play. This is because HRTBs have\n*contravariance* with respect to their bound regions. For example,\nthis code snippet compiles:\n\n```rust\nlet a: for<'a> fn(&'a ()) = |_| {};\nlet b: fn(&'static ()) = a;\n```\n\nHere, we require that 'a' is a subtype of 'b'. Because of\ncontravariance, we end up with the region constraint 'static: 'a,\n*not* 'a: 'static\n\nThis means that our 'constraint chains' grow in the opposite direction\nof 'normal lifetime' constraint chains. As we introduce subtypes, our\nlifetime ends up being outlived by other lifetimes, rather than\noutliving other lifetimes. Therefore, starting at the end of the\n'constraint chain' will cause us to 'blame' a lifetime close to the original\ndefinition of a variable, instead of close to where the bad lifetime\nconstraint is introduced.\n\nThis PR improves how we select the region to blame for 'too large'\nuniversal lifetimes, when bound lifetimes are involved. If the region\nwe're checking is a 'placeholder' region (e.g. the region 'a' in\nfor<'a>, or the implicit region in fn(&())), we start traversing the\nconstraint chain from the beginning, rather than the end.\n\nThere are two (maybe more) different ways we generate region constraints for NLL:\nrequirements generated from trait queries, and requirements generated\nfrom MIR subtype constraints. While the former always use explicit\nplaceholder regions, the latter is more tricky. In order to implement\ncontravariance for HRTBs, TypeRelating replaces placeholder regions with\nexistential regions. This requires us to keep track of whether or not an\nexistential region was originally a placeholder region. When we look for\na region to blame, we check if our starting region is either a\nplaceholder region or is an existential region created from a\nplaceholder region. If so, we start iterating from the beginning of the\nconstraint chain, rather than the end.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e15e51acd68c784585469fc07dc12b41931ba2d", "html_url": "https://github.com/rust-lang/rust/commit/3e15e51acd68c784585469fc07dc12b41931ba2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e15e51acd68c784585469fc07dc12b41931ba2d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2daa404e9a151a2e8262cbd6d8c209fd067aca16", "url": "https://api.github.com/repos/rust-lang/rust/commits/2daa404e9a151a2e8262cbd6d8c209fd067aca16", "html_url": "https://github.com/rust-lang/rust/commit/2daa404e9a151a2e8262cbd6d8c209fd067aca16"}, {"sha": "ba54ef8110db16475b19ff9a1eaa46c696fa9584", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba54ef8110db16475b19ff9a1eaa46c696fa9584", "html_url": "https://github.com/rust-lang/rust/commit/ba54ef8110db16475b19ff9a1eaa46c696fa9584"}], "stats": {"total": 202, "additions": 172, "deletions": 30}, "files": [{"sha": "35db82406ab4681ca993630a8dba1179cfa5b9ca", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -418,15 +418,27 @@ pub enum NLLRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n-    Existential,\n+    Existential {\n+        /// If this is true, then this variable was created to represent a lifetime\n+        /// bound in a `for` binder. For example, it might have been created to\n+        /// represent the lifetime `'a` in a type like `for<'a> fn(&'a u32)`.\n+        /// Such variables are created when we are trying to figure out if there\n+        /// is any valid instantiation of `'a` that could fit into some scenario.\n+        ///\n+        /// This is used to inform error reporting: in the case that we are trying to\n+        /// determine whether there is any valid instantiation of a `'a` variable that meets\n+        /// some constraint C, we want to blame the \"source\" of that `for` type,\n+        /// rather than blaming the source of the constraint C.\n+        from_forall: bool\n+    },\n }\n \n impl NLLRegionVariableOrigin {\n     pub fn is_universal(self) -> bool {\n         match self {\n             NLLRegionVariableOrigin::FreeRegion => true,\n             NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential => false,\n+            NLLRegionVariableOrigin::Existential{ .. } => false,\n         }\n     }\n "}, {"sha": "4649f3f9567e78fb4e3eddcf48eadd3a33c2706f", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -93,7 +93,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+    fn next_existential_region_var(&mut self, was_placeholder: bool) -> ty::Region<'tcx>;\n \n     /// Creates a new region variable representing a\n     /// higher-ranked region that is instantiated universally.\n@@ -193,7 +193,7 @@ where\n                     let placeholder = ty::PlaceholderRegion { universe, name: br };\n                     delegate.next_placeholder_region(placeholder)\n                 } else {\n-                    delegate.next_existential_region_var()\n+                    delegate.next_existential_region_var(true)\n                 }\n             }\n         };"}, {"sha": "a23afd2242cc76e945a1cde4a116683120f80bb5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -97,9 +97,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n+        from_region_origin: NLLRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, bool, Span) {\n-        debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n+        debug!(\"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n+            from_region, from_region_origin);\n \n         // Find all paths\n         let (path, target_region) =\n@@ -152,19 +154,85 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // we still want to screen for an \"interesting\" point to\n         // highlight (e.g., a call site or something).\n         let target_scc = self.constraint_sccs.scc(target_region);\n-        let best_choice = (0..path.len()).rev().find(|&i| {\n-            let constraint = path[i];\n+        let mut range = 0..path.len();\n+\n+        // As noted above, when reporting an error, there is typically a chain of constraints\n+        // leading from some \"source\" region which must outlive some \"target\" region.\n+        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n+        // but there is one exception. When constraints arise from higher-ranked subtyping,\n+        // we generally prefer to blame the source value,\n+        // as the \"target\" in this case tends to be some type annotation that the user gave.\n+        // Therefore, if we find that the region origin is some instantiation\n+        // of a higher-ranked region, we start our search from the \"source\" point\n+        // rather than the \"target\", and we also tweak a few other things.\n+        //\n+        // An example might be this bit of Rust code:\n+        //\n+        // ```rust\n+        // let x: fn(&'static ()) = |_| {};\n+        // let y: for<'a> fn(&'a ()) = x;\n+        // ```\n+        //\n+        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n+        // In particular, the 'static is imposed through a type ascription:\n+        //\n+        // ```rust\n+        // x = ...;\n+        // AscribeUserType(x, fn(&'static ())\n+        // y = x;\n+        // ```\n+        //\n+        // We wind up ultimately with constraints like\n+        //\n+        // ```rust\n+        // !a: 'temp1 // from the `y = x` statement\n+        // 'temp1: 'temp2\n+        // 'temp2: 'static // from the AscribeUserType\n+        // ```\n+        //\n+        // and here we prefer to blame the source (the y = x statement).\n+        let blame_source = match from_region_origin {\n+            NLLRegionVariableOrigin::FreeRegion\n+                | NLLRegionVariableOrigin::Existential { from_forall: false  } => {\n+                    true\n+            }\n+            NLLRegionVariableOrigin::Placeholder(_)\n+                | NLLRegionVariableOrigin::Existential { from_forall: true  } => {\n+                    false\n+            }\n+        };\n+\n+        let find_region = |i: &usize| {\n+            let constraint = path[*i];\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n-            match categorized_path[i].0 {\n-                ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n-                ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n-                ConstraintCategory::TypeAnnotation | ConstraintCategory::Return |\n-                ConstraintCategory::Yield => true,\n-                _ => constraint_sup_scc != target_scc,\n+            if blame_source {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n+                    ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n+                    ConstraintCategory::TypeAnnotation | ConstraintCategory::Return |\n+                    ConstraintCategory::Yield => true,\n+                    _ => constraint_sup_scc != target_scc,\n+                }\n+            } else {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n+                    ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n+                    _ => true\n+                }\n             }\n-        });\n+        };\n+\n+        let best_choice = if blame_source {\n+            range.rev().find(find_region)\n+        } else {\n+            range.find(find_region)\n+        };\n+\n+        debug!(\"best_blame_constraint: best_choice={:?} blame_source={}\",\n+            best_choice, blame_source);\n+\n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n                 if categorized_path[i].0 == ConstraintCategory::Return\n@@ -300,12 +368,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n+        fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n+        let (category, _, span) = self.best_blame_constraint(body, fr, fr_origin, |r| {\n             self.provides_universal_region(r, fr, outlived_fr)\n         });\n \n@@ -712,6 +781,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let (category, from_closure, span) = self.best_blame_constraint(\n             body,\n             borrow_region,\n+            NLLRegionVariableOrigin::FreeRegion,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n \n@@ -771,11 +841,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n+        fr1_origin: NLLRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n         let (category, _, span) = self.best_blame_constraint(\n             body,\n             fr1,\n+            fr1_origin,\n             |r| self.provides_universal_region(r, fr1, fr2),\n         );\n         (category, span)\n@@ -828,7 +900,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential => false,\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n         }\n     }\n }"}, {"sha": "dbb810db555b40769e2de65dca44427f7bb69c24", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -406,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NLLRegionVariableOrigin::Existential => {\n+                NLLRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1348,7 +1348,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n                 }\n \n-                NLLRegionVariableOrigin::Existential => {\n+                NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1461,7 +1461,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n-                    self.find_outlives_blame_span(body, longer_fr, shorter_fr);\n+                    self.find_outlives_blame_span(body, longer_fr,\n+                                                  NLLRegionVariableOrigin::FreeRegion,shorter_fr);\n \n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n@@ -1494,6 +1495,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             infcx,\n             mir_def_id,\n             longer_fr,\n+            NLLRegionVariableOrigin::FreeRegion,\n             shorter_fr,\n             region_naming,\n         );\n@@ -1547,7 +1549,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let (_, span) = self.find_outlives_blame_span(body, longer_fr, error_region);\n+        let (_, span) = self.find_outlives_blame_span(\n+            body, longer_fr, NLLRegionVariableOrigin::Placeholder(placeholder), error_region\n+        );\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --\n@@ -1608,7 +1612,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n \n         let origin = match rv_origin {\n             RegionVariableOrigin::NLL(origin) => origin,\n-            _ => NLLRegionVariableOrigin::Existential,\n+            _ => NLLRegionVariableOrigin::Existential { from_forall: false },\n         };\n \n         Self { origin, universe, external_name: None }"}, {"sha": "315c369716e38f005bad5b602cec465fa3812666", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -35,7 +35,7 @@ where\n     infcx\n         .tcx\n         .fold_regions(value, &mut false, |_region, _depth| {\n-            let origin = NLLRegionVariableOrigin::Existential;\n+            let origin = NLLRegionVariableOrigin::Existential { from_forall: false };\n             infcx.next_nll_region_var(origin)\n         })\n }"}, {"sha": "80bf0478128c792cd9f6d42d8296aba609c24ecc", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -66,9 +66,9 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n         if let Some(_) = &mut self.borrowck_context {\n-            let origin = NLLRegionVariableOrigin::Existential;\n+            let origin = NLLRegionVariableOrigin::Existential { from_forall };\n             self.infcx.next_nll_region_var(origin)\n         } else {\n             self.infcx.tcx.lifetimes.re_erased\n@@ -88,7 +88,9 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n         self.infcx\n-            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, universe)\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential {\n+                from_forall: false\n+            }, universe)\n     }\n \n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {"}, {"sha": "5959c2ea5ca147b90f30bda166af2fdb529510e8", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -65,7 +65,7 @@ impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(&mut self, _was_placeholder: bool) -> ty::Region<'tcx> {\n         self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n     }\n "}, {"sha": "cd1272da2a66ee8102912859c03b7587e33b06f9", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -1,14 +1,20 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:113:18\n+  --> $DIR/issue-30786.rs:108:15\n+   |\n+LL |     let map = source.map(|x: &_| x);\n+   |               ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-30786.rs:114:18\n    |\n LL |     let filter = map.filter(|x: &_| true);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:115:17\n+  --> $DIR/issue-30786.rs:116:17\n    |\n LL |     let count = filter.count(); // Assert that we still have a valid stream.\n    |                 ^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "34d6b19f602f7d60c60caaba7bea48c2c0266c32", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -106,12 +106,14 @@ impl<T> StreamExt for T where for<'a> &'a mut T: Stream { }\n fn main() {\n     let source = Repeat(10);\n     let map = source.map(|x: &_| x);\n-    //[migrate]~^ ERROR implementation of `Stream` is not general enough\n+    //[nll]~^ ERROR higher-ranked subtype error\n+    //[migrate]~^^ ERROR implementation of `Stream` is not general enough\n     //[migrate]~| NOTE  `Stream` would have to be implemented for the type `&'0 mut Map\n     //[migrate]~| NOTE  but `Stream` is actually implemented for the type `&'1\n     //[migrate]~| NOTE  implementation of `Stream` is not general enough\n     let filter = map.filter(|x: &_| true);\n     //[nll]~^ ERROR higher-ranked subtype error\n     let count = filter.count(); // Assert that we still have a valid stream.\n     //[nll]~^ ERROR higher-ranked subtype error\n+\n }"}, {"sha": "ac00627ad00ebfb941165f8fc6bb78ae3d8ce29b", "filename": "src/test/ui/nll/relate_tys/fn-subtype.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -0,0 +1,10 @@\n+// Test that NLL produces correct spans for higher-ranked subtyping errors.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let x: fn(&'static ()) = |_| {};\n+    let y: for<'a> fn(&'a ()) = x; //~ ERROR higher-ranked subtype error\n+}"}, {"sha": "b089b5aaa25354595a30cbc0a657999ba16f96f3", "filename": "src/test/ui/nll/relate_tys/fn-subtype.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/fn-subtype.rs:9:33\n+   |\n+LL |     let y: for<'a> fn(&'a ()) = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "80f31ca6b4782d86baff8223ee9beac9e84bb4cb", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -0,0 +1,16 @@\n+// Test that NLL generates proper error spans for trait HRTB errors\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+trait Foo<'a> {}\n+\n+fn make_foo<'a>() -> Box<dyn Foo<'a>> {\n+    panic!()\n+}\n+\n+fn main() {\n+    let x: Box<dyn Foo<'static>> = make_foo();\n+    let y: Box<dyn for<'a> Foo<'a>> = x; //~ ERROR higher-ranked subtype error\n+}"}, {"sha": "4df2f352522a3e3078a283bf3b0e83ebb233d9ac", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e15e51acd68c784585469fc07dc12b41931ba2d/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr?ref=3e15e51acd68c784585469fc07dc12b41931ba2d", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/trait-hrtb.rs:15:39\n+   |\n+LL |     let y: Box<dyn for<'a> Foo<'a>> = x;\n+   |                                       ^\n+\n+error: aborting due to previous error\n+"}]}